<html>
<head>
<title>Channels in Kotlin — part two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的渠道——第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/channels-in-kotlin-part-two-7d52abbc5b6e?source=collection_archive---------5-----------------------#2020-04-10">https://medium.com/analytics-vidhya/channels-in-kotlin-part-two-7d52abbc5b6e?source=collection_archive---------5-----------------------#2020-04-10</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="23a1" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">协程程序的通信要点</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/f9b60fba7c82a51742d4695fa2d8a4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lOqD_NHM7gQY9Ax9TF4wZg.jpeg"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">泰勒·维克在<a class="ae jo" href="https://unsplash.com/s/photos/cord-organized?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c849" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在<a class="ae jo" rel="noopener" href="/@dahlberg.bob/channels-in-kotlin-part-one-594ba12dcb5a">的上一篇文章</a>中，我们讲述了什么是渠道以及渠道的四种类型。让我们更实际一点，看看什么时候，如何，以及使用渠道的不同方式。</p><h2 id="cd2c" class="kl km hj bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">不是Rx</h2><p id="0d3a" class="pw-post-body-paragraph jp jq hj jr b js lg ik ju jv lh in jx jy li ka kb kc lj ke kf kg lk ki kj kk hc bi translated">首先，我们需要确定与Rx的区别，这样我们就可以专注于渠道，而不是Rx的替代品。要记住的最重要的事情是，一个频道本质上不是在传播它的价值观。一旦接收器从信道获得了某个值，它就被从信道中移除。看一下扇入和扇出的例子，这样会更清楚。</p><h2 id="bb7b" class="kl km hj bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">扇出</h2><p id="8b86" class="pw-post-body-paragraph jp jq hj jr b js lg ik ju jv lh in jx jy li ka kb kc lj ke kf kg lk ki kj kk hc bi translated">先说一个场景。您有一个地址列表，需要对每个地址进行查找，以便从某个网络服务中获得相应的GPS坐标。在这种情况下，按顺序执行并不是最佳选择。所以我们希望<em class="ll">将列表扇出</em>到多个协程，以便能够同时处理几个地址。如果我们从生产端开始，我们需要一个列表并将所有值发送到一个通道。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="7ff8" class="kl km hj ln b fj lr ls l lt lu"><strong class="ln hk">val </strong>channel = <em class="ll">Channel</em>&lt;String&gt;()<br/><strong class="ln hk">val </strong>addresses = <em class="ll">listOf</em>(<br/>    "Fasanv 34, 11111",<br/>    "Publikv 10, 22222",<br/>    ...<br/>)</span><span id="f956" class="kl km hj ln b fj lv ls l lt lu"><em class="ll">launch</em>(Dispatchers.Default) <strong class="ln hk">{ <br/>    </strong>addresses.<em class="ll">forEach </em><strong class="ln hk">{<br/>        </strong>channel.send(<strong class="ln hk">it</strong>)<br/>    <strong class="ln hk">}<br/>    </strong>channel.close()<strong class="ln hk"><br/>}</strong></span></pre><p id="617c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在我们有了一个通道，可以一个接一个地获取所有的地址。正如我们现在所知，它的类型是rendevous，这意味着它将暂停，直到有人收到每个值。接下来，我们使用通道中的地址。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="20e2" class="kl km hj ln b fj lr ls l lt lu"><em class="ll">launch</em>(Dispatchers.Default) <strong class="ln hk">{<br/>    for </strong>(address <strong class="ln hk">in </strong>channel) {<br/>        <strong class="ln hk">val </strong>gps = <em class="ll">fetchCoordinates</em>(address)<br/>        <em class="ll">saveCoordinates</em>(address, gps)<br/>    }<br/><strong class="ln hk">}</strong></span></pre><p id="3667" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在，我们有了完整的流程。我还使用了一个for循环来迭代通道。它为我们处理所有的暂停，当通道关闭时，for循环退出。这是我喜欢Kotlin的微妙之处之一，抽象中的每个构造都是可迭代的，也遵循约定，可以用作语言中的任何其他可迭代的构造。</p><p id="cb1a" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">另一个旁注是，这是我开始真正理解挂起函数和协程的顺序性的地方。在经历了至少15年的不同步回调后，这是一项艰巨的任务。</p><p id="b994" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我跑题了，回到场景，以及如何让它并发。嗯，这就像创建几个协程来做同样的事情一样简单，就像这样。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="85bf" class="kl km hj ln b fj lr ls l lt lu"><em class="ll">repeat</em>(5) <strong class="ln hk">{ </strong><em class="ll">// iterates 5 times -&gt; creating 5 coroutines</em><strong class="ln hk"><br/>    </strong><em class="ll">launch</em>(Dispatchers.Default) <strong class="ln hk">{<br/>        for </strong>(address <strong class="ln hk">in </strong>channel) {<br/>            <strong class="ln hk">val </strong>gps = <em class="ll">fetchCoordinates</em>(address)<br/>            <em class="ll">saveCoordinates</em>(address, gps)<br/>        }<br/>    <strong class="ln hk">}<br/>}</strong></span></pre><p id="a58f" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">当我知道我想要的迭代次数时，我喜欢使用repeat函数而不是for循环，这里我们迭代了五次，从而创建了五个协程。现在，五个不同的协程在同一个通道上迭代，每个都暂停，直到轮到它们接收值。这也是渠道的优势之一。您不必关心同步、线程或永久挂起。即使您只是通过通道发送一个项目，当您关闭通道时，所有五个协程及其对应的五个for循环都将退出。</p><p id="574c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我们还可以使用<em class="ll"> produce- </em>和<em class="ll">consume each</em>-函数来更新代码，使其更加符合通道习惯。这是更新的版本。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="ec2d" class="kl km hj ln b fj lr ls l lt lu"><strong class="ln hk">val </strong>addresses = <em class="ll">listOf</em>(<br/>    "Fasanv 34, 11111",<br/>    "Publikv 10, 22222",<br/>    ...<br/>)</span><span id="8172" class="kl km hj ln b fj lv ls l lt lu"><strong class="ln hk">val </strong>channel = <em class="ll">produce </em><strong class="ln hk">{ <br/>    </strong>addresses.<em class="ll">forEach</em><strong class="ln hk">{ </strong>send(it) <strong class="ln hk">}<br/>}</strong></span><span id="c225" class="kl km hj ln b fj lv ls l lt lu"><em class="ll">repeat</em>(5) <strong class="ln hk">{ </strong><em class="ll">// iterates 5 times -&gt; creating 5 coroutines</em><strong class="ln hk"><br/>    </strong><em class="ll">launch</em>(Dispatchers.Default) <strong class="ln hk">{ <br/>        </strong>channel.<em class="ll">consumeEach </em><strong class="ln hk">{ </strong>address <strong class="ln hk">-&gt;<br/>            val </strong>gps = <em class="ll">fetchCoordinates</em>(address)<br/>            <em class="ll">saveCoordinates</em>(address, gps)<br/>        <strong class="ln hk">}<br/>    }<br/>}</strong></span></pre><p id="57e8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">consumeEach扩展函数几乎与for循环相同，看起来没什么意思。它可能会在未来出现，因为它仍然是一个实验性的API。</p><p id="07aa" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">但是产生的延伸功能是一种美。它所做的是，为我们创建一个新的通道，并将其作为ReceiverChannel返回，它将发送功能封装在produce-function中。在封闭之外，我们只能从通道接收。关闭完成后，生产功能会自动关闭通道。因此，您不会意外地得到一个永不终止的协程和通道。</p><h2 id="1ced" class="kl km hj bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">扇入</h2><p id="1d08" class="pw-post-body-paragraph jp jq hj jr b js lg ik ju jv lh in jx jy li ka kb kc lj ke kf kg lk ki kj kk hc bi translated">毫不奇怪，在通道的帮助下，我们还可以将来自许多不同协程的数据扇入到一个协程中，这就是所谓的扇入。让我们坚持前面的例子，并在此基础上进行构建。我们不想保存坐标，而是希望能够在完成后显示它们。</p><p id="0805" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在大多数图形渲染环境中，您需要从一个特定的线程中呈现数据，这个线程通常被称为UI线程或主线程。因此，要从运行在我们无法控制的任意数量线程上的所有协程中收集所有数据，至少在本例中不是这样，我们需要再次将它们分散到一个线程中。为此，我们需要一个新的渠道。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="0ff3" class="kl km hj ln b fj lr ls l lt lu"><strong class="ln hk">val </strong>receiveChannel = <em class="ll">Channel</em>&lt;Pair&lt;String, GPS&gt;&gt;()</span></pre><p id="80fc" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在我们有了一种从多个协程(可能还有线程)发送并在一个协程中使用它们的方法。我们正在迭代之前保存坐标的函数，以通过新的通道发送坐标。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="770f" class="kl km hj ln b fj lr ls l lt lu">...<br/>channel.<em class="ll">consumeEach </em><strong class="ln hk">{ </strong>address <strong class="ln hk">-&gt;<br/>    val </strong>gps = <em class="ll">fetchCoordinates</em>(address)<br/>    receiveChannel.send(address <em class="ll">to </em>gps)<br/><strong class="ln hk">}</strong><br/>receiveChannel.close() <em class="ll">// don't forget to close</em><strong class="ln hk"><br/></strong>...</span></pre><p id="b369" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">所有的地址，伴随着它们相应的GPS坐标，现在从多个协同程序发送到<em class="ll">接收通道</em>。所以基本上，所有的繁重工作都完成了，对吧？现在，我们需要从一个将向用户显示该通道的协程中使用该通道，到目前为止，您应该已经熟悉了如何使用该通道。</p><pre class="iz ja jb jc fe lm ln lo lp aw lq bi"><span id="2cfd" class="kl km hj ln b fj lr ls l lt lu"><em class="ll">// this runs on the main thread - inherited from runBlocking<br/>launch </em><strong class="ln hk">{ <br/>    </strong>receiveChannel.<em class="ll">consumeEach </em><strong class="ln hk">{ </strong>(address, gps) <strong class="ln hk">-&gt;<br/>        </strong><em class="ll">println</em>("<strong class="ln hk">$</strong>address -&gt; <strong class="ln hk">$</strong>gps")<br/>    <strong class="ln hk">}<br/>}</strong></span></pre><p id="4db4" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在我们也完成了风扇的工作。现在我们有了一个完整的工作应用程序，它使用了一个典型的并发模式。它也可以用于并行，但这需要更具体的实现，与硬件更紧密地耦合，我现在不会深入讨论这个问题。</p><p id="e0ae" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这是一个很小的例子，但它显示了Kotlin中渠道的优势。我们已经分割了一系列的值来同时处理，并且我们已经将它们收集到一个协程中，没有任何线程或者同步的想法。在我看来，这就是渠道的真正力量。它们使得将协程同步到系统中变得简单。这是我们代码的一个小图和完整的例子。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et lw"><img src="../Images/809561cbcaf685b283e0fdfae41cb7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkSzjW_HNf-vZ7qLC93OgQ.png"/></div></div></figure><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="lx ly l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">上面的全功能示例</figcaption></figure><h2 id="6862" class="kl km hj bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">当心变化</h2><p id="2a49" class="pw-post-body-paragraph jp jq hj jr b js lg ik ju jv lh in jx jy li ka kb kc lj ke kf kg lk ki kj kk hc bi translated">显示的一些功能是实验性的，将来可能会有变化。如果您更深入地研究Channel API，您会发现许多不推荐使用和过时的函数，例如filter和take等等。它们已经被弃用，而支持流，以保持信道的简洁和直接，并将与Rx的斗争留给流。</p><p id="26d2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">API也在发展，另一个过时的功能是actor-builder，它的工作方式类似于product-builder，但它是用来表示一个actor的，其中通道变成了actor的邮箱。这是一个很好的渠道使用，它只是过时了，因为他们正在建立一个更好的，更复杂的演员建设者。而只有未来会告诉我们，它会成为一个新的构建者(类似于现在)还是一个自己的实现，比如Flow。</p><h2 id="a728" class="kl km hj bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">最后的想法</h2><p id="35d4" class="pw-post-body-paragraph jp jq hj jr b js lg ik ju jv lh in jx jy li ka kb kc lj ke kf kg lk ki kj kk hc bi translated">我希望这两篇文章能帮助您理解通道，并帮助您掌握协程和挂起函数。它确实帮助我以顺序的方式思考异步性。</p><p id="4a9f" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">文章第一部分:<a class="ae jo" rel="noopener" href="/@dahlberg.bob/channels-in-kotlin-part-one-594ba12dcb5a">https://medium . com/@ Dahl Berg . bob/channels-in-kotlin-part-one-594 ba 12 dcb 5a</a></p></div></div>    
</body>
</html>