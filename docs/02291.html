<html>
<head>
<title>Song Recommendation using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习的歌曲推荐</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/song-recommendation-using-machine-learning-de4e0ea81118?source=collection_archive---------20-----------------------#2019-12-09">https://medium.com/analytics-vidhya/song-recommendation-using-machine-learning-de4e0ea81118?source=collection_archive---------20-----------------------#2019-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是关于使用最少的用户数据建立一个简单的歌曲推荐模型。下表是数据集的预览。我的jupyter笔记本解决方案可以在这里找到:<a class="ae jd" href="https://github.com/vnb/Data-Science-Portfolio/blob/master/Song%20Recommendation.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/vnb/Data-Science-Portfolio/blob/master/Song % 20 recommendation . ipynb</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/3b5352af0907d7e3e53979fde1cd25e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jNqubMphhmIpfdiIDIy1Q.png"/></div></div></figure><p id="d2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约有200个不同的用户由他们的“用户id”标识，4000行中的每一行都有一个唯一的“id ”,表示用户采取的一个动作，在这种情况下是播放一首歌曲。歌曲列表也限于甲壳虫乐队，因此更容易制定简单的ML算法来基于用户之前听过的歌曲预测用户播放的下一首歌曲可能是什么。</p><p id="f510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据数据，以下是基于总独立用户数和用户活动数的前10名和后10名状态。用户活动可以被定义为用户采取播放歌曲的动作的总次数，该歌曲由收听这些歌曲的不同时间戳来标识。这些信息可以根据每个状态进行汇总，得出以下结果</p><div class="jf jg jh ji fd ab cb"><figure class="jq jj jr js jt ju jv paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/cf9e132f796f6c7626d654c76efa79ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*7edCKW2MiE5O8ZLGyFK30Q.png"/></div></figure><figure class="jq jj jw js jt ju jv paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/992ec90fb2dfa12154c994e0046e4404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*GSjvAfIX6NF4r1PPrVTrpA.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx kb di kc kd translated">基于唯一用户计数的前10个状态和后10个状态</figcaption></figure></div><div class="ab cb"><figure class="jq jj ke js jt ju jv paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/7eea97a1d30e4ac015a33a3c75e7776c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wTpKpwABhB_3FsHXGoHFGA.png"/></div></figure><figure class="jq jj kf js jt ju jv paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><img src="../Images/6098411c109c4bff586da722486302e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*GSjvAfIX6NF4r1PPrVTrpA.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx kg di kh kd translated">基于用户活动的前10名和后10名状态</figcaption></figure></div><h1 id="47e7" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">特征工程</h1><p id="e32b" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">为了能够为上述数据构建模型，需要构建一组新的要素。由于用户数量有限且播放列表很小(仅包含披头士的歌曲),因此可以很容易地创建新的指标:</p><ol class=""><li id="f3bc" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">每个用户播放歌曲的总次数</li><li id="2b64" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">一首歌曲被所有用户播放的总次数-每天的总数</li><li id="7f62" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">按状态列出的所有用户播放歌曲的总次数</li><li id="063c" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">用户按日期播放每首歌曲的顺序</li></ol><p id="e6a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些指标有助于从播放列表中找到最受欢迎和最不受欢迎的歌曲</p><div class="jf jg jh ji fd ab cb"><figure class="jq jj lz js jt ju jv paragraph-image"><img src="../Images/22e70fe1851df44937dbcce3897cb1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*4Gzc4rYXH9uIgYUpA4sMow.png"/></figure><figure class="jq jj ma js jt ju jv paragraph-image"><img src="../Images/e08ad07d016e0247bea3ad3cd9e413a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*1GZpnDWY7IBehSmF0DwAgQ.png"/><figcaption class="jx jy et er es jz ka bd b be z dx mb di mc kd translated">最受欢迎和最不受欢迎的歌曲</figcaption></figure></div><p id="7438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二组指标与日期相关。由于不能在模型中直接使用日期时间，因此可以使用日期时间的增量，并进一步转换为整数值。这样做将确保关于注册日期之间的时间和每次播放之间的时间差的信息被保留。</p><h1 id="a94a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">模型</h1><p id="b7ad" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">为了创建歌曲推荐系统，该模型必须能够预测用户接下来最有可能播放的歌曲。可以删除与日期相关的列，因为与日期相关的所有信息都保留在之前创建的新功能中，然后使用“pandas.get_dummy”将分类数据(如user_state和user_id)转换为一次性编码。</p><p id="ad47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦完成，任何分类器都可以用来训练和测试数据集，但我发现adaBoost分类器在预测用户接下来可能会听的歌曲方面是最准确的(就F1分数而言)。该模型可以随着同一组用户收听更多的歌曲而不断更新，以便改进歌曲推荐模型。</p></div></div>    
</body>
</html>