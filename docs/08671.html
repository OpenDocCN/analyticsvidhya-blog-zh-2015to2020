<html>
<head>
<title>C++ dependency management with CMake’s FetchContent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CMake的FetchContent进行C++依赖管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-dependency-management-with-cmakes-fetchcontent-4ceca4693a5d?source=collection_archive---------7-----------------------#2020-08-08">https://medium.com/analytics-vidhya/c-dependency-management-with-cmakes-fetchcontent-4ceca4693a5d?source=collection_archive---------7-----------------------#2020-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/42670a1309758a13bc9e10ffb4529908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ueQ5PwB1Rvf7Tc1k"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@evankrause_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃文·克劳斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0742" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我们将讨论C++中的依赖管理。特别介绍一下<code class="du jt ju jv jw b">FetchContent</code>，一个应该会得到更多喜爱的CMake特性！</p><p id="92b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从C++应用程序的依赖管理概述开始。</p><h1 id="9f17" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Git子模块</h1><p id="2e16" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">过去，我的默认做法是将每个依赖项作为git子模块添加。对于现代CMake设置的依赖项，这足以使它可用于您的项目。</p><p id="bfcb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我一直不喜欢这种方法，因为它要求每个用户都运行</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="c6e0" class="li jy hi jw b fi lj lk l ll lm">$ git submodule update --init</span></pre><p id="2c79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构建代码之前。我喜欢让人们使用我的代码变得简单。因此，我一直在寻找一种方法来摆脱运行任何额外的命令。此外，我已经多次发现自己忘记运行<code class="du jt ju jv jw b">git submodule update --init</code>。</p><h1 id="e3c5" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">将代码复制到您的存储库中</h1><p id="7756" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">当然，您也可以将依赖项的整个源代码复制到项目的存储库中。然而，在我看来，这不如子模块。更新依赖关系变得复杂。而且，根据您的依赖关系有多大，这会使您的存储库膨胀。</p><h1 id="cace" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">柯南(和其他包装经理)</h1><p id="4043" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">另一个选择是使用像<a class="ae iu" href="https://conan.io/" rel="noopener ugc nofollow" target="_blank">柯南</a>这样的包管理器。我发现它们是更大项目的合适解决方案。当你有需要很长时间构建的依赖项时，它们也很好(我在看你的OpenCV！😴).<br/>但是对于需要Github的两到三个库的小型项目来说，这往往太费力了。</p><p id="9b7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的主要批评点是包管理器本身变成了一个依赖项。每个想要构建您的项目的人都已经安装了正确的版本。如果您正在使用CI，您还必须在构建服务器上设置所有的东西，这有时会很麻烦。</p><h1 id="a9c8" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">CMake能帮我们吗？</h1><p id="1daa" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">Rust和Go等较年轻的语言在构建系统中加入了包管理。这有助于更好的开发者体验，因为用户不必选择使用哪个包管理器。此外，默认情况下，软件包是为内置软件包管理器的语言设置的。</p><p id="6a95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这一点，很自然地会向CMake寻求解决方案。听说CMake在3.0版本中引入了一个名为<code class="du jt ju jv jw b"><a class="ae iu" href="https://cmake.org/cmake/help/latest/module/ExternalProject.html" rel="noopener ugc nofollow" target="_blank">ExternalProject</a></code>的模块，我很兴奋。<code class="du jt ju jv jw b">ExternalProject</code>将依赖项包装到CMake目标中，并允许从您的<code class="du jt ju jv jw b">CMakeLists.txt</code>管理外来代码。</p><p id="45cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用它，必须通过<code class="du jt ju jv jw b">ExternalProject_Add()</code>添加一个目标。然后，CMake将为此目标运行以下步骤。</p><p id="6112" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">DOWNLOAD</code></p><p id="76f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下载依赖项。这里可以使用版本控制系统或从URL下载。</p><p id="8f68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">UPDATE</code></p><p id="1b74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果自上次CMake运行以来发生了任何变化，请更新下载的代码。</p><p id="8853" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">CONFIGURE</code></p><p id="3e69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">配置项目代码。</p><p id="721e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">BUILD</code></p><p id="cc5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构建依赖项代码。</p><p id="6b30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">INSTALL</code></p><p id="56d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将构建的代码安装到指定的目录中。</p><p id="d895" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">TEST</code>(可选)</p><p id="43a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行测试。</p><p id="482e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上所有命令都是可配置的。<code class="du jt ju jv jw b">ExternalProject</code>也允许自定义步骤。有关更多信息，请查看<a class="ae iu" href="https://cmake.org/cmake/help/latest/module/ExternalProject.html#module:ExternalProject" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="b8e3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么，这就是解决办法吗？</h1><p id="c423" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">稍微摆弄了一下，发现<code class="du jt ju jv jw b"><strong class="ix hj">ExternalProject</strong></code> <strong class="ix hj">不是我要找的。</strong>😕</p><p id="1202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原因是当使用<code class="du jt ju jv jw b">ExternalProject</code>时，它的所有步骤都将在构建时运行。这意味着CMake会在生成步骤之后下载并构建您的依赖项。因此，当CMake配置您的项目时，您的依赖项还不可用。</p><h1 id="65ea" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么我们必须坚持子模块吗？</h1><p id="1ec1" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">不，我们不会！</p><p id="b5f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在3.11版本中，CMake引入了一个新的模块:<code class="du jt ju jv jw b"><a class="ae iu" href="https://cmake.org/cmake/help/latest/module/FetchContent.html" rel="noopener ugc nofollow" target="_blank">FetchContent</a></code>。该模块提供与<code class="du jt ju jv jw b">ExternalProject</code>相同的功能，但将在配置时间之前下载依赖关系。这意味着我们可以用它来管理来自<code class="du jt ju jv jw b">CMakeLists.txt</code>文件的C++项目依赖关系！🎉🎉🎉</p><h1 id="c2ca" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">如何使用<code class="du jt ju jv jw b">FetchContent</code></h1><p id="28ba" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">在这个<a class="ae iu" href="https://github.com/bewagner/fetchContent_example" rel="noopener ugc nofollow" target="_blank">资源库</a>中，我准备了一个例子。它使用<code class="du jt ju jv jw b">FetchContent</code>来包含库的<a class="ae iu" href="https://github.com/onqtam/doctest" rel="noopener ugc nofollow" target="_blank"> doctest </a>和<a class="ae iu" href="https://github.com/ericniebler/range-v3" rel="noopener ugc nofollow" target="_blank"> range-v3 </a>。CMake将下载并构建依赖项。非常方便！我将在下面解释一切是如何工作的。确保你得到了<a class="ae iu" href="https://github.com/bewagner/fetchContent_example" rel="noopener ugc nofollow" target="_blank">代码</a>来使用它。</p><p id="9f9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先创建一个常规的CMake项目。在3.14版本中，<code class="du jt ju jv jw b">FetchContent</code> API得到了改进，使得使用更加容易。因此，这是我们需要的最少版本。然后我们包括了<code class="du jt ju jv jw b">FetchContent</code>模块。</p><p id="710d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">cmake_minimum_required(VERSION 3.14) <br/>project(fetchContent_example CXX) <br/>include(FetchContent)</code></p><p id="2e64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过调用<code class="du jt ju jv jw b">FetchContent_Declare()</code>来注册每个依赖项。进行此调用时，您可以自定义如何加载依赖项。<code class="du jt ju jv jw b">FetchContent</code>理解与<code class="du jt ju jv jw b">ExternalProject</code>几乎相同的选项。但是与<code class="du jt ju jv jw b">CONFIGURE</code>、<code class="du jt ju jv jw b">BUILD</code>、<code class="du jt ju jv jw b">INSTALL</code>和<code class="du jt ju jv jw b">TEST</code>相关的选项被禁用。</p><p id="8a53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们声明两个目标，一个用于<code class="du jt ju jv jw b">doctest</code>，一个用于<code class="du jt ju jv jw b">range-v3</code>。CMake通过git库下载这两个库。</p><p id="a2a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数<code class="du jt ju jv jw b">GIT_TAG</code>指定了我们使用的依赖关系历史中的提交。这里也可以使用git分支名称或标记。然而，新的提交可以改变分支所指向的内容。这可能会影响项目的可重复性。所以CMake文档不鼓励使用分支名称或标记。</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="ac11" class="li jy hi jw b fi lj lk l ll lm">FetchContent_Declare(DocTest <br/>    GIT_REPOSITORY "https://github.com/onqtam/doctest"         <br/>    GIT_TAG "932a2ca50666138256dae56fbb16db3b1cae133a" ) FetchContent_Declare(Range-v3         <br/>    GIT_REPOSITORY "https://github.com/ericniebler/range-v3" <br/>    GIT_TAG "4d6a463bca51bc316f9b565edd94e82388206093" )</span></pre><p id="cbc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们调用<code class="du jt ju jv jw b">FetchContent_MakeAvailable()</code>。这个调用确保CMake下载我们的依赖项并添加它们的目录。</p><p id="c0b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">FetchContent_MakeAvailable(DocTest Range-v3)</code></p><p id="3653" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们可以添加一个可执行文件并链接到包含的包。CMake接手了所有的重活！</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="32d0" class="li jy hi jw b fi lj lk l ll lm">add_executable(${PROJECT_NAME} src/main.cpp)<br/>target_link_libraries(${PROJECT_NAME} doctest range-v3)</span></pre><p id="2902" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用git存储库是包含依赖于<code class="du jt ju jv jw b">FetchContent</code>的最方便的方式。但是，如果您所依赖的代码不是git存储库，您可以定制<code class="du jt ju jv jw b">FetchContent</code>来使用其他来源。看看 <code class="du jt ju jv jw b"><a class="ae iu" href="https://cmake.org/cmake/help/latest/module/ExternalProject.html#module:ExternalProject" rel="noopener ugc nofollow" target="_blank">ExternalProject</a></code>的<a class="ae iu" href="https://cmake.org/cmake/help/latest/module/ExternalProject.html#module:ExternalProject" rel="noopener ugc nofollow" target="_blank">文档。它解释了所有参数。</a></p><p id="afb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个<code class="du jt ju jv jw b">CMakeLists.txt</code>文件会是这样的。</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="04ab" class="li jy hi jw b fi lj lk l ll lm">cmake_minimum_required(VERSION 3.14) <br/>project(fetchContent_example CXX)  <br/>include(FetchContent)  <br/>FetchContent_Declare(DocTest <br/>    GIT_REPOSITORY "https://github.com/onqtam/doctest"         <br/>    GIT_TAG "932a2ca50666138256dae56fbb16db3b1cae133a" ) </span><span id="3f25" class="li jy hi jw b fi ln lk l ll lm">FetchContent_Declare(Range-v3         <br/>    GIT_REPOSITORY "https://github.com/ericniebler/range-v3"  <br/>    GIT_TAG "4d6a463bca51bc316f9b565edd94e82388206093" )  </span><span id="22cb" class="li jy hi jw b fi ln lk l ll lm">FetchContent_MakeAvailable(DocTest Range-v3)  </span><span id="f7bf" class="li jy hi jw b fi ln lk l ll lm">add_executable(${PROJECT_NAME} src/main.cpp) target_link_libraries(${PROJECT_NAME} doctest range-v3)</span></pre><p id="28c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在CMake中设置好一切之后，我们可以在源代码中使用这些包。下面是一个小的测试程序，它使用了两个包含的库。</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="09cd" class="li jy hi jw b fi lj lk l ll lm">#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN  <br/>#include &lt;vector&gt; <br/>#include "doctest/doctest.h" <br/>#include "range/v3/view.hpp" <br/>#include "range/v3/numeric/accumulate.hpp" <br/> <br/>int f(const std::vector&lt;int&gt; &amp;v) {<br/>    auto square = [](int i){ return i * i; };      <br/>    int sum = ranges::accumulate(v<br/>        | ranges::views::transform(square)       <br/>        | ranges::views::take(10)<br/>        , 0);<br/>       <br/>    return sum; <br/>    }  </span><span id="7b28" class="li jy hi jw b fi ln lk l ll lm">TEST_CASE ("Test function") { <br/>CHECK(f({1, 2, 3}) == 14);             <br/>CHECK(f({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 385);             CHECK(f({}) == 0); <br/>}</span></pre><p id="9722" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的示例项目是<a class="ae iu" href="https://github.com/bewagner/fetchContent_example" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="c42b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">需要注意什么</h1><p id="2aca" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">以下是使用<code class="du jt ju jv jw b">FetchContent</code>时需要记住的一些事情。</p><h2 id="594c" class="li jy hi bd jz lo lp lq kd lr ls lt kh jg lu lv kl jk lw lx kp jo ly lz kt ma bi translated">下载需要互联网连接</h2><p id="b72d" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">当然，首先你必须在线下载你的依赖项。与使用子模块相比，这个需求现在是隐藏的。因此，在构建代码时，您可能会忘记它。为了缓解这个问题，有一组选项。</p><ul class=""><li id="6bc3" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated"><code class="du jt ju jv jw b">FETCHCONTENT_FULLY_DISCONNECTED=ON</code>将跳过<code class="du jt ju jv jw b">DOWNLOAD</code>和<code class="du jt ju jv jw b">UPDATE</code>步骤</li><li id="4318" class="mb mc hi ix b iy mk jc ml jg mm jk mn jo mo js mg mh mi mj bi translated"><code class="du jt ju jv jw b">FETCHCONTENT_UPDATES_DISCONNECTED=ON</code>将跳过<code class="du jt ju jv jw b">UPDATE</code>步骤</li></ul><h2 id="8480" class="li jy hi bd jz lo lp lq kd lr ls lt kh jg lu lv kl jk lw lx kp jo ly lz kt ma bi translated">输出会变得非常冗长</h2><p id="7080" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated"><code class="du jt ju jv jw b">FetchContent</code>将记录其所有步骤。这就是控制台输出变得难以阅读的原因。要使所有输出静音，请将<code class="du jt ju jv jw b">FETCHCONTENT_QUIET</code>设置为<code class="du jt ju jv jw b">ON</code>。</p><h2 id="6a1a" class="li jy hi bd jz lo lp lq kd lr ls lt kh jg lu lv kl jk lw lx kp jo ly lz kt ma bi translated">该库必须是可安装的</h2><p id="a243" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">我经常遇到的一个问题是，我想要使用的依赖项是不可安装的。每隔一段时间，您会遇到在它们的<code class="du jt ju jv jw b">CMakeLists.txt</code>中缺少对<code class="du jt ju jv jw b">install()</code>的调用的库。在这种情况下，<code class="du jt ju jv jw b">FetchContent</code>不知道如何将构建好的代码复制到安装文件夹中，将会失败。在这种情况下，考虑添加<code class="du jt ju jv jw b">install()</code>呼叫并创建一个PR。</p><p id="4198" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">FetchContent</code>最适合基于CMake的依赖项。我还没有机会用不是用CMake构建的库来测试它。但是我认为需要一些额外的配置来使它工作。</p><h1 id="9376" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结论</h1><p id="286e" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">在这篇博文中，我们了解了<code class="du jt ju jv jw b">FetchContent</code>。现在您知道了如何在CMake设置中管理您的依赖项。我们看到了如何使用<code class="du jt ju jv jw b">FetchContent</code>来获取一个小示例项目的依赖关系。我们还读到了一些使用时需要注意的事情。</p><p id="5d23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很喜欢这种管理依赖关系的方式。当然，你可以混合不同的方法，使用最适合你的方法！</p><p id="313b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你认为我在这篇文章中遗漏了什么，请告诉我！</p><p id="8582" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢我的写作，考虑支持我，这样我可以继续为你创造内容！</p><div class="la lb lc ld fd ab cb"><figure class="mp ij mq mr ms mt mu paragraph-image"><a href="https://ko-fi.com/bewagner"><img src="../Images/442e2379dd4c422211e3762adb3e50e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*upxn1lEIsQB36yY-a-RHVw.png"/></a></figure><figure class="mp ij mv mr ms mt mu paragraph-image"><a href="https://www.patreon.com/bewagner?fan_landing=true"><img src="../Images/8f52df8c73b6eb1b2ef850f39042e120.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*rDcCY5d9_DyCDt9s_1RlQg.png"/></a></figure></div><p id="3678" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在Twitter上关注我</strong><a class="ae iu" href="https://twitter.com/bewagner_" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">@ be Wagner _</strong></a><strong class="ix hj">了解更多关于编程和C++的想法！</strong></p><p id="f802" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章最初发表在我的博客上:</p><p id="693a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://bewagner.github.io/programming/2020/05/02/cmake-fetchcontent/" rel="noopener ugc nofollow" target="_blank">https://be Wagner . net/programming/2020/05/02/cmake-fetch content/</a></p></div></div>    
</body>
</html>