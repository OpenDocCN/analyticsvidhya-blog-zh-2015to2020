<html>
<head>
<title>McCulloch-Pitts Neuron, Perceptron and the Perceptron Learning Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">麦卡洛克-皮茨神经元、感知器和感知器学习算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mcculloch-pitts-neuron-perceptron-and-the-perceptron-learning-algorithm-305796f6f980?source=collection_archive---------24-----------------------#2020-06-19">https://medium.com/analytics-vidhya/mcculloch-pitts-neuron-perceptron-and-the-perceptron-learning-algorithm-305796f6f980?source=collection_archive---------24-----------------------#2020-06-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e0ec7ab3671e0737827fa6323ccf569e.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*GA6qOtJlcqutoNcO3wuj4A.jpeg"/></div></figure><p id="c5e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的大脑大约有860亿个神经元。神经元帮助我们做决定。我们反复做决定——“我是应该看《网飞》还是应该学习？”，“我到底应该看黑暗还是朋友？，“是否观看IPL比赛”。我们的决定通常是布尔形式的——是或否，0或1。在做出决定之前，我们还会考虑各种因素(通常也是布尔型的)。因此，举例来说，我们观看IPL比赛的因素将是——它是否是CSK的比赛，如果是，那么我将观看。对手队是不是皇家挑战者Banglore，如果不是，我就看”等。因此，这个灵感被用来形成生物神经元的第一个数学表示——MP神经元。让我们看看它是如何工作的:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/f52122a813480901336c2e77163bf79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*BqJy7GQmSoAwzAkMpfPAKA.png"/></div></figure><p id="c463" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如图所示，输入和输出都是布尔型的。有两个部分:<strong class="io hj"> <em class="jp"> g </em> </strong>接受所有的输入并聚合它们，<strong class="io hj"> <em class="jp"> f </em> </strong>根据聚合做出决定。让我们继续以IPL比赛为例。所以，</p><p id="557b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jp"> y </em> </strong>:可能是{ 1:我会看比赛，0:我不会看比赛}</p><p id="4c28" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jp"> x1 </em> </strong>:可能是{比赛在我的城市进行吗}</p><p id="ce66" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jp">x2</em></strong>:{ CSK在玩吗}</p><p id="cd04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jp">x3</em></strong>:{ Dhoni女士在玩吗}</p><p id="1477" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很明显，只有当<strong class="io hj"> <em class="jp"> x1 </em> </strong>为1时，我才能决定去还是不去，也就是说，我要去的比赛必须在我的城市。我不能去另一个城市看比赛了(实际上)。<strong class="io hj"> <em class="jp"> x1 </em> </strong>为此被称为抑制输入。一般来说，<em class="jp"> x1是所有不去看比赛的理由。</em></p><p id="5e46" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，如果你是Dhoni女士的铁杆粉丝——只有Dhoni女士在玩的时候你才会去——所有的<strong class="io hj"> <em class="jp"> x1，x2，x3 </em> </strong>都必须是1。另一方面，如果你只是CSK的粉丝，只有<strong class="io hj"><em class="jp"/></strong>和<strong class="io hj"> <em class="jp"> x2 </em> </strong>必须是1——不管<strong class="io hj"> <em class="jp"> x3 </em> </strong>是0还是1。拿第一种情况来说，我们可以说，只有当<strong class="io hj"><em class="jp">g(x)= x1+x2+x3≥3</em></strong>时，这个神经元才会“开火”</p><p id="e7a4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来看看另一个布尔函数——AND函数。用MP神经元来表示:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/af6fa8cf20bbbb016b5dbb20a629599e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqyHNa2npHmBgA5raoMIiw.png"/></div></div></figure><p id="f5b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以说，只有当<strong class="io hj"> <em class="jp"> g(x)≥2时，神经元才会“激发”。</em> </strong>因此，<strong class="io hj"> <em class="jp"> g(x)=2 </em> </strong>称为决定边界，对于线上或线上的所有点，<strong class="io hj"> <em class="jp"> y=1。</em> </strong>一般情况下，<strong class="io hj"> <em class="jp"> g(x)≥θ </em> </strong>，其中<strong class="io hj"> <em class="jp"> θ </em> </strong> =阈值参数。</p><p id="f3b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样，一些布尔函数可以用MP-neuron来表示。但是非布尔输入呢？所有的输入都相等吗——在我们的例子中，我可能想给<strong class="io hj"> <em class="jp"> x3更多的“重要性”。</em> </strong>“威震天来了！”不，感知器</p><h2 id="4754" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ix kg kh ki jb kj kk kl jf km kn ko kp bi translated">感知器</h2><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/ed579340a01c8a702a412183681a5107.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*UukTRb0rSGoGBXX6QC2tXQ.png"/></div></figure><p id="eaaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在现实生活中，有些因素比其他因素更重要。因此，除了MP-neuron中的输入，感知器中也给出了输入的权重(重要性)。此外，除了学习权重，我们之前手动编码的阈值现在将通过一种称为<em class="jp">感知器学习算法</em>的算法来学习。</p><p id="61b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在聚合会变成<strong class="io hj"> <em class="jp"> g(x) = w1x1+w2x2+w3x3≥θ或者w0x0+w1x1+w2x2+w3x3≥0 </em> </strong>其中<strong class="io hj">x0</strong>=<strong class="io hj"><em class="jp">1</em></strong>和<strong class="io hj"><em class="jp">w0</em></strong>=-<strong class="io hj"><em class="jp">θ。</em> </strong>我们也可以把它写成<strong class="io hj"> <em class="jp"> w.x≥0，</em> </strong>点积。判定边界将是<strong class="io hj"> <em class="jp"> w.x=0。</em> </strong>任务是学习权重<strong class="io hj"><em class="jp"/></strong>使输入<strong class="io hj"> <em class="jp"> xi的误差最小化。</em>T59】</strong></p><h2 id="3037" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ix kg kh ki jb kj kk kl jf km kn ko kp bi translated">感知机学习算法</h2><p id="4da5" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj hb bi translated">让我们将权重初始化为:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/c34eba4b90b48a9af342778e93626910.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*LspM734kU5kBhEJTTnDG2Q.png"/></div></figure><p id="43b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">案例1: <strong class="io hj"> <em class="jp"> P={p1，p2，p3} </em> </strong>是<strong class="io hj"> <em class="jp"> y=1的所有输入。</em> </strong>换句话说，以决策边界为<strong class="io hj"> <em class="jp"> w.x=0 </em> </strong>，P是<strong class="io hj"> <em class="jp"> w.x≥0 </em> </strong>的所有点的集合。</p><p id="7416" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">案例2: <strong class="io hj"> <em class="jp"> N={n1，n2，n3} </em> </strong>为<strong class="io hj"> <em class="jp"> y=0 </em> </strong>的所有输入。换句话说，N是<strong class="io hj"> <em class="jp"> w.x≤0 </em> </strong>的所有点的集合。</p><p id="5d58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们希望在最后，情况1和情况2必须发生(而不是相反)。还有，注意w.x≥0表示<strong class="io hj"> <em class="jp"> α≤90度，</em> </strong>角度b/w <strong class="io hj"> <em class="jp"> w </em> </strong>和<strong class="io hj"> <em class="jp"> x. </em> </strong>并且，w.x≤0表示<strong class="io hj"> <em class="jp"> α≥90度。</em>T103】</strong></p><p id="231b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了所有的声明，让我们看看算法:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/5f6f6ca1c29b09b6419dbeea85856220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*Leev_sgIOwmFTTRPXDMubw.png"/></div></figure><p id="8f7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们迭代输入空间(P U N)中的所有点，对于P中的点，我们希望最后有<strong class="io hj"> <em class="jp"> w.x≥0 </em> </strong>。所以每当<strong class="io hj"> <em class="jp"> w.x &lt;，</em> </strong>我们给w加上x向量使其<strong class="io hj"> <em class="jp"> w.x≥0。</em> </strong>我们对n中的点做同样的处理。</p><p id="59fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，当算法已经收敛-当对于P，<strong class="io hj"> <em class="jp"> w.x≥0 </em> </strong>中的所有点以及对于N，<strong class="io hj"> <em class="jp"> w.x &lt; 0，</em> </strong>中的所有点，我们停止。</p><p id="fdb9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">算法总会收敛。收敛的证据可以在这里找到。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/35deac2b865a7a795d8918e671ecf08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*d_3XKUenCUV7NTSO3vAm1g.jpeg"/></div></figure><p id="313e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇文章只提到了一个感知器。单个感知器只能表示线性可分函数。将需要感知器网络来分类线性不可分的函数。在下一个帖子里！</p><p id="e3e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jp">注:本文的概念基于NPTEL在线教授的课程</em> <a class="ae ky" href="https://www.cse.iitm.ac.in/~miteshk/CS7015.html" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> CS7015:深度学习</em> </a> <em class="jp">的视频。</em></p></div></div>    
</body>
</html>