<html>
<head>
<title>NumPy :Broadcasting and Shape Manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy:广播和形状操纵</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/numpy-broadcasting-and-shape-manipulation-8e2b6fd0f987?source=collection_archive---------20-----------------------#2020-06-02">https://medium.com/analytics-vidhya/numpy-broadcasting-and-shape-manipulation-8e2b6fd0f987?source=collection_archive---------20-----------------------#2020-06-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/30c31b3fc58a509ab40ccf04e67a8a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INmhyNtbNZm8pO4lt5ooBw.jpeg"/></div></div></figure><h1 id="9b3c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数字广播:</h1><p id="f9e5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">术语<strong class="jq hj">广播</strong>指的是NumPy在算术运算中处理不同形状数组的能力。数组上的算术运算通常在相应的元素上完成。如果两个数组的形状完全相同，那么这些操作可以顺利执行。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es km"><img src="../Images/b9926cdcdad8b5fb1498351785f4000b.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*5ejGkssCwNWiaf4rrT5hHw.png"/></div></figure><p id="44b5" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">广播提供了一种向量化数组操作的方法，因此循环在C中而不是Python中发生，因为我们知道Numpy是用C实现的。它这样做不会产生不必要的数据副本，从而导致高效的算法实现。有些情况下，广播是一个坏主意，因为它会导致内存使用效率低下，从而降低计算速度。</p><p id="dc73" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">NumPy操作通常是在逐个元素的基础上对数组对进行的。在最简单的情况下，两个数组必须具有完全相同的形状，如下例所示:</p><pre class="kn ko kp kq fd kw kx ky kz aw la bi"><span id="95df" class="lb ir hi kx b fi lc ld l le lf"><strong class="kx hj">&gt;&gt;&gt; </strong>a = np.array([1.0, 2.0, 3.0])<br/><strong class="kx hj">&gt;&gt;&gt; </strong>b = np.array([2.0, 2.0, 2.0])<br/><strong class="kx hj">&gt;&gt;&gt; </strong>a * b<br/>array([ 2.,  4.,  6.])</span></pre><p id="6982" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">如果两个数组的维数不同，元素到元素的运算是不可能的。然而，由于广播能力，在NumPy中对非相似形状的数组的操作仍然是可能的。较小的数组被<strong class="jq hj">广播</strong>到较大数组的大小，以便它们具有兼容的形状。</p><h1 id="412a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">广播规则:</h1><p id="2b47" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果满足以下规则，广播是可能的</p><ul class=""><li id="1042" class="lg lh hi jq b jr kr jv ks jz li kd lj kh lk kl ll lm ln lo bi translated">ndim<strong class="jq hj">比另一个小的数组在其形状前加上“1”。</strong></li><li id="77f1" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">输出形状的每个维度中的大小是该维度中输入大小的最大值。</li><li id="f4b2" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">如果输入在特定维度中的大小与输出大小匹配，或者其值正好为1，则可以在计算中使用输入。</li><li id="a58d" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">如果输入的维度大小为1，则该维度中的第一个数据条目将用于该维度上的所有计算。</li></ul><p id="af72" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">如果上述规则产生一个有效的结果，并且下列条件之一为真，则称一组数组为<strong class="jq hj">可广播的</strong></p><ul class=""><li id="51ac" class="lg lh hi jq b jr kr jv ks jz li kd lj kh lk kl ll lm ln lo bi translated">数组具有完全相同的形状。</li><li id="4bac" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">数组具有相同的维数，每个维的长度要么是公共长度，要么是1。</li><li id="1a76" class="lg lh hi jq b jr lp jv lq jz lr kd ls kh lt kl ll lm ln lo bi translated">维度太少的数组可以在形状前添加长度为1的维度，因此上述属性成立。</li></ul><p id="9912" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated"><strong class="jq hj">让我们看看下面的例子来理解广播:</strong></p><pre class="kn ko kp kq fd kw kx ky kz aw la bi"><span id="2de9" class="lb ir hi kx b fi lc ld l le lf"><strong class="kx hj">&gt;&gt;&gt; from</strong> <strong class="kx hj">numpy</strong> <strong class="kx hj">import</strong> array<br/><strong class="kx hj">&gt;&gt;&gt; </strong>a = array([[ 0.0,  0.0,  0.0],<br/><strong class="kx hj">... </strong>           [10.0, 10.0, 10.0],<br/><strong class="kx hj">... </strong>           [20.0, 20.0, 20.0],<br/><strong class="kx hj">... </strong>           [30.0, 30.0, 30.0]])<br/><strong class="kx hj">&gt;&gt;&gt; </strong>b = array([0.0, 1.0, 2.0])<br/><strong class="kx hj">&gt;&gt;&gt; </strong>a + b<br/>array([[  0.,   1.,   2.],<br/>       [ 10.,  11.,  12.],<br/>       [ 20.,  21.,  22.],<br/>       [ 30.,  31.,  32.]])</span></pre><p id="7731" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">如图1所示，<code class="du lu lv lw kx b">b</code>被添加到<code class="du lu lv lw kx b">a</code>的每一行。当<code class="du lu lv lw kx b">b</code>比<code class="du lu lv lw kx b">a</code>的行长时，如图2所示，因为形状不兼容而引发异常。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/c1986f17ef076e1486ec7b3fe7ba7e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/1*jlGI1GcgRoggiHGSUGGFFA.gif"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">图1: <em class="mc">如果一维数组元素的数量与二维数组列的数量匹配，则二维数组乘以一维数组会导致广播。</em></figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es md"><img src="../Images/eba0db973a30593eceb1687694054e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/1*trn4NUkMIiHwK0ZN1afg5Q.gif"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">图2 <em class="mc">当数组的尾部维数不相等时，广播失败，因为无法将第一个数组的行中的值与第二个数组的元素对齐以进行元素间的加法。</em></figcaption></figure><h1 id="37d2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">广播的局限性</h1><p id="c7d0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">1️⃣广播是一种方便的快捷方式，在使用NumPy数组的实践中证明非常有用。</p><p id="734c" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">2️⃣:也就是说，它并不适用于所有情况，事实上，它强加了一个严格的规则，必须满足该规则才能进行广播。</p><p id="9394" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">包括广播在内的3️⃣算法只能在数组中每个维度的形状相等或者其中一个维度的大小为1时执行。</p><h1 id="7189" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">NumPy中的形状操作:</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es me"><img src="../Images/14952378c03fcc7d9622fe5d90c65ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*uguDl7q39C4mZW3eiHHa7A.png"/></div></figure><p id="b160" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">Numpy提供了灵活的工具来改变数组的维数。在更改维度之前，最好记住数组的维度是什么意思，以及不同维度的数组是什么样子:</p><pre class="kn ko kp kq fd kw kx ky kz aw la bi"><span id="52e3" class="lb ir hi kx b fi lc ld l le lf"># 2-dimensional<br/>b = np.zeros((3,4))b<br/>array([[0., 0., 0., 0.],        <br/>       [0., 0., 0., 0.],        <br/>       [0., 0., 0., 0.]])<br/>b.ndim<br/>2<br/># 3-dimensional<br/>c = np.ones((2,2,2))<br/>array([[[1., 1.],         <br/>        [1., 1.]],<br/>         <br/>        [[1., 1.],         <br/>         [1., 1.]]])<br/>c.ndim<br/>3</span></pre><p id="7aff" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated">有不同的方法来改变数组的维数。<strong class="jq hj"> Reshape </strong>函数通常用于修改一个数组的形状和维度。我们只需要将新形状作为参数传递给shape函数:</p><pre class="kn ko kp kq fd kw kx ky kz aw la bi"><span id="2ed0" class="lb ir hi kx b fi lc ld l le lf">np.arange(8).reshape(2,2,2)<br/>array([[[0, 1],         <br/>        [2, 3]],          <br/>        [[4, 5],         <br/>        [6, 7]]])</span></pre><h1 id="852a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">更改数组形状:</h1><p id="ce50" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> 1️⃣整形</strong> (a，newshape[，order])→给一个数组一个新的形状而不改变它的数据。</p><p id="9220" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated"><strong class="jq hj">2️⃣·拉威尔</strong> (a[，order])→返回一个连续的扁平数组。</p><p id="321c" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated"><strong class="jq hj"> 3️⃣ ndarray.flat → </strong>数组上的一维迭代器。</p><p id="542b" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated"><strong class="jq hj">4️⃣ndarray . flatten</strong>([order])→返回折叠成一维的数组的副本。</p><p id="8122" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hb bi translated"><strong class="jq hj">因此，通过这种方式，可以在NumPy </strong>中的数组上执行广播和形状操作。</p><blockquote class="mf"><p id="d64b" class="mg mh hi bd mi mj mk ml mm mn mo kl dx translated">“你不一定要开始变得伟大，但你必须开始变得伟大。”–ZIG ZIG lar</p></blockquote><h1 id="d02c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb mp jd je jf mq jh ji jj mr jl jm jn bi translated">谢谢大家！！</h1></div></div>    
</body>
</html>