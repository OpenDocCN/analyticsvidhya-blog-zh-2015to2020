<html>
<head>
<title>How to make a movie recommender: using Svelte as a front-end application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作电影推荐器:使用Svelte作为前端应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-make-a-movie-recommender-using-svelte-as-a-front-end-application-5907d1610b09?source=collection_archive---------9-----------------------#2020-12-12">https://medium.com/analytics-vidhya/how-to-make-a-movie-recommender-using-svelte-as-a-front-end-application-5907d1610b09?source=collection_archive---------9-----------------------#2020-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b34d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">svelte(<a class="ae jd" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/</a>)是一个用于创建反应式web应用程序的优秀JavaScript框架。在本教程中，我们将制作一个单页面应用程序(SPA ),换句话说，用户可以交互的所有内容都在一个页面中。由于一些应用程序可以使用多个页面，我们将创建一个空白页面，这样您就可以知道如何创建更多的页面。我不是JavaScript开发人员，所以这段代码可能不是最棒的代码，但它是有效的，这才是最重要的。我从这个教程中学到了很多关于苗条身材的知识。本教程所有代码<a class="ae jd" href="https://github.com/jdortuzar5/movie-recommender/tree/master/frontend" rel="noopener ugc nofollow" target="_blank">此处</a>，本项目所有代码<a class="ae jd" href="https://github.com/jdortuzar5/movie-recommender/tree/master/frontend" rel="noopener ugc nofollow" target="_blank">此处</a>。因此，让我们首先看看用户将如何与我们的应用程序进行交互:</p><h1 id="53e8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">用户旅程</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/8c92b4015f943dd07f7793300aba19b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uF-NLoQDGREO5YxjPjNCfQ.png"/></div></div></figure><p id="8d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是用户在应用程序启动时会看到的，这个想法是用户将制作一个他或她想看的风格的电影列表。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ko"><img src="../Images/6032fae10b026357dab6686d98cce2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNsjqhtOTFxfAHuAYkTN0A.png"/></div></div></figure><p id="6ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户添加一部电影时，当她点击推荐按钮时，一个漂亮的动画告诉用户它正在工作。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kp"><img src="../Images/b28dac91b7dc9150bcafe2f3a0a5f7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAxAME9Tb2_300nuvo5vsA.png"/></div></div></figure><p id="80ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几秒钟后，用户将收到一个电影推荐列表。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kq"><img src="../Images/f4971f79b440ffbd6a19fec0cefc7f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNkRUR5tiF96vRaW_TkETg.png"/></div></div></figure><p id="5a58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，简单明了，一页纸就能写完。现在让我们去做吧。</p><h1 id="488b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">用苗条编码</h1><p id="45dd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">要安装svelite，你应该按照官方<a class="ae jd" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">svelite网站</a>里的简单教程en。这样一来，我们将安装<a class="ae jd" href="https://materializecss.com/" rel="noopener ugc nofollow" target="_blank"> Materialize CSS </a>库，让我们无需编写CSS文件就能创建时尚的网站。</p><p id="f705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从使用NPM安装库开始。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="e72d" class="lb jf hi kx b fi lc ld l le lf">npm install materialize-css@next</span></pre><p id="e6ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了能够使用物化CSS和苗条，我们需要把它和Rollup捆绑在一起。为此，我们首先需要一个插件，所以让我们安装它:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="5f8d" class="lb jf hi kx b fi lc ld l le lf">npm install rollup-plugin-css-only -D</span></pre><p id="8e20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们转到我们的<code class="du lg lh li kx b">rollup.config.js</code>文件，你可以将我的文件复制并粘贴到你的文件上，但是有非常小的变化。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="ef71" class="lb jf hi kx b fi lc ld l le lf">import svelte from 'rollup-plugin-svelte';<br/>import resolve from '@rollup/plugin-node-resolve';<br/>import commonjs from '@rollup/plugin-commonjs';<br/>import livereload from 'rollup-plugin-livereload';<br/>import { terser } from 'rollup-plugin-terser';<br/>// Tutorial: Here we are importing our css plugin<br/>import css from "rollup-plugin-css-only";</span><span id="96ff" class="lb jf hi kx b fi lj ld l le lf">const production = !process.env.ROLLUP_WATCH;</span><span id="c6ee" class="lb jf hi kx b fi lj ld l le lf">function serve() {<br/>	let server;<br/>	<br/>	function toExit() {<br/>		if (server) server.kill(0);<br/>	}</span><span id="d51c" class="lb jf hi kx b fi lj ld l le lf">	return {<br/>		writeBundle() {<br/>			if (server) return;<br/>			server = require('child_process').spawn('npm', ['run', 'start', '--', '--dev'], {<br/>				stdio: ['ignore', 'inherit', 'inherit'],<br/>				shell: true<br/>			});</span><span id="3a16" class="lb jf hi kx b fi lj ld l le lf">			process.on('SIGTERM', toExit);<br/>			process.on('exit', toExit);<br/>		}<br/>	};<br/>}</span><span id="eb11" class="lb jf hi kx b fi lj ld l le lf">export default {<br/>	input: 'src/main.js',<br/>	output: {<br/>		sourcemap: true,<br/>		format: 'iife',<br/>		name: 'app',<br/>		file: 'public/build/bundle.js'<br/>	},<br/>	plugins: [<br/>		svelte({<br/>			// enable run-time checks when not in production<br/>			dev: !production,<br/>			// we'll extract any component CSS out into<br/>			// a separate file - better for performance<br/>			css: css =&gt; {<br/>				css.write('public/build/bundle.css');<br/>			}<br/>		}),<br/>		//Tutorial: Here we are linking our bundler to our css files.<br/>		//These will be saved in the public folder with the name extra.css<br/>		css({output: 'public/extra.css'}),<br/>		// If you have external dependencies installed from<br/>		// npm, you'll most likely need these plugins. In<br/>		// some cases you'll need additional configuration -<br/>		// consult the documentation for details:<br/>		// &lt;https://github.com/rollup/plugins/tree/master/packages/commonjs&gt;<br/>		resolve({<br/>			browser: true,<br/>			dedupe: ['svelte']<br/>		}),<br/>		commonjs(),</span><span id="1984" class="lb jf hi kx b fi lj ld l le lf">		// In dev mode, call `npm run start` once<br/>		// the bundle has been generated<br/>		!production &amp;&amp; serve(),</span><span id="094e" class="lb jf hi kx b fi lj ld l le lf">		// Watch the `public` directory and refresh the<br/>		// browser on changes when not in production<br/>		!production &amp;&amp; livereload('public'),</span><span id="7232" class="lb jf hi kx b fi lj ld l le lf">		// If we're building for production (npm run build<br/>		// instead of npm run dev), minify<br/>		production &amp;&amp; terser()<br/>	],<br/>	watch: {<br/>		clearScreen: false<br/>	}<br/>};</span></pre><p id="0b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在文件夹<code class="du lg lh li kx b">public</code>的文件<code class="du lg lh li kx b">index.html</code>中，我们必须添加我们的css链接。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="937e" class="lb jf hi kx b fi lc ld l le lf">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>	&lt;meta charset='utf-8'&gt;<br/>	&lt;meta name='viewport' content='width=device-width,initial-scale=1'&gt;</span><span id="d24e" class="lb jf hi kx b fi lj ld l le lf">	&lt;title&gt;Svelte app&lt;/title&gt;</span><span id="7317" class="lb jf hi kx b fi lj ld l le lf">	&lt;link rel='icon' type='image/png' href='/favicon.png'&gt;<br/>	&lt;!-- Tutorial: the tag below makes sure that we can use Materialize CSS --!&gt;<br/>	&lt;link rel="stylesheet" href="extra.css"&gt;</span><span id="7b9d" class="lb jf hi kx b fi lj ld l le lf">	&lt;script defer src='/build/bundle.js'&gt;&lt;/script&gt;<br/>&lt;/head&gt;</span><span id="7585" class="lb jf hi kx b fi lj ld l le lf">&lt;body&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="06c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要将物化CSS导入到我们的苗条组件中。为此，我们转到<code class="du lg lh li kx b">src</code>文件夹中的<code class="du lg lh li kx b">App.Svelte</code>文件。在<code class="du lg lh li kx b">script</code>标签中，我们可以添加以下几行:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="cba1" class="lb jf hi kx b fi lc ld l le lf">&lt;script&gt;<br/>	import "../node_modules/materialize-css/dist/css/materialize.min.css"<br/>	import "../node_modules/materialize-css/dist/js/materialize.min.js"<br/>	<br/>&lt;/script&gt;</span></pre><p id="36b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以开始创建应用程序的其余部分，而不必编写所有的CSS代码。这个方法可以和其他CSS库一起工作，比如Bootstrap或者Tailwind。</p><h1 id="47e9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">苗条的路线</h1><p id="ac85" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">路由是在应用程序中更改页面或路由的过程。因为我们的应用程序只需要一个页面，所以我们不需要路由。但是我们无论如何都会使用它，所以你可以把它添加到你自己的应用程序中。现在，Svelte没有配备官方路由器，但有一个允许路由的插件，名为<a class="ae jd" href="https://github.com/EmilTholin/svelte-routing" rel="noopener ugc nofollow" target="_blank"> Svelte Routing </a>。要安装它，我们将使用以下命令:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="617e" class="lb jf hi kx b fi lc ld l le lf">npm install --save svelte-routing</span></pre><h1 id="d8a8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">苗条是如何工作的</h1><p id="806c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Svelte和许多JavaScript框架一样，使用了组件的概念。这意味着站点的每个部分都应该包含在一个组件中，并且它们应该能够相互通信。现在，Svelte最大的特点之一(以我的拙见)是它使组件之间的通信变得非常简单。现在，我们应用程序中的主要组件叫做App。苗条(所有在<code class="du lg lh li kx b">src</code>中以<code class="du lg lh li kx b">.svelte</code>结尾的文件都被认为是组件)。为什么我们不从为我们的应用程序制作一个导航栏开始呢？</p><p id="d378" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du lg lh li kx b">src</code>文件夹中，我们创建另一个名为<code class="du lg lh li kx b">components</code>的文件夹，这是我们保存组件的地方。在<code class="du lg lh li kx b">components</code>中，我们创建一个名为<code class="du lg lh li kx b">Navbar.svelte</code>的文件，并添加以下代码:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="e87b" class="lb jf hi kx b fi lc ld l le lf">&lt;script&gt;<br/>  import {Link} from 'svelte-routing'<br/>&lt;/script&gt;<br/>  &lt;nav&gt;<br/>    &lt;div class="nav-wrapper"&gt;<br/>      &lt;div class="container"&gt;<br/>        &lt;Link to="/"&gt;&lt;span class="brand-logo"&gt;Movie Recommender&lt;/span&gt;&lt;/Link&gt;<br/>        &lt;ul id="nav-mobile" class="right hide-on-med-and-down"&gt;<br/>          &lt;li&gt;&lt;Link to="/" class="brand-logo"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>          &lt;li&gt;&lt;Link to="/history" class="brand-logo"&gt;History&lt;/Link&gt;&lt;/li&gt;<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/nav&gt;</span></pre><p id="afed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个苗条的组件有三个部分a <code class="du lg lh li kx b">script</code>、<code class="du lg lh li kx b">style</code>和<code class="du lg lh li kx b">main</code>(没有真正的名字，但我是这样称呼它的)。组件的<code class="du lg lh li kx b">script</code>部分是组件的所有JavaScript逻辑所在的地方，在<code class="du lg lh li kx b">&lt;script&gt;</code>标签之间，对于我们的<code class="du lg lh li kx b">Navbar</code>组件，我们只是从<code class="du lg lh li kx b">svelte-routing</code>库中导入了一个<code class="du lg lh li kx b">Link</code>组件。组件的<code class="du lg lh li kx b">style</code>部分是你可以为组件编写定制CSS的地方，因为每个组件都是相互独立的，CSS不会互相覆盖。您可以在<code class="du lg lh li kx b">&lt;style&gt;</code>标记之间编写自己的自定义CSS。不在<code class="du lg lh li kx b">script</code>或<code class="du lg lh li kx b">style</code>标签中的任何东西都是<code class="du lg lh li kx b">main</code>部分的一部分，在这里你编写组件的HTML部分。在Navbar组件中，我们使用<code class="du lg lh li kx b">&lt;nav&gt;</code>来定义一个导航栏，使用几个<code class="du lg lh li kx b">div</code>来以物化CSS样式包装我们的导航栏。<code class="du lg lh li kx b">Link</code>选项卡很重要，因为它们允许我们使用<code class="du lg lh li kx b">svelte-router</code>库，告诉他们去哪里，查看标签到<code class="du lg lh li kx b">History</code>页面的路线，我们有一条路线<code class="du lg lh li kx b">/history</code>，所以当我们单击那个<code class="du lg lh li kx b">Link</code>时，那就是我们要去的地方。</p><p id="7a5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建我们的页面，在我们的<code class="du lg lh li kx b">src</code>文件夹内名为<code class="du lg lh li kx b">pages</code>的文件夹中，让我们创建两个空组件:<code class="du lg lh li kx b">Home.svelte</code>和<code class="du lg lh li kx b">History.svelte</code>。我们稍后将填写它们，但是现在在我们的<code class="du lg lh li kx b">App.svelte</code>组件中，让我们添加我们的<code class="du lg lh li kx b">Navbar</code>。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="22f3" class="lb jf hi kx b fi lc ld l le lf">&lt;script&gt;<br/>	import "../node_modules/materialize-css/dist/css/materialize.min.css"<br/>	import "../node_modules/materialize-css/dist/js/materialize.min.js"<br/>	import { Router, Link, Route } from "svelte-routing";<br/>	import Navbar from "./components/Navbar.svelte";<br/>	import History from "./pages/History.svelte";<br/>	import Home from "./pages/Home.svelte"<br/>	<br/>&lt;/script&gt;</span><span id="624a" class="lb jf hi kx b fi lj ld l le lf">&lt;style&gt;<br/>	main {<br/>		text-align: center;<br/>		padding: 1em;<br/>		max-width: 240px;<br/>		margin: 0 auto;<br/>		background-color: #d5274c;<br/>	}</span><span id="1920" class="lb jf hi kx b fi lj ld l le lf">	h1 {<br/>		color: #ff3e00;<br/>		text-transform: uppercase;<br/>		font-size: 4em;<br/>		font-weight: 100;<br/>	}</span><span id="c9e3" class="lb jf hi kx b fi lj ld l le lf">	@media (min-width: 640px) {<br/>		main {<br/>			max-width: none;<br/>		}<br/>	}<br/>&lt;/style&gt;</span><span id="78a7" class="lb jf hi kx b fi lj ld l le lf">&lt;Router&gt;<br/>	&lt;Navbar/&gt;<br/>	&lt;div class="container"&gt;<br/>		&lt;Route path="/" component={Home} /&gt;<br/>		&lt;Route path="/history" component={History} /&gt;<br/>	&lt;/div&gt;<br/>&lt;/Router&gt;</span></pre><p id="d4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们不要担心组件的样式，让我们关注于<code class="du lg lh li kx b">script</code>部分。除了导入Materialize CSS，我们还导入了使用<code class="du lg lh li kx b">Router</code>所需的元素。此外，我们正在导入<code class="du lg lh li kx b">Home</code>和<code class="du lg lh li kx b">History</code>组件，因此我们可以将路线与页面链接起来。现在<code class="du lg lh li kx b">Router</code>标签负责分配<code class="du lg lh li kx b">Links</code>和<code class="du lg lh li kx b">Routes</code>，所以当你改变URL时，Svelte将知道加载哪个组件。<code class="du lg lh li kx b">Route</code>标签用于链接一个URL和一个组件，而<code class="du lg lh li kx b">Link</code>标签(类似于<code class="du lg lh li kx b">Navbar</code>上使用的标签)在点击时为文本按钮分配一个URL的变化。通过将我们的<code class="du lg lh li kx b">Navbar</code>添加到<code class="du lg lh li kx b">Router</code>标签中，我们告诉Svelte这个组件能够使用<code class="du lg lh li kx b">svelte-routing</code>库改变路径。一个组件中可以有多个<code class="du lg lh li kx b">Routers</code>，但是只有<code class="du lg lh li kx b">Router</code>中的组件可以使用<code class="du lg lh li kx b">svelte-routing</code>库。</p><h1 id="486d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">为什么我们使用苗条路线？</h1><p id="5702" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们使用<code class="du lg lh li kx b">svlete-routing</code>是因为我们使用客户端渲染。这意味着当你进入应用程序时，你是负责渲染网站的计算机，而不是世界上某个地方的服务器。这主要取决于你在做什么，但是如果你正在使用一个像Svelte这样的框架，让应用程序的前端成为一个客户端渲染应用程序是很有意义的。</p><h1 id="0244" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">让我们提出一些建议</h1><p id="2c73" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在大量的设置之后，让我们把推荐作为教程的一部分。在<code class="du lg lh li kx b">Home</code>页面上，您可以复制并粘贴代码，我将解释这些代码背后的概念:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="e628" class="lb jf hi kx b fi lc ld l le lf">&lt;script&gt;<br/>    import Searchbar from '../components/Searchbar.svelte';<br/>    import MovieCard from '../components/MovieCard.svelte';<br/>    import { onMount } from "svelte";</span><span id="f2ab" class="lb jf hi kx b fi lj ld l le lf">    var movieCards = [];<br/>    var movieIds ={};<br/>    var loading = false;<br/>    var recommendations = [];<br/>    onMount(async () =&gt; {<br/>        const response = await fetch("&lt;http://localhost:8000/autocomplete&gt;")<br/>        movieIds = await response.json()<br/>        <br/>    });<br/>    function getMovieIds(movieTitle){<br/>        var movieIndex = movieIds[movieTitle];<br/>        return movieIndex<br/>    };<br/>    <br/>    async function postMovieRecommendations(movieIndexes){<br/>        loading = true;<br/>        var message;<br/>        <br/>        const response = await fetch("&lt;http://localhost:8000/movie/make_recom&gt;",<br/>                                    {<br/>                                        method: 'POST',<br/>                                        body: JSON.stringify(movieIndexes)<br/>                                    })<br/>        message = await response.json();<br/>        while(message["status"] == "inProgress"){<br/>            <br/>            const response = await fetch("&lt;http://localhost:8000/status/"+message["jobId&gt;"])<br/>            message = await response.json()<br/>        }<br/>        return message["recommendation"]<br/>    }<br/>    <br/>    async function makeRecommendations(){<br/>        var recom_index = [];<br/>        var i;<br/>        for(i = 0; i&lt;movieCards.length; i++){<br/>            var movIndx = getMovieIds(movieCards[i])<br/>            recom_index.push(movIndx)<br/>        }<br/>        var newMovies = await postMovieRecommendations(recom_index)<br/>        <br/>        for(i=0; i&lt;newMovies.length; i++){<br/>            recommendations = [...recommendations, newMovies[i]["title"]]<br/>        }<br/>        loading = false;<br/>    };</span><span id="20e9" class="lb jf hi kx b fi lj ld l le lf">    function clearRecommendations(){<br/>        recommendations = []<br/>        movieCards = []<br/>    }<br/>&lt;/script&gt;</span><span id="27bb" class="lb jf hi kx b fi lj ld l le lf">&lt;style&gt;<br/>&lt;/style&gt;</span><span id="bfe1" class="lb jf hi kx b fi lj ld l le lf">&lt;Searchbar bind:movieTitles={movieCards} /&gt;<br/>{#if loading == false}<br/>    {#if recommendations.length &lt; 1}<br/>        {#if movieCards.length &lt; 1}<br/>            &lt;div class="container"&gt;<br/>            &lt;h2&gt;You can add movies to get recommendations&lt;/h2&gt;<br/>            &lt;/div&gt;<br/>        {:else}<br/>            &lt;button class="btn waves-effect waves-light" type="submit" name="action" on:click={makeRecommendations}&gt;Recommend<br/>            &lt;/button&gt;<br/>            {#each movieCards as card}<br/>                    &lt;MovieCard movieTitle={card} /&gt;<br/>            {/each}<br/>        {/if}<br/>    {:else}<br/>        &lt;button class="btn waves-effect waves-dark" type="submit" name="action" on:click={clearRecommendations}&gt;Clear&lt;/button&gt;<br/>        {#each recommendations as card}<br/>            &lt;MovieCard movieTitle={card} /&gt;<br/>        {/each}<br/>    {/if}<br/>{:else}<br/>    &lt;div class="container"&gt;<br/>        &lt;img src="giphy.gif" alt="Making Recommendations"&gt;<br/>    &lt;/div&gt;<br/>{/if}</span></pre><p id="def2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从导入<code class="du lg lh li kx b">MovieCard</code>和<code class="du lg lh li kx b">Searchbar</code>组件开始，它们的定义如下。我们也在导入<code class="du lg lh li kx b">onMount</code>这是Svelte中的一个很棒的函数，它允许我们在页面中一呈现组件就运行代码，所以组件会在出现之前等待它运行。在这种情况下，我们使用它来调用我们的后端(在端点<code class="du lg lh li kx b">/autocomplete</code>)来获取我们数据库中所有电影的名称和id。</p><p id="4c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下函数是调用我们的后端生成推荐的函数。逻辑是我们有一个电影id列表和一个名为<code class="du lg lh li kx b">loading</code>的状态。然后我们将列表发送到我们的<code class="du lg lh li kx b">/movie/make_recom</code>，后端将返回一个<code class="du lg lh li kx b">jobId</code>和一个状态，我们将变量<code class="du lg lh li kx b">loading</code>设置为true。我们问我们的后端，如果我们的工作完成了，当我们等待时，我们将显示我们的gif。一旦工作完成，我们的后端将返回一个电影id列表，我们可以将它改回我们的电影名称。现在我们将能够在组件的<code class="du lg lh li kx b">main</code>部分在加载状态和推荐阶段之间切换。Svelte允许我们使用简单的逻辑，如<code class="du lg lh li kx b">if</code>语句或<code class="du lg lh li kx b">for</code>循环，如下例所示:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="367b" class="lb jf hi kx b fi lc ld l le lf">{#each recommendations as card}<br/>    &lt;MovieCard movieTitle={card} /&gt;<br/>{/each}</span></pre><p id="fd8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们为推荐的<code class="du lg lh li kx b">each</code>电影创建一个<code class="du lg lh li kx b">MovieCard</code>组件，并结束循环。我们将电影Id作为变量放在花括号中。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="8745" class="lb jf hi kx b fi lc ld l le lf">{#if loading == false}<br/>   /// ... code here<br/>{:else}<br/>    &lt;div class="container"&gt;<br/>        &lt;img src="giphy.gif" alt="Making Recommendations"&gt;<br/>    &lt;/div&gt;<br/>{/if}</span></pre><p id="a2c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们正在检查我们是否在等待一个作业，我们正在显示一个GIF(GIF可以在这里找到<a class="ae jd" href="https://giphy.com/gifs/eat-popcorn-snack-5bDaEqBgVZXfpY8Qdk" rel="noopener ugc nofollow" target="_blank">，并且必须保存在<code class="du lg lh li kx b">public</code>文件夹中)。这将允许我们根据条件改变状态。这个和更多的特性在官方的苗条教程中有更详细的解释。</a></p><h1 id="84cd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">电影卡组件</h1><p id="6489" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在<code class="du lg lh li kx b">components</code>文件夹中，创建名为<code class="du lg lh li kx b">MovieCard.svelte</code>的新文件。该组件将接收一个电影标题，并将呈现一张卡片。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="e7e2" class="lb jf hi kx b fi lc ld l le lf">&lt;script&gt;<br/>    export let movieTitle;<br/>&lt;/script&gt;</span><span id="3424" class="lb jf hi kx b fi lj ld l le lf">&lt;div class="row"&gt;<br/>&lt;div class="col s12 m6"&gt;<br/>    &lt;div class="card blue-grey darken-1"&gt;<br/>        &lt;div class="card-content white-text"&gt;<br/>            &lt;span class="card-title"&gt;{movieTitle}&lt;/span&gt;<br/>            <br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h1 id="3270" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">搜索栏组件</h1><p id="8b62" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这个组件是一个简单的搜索栏，具有自动完成功能。为了能够使用自动完成功能，我们需要数据库中所有电影的名称。然后我们初始化autocomplete并将其链接到搜索栏标签。有关更多信息，您可以查看物化CSS <a class="ae jd" href="https://materializecss.com/autocomplete.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="de9e" class="lb jf hi kx b fi lc ld l le lf">&lt;script&gt;<br/>    import { onMount } from "svelte";<br/>    let response = [];<br/>    export let movieTitles;<br/>    onMount(async () =&gt; {<br/>        const response = await fetch("&lt;http://localhost:8000/autocomplete&gt;")<br/>        var options = { data:  await response.json(),<br/>                        limit: 5};<br/>        var elems = document.querySelectorAll(".autocomplete");<br/>        var instances = M.Autocomplete.init(elems, options);<br/>    });<br/>    <br/>    function addNewMovie(){<br/>      var newMovie = document.getElementById("autocomplete-input").value<br/>      movieTitles = [...movieTitles, newMovie]<br/>    };<br/>   <br/>&lt;/script&gt;</span><span id="5048" class="lb jf hi kx b fi lj ld l le lf">&lt;style&gt;</span><span id="45ed" class="lb jf hi kx b fi lj ld l le lf">&lt;/style&gt;</span><span id="fd9b" class="lb jf hi kx b fi lj ld l le lf">&lt;div class="container"&gt;<br/>  &lt;div class="row"&gt;<br/>    &lt;div class="col s12"&gt;<br/>      &lt;div class="row"&gt;<br/>        &lt;div class="input-field col s12"&gt;<br/>          &lt;input type="text" id="autocomplete-input" class="autocomplete" /&gt;<br/>          &lt;label for="autocomplete-input"&gt;Movies&lt;/label&gt;<br/>          &lt;button class="btn waves-effect waves-light" type="submit" name="action" on:click={() =&gt; addNewMovie()}&gt;Add<br/>            &lt;i class="material-icons right"&gt;Movie&lt;/i&gt;<br/>          &lt;/button&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h1 id="1aaf" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="0718" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">现在，我们有了一个很好的方式来以有趣的方式展示模型，而不是笔记本或文本文件。Svelte是一个伟大的新框架，这意味着几件事。首先，没有很多人使用它，有些问题你可能在栈溢出上找不到答案。第二，不知道会不会有足够多的开发者采用。但是我确实发现Svelte背后的想法非常棒，框架的简单性、小的包大小和它的速度让我希望它将成为新的JavaScript开发人员的好去处。</p></div></div>    
</body>
</html>