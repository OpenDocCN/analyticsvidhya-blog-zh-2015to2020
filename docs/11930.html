<html>
<head>
<title>What is widening , truncation , promotion , and conversion between , the different C , arithmetic data types ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是不同C #算术数据类型之间的扩大、截断、提升和转换？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-widening-truncation-promotion-and-conversion-between-the-different-c-arithmetic-eb35f1ef1054?source=collection_archive---------24-----------------------#2020-12-23">https://medium.com/analytics-vidhya/what-is-widening-truncation-promotion-and-conversion-between-the-different-c-arithmetic-eb35f1ef1054?source=collection_archive---------24-----------------------#2020-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="23a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C语言  <em class="jd">中的<strong class="ih hj"> <em class="jd">算术数据类型为</em>整数类型，如<code class="du je jf jg jh b">int</code>或<code class="du je jf jg jh b">unsigned long</code>，浮点类型，如<code class="du je jf jg jh b"> float</code>或<code class="du je jf jg jh b"> long double</code>。</strong></em></p><h1 id="2ef4" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">整数类型的转换</h1><h2 id="7eef" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">什么是加宽？</h2><p id="3674" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">加宽<em class="jd">仅将</em>应用于<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-a-signed-integer/" rel="noopener ugc nofollow" target="_blank">有符号</a>和<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-an-unsigned-integer/" rel="noopener ugc nofollow" target="_blank">无符号</a>整数类型。不适用于其他类型，如<code class="du je jf jg jh b">float</code>或<code class="du je jf jg jh b">double</code>。</p><p id="203b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加宽不是从有符号转换到无符号，或者从无符号转换到有符号，而是扩展整数类型的有符号性，从较小的类型扩展到较大的类型，因此从较少的位数扩展到较大的位数。整数类型的<strong class="ih hj"> <em class="jd">有符号性不改变</em> </strong>。</p><p id="fa58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">对于有符号类型</em> </strong>，加宽是通过所谓的:<code class="du je jf jg jh b">sign extension</code>完成的。如果有符号类型的值为负，则通过用值<code class="du je jf jg jh b">1</code>填充新位来扩展它，如果有符号类型的值为非负，则通过用<code class="du je jf jg jh b">0</code>填充新分配的位来扩展它。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/56eb0bb94200df9b743ccd3a749b75f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ekgXfHlTGiJAIjis.jpeg"/></div></figure><p id="83cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">对于无符号类型</em> </strong>，新分配的位用<code class="du je jf jg jh b">0</code>填充</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/80d33892a6842f2ace756a623fd59695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LjWx7GR8-TQu_JDA.jpeg"/></div></figure><h2 id="3987" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">什么是截断？</h2><p id="e251" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">截断<strong class="ih hj"> <em class="jd">只发生在</em> </strong>整数类型，当从一个较大的整数类型传递到一个较小的整数类型时，例如，当从<code class="du je jf jg jh b">int</code>传递到<code class="du je jf jg jh b">char</code>或从<code class="du je jf jg jh b">unsigned int</code>传递到<code class="du je jf jg jh b">unsigned char</code>时，具有相同符号。</p><p id="8366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论是有符号的还是无符号的，通过丢弃位于较小类型宽度之外的较大类型的位，较大类型被<em class="jd">定制为</em> <strong class="ih hj"> <em class="jd">适合较小类型</em> </strong>，仅保留较低阶位。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/259a8a8005f0092a7b479a46d4d7db64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6iApI7vt4UEbvV_R.jpeg"/></div></figure><p id="309a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，截断仅保留有限数量的位，<strong class="ih hj"> <em class="jd">在将</em> </strong> <em class="jd"> </em>从浮点类型转换为整数类型或在浮点类型之间转换时不会发生。<br/>从浮点类型转换为整数类型时，小数部分被丢弃，浮点类型位不适合整数类型宽度，但浮点类型从浮点表示转换为整数表示。</p><h2 id="15c1" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">整数转换程序</h2><p id="5cb9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">整数类型的转换，<strong class="ih hj"> <em class="jd">包括</em> </strong> <em class="jd"> </em>首先执行扩大或截断，然后重新解释位。因此首先执行截断或加宽。截断或加宽<strong class="ih hj"> <em class="jd">不会改变字体的符号性</em> </strong>，字体只是为了适应更大或更窄的宽度，具有相同的符号性。<br/>在执行了加宽或截断之后，目标宽度中得到的位仅<strong class="ih hj">被<em class="jd">重新解释为属于</em> </strong>新的整数类型，即目标类型。</p><p id="9f2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">这个规则</em> </strong>唯一的例外，就是当转换为<code class="du je jf jg jh b">_Bool</code>类型时，任何非零值都转换为<code class="du je jf jg jh b">1</code>，而任何零值都转换为<code class="du je jf jg jh b">0</code>。</p><p id="155a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解释了整数类型的转换是如何发生的之后，让我们先解释整数<code class="du je jf jg jh b">rank</code>、<strong class="ih hj">、<em class="jd">的概念，然后再解释何时发生到另一个整数类型</em>、</strong>的转换。</p><h2 id="1a41" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">什么是等级？</h2><p id="b305" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">C中每个整数类型都有一个秩</em>。</strong></p><p id="44a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">的<code class="du je jf jg jh b">unsigned</code>和<code class="du je jf jg jh b">signed</code>整数类型</em> <strong class="ih hj"> <em class="jd">不分符号</em> </strong>，具有相同的等级。例如<code class="du je jf jg jh b">int</code>和<code class="du je jf jg jh b">unsigned int</code>，具有相同的等级。</p><p id="c98a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整数类型的<strong class="ih hj"> <em class="jd">等级</em> </strong>顺序如下:</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="203f" class="kg jj hi jh b fi lm ln l lo lp">_Bool &lt; signed char &lt; short &lt; int &lt; long &lt; long long</span></pre><p id="adbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面概述的任何标准整数类型的秩大于任何实现定义的 的<strong class="ih hj"> <em class="jd">秩，具有相同的宽度。</em></strong></p><p id="ec06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kz" href="https://twiserandom.com/c/what-is-char-signed-char-unsigned-char-and-character-literals-in-c/" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> char </em> </a> <em class="jd">和</em> <code class="du je jf jg jh b"><em class="jd">signed char</em></code>整数类型，具有相同的秩。</p><p id="80e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个  <a class="ae kz" href="https://twiserandom.com/c/what-is-an-enum-in-c/" rel="noopener ugc nofollow" target="_blank">枚举</a>类型的<strong class="ih hj"> <em class="jd">秩等于它的赋值实现，定义的整数类型。</em></strong></p><h2 id="f4c4" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">整数提升</h2><p id="c5e6" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">整数类型，其中<strong class="ih hj"> <em class="jd">具有比<code class="du je jf jg jh b">int</code>小的</em> </strong>，每个都被提升为<code class="du je jf jg jh b">int</code>类型，如果<code class="du je jf jg jh b">int </code>类型可以表示其所有可能的值，或者在其他情况下被提升为<code class="du je jf jg jh b">unsigned int</code>类型。</p><p id="3233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 运算符期望其操作数之一是算术类型时，秩小于<code class="du je jf jg jh b">int</code>，<strong class="ih hj"> <em class="jd">的整数类型被提升。C #中的算术类型是整数或浮点类型。这种运算符的一个例子是减法运算符<code class="du je jf jg jh b">-</code>，或者一元否定运算符<code class="du je jf jg jh b">-</code>。</em></strong></p><p id="defb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整数提升，不是整数如何转换成另一种类型，<strong class="ih hj"> <em class="jd">是当</em> </strong> <em class="jd"> </em>一个整数转换成另一种类型，在这种情况下是因为它的秩比<code class="du je jf jg jh b">int</code>低。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="1ba8" class="kg jj hi jh b fi lm ln l lo lp">unsigned char x = 1;<br/>signed char y = -x;<br/>/* <br/>x , is an unsigned char type , <br/>  it has a rank lower than int .<br/>The unary negation operator is <br/>  used , as such x must be promoted . <br/>An int on 32 bits systems , have a <br/>  typical width of 32 bits , as such <br/>  it can store all the possible values<br/>  of an unsigned char , which is limited<br/>  to only 8 bits . As such the target<br/>  promotion type is an int .<br/>Now that the target type is decided , <br/>  which is an int , it has a larger<br/>  width than an unsigned char , as<br/>  such widening must be performed . <br/>Widening does not change  signedness ,<br/>  so the unsigned char is widened to an<br/>  unsigned int , by using zero fill . <br/>The resulting value is 1 ,  and has a bit <br/>  representation of : <br/>  00000000000000000000000000000001<br/>The resulting bits , are interpreted as if , <br/>   as being of the type signed int , and the<br/>   negation operator is applied .<br/>The result of the negation operator is -1 , <br/>   which , has a bit representation of :<br/>    11111111111111111111111111111111<br/>The value is to be stored in a signed <br/>  char type , both int and signed char ,<br/>  have the same signedness , as such <br/>  truncation is applied .<br/>The width of a signed char type is <br/>  8 bits , as such the leading 24 bits <br/>  are discarded , and the result is : <br/>  11111111 , which is equal to -1 . */</span></pre><h2 id="401c" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">函数调用或返回值</h2><p id="5cd9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当进行函数调用时，一个<strong class="ih hj"> <em class="jd">参数是整数类型</em> </strong> <em class="jd">，不同于目标参数的整数类型</em>，发生类型转换。</p><p id="fe46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变元被<strong class="ih hj"> <em class="jd">转换为参数类型</em> </strong>，首先被截断或加宽到相同的宽度，然后重新解释目标参数类型的位。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="d28a" class="kg jj hi jh b fi lm ln l lo lp">#include&lt;stdio.h&gt;</span><span id="adad" class="kg jj hi jh b fi lq ln l lo lp">void trivialFunction( unsigned int val){<br/>  if( val == 4294967295){<br/>    printf( "%u is equal to 4294967295\n" , val);<br/>  }<br/>  else{<br/>    printf( "%u is different from 4294967295\n" , val);}}</span><span id="5e26" class="kg jj hi jh b fi lq ln l lo lp">int main( void){<br/>  signed char x = -1 ;  <br/>  trivialFunction( x);<br/>  unsigned char y = x ;<br/>  trivialFunction( y);}</span><span id="18a2" class="kg jj hi jh b fi lq ln l lo lp">/* Output<br/>4294967295 is equal to 4294967295<br/>255 is different from 4294967295<br/>*/</span><span id="4467" class="kg jj hi jh b fi lq ln l lo lp">/*<br/>In the first call to trivialFunction , <br/>  the passed argument is of type signed <br/>  char . trivialFunction expects its <br/>  argument , to be of the type unsigned <br/>  int , as such the argument must be <br/>  converted .<br/>First widening to the same width of <br/>  unsigned int takes place . <br/>x is a signed char , as such it is <br/>  widened to a signed int , by sign<br/>  extension . The value of x is -1 , <br/>  and it has a bit representation of <br/>  11111111 . The resulting value is -1 ,<br/>  and it has a bit representation of <br/>  11111111111111111111111111111111 .<br/>This bit pattern , is next reinterpreted<br/>  as an unsigned int , so<br/>  11111111111111111111111111111111 ,  <br/>  as an unsigned int , has a value of <br/>  4294967295 . This is why trivialFunction<br/>  prints : 4294967295 is equal to 4294967295</span><span id="876d" class="kg jj hi jh b fi lq ln l lo lp">The variable y , has a type of unsigned <br/>  char . It is assigned the value of x , <br/>  which is a signed char .<br/>Both x , and y have the same width , as such <br/>  no widening occurs , only the bits of x ,<br/>  are reinterpreted as being unsigned .<br/>The bits of x , has a value of -1 , which is <br/>  11111111 , when reinterpreted as unsigned ,<br/>  this yield the value of 255 . <br/>Next trivialFunction is called with y , <br/>  as a parameter . <br/>Widening occurs  , because y is an unsigned <br/>  char , and the function parameter is an <br/>  unsigned int . It is done by using <br/>  zero fill . <br/>Hence the value of 1 which has a bit <br/>  representation of 11111111 , is widened <br/>  to the value 255 which has a bit <br/>  representation of : <br/>  00000000000000000000000011111111 <br/>The function prints : <br/>  255 is different from 4294967295 <br/>*/</span></pre><p id="4f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当函数的返回值<strong class="ih hj"> <em class="jd">不同于其返回类型</em> </strong>时，返回值被转换为函数的返回类型。</p><h2 id="7274" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">分配和初始化</h2><p id="fcce" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当使用<code class="du je jf jg jh b">=</code>运算符对整数变量执行<strong class="ih hj"> <em class="jd">赋值或初始化</em> </strong>时，如果要赋值的表达式属于不同的整数类型，则会发生整数转换。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="55ec" class="kg jj hi jh b fi lm ln l lo lp">unsigned char x = 1 ; <br/>/*<br/>1 is an integral literal ,  it is <br/>  of the type int . <br/>The type int has a typical width <br/>  of 32 bits , while an unsigned <br/>  char has a typical width <br/>  of 8 bits .<br/>The bits of the int type <br/>  00000000000000000000000000000001<br/>  are reinterpreted as  being the <br/>  bits of an unsigned int type . <br/>  The result is :<br/>  00000000000000000000000000000001 <br/>The unsigned int value is truncated to <br/>  8 bits , and the value gotten is <br/>  00000001 , which is assigned to <br/>  the unsigned char x .*/</span></pre><p id="b922" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">关于整数文字量</em> </strong>类型的进一步信息，可以查看这篇<a class="ae kz" href="https://difyel.com/c/literal/integer-literals-in-c/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h2 id="8b89" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">算术运算符</h2><p id="783b" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当<strong class="ih hj"> <em class="jd">使用以下运算符</em> </strong>之一时，将发生整数转换。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="37d3" class="kg jj hi jh b fi lm ln l lo lp">* / % + -  <br/>/* <br/>Multiplication , division , <br/>  modulos , addition , <br/> subtraction  .*/</span><span id="658b" class="kg jj hi jh b fi lq ln l lo lp">&lt; &lt;= &gt; &gt;= == !=  <br/>/*<br/> Relational less , less or equal , <br/>  larger , larger or equal , <br/>  equal , not equal .*/</span><span id="6417" class="kg jj hi jh b fi lq ln l lo lp">&amp; ^ | <br/>/* <br/>Bitwise and , xor , or .*/</span><span id="d17c" class="kg jj hi jh b fi lq ln l lo lp">?: <br/>/* <br/>The Ternary operator expression , <br/>  must return a value of a specific <br/>  type , the second and third operand , <br/>  are converted to a same type . */</span><span id="962d" class="kg jj hi jh b fi lq ln l lo lp">+=  -=  *=  /=  %=  &amp;=   ^=  |=  <br/>/* operate and assign operators  */</span></pre><p id="7cc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这些操作符的情况下，<strong class="ih hj"> <em class="jd">一个普通的类型</em> </strong>为必须确定的操作数和结果。这是按照下表的指定来完成的。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es lr"><img src="../Images/def543b945ee36e257aec96a43727d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*tzeEiSzHDTkdSApWMCUIVg.png"/></div></figure><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="32d0" class="kg jj hi jh b fi lm ln l lo lp">int si = -1 ; <br/>unsigned int ui = 0 ;</span><span id="d071" class="kg jj hi jh b fi lq ln l lo lp">ui = ui + si ; <br/>/*<br/>int , and unsigned int , have the same <br/>  rank , one is signed , and the other <br/>  is unsigned , as such both operands , <br/>  must be converted to the unsigned int <br/>  type , and the result of the operation ,<br/>  is of an the unsigned int type . <br/>ui is unsigned , so no conversion is <br/>  necessary . <br/>To convert si , to the unsigned int type , <br/>  and since both si and ui have the same <br/>  width , the bits of si , which are <br/>  11111111111111111111111111111111 ,<br/>  are kept as is , they are only reinterpreted<br/>  as belonging to a signed type , so now<br/>  they have a value of 4294967295 . <br/>The addition is performed , and the result <br/>  of the addition operation , is as such :<br/>  4294967295 + 0 = 4294967295 , and is<br/>  of the type unsigned int . <br/>ui is of type unsigned int , as such <br/>  no conversion is necessary , and the <br/>  result of 4294967295 is stored in ui .<br/>*/</span><span id="b8f5" class="kg jj hi jh b fi lq ln l lo lp">long long lli = -1 ; <br/>ui = lli + ui ; <br/>/*<br/>lli is of the type long long , <br/>  it has a higher rank than <br/>  unsigned int . long long <br/>  can hold all the values of <br/>  unsigned int , as such , <br/>  both operands must be of<br/>  the type long long . <br/>lli is of the type long long , <br/>  so no conversion is necessary . <br/>ui is an unsigned int , it has <br/>  a bit representation of <br/>  11111111111111111111111111111111<br/>  it is first extended to unsigned <br/>  long by using zero fill . <br/>  0000000000000000000000000000000011111111111111111111111111111111<br/>  After that , the gotten bits are <br/>  reinterpreted as being of type <br/>  long long . The gotten value , is <br/>  the same as the value of ui , which <br/>  is 4294967295 .  <br/>The addition is  performed between , <br/>  the two long long integer types , and <br/>  the result is -1 + 4294967295 , which<br/>  is equal to 4294967294 , and is of <br/>  the type long long .<br/>ui is of the type unsigned int , the result<br/>  which is of the type long long  must <br/>  be converted to unsigned int  .<br/>It is first converted to unsigned long long , <br/>  the bits pattern does not change ,  so it remains <br/>  0000000000000000000000000000000011111111111111111111111111111110 .<br/>  Now that is is of the type unsigned long long , <br/>  it is truncated to the type of ui , which is <br/>  unsigned int , and it has the format : <br/>  11111111111111111111111111111110  , <br/>  and a value of : 4294967294 .<br/>*/</span><span id="008e" class="kg jj hi jh b fi lq ln l lo lp">long int li  = -1 ; <br/>li = li + ui ;<br/>/*<br/>ui is an unsigned int , whereas li<br/>  is a long int . A long int has <br/>  a higher rank than an unsigned <br/>  int . Assuming that on this machine , <br/>  both long int and unsigned int have<br/>  a width of 32 bits , this means <br/>  that long int is not capable of <br/>  representing all the possible values <br/>  of the unsigned int type , as such <br/>  the operands , and the result <br/>  must be of the unsigned long type . <br/>li bits are kept as is , and only<br/>  reinterpreted as being of the <br/>  type unsigned long , as such li <br/>  will have the value of 4294967295 .<br/>ui is converted to unsigned long , by <br/>  widening. unsigned int , and unsigned long <br/>  have the same width , as such the bits<br/>  of ui remains the same , <br/>  11111111111111111111111111111110 .<br/>Adding 4294967295 + 4294967294 = <br/>  8589934589 . The result is of <br/>  the type unsigned long , it cannot<br/>  fit the width of the unsigned <br/>  long type , which has a max <br/>  value of 4294967295 , as such <br/>  overflow has occurred . <br/>  The modulo of the result , with<br/>  regards to 2 to the power of <br/>  the number of bits ,<br/>  of the unsigned long type is taken . <br/>  This is equal to <br/>  8589934589 % 4294967296 = <br/>    4294967293 , which is <br/>  11111111111111111111111111111101 <br/>The result must be stored in li , <br/>  li is of the long type , the gotten<br/>  value is of the type unsigned long , <br/>  the bits are kept as is , and the <br/>  result is only reinterpreted as being <br/>  a signed long , as such the value <br/>  of li is -3 . <br/>*/</span></pre><p id="fa87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<em class="jd">有符号和无符号整数类型的溢出</em>信息，可以查看<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-a-signed-integer/" rel="noopener ugc nofollow" target="_blank">这篇</a>和<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-an-unsigned-integer/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章。</p><h2 id="24d5" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">演职人员</h2><p id="3247" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><code class="du je jf jg jh b"><strong class="ih hj"><em class="jd">Explicit</em></strong></code> <strong class="ih hj"> <em class="jd">转换发生在</em> </strong>中，使用铸造运算符:<code class="du je jf jg jh b">(Type) expression</code>时。例如，显式地将<code class="du je jf jg jh b">int</code>文字<code class="du je jf jg jh b">1</code>转换为<code class="du je jf jg jh b">long</code>类型</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="e15c" class="kg jj hi jh b fi lm ln l lo lp">(long) 1</span></pre><p id="5c46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用cast运算符时，这个<strong class="ih hj"> <em class="jd">称为</em> </strong> <code class="du je jf jg jh b">explicit</code>铸造，所有其他情况的转换，都称为<code class="du je jf jg jh b">implicit</code>铸造。</p><h1 id="14cb" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">浮点类型的转换</h1><h2 id="6c33" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">从一种浮点类型转换到另一种浮点类型</h2><p id="0d29" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">每个<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-a-floating-point-number/" rel="noopener ugc nofollow" target="_blank">浮点型</a>，都有不同的<a class="ae kz" href="https://twiserandom.com/c/what-is-a-float-double-long-double-and-a-floating-point-literal-in-c/" rel="noopener ugc nofollow" target="_blank">量程和精度</a>。因此，当将<strong class="ih hj"> <em class="jd">从具有较高</em> </strong>精度和范围的浮点类型传递到具有较小精度和范围的浮点类型时，可能会发生精度损失、下溢或上溢。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="7a0c" class="kg jj hi jh b fi lm ln l lo lp">double dbl = 16777217 ;<br/>float fl = dbl ; <br/>/*<br/>Loss of precision , fl value is<br/>  16777216 .*/</span><span id="307e" class="kg jj hi jh b fi lq ln l lo lp">dbl = 1.2e-50 ; <br/>fl = dbl ; <br/>/*<br/>Underflow occurs , the behavior <br/>  is implementation defined , <br/>  in this case , fl has a value <br/>  of 0 .*/</span><span id="bffb" class="kg jj hi jh b fi lq ln l lo lp">dbl = 3.4e100;<br/>fl = dbl ;<br/>/*<br/>Overflow occurs , the behavior <br/>  is implementation defined , <br/>  fl has a value <br/>  of positive infinity */</span></pre><p id="9161" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当从具有较小范围和精度的浮点类型<strong class="ih hj"><em class="jd"/></strong><em class="jd">传递到具有较高范围和精度的浮点类型</em>时，不会发生精度损失、下溢或上溢。精度和范围保持不变。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="7ec5" class="kg jj hi jh b fi lm ln l lo lp">float fl = 1.099511627776e12f;<br/>double dbl = fl ; <br/>/*<br/>precision and range are <br/>  preserved , dbl has a <br/>  value of :<br/>  1.099511627776e12f , <br/>  which is 2 to the <br/>  power 40 .*/</span></pre><h2 id="f3af" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">从浮点类型转换为整数类型</h2><p id="d5b6" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">将浮点类型转换为整数类型的过程，<strong class="ih hj"> <em class="jd">可以认为是</em> </strong>，就好像，首先将数字转换为十进制记数法，然后丢弃小数部分，然后用其<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-a-signed-integer/" rel="noopener ugc nofollow" target="_blank">有符号</a>或<a class="ae kz" href="https://twiserandom.com/data-structure-and-algorithms/what-is-an-unsigned-integer/" rel="noopener ugc nofollow" target="_blank">无符号表示法</a>来表示。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="1aae" class="kg jj hi jh b fi lm ln l lo lp">double dbl = 1.3f; <br/>unsigned char uc = (unsigned char) x ;  <br/>// uc is equal to 1</span><span id="d67c" class="kg jj hi jh b fi lq ln l lo lp">dbl  = -1.3f;<br/>uc = dbl  ; <br/>// uc is equal to 255</span></pre><p id="593f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果浮点数<strong class="ih hj"> <em class="jd">太大而不能用整数类型表示</em> </strong>，那么这种行为不是由C标准定义的，而是由实现定义的。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="f51d" class="kg jj hi jh b fi lm ln l lo lp">double dbl = 3.4E30 ;</span><span id="320f" class="kg jj hi jh b fi lq ln l lo lp">unsigned long ul  = dbl ; //ul is equal to 0<br/>unsigned int ui  = dbl ; //ui is equal to 0<br/>unsigned char uc  = dbl ; //uc is equal to 0</span><span id="3b5b" class="kg jj hi jh b fi lq ln l lo lp">long li  = dbl ; //li is equal to -9223372036854775808<br/>int si  = dbl ; //si is equal to -2147483648<br/>signed char sc  = dbl ; //sc is equal to 0</span></pre><h2 id="2b07" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">从整数类型转换为浮点类型</h2><p id="5206" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">将整数类型转换为浮点类型时，<strong class="ih hj"> <em class="jd">整数值始终可以用</em>表示</strong>，但可能会损失<a class="ae kz" href="https://twiserandom.com/c/what-is-a-float-double-long-double-and-a-floating-point-literal-in-c/#Floating_point_precision" rel="noopener ugc nofollow" target="_blank">精度</a>。</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="7169" class="kg jj hi jh b fi lm ln l lo lp">int si = 16777216 ; <br/>float fl = si ;  // fl is equal to 16777216</span><span id="d1d0" class="kg jj hi jh b fi lq ln l lo lp">si = 16777217 ; <br/>float fl = si ; // fl is equal to 16777216</span></pre><h2 id="6af6" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">转换发生在什么时候？</h2><p id="201e" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当涉及浮点类型时，<strong class="ih hj"> <em class="jd">转换发生</em> </strong>，当进行函数调用，且传递的实参与函数形参的类型不同，或当函数的返回值与其返回类型不同时。</p><p id="e991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当执行浮点变量、赋值和初始化时，也会发生这种情况。最后，当使用算术运算符时，或者当使用显式强制转换(如<code class="du je jf jg jh b">(float) 1.0</code>)显式完成时，会出现这种情况。</p><h2 id="bbc9" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">浮点类型的等级</h2><p id="49df" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">一个浮点类型的秩，<em class="jd">是</em> <strong class="ih hj"> <em class="jd">总是高于</em> </strong>一个整数类型的秩，所以一个整数类型，总是被转换成浮点类型。</p><p id="ecf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于浮点类型，它们有以下<em class="jd">等级</em>:</p><pre class="lb lc ld le fd li jh lj lk aw ll bi"><span id="2708" class="kg jj hi jh b fi lm ln l lo lp">float &lt; double &lt; long double</span></pre><p id="0478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个算术运算，<strong class="ih hj"> <em class="jd">涉及两个不同秩的浮点类型</em> </strong>，则秩较低的浮点类型转换为秩较高的浮点类型。</p><p id="23c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">涉及浮点类型的运算的结果  <em class="jd"> </em>的<strong class="ih hj"> <em class="jd">类型与排序算法确定的类型相同。</em></strong></p><h2 id="ae23" class="kg jj hi bd jk kh ki kj jo kk kl km js iq kn ko jw iu kp kq ka iy kr ks ke kt bi translated">浮点类型提升</h2><p id="358c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">与整数类型提升一样，在执行算术运算时，浮点类型<strong class="ih hj"> <em class="jd">可以提升</em> </strong>，成为具有更高精度和范围的类型。</p><p id="38ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是<strong class="ih hj"> <em class="jd">不要与</em> </strong>混淆转换是如何发生的，或者在哪个秩中执行，涉及浮点类型的算术运算，它总是使用较高的操作数秩来执行。</p><p id="8985" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">推广规则，在</em> </strong>宏<code class="du je jf jg jh b">FLT_EVAL_METHOD</code>中定义，在<code class="du je jf jg jh b">float.h</code>表头中定义。</p><p id="0817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du je jf jg jh b">FLT_EVAL_METHOD</code>被设置为<code class="du je jf jg jh b">0</code>，那么算术运算以最宽操作数的类型完成，所以如果两个操作数都是<code class="du je jf jg jh b">float</code>，算术运算使用<code class="du je jf jg jh b">float</code>类型完成，所以不发生提升。</p><p id="4d86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du je jf jg jh b">FLT_EVAL_METHOD</code>被设置为<code class="du je jf jg jh b">1</code>，则通过将操作数提升为<code class="du je jf jg jh b">long double</code>来执行算术运算，如果任何操作数是<code class="du je jf jg jh b">long double</code>类型，否则操作数被提升为<code class="du je jf jg jh b">double</code>类型，即使两个操作数都是<code class="du je jf jg jh b">float</code>类型。</p><p id="1a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du je jf jg jh b">FLT_EVAL_METHOD</code>被设置为<code class="du je jf jg jh b">2</code>，则通过将操作数提升为<code class="du je jf jg jh b">long double</code>类型来执行算术运算。</p><p id="a573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du je jf jg jh b">FLT_EVAL_METHOD</code>设置为<code class="du je jf jg jh b">-1</code>，则行为未定义。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="6333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">原载于2020年12月23日</em><a class="ae kz" href="https://twiserandom.com/c/what-is-widening-truncation-promotion-and-conversion-between-the-different-c-arithmetic-data-types/" rel="noopener ugc nofollow" target="_blank"><em class="jd">https://twiserandom.com</em></a><em class="jd">。</em></p></div></div>    
</body>
</html>