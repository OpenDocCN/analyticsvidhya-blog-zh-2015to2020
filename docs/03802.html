<html>
<head>
<title>Backtracking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">追踪</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/backtracking-42aee84b5e39?source=collection_archive---------13-----------------------#2020-02-19">https://medium.com/analytics-vidhya/backtracking-42aee84b5e39?source=collection_archive---------13-----------------------#2020-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c276" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用回溯的总结可以在这里找到<a class="ae jd" href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-%28Subsets-Permutations-Combination-Sum-Palindrome-Partioning%29" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c5f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想通过解决几个leetcode问题来演示如何使用这个算法。</p><h2 id="f860" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><a class="ae jd" href="https://leetcode.com/problems/subsets/" rel="noopener ugc nofollow" target="_blank"> 78。子集</a></h2><p id="e2b2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">递归(32毫秒)</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="3007" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def subsets(self, nums: List[int]) -&gt; List[List[int]]:<br/>        if len(nums)==0:return [[]]<br/>        if len(nums)==1:return [[], nums]<br/>        res = self.subsets(nums[1:])<br/>        return res+[[nums[0]]+r for r in res]</span></pre><p id="f919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迭代(24毫秒)</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a34b" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def subsets(self, nums: List[int]) -&gt; List[List[int]]:<br/>        res = [[]]<br/>        for num in nums:<br/>            res += [[num] + r for r in res]<br/>        return res</span></pre><p id="6cf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Itertools.product</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="60ad" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def subsets(self, nums: List[int]) -&gt; List[List[int]]:<br/>        return [[x for x in l if x is not None] for l in itertools.product(*zip(nums, [None]*len(nums)))]</span></pre><p id="d5e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">位操作</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5b4c" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def subsets(self, nums: List[int]) -&gt; List[List[int]]:<br/>        def f(i):<br/>            return [nums[j] for j in range(len(nums))<br/>                    if i &amp; (1&lt;&lt;j)]<br/>        return [f(i) for i in range(1&lt;&lt;len(nums))]</span></pre><h1 id="c036" class="kr jf hi bd jg ks kt ku jk kv kw kx jo ky kz la jr lb lc ld ju le lf lg jx lh bi translated">C++</h1><h2 id="c36d" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">循环</h2><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="58ef" class="je jf hi kj b fi kn ko l kp kq">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;vector&lt;int&gt;&gt; res = {{}};<br/>        for(auto &amp;num:nums){<br/>            const int n=res.size();<br/>            for(int j=0;j&lt;n;++j){<br/>                res.push_back(res[j]);<br/>                res.back().push_back(num);<br/>            }<br/>        }<br/>        return res;<br/>         <br/>    }<br/>};</span></pre><h2 id="68f2" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">追踪</h2><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="d8c3" class="je jf hi kj b fi kn ko l kp kq">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;vector&lt;int&gt;&gt; res;<br/>        vector&lt;int&gt; this_res;<br/>        subsets(nums, 0, this_res, res);<br/>        return res;<br/>    }<br/>private:<br/>    void subsets(vector&lt;int&gt;&amp; nums, int i, vector&lt;int&gt;&amp; this_res, vector&lt;vector&lt;int&gt;&gt;&amp; res) {<br/>        res.push_back(this_res);<br/>        for (int j = i; j &lt; nums.size(); j++) {<br/>            this_res.push_back(nums[j]);<br/>            subsets(nums, j + 1, this_res, res);<br/>            this_res.pop_back();<br/>        }<br/>    }<br/>};</span></pre><p id="1609" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“[1，2，3]”输入的输出</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5ec3" class="je jf hi kj b fi kn ko l kp kq">[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></pre><p id="90f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回溯过程如下所示:</p><figure class="ke kf kg kh fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/57f0ff75acc39396e2447437b9fc53b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6iVikQxwNfQZNQ0yeqmDyg.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">回溯过程</figcaption></figure><p id="953c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">位操作</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="817e" class="je jf hi kj b fi kn ko l kp kq">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {<br/>        int n=1&lt;&lt;nums.size();<br/>        vector&lt;vector&lt;int&gt;&gt; res(n);<br/>        for(int i=0;i&lt;n;++i){<br/>            for(int j=0;j&lt;nums.size();++j){<br/>                if((1&lt;&lt;j)&amp;i)res[i].push_back(nums[j]);<br/>            }<br/>        }<br/>        return res;<br/>    }<br/>};</span></pre><p id="5e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="2e32" class="je jf hi kj b fi kn ko l kp kq">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {<br/>        int n = nums.size(), p = 1 &lt;&lt; n;<br/>        vector&lt;vector&lt;int&gt;&gt; subs(p);<br/>        for (int i = 0; i &lt; p; i++) {<br/>            for (int j = 0; j &lt; n; j++) {<br/>                if ((i &gt;&gt; j) &amp; 1) {<br/>                    subs[i].push_back(nums[j]);<br/>                }<br/>            }<br/>        }<br/>        return subs;<br/>    }<br/>};</span></pre><h2 id="8c5e" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><a class="ae jd" href="https://leetcode.com/problems/n-queens/" rel="noopener ugc nofollow" target="_blank"> N皇后区</a></h2><p id="2fc0" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">Python代码</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ab9c" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def solveNQueens(self, n: int) -&gt; List[List[str]]:<br/>        def dfs(queens, xy_dif, xy_sum):<br/>            p = len(queens)<br/>            if p==n:<br/>                result.append(queens)<br/>                return None<br/>            for q in range(n):<br/>                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: <br/>                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  <br/>        result = []<br/>        dfs([],[],[])<br/>        return [ ["."*i + "Q" + "."*(n-i-1) for i in sol] for sol in result]</span></pre><figure class="ke kf kg kh fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lu"><img src="../Images/9f610e51417f174d550579f058b958ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PmoeRI0Yn_5maNNP.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">参考<a class="ae jd" href="https://daisyleetcode2014.wordpress.com/2014/05/12/n-queens%E8%A7%A3%E6%B3%95-dfs/" rel="noopener ugc nofollow" target="_blank">https://daisyleetcode 2014 . WordPress . com/2014/05/12/n-queens % E8 % A7 % A3 % E6 % B3 % 95-DFS/</a></figcaption></figure><p id="755a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以稍微修改一下python代码。这是一个非常清晰的回溯解决方案。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="4d96" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def solveNQueens(self, n: int) -&gt; List[List[str]]:<br/>        def dfs(queens, rc_dif, rc_sum):<br/>            r = len(queens)<br/>            if r==n:<br/>                results.append(queens)<br/>                return None<br/>            for c in range(n):<br/>                rc_d, rc_s = r-c+n-1, r+c<br/>                if c not in queens and not rc_dif[rc_d] and not rc_sum[rc_s]: <br/>                    rc_dif[rc_d], rc_sum[rc_s] = 1, 1<br/>                    dfs(queens+[c], rc_diff, rc_sum) <br/>                    rc_dif[rc_d], rc_sum[rc_s] = 0, 0<br/>        results = []<br/>        rc_diff, rc_sum = [0]*(2*n), [0]*(2*n)<br/>        dfs([],rc_diff, rc_sum)<br/>        return [ ["."*i + "Q" + "."*(n-i-1) for i in sol] for sol in results]</span></pre><p id="96dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上图片参考的C++代码。它相当快。运行时间只有4毫秒左右。</p><p id="ade3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按行</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="3460" class="je jf hi kj b fi kn ko l kp kq">class Solution {<br/>public:<br/>    vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) {<br/>        vector&lt;vector&lt;string&gt;&gt; results;<br/>        vector&lt;int&gt; q_pos_row;<br/>        solveNQueens(results, q_pos_row, 0, n);<br/>        return results;<br/>    }<br/>    <br/>    void solveNQueens(vector&lt;vector&lt;string&gt; &gt; &amp;results, vector&lt;int&gt; &amp;q_pos_row, int row, int n)<br/>    {<br/>        if (row == n)<br/>            convert(results, q_pos_row);//one solution is put into the result vector<br/>        else{<br/>            for(int col=0;col&lt;n;++col){<br/>                if (is_valid(q_pos_row, row, col)){<br/>                    q_pos_row.push_back(col);<br/>                    solveNQueens(results, q_pos_row, row+1,n);<br/>                    q_pos_row.pop_back();<br/>                }<br/>            }<br/>        }<br/>        <br/>    }<br/>    <br/>    void convert(vector&lt;vector&lt;string&gt; &gt; &amp;results, vector&lt;int&gt; &amp;q_pos_row){<br/>        int n = q_pos_row.size();<br/>       vector&lt;string&gt;path;<br/>        for(int i=0;i&lt;n;++i){<br/>            string s(n,'.');<br/>            s[q_pos_row[i]] = 'Q';<br/>            path.push_back(s);<br/>        }<br/>        results.push_back(path);<br/>    }<br/>    <br/>    bool is_valid(vector&lt;int&gt; &amp;q_pos_row, int row, int col){<br/>        for(int i=0;i&lt;q_pos_row.size();++i){<br/>            if(col==q_pos_row[i] || abs(row-i)==abs(col-q_pos_row[i]))return false;<br/>        }<br/>        return true;<br/>        <br/>    }<br/>};</span></pre><h2 id="29f1" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><a class="ae jd" href="https://leetcode.com/problems/generate-parentheses" rel="noopener ugc nofollow" target="_blank"> 22。生成括号</a></h2><p id="b5e6" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">追踪</p><p id="e1c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以选择的每一步</p><ol class=""><li id="1721" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated">添加”(“如果左&gt; 0，则有效</li><li id="d148" class="lv lw hi ih b ii me im mf iq mg iu mh iy mi jc ma mb mc md bi translated">添加")"如果右&gt;左，则有效</li></ol><p id="718a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">left ==right ==0表示我们完成了。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="be44" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def generateParenthesis(self, n: int) -&gt; List[str]:<br/>        res = []<br/>        def generate(parenthesis, left, right):<br/>            if right ==0 and left == 0:  <br/>                res.append(parenthesis)<br/>                return<br/>            if left&gt;0:<br/>                generate(parenthesis + '(', left-1, right)<br/>            if right &gt; left:<br/>                generate(parenthesis + ')', left, right-1)<br/>        generate("", n, n)<br/>        return res</span></pre><h2 id="8bd6" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><a class="ae jd" href="https://leetcode.com/problems/word-search/" rel="noopener ugc nofollow" target="_blank"> 79。单词搜索</a></h2><h2 id="2f86" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">Python代码</h2><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="f7b9" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def exist(self, board: List[List[str]], word: str) -&gt; bool:<br/>        d = []<br/>        if not word or not word[0]:return bool(word)<br/>        if not word:return True<br/>        R, C = len(board), len(board[0])<br/>        for i in range(R):<br/>            for j in range(C):<br/>                if board[i][j] == word[0]:d.append((i,j))<br/>        if not d:return False<br/>        def dfs(seen, i,j, idx):<br/>            if idx == len(word)-1:return True<br/>            for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:<br/>                r, c =i+di, j+dj<br/>                if 0&lt;=r&lt;R and 0&lt;=c&lt;C and (r,c) not in seen and board[r][c]==word[idx+1] :<br/>                    seen.add((r,c))<br/>                    if dfs(seen, r, c, idx+1):return True<br/>                    seen.remove((r,c))<br/>            return False<br/>        return any(dfs({(i,j)},i,j, 0) for i,j in d)</span></pre><p id="0015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种更简洁的方法是通过修改纸板值来指示该位置是否可见</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a743" class="je jf hi kj b fi kn ko l kp kq">class Solution:<br/>    def exist(self, board: List[List[str]], word: str) -&gt; bool:<br/>        R, C = len(board), len(board[0])<br/>        def dfs(i, j, k):<br/>            if i&lt;0 or i&gt;=R or j&lt;0 or j&gt;=C:return False<br/>            if board[i][j]!=word[k]:return False<br/>            if k==len(word)-1:return True<br/>            old_val = board[i][j]<br/>            board[i][j] = '#'<br/>            if any(dfs(i+di, j+dj, k+1) <br/>                   for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]):return True<br/>            board[i][j] = old_val<br/>            return False<br/>        if any(dfs(i,j,0) for i in range(R) <br/>                          for j in range(C)<br/>                          if board[i][j] == word[0]):return True<br/>        return False</span></pre><h2 id="0f4a" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">C++代码</h2><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="81a6" class="je jf hi kj b fi kn ko l kp kq">class Solution {<br/>public:<br/>    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string &amp;word, int i, int j, int k)<br/>    {<br/>        if (i&lt;0 || i&gt;=board.size() || j&lt;0 || j&gt;=board[0].size())return false;<br/>        if(board[i][j]!=word[k])return false;<br/>        if (k==word.length()-1)return true;<br/>        auto original_val = board[i][j];<br/>        board[i][j] = '#';<br/>        if(dfs(board, word, i-1, j, k+1) ||<br/>           dfs(board, word, i, j-1, k+1) ||<br/>           dfs(board, word, i+1, j, k+1) ||<br/>           dfs(board, word, i, j+1, k+1)) return true;<br/>        board[i][j] = original_val ;<br/>        return false;<br/>    }<br/>    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {<br/>        const int R = board.size(), C = board[0].size();<br/>        for(int i = 0;i&lt;R;++i)<br/>            for(int j =0;j&lt;C;++j)<br/>                if(dfs(board, word, i, j, 0))return true;<br/>        return false;<br/>    }<br/>};</span></pre><p id="a6dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>