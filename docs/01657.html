<html>
<head>
<title>CAP Theorem Considered Harmful: Data integrity in NoSQL &amp; Alternatives to CAP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被认为有害的CAP定理:NoSQL的数据完整性&amp; CAP的替代方案</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cap-theorem-considered-harmful-data-integrity-in-nosql-alternatives-to-cap-904c24e390d5?source=collection_archive---------12-----------------------#2019-11-06">https://medium.com/analytics-vidhya/cap-theorem-considered-harmful-data-integrity-in-nosql-alternatives-to-cap-904c24e390d5?source=collection_archive---------12-----------------------#2019-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2197919d44be57c54b57d4c332ed0e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j2PIt_iwshL4F5kl"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">米卡·鲍梅斯特在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7484" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“最好避免CAP”。广受好评的分布式系统畅销书<a class="ae iu" href="https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321/ref=sr_1_2?keywords=designing+data+intensive+applications&amp;qid=1572997508&amp;sr=8-2" rel="noopener ugc nofollow" target="_blank">《设计数据密集型应用软件》</a>如是说。为什么？</p><p id="7cab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(所有引文均来自本书，除非另有说明)</p><p id="9914" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们打个赌:我给你42美元，然后你选择你想运行这些数据系统中的哪一个。</p><p id="a48c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">系统1:</p><p id="53e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端浏览器向web服务器发送请求，web服务器将该请求发送到SQL数据库:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8c4a" class="kc kd hi jy b fi ke kf l kg kh">BEGIN TRANSACTION;<br/>UPDATE bank_account SET balance = balance + 40.00 WHERE account_id = 'Me';<br/>UPDATE bank_account SET balance = balance - 40.00 WHERE account_id = 'You';<br/>COMMIT;</span></pre><p id="0d17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">系统2:</p><p id="c7e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端浏览器向web服务器发送请求，web服务器向分布在全球的高可用性NoSQL集群发送请求。在这个集群中，我的帐户存储在分区A(恰好位于夏威夷)，而您的帐户存储在分区B(恰好位于南极洲)。每个分区单独(没有协调)运行代码来更新我们的余额。</p><p id="6466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用系统#2，您可能会认为，因为系统#2使用高可用性集群，所以根据CAP定理，它在不可避免的网络分区期间无法保持一致。你已经听到人们警告NoSQL丢失和损坏数据。你已经听人们说过，“如果你正在执行一个金融交易，那么你最好使用一个ACID交易！”换句话说，也许你认为系统#2不能保证我们的余额转移的一次性处理。也许你希望转账会丢失，这样你就能保留所有的42美元。也许你害怕转账会因为多次处理而被破坏，最后你会欠我的。</p><p id="547a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你选择系统1，你可能会认为系统1保证我只拿回42美元中的40美元，这样你就多了2美元。毕竟，系统使用的是ACID事务，其中C代表一致。</p><p id="8e0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望您选择系统#1，因为我知道ACID交易不会保护您免于被多次收费。当然，我保留了系统#2中的一些细节，以保证您只被充电一次，即使该系统是容错的，其性能也是水平扩展的。</p><p id="a6ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">系统#2如何保证你只被收费一次？CAP定理证明了在网络划分期间不是一致的系统吧？实际上，CAP定理在这里并不适用:“许多所谓的‘高可用’(容错)系统实际上并不符合CAP对可用性的特质定义”，这是其中之一。事实上，只要大多数节点都有响应，您就可以拥有一个在网络分区期间既高度一致又“可用”的系统。我们可以使系统#2非常一致，但是我们没有。然而，它确实保证了强大的完整性。</p><p id="af70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯……如果我们可以在没有强一致性的情况下保证强完整性，那么强一致性给我们带来了什么额外的好处呢？它赋予了我们<em class="ki">极强的时效性</em>。</p><p id="5782" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ki">时效性强</em>意味着用户阅读最新状态。</p><p id="02c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ki">强完整性</em>意味着没有丢失或损坏的数据。</p><p id="5f5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两者经常被合并成“一致性”。</p><p id="9fbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一种常见的误解，认为只有强一致性才能保证强完整性。这是错误的。</p><p id="34f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理解系统#2 <em class="ki"/>如何保证你被精确地充电一次，在理解系统# 1<em class="ki">如何不</em>保证你被精确地充电一次之后，理解系统# 2<em class="ki">如何保证你被精确地充电一次会更容易。</em></p><p id="232c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，让我们首先检查系统#1的缺陷。</p><p id="b63e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">系统#1的问题在于，它是一个分布式系统(web浏览器、web服务器和数据库是联网的),只能在数据库级别保证很强的完整性，而不能在系统级别。</p><p id="2693" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么会出错？</p><p id="1c74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设web服务器向数据库发送事务请求，但是在web服务器收到数据库的响应之前，网络进行了分区。网络服务器不知道交易是否被处理。如果web服务器重新连接并重新发送事务，数据库实际上可能会处理两个事务。相反，如果web服务器在重新发送交易之前检查40美元的转账是否发生，它不知道该转账是否来自其请求。问题是我们在网络连接和事务之间有1:1的映射，导致事务不能容忍网络分区。我们可以通过使用2PC(两阶段提交)来消除这种1:1的映射，使web服务器-数据库网络分区具有容错性，保证在这一级上只进行一次处理。但是我们仍然有客户端浏览器。</p><p id="7fb7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端浏览器可以向web服务器发送事务请求，但是在客户端浏览器收到web服务器的响应之前，网络会进行分区。客户端浏览器不知道交易是否被处理，所以它告诉我有一个错误。我发出另一个请求。浏览器警告我:“您确定要重新提交此表单吗？”我说是的，因为我不知道我之前的提交工作，我想要我的钱。对web服务器来说，这是一个新的请求，对数据库来说，这是一个新的事务。(是的，在现实生活中，我不会发送提交此表单。如果一定要想象一个现实的场景，可以想象你想把房租钱转给室友。)</p><p id="684c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何保证系统级的一次性处理呢？我们需要一个端到端的操作id。</p><p id="969d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端浏览器可以在隐藏的表单字段中包含一个UUID，这样它就可以与初始请求和任何重试请求一起发送。web服务器将这个UUID传递给数据库，数据库保证它将只处理每个UUID一次。可能通过使用此SQL而不是上面的SQL:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="bd73" class="kc kd hi jy b fi ke kf l kg kh">CREATE TABLE requests (<br/>    request_id uuid PRIMARY KEY,<br/>    from_account varchar(40),<br/>    to_account varchar(40),<br/>    amount decimal(19, 4)<br/>);</span><span id="506e" class="kc kd hi jy b fi kj kf l kg kh">// The above table was created before our request</span><span id="d0e5" class="kc kd hi jy b fi kj kf l kg kh">BEGIN TRANSACTION;</span><span id="3701" class="kc kd hi jy b fi kj kf l kg kh">INSERT INTO requests<br/>    (request_id, from_account, to_account, amount)<br/>    VALUES('totally-a-valid-uuid', 'You', 'Me', 40.00);</span><span id="57ae" class="kc kd hi jy b fi kj kf l kg kh">UPDATE accounts SET balance = balance + 40.00 WHERE account_id = 'Me';<br/>UPDATE accounts SET balance = balanced - 40.00 WHERE account_id = 'You';</span><span id="294a" class="kc kd hi jy b fi kj kf l kg kh">COMMIT;</span></pre><p id="64e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这些改变，系统#1现在保证了强大的完整性。如果我们不需要更好的性能或容错，这可能是比系统#2更好的解决方案。但是它没有更好的完整性保证。</p><p id="f1d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们理解了为什么最初的系统#1不能保证完整性，以及如何修复它，那么让我们看看系统#2如何保证强完整性。</p><p id="3de4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是处理步骤的概要:</p><ol class=""><li id="b4be" class="kk kl hi ix b iy iz jc jd jg km jk kn jo ko js kp kq kr ks bi translated">如在固定系统#1中一样使用操作id。转移请求根据操作id从客户端浏览器发送到web服务器，再发送到数据库分区，从而创建新的转移请求记录。</li><li id="2bd5" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">这个新的转账请求记录导致2个新的转账记录:1个到我的账户，1个到你的账户。所有记录都包括操作id。</li><li id="1492" class="kk kl hi ix b iy kt jc ku jg kv jk kw jo kx js kp kq kr ks bi translated">当我们的任何一个账户被读取时，转账记录被操作id删除重复，因此它们被处理<em class="ki">恰好一次</em>(确切一次的更好的说法是<em class="ki">有效一次，</em>但不幸的是确切一次更常用)。</li></ol><p id="40cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，任何步骤都可以多次发送消息，因为在最后，操作id会被重复删除，从而只进行一次处理。这使得系统具有高度的容错性。因为一切都是分区的，所以系统可以水平扩展。没有多节点提交意味着更高的可用性和更低的延迟，即使我们的数据库集群是全球分布的。</p><p id="e6c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这些好处，我们为什么想要强及时性呢(这里强一致性给我们带来的唯一额外好处)？因为它简化了系统。</p><p id="c69b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们想要简单的系统，所以我们可能会说，“CAP说我们通过在网络分区期间失去可用性来支付强一致性，但我们不是Google，所以我们系统中的网络分区是如此罕见和快速，我们可以为此付费”。这可能是真的，但CAP并没有警告说，即使没有网络分区，强一致性也会带来更高的延迟。不幸的是，强一致性事务“通常只在单个数据中心工作”，并且它们“限制了规模和容错属性，尤其是在异构存储系统中”。随着多个数据中心、规模和异构存储系统成为越来越常见的业务需求，我们将需要在没有强一致性的情况下保证强完整性，即使我们的系统在网络分区期间可能不可用。</p><p id="6d7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，为什么最好避免CAP？</p><p id="e0e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“在对CAP的讨论中……作为一个定理的形式化与其通常的含义不符。[例如，]许多所谓的“高可用性”(容错)系统实际上不符合CAP对可用性的特殊定义。总而言之，围绕CAP有很多误解和困惑，它并不能帮助我们更好地理解系统，所以最好避免CAP。”</p><p id="f96b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">CAP定理告诉我们的唯一一件事是，系统可以选择如何处理集群中的网络分区:要么停止处理写操作，要么冒着来自非多数节点的过时读操作的风险。这只是许多权衡中的一个，并不像大多数人认为的那样重要:如果我们有一个5节点集群，其中节点1无法与其余节点通信，节点2-5可以继续处理读/写，同时保持强一致性。此外，“CAP现在已经被更精确的结果所取代，所以它在今天主要是有历史意义的”。</p><p id="04ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果CAP是最好避免的，那么为什么人们仍然使用它(如果不正确的话)？因为它在历史上很重要，而且因为“CAP”曾经是一个非正式的术语，用来开始讨论各种类型的一致性和可用性之间的权衡。不幸的是，上限定理改变了这个术语的含义，这种混淆以及过载的术语“一致性”和“可用性”导致了误解。</p><p id="d2e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为CAP是最好避免的，所以我们应该考虑什么呢？</p><p id="32f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与其“一致性”甚至“强一致性”，不如想想“完整性”和“时效性”:我们需要什么样的数据时效性？我们需要什么样的数据完整性(答案出人意料地往往不是强完整性)？如果是强完整性，那么系统#1表明我们应该能够在系统级别保证这一点，而不仅仅是在数据库级别。</p><p id="8f63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与其考虑CAP定理的“总可用性”和集群网络分区，不如考虑系统需要有多高的性能、可伸缩性和容错性。当人们说“高可用性”时，他们通常意味着“容忍网络分区”，但我们通常对网络分区以外的故障更感兴趣，比如节点超时或被关闭，尤其是在云架构中。</p><p id="f210" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结论:随着我们的业务需求越来越频繁地使强一致性变得过于昂贵，当设计系统时，我们必须学会在没有强一致性的情况下进行权衡。在这些与自己，尤其是与他人的权衡讨论中，CAP没有帮助，反而有害。</p><p id="ee18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">PS:</p><ul class=""><li id="817c" class="kk kl hi ix b iy iz jc jd jg km jk kn jo ko js ky kq kr ks bi translated">强一致性不是SQL -vs- NoSQL的特性:强一致性是一些NoSQL数据库的缺省值，任何异步复制的数据库(SQL或NoSQL)都缺乏强一致性。</li></ul></div></div>    
</body>
</html>