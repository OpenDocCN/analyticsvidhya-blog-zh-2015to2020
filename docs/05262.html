<html>
<head>
<title>Amortized Runtime analysis for python Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python列表的分期运行时分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/amortized-runtime-analysis-for-python-lists-35e935e290db?source=collection_archive---------17-----------------------#2020-04-15">https://medium.com/analytics-vidhya/amortized-runtime-analysis-for-python-lists-35e935e290db?source=collection_archive---------17-----------------------#2020-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a284fe8fd64b70130e8fc4646a490d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*Y6Iw9S1TaQuwKd1PaIpzCg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片来源:真实Python</figcaption></figure><p id="f824" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天，在阅读时间复杂性时，我决定关注python内部的工作方式。这让我<em class="jo">摊销时间复杂度</em>以及Python的‘list’如何以O(1)时间计算其插入和删除操作。</p><p id="4a25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您熟悉python，您会知道python允许您创建一个列表，而无需在初始化时定义其长度。在大多数编程语言中，如Java、C/C++等。必须指定数组的长度。</p><p id="f65a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么python如何在没有明确指定长度的情况下创建一个列表呢？是一个无限长的数组吗？</p><blockquote class="jp jq jr"><p id="0b70" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">列表不是无限存储的数组。</p></blockquote><p id="7f51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">众所周知，在列表中插入一个元素的运行时间复杂度是O(1)时间。这是不是意味着一个链表有无限的存储块？无限大小的数组在计算上将是昂贵的。想象一下，您的系统为一个列表提供了大量的存储空间，这样它就永远不会耗尽存储空间。</p><blockquote class="jp jq jr"><p id="3b42" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">Python的“列表”是一种类似数组的数据结构，提供动态调整大小。</p></blockquote><p id="f85c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">列表根据需要调整自身大小，同时仍然提供O(1)访问。在大多数编程语言中，这是通过在满时将数组的大小加倍来实现的。例如，对于大多数编程语言，动态数组的长度将表现如下。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/be1f60c9dbfc7137799a640a6ca5a5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*oIDQySVnSHtK1e2q5biBNg.png"/></div></figure><p id="47dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">将n个项目复制到一个新数组的时间复杂度为O(n) </strong></p><p id="6589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这种情况很少发生，即当数组长度改变时，插入的最坏情况时间复杂度为O(n)。</p><blockquote class="jp jq jr"><p id="b728" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">那么插入的平均时间复杂度是多少</p></blockquote><p id="c08b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们计算一下将n个对象追加到一个动态数组的时间复杂度。</p><p id="b92f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将“n”个对象追加到动态数组的时间复杂度将是时间复杂度简单地为O(1)的所有情况(<em class="jo">追加</em>)以及时间复杂度为O(n)的所有这些罕见事件(<em class="jo">复制</em>)</p><blockquote class="jp jq jr"><p id="0898" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">所以时间复杂度可以写成如下</p></blockquote><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es ka"><img src="../Images/d2f447a5ab4d0497c87777896521d6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vAecx0A9SI6AfE91O3IaA.png"/></div></div></figure><p id="79de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在动态数组中插入“n”个对象的平均开销是O(n ),因此一次插入的平均开销是O(1)。T11】</p><p id="ffa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以说，附加一个项目运行在O(n)中，即平均线性时间。这被称为摊余时间复杂度。因此，分析整个操作(插入n个对象)而不是单独分析一个操作的方法称为摊销分析。</p><h2 id="e8cf" class="kf kg hi bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">在Python中调整列表的大小</h2><p id="407b" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我写了下面的代码来检查Python列表在哪里加倍了它的大小。代码将100个对象追加到一个列表中，并在每一步计算其大小<em class="jo">(这有助于确定动态数组的长度)</em>。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/a7d4bdc7b61d57bc4f4588e44e46b3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*-EYh47FYwU58p4F8DV4Nng.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图:代码“Python列表的大小翻倍”</figcaption></figure><p id="7aaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所见，List <em class="jo"> list_ </em>在i=0，1，5，9，17，26时改变其大小……这与当数组长度达到2的幂时加倍的等式不同。相反，Python的等式是</p><p id="b785" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">长度= ceil(1.125 * n + 3)当n ≥1 &amp;&amp; n &lt;9</p><p id="987d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">length = ceil(1.125 * n + 6) when n ≥9</p><p id="39d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">This equation is applied only when <em class="jo"> n &gt;列表长度</em>即n =1，5，9，17，..使用新值5，9，17，26，…</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es lg"><img src="../Images/c57f9448d3d8756495d39f6b1ee94496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXOwCyv4V8G7lNlqSPqZJg.png"/></div></div></figure><blockquote class="jp jq jr"><p id="ee48" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">那么插入的平均时间复杂度是多少</p></blockquote><p id="0809" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似于上面的等式，将‘n’个对象附加到动态数组的时间复杂度将是时间复杂度简单地为O(1)的所有情况(<em class="jo">附加</em>)以及时间复杂度为O(n)的所有这些罕见事件(<em class="jo">复制</em>)</p><blockquote class="jp jq jr"><p id="d00e" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">时间复杂度可以写成如下形式</p></blockquote><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es lh"><img src="../Images/3e832085596cff19fe02868661cb6148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQfkJjg4sjaK0hvCZJW3Lg.png"/></div></div></figure><p id="ca32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我试着解方程的第二部分，如果不假设Ceil(x) ~ x，就找不到具体的数学证明。所以我模拟了上面的操作。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es li"><img src="../Images/c79ec0e311b4830d364f4e5877204b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*r-Ji2AYXFZIfwPG6NndqSQ.png"/></div></figure><p id="0f29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我绘制了“n”对n的Sum os系列图</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/0985917c66661319881e69f13ea9d1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*JBwgAUSC4TdNdNVLKQY6sA.png"/></div></figure><p id="3e68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">等式的第二部分近似收敛到10 *n。这使得我们在列表中插入O(11n)的时间复杂度，这仅仅是插入n个对象的O(n)次。</p><blockquote class="jp jq jr"><p id="09d2" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">通过摊销分析，Python中的list.append取O(1)。</p></blockquote><p id="a99d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅供参考:以2的幂将大小加倍的动态数组稍微快一些。</p></div></div>    
</body>
</html>