<html>
<head>
<title>Chapter 3 — Linear Regression From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第3章—从头开始线性回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/chapter-3-linear-regression-from-scratch-474a795ea70f?source=collection_archive---------29-----------------------#2020-06-13">https://medium.com/analytics-vidhya/chapter-3-linear-regression-from-scratch-474a795ea70f?source=collection_archive---------29-----------------------#2020-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" rel="noopener" href="/swlh/introduction-to-pytorch-fcb8a8e452ec">第1章</a>和<a class="ae jd" rel="noopener" href="/analytics-vidhya/chapter-2-introduction-to-linear-regression-d6f95409e657">第2章</a>中，我们得到了PyTorch的介绍，PyTorch中使用的一些有趣的函数，机器学习中使用的不同算法，以及线性回归的简要但扎实的介绍。在本章中，我们将从头开始构建一个线性回归模型，也就是说，不使用任何PyTorch内置函数。事不宜迟，我们开始吧。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f71b276eeebfef99636165baa26321f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1U5FmqGDvawJ5EXprrw9dA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://wallpaperaccess.com/full/510424.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="b898" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">问题陈述</strong></h2><p id="c2af" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">通过观察一个地区的平均温度、降雨量和湿度(独立变量或预测变量)来预测苹果和橙子的产量(因变量或目标变量)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/ae6d30322a4829fd886c61215aaeb7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oqxvab86zsTvcnmJ9ubQw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://i.imgur.com/6Ujttb4.png" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="914e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道，在线性回归中，目标变量被认为是独立变量的加权和，被称为偏差的某个常数抵消(我们添加此抵消，以便当所有独立变量变为零时，输出不应变为零)。</p><p id="804b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个陈述可以用数学方法表示为:-</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kv"><img src="../Images/c0fa8d86694711a33adffe8828a9abc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*Ax3B6EG5dcskZRpepWDfjw.png"/></div></figure><p id="6e27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些方程表明，因变量与因变量共享一个线性关系。</p><h2 id="3d4b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">线性回归的学习部分</strong></h2><p id="7fcb" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们应该通过分析训练数据来找到一组权重和偏差，即w11、w12、…w23以及b1和b2，以基于avg来预测新区域的苹果和橙子的产量。在…之时、降雨量和湿度。这是通过稍微调整权重和偏差来实现的。</p><p id="7c94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练数据可以被认为是两个numpy阵列(矩阵),每个观察值输入和目标一行。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kw"><img src="../Images/4ed56bf12ebe3111512b2b2720f7a812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFL97OSs2CYMJ-zouJevjg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="53d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将numpy数组转换为张量，为此我们使用torch.from_numpy()，该方法将numpy数组作为输入和输出张量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/7533acbf917b2b6c2a30aaf87de7fd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltDuGoszRZtgSMtZdeDPfw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="20b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">权重(w11，w12，…w23)和偏差(b1，b2)可以表示为矩阵，第一行和第一个偏差元素用于预测苹果的产量，第二行和元素用于预测橙子的产量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ky"><img src="../Images/a931937da831f9135730796ea4d1ccd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3ZxREDSVPKceZ5drLjETw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="b3be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这段代码中，我们使用torch.randn()创建了两个张量w和b，它们将作为我们的权重和偏差矩阵。torch.randn()函数创建两个矩阵，其中元素是从均值=0、标准差=1的正态分布中随机选取的。</p><h2 id="bf7a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">模型创建</strong></h2><p id="04d1" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们的模型只是一个执行输入和权重(转置)的矩阵乘法并添加偏差的函数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kz"><img src="../Images/2dcf86915eb9e5aac503a724053af0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*nXPg5_Ma_RmbfdITEQu34g.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="6462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义model()，它将输入矩阵作为参数并返回预测。</p><p id="fe88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将输入矩阵与随机生成的权重矩阵的转置相乘(以避免大小不匹配)，并将结果与偏差矩阵相加。</p><ul class=""><li id="6ee8" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">@符号代表PyTorch中矩阵乘法</li><li id="2025" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">。方法返回矩阵的转置</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/2a9fed0d8597aa0907ad99b5cd314947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ra8iF7RZYgONQ6SjXrQu3w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="7269" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将输入作为参数传递给model()。比较目标矩阵和预测矩阵，我们看到预测值和目标值之间的巨大差异。这是因为我们选择了完全随机的权重和偏差矩阵。</p><h2 id="7daf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">损失函数</strong></h2><p id="1342" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在我们改进我们的模型之前，我们需要评估我们的模型表现如何。为了确定性能，我们计算均方误差(MSE)。</p><ol class=""><li id="9234" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lp lg lh li bi translated">找出预测值和目标值之间的差异，即误差</li><li id="9661" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">由于误差可能有负值，为了消除这一点，我们平方这些值。</li><li id="9899" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">求平均值。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lq"><img src="../Images/4c29e159be990429a041cc7c4cc4d642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tzqr2oyK2hFveuZtr2oISw.png"/></div></div></figure><p id="2f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数计算均方误差。</p><ul class=""><li id="393f" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">torch.sum返回张量中所有元素的总和</li><li id="015f" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">numel方法返回张量中元素的数量。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/761cd75e29f0b8a7fed47df90407dbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcgVR-pkvSiDwCPr0BukDg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="5e4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型的损耗非常高。平均而言，预测值与目标值相差约165.803 (sqrt(27490.5352))。考虑到我们的目标值本身在50–150的范围内。损失越低，模型越好。</p><h2 id="65b4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">梯度计算</strong></h2><p id="b8c5" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们可以根据权重和偏差矩阵自动找到损失的梯度或导数，因为它们的<em class="ls">。requires_grad </em>被设置<em class="ls">为真</em>，grad返回一个相同维数的矩阵。梯度存储在<em class="ls">中。各自张量的grad </em>属性。在调用。grad属性我们必须调用backward()函数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/2e7bb5be1780fdbec2e19b3c04c405f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiJgcyJzzJ3oQBJOTzZWzQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="1648" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">损失是我们的权重和偏差的二次函数，我们的目标是找到给出最低损失的权重和偏差的集合。微积分的一个关键观点是，梯度表示损失的变化率，或损失函数相对于权重和偏差的斜率。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/568fdfe94d4510b45079e41e406d8ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xN0gAeM3m4604zLEEPIaA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://i.imgur.com/hFYoVgU.png" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jw">来源</strong> </a> <strong class="bd jw">:图表1 </strong></figcaption></figure><p id="57f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图1中，梯度元素为正，因此:</p><ul class=""><li id="bd82" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">稍微增加元素的值会增加损耗。</li><li id="d84a" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">稍微降低元素的值，可以减少损耗。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/868e549b45e52ab129355ad43608e8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRTLNzzk0Ey3xM9GfFsgPA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://i.imgur.com/w3Wii7C.png" rel="noopener ugc nofollow" target="_blank">来源</a>:图2</figcaption></figure><p id="c8ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图2中，梯度元素是负的，因此:</p><ul class=""><li id="4199" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">稍微增加元素的值，可以减少损耗。</li><li id="66cc" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">稍微降低元素的值会增加损耗。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lw"><img src="../Images/d90aeb034e7b7b57aa3e73751d377c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*roTLExdr33SAC8DyPpwwYg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="a6f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码片段中，我们通过调用。zero_()方法。我们需要这样做，因为PyTorch会累积梯度，也就是说，下次我们对loss调用backward()时，新的梯度值会添加到现有的梯度值中，这可能会导致意外的结果。</p><h2 id="dc3d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">使用梯度下降调整权重和偏差</strong></h2><p id="7b94" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们将使用梯度下降优化算法来减少损失并改进我们的模型，该算法具有以下步骤:</p><ul class=""><li id="a1f7" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">生成预测</li><li id="3d3e" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">计算损失</li><li id="4093" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">根据权重和偏差计算梯度</li><li id="1df8" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">通过减去与梯度成比例的少量来调整权重</li><li id="22f8" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">将梯度重置为零</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ky"><img src="../Images/2cc79ff5e989a605f6ef6189275ff3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7syJJMBgQxKvtl7xJjegyQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="ac0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过用临时设置所有<em class="ls">的<em class="ls"> torch.no_grad(): </em>包装代码块来阻止autograd()在requires_grad设置为True的张量上跟踪历史。requires_grad=False </em>。</p><p id="df32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将梯度乘以一个很小的数(在这种情况下是10^-5)，以确保我们不会对权重进行很大的修改，因为我们只想在梯度的下坡方向上迈出一小步。这个数叫做算法的学习率。在我们更新了权重之后，我们将梯度重置回零，以避免影响任何未来的计算。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/480356028996b8b77803c6599f1036c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyQTQU1L-O2uH_8qAqJtYA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="91a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经实现了损失的显著减少，简单地通过使用梯度下降稍微调整权重和偏差。</p><h2 id="6cd5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">多纪元训练</strong></h2><p id="c350" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">为了进一步减少损失，我们可以使用梯度下降多次重复调整权重和偏差的过程。每次迭代称为一个时期。让我们训练模型200个纪元。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ly"><img src="../Images/3cf921587fb2e09f241c4c612f9b9769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iblaE96MpIvOavS1WRP_ZQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由作者生成</figcaption></figure><p id="ad07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，损失已经大大减少，经过200个时代后，损失的最终值是128.6884，这是相当不错的。预测值现在更接近目标值。</p><p id="3a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总结一下这篇博客，我们了解了如何在不使用任何PyTorch内置工具的情况下从头构建一个模型，并且仍然能够获得一个好的预测模型。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="0260" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了一个Jupyter笔记本来创建模型，这是一个开源的web应用程序，允许您创建和共享包含实时代码、方程、可视化和叙事文本的文档，任何人都可以使用这个平台来实践本教程。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="36bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇博客中，我们将学习使用PyTorch内置函数为更大的数据构建一个线性回归模型。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="7dc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ls">感谢阅读，下期再见！</em></p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><blockquote class="mg mh mi"><p id="05c2" class="if ig ls ih b ii ij ik il im in io ip mj ir is it mk iv iw ix ml iz ja jb jc hb bi translated">如果你需要这个博客的链接，请留下你的评论。</p></blockquote></div></div>    
</body>
</html>