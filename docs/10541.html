<html>
<head>
<title>Advanced Locking in Java: Reentrant Read Write Lock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的高级锁定:可重入读写锁</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/advanced-locking-in-java-reentrant-read-write-lock-b40fce0833de?source=collection_archive---------3-----------------------#2020-10-23">https://medium.com/analytics-vidhya/advanced-locking-in-java-reentrant-read-write-lock-b40fce0833de?source=collection_archive---------3-----------------------#2020-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(使用读写锁在 Java 中设计高效的分布式数据系统)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/22baeb60e8103c53e620b9ac45d1d7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZOZlw2MnMjZEyakS"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">锁</figcaption></figure><h1 id="0708" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在一个巨大的数据系统上读写</h1><p id="a6ba" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">假设您有一个大型分布式数据库系统，您想在其上执行一些读/写操作。</p><p id="f038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望事务是原子的和一致的。使用一个线程来执行读写任务将确保系统的稳定性，但速度会受到影响。此外，遍历整个数据库并不容易，需要多次查询才能得到结果。</p><p id="653f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">手术自然需要时间。所以我们将读写任务拆分到多个线程来优化性能。</p><h1 id="7d2a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解决这个问题的典型代码</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kw"><img src="../Images/b36417440e0a965a274f6af3aab4c0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*QD0HgNddut83kJ0XRW6zrA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">简单溶体</figcaption></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="8e96" class="jt ju hi bd jv jw le jy jz ka lf kc kd ke lg kg kh ki lh kk kl km li ko kp kq bi translated">简单的 ReentrantLock 方法性能很差</h1><p id="153a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">“锁”保护临界区免受并发访问。</p><p id="62f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">这很好，因为我们不想并行线程进入这个部分，因为它会导致数据不一致。所以我们使用简单的锁来实现多线程之间的并发。</em></p><h2 id="75b0" class="lk ju hi bd jv ll lm ln jz lo lp lq kd iq lr ls kh iu lt lu kl iy lv lw kp lx bi translated">这里什么好？</h2><p id="68bf" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><em class="lj">这里我们使用一个锁来阻止线程进入临界区。因此，当其中任何一个线程正在写时，它会阻止所有其他线程读取。这种行为没问题。</em></p><h2 id="e2f5" class="lk ju hi bd jv ll lm ln jz lo lp lq kd iq lr ls kh iu lt lu kl iy lv lw kp lx bi translated">这里什么不好？</h2><p id="02b7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">但是当任何一个线程正在读取时，它也阻止所有其他线程读取。<br/>这将导致应用程序变慢，因为大多数读取操作可以共享。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/072f080896599701be256c51ab5f3ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vmtojLpMAK-BIFZa"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">冲突</figcaption></figure><h1 id="a896" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们能做得更好吗？</h1><p id="9549" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><em class="lj">是的，</em></p><p id="1af2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">当没有其他线程正在执行写操作时，允许多线程读取。当所有线程都处于读取模式时，没有必要阻塞线程。<br/>但是，当其中一个线程正在写时，阻塞所有其他线程的读写。</em></p><blockquote class="lz"><p id="155b" class="ma mb hi bd mc md me mf mg mh mi jc dx translated">在图片中输入 ReentrantReadWriteLock</p></blockquote><figure class="mk ml mm mn mo ji er es paragraph-image"><div class="er es mj"><img src="../Images/1924d147359173c63207a3cdfe4c9729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*zXSock31eiPu4rl6rlQzXg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">读写锁</figcaption></figure><h1 id="8417" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">一次漫游</h1><p id="3b4d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们首先创建一个可重入的读写锁。<br/>然后我们从上面的可重入读写锁创建两个锁对，即读锁和写锁。</p><h2 id="c47d" class="lk ju hi bd jv ll lm ln jz lo lp lq kd iq lr ls kh iu lt lu kl iy lv lw kp lx bi translated">读取锁定</h2><p id="5bd2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们使用读代码的可重入读写锁对中的读锁。之前获取锁，然后在 try 块中调用 read 任务，在 finally 块中释放 read 锁。</p><p id="64b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当所有同步线程都只使用可重入读写锁对的读锁时，读锁允许多线程在读方法中获取锁。如果任何线程正在使用可重入读写锁对的写锁，则不允许对资源进行读锁。</p><h2 id="4b47" class="lk ju hi bd jv ll lm ln jz lo lp lq kd iq lr ls kh iu lt lu kl iy lv lw kp lx bi translated">写锁定</h2><p id="019c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们使用带有写代码的可重入读写锁对中的写锁。之前获取锁，然后在 try 块中调用写任务，在 finally 块中释放写锁。</p><p id="0578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写锁只允许一个线程在 Write 方法中获取锁。</p><p id="dfd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有其他同步线程必须等待锁被释放，然后才能获取资源上的读或写锁。</p><h2 id="6398" class="lk ju hi bd jv ll lm ln jz lo lp lq kd iq lr ls kh iu lt lu kl iy lv lw kp lx bi translated">拿走！！</h2><p id="cece" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">ReentrantReadWriteLock 方法确保我们总是拥有共享数据的一致副本。此外，读取和写入既高效又同步。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="71dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在这里阅读更多关于并发编程的内容</strong></p><p id="a17e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Java 中的锁:</strong><a class="ae mp" rel="noopener" href="/analytics-vidhya/understanding-java-thread-synchronization-with-methods-vs-objects-vs-locks-5428e3342fee">https://medium . com/analytics-vid hya/understanding-Java-thread-synchron ization-with-methods-vs-objects-vs-Locks-5428 e 3342 fee</a></p><p id="c519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重入锁:</strong><a class="ae mp" rel="noopener" href="/analytics-vidhya/unlock-the-power-of-reentrant-lock-in-java-d55ae9135443">https://medium . com/analytics-vid hya/unlock-the-power-of-Reentrant-lock-in-Java-d55ae 9135443</a></p></div></div>    
</body>
</html>