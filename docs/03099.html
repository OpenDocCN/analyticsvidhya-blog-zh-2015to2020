<html>
<head>
<title>Transform an image into a Quadtree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将图像转换成四叉树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/transform-an-image-into-a-quadtree-39b3aa6e019a?source=collection_archive---------1-----------------------#2020-01-16">https://medium.com/analytics-vidhya/transform-an-image-into-a-quadtree-39b3aa6e019a?source=collection_archive---------1-----------------------#2020-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c2a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发现数据结构的有趣实验</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/33ccc4369711c5f8a54bbeccd2b909f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYsiqr93y5k8Kf8vjY39FQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://www.pexels.com/photo/dawn-nature-tree-romania-56875/" rel="noopener ugc nofollow" target="_blank">山上的绿叶树</a></figcaption></figure><p id="d296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近发现了四叉树和八叉树数据结构，我必须找到一个想法来试验它们。灵感来自于<a class="ae jt" href="https://en.wikipedia.org/wiki/Quadtree#QuadTree_class" rel="noopener ugc nofollow" target="_blank">四叉树维基百科页面</a> e上这张漂亮的gif</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/bddd00e670c5775d3743be32c568a568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*szzDMHXHMUNA0-hnCG9i4w.gif"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图像的四叉树压缩。来源:维基百科<a class="ae jt" href="https://en.wikipedia.org/wiki/Quadtree#/media/File:Quadtree_compression_of_an_image.gif" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/quad tree #/media/File:quad tree _ compression _ of _ an _ image . gif</a></figcaption></figure><p id="87ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为这是一个很酷的尝试和重现的小实验。我启动了Jupyter notebook，开始尝试Python、numpy和matlplotlib。</p><h1 id="7028" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">四叉树</h1><p id="047c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">四叉树是一种特殊的树，它将每个节点定义为有四个子节点。通过递归分割成四个象限来细分2D空间是非常有用的。关于这个主题的维基百科页面非常完整，并且提供了一些使用的例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/951345e5cd3239f1a52d653307023a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*-YhAN5gbvCyDWlWD.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">将一个简单的图像存储到四叉树中</figcaption></figure><h1 id="2f05" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">加载图像</h1><p id="9411" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">显然，要做的第一件事是加载图像并将其转换成我能够使用的东西。Matplotlib有一个很酷的方法叫做<a class="ae jt" href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imread.html" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> imread </em> </a>，它允许加载一个文件并将其转换成一个<em class="kz"> numpy.array </em>对象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="11ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这张图片是来自用户yokok在Flickr上的照片。图像被加载到一个表示每个像素的高度、宽度和RGB值的三维numpy数组中。使用matplotlib，您可以简单地调用<em class="kz"> plt.imshow </em>来显示图像。</p><h1 id="329e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">将图像分成4份</h1><p id="8903" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">算法的下一步是能够将图像分割成四个“相等”的部分。当然，只有在高度或宽度上有一对像素的图像才能被分割成4个完全相等的部分，但这对我们的算法来说并不重要。所以我们分头行动吧。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="bf06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，将图像分成4份并不太复杂，它在一个方向使用<a class="ae jt" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> array_split </em> </a>一次，然后在另一个方向使用。你必须使用地图的技巧来保持正确的尺寸。</p><h1 id="5035" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">把图像重建回来</h1><p id="e5fe" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">当我们从四叉树中读取图像时，我们必须从四个分裂的孩子中重建一个完整的图像。</p><p id="134d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过使用numpy的<a class="ae jt" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html" rel="noopener ugc nofollow" target="_blank">连接</a>方法很容易地做到这一点，它需要一个<em class="kz">轴</em>参数来确定在哪个轴上连接数组。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="50b0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">计算平均颜色</h1><p id="2a59" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">工具箱中的最后一个工具，我们需要用它来构造四叉树，我们将计算每个节点的平均颜色。该颜色将保存在节点中，并将用于显示中间图像。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ef3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，numpy非常有用，只需通过定义使用哪个轴来配置<a class="ae jt" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> mean </em> </a>方法，就可以获得平均颜色。</p><h1 id="be03" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">四叉树数据结构</h1><p id="949f" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">最后，我们得到了算法的核心。我定义了一个四叉树类和一个允许将图像插入四叉树的<em class="kz"> insert </em>方法，以及一个在特定级别显示图像的<em class="kz"> show_image </em>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="1494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">四叉树结构是一种递归结构，每个四叉树包含四个其他的四叉树(或者没有叶子)。</p><h2 id="7363" class="lc jw hi bd jx ld le lf kb lg lh li kf iq lj lk kj iu ll lm kn iy ln lo kr lp bi translated">插入</h2><p id="b4dd" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">insert方法是一种将被递归调用的方法。传递一个级别，从第一个节点的0开始，在每个级别上加1。它让我们知道在遍历树的时候我们在哪个层次。</p><p id="637f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们保存这个级别以及为当前级别计算的平均颜色(对于接收到的整个图像)。最后，我们保存分辨率，以便用传递的分辨率重新创建图像。</p><p id="e4d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们检查图像中的所有像素是否相等。如果是这种情况，我们在这里停下来，我们将能够在当前级别上重新创建图像，方法是从具有平均颜色的分辨率重新创建图像。我们通过设置一个标志来保存它是一个假期。</p><p id="6fde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们有不同的像素颜色，我们创建四个子四叉树，并通过调用insert方法将相应的四分之一插入每棵树，传递当前级别+ 1。</p><h2 id="c704" class="lc jw hi bd jx ld le lf kb lg lh li kf iq lj lk kj iu ll lm kn iy ln lo kr lp bi translated">显示图像</h2><p id="d3ee" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了在特定的层次上重建图像，我们只需要遍历四叉树，将每个分割连接成一个图像，然后发送回父调用者。</p><p id="b159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归方法调用的停止条件是当前节点级别与level参数中传递的级别相同，或者当前节点是叶子(<em class="kz"> final = true </em>)。</p><p id="659e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是这种情况，我们用平均颜色创建一个存储分辨率的图像。</p><h1 id="32d8" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="ae4f" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">这是一个有趣的小项目，让我更好地理解四叉树是如何构建和使用的。这肯定不是构造四叉树的最快方法，也不是存储四叉树的更好方法。似乎有以“平面”方式(在数组中)存储四叉树的解决方案非常高效，但我还没有找到算法或示例。我可能会进一步研究。</p><p id="72ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的GitHub上找到完整的Jupyter笔记本，网址是<a class="ae jt" href="https://github.com/Gimly/image-quadtree/blob/master/Transform_image_into_quadtree.ipynb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Gimly/image-quad tree/blob/master/Transform _ image _ into _ quad tree . ipynb</a></p><p id="3943" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>