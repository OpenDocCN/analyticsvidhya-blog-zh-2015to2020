<html>
<head>
<title>Movie Lens Data Analysis Using PySpark [for beginners]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PySpark进行电影镜头数据分析[适合初学者]</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/movie-lens-data-analysis-using-pyspark-for-beginners-9c0f5f21eaf5?source=collection_archive---------3-----------------------#2019-12-20">https://medium.com/analytics-vidhya/movie-lens-data-analysis-using-pyspark-for-beginners-9c0f5f21eaf5?source=collection_archive---------3-----------------------#2019-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f35b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Apache Spark正被广泛应用于大数据分析。我们可以在spark框架中使用Scala、Python或R。在本文中，我们将使用python来工作。</p><p id="355e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何项目的第一步都是加载数据，我们将在spark生态系统中加载两个包含以下数据的CSV文件(movies.csv和ratings.csv)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/37b5f7a7efc4612bf1b206032eb0fd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhUqqDG03U7FM_p7NY9YpQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">电影. csv</figcaption></figure><p id="cf0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">电影数据集有一个唯一的电影Id、标题和类型(一部电影可以被划分到多个类型中)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/26b313d1792e9bdec030ba304efaf47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*EABObfiWXbJY8SbMkNFJhw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">评级. csv</figcaption></figure><p id="2449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分级数据集具有唯一的用户Id、电影Id、分级和时间戳。</p><p id="9a79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将通过在shell中使用以下命令来加载这些数据集</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/cca1cb3ba81b99aeb36677016a96ea80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nb4WDvbvct0TCfiY2PpwOQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">加载csv文件</figcaption></figure><p id="d5de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个模式来确保每一列都有我们需要的数据类型。为此，我们将创建StructType并使用目标数据类型向其添加StructFields。然后，当我们从本地机器读取文件时，我们将传递这个模式，并设置header = True(它将CSV文件的第一行作为表的列名，默认情况下它是False，如果没有设置True，则保留默认的列名，如_c0、_c1)。现在我们已经创建了名为moviesdf的数据帧，现在我们将对它执行各种转换。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/0e6ccfc3419ac1f28d55f6a5fbbc9d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*KX5ZgWqybTF2NNVkmabTYg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用爆炸功能将每部电影与每种类型分开</figcaption></figure><p id="6045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须了解withColumn是如何工作的，withColumn用于在数据帧中创建一个新列，它带有某种条件或者只是填充常量值。如果列已经存在，就像在这种情况下(类型列)，我们可以用一些条件填充它。</p><p id="fd7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流派列有与该电影相关的各种流派，但我们需要分别处理每个流派，因此我们将使用“|”操作符拆分流派，然后使用explode，以便每个不同的流派都在各自的行中。这将忽略数据集内存在的null或空类型，如果出于某种原因您希望它们持续存在，那么您可以使用explode_outer，因为它也将存储null或空值。</p><p id="fc90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据电影的类型列出电影的数量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/13654b0294390bc573ab42fc2493fee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*2geVMP8Hb0mEBlmKJz-aWA.png"/></div></figure><p id="3368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须根据电影的类型对其进行分组，并计算行数，以了解不同类型的电影数量。正如我们在这里看到的，drama以一定的优势赢得了比赛。</p><p id="5b5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jw">现在问题来了，他们有没有没有指定类型的电影。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/d02cefc138e4ddee15039acc928c04ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*crLSv9YEdJOqLQxK7EjLgQ.png"/></div></figure><p id="92db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将根据我们的条件过滤数据帧，电影结果是《第三帝国:兴衰》。我想这个应该在纪录片栏目下。如果你不这么认为，请评论:)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/d103e2f7d68f4eab928f82fa21ce7682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llnevRE440bHksjC8sA75Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">正在读取分级csv文件</figcaption></figure><p id="5608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将读取第二个数据集，但这一次我们不会传递模式，spark框架将通过默认情况下将它分配给StringType来处理它。您可以使用df.schema命令对此进行交叉检查。</p><p id="c527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将movieId作为两个数据集中的公共主键，我们可以通过某种条件连接这些数据帧，并在一个视图中获得可用信息的完整视图。</p><p id="a8dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jw">连接两个数据帧(moviesdf和ratingsdf) </em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/764abff0dee40aa73a7fcbc2f71f07aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1bUoUdpVICEieo0NGj-Hw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">两个数据框架之间的内部连接</figcaption></figure><p id="f85b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里moviesdf是左表，ratings df是右表。当两个电影id匹配时，我们执行内部连接，我们得到结果，因此movie id列出现在两个数据帧中，所以我们必须删除一个movieId列，否则它们都将出现在最终的数据帧中，这是不必要的，因为它们是相同的。因为是内部连接，所以我们可以不指定连接类型就得到结果。如果你想执行外部或左连接等，那么你可以使用一个共同的一般方式是moviesdf.join(ratingsdf，on=['movieId']，how='outer ')。</p><p id="00df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们可以看到，对于同一个电影Id和片名，存在不止一种类型。<em class="jw">假设我们只想要每个电影Id和标题行中的第一行。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/cfea0e5afcb7d7b8016676775728f7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ivtb-Z3gtBJNdpL6tkdCA.png"/></div></div></figure><p id="ccbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将通过在spark中使用窗口操作来实现这一点，spark在开发中被广泛使用。我们将创建一个movieId和title相同的窗口，如果它们包含相同的movieId和title值，则将它们组合在一起并存储在同一个分区中，并按评级对它们进行排序(尽管在现实生活中，我们可能会得到不同的时间戳，我们必须按此对它们进行排序，但在这里时间戳是相同的，因此我们可以按评级或时间戳对它们进行排序)。在行号的帮助下，我们会给它一个序列号，然后我们可以选择行号的最低或最高值，但这样做时，我们会保留这些等级值，并使用列来实现这一点。它将创建一个名为rank的新列，其中包含递增的序列值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kc"><img src="../Images/db1e3e09453e2cb40a404f14a0fdcd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*74MSqbvNxSDH0SIubOzl0Q.png"/></div></figure><p id="6889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以过滤掉等级等于1的记录，这样每部电影只有一行。如果您愿意，也可以在转换后删除rank列，因为我们已经过滤掉了记录，所有行的值都相同。</p><p id="912e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jw">找出用户最喜欢的10部电影(高评分)和最差的(低评分)(例如让用户标识为544) </em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/d71e92b3f42a2d99acbe0f9d791351e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSpDFXmcP2hNGdZLkf9_yg.png"/></div></div></figure><p id="a704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为特定用户找出按其类型分级的所有电影的数量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ke"><img src="../Images/fbe1617ae5f0082eeb47f4bc4c9e29bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMing7ZkMpkKn5Bwq6aTng.png"/></div></div></figure><p id="36a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在这可能相当简单，首先，我们将检查用户id是否为544，然后我们将按照他们的类型对他们进行分组，并对其使用一些聚合函数，因为我们只想计算记录的数量，因此我们将使用count。</p><p id="5533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何建议，请在回复中告诉我！</p><p id="3801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章对你有帮助！</p></div></div>    
</body>
</html>