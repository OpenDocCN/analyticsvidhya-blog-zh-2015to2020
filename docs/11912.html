<html>
<head>
<title>Using Server-Sent Events with Python and FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Python和FastAPI使用服务器发送的事件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/real-time-log-streaming-with-fastapi-and-server-sent-events-54c31cfe78c5?source=collection_archive---------6-----------------------#2020-12-23">https://medium.com/analytics-vidhya/real-time-log-streaming-with-fastapi-and-server-sent-events-54c31cfe78c5?source=collection_archive---------6-----------------------#2020-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4e85cf1147bd4095ae9e010d58e66bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tp0gAEewz3cFjc9S.png"/></div></div></figure><p id="5c79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务器发送事件(SSE)经常被它的两个大哥——Web套接字和长轮询——所掩盖。然而，有许多使用SSE的实际用例。更新动态内容、发送推送通知和实时流数据只是SSE可以利用的几个应用程序。这篇文章将解释SSE，何时使用它，并用FastAPI实现一个简单的SSE应用程序。</p><h1 id="c2db" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是SSE</h1><blockquote class="km kn ko"><p id="abf1" class="iq ir kp is b it iu iv iw ix iy iz ja kq jc jd je kr jg jh ji ks jk jl jm jn hb bi translated">传统上，网页必须向服务器发送请求以接收新数据；也就是说，页面从服务器请求数据。使用服务器发送的事件，服务器可以通过向网页推送消息，随时向网页发送新数据。 <a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> MDN </em> </a></p></blockquote><p id="23f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是什么意思？本质上，服务器发送事件(SSE)使用户能够订阅实时数据流。每当数据流更新时，用户可以实时看到新的事件。如果您过去使用过长轮询或Web Socket应用程序，您可能会想知道SSE有什么了不起的？</p><h1 id="f8b2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">SSE与Web套接字</h1><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/c8914b01d476c9d8214d4e37e2c41d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/0*em05rU50e32ma9ol.gif"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated"><a class="ae kt" href="https://www.amazon.com/Aurora-World-Pompom-Penguin-White/dp/B00GS228DG/ref=asc_df_B00GS228DG/?tag=hyprod-20&amp;linkCode=df0&amp;hvadid=312126267557&amp;hvpos=&amp;hvnetw=g&amp;hvrand=9396469599274290370&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9032144&amp;hvtargid=pla-489531873487&amp;psc=1" rel="noopener ugc nofollow" target="_blank">玩具企鹅</a></figcaption></figure><p id="1c09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Websockets 是服务器之间的双向通信形式。它们通常用于构建聊天室或多人视频游戏，因为这些应用程序需要服务器和客户端之间的持续通信。你可以把SSE想象成一个单向的websocket。只有服务器可以向订阅的客户端发送消息。在许多web应用程序中，web套接字可能有些过头了。例如，更新产品页面上的商品价格不需要双向通信。服务器只需要单向通信来更新所有客户端的价格。这是SSE的一个完美用例。</p><h1 id="5237" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">SSE与长轮询</h1><p id="ffbe" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated"><a class="ae kt" href="https://www.ably.io/topic/long-polling#:~:text=Rather%20than%20having%20to%20repeat,available%20or%20a%20timeout%20threshold" rel="noopener ugc nofollow" target="_blank">长轮询</a>是一种通信方法，客户端定期向服务器发送新数据。当正在构建的应用程序涉及人工干预或执行计算开销大的任务时，通常会使用这种形式的通信。想想看，你的DoorDash交付状态或者触发了一个重型机器学习模型的训练。这些事件需要很长时间才能完成，因为它们可能需要人进行更新，或者只是计算量很大。在这种情况下，经常检查这些任务的完成可能是不必要的。SSE通常用于快速生成事件的应用程序中。例如，在YouTube视频上进行实时点赞计数，在用户界面上显示服务器日志文件，或者向用户手机推送通知。所有这些事件都近乎即时更新。</p><h1 id="0cb7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">快速回顾</h1><p id="ad3b" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">简而言之，SSE是一个很好的快速实时数据流工具。它们提供从服务器到客户端的单向通信，通常用于更新网页上的动态内容。</p><h1 id="4645" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让我们使用SSE在网页上显示日志文件！</h1><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/601345f12600059cc6224eace5012c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ak6eE0p9mfZq9Rj0.gif"/></div></div></figure><p id="7d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然知道了SSE的优缺点，那就用起来吧。我们将建立一个网页，显示来自服务器的实时日志文件！这是SSE的一个很好的用例，因为日志是通常会快速更新的事件。我们也不需要双向交流。在本教程中，我们将使用python和FastAPI。FastAPI对于SSE应用程序来说是一个很好的工具，因为它非常容易使用，并且是建立在内置了SSE功能的starlette之上的。下面显示的所有代码都可以在<a class="ae kt" href="https://github.com/amittallapragada/SSELoggerDemo" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="f100" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码将分为两部分:服务器和客户端</p><p id="d756" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务器应用程序必须分为两个部分——一个是模拟生成日志的程序，另一个是传输这些日志的程序。</p><p id="3ab1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的日志生成器非常简单。我们将创建一个名为<strong class="is hj"> program.py </strong>的文件。在其中，我们首先创建一个指向日志文件的logger对象。然后，我们将编写一个无限while循环，将一些随机消息打印到我们的日志文件中。我们将放置一个小的time.sleep()来降低我们创建日志的速度。</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="8673" class="lo jp hi lk b fi lp lq l lr ls">program.py</span></pre><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="05a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们有了一个生成日志的程序。现在让我们用SSE流式传输这些日志。为此，我们将使用FastAPI构建一个快速web服务器。您需要安装一些python库来运行这个代码片段，所以我强烈建议您在继续之前按照我在<a class="ae kt" href="https://github.com/amittallapragada/SSELoggerDemo" rel="noopener ugc nofollow" target="_blank"> Github </a> readme上的安装说明进行操作。我们将把所有的服务器逻辑写在一个名为server.py的文件中。</p><p id="a8d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">webserver代码可以分为三个部分:导入和服务器设置、我们的SSE生成器和我们的服务器端点。让我们看一下每一部分:</p><h2 id="921a" class="lo jp hi bd jq lv lw lx ju ly lz ma jy jb mb mc kc jf md me kg jj mf mg kk mh bi translated">导入和服务器设置</h2><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="3ad9" class="lo jp hi lk b fi lp lq l lr ls">server.py</span></pre><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="56c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里需要了解的主要导入是FastAPI、EventSourceResponse和tail。FastAPI将使我们能够快速构建网络服务器。EventSourceResponse是sse_starlette库中的一个函数，它将python <a class="ae kt" href="https://wiki.python.org/moin/Generators" rel="noopener ugc nofollow" target="_blank">生成器</a>对象转换成sse信号。sh库中的tail函数让我们无限地跟踪一个文件，并且只打印未读的行。这对于我们开发一个日志记录器是至关重要的，因为我们只想显示用户还没有看到的行。完成导入后，我们创建一个FastAPI实例。我们还添加了一些CORS中间件，允许我们的客户端接受服务器发送的事件。</p><h2 id="d9ee" class="lo jp hi bd jq lv lw lx ju ly lz ma jy jb mb mc kc jf md me kg jj mf mg kk mh bi translated">SSE生成器</h2><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="bf8f" class="lo jp hi lk b fi lp lq l lr ls">server.py</span></pre><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">日志生成器</figcaption></figure><p id="0253" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢EventSourceResponse函数，我们可以将python <a class="ae kt" href="https://wiki.python.org/moin/Generators" rel="noopener ugc nofollow" target="_blank">生成器</a>作为服务器发送的事件发送。我们的生成器是在logGenerator函数中定义的。它使用尾部导入无限期地跟踪我们的日志文件，并在文件更新时生成新的行。我们还将添加一个睡眠功能来降低发电机的速度。这将使我们更容易跟踪打印在网页上的日志。您可能想知道为什么函数是异步的，request.is_disconnected在做什么。我稍后会解释那件事。</p><h2 id="6a78" class="lo jp hi bd jq lv lw lx ju ly lz ma jy jb mb mc kc jf md me kg jj mf mg kk mh bi translated">服务器端点</h2><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="d374" class="lo jp hi lk b fi lp lq l lr ls">server.py</span></pre><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">流式端点</figcaption></figure><p id="fc13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后但同样重要的是，我们有我们的服务器端点。我们创建一个路由“/stream-logs ”,它将创建日志生成器的一个实例，并将is作为EventSourceResponse返回。EventSourceResponse是starlette对服务器发送的事件的表示。您可能会注意到，我们的run方法接收一个请求对象，并将其传递给logGenerator。starlette请求的一个很酷的优点是我们可以监控客户请求的整个生命周期。每当我们检测到一个特定的客户端断开连接时，这就允许我们中断生成器并节省资源。这就是“request.is_disconnected”逻辑在日志生成器中的作用。这个代码片段的最后一行在您本地主机的端口8080上运行我们的web服务器，可以这样访问:<a class="ae kt" href="http://0.0.0.0:8000/" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:8000/ </a></p><p id="373d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与服务器相比，我们的客户端应用程序非常简单。这是一个订阅我们服务器的html页面。它将被命名为client.html</p><pre class="kv kw kx ky fd lj lk ll lm aw ln bi"><span id="e54e" class="lo jp hi lk b fi lp lq l lr ls">client.html</span></pre><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">客户端html代码</figcaption></figure><p id="9d57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个文件中唯一值得讨论的部分是脚本部分。这里我们创建了一个名为Source的新EventSource变量。我们的source var表示我们的客户端已经订阅了服务器的流日志端点。EventSource对象的onmessage函数允许我们在从流中接收到新消息时触发自定义操作。在我们的例子中，我们将修改一个div，并在那里追加日志数据。(我试图将这个元素设计成控制台的样子)</p><p id="ca2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">厉害！我们已经写好了我们的服务器和客户机代码。为了完成这项工作，我们首先需要运行我们的服务器和日志文件。一旦两者都运行了，我们就可以在任何浏览器中打开客户端html代码。我将详细介绍如何在项目<a class="ae kt" href="https://github.com/amittallapragada/SSELoggerDemo" rel="noopener ugc nofollow" target="_blank"> Github </a>页面上运行这些脚本！感谢您的关注！</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/2b6fed8d261d3ee40c3b4f63ccaa247c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ed6-gHUlHTO9Vbyn.gif"/></div></div></figure></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="e970" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">原载于2020年12月23日</em><a class="ae kt" href="https://amittallapragada.github.io/docker/fastapi/python/2020/12/23/server-side-events.html" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://amittallapragada . github . io</em></a><em class="kp">。</em></p></div></div>    
</body>
</html>