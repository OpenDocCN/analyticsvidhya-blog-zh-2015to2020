<html>
<head>
<title>Multi-label classification using fastai — a shallow dive into fastai data-block API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用fastai的多标签分类——fastai数据块API浅探</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multi-label-classification-using-fastai-a-shallow-dive-into-fastai-data-block-api-54ea57b2c78b?source=collection_archive---------1-----------------------#2019-09-22">https://medium.com/analytics-vidhya/multi-label-classification-using-fastai-a-shallow-dive-into-fastai-data-block-api-54ea57b2c78b?source=collection_archive---------1-----------------------#2019-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e956" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是一篇关于多标签分类的简短博文。如果你想了解分类背后的动态，我建议你浏览一下这篇博客文章。</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/7c0e066a2ae0758b948894a1e3b185cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qswfigz6sc5mIdoJup0fmA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">图片来源——谷歌</figcaption></figure><p id="c48a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于多标签分类，我将解决一个<a class="ae ix" href="https://www.kaggle.com/c/planet-understanding-the-amazon-from-space/overview" rel="noopener ugc nofollow" target="_blank"> Kaggle竞赛</a>。您需要将数据集下载到您的本地。网上有很多指南告诉我们如何下载Kaggle竞赛数据集。去找那个人吧！</p><h2 id="d612" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">😈深入了解数据库</h2><p id="311a" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">Kaggle提供的数据集是用一个名为7zip的程序压缩的，该程序的扩展名为. 7z。如果你使用的是conda，那么你需要为7zip安装conda扩展。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="bd36" class="kk kl hi ll b fi lp lq l lr ls">! conda install -y -c haasad eidl7zip</span></pre><p id="1eea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你使用的是基于Linux的系统，比如goggle collab，那么使用下面的命令来安装7zip。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="1804" class="kk kl hi ll b fi lp lq l lr ls">!sudo apt install p7zip</span></pre><p id="cc8e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，数据集不仅被压缩了，还被涂上了焦油。因此，您可以运行下面的命令来完全访问数据集。我是谷歌实验室，所以我的道路将取决于此。你可能会有不同的道路。所以找到你的那一个，写在下面。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="013e" class="kk kl hi ll b fi lp lq l lr ls">path = '/content/planet'<br/>path.mkdir(parents=True, exist_ok=True)<br/>path</span><span id="29c6" class="kk kl hi ll b fi lt lq l lr ls">! 7za -bd -y -so x {path}/train-jpg.tar.7z | tar xf - -C {path}</span></pre><p id="0d70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将解压缩train.tar.7z文件。标签在中提供。csv文件，也是压缩的。要解压缩CSV文件，请运行以下命令。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="09dc" class="kk kl hi ll b fi lp lq l lr ls">!unzip -q {path}/train_v2.csv.zip -d {path}</span></pre><p id="6043" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">深入数据集</strong></p><p id="0141" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于我们必须对数据集进行多重标记，因此Kaggle很好地处理了这一点，而不是将图像放在不同的文件夹中进行不同的标记。Kaggle已经向我们提供了CSV文件，其中显示了文件(图像)的名称和相应的标签。你可以用熊猫库来玩CSV文件。如果您以前没有使用过pandas，它是Python中处理表格数据的标准方式。我建议你去探索熊猫。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="1e3e" class="kk kl hi ll b fi lp lq l lr ls">from fastai.vision import *<br/>import pandas as pd</span><span id="7834" class="kk kl hi ll b fi lt lq l lr ls">df = pd.read_csv(path/'train_v2.csv')<br/>df.head()</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es lu"><img src="../Images/7d7ae08e7b70d8a69f3bdfb0d14cdc0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*VMw_X6KgqTfr_LCTthdgJg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">带标签的图像名称</figcaption></figure><p id="1a5a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我以前的分类博客中，我一直使用工厂方法来创建图像数据束，如image data bunch。但有时我们需要在以下方面做出选择:</p><ul class=""><li id="7785" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">文件在哪里</li><li id="f41c" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">它们的结构是什么，比如文件夹，CSV文件</li><li id="e5cb" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">标签看起来如何像多标签、单标签</li><li id="74b9" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">你如何吐出验证集</li><li id="c862" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">你如何改变它</li></ul><p id="380e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我并不是说你不能从ImageDataBunch做任何事情，但是fastai提供了一个API，叫做<a class="ae ix" href="https://docs.fast.ai/data_block.html" rel="noopener ugc nofollow" target="_blank">数据块API </a>。它为我们提供了更多的灵活性。在这篇文章中，我将使用这个API。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="bcf6" class="kk kl hi ll b fi lp lq l lr ls">tfms = get_transforms(flip_vert=True, max_lighting=0.1, max_zoom=1.05, max_warp=0.)</span><span id="7960" class="kk kl hi ll b fi lt lq l lr ls">np.random.seed(42)<br/>src = (ImageFileList<br/>       <strong class="ll hj">.from_folder(path)</strong>            <br/>       <strong class="ll hj">.label_from_csv</strong>('train_v2.csv',sep=' ',folder='train-jpg',suffix='.jpg')<br/>       <strong class="ll hj">.random_split_by_pct</strong>(0.2))</span><span id="54f3" class="kk kl hi ll b fi lt lq l lr ls">data = (src.datasets()<br/>        .transform(tfms, size=256)<br/>        .databunch().normalize(imagenet_stats))</span></pre><p id="8bbd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来理解一下上面的养发码。不是真的！😜</p><ul class=""><li id="42ca" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">。from_folder(path) —我们希望从提供的文件夹中获取数据。您必须定义文件所在文件夹的路径。这里我们的路径是“/内容/星球”</li><li id="4d8a" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">。label_from_csv(文件名、分隔符、文件夹名、扩展名)—我们的图像多标签存在于csv文件中。我们已经在from_folder()中提供了所有文件所在的路径。在这个属性中，我们不得不提到CSV文件名，CSV中的东西是如何被分开的。在我们的例子中，这些是通过“”(空格)分开的。然后，我们必须提到数据所在的文件夹名称。最后是文件的后缀。</li><li id="32a6" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">。random_split_by_pct(验证数据集的数量)</li><li id="b788" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">。datasets()-它用于创建数据集。我们将很快了解更多。</li><li id="e82c" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">。databunch() —现在，您想要使用命令创建图像数据束。它将为您提供培训和验证数据束。</li></ul><p id="b864" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">❓什么也看不上”。dataset()" do</p><p id="4584" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据集是PyTorch的东西。它为我们提供了两种dunder方法:</p><ul class=""><li id="efcb" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">__getItem__ =它将在您在方法中提供的索引处获取特定的项。如果你有一个名为data的数据集，你想获取数据集中的第4项，你可能会做一些类似data[0]的事情。在内部，这个命令将调用__getItem__方法来获取第4个项目。</li><li id="fbe9" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">__len__ =当我们想要检查数据集的长度时，在内部调用该方法。你可以使用len(数据)这样的东西。它将调用__len__来计算数据集的长度。</li></ul><p id="e52a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以当我们打电话时。dataset()，它做上面的事情。此外，它将我们的输入数据转换成数据集的东西。</p><p id="920e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">❓什么是数据捆绑</p><p id="623d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在理解databunch之前，我们需要了解数据加载器。</p><p id="360b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">— ❔什么是数据加载器<br/>数据加载器使用我们的数据集，并为我们提供小批量数据，很像python迭代器。简而言之，我们可以说— <em class="mj">为了创建一个小批量，我们使用了另一个PyTorch类，称为DataLoader。</em></p><p id="f5b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据加载器在其构造函数中接受数据集。它做以下事情:</p><ul class=""><li id="3642" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">从数据集中随机抓取项目</li><li id="38f3" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">创建一批你要求的任何大小</li><li id="6586" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">在GPU上弹出它</li><li id="61b9" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">给你的模特送去</li></ul><p id="5e59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在回到<strong class="jq hj"> DataBunch，</strong><strong class="jq hj"/>训练数据集不足以训练模型。我们还需要验证数据集来检查模型的性能。同样的事情。它将我们的训练数据加载器、验证数据加载器和可选的测试数据加载器绑定在一起，并确保相同的转换应用于所有数据加载器。因此，当您创建一个DataBunch时，您会提供它，或者它会获取一个训练集数据加载器和一个验证集数据加载器。现在，这是一个你可以发给学习者并开始安装的物体。</p><p id="1930" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你没有使用你不应该使用的数据块😆，您可以使用ImageDataBunch以及下面的。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="0995" class="kk kl hi ll b fi lp lq l lr ls">ImageDataBunch.from_csv(planet, folder='train', size=256, suffix='.jpg', sep = ' ', ds_tfms=planet_tfms)</span></pre><h2 id="d764" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">解释数据集</h2><p id="f783" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">您可以查看如下数据集:</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="33f1" class="kk kl hi ll b fi lp lq l lr ls">data.show_batch(rows=3, figsize=(12,9))</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mk"><img src="../Images/5c5f05c094958d0d070d6046f61e0fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75ypT8sOxhmIGQeakVxKGg.png"/></div></div></figure><p id="34b8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于我们的数据集，我们有大量的类，每个图像对于每个数据类都有一个概率。</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="353d" class="kk kl hi ll b fi lp lq l lr ls">data.classes</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ml"><img src="../Images/5736fba6ffc66b1051a74716202c1044.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*IBxLVp4kRnFGMyeji08_KQ.png"/></div></figure><p id="bfb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们必须决定某个数字，高于这个数字的概率将被显示为图像的标签。我们将在一分钟内研究这个想法。</p><h2 id="2979" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">创建多标签分类器</h2><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="8728" class="kk kl hi ll b fi lp lq l lr ls">arch = models.resnet50</span><span id="9f20" class="kk kl hi ll b fi lt lq l lr ls">acc_02 = partial(accuracy_thresh, thresh=0.2)<br/>f_score = partial(fbeta, thresh=0.2)<br/>learn = create_cnn(data, arch, metrics=[acc_02, f_score])</span></pre><p id="b945" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码很多。让我们一点一点去了解。</p><ul class=""><li id="40fe" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">在我以前的分类器博客中，我使用过resnet34，但在这里我使用ResNet 50，因为它很快，使用它效果也很好。您可以先使用ResNet34，然后使用ResNet50来感受不同之处。去吧；你需要的都有了。</li><li id="ba3a" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">我可以使用任何度量，这是我们的模型在不同训练点的输出。在这里，我使用accuracy_thresh来衡量kaggle比赛的准确性和f_score(f_beta)。这不会提高我的模型性能。千万不要这么想，绝对不会影响模型性能。您可以在这里了解指标<a class="ae ix" href="https://docs.fast.ai/metrics.html" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="147d" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">因为我们必须对数据进行多重标记，所以我们传递thresh属性，该属性用作标记的阈值。</li><li id="1a44" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">这里我们使用python中定义的部分函数。我建议读者学习python中的部分函数。它用一些属性的预定义值调用真正的函数。这里我们已经预定义了thresh属性值。</li></ul><p id="8baa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们继续之前，我想讨论一下f_score。<br/> <strong class="jq hj">精度</strong> —以真阳性与实际结果之比来衡量。意思是在所有的实际产出中，有多少预测是实际真实的。<br/> <strong class="jq hj">回忆</strong> —它被定义为真阳性与预测结果的比率。这意味着ao所有的预测输出，有百分之多少涵盖了真阳性。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mm"><img src="../Images/6af5366bf806827930230fc8c96a22ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*qLGz8BenLcrlxZ5xPdPI9g.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">F1分数或f_score</figcaption></figure><p id="ad9d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们只剩下已知的东西了。所有这些在我的第一篇关于分类的博客中都有详细的提及。<a class="ae ix" rel="noopener" href="/@PJrohan/image-classification-using-fastai-5ff5b374d414">请过目</a>。这里我只说方法。</p><p id="e8f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一部分</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="09f5" class="kk kl hi ll b fi lp lq l lr ls">learn.lr_find()<br/>learn.recorder.plot()<br/>learn.fit_one_cycle(5, slice(lr)) where lr is the learning rate.<br/>learn.save('stage-1-rn50')</span></pre><p id="3cc8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二部分</p><pre class="iz ja jb jc fd lk ll lm ln aw lo bi"><span id="902a" class="kk kl hi ll b fi lp lq l lr ls">learn.unfreeze()<br/>learn.lr_find()<br/>learn.recorder.plot()<br/>learn.fit_one_cycle(5, slice(lr-1, lr-2))<br/>learn.save('stage-2-rn50')</span></pre><p id="c3a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">❓如何选择学习率</p><ul class=""><li id="9de6" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">解冻前-找到最陡的坡度，但不要在底部，并试验其周围的值。</li><li id="005a" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">解冻后——我们使用slice()，其中第二个参数与冻结前的参数相同，但您可以根据得到的结果将其除以一些值，如lr/5、lr/10等。对于第一个论点，你必须很有实验性。就一般意义而言，找到图表中刚好在它被击落之前的部分，并且只对图表中该部分周围的值进行实验。例如:</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mn"><img src="../Images/9e5284c3d2ef7b541792ac4e2d649107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*jBEwLtC1T8EYrZ9fXNIk7g.png"/></div></figure><ul class=""><li id="b9df" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">如上所述，被称为区别学习率的技术是基于我从fastai那里学到的。我建议读者尝试一下这些值，如果他们发现其他值更有价值的话，可以使用其他值。</li><li id="d730" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">这是验证码。当我们声明区别学习率时，我们向一组层而不是单个层提供不同的学习率。如果你使用cnn来创建学习者，我们通常把层分成3层组。第一组由添加的层组成，其余的层分为两个独立的组。这也称为微调。</li></ul><p id="6c8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi mo translated">数据集的多分类标注到此结束。<br/>向读者致谢。</p><h1 id="a490" class="mx kl hi bd km my mz na kq nb nc nd ku io ne ip kx ir nf is la iu ng iv ld nh bi translated">参考</h1><ul class=""><li id="46c1" class="lv lw hi jq b jr lf ju lg jx ni kb nj kf nk kj ma mb mc md bi translated">fast.ai</li></ul></div></div>    
</body>
</html>