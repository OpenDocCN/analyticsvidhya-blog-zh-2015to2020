<html>
<head>
<title>Camera Calibration with OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV进行摄像机校准</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/camera-calibration-with-opencv-f324679c6eb7?source=collection_archive---------0-----------------------#2019-02-09">https://medium.com/analytics-vidhya/camera-calibration-with-opencv-f324679c6eb7?source=collection_archive---------0-----------------------#2019-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们谈论相机校准和图像失真时，我们谈论的是当相机查看真实世界中的3D对象并将它们转换为2D图像时会发生什么。这种转变并不完美。</p><p id="26ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，这里有一个道路的图像和一些通过不同的相机镜头拍摄的轻微扭曲的图像。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/96c1b7eb008d0c982d0642a498afa6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*O41plkKxm9SFvpQEbt_U3A.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">道路的原始图片</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/bba6aa0bbc36decf2d710cdaa9bd3494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLv96PyejmWq1M5xjuKWUA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">相机拍摄的上述图片的变形版本</figcaption></figure><p id="9768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这些扭曲的图像中，你可以看到车道的边缘是弯曲的，呈圆形或向外伸展。我们分析相机的第一步是消除这种失真，这样我们就可以从中获得正确和有用的信息。</p><h1 id="2b5d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为什么失真？</h1><p id="3ef5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在我们进入代码并开始纠正失真之前，让我们先直观地了解一下这种失真是如何发生的。</p><p id="eebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的相机模型，叫做针孔相机模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kx"><img src="../Images/2f2e5a5a54edc5099bb2cbb44eabfdd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Wh9L_VYNsPbBf5m2u0aXw.png"/></div></div></figure><p id="cf65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当照相机看着一个物体时，它就像我们的眼睛一样看着这个世界。通过聚焦世界上物体反射的光。在这种情况下，通过一个小针孔，相机将反射的光聚焦到3D交通标志上，并在相机后面形成2D图像。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/0b9f1adcca2fe2a851b74da84f675129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*R7Ec-32NFWWf9E7K9SgnRA.png"/></div></figure><p id="3143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数学中，从X，Y和Z的3D对象点P到X和Y的转换是通过一个称为<strong class="ih hj">相机矩阵(C) </strong>的转换矩阵来完成的，我们将使用它来校准相机。</p><p id="953b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，真正的相机不会使用微小的针孔；他们使用<strong class="ih hj">透镜</strong>一次聚焦多条光线，这使得他们能够快速成像。但是，镜片也会引入<strong class="ih hj">失真</strong>。</p><blockquote class="kz la lb"><p id="1969" class="if ig lc ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">在相机的曲面镜头边缘，光线经常弯曲得太多，这就产生了扭曲图像边缘的效果。</p></blockquote><h1 id="f2f9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">失真的类型</h1><p id="af39" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> <em class="lc">径向失真:</em> </strong>径向失真是影响图像最常见的一种类型，其中当相机拍摄的图片中的直线出现轻微的弯曲或弯曲</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lg"><img src="../Images/17043c2028dec31855f2a259e859d796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUl8POYptRmR4UzCM4Ox8Q.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">被摄像机径向扭曲</figcaption></figure><p id="5e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lc">切向畸变:</em> </strong>切向畸变主要是由于镜头与成像平面不平行，使图像拉长一点或倾斜一点，使物体看起来比实际更远或更近。</p><div class="je jf jg jh fd ab cb"><figure class="lh ji li lj lk ll lm paragraph-image"><img src="../Images/8c8612c7e10b5e24ec30a1ba3f0a0529.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*VaeeJWD3M3Qu2BbJ-hyuNg.png"/></figure><figure class="lh ji ln lj lk ll lm paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><img src="../Images/888f3b6300dbd5f5cfdfa29ca872fb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*bkF_vos8mQSFe7jy5JXsJA.png"/></div></figure></div><p id="d0e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了减少失真，幸运的是，这种失真可以通过称为<strong class="ih hj">失真系数</strong>的五个数字来捕捉，其值反映了图像中径向和切向失真的量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/65c42a555d5d36259b8e2061c694911a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*kDPV6S_yLNE15lwuC9nxQA.png"/></div></figure><p id="5bcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们知道所有系数的值，我们可以用它们来校准我们的相机，使失真的图像不失真。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lp"><img src="../Images/cd70d79cd35b6902f7864b2fcfea4d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dc3TTGhlqfQNp_XJY3xKw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">用失真系数使失真的图像不失真。</figcaption></figure><h1 id="938e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">测量失真</strong></h1><p id="9790" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">所以，我们知道扭曲改变了图像中物体的大小和形状。但是，我们如何校准呢？</p><p id="52dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我们可以拍摄已知形状的照片，然后我们将能够检测和纠正任何失真错误。我们可以选择任何形状来校准我们的相机，我们将使用<strong class="ih hj">棋盘。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/f71d02c80e6aade9f436ddc29c983bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*kuatnf9nLE0vZsC0qF7pTQ.png"/></div></figure><p id="583c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">棋盘非常适合校准，因为它的规则、高对比度图案使其易于自动检测。我们知道一个没有扭曲的平面棋盘是什么样子。所以，如果我们用相机从不同角度拍摄棋盘</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lr"><img src="../Images/fe4f25d9301250b88dc83dc8d907a51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owW3QvK-yQqdVLxkDQn53g.png"/></div></div></figure><h1 id="a514" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">寻找角落</h1><p id="0f45" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Open CV通过<em class="lc">findchesboardcorners()</em>和<em class="lc">drawchesboardcorners()</em>帮助自动检测角点并在其上绘制</p><p id="934d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对样本图像应用这两个函数，结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ls"><img src="../Images/e430a82198f60808858f649188013114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoHEjJmK58OaO0xmnItayg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">应用<em class="lt">findchesboardcorners()</em>和<em class="lt">drawchesboardcorners()</em>后</figcaption></figure><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="5fb1" class="lz jv hi lv b fi ma mb l mc md">import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import matplotlib.image as mpimg</span><span id="cc68" class="lz jv hi lv b fi me mb l mc md"># prepare object points<br/>nx = 8 number of inside corners in x<br/>ny = 6 number of inside corners in y</span><span id="4f8f" class="lz jv hi lv b fi me mb l mc md"># Make a list of calibration images<br/>fname = 'calibration_test.png'<br/>img = cv2.imread(fname)</span><span id="aa2d" class="lz jv hi lv b fi me mb l mc md"># Convert to grayscale<br/>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><span id="b416" class="lz jv hi lv b fi me mb l mc md"># Find the chessboard corners<br/>ret, corners = cv2.findChessboardCorners(gray, (nx, ny), None)</span><span id="44b6" class="lz jv hi lv b fi me mb l mc md"># If found, draw corners<br/>if ret == True:<br/>    # Draw and display the corners<br/>    cv2.drawChessboardCorners(img, (nx, ny), corners, ret)<br/>    plt.imshow(img)</span></pre><h1 id="c8d0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">校准摄像机</h1><p id="50dc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">为了校准摄像机，第一步是读入棋盘的校准图像。建议使用至少20张图像来获得可靠的校准，为此，我们这里有很多图像，每个棋盘都有8×6个角来检测，</p><p id="f179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了校准相机，OpenCV给了我们<strong class="ih hj"><em class="lc">calibrate camera()</em></strong>函数</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mf"><img src="../Images/fe466bf99fef344a1ea6af2301dd8dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CDYzCBsuSB0uFN9GTd6yw.png"/></div></div></figure><p id="2eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它接收对象点、图像点[ <em class="lc">将在一会儿理解这些点</em> ]，以及图像的形状，并使用这些输入，它计算并返回</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mg"><img src="../Images/3a1a532c01ddb5645700240d41d97c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVKMMo_RnI0bUw_6h4CXMA.png"/></div></div></figure><p id="3f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> mtx </strong>:相机矩阵，帮助将3D物体点转换为2D图像点。</p><p id="8f06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> dist: </strong>失真系数</p><p id="b9bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它还返回摄像机在世界上的位置，以及旋转和平移向量的值<strong class="ih hj"> rvecs，tvecs </strong></p><p id="f710" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要的下一个函数是<strong class="ih hj"> <em class="lc"> undistort() </em> </strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mh"><img src="../Images/994c3e26b73bc69aa8c3ed031f8c0567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wjojfc9y4edjrBW_Va0Lw.png"/></div></div></figure><p id="ccdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无失真函数接收失真图像、我们的相机矩阵和失真系数，并返回一个<strong class="ih hj">无失真</strong>，通常称为<strong class="ih hj">目标图像。</strong></p><p id="d6cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在calibrateCamera()函数中，我们需要对象点和图像点。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="36b7" class="lz jv hi lv b fi ma mb l mc md">import numpy as np <br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import matplotlib.image as mpimg</span><span id="62e7" class="lz jv hi lv b fi me mb l mc md">#read in a calibration image<br/>img = mpimg.imread('../calibration_images/calibration1.jpg')<br/>plt.imshow(img)</span></pre><p id="f13d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，完成numpy、openCV和绘图导入，然后我们将读取第一个图像<code class="du mi mj mk lv b">calibarion1.jpg</code>并显示它。</p><p id="a2b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们要将2D显示图像中称为<code class="du mi mj mk lv b">imagepoints</code>的角的坐标映射到真实的、未失真的棋盘角的3D坐标，称为<code class="du mi mj mk lv b">objectpoinst</code>。</p><p id="9167" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将建立两个空数组来存放这些点，<code class="du mi mj mk lv b">objectpoints</code>和<code class="du mi mj mk lv b">imagepoints</code></p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="0014" class="lz jv hi lv b fi ma mb l mc md"># Arrays to store object points and image points from all the images</span><span id="e9e5" class="lz jv hi lv b fi me mb l mc md">objpoints = [] # 3D points in real world space<br/>imgpoints = [] # 2D points in image plane</span></pre><p id="4df6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标点都是相同的，只是已知的8×6棋盘的棋盘角。</p><p id="8b1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将准备这些对象点，首先在一个数组中创建6×8个点，每个点有三列，分别表示每个角的x、y和z坐标。然后，我们将使用Numpy的zeros函数将所有这些初始化为0。z坐标将保持为零，因此保持不变，但是对于我们的前两列x和y，使用Numpy的<code class="du mi mj mk lv b">mgrid</code>函数来生成我们想要的坐标。<code class="du mi mj mk lv b">mgrid</code>返回给定网格大小的坐标值，并将这些坐标分成两列，一列用于x，一列用于y:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="3ce0" class="lz jv hi lv b fi ma mb l mc md"># Prepare obj points, like (0, 0, 0), (1, 0, 0), (2, 0, 0)....., (7, 5, 0)</span><span id="6251" class="lz jv hi lv b fi me mb l mc md">objp = np.zeros((6*8,3), np.float32)<br/>objp[:,:,] =  mp.mgrid[0:8,0:6].T.reshape(-1,2) # x,y coordinates </span></pre><p id="6d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来创建<code class="du mi mj mk lv b">imagepoints</code>，我们需要考虑失真的校准图像并检测板子的角。OpenCV为我们提供了一种简单的检测棋盘角的方法，它使用一个名为<code class="du mi mj mk lv b">findChessboardCorners()</code>的函数，返回在灰度图像中发现的角。</p><p id="9aca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我们将把图像转换成灰度，然后传递给<code class="du mi mj mk lv b">findChessboardCorners()</code>函数。这个函数接收一个<code class="du mi mj mk lv b">grayscle</code>图像以及棋盘角的尺寸。在这种情况下，8乘6，最后一个参数用于任何标志；本例中没有:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="24b6" class="lz jv hi lv b fi ma mb l mc md"># Convert image to grayscale<br/>gray = cv2.cvtColor(img, cv2.COLOR_BRG2GRAY)</span><span id="232f" class="lz jv hi lv b fi me mb l mc md"># Find the Chesse board corners<br/>rer, corners = cv2.findChessboardCorners(gray, (8,6), None)</span></pre><p id="3ec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这个函数检测到了角点，我们将把这些点添加到图像点数组中，并将准备好的对象点<code class="du mi mj mk lv b">objp</code>添加到<code class="du mi mj mk lv b">objectpoints</code>数组中。这些目标点对于所有的校准图像都是相同的，因为它们代表了真实的棋盘。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="87a7" class="lz jv hi lv b fi ma mb l mc md"># If corners are found, add object points, image points<br/>if ret == True:<br/>    imgpoints.append(corners)<br/>    objpoints.append(objp)  </span></pre><p id="62b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们还绘制检测到的角点，调用<code class="du mi mj mk lv b">drawChessboardCorners()</code>，获取我们的图像、角点尺寸和角点。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="cf34" class="lz jv hi lv b fi ma mb l mc md"># If corners are found, add object points, image points<br/>if ret == True:<br/>    imgpoints.append(corners)<br/>    objpoints.append(objp)<br/>    <br/>    # Draw and display the corners<br/>    img = cv2.drawChessboardCorners(img, (8,6), corners, ret)<br/>    plt.imshow(img)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ml"><img src="../Images/c3c17f421c138d4dc028a067bd6d1b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ofE5NjiT0kqLv3YnFMriQ.png"/></div></div></figure><h1 id="6c7d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">失真校正</h1><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="e9cb" class="lz jv hi lv b fi ma mb l mc md">import pickle<br/>import cv2<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import matplotlib.image as mpimg</span><span id="7945" class="lz jv hi lv b fi me mb l mc md"># Read in the saved objpoints and imgpoints<br/>dist_pickle = pickle.load( open( "wide_dist_pickle.p", "rb" ) )<br/>objpoints = dist_pickle["objpoints"]<br/>imgpoints = dist_pickle["imgpoints"]</span><span id="9baa" class="lz jv hi lv b fi me mb l mc md"># Read in an image<br/>img = cv2.imread('test_image.png')</span><span id="58f7" class="lz jv hi lv b fi me mb l mc md">def cal_undistort(img, objpoints, imgpoints):<br/>    ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, img.shape[1:], None, None)<br/>    undist = cv2.undistort(img, mtx, dist, None, mtx)<br/>    return undist</span><span id="e7e5" class="lz jv hi lv b fi me mb l mc md">undistorted = cal_undistort(img, objpoints, imgpoints)</span><span id="bf67" class="lz jv hi lv b fi me mb l mc md">f, (ax1, ax2) = plt.subplots(1, 2, figsize=(24, 9))<br/>f.tight_layout()<br/>ax1.imshow(img)<br/>ax1.set_title('Original Image', fontsize=50)<br/>ax2.imshow(undistorted)<br/>ax2.set_title('Undistorted Image', fontsize=50)<br/>plt.subplots_adjust(left=0., right=1, top=0.9, bottom=0.)</span></pre><p id="4fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取<a class="ae mm" href="https://s3-us-west-1.amazonaws.com/udacity-selfdrivingcar/files/Advanced_Lane_Finding_Images/correct_for_distortion/wide_dist_pickle.p" rel="noopener ugc nofollow" target="_blank">失真酸洗文件</a>和<a class="ae mm" href="https://s3-us-west-1.amazonaws.com/udacity-selfdrivingcar/files/Advanced_Lane_Finding_Images/correct_for_distortion/test_image.png" rel="noopener ugc nofollow" target="_blank">测试图像</a></p><p id="b271" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/10a4fda07be2e93f25ae48fc22835faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*KR71E-iu_Z5PNCUATg6XIA.png"/></div></figure><p id="f08f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考:Udacity自动驾驶汽车工程师Nanodegree</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/b8fe2cb45e21df7a7da62feea0bf3b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GVQD9AZADus5ilHq8mOxJg.png"/></div></figure></div></div>    
</body>
</html>