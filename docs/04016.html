<html>
<head>
<title>Excel in pRod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">擅长生产</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/excel-in-prod-181ab49d06a9?source=collection_archive---------15-----------------------#2020-03-01">https://medium.com/analytics-vidhya/excel-in-prod-181ab49d06a9?source=collection_archive---------15-----------------------#2020-03-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6a00" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">或者<em class="ix">如何使用水管工</em>或<em class="ix">微excel微服务</em>将excel整合到生产API中</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/08df472421b3555b40b2eab4fe9aba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0oItMqzlqPGaCawU"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">照片由<a class="ae jo" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae jo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f1e4" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><em class="kl">最初发表于</em><a class="ae jo" href="http://josiahparry.com/post/2020-03-01-excel-in-prod/" rel="noopener ugc nofollow" target="_blank"><em class="kl">http://josiahparry.com</em></a><em class="kl">。</em></p><p id="a9c2" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我最近有一次谈话，谈到了使用自动解析Excel文档来管理数据科学资产。这引出了一些非常有趣的观点:</p><ol class=""><li id="e1e6" class="km kn hi jr b js jt jv jw jy ko kc kp kg kq kk kr ks kt ku bi translated">Excel有时是不可避免的，我们需要接受这一点。</li><li id="8fff" class="km kn hi jr b js kv jv kw jy kx kc ky kg kz kk kr ks kt ku bi translated">如何才能将Excel融入到生产中？</li></ol><blockquote class="la lb lc"><p id="d831" class="jp jq kl jr b js jt ij ju jv jw im jx ld jz ka kb le kd ke kf lf kh ki kj kk hb bi translated"><em class="hi">注意，现在不是时候💩在Excel上。它服务于非常真实的商业目的，不幸的是不是每个人都能学会编程😕。对于h8rs来说，这里有一个有趣的问题:几乎每个总统选举活动的数据程序都是基于Google Sheets的背面。</em></p></blockquote><p id="ba77" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在这篇文章中，我开始探索是否以及如何将Excel整合到生产代码中。这里使用的代码请参见<a class="ae jo" href="https://github.com/JosiahParry/plumber-excel" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="8419" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">生产化代码是什么意思——也就是把它放到产品中？这是什么意思，没有一个统一定义，每个组织都有不同的操作方法。</p><blockquote class="la lb lc"><p id="7daa" class="jp jq kl jr b js jt ij ju jv jw im jx ld jz ka kb le kd ke kf lf kh ki kj kk hb bi translated"><em class="hi"/>可操作化的定义<em class="hi">，至少从社会科学的角度来看，是如何定义一个事物，以便对该事物有一个共同的理解。</em></p></blockquote><p id="a53d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">格雷格·威尔逊将其定义为“不会让运营团队哭泣的代码”(强调他的)。这是我最喜欢的定义，因为它是异想天开的、讽刺的、诚实的，并且承认代码将不得不离开数据科学的核心圈子。</p><p id="b9af" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">据我所知，当前的数据科学讨论强调使用RESTful APIs作为最好的，或者至少是主导的，生产代码的方式。</p><p id="1654" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">API是一个应用程序编程接口。当我第一次学习什么是API时，我叔叔告诉我把它们想象成“与其他机器对话的机器”那并不遥远！</p><p id="d336" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">RESTful API是一种特殊的API。坦率地说，我不知道这到底意味着什么。据我理解，REST实际上是一种自以为是的API架构方式。RESTful APIs使用HTTP请求，这使得它们非常容易访问。RESTful APIs是开发微服务的关键，微服务是将代码放入产品的核心。在python生态系统中，Flask是制作微服务的领先库之一。在R空间中，一个名为<code class="du lg lh li lj b">plumber</code>的包承担了这个角色。</p><p id="6511" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们可以设想一个假设的场景，其中我们通过一些数据收集过程接收Excel文件。一旦收到该Excel文件，它将用于启动一些其他流程，例如报告编写或数据处理。人们通常会创建闪亮的应用程序来提供上传和数据输入的UI。当我们想开发一个以用户为中心的界面时，这真的很棒。但是当我们想要自动化这个过程或者至少让其他工具可以使用这个过程的时候呢？这时，我们可以求助于plumber来创建一个微服务来处理这个问题。</p><p id="4211" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">上图(用制作)展示了两种不同的方法。首先，我们将收到Excel文件。从那里，我们可能希望将文件上传到共享驱动器、数据库或两者。或者，我们可能不想存储数据，而是想立即使用它。</p><p id="d1ee" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">从API开发的角度来看，我们可以将每个流程想象成一个API <em class="kl">端点</em>。端点本质上是一个url，它表明每个应用程序交互将在哪里发生。在这个小例子中，我们将创建两个端点:<code class="du lg lh li lj b">/read_excel</code>和<code class="du lg lh li lj b">/upload</code>。第一个会，你猜对了，读取一个随请求发送的Excel文件。第二个将上传所述文件。</p><p id="5d91" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在我们着手创建API之前，我们需要首先弄清楚如何通过API发送文件。在我们弄清楚这一点之前，我们需要知道我们可以向API发出什么类型的请求。因为REST API将是一个HTTP API，所以我们必须知道使用HTTP协议可以发出什么类型的请求。有7种HTTP请求类型。</p><p id="1efb" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">坦白地说，我不记得<code class="du lg lh li lj b">HEAD</code>、<code class="du lg lh li lj b">PATCH</code>和<code class="du lg lh li lj b">OPTIONS</code>是做什么的——如果你不使用它，你就会失去它，对吗？对于超级简单的API，我们只需要知道<code class="du lg lh li lj b">GET</code>和<code class="du lg lh li lj b">POST</code>请求——不要让我做任何事情，我不可信。</p><p id="0713" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><code class="du lg lh li lj b">GET</code>用于<em class="kl">从资源中获取</em>数据。您可以将键值对作为参数传递给<code class="du lg lh li lj b">GET</code>请求。"<code class="du lg lh li lj b">GET</code>请求仅用于请求数据(不能修改)."你永远不应该通过<code class="du lg lh li lj b">GET</code>请求发送敏感信息。</p><p id="e7cb" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这就把我们带到了<code class="du lg lh li lj b">POST</code>方法。<code class="du lg lh li lj b">POST</code>方法用于向服务器发送数据，以便创建、修改或更新资源。当你有很多参数要发送，或者如果它们是敏感的，或者如果你需要通过API发送一个文件，使用<code class="du lg lh li lj b">POST</code>。</p><p id="4066" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在研究这个API设计时，我有三个问题。</p><ol class=""><li id="871c" class="km kn hi jr b js jt jv jw jy ko kc kp kg kq kk kr ks kt ku bi translated">你是如何通过HTTP请求发送文件的？</li><li id="7248" class="km kn hi jr b js kv jv kw jy kx kc ky kg kz kk kr ks kt ku bi translated">一旦我们发送了它，我们如何访问文件，它去了哪里？</li><li id="baa0" class="km kn hi jr b js kv jv kw jy kx kc ky kg kz kk kr ks kt ku bi translated">我们如何将API中的数据传递给R？</li></ol><p id="0ae3" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我不会说Linux，所以祝福<code class="du lg lh li lj b">httr</code>让这变得简单(有点)。<code class="du lg lh li lj b">httr</code>包含发布excel文件的两个核心功能。有<code class="du lg lh li lj b">POST()</code>用于发出post请求，还有<code class="du lg lh li lj b">upload_file()</code>用于上传POST请求中的文件。</p><blockquote class="la lb lc"><p id="9c3f" class="jp jq kl jr b js jt ij ju jv jw im jx ld jz ka kb le kd ke kf lf kh ki kj kk hb bi translated">我们能不能花点时间来欣赏一下函数有时是多么完美的命名？越不言自明越好。</p></blockquote><p id="0566" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如果你没有太多使用<code class="du lg lh li lj b">httr</code>制作请求的经验，我建议你从<a class="ae jo" href="https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html" rel="noopener ugc nofollow" target="_blank">快速入门简介</a>开始。</p><p id="152e" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们的POST请求的结构如下所示</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="f18c" class="lo lp hi lj b fi lq lr l ls lt">POST(end_point, body = list(param = upload_file("file-path.ext")) )</span></pre><h1 id="da2d" class="lu lp hi bd lv lw lx ly lz ma mb mc md io me ip mf ir mg is mh iu mi iv mj mk bi translated">构建第一个端点</h1><p id="c2d3" class="pw-post-body-paragraph jp jq hi jr b js ml ij ju jv mm im jx jy mn ka kb kc mo ke kf kg mp ki kj kk hb bi translated">现在我们知道<em class="kl">文件将如何发送。但是困难的部分实际上是构建将接收它的管道工API端点。关于如何通过水管工上传文件有相当多的讨论。还好，<a class="ae jo" href="https://github.com/krlmlr" rel="noopener ugc nofollow" target="_blank"> @krlmlr </a>指出了<code class="du lg lh li lj b">mime::parse_multipart()</code>可以用来处理请求中发送的文件。</em></p><blockquote class="la lb lc"><p id="a394" class="jp jq kl jr b js jt ij ju jv jw im jx ld jz ka kb le kd ke kf lf kh ki kj kk hb bi translated">注意:MIME是通过互联网发送文件的标准方式。我对哑剧类型一无所知，非常欣赏谢一辉、杰弗里·霍纳和边·贝勒用这个包所做的工作，他们把所有这些都抽象了出来。</p></blockquote><p id="39ec" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><code class="du lg lh li lj b">parse_multipart()</code>将接受传入的请求并返回一个命名列表。对我们来说最重要的是，返回的对象包含了我们发布到临时位置的文件。在结果列表中是临时文件的路径。在我们的管道工函数定义中，我们解析请求，并取出<code class="du lg lh li lj b">datapath</code>。保存的路径然后被提供给<code class="du lg lh li lj b">readxl::read_excel()</code>,后者返回一个tibble！</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="8565" class="lo lp hi lj b fi lq lr l ls lt">#* Read excel file #* @post /read_excel function(req) { </span><span id="28da" class="lo lp hi lj b fi mq lr l ls lt">  multipart &lt;- mime::parse_multipart(req) <br/>  fp &lt;- purrr::pluck(multipart, 1, "datapath", 1)<br/>  readxl::read_excel(fp) </span><span id="c010" class="lo lp hi lj b fi mq lr l ls lt">}</span><span id="1d71" class="lo lp hi lj b fi mq lr l ls lt">pr &lt;- plumber::plumb("plumber.R") <br/>pr$run(host = "127.0.0.1", port = 5846)</span><span id="1483" class="lo lp hi lj b fi mq lr l ls lt"># start a background job using the RStudio job launcher rstudioapi::jobRunScript(<br/>  path = file.path(here::here(), "activate.R"),<br/>  workingDir = here::here()<br/>)</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mr"><img src="../Images/f81427e6793e5a86796be0111f805ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*WT9k5L5HkIL33vwv.gif"/></div></figure><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="b0b4" class="lo lp hi lj b fi lq lr l ls lt">#* Read excel file <br/>#* @post /read_excel <br/>function(req) { <br/>  mime::parse_multipart(req) <br/>}</span></pre><h1 id="c201" class="lu lp hi bd lv lw lx ly lz ma mb mc md io me ip mf ir mg is mh iu mi iv mj mk bi translated">创建API包装</h1><p id="2a5c" class="pw-post-body-paragraph jp jq hi jr b js ml ij ju jv mm im jx jy mn ka kb kc mo ke kf kg mp ki kj kk hb bi translated">创建API包装器是我最喜欢的活动之一，因为它相当简单，而且感觉超级强大💪🏼。如前所述，我们创建POST请求所需要做的就是指定在哪里发出请求(端点)，并为其提供一些参数。</p><p id="0408" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在后台启动API。</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="13b6" class="lo lp hi lj b fi lq lr l ls lt"># start a background job using the RStudio job launcher rstudioapi::jobRunScript(<br/>  path = file.path(here::here(), "activate.R"),<br/>   workingDir = here::here())</span></pre><p id="48a1" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们首先用端点定义一个名为<code class="du lg lh li lj b">b_url</code>(基本url)的对象。接下来，我们在<code class="du lg lh li lj b">upload_file()</code>命令中指定想要上传的文件的路径。在存储库中，我已经包含了<code class="du lg lh li lj b">test.xls</code>，它包含了美国社区调查(社会科学，amirite？).请注意，上传的文件是<code class="du lg lh li lj b">body</code>参数中命名列表的一部分。任何需要传递给API的参数都需要在提供给<code class="du lg lh li lj b">body</code>的列表中定义。我<em class="kl">认为</em>上传文件的名称需要与plumber API ( <code class="du lg lh li lj b">req</code>)中定义的名称相匹配。我可能错了，但为了安全起见！</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="d3af" class="lo lp hi lj b fi lq lr l ls lt">library(httr) <br/>library(tidyverse)<br/> <br/># define the url b_url &lt;- "http://127.0.0.1:5846/read_excel" </span><span id="51d2" class="lo lp hi lj b fi mq lr l ls lt"># make the request! <br/>req &lt;- POST(b_url, body = list(req = upload_file("data/test.xls")))</span></pre><p id="a1f1" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们现在已经上传了文件并提出了我们的请求！虽然如果我们不能访问数据，这个请求对我们没有用😮。我们可以使用<code class="du lg lh li lj b">httr::content()</code>获得请求的内容。我设置了<code class="du lg lh li lj b">type = "text/json"</code>,因为我发现将json转换成tibble比转换成命名列表更容易。</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="d2b9" class="lo lp hi lj b fi lq lr l ls lt"># get json <br/>res_json &lt;- content(req, type = "text/json")<br/> <br/># show the first 50 characters of resultant json <br/>strtrim(res_json, 50)</span><span id="f631" class="lo lp hi lj b fi mq lr l ls lt">## [1] "[{\"statefip\":1,\"costelec\":7440,\"costgas\":5760,\"cos"</span></pre><p id="2315" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">要将这个json放入tibble，将使用<code class="du lg lh li lj b">jsonlite::fromJSON()</code>和<code class="du lg lh li lj b">tibble::as_tibble()</code>。</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="a784" class="lo lp hi lj b fi lq lr l ls lt">res &lt;- content(req, type = "text/json") %&gt;% <br/>  jsonlite::fromJSON() %&gt;% <br/>  as_tibble() </span><span id="d28b" class="lo lp hi lj b fi mq lr l ls lt">glimpse(res)</span><span id="7a29" class="lo lp hi lj b fi mq lr l ls lt">## Observations: 52 ## Variables: 27<br/>## $ statefip &lt;int&gt; 1, 2, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18... <br/>## $ costelec &lt;int&gt; 7440, 7080, 7320, 6600, 7800, 6240, 7800, 6720, 648... <br/>## $ costgas &lt;int&gt; 5760, 6240, 4800, 5880, 5400, 5520, 6840, 6360, 528... <br/>## $ costwatr &lt;int&gt; 3100, 3400, 3800, 3100, 4100, 3300, 3100, 2800, 360... <br/>## $ costfuel &lt;int&gt; 3900, 7100, 2800, 3300, 2900, 2400, 5700, 3500, 430... <br/>## $ condofee &lt;int&gt; 1100, 690, 1000, 870, 1200, 920, 940, 950, 1400, 14... <br/>## $ rent &lt;int&gt; 2400, 2800, 2900, 2000, 3900, 3200, 3300, 2800, 390... <br/>## $ proptx99 &lt;int&gt; 66, 69, 69, 67, 69, 69, 69, 69, 69, 69, 69, 69, 69,... <br/>## $ propinsr &lt;int&gt; 5400, 7500, 5000, 5200, 8100, 7200, 9800, 6000, 770... <br/>## $ mortamt1 &lt;int&gt; 3400, 4000, 5000, 3600, 7300, 5400, 7400, 4000, 700... <br/>## $ mortamt2 &lt;int&gt; 1600, 2900, 2400, 2200, 3900, 3600, 2900, 2700, 540... <br/>## $ moblhome &lt;int&gt; 4300, 7900, 10300, 4800, 13900, 12000, 8000, 10100,... <br/>## $ rooms &lt;int&gt; 16, 16, 15, 15, 14, 17, 17, 16, 16, 14, 18, 14, 17,... <br/>## $ bedrooms &lt;int&gt; 8, 8, 6, 6, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 8, 7, ... <br/>## $ valueh &lt;int&gt; 1551000, 1945000, 2387000, 1901000, 6288000, 348100... ## $ incwage &lt;int&gt; 391000, 439000, 412000, 422000, 565000, 498000, 718... ## $ incbus00 &lt;int&gt; 335000, 256000, 280000, 295000, 372000, 320000, 448... ## $ incinvst &lt;int&gt; 299000, 96000, 306000, 263000, 353000, 290000, 3230... ## $ incretir &lt;int&gt; 109000, 148000, 138000, 113000, 169000, 129000, 158... ## $ incother &lt;int&gt; 64000, 33200, 73000, 67000, 78000, 76000, 79000, 72... ## $ incwelfr &lt;int&gt; 10200, 11800, 12700, 11300, 18900, 14500, 19000, 75... ## $ incsupp &lt;int&gt; 22700, 24000, 25800, 22700, 25400, 26200, 26600, 24... ## $ incss &lt;int&gt; 34500, 32400, 34400, 35100, 35300, 35100, 37700, 36... ## $ age &lt;int&gt; 93, 91, 93, 94, 94, 93, 96, 92, 94, 95, 92, 96, 94,... ## $ trantime &lt;int&gt; 152, 162, 145, 129, 141, 157, 142, 157, 111, 150, 1... ## $ incbus00_min &lt;int&gt; -6900, -6500, -5000, -7800, -4800, -5800, -4800, -6... ## $ incincst_min &lt;int&gt; -1500, -800, -1600, -920, -2300, -1800, -1800, -140...</span></pre><p id="96d0" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">嘣！！！成功了。现在是时候把它变成一个函数了。为了使其通用化，我们需要让用户可以为<code class="du lg lh li lj b">upload_file()</code>指定文件路径。</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="f35c" class="lo lp hi lj b fi lq lr l ls lt"># define `post_excel()` <br/>post_excel &lt;- function(file) {</span><span id="487c" class="lo lp hi lj b fi mq lr l ls lt">   b_url &lt;- "http://127.0.0.1:5846/read_excel" </span><span id="ef9f" class="lo lp hi lj b fi mq lr l ls lt">   req &lt;- POST(b_url, body = list(req = upload_file(file))) </span><span id="864f" class="lo lp hi lj b fi mq lr l ls lt">   res &lt;- content(req, type = "text/json") %&gt;% <br/>             jsonlite::fromJSON() %&gt;%<br/>             tibble::as_tibble() res <br/>}</span></pre><p id="4221" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">您已经为您的API创建了一个包装器！现在您已经有了一个正在运行的微服务，可以通过R包装器访问它。</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="52c8" class="lo lp hi lj b fi lq lr l ls lt">post_excel("data/test.xls")</span><span id="fc44" class="lo lp hi lj b fi mq lr l ls lt">## # A tibble: 52 x 27 <br/>## statefip costelec costgas costwatr costfuel condofee rent proptx99 <br/>## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; <br/>## 1 1 7440 5760 3100 3900 1100 2400 66 <br/>## 2 2 7080 6240 3400 7100 690 2800 69<br/>## 3 4 7320 4800 3800 2800 1000 2900 69 <br/>## 4 5 6600 5880 3100 3300 870 2000 67 <br/>## 5 6 7800 5400 4100 2900 1200 3900 69 <br/>## 6 8 6240 5520 3300 2400 920 3200 69 <br/>## 7 9 7800 6840 3100 5700 940 3300 69 <br/>## 8 10 6720 6360 2800 3500 950 2800 69 <br/>## 9 11 6480 5280 3600 4300 1400 3900 69 <br/>## 10 12 6720 3480 3400 3600 1400 3300 69 <br/>## # ... with 42 more rows, and 19 more variables: propinsr &lt;int&gt;, ## # mortamt1 &lt;int&gt;, mortamt2 &lt;int&gt;, moblhome &lt;int&gt;, rooms &lt;int&gt;, <br/>## # bedrooms &lt;int&gt;, valueh &lt;int&gt;, incwage &lt;int&gt;, incbus00 &lt;int&gt;, <br/>## # incinvst &lt;int&gt;, incretir &lt;int&gt;, incother &lt;int&gt;, incwelfr &lt;int&gt;, ## # incsupp &lt;int&gt;, incss &lt;int&gt;, age &lt;int&gt;, trantime &lt;int&gt;, <br/>## # incbus00_min &lt;int&gt;, incincst_min &lt;int&gt;</span></pre><p id="aa84" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们可以为<code class="du lg lh li lj b">/upload</code>端点创建一个类似的函数。</p><pre class="iz ja jb jc fd lk lj ll lm aw ln bi"><span id="e8a6" class="lo lp hi lj b fi lq lr l ls lt">upload &lt;- function(file) { </span><span id="ae24" class="lo lp hi lj b fi mq lr l ls lt">  b_url &lt;- "http://127.0.0.1:5846/upload"</span><span id="91c0" class="lo lp hi lj b fi mq lr l ls lt">  usethis::ui_info(glue::glue("Copying {file} to /data/{file}")) </span><span id="ff0a" class="lo lp hi lj b fi mq lr l ls lt">  req &lt;- POST(b_url, body = list(req = upload_file(file))) </span><span id="adaa" class="lo lp hi lj b fi mq lr l ls lt">  invisible(req) <br/>}</span><span id="11d3" class="lo lp hi lj b fi mq lr l ls lt">upload("data/test.xls")</span><span id="d2f2" class="lo lp hi lj b fi mq lr l ls lt">## ℹ Copying data/test.xls to /data/data/test.xls</span></pre><blockquote class="la lb lc"><p id="0ee3" class="jp jq kl jr b js jt ij ju jv jw im jx ld jz ka kb le kd ke kf lf kh ki kj kk hb bi translated"><em class="hi">注:我建议使用{usethis}的</em> <code class="du lg lh li lj b"><em class="hi">ui_*()</em></code> <em class="hi">功能，为用户提供信息性消息。<br/>第二个注意:如果你打算只允许一个文件上传一次，就像这个函数所做的那样，你可能实际上应该使用一个上传请求。</em></p></blockquote><p id="397f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">吧嗒吧嗒嘣。现在，您可以使用plumber创建一个能够处理Microsoft Excel文件的微服务。这不是一个小壮举！下一步是什么？您应该为新创建的API创建一个漂亮的小python包装器。python包装器对您的团队来说将是一笔巨大的财富，现在您的基于R的工具可以被任何能够发出HTTP请求的人或事物访问！！！</p></div></div>    
</body>
</html>