<html>
<head>
<title>ML with Spotif(p)y</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带点的ML(p)y</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ml-with-spotif-p-y-fc27f0099a35?source=collection_archive---------8-----------------------#2019-11-16">https://medium.com/analytics-vidhya/ml-with-spotif-p-y-fc27f0099a35?source=collection_archive---------8-----------------------#2019-11-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1842" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">具有音频特征的Python机器学习</h2></div><h2 id="5143" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">介绍</h2><p id="3c2d" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">我开始这个项目时不得不谷歌“什么是机器学习”。然后，我继续学习传统的ml教程，使用<em class="ko"> Iris </em>数据集。现在，在这里我试图根据一首歌的音频特征来预测我是否会喜欢这首歌。</p><h2 id="aa18" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">数据采集</h2><p id="dffc" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">显而易见的事实是，机器学习依赖于数据。因此，让我们从从Spotify检索数据开始。</p><p id="f5ba" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">获取数据的第一步是向Spotify注册一个访问令牌。</p><div class="ku kv ez fb kw kx"><a href="https://developer.spotify.com/documentation/web-api/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hj fi z dy lc ea eb ld ed ef hh bi translated">Web API |面向开发者的Spotify</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">注意:使用Spotify开发者工具，即表示您接受Spotify开发者服务条款。基于简单的休息…</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">developer.spotify.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll lm kx"/></div></div></a></div><p id="bf84" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">到目前为止，有三个关键部分:客户机ID、客户机密钥和用户名。前两个将在获得访问令牌后给出。最后一个是用户ID，您可以从您的个人资料设置中获得。一旦解决了这个问题，我们就可以直接从Spotify数据目录中访问Spotify的专辑、曲目和艺术家数据。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="2c06" class="ix iy hi ls b fi lw lx l ly lz">import spotipy<br/>import spotipy.util as util<br/>from spotipy.oauth2 import SpotifyClientCredentials</span><span id="5d27" class="ix iy hi ls b fi ma lx l ly lz">#initialise a client credentials manager</span><span id="5f5c" class="ix iy hi ls b fi ma lx l ly lz">cid = ""<br/>secret = ""<br/>username = ""<br/>client_credentials_manager = SpotifyClientCredentials(client_id=cid, client_secret=secret)<br/>sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)<br/>playlists = sp.user_playlists(username)</span></pre><p id="c030" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">此时，我们有了一个Spotify对象来在线收集数据。下一步是使用追踪URIs创建数据框。URIs是统一的资源指示器——把它当作获取播放列表或歌曲详细信息的神奇门户。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="8684" class="ix iy hi ls b fi lw lx l ly lz">def get_playlist_tracks(username, playlist_id):<br/>  tracks_list= []<br/>  results = sp.user_playlist(username, playlist_id,<br/>  fields="tracks,next")<br/>  tracks = results['tracks']<br/>  while tracks:<br/>     tracks_list += [ item['track'] for (i, item) in<br/>     enumerate(tracks['items']) ]<br/>     tracks = sp.next(tracks)<br/>  return tracks_list</span><span id="9d54" class="ix iy hi ls b fi ma lx l ly lz">def get_playlist_URIs(username, playlist_id):<br/>  return [t["uri"] for t in get_playlist_tracks(username,<br/>  playlist_id)]</span></pre><h2 id="8e7b" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">使数据可用</h2><p id="f69c" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">使用URIs列表，我们可以获取歌曲的音频特征。在这种情况下，我创建了两个播放列表:我喜欢的歌曲和我不喜欢的歌曲——因此，有两个URI列表。因为每个列表的长度超过50，并且<em class="ko"> sp.audio_features </em>一次处理50个元素，我们必须创建一个<em class="ko"> splitlist </em>函数，将一个列表拆分成一个包含50个元素的列表。完成后，我遍历这个列表，并将音频特征保存到数据帧中。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="79b4" class="ix iy hi ls b fi lw lx l ly lz">#modified get features function</span><span id="a263" class="ix iy hi ls b fi ma lx l ly lz">def get_audio_features (track_URIs) :<br/>  features = []<br/>  r = splitlist(track_URIs,50)<br/>  for pack in range(len(r)):<br/>     features = features + (sp.audio_features(r[pack]))<br/>  df = pd.DataFrame.from_dict(features)<br/>  df["uri"] = track_URIs<br/>  return df</span></pre><p id="50ff" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">值得注意的是，该函数返回一系列音频特性，我只选择我认为与我的项目相关的特性。有关每项功能的详细说明，请访问:</p><p id="0f54" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated"><a class="ae mb" href="https://developer.spotify.com/documentation/web-api/reference/tracks/get-several-audio-features/" rel="noopener ugc nofollow" target="_blank">https://developer . Spotify . com/documentation/we b-API/reference/tracks/get-something-audio-features/</a></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="bdde" class="ix iy hi ls b fi lw lx l ly lz">[‘danceability’,’acousticness’,’energy’,’instrumentalness’,’speechiness’,’tempo’,’valence’]</span></pre><p id="145a" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">另一个重要的组成部分是标签。一旦我有了两个数据帧——一个包含我喜欢的歌曲的音频特征，另一个包含我不喜欢的歌曲的音频特征——我就向两个数据帧添加一列<em class="ko">‘target’</em>，并用1填充我喜欢的歌曲，用0填充我不喜欢的歌曲。这样，一旦两个数据帧被连接，两类歌曲之间就有了区别。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="6c47" class="ix iy hi ls b fi lw lx l ly lz">training_data = pd.concat([good_features_x,bad_features_x], axis=0, join='outer', ignore_index=True)</span></pre><h2 id="2c23" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">可视化数据</h2><p id="dadf" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">之前，我会查看特征，并选择我认为相关的特征。现在，我想以某种方式验证这两个播放列表之间的哪些功能实际上有显著差异。所以，我把它们画在同一个图上:如果我看不出太大的区别，我就不在我的ML模型中使用这个特性。例如，在绘制了节奏之后，我看到了两种分布的显著差异。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="7f70" class="ix iy hi ls b fi lw lx l ly lz">sns.distplot(good_features_df[['tempo']],color='indianred',axlabel='Tempo')<br/>sns.distplot(bad_features_df[['tempo']],color='mediumslateblue')<br/>plt.show()</span></pre><figure class="ln lo lp lq fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mc"><img src="../Images/b55fce9d97c848fce31978381550c0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqlkxRjXy8seT8h2Ap7acg.png"/></div></div></figure><p id="072d" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">另一方面，在可跳舞性曲线上，我认为这种差异可以忽略不计。</p><figure class="ln lo lp lq fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mc"><img src="../Images/5a84a9d5ff50c8d83964627dd7df543a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIex5JZ2ydLzbcBkTP9KoA.png"/></div></div></figure><p id="fc1d" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">毕竟，我解决了以下问题:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="304f" class="ix iy hi ls b fi lw lx l ly lz">features = ['tempo','acousticness','energy','instrumentalness','speechiness']</span></pre><h2 id="f1b1" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">将数据分为训练和测试</h2><p id="ccd3" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">我选择80/20分割我的数据:80%用于训练模型，20%用于测试模型。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="d50b" class="ix iy hi ls b fi lw lx l ly lz">train, test = train_test_split(training_data, test_size = 0.2)<br/>x_train = train[features]<br/>y_train = train['target']<br/>x_test = test[features]<br/>y_test = test['target']</span></pre><h2 id="600f" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">决策树分类器</h2><p id="2289" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">这个模型适合我的目的，因为我正试图将歌曲分为两类。这本质上是一个两步走的过程:学习和预测。换句话说，必须有训练模型的数据和测试模型的数据。更详细地说，每个节点代表一个带有“决策规则”的音频特征，节点中的每个叶子是基于该规则的决策。在这种情况下，Decision是与将用于将歌曲分成类别的每个特征相关的数字。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="55b5" class="ix iy hi ls b fi lw lx l ly lz">dtc = DecisionTreeClassifier()<br/>dt = dtc.fit(x_train,y_train)<br/>y_pred = dtc.predict(x_test)<br/>score = accuracy_score(y_test, y_pred) * 100</span></pre><h2 id="2e14" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">k近邻分类器</h2><p id="b6b1" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">在这个模型中，点是缓慢聚集的。给定点A，模型找到最近的邻居。然后，这个邻居“投票”决定在哪里对点a进行分类。这是最简单的情况；在另一种情况下，票数可以改变，并且由于投票的性质，应该是奇数。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="68fb" class="ix iy hi ls b fi lw lx l ly lz">knc = KNeighborsClassifier(5)<br/>knc.fit(x_train,y_train)<br/>knn_pred = knc.predict(x_test)<br/>score = accuracy_score(y_test, knn_pred) * 100</span></pre><h2 id="cc41" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">主成分分析</h2><p id="465a" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">这种无监督学习技术通过分析特征方差并选择方差最大的特征，将多维数据转换为低维数据。早些时候，我通过查看单个图来手动完成。这个分析替我做了。因此，模型调整的输入之一是用于训练它的组件的数量。经过一些试验，我发现我的场景的理想数字是3。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="aa0c" class="ix iy hi ls b fi lw lx l ly lz">sc = StandardScaler()<br/>X_train = sc.fit_transform(x_train)<br/>X_test = sc.transform(x_test)<br/>pca = PCA(n_components=3)<br/>classifier = RandomForestClassifier(max_depth=2, random_state=0)<br/>classifier.fit(X_train, y_train)</span><span id="5b1f" class="ix iy hi ls b fi ma lx l ly lz">y_pred = classifier.predict(X_test)</span><span id="a70e" class="ix iy hi ls b fi ma lx l ly lz">print("Accuracy using the PCA model is: ", accuracy_score(y_test, y_pred), "%")</span></pre><h2 id="bc3a" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">挑战</h2><p id="0e83" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">第一个挑战是坐下来编辑一个我喜欢的歌曲列表。即便如此，我的播放列表也只有150首歌曲——但越多越好。同样，人们应该努力创建一个不喜欢的歌曲的播放列表，而不是像我做的那样随意添加歌曲。</p><p id="f60c" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">另一个挑战是从我的帐户中提取数据，然后从我的播放列表中提取数据，并决定哪些功能值得使用。</p><p id="0a4f" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">我花了一段时间才意识到，在连接两个数据帧之前，我需要以某种方式标记我喜欢和不喜欢的歌曲。</p><p id="efb1" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">令人惊讶的是，在我的数据上运行各种模型是这个项目最容易的部分之一。然而，我承认我的模型调得很差，因为(1)我对机器学习总体上没有很好的理解，以及(2)我没有掌握模型中的组件。</p><h2 id="3751" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">结论</h2><p id="191e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">我可以用主成分分析达到最高的准确率- 86.6%。树分类器产生了平均82%的准确度，而KNN模型产生了平均73%的准确度。</p><p id="2046" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">可以通过以下方式提高准确性:(1)在调整模型上花费更多时间，(2)努力创建两个播放列表，以及(3)拥有总共超过300个数据点。</p></div></div>    
</body>
</html>