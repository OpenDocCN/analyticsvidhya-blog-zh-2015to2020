<html>
<head>
<title>Web Scraping — An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络搜集—简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/web-scraping-an-introduction-1fccdfd039a3?source=collection_archive---------7-----------------------#2019-12-18">https://medium.com/analytics-vidhya/web-scraping-an-introduction-1fccdfd039a3?source=collection_archive---------7-----------------------#2019-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d5b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Web抓取通常是一个自动过程，包括扫描网页列表以查找数据，然后保存这些数据以备后用。这是可以手动完成的事情，但是当存在更容易的替代方案时，这是劳动密集型的并且是不必要的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/88d74852134707a508f5edae247f8a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*nHfayfdmxAApbg84iMrJqQ.gif"/></div></figure><p id="2d14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个自动化抓取过程的工具，我将研究用于python的Selenium库。这是一个非常简单实用的库，它可以使用一系列不同的浏览器来自动化抓取过程。要开始一个脚本，你必须<a class="ae jl" href="https://selenium-python.readthedocs.io/getting-started.html" rel="noopener ugc nofollow" target="_blank">创建一个“驱动”对象</a>。您可以在这里选择要使用的浏览器。在这篇文章中，我将略读这一点，但在必要的地方，我将把它称为“驱动程序”。</p><p id="c3a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很大一部分网页抓取是有一些HTML的基础知识；能够通读网页，找出你在搜索什么。我假设你至少知道一个基本的空白网页的结构，以及基本元素的名称。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/a9b356dba5576bc2e2a07526074c03b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSBvsxZoEz5meu9G4Kl6fg.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">来自Google的HTML片段</figcaption></figure><p id="bf45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使只看Google.com的HTML的前十几行(在左边)，也可以看出要遍历的级联和嵌套元素的数量增加得很快。我将解释如何在这些嵌套的元素中导航(以及一些页面的结构如何使它更容易)。</p><p id="e755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先让我们举一个更简单的网页的例子，这样我们就可以讨论如何挑选出我们想要的数据。下面你会发现HTML(带有一些内部CSS)，它构成了一个简单的，但非常不吸引人的网页。我将以此为例。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="2790" class="ka kb hi jw b fi kc kd l ke kf">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/> &lt;style&gt;<br/>  .a_div {background-color: blue; padding: 10px;}<br/>  .a_span {background-color: red; padding: 10px;}<br/>  #the_only_span {border-color: white; border-width: 5px; border-style: solid;}<br/>  #relevant_data {background-color: pink; padding: 10px;}<br/> &lt;/style&gt;<br/> &lt;title&gt;&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/> &lt;div class="a_div"&gt;<br/>  &lt;div class="a_div"&gt;<br/>   &lt;span class="a_span" id="the_only_span"&gt;<br/>    &lt;div id="relevant_data"&gt;<br/>     Web Scraping is a useful tool.<br/>    &lt;/div&gt;<br/>   &lt;/span&gt;<br/>  &lt;/div&gt;<br/> &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">id为“relevant _ data”的div是我们想要访问的。有两种主要的方法可以做到这一点——都需要我们能够阅读HTML结构，其中一种还需要我们理解哪个元素嵌套在哪个元素中。</p><p id="12bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从两者中较容易的开始。这个<div>有一个<em class="kg"> id </em>，这是页面中的唯一标识符。这使得它非常容易辨认。因此，通过用<em class="kg"> id </em>标识来查找保存在&lt; div &gt;中的文本，我们将使用:</div></p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="ce9c" class="ka kb hi jw b fi kc kd l ke kf">driver.get([WEB-PAGE NAME HERE]) # TO NAVIGATE TO THE PAGE</span><span id="774c" class="ka kb hi jw b fi kh kd l ke kf">relevant_div = driver.find_element_by_id('relevant_data')</span><span id="4059" class="ka kb hi jw b fi kh kd l ke kf">print(relevant_div.get_attribute('innerHTML')) # PRINT TEXT</span></pre><p id="99c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，这是一个非常简单的过程，我希望更多的网站可以使用这样一个易于交互的结构。唉，大多数使用潜在不一致的类，而不是<em class="kg"> id </em>的。然而，尽管使用笨拙命名的类，他们倾向于使用一致的嵌套系统。这将我们引向寻找所寻找元素的第二个主要方法。使用'<strong class="ih hj"> XPath </strong>'。</p><p id="6e9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们从感兴趣的元素中删除id。我们该如何独特地描述它呢？鉴于示例页面的简单性，它不会太复杂。我会让它稍微复杂一点，但是去掉CSS。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="b9db" class="ka kb hi jw b fi kc kd l ke kf">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/> &lt;title&gt;&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/> &lt;div class="a_div"&gt;<br/>  &lt;div class="a_div"&gt;<br/>   &lt;span class="a_span" id="the_only_important_span"&gt;<br/>    &lt;div&gt;<br/>     Web Scraping is a useful tool.<br/>    &lt;/div&gt;<br/>   &lt;/span&gt;<br/>  &lt;/div&gt;<br/> &lt;/div&gt;<br/> &lt;div class="a_div"&gt;<br/>  &lt;span class="a_span"&gt;<br/>   &lt;span class="a_span" id="the_only_span"&gt;<br/>    &lt;div&gt;<br/>     Ignore me.<br/>    &lt;/div&gt;<br/>   &lt;/span&gt;<br/>  &lt;/span&gt;<br/> &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="c465" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我在这里加倍了嵌套元素，但是你仍然可以看到我们正在寻找的重要的<span>。从这里开始，我将展示同样的方法可以用来找到这个<span>的两种方式。第一种是通过使用<em class="kg">“唯一重要的跨度”</em> <em class="kg"> id </em>来遍历跨度。</span></span></p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="ad9c" class="ka kb hi jw b fi kc kd l ke kf">relevant_div = <br/>     driver.find_element_by_xpath(//span[@id=<br/>     'the_only_important_span']/div[1])</span><span id="426d" class="ka kb hi jw b fi kh kd l ke kf">print(relevant_div.get_attribute('innerHTML')) # PRINT TEXT</span></pre><p id="cbf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们来看看这个xpath 告诉我们什么。“//”表示从匹配后面的字符串的任何元素开始查找。由于我们有“// &lt; span &gt;”，我们将查看当前的span元素。但是我们对它做了进一步的限制，用'<em class="kg">@ id = " the _ only _ important _ span "</em>'。这意味着我们只查看带有那个<em class="kg"> id </em>的任何&lt; span &gt;，碰巧只有一个。“/ &lt; div &gt; [1]”告诉我们选择出现在我们第一个选择的元素中的第一个&lt; div &gt;元素。在本例中，这正是我们要寻找的&lt; div &gt;！</p><blockquote class="ki kj kk"><p id="f35e" class="if ig kg ih b ii ij ik il im in io ip kl ir is it km iv iw ix kn iz ja jb jc hb bi translated">顺便提一下:<strong class="ih hj"> xpath </strong>不是零索引的，也就是说计数从‘1’而不是‘0’开始。</p></blockquote><p id="85ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们以稍微不同的方式使用<strong class="ih hj"> xpath </strong>，同样的例子。这一次我们不会使用id<em class="kg">id</em>，而是非常详细、具体地描述元素是如何嵌套的:</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="2795" class="ka kb hi jw b fi kc kd l ke kf">relevant_div = driver.find_element_by_xpath(//div/div/span/div[1])</span><span id="7a3a" class="ka kb hi jw b fi kh kd l ke kf">print(relevant_div.get_attribute('innerHTML')) # PRINT TEXT</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ko"><img src="../Images/0a6ef75fbf058c3e73eb511b8866a336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/1*mL1xFXsah-VwPWCH3svf2g.gif"/></div></figure><p id="8f84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据上一个例子中的描述，我们再次考虑从any ('//') <div>开始。在这个<div>中，我们寻找一个<div>，它包含一个<span>。在那个<span>中，我们寻找第一个<div>。这再次以稍微不同的方式独特地描述了我们重要的<div>。</div></div></span></span></div></div></div></p><p id="5788" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的两个例子中，可以省略“[1]”，因为只有一个<div>，但是明确说明任何变化是一个好的做法。</div></p><p id="eeb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这涵盖了定位元素和检索它们包含的信息的主要方法。在很大程度上，web抓取剩下的工作就是塑造你的搜索路径，存储你的数据，并决定如何处理它们！</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kw"><img src="../Images/67bad586da66b54f7882c7b90bb7fcd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/1*LLJrhElUSmqihuZgpx-wrw.gif"/></div></figure><p id="97b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能想知道为什么网络抓取？它有哪些应用？我现在的部分工作是记录我在LinkedIn上的帖子。通常是观点和反应(只是一个简单的数字，而不是对哪些反应的细分)。这是我期望通过LinkedIn API可以得到的东西。但遗憾的是，这是他们的版本1和版本2 APIs之间移除的许多特性之一。</p><p id="900c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我开始设置几个虚拟机来执行网络抓取。如果你想知道我是如何做到的，请看看我的下一篇文章！</p><p id="0e59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与此同时，考虑注册一个<a class="ae jl" href="http://bit.ly/OCTrialLink" rel="noopener ugc nofollow" target="_blank"> Oracle免费云试用</a>，看看你是否也可以用它做一些很酷的东西！</p><p id="91c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题，评论？你可以在LinkedIn上找到我。</p><blockquote class="kx"><p id="0614" class="ky kz hi bd la lb lc ld le lf lg jc dx translated">*所有观点均为我个人观点，与甲骨文无关*</p></blockquote></div></div>    
</body>
</html>