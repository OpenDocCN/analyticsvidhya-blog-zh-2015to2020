<html>
<head>
<title>Simplify Strategy Pattern Using Lambda Expression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lambda表达式简化策略模式</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simplify-strategy-using-lambda-expression-40195d1445ea?source=collection_archive---------1-----------------------#2019-12-30">https://medium.com/analytics-vidhya/simplify-strategy-using-lambda-expression-40195d1445ea?source=collection_archive---------1-----------------------#2019-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/eb86f3f2fa2065e5670f5999770232e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l556EAT1fDUMw1YixRBOJQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae iu" href="https://unsplash.com/s/photos/strategy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="aba1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">1.介绍</h1><p id="7988" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">策略设计模式是软件开发世界中使用最广泛的模式之一。在本文中，我们将学习策略设计模式，何时使用，何时不使用，我们如何利用该模式使我们的设计更加灵活？我们将看到一个例子，说明如何在有和没有lambdas的情况下实现它。</p><h1 id="a0e0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">2.战略设计模式</h1><h2 id="18e7" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">2.1定义</h2><p id="68f1" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了节省你搜索维基百科的时间，下面是定义:</p><blockquote class="lf lg lh"><p id="c874" class="jt ju li jv b jw lj jy jz ka lk kc kd ll lm kg kh ln lo kk kl lp lq ko kp kq hb bi translated"><strong class="jv hj">策略模式</strong>(也称为<strong class="jv hj">策略模式</strong>)是一个<a class="ae iu" href="https://en.wikipedia.org/wiki/Behavioral_design_pattern" rel="noopener ugc nofollow" target="_blank">行为</a> <a class="ae iu" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，它允许在运行时选择一个<a class="ae iu" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。代码不是直接实现单个算法，而是接收运行时指令，以决定使用哪一组算法。策略让算法独立于使用它的客户端而变化。</p></blockquote><p id="6ad3" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">策略模式的思想是定义一个算法家族，将不同的封装到不同的类中，并使它们的对象在上下文中可以互换。此处的“变化”是指:可能会因不断发展的需求而随时间发生变化。</p><h2 id="8ff8" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">2.2 UML图</h2><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/8eef29fb087e758ea9664ca203f4b0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TReMas4vAhC8YB9H3my4fA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">策略设计模式的UML类图示例</figcaption></figure><p id="55bf" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated"><code class="du lw lx ly lz b">Context</code>类不实现任何策略(算法)。相反，它维护一个对<code class="du lw lx ly lz b">Strategy</code>接口的引用。<code class="du lw lx ly lz b">Context</code>类不关心那些算法的实现。它只知道能执行那些算法！</p><p id="ecfc" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated"><code class="du lw lx ly lz b">StrategyImpl1</code>和<code class="du lw lx ly lz b">StrategyImpl2</code>实现<code class="du lw lx ly lz b">Strategy</code>接口，意思是实现并封装一个算法。</p><h2 id="e632" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">2.3何时使用/避免策略模式</h2><p id="6afe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">当您想要:</p><ul class=""><li id="e8a0" class="ma mb hi jv b jw lj ka lk ke mc ki md km me kq mf mg mh mi bi translated">在一个对象中使用不同的算法，并且能够在运行时从一种算法切换到另一种算法。</li><li id="1537" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn kq mf mg mh mi bi translated">对客户端隐藏算法的无关实现细节。通过使用依赖注入机制，实现在运行时被注入到客户端。</li><li id="9642" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn kq mf mg mh mi bi translated">用一行方法调用替换大量的条件语句。请注意，委托在这里起着重要的作用，因为这一行方法将在运行时基于引用类型调用适当的实现(<a class="ae iu" href="https://en.wikipedia.org/wiki/Dynamic_dispatch" rel="noopener ugc nofollow" target="_blank">动态分派</a>！).</li><li id="f00c" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn kq mf mg mh mi bi translated">用合成代替继承</li></ul><p id="fc7e" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">当你的算法很少改变时，避免使用策略模式，没有必要用伴随模式而来的新类和接口来过度设计程序</p><h2 id="b6ac" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">2.4行动中的经典战略</h2><p id="4db0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这个例子中，我将向您展示如何用Java实现经典的策略模式。这个例子模拟了一个使用各种算法(或策略)对列表进行排序和搜索的虚拟程序。从这里开始是我们的小演示的类图:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/5244a393eec108f6417aad4ebd644bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBTHqjhDvtibQzj2Jz2uNg.png"/></div></div></figure><p id="869a" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">注意，<code class="du lw lx ly lz b">Client</code>类依赖于<code class="du lw lx ly lz b">Context</code>和一些策略实现(我没有画we，因为我们不想在这里有意大利面条)。这是我们演示的实现(虚拟):</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="3e08" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">输出:</p><pre class="ls lt lu lv fd mr lz ms mt aw mu bi"><span id="74b0" class="kr iw hi lz b fi mv mw l mx my">List sorted using Bubble sort implementation<br/>list is binary searched<br/>---------------<br/>List sorted using Quick sort implementation<br/>list is linearly searched</span></pre><p id="2c69" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated"><code class="du lw lx ly lz b">Context</code> <strong class="jv hj"> <em class="li"> </em> </strong>类只依赖于声明策略的接口、<code class="du lw lx ly lz b">SortStrategy</code>和<code class="du lw lx ly lz b">SearchStrategy</code>。它不关心那些接口的实现。<code class="du lw lx ly lz b">BubbleSortStrategyImpl</code>和<code class="du lw lx ly lz b">BinarySearchStrategyImpl</code>分别是实现这些接口的类。正如我们之前所说，它们实现并封装了策略(算法)。</p><p id="71b7" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">例如，在第75行，这些实现被客户端注入到<code class="du lw lx ly lz b">Context</code>类中。所以当我们在运行时调用<code class="du lw lx ly lz b">context.sort(list)</code>和<code class="du lw lx ly lz b">context.search(“b”)</code>时，上下文将知道执行哪个实现(多态性)。</p><p id="2f31" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">注意类<code class="du lw lx ly lz b">Context</code>公开了setters，让客户端在运行时替换与上下文相关的策略实现(记住:策略让算法独立于使用它的客户端而变化)。</p><p id="aeae" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">假设我们有另一个需求来添加另一个排序或搜索策略实现，我们可以通过实现适当的策略接口来添加它，而无需更改任何现有的代码。<strong class="jv hj">可以看到，策略设计模式推广了开放/封闭原则</strong>。</p><h1 id="4d12" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">3.Lambda表达式和策略模式</h1><h2 id="ccd0" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">3.1概述</h2><p id="37f0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Lambda表达式改变了Java的世界，我们可以有效地使用lambda表达式来避免编写大量礼仪性的代码。</p><p id="1eeb" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">就策略设计模式而言，我们不必创建类的层次结构。相反，我们可以将接口的策略实现作为lambda表达式直接传递给上下文。</p><h2 id="e38a" class="kr iw hi bd ix ks kt ku jb kv kw kx jf ke ky kz jj ki la lb jn km lc ld jr le bi translated">3.2战略简化</h2><p id="9969" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">上面的代码很冗长，对于一个简单的算法来说，它有很多仪式。我们可以利用lambda表达式来减少代码的冗长。使用lambda，我们可以在一组函数对象中实现不同版本的算法，而不会用额外的类来增加代码。</p><p id="e4a3" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">在这个演示中，我们将重构代码以使用lambda表达式来避免创建自定义接口和类。这是重构的实现(虚拟)代码:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="0e47" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">注意我没有创建任何接口，因为我使用了来自<code class="du lw lx ly lz b">java.util.function</code>包的功能接口。</p><p id="bf20" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">输出与之前相同。但是需要注意的重要一点是，我并没有创建类和接口来实现这个策略。我所使用的是用<code class="du lw lx ly lz b"><a class="ae iu" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Consumer.html" rel="noopener ugc nofollow" target="_blank">Consumer</a></code>和<code class="du lw lx ly lz b"><a class="ae iu" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank">Function</a></code>接口组合<code class="du lw lx ly lz b">Context</code>类，并且我已经创建了setters，所以我可以在运行时改变策略行为。</p><p id="2d63" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">在客户端，我将实现(<a class="ae iu" href="https://en.wikipedia.org/wiki/Function_object" rel="noopener ugc nofollow" target="_blank">函数对象</a>)传递给<code class="du lw lx ly lz b">Context</code>类。</p><h1 id="945b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">4.结论</h1><p id="8de2" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在本文中，我们看到了策略设计模式的定义，以及如何使用它来提高设计的灵活性。我们还学习了策略模式的经典实现，以及使用Java 8特性的实现。在下一篇文章中，将会有更多的核心Java。敬请期待！</p><p id="bef9" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke lm kg kh ki lo kk kl km lq ko kp kq hb bi translated">请在下面的评论中告诉我们你的想法，别忘了分享哦！</p></div></div>    
</body>
</html>