<html>
<head>
<title>Time Series Analysis with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python进行时间序列分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-analysis-with-python-3a86baa78770?source=collection_archive---------2-----------------------#2020-02-02">https://medium.com/analytics-vidhya/time-series-analysis-with-python-3a86baa78770?source=collection_archive---------2-----------------------#2020-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="84ed" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">特斯拉股票价格的案例研究</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3936dabbc9d11ff20f7c3a03635e940b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YWPs5JeAF1R1z2GU1pYFQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcR4iIplt9jkStHY5yQHtEeUS1QETURMYCJZlvjdlAS4F7wM5TS7" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="0048" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">1.什么是时间序列</h1><p id="8dc7" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">时间序列是按连续的时间顺序排列的数据序列<strong class="ki hj"/>。当与时间结合时，数据的价值通常变得更加有用。我们可以通过时间序列分析获得更多的信息，这通常会导致预测。让我们来看看最常见的时间序列数据，股票数据。</p><p id="b757" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">前几天(准确的说是2020年1月25日)看了一篇文章，说特斯拉已经超越大众成为通用汽车之前第二大最有价值的汽车公司。大众还称赞了特斯拉，并开始其可再生能源(电动汽车)之路。这是一个伟大的消息，因为我是特斯拉的粉丝(来源:<a class="ae jn" href="https://www.bbc.com/news/business-51214824" rel="noopener ugc nofollow" target="_blank"> bbc </a>，<a class="ae jn" href="https://www.wsj.com/articles/tesla-tops-volkswagen-to-become-second-most-valuable-auto-maker-11579709320" rel="noopener ugc nofollow" target="_blank"> wsj </a>)。所以现在，让我们试着把他们的股价从雅虎。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/31d1cdbcc82fb3f3a22d1a29bd248a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVF-V_2Grob7mq4J3wiWNA.png"/></div></div></figure><p id="6e49" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果看到intersect，其实特斯拉在2015年底就已经战胜了大众，为什么现在才报道？良好的..上图是股价图。<strong class="ki hj">不代表</strong>一个公司的价值。一家公司的真正价值是市值，用<em class="lk">𝑠𝑡𝑜𝑐𝑘𝑝𝑟𝑖𝑐𝑒</em>×<em class="lk">𝑠ℎ𝑎𝑟𝑒𝑠</em>表示。特斯拉的股价确实在年前战胜了大众。但是特斯拉的股份没有大众那么多，这使得它不那么值钱了。</p><h1 id="f860" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">2.时间序列中的缺失值</h1><p id="46a0" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在继续之前，我们需要先清理数据。如你所见，有些日期有漏洞。这可能是由于市场误差，或我们还没有检查的东西。我们需要修复它，否则预测模型不能正常工作。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/2de7c07ad670fa24ead1bf27beddbc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*B1UzVnmyafTZQqCA7q54bA.png"/></div></figure><p id="abb1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">有许多方法可以填充这些<code class="du lm ln lo lp b">nan</code> -s。如果您有一个好的预测模型，您可以预测每个缺失的值。但这不是我们要做的，因为我们还没有建模。所以让我们从最简单的方法开始，做一个<code class="du lm ln lo lp b">ffill</code>或<code class="du lm ln lo lp b">bfill</code>来复制前一个/后一个数据值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="6701" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">3.时间序列成分</h1><p id="0ef4" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">时序数据有三个组成部分:</p><ul class=""><li id="cdc1" class="lq lr hi ki b kj lc km ld kp ls kt lt kx lu lb lv lw lx ly bi translated">趋势:数据在更大范围内的移动(移动平均线)</li><li id="0962" class="lq lr hi ki b kj lz km ma kp mb kt mc kx md lb lv lw lx ly bi translated">季节性:反复的季节性波动</li><li id="4b28" class="lq lr hi ki b kj lz km ma kp mb kt mc kx md lb lv lw lx ly bi translated">残差:没有从趋势或季节性中捕捉到的任何波动(应该是随机的)</li></ul><p id="54cf" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">根据趋势和季节性的性质，时间序列可以建模为<strong class="ki hj">加法</strong>或<strong class="ki hj">乘法</strong>时间序列。</p><ul class=""><li id="0739" class="lq lr hi ki b kj lc km ld kp ls kt lt kx lu lb lv lw lx ly bi translated"><strong class="ki hj">加法时间序列</strong></li></ul><p id="b653" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">观察值=趋势+季节性+残差</p><ul class=""><li id="9688" class="lq lr hi ki b kj lc km ld kp ls kt lt kx lu lb lv lw lx ly bi translated"><strong class="ki hj">乘法时间序列</strong></li></ul><p id="2823" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">观察值=趋势×季节×残差</p><p id="d94d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lk">资料来源:Hyndman，R.J .，&amp; Athanasopoulos，G. (2018)《预测:原理与实践》，第二版，2020年1月22日获取。</em></p><p id="9905" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">那么，如何区分加法和乘法时间序列，请看下面的一个例子图片(<a class="ae jn" href="https://kourentzes.com/forecasting/2014/11/09/additive-and-multiplicative-seasonality/" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es me"><img src="../Images/7a37b928b4d3ec2f0e91ba3c4fa1b22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*l3TW9hwiD-BFNOtRuSQD5w.png"/></div></figure><p id="82c6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">根据数据值，如果季节性的大小随时间而变化(见右图)，那么数据是倍增的。然而，我们的数据并没有显示出季节性增加或减少的明显证据，所以我们假设这是一个附加的时间序列。请再看一眼。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/906057f47622ebe6c7f14cc4f30bc7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmfQtJVAJuoqf8vmwmQ3DQ.png"/></div></div></figure><p id="61d8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在让我们尝试提取子组件。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/eac5934b7dff812c93a31fc5149f221c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnBfAbn2k_DCS0eGHDibKA.png"/></div></div></figure><p id="d4b0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在上面的例子中，我们使用<code class="du lm ln lo lp b">freq= 7*4*3</code> (~3个月)来模拟我们的数据。你可以通过保持<code class="du lm ln lo lp b">trend</code>可视化来调整它。如果趋势的可视化是平滑的，季节有模式，那么继续是好的。<br/><code class="du lm ln lo lp b">extrapolate_trend='freq'</code>将通过处理序列开始时的任何缺失值，使残差、趋势和季节的长度相同。<br/>现在我们已经分解了数据，让我们试着重构一下，看看公式是否正确。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mg"><img src="../Images/e3a7010e740343c32414cf51a3b42795.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*UyZbzuYpSkBK_-0Ca2jBOg.png"/></div></figure><p id="cd9a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">试着自己检查一下值是否相同，这样我们就有一个公式为真的证据。</p><h1 id="73ba" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">4.平稳时间序列</h1><p id="5ee9" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">平稳时间序列是数值不遵循时间函数的时间序列数据。</p><p id="21da" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">平稳时间序列和非平稳时间序列之间的差异在这些例子中是显而易见的(<a class="ae jn" href="https://towardsdatascience.com/stationarity-in-time-series-analysis-90c94f27322" rel="noopener" target="_blank">来源</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/a3d96a72d8b4fbabe52cf3c0791ec333.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*ynuU6lvOJluT-KhALP2KsQ.png"/></div></figure><p id="c7e5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">通过上面的例子，我们可以得出结论，对于每个窗口，平稳时间序列的方差可能是常数。为什么我们需要平稳的时间序列？这是因为平稳时间序列更容易分析，而且大多数预测算法对平稳时间序列都适用。让我们再次看看我们的数据</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/906057f47622ebe6c7f14cc4f30bc7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmfQtJVAJuoqf8vmwmQ3DQ.png"/></div></div></figure><p id="b99b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">通过研究我们的数据，数据似乎不是静止的。如果你对此有点怀疑，有几种测量方法可以测试数据的平稳性:<br/> -增强的迪基富勒(ADF)测试<br/> -科维亚特科夫斯基-菲利普斯-施密特-申-KPSS测试(趋势平稳)</p><p id="9963" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">让我们尝试使用ADF来检查我们的数据的平稳性，这是测试平稳性最常用的方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/01f5255a82243bf55490b7f1cbef5870.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*G1nesLh2BZZhAqJZSNa_Cw.png"/></div></figure><p id="ff72" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当您运行ADF测试时，结果应该是负值，并且P值应该低于某个阈值。比如我们会用p值&lt; 5%. Based on the result, the ADF Value is -0.7 wich means our data is not stationary enough. This result also show that p-value &gt; 5%，甚至远远超过10%。这表明我们数据在统计上不是稳定的。</p><h2 id="526f" class="mj jp hi bd jq mk ml mm ju mn mo mp jy kp mq mr ka kt ms mt kc kx mu mv ke mw bi translated">4.1将时间序列转换为平稳序列</h2><p id="2d08" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">有一些方法可以让一个数列变成平稳的:<br/> -求数列的差<br/> -把数列转换成它的对数<br/> -把数列转换成它的根<br/> -其他组合</p><p id="2d64" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">首先，让我们尝试最简单的方法，使用log。对数据应用对数将有效地消除变化的幅度，也可以使时间序列从乘法变为加法。现在让我们看看它有多稳定</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/3be944b7fb8181a26dcfb6715e77cba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_vOZu4Rj2GsJFRPma0lYQ.png"/></div></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es my"><img src="../Images/5eeeae41a079194586f448f1556738cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*_Jo2sxRvF6daWEqvZ6KdIg.png"/></div></figure><p id="4594" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">看来把我们的数据转换成它的日志并不足以让它静止。让我们试着改变方法，区别对待。差分数据是数学上应用的函数</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mz"><img src="../Images/e8d7bba7ab996f08209f9da8478b8300.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*X-W7LgD8MvYcLcz91gZ27g.png"/></div></figure><p id="95cb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">对于<code class="du lm ln lo lp b">t</code>从数据长度移动到2。</p><p id="1ebc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">你必须意识到这样一个事实，做差分会使第一个数据成为<code class="du lm ln lo lp b">nan</code>，因为事先没有数据。这意味着，做一次差分就会删除第一个数据，我们必须处理它(使用fillna或dropna)。进行两次差分将删除两个第一数据，依此类推。现在让我们看看做一次差分是否会使数据成为平稳的时间序列。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/bc24729e97aa5e583b9ab7dafd93c24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmXPy51vLdK_L38XOeDE2g.png"/></div></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nb"><img src="../Images/13ba8d6cf59395b799b4811f94b39c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*X-kEfIVKNmnBYQ9esWb0xw.png"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nc"><img src="../Images/3dc407a0bb24e98aedddfe24319b1857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*KAcoiAu7nqZN1Av24ZNIrA.png"/></div></figure><p id="4e60" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">进行转换意味着我们改变数据。不过别担心，我们还是可以把它重建成原来的形态。但是，这取决于您如何更改数据。由于我们使用的是导致当前数据和先前数据之间差异的diff，因此累积和(<code class="du lm ln lo lp b">cumsum</code>)将作为一种解决方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/11d65abab1ca5eb86a3fc44e58c8657c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-TlB2fRYr71fN7YUDq7CA.png"/></div></div></figure><p id="b25a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然而，进行累积求和不会将数据重新转换为其原始值。这是由于数据的第一个值为零(以前为nan，改为零)造成的。我们需要初始数据，以便它可以转换为原始值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="ae22" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在让我们检查它是否与原始数据相同</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/1b1750b8cac80ab4549a2a50787b5043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJaXqaknmbcKS_ZV5p4sWA.png"/></div></div></figure><p id="1de9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">根据图表和人工检查，两个数据帧(原始的和重建的)是相同的。既然我们知道差分一次将使我们的数据变成静态的，我们将在稍后的建模中使用差分数据。下一步，我们将把它分成一个训练验证集</p><h1 id="7f16" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">5.列车测试分离</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="1e07" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">6.自相关和偏自相关</h1><p id="0603" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">自相关是时间序列数据与其自身滞后的相关性。如果相关性很高，这意味着以前的数据将有助于预测未来。虽然部分自相关可能是相同的，但它衡量的是序列及其滞后之间的纯相关性。</p><p id="04c9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们可以使用来自<code class="du lm ln lo lp b">statsmodel</code>的acf和pacf图来帮助我们测量几个滞后上的序列之间的相关性</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/103c6e3a33a68c9791e28c3d36c89942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ym_7xvQw1t5cHeFXDOZ5ug.png"/></div></div></figure><p id="1d81" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果我们看到自相关和部分自相关值，这些值形成了ACF和PACF结果的截止模式。这表明我们可以使用自回归及其移动平均来模拟数据。请查看每个图中几乎越过或越过蓝色阈值的滞后。在PACF，几乎越过蓝色阈值的第一个滞后是5，所以我们将使用P=5。<br/>另一方面，ACF图上跨越/几乎跨越蓝色阈值的第一个滞后也是5，因此我们将使用q=5。</p><h1 id="fea2" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">7.利用ARIMA进行时间序列预测</h1><h2 id="964f" class="mj jp hi bd jq mk ml mm ju mn mo mp jy kp mq mr ka kt ms mt kc kx mu mv ke mw bi translated">7.1建模</h2><p id="6bba" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">ARIMA模型将需要(p，d，q)个自变量作为其阶数，<br/>其中:<br/> - p:模型中包含的滞后数，也称为滞后阶数。先前通过查看PACF可视化定义<br/> - d:差分顺序。在上一节中，我们知道做一个差异曾经使数据稳定。因此，我们将对原始数据使用d=1。<br/> -问:移动平均线窗口的大小，或者也叫移动平均线顺序。先前通过观察ACF可视化来定义</p><p id="4262" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们再看一遍剧情，建立模型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/0cc4024832b08ddaf40cabd4147067c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*soG3zoKEAqNh-HJp09aRjA.png"/></div></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ng"><img src="../Images/a7ccaa45dfa638ce8caaecf7417f5acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*JVjQbyzJUj5d-KdWuj5q3Q.png"/></div></figure><p id="f293" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">基于模型总结，所有变量(ar和ma)都有一个p值&lt;5%. This means that our model really fits into the train data. The AIC, BIC, and HQIC is a score to measure the goodness of our model based on the train data.</p><p id="c8ee" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">Akaike Information Criterion (AIC) tests how good your model fits the train data without over-fitting it. AIC Score rewards the model if it has a good fit, and penalizes the model if it becomes overfit. The model with a lower AIC score is supposed to have a balance between its ability to fit and avoid overfitting.</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nh"><img src="../Images/493fea95ad6dc6358c96013bb352f01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*yjBwapEuo9P5xxhJ9191mw.png"/></div></figure><p id="4396" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">where <em class="lk"> 𝑘 </em>是模型参数的个数，<em class="lk"> 𝐿 </em>是模型的似然函数的最大值。要了解更多信息，你可以访问我在Research Gate上找到的这篇论文，它可以帮助你更好地了解AIC。</p><p id="da56" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">贝叶斯信息准则(BIC)非常接近AIC。事实上，BIC的建立是为了改善AIC。主要的想法是惩罚更多的过度拟合。这是公式</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ni"><img src="../Images/e4a5fbac2472bffb8c1e61c10aab6895.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*jtmSZpWw5CFiyQ1B0HPBWg.png"/></div></figure><p id="1aa4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">其中:</p><ul class=""><li id="6a71" class="lq lr hi ki b kj lc km ld kp ls kt lt kx lu lb lv lw lx ly bi translated"><em class="lk"> 𝑛 </em>是数据或观测值的数量</li><li id="ba9d" class="lq lr hi ki b kj lz km ma kp mb kt mc kx md lb lv lw lx ly bi translated"><em class="lk"> 𝑘 </em>是模型参数的个数</li><li id="aa45" class="lq lr hi ki b kj lz km ma kp mb kt mc kx md lb lv lw lx ly bi translated"><em class="lk"> 𝐿 </em>是模型的似然函数的最大值</li></ul><p id="e411" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">汉南-奎因信息准则(HQIC)是前两个准则的替代。根据R的<a class="ae jn" href="https://www.rdocumentation.org/packages/qpcR/versions/1.3-7.1/topics/HQIC" rel="noopener ugc nofollow" target="_blank">文档</a>，对于n&gt;∞20左右，BIC在惩罚自由度损失方面最严格，在拟合模型中有更多的参数。对于n&gt;∞40，AIC是三个国家中最不严格的，而HQIC处于中间位置，或者说对于n&lt;∞20是惩罚最少的。HQIC如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nj"><img src="../Images/12da6fb14f0190149aac72c2575c0773.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*DwfW9ep6ziStFB-UT0zOZg.png"/></div></figure><p id="a5e3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">但最重要的是，那些测量是没有用的，除非我们把它和其他模型进行比较。那么现在让我们试着比较一下我们模型的几种可能性。我们将使用AIC，因为我们的数据&gt; 40。</p><h2 id="b95d" class="mj jp hi bd jq mk ml mm ju mn mo mp jy kp mq mr ka kt ms mt kc kx mu mv ke mw bi translated">7.2型号选择</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nk"><img src="../Images/4caaf79c88ca6d5ff95b23349f214cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*dYaJY_boGnDFfZYbgCaU3Q.png"/></div></figure><p id="1701" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">从上面AIC的结果，我们知道ARIMA(3 1 3)和(2 1 2)有最好的AIC站在前2名。显然，ARIMA(0 1 0)也比我们的模型ARIMA (5 1 5)要好。在计算上，p和q越低，复杂度成本就越低。让我们比较一下我们的模型的最终结果(ARIMA (5 1 5)后)与其余三个</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="e4a4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在我们有了模型，我们不希望残差有自相关。因此，让我们来看看每个剩余滞后的ACF-PACF值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/0b2f4f61f84b88d215439636ff01227b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBUXNR6G6dv2RDpIh9WL2A.png"/></div></div></figure><p id="2d3d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们还想确保残差是随机的，集中在零，</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><div class="iy iz ja jb fd ab cb"><figure class="nl jc nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/754d9a5a47055871bb5a2fdb7176c7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*105sIt3ejLvvDKLmAptEUg.png"/></div></figure><figure class="nl jc nr nn no np nq paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/d17cb0fc59a7460b4e2a1f5a6dec396f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*3GSB7ecThtY3Qpiuu_6Dqg.png"/></div></figure></div><h2 id="6808" class="mj jp hi bd jq mk ml mm ju mn mo mp jy kp mq mr ka kt ms mt kc kx mu mv ke mw bi translated">7.3模型评估</h2><p id="2a8b" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">让我们先来看看我们的模型的预测(ARIMA (5 1 5))</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ns"><img src="../Images/464e83a9f2d87a596a4c791a7a7399a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5XNunHkpxwczyqBPlwVBg.png"/></div></div></figure><p id="2d5c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然后让我们比较每个模型的预测</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nt"><img src="../Images/f6768fe82794b526bc9d99dae05a0a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHpukmO_3OkulK6J29Adxg.png"/></div></div></figure><p id="28ba" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">总的来说，所有的模型都有相似的预测，除了ARIMA (3 1 3)</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/50398e2938f707d306d1598fe3a6937f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fe8hys7DXDyJXTuZEFuv7Q.png"/></div></div></figure><p id="23bf" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果以前我们根据ACF和PACF的结果定义我们的模型，AIC却有不同的说法。让我们从另一个角度来看，RMSE</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nu"><img src="../Images/e4ac4b2d9b5e1d24e17d018df9ca7bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*AtDHuezeKxZPuTcPnyOhUg.png"/></div></figure></div><div class="ab cl nv nw gp nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hb hc hd he hf"><h1 id="238f" class="jo jp hi bd jq jr oc jt ju jv od jx jy io oe ip ka ir of is kc iu og iv ke kf bi translated">8.结论</h1><p id="2b73" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">根据结果，ARIMA (5 1 5)给出了最好的表现(对RMSE)。尽管如此，这个模型发现很难预测长期数据。这可能是因为ARIMA是敏感的，而不是用于预测的通用算法。另一方面，股票数据通常没有ARIMA模型所能观察到的季节性。</p><p id="6c64" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果我们在每个时间段都有一个清晰或隐藏的重复模式，那么做预测应该会更容易。但是从本质上讲，股票价格太复杂了，很难建模。影响价格的外部动态因素很多。</p><p id="a1c1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">对于未来的工作，我们将尝试使用更复杂的机器学习方法对其建模。</p><p id="4fe4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我的<a class="ae jn" href="http://github.com/iqbalbasyar" rel="noopener ugc nofollow" target="_blank"> github </a>上有完整的代码</p></div></div>    
</body>
</html>