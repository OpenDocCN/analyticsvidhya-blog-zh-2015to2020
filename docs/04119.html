<html>
<head>
<title>Stack ’Em up With Stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">把它们堆在一起</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stackem-up-data-structure-5cbf23a43170?source=collection_archive---------17-----------------------#2020-03-05">https://medium.com/analytics-vidhya/stackem-up-data-structure-5cbf23a43170?source=collection_archive---------17-----------------------#2020-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0dc20199ceb99031f70e68b3ce36136f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CudS7opts1yDIM2ysdVixQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安妮·斯普拉特在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1506" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最直观的计算机科学数据结构之一是堆栈。这种数据结构广泛应用于但不限于您的编译器、应用程序内存和一些函数调用中。现在你可能不熟悉这种结构，可能想知道，什么是栈？嗯，根据谷歌的解释，stack是"<em class="jt">一堆物体，通常是整齐排列的物体</em>就是这样……就是这样。栈数据结构是一堆对象，没什么特别的。在深入什么是栈数据结构之前，让我们先来看看我们在日常生活中是如何创建栈的。</p><h1 id="7b27" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">准备堆叠</h1><p id="c3e9" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">让我们放轻松，从一个简单的类比开始，老式的叠衣服。</p><p id="a1e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你坐在那里叠衣服，思考你的生活时，你不知不觉地创造了一堆整齐排列的衣服。你突然意识到你需要那件堆中间的红色衬衫。我知道你通常会把红色的衬衫拉出来，但是让我们假装一下我们是一个整洁的人，把一件衬衫脱下来，直到我们得到我们想要的那件。我知道这听起来有点疯狂，但这一切很快就会有意义。</p><p id="1593" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太好了，您正在学习更多关于堆栈的知识。请记住这个类比，因为在我们继续讨论时我会引用它。是时候更专业一点了。</p><h1 id="ac38" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">很高兴知道</h1><p id="2317" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><strong class="ix hj">抽象数据类型:</strong>数据和操作的定义但是那些操作的实现方式是隐藏的。</p><p id="b2d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">抽象例子:</strong>电脑用户可以看到它有多少内存，ram的数量，CPU的类型等规格。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="b9cb" class="lg jv hi lc b fi lh li l lj lk">Processor: 2.3 GHz 8-Core Intel Core I9<br/>Memory: 32 GB 2667 MHz DDR4<br/>Storage: 512 GB SSD</span></pre><p id="2cf8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">实现示例:</strong>用户看到一台计算机的规格标签<em class="jt">(抽象视图)</em>，但标签背后包含了使计算机发挥功能的非常复杂的实现。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="66c5" class="lg jv hi lc b fi lh li l lj lk"><strong class="lc hj">def Computer():<br/>   </strong>processor_name = “Intel”<br/>   ram_size= 32<br/>   storage_type= “SSD”<br/>   storage_amount= 512</span></pre><h1 id="80d7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是栈数据结构？</h1><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/fffbda85f60ac4b133f87f40efe87ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jhQ-b1ucAntqUELrMDBxg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">后进先出模型</figcaption></figure><p id="9d61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈是一种抽象的数据类型，充当项目的集合。这种数据结构创建了添加和删除项目的特定顺序。这种顺序被称为<strong class="ix hj">后进先出</strong>(后进先出)。最后进入堆栈的项目是第一个出来的。如果我必须选择我想让你从这篇文章中学到什么，那一定是LIFO所代表的。如果你能记住后进先出法，你就能很容易地拼凑出堆栈是如何工作的。</p><h1 id="4f84" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">指导原则</h1><p id="7428" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">回到我们的衣服类比，我提到我们必须一件接一件地脱下每件衣服才能得到我们想要的衬衫。这是因为你不能在一堆东西中挑出你想要的，然后把它拉出来。你必须从顶部开始，并删除每个项目，直到你得到你想要的。</p><h1 id="16cb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">我们为什么以及如何使用堆栈</h1><p id="aecf" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">当你想以特定的顺序(LIFO)记住前一个动作或项目时，堆栈是一个强大的工具。栈的一个很好的例子是撤销功能，许多应用程序允许你编辑照片。我们以Snapchat为例。</p><h2 id="3a6e" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">我们的快照轮廓:</h2><ul class=""><li id="53d1" class="lz ma hi ix b iy ks jc kt jg mb jk mc jo md js me mf mg mh bi translated">拍一张照片，画一个笑脸，并添加一个标题。</li></ul><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/e134e776e6220a1251286d14ab1e6751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xo7E3nFmbhEDI7Sb3BjYVQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">金门大桥照片和Snapchat堆栈模型</figcaption></figure><h2 id="d594" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">幕后:</h2><ol class=""><li id="3457" class="lz ma hi ix b iy ks jc kt jg mb jk mc jo md js mj mf mg mh bi translated">一个用户拍了一张照片，这张照片被放到一个堆栈中。</li><li id="b1ba" class="lz ma hi ix b iy mk jc ml jg mm jk mn jo mo js mj mf mg mh bi translated">用户画一个笑脸，每个笔画按照画的顺序放在栈顶。</li><li id="6266" class="lz ma hi ix b iy mk jc ml jg mm jk mn jo mo js mj mf mg mh bi translated">用户添加一个文本标题，然后标题被放在栈顶。</li></ol><p id="18a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种数据结构对这些应用程序非常有用，因为每个动作都是按照编辑的顺序添加到堆栈中的。程序员可以创建一个撤销按钮来删除最后添加的项目(LIFO)。栈是非常高效和容易创建的，但是这取决于你如何实现它。</p><h1 id="784e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">提高堆栈的效率</h1><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/d28e715d192331006460123ad8b26c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9Q3Ft9-YQ-N_1Pfwpdo_A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">阵列移位模型</figcaption></figure><p id="ca12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据您构建堆栈的方式，用数组创建堆栈可能会变得非常低效。然而，提高效率非常容易，只需要改变你观察顶部和底部的方式。</p><h2 id="9b90" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">V1的例子</h2><p id="7ed3" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">数组是连续的，这意味着每一项都相互接触。如果你在索引0处移除一个项目(顶部项目)，每个项目都必须向左移动1，这需要O(n)时间。这也适用于向堆栈中添加一个条目时，除了不是向左移动，所有的条目都必须向右移动1。</p><h2 id="0a6b" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">V2的例子</h2><p id="c795" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">您会注意到，我将Top重命名为Bottom，Bottom重命名为Top，因为这是您查看该实现所需的方式。因为数组中的最后一项的右边永远不会有项，所以当您移除它时，它不会导致任何移动。当你添加一个项目时，同样的规则也适用，因为它将移动到数组的末尾，所以不需要向右移动项目。这允许您在O(1)时间内创建一个推和弹出方法。</p><h1 id="d6e3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">堆栈是如何制作的</h1><h2 id="9ea7" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">履行</h2><p id="e2a0" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在本文中，我们的堆栈将以数组数据结构的形式出现。另一种创建堆栈的方法是使用链表。它们各有利弊，我鼓励你了解它们的不同之处。如果你想了解更多关于链表堆栈的工作原理，可以考虑阅读Vaidehi Joshi的这篇文章，他很好地解释了链表的工作原理。</p><p id="ee32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你还同意我的观点，让我们来看看组成堆栈的方法。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/00393e9346f673ec484ab1ff4e65e802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fPM-tpSzr2HGcThBIyr8g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">行动模型中的方法</figcaption></figure><h2 id="39b3" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">堆栈方法词汇表</h2><p id="f40d" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">不确定Big-O符号是什么？考虑看看Bret Cameron的这篇非常详细的文章讨论Big-O符号如何工作以及我们为什么使用它。</p><p id="ac2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">阵列实现</strong></p><p id="18ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，这是我们在本节之前讨论过的V2实现。顶部=底部，底部=顶部。</p><ul class=""><li id="2a56" class="lz ma hi ix b iy iz jc jd jg mq jk mr jo ms js me mf mg mh bi translated">Push() —将新项目添加到堆栈的顶部</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="24c0" class="lg jv hi lc b fi lh li l lj lk">Running time: O(1). The append operation executes in constant time in this implementation because no shifting occurs.</span></pre><ul class=""><li id="e379" class="lz ma hi ix b iy iz jc jd jg mq jk mr jo ms js me mf mg mh bi translated">Pop() —从堆栈中移除顶部项目</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="bb0e" class="lg jv hi lc b fi lh li l lj lk">Running time: O(1). Pop executes in constant time in this implementation because no shifting occurs.</span></pre><h2 id="4142" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">有用的方法</h2><ul class=""><li id="a088" class="lz ma hi ix b iy ks jc kt jg mb jk mc jo md js me mf mg mh bi translated">Is_Empty() —如果堆栈为空，则返回true，否则返回false</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2b9a" class="lg jv hi lc b fi lh li l lj lk">Running time: O(1). Arrays keep track of their own length, so checking if there is a length simply returns true or false which takes constant time.</span></pre><ul class=""><li id="742a" class="lz ma hi ix b iy iz jc jd jg mq jk mr jo ms js me mf mg mh bi translated">peek()-返回顶部项目，但不删除它</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="acc1" class="lg jv hi lc b fi lh li l lj lk">Running time: O(1). Returns the top item without removing it which takes constant time.</span></pre><ul class=""><li id="c5b2" class="lz ma hi ix b iy iz jc jd jg mq jk mr jo ms js me mf mg mh bi translated">length()-返回堆栈中的项目数</li></ul><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="bca8" class="lg jv hi lc b fi lh li l lj lk">Running time: O(1). Arrays keep track of their own length so there is no need to loop over each item, so this runs in constant time.</span></pre><h1 id="72af" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Python中的堆栈实现</h1><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure></div></div>    
</body>
</html>