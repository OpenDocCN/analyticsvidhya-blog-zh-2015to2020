<html>
<head>
<title>TensorFlow Batch Inference using sagemaker-spark-sdk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用sagemaker-spark-sdk的TensorFlow批量推理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tensorflow-batch-inference-using-sagemaker-spark-sdk-6ccb01f2e29c?source=collection_archive---------14-----------------------#2020-05-26">https://medium.com/analytics-vidhya/tensorflow-batch-inference-using-sagemaker-spark-sdk-6ccb01f2e29c?source=collection_archive---------14-----------------------#2020-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4d69a891a6c6a9344cf67f2bce0f01f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1c1CGbCtAgAmGsgdgAb-fg.png"/></div></div></figure><div class="iq ir ez fb is it"><a href="https://github.com/aws/sagemaker-spark" rel="noopener  ugc nofollow" target="_blank"><div class="iu ab dw"><div class="iv ab iw cl cj ix"><h2 class="bd hj fi z dy iy ea eb iz ed ef hh bi translated">aws/sagemaker-spark</h2><div class="ja l"><h3 class="bd b fi z dy iy ea eb iz ed ef dx translated">SageMaker Spark是亚马逊SageMaker的开源Spark库。使用SageMaker Spark，您可以构建Spark ML…</h3></div><div class="jb l"><p class="bd b fp z dy iy ea eb iz ed ef dx translated">github.com</p></div></div><div class="jc l"><div class="jd l je jf jg jc jh io it"/></div></div></a></div><p id="00fc" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我最近试图使用sagemaker的<a class="ae kg" href="https://github.com/aws/sagemaker-spark" rel="noopener ugc nofollow" target="_blank"> spark-sdk </a>对其进行批量推理。这样做的好处是，它允许直接在spark数据帧上执行推理，因此我们可以将推理与同一作业中的其他转换任务结合起来。</p><p id="557d" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">为了实现这一点，我们必须创建一个定制的<a class="ae kg" href="https://github.com/aws/sagemaker-spark/tree/master/sagemaker-spark-sdk/src/main/scala/com/amazonaws/services/sagemaker/sparksdk/transformation/serializers" rel="noopener ugc nofollow" target="_blank">序列化器</a>来将输入行序列化为推理容器所期望的格式，然后<a class="ae kg" href="https://github.com/aws/sagemaker-spark/tree/master/sagemaker-spark-sdk/src/main/scala/com/amazonaws/services/sagemaker/sparksdk/transformation/deserializers" rel="noopener ugc nofollow" target="_blank">反序列化</a>从预测中得到的响应。</p><p id="8fd6" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我很惊讶，因为我找不到任何简单的解决方案或指南来说明如何为非常简单的推理工作编写这个定制的序列化器和反序列化器(从这里开始的SerDe)。此外，sagemaker不提供开箱即用。</p><p id="f9be" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这篇博客将试图介绍sagemaker-spark-sdk的实现和我所了解的东西。</p><p id="de4d" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">对于我的实现，我试图从预先训练的tensorflow模型中创建一个<a class="ae kg" href="https://aws.github.io/sagemaker-spark/index.html#com.amazonaws.services.sagemaker.sparksdk.SageMakerModel$" rel="noopener ugc nofollow" target="_blank"> SageMakerModel </a>。我决定使用sagemaker 提供的<a class="ae kg" href="https://github.com/aws/sagemaker-tensorflow-serving-container" rel="noopener ugc nofollow" target="_blank">推理容器。</a></p><p id="597c" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">提供推理的数据框是一个简单的二维数字数据框，其中每一行对应一个特征向量。</p><p id="301f" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">创建SageMakerModel</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="bd09" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在的问题是，如何为数据帧编写SerDe。</p><p id="d2ea" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">从SerDe的特点中，我们可以看到几个有用的方面:</p><p id="0f3c" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae kg" href="https://github.com/aws/sagemaker-spark/blob/master/sagemaker-spark-sdk/src/main/scala/com/amazonaws/services/sagemaker/sparksdk/transformation/RequestRowSerializer.scala" rel="noopener ugc nofollow" target="_blank"> RequestRowSerializer </a>:在实现时要注意的主要部分是定义<strong class="jk hj"> contentType </strong>(服务容器在执行推理时期望的格式)和<strong class="jk hj"> serializeRow() </strong>(它接受每一行并将其转换为以字节为单位的contentType的单个实体)。</p><p id="1a51" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae kg" href="https://github.com/aws/sagemaker-spark/blob/master/sagemaker-spark-sdk/src/main/scala/com/amazonaws/services/sagemaker/sparksdk/transformation/ResponseRowDeserializer.scala" rel="noopener ugc nofollow" target="_blank"> ResponseRowDeserializer </a>:这里要实现的主要部分是<strong class="jk hj">模式</strong>(放入数据帧时推理的预期输出格式)；<strong class="jk hj">接受</strong>(服务容器应该返回得分值的内容类型)和<strong class="jk hj">反序列化响应()</strong>(将得分值转换为Row对象上的迭代器的方法，其中每行包含单个特征向量的输出得分)</p><p id="402c" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">contentType和accepts的限制是从serving container应用的，它可以通过编写我们自己的推理容器来扩展(可能在另一篇文章中)。</p><p id="b6e5" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这里需要注意的是，sagemaker-spark-sdk会自动创建一个RequestBatchIterator，并使用序列化程序在一次操作中序列化多个请求。查看请求批处理迭代器，我们可以看到它使用serialize创建了单个<a class="ae kg" href="https://github.com/aws/sagemaker-spark/blob/master/sagemaker-spark-sdk/src/main/scala/com/amazonaws/services/sagemaker/sparksdk/transformation/util/RequestBatchIterator.scala#L107-L125" rel="noopener ugc nofollow" target="_blank">请求体</a>，在反序列化时，<a class="ae kg" href="https://github.com/aws/sagemaker-spark/blob/master/sagemaker-spark-sdk/src/main/scala/com/amazonaws/services/sagemaker/sparksdk/transformation/util/RequestBatchIterator.scala#L135-L158" rel="noopener ugc nofollow" target="_blank">它尝试获取row对象的迭代器，其中每一行都是给定输入特性</a>的预测值</p><p id="6af8" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">考虑到这些因素，我们可以如下实现SerDe:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><ol class=""><li id="2316" class="kn ko hi jk b jl jm jp jq jt kp jx kq kb kr kf ks kt ku kv bi translated">Serialize:我们正在创建一个长度为(# input features)的特征向量，并将第一个“input feature”值以双精度形式放入该向量。然后我们将它转换成CSV字符串。这里需要注意的重要一点是，在结尾有一个“\n”。鉴于请求将被批处理，这是必需的。然后我们把它转换成字节数组。内容类型设置为CSV，因为tensorflow服务容器接受该格式。</li><li id="e907" class="kn ko hi jk b jl kw jp kx jt ky jx kz kb la kf ks kt ku kv bi translated">反序列化:唯一的响应格式是json和jsonlines。对于这个例子，我们使用json。给定输入格式，响应将类似于<code class="du lb lc ld le b">{ "predictions": [[1],[2],[3]...] }</code>,因此我们迭代外部序列，并将内部序列转换为一行(DoubleType ),这是我们的<strong class="jk hj">模式所期望的。</strong>最后将序列转换成可迭代的。</li></ol><p id="753b" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这就完成了实现，我们的模型对象将看起来像这样:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="2041" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">要对输入数据帧进行评分，我们只需:</p><pre class="kh ki kj kk fd lf le lg lh aw li bi"><span id="a3b4" class="lj lk hi le b fi ll lm l ln lo">val scoredDF: DataFrame = model.transform(inputDF)</span></pre><p id="ee45" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一旦我们完成了评分，我们就可以销毁创建的资源:</p><pre class="kh ki kj kk fd lf le lg lh aw li bi"><span id="9768" class="lj lk hi le b fi ll lm l ln lo">val sagemakerClient = AmazonSageMakerClientBuilder.defaultClient<br/>val cleanup = new SageMakerResourceCleanup(sagemakerClient)<br/>cleanup.deleteResources(model.getCreatedResources)</span></pre><p id="f0bb" class="pw-post-body-paragraph ji jj hi jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这就完成了使用tensorflow的自定义SerDe的模型评分。</p></div></div>    
</body>
</html>