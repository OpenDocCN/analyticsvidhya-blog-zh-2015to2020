<html>
<head>
<title>Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的装饰者</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/decorators-in-python-33af58b3be32?source=collection_archive---------21-----------------------#2020-10-18">https://medium.com/analytics-vidhya/decorators-in-python-33af58b3be32?source=collection_archive---------21-----------------------#2020-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="574f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正在学习 python 或者你已经完成了 python 的基础，你一定在考虑学习“装饰”。大多数 python 程序员觉得这很难理解，对我来说这也是一个很难理解的概念。</p><p id="12dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在理解 decorator 的概念之前，让我们先了解一下 python 中 decorator 的威力。</p><ul class=""><li id="5afc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Decorators 允许我们根据自己的需要修改函数，而不用永久地修改它。</li><li id="155e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">更简单地说，decorators 允许我们在调用函数之前和之后进行修改。</li></ul><blockquote class="jr js jt"><p id="f28e" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">为了学习装饰，你必须理解以下两个概念。</p></blockquote><h2 id="dd5d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">1.函数是对象，它们可以赋给变量，传递给其他函数，也可以从其他函数返回。</h2><h2 id="8191" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">2.函数可以在其他函数中定义，子函数可以捕获父函数的本地状态(词法闭包)。</h2><p id="53cd" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">现在我们来了解一下装修工。</p><p id="aa0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，decorators 将 callable 作为一个参数，做一些修改并返回另一个 callable。</p><p id="f507" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Callable 是实现特殊方法 __call__()的任何对象</p><blockquote class="ky"><p id="3552" class="kz la hi bd lb lc ld le lf lg lh jc dx translated">具有双下划线的方法，如 __call__()也称为 dunders。</p></blockquote><p id="2ab3" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">让我们实现装饰器。</p><p id="effb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，函数 mul 是一个普通的函数，它返回两个数的乘积。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/c63da34a445a1a57c5fb81be54472e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzJDcVBK3ais3mCEAj26_w.jpeg"/></div></div></figure><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lz"><img src="../Images/9f412aa85df255e747cea8f303f30806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdKrWvuYHbJRATSmXX7MwA.jpeg"/></div></div></figure><p id="59a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在装饰者的帮助下做一些改变。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ma"><img src="../Images/611c6aed24e1391e3ff40cc634c8d11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvaeUnNi5eIpTm99fNByUA.jpeg"/></div></div></figure><p id="8c53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，函数“装饰”是一个装饰器。它接受 func 函数作为参数。</p><p id="d495" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个装饰者都应该有包装功能。我们可以给包装函数取任何名字。在上面的例子中,‘wrapper’是包装函数。</p><p id="3de9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在包装函数内部，我们做所有的修改。正如你在上面的例子中看到的，我们在调用函数之前和之后只添加了两个 print()语句。</p><p id="3df3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除非我们调用包装函数，否则我们所做的任何更改都不会实现。为了调用包装函数，我们使用 return 语句。</p><p id="e43c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们装饰人员可以使用了。</p><p id="56d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要对函数应用 decorator，我们必须使用@ decorator_name。您可以在上面程序的第 9 行看到这一点。</p><p id="7281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">@符号只是一个句法糖。实际上，我们如下调用 decorator:</p><blockquote class="jr js jt"><p id="98c9" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">装饰(mul(a，b))</p></blockquote><p id="3a8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看输出:</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mb"><img src="../Images/e5b75aaad9174d10428502f34dcad35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5AXHw8mQ9WFdHXlRWTH4XA.jpeg"/></div></div></figure><p id="8bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">敏锐的观察者一定注意到了装饰器中包装函数的参数和它所装饰的函数的参数是一样的。</p><p id="ce70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了克服这个限制并使装饰器更通用，可以处理任意数量参数，我们可以使用，</p><blockquote class="jr js jt"><p id="7831" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">函数(*args，**kwargs)</p></blockquote><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mc"><img src="../Images/d5da881401db8da82d6816d27e4e1cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biFcFadh-r7YTjjBSWa3Ag.jpeg"/></div></div></figure><p id="88a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关键要点:</p><blockquote class="jr js jt"><p id="3125" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">1.装饰者接受 function 作为参数，并返回另一个函数。</p><p id="31a6" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">2.Decorator 必须有包装函数，并且应该返回它。</p><p id="a7db" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">3.修改应该在包装函数内部完成。</p><p id="db8d" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">4.要将 decorator 应用于函数，请在定义函数之前使用@ with decorator name。</p></blockquote><p id="650b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐的蟒蛇。</p></div></div>    
</body>
</html>