<html>
<head>
<title>Machine Learning Algorithms: Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习算法:逻辑回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-algorithms-logistics-regression-8ba38af531b3?source=collection_archive---------24-----------------------#2020-12-28">https://medium.com/analytics-vidhya/machine-learning-algorithms-logistics-regression-8ba38af531b3?source=collection_archive---------24-----------------------#2020-12-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="78a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Tom Mitchell的一个最著名的定义将机器学习表述为“当性能P随着任务T超过经验E而提高时，性能P的计算机程序据说从一组任务T和经验E中学习”。构建和训练可以学习手头问题的算法，基本上就是机器学习的全部思路。它们分为回归和分类问题。当输出在连续范围内时，例如汽车价格、降雨量等。那么就是一个回归问题。然而，当输出是分类的，比如说，它是一个欺诈交易或不是，那么它被称为分类问题。在这一系列文章中，我将直观地介绍广泛用于解决问题的不同类型的算法。我们将在本文中讨论最常用的分类算法之一逻辑回归。开始分类吧！☺</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/cbcc36f8b06544ab2378d01d73246cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xnT2nYiI-YUzGHEP"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">威尔·弗朗西斯在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="777f" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">逻辑回归</h1><p id="d6a0" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">线性回归算法是做什么的？它试图得到一个本质上是数字的输出，以便与实际值相比，损失或剩余尽可能低。逻辑回归几乎是根据这个原理工作的。但是我们希望输出介于0和1之间，而不是任何数值。为了解决这个问题，让我们改变假设的形式，以满足条件0≤ <em class="kw"> hθ </em> ( <em class="kw"> x </em> )≤1。Sigmoid函数是一种帮助将线性函数转换为0到1之间的值的函数。因为该值在0和1之间，所以它可以与和特定类别相关联的概率值相关。让我们考虑一个有n个变量x1到xn的线性函数。设θ是与线性函数中的变量相关的系数或权重。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kx"><img src="../Images/ac37a1bad1c6b33c93338263f8ba3f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*dNZce4gGblG-e8iygfMECQ.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ky"><img src="../Images/471d3b837f9ddb43685fbff362d2f358.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*plM1k9mquw9qR_tv5JRVkw.png"/></div></figure><p id="00e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图解释了s形曲线的样子。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kz"><img src="../Images/b9181318a5b2b8db0d2879c0be64f25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*-IZo8prDHcWILY-WKSmR6Q.png"/></div></figure><p id="6b28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">梯度下降算法是线性回归中最常用的方法，用于获得与独立变量相关的最佳权重。梯度下降根据实际值计算与预测值相关的损失。该算法以相关损失尽可能低的方式操作系数。从图形上看，梯度下降算法以尽可能接近全局最小值的方式工作。但是当涉及到物流回归时，这种方法是一个死胡同。损失的非线性使得梯度下降法不方便。它们形成了如下左图所示的非凸函数。因此，为了以凸形式获得我们的损失，我们使用对数损失函数来获得合适的系数以减少损失。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es la"><img src="../Images/8bfa799b350987b83a31472977bbca86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqXZxh-pZRRzoEi5m_qjqg.png"/></div></div></figure><p id="72c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">逻辑回归的对数损失函数分为两部分。一个用于标签y=0，另一个用于标签y=1。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lb"><img src="../Images/44e74ae01f316fc27bdc5f0d7c08de59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*6BHfRjgSi3Eg1IXk4CY8fA.png"/></div></figure><p id="c630" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么为什么要使用对数函数呢？从下面的图表中可以清楚地看到，错误的分配所带来的惩罚是非常巨大的。当预测值接近0而不是1时，对数损失的值接近无穷大。类似地，当预测值接近1而不是0时产生的惩罚也是巨大的。因此，对数损失函数显然满足目的，并且因此对于分类算法来说工作良好。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lc"><img src="../Images/950a90a9914ab1fc0f38b01c40ac70fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdS2QkmOYs4sZoZSA3fd3A.png"/></div></div></figure><p id="4c8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当y等于0和1时，上述两个对数损失函数可以组合在一起形成单个对数损失函数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ld"><img src="../Images/41303c0b7340d2cf657438c3559c7018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXknEsYw6lqvftg4OJKa0Q.png"/></div></div></figure><p id="0ab5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">赞成的意见</p><ol class=""><li id="cd5e" class="le lf hh ig b ih ii il im ip lg it lh ix li jb lj lk ll lm bi translated">物流回归算法简单，易于解释。</li><li id="afea" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated">它们可以很容易地扩展到多个类的问题。</li></ol><p id="2ef0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">骗局</p><p id="144b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.当数据不能线性分离时，逻辑回归表现不佳。因此，决策界限将很难构建。</p><p id="f699" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望你读得不错。请鼓掌以示支持，并关注我以获取更多文章☺</p></div></div>    
</body>
</html>