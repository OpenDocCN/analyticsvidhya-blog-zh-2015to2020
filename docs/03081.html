<html>
<head>
<title>Understanding concurrency in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python中的并发性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-concurrency-in-python-d7ada0516d01?source=collection_archive---------7-----------------------#2020-01-15">https://medium.com/analytics-vidhya/understanding-concurrency-in-python-d7ada0516d01?source=collection_archive---------7-----------------------#2020-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/954ee6df7325a3dde37b7b31b4aeba54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pAtCgW9N4D-CVT-A"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">"每个学习并发的人都认为他们理解并发！"—赫伯·萨特</figcaption></figure><div class=""/><p id="449a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们都或多或少地理解并发和并行的概念。同时执行多个进程或线程的技术/机制，同时最大限度地利用CPU。不管是什么，但是并发作为一个概念是非常棘手的！</p><blockquote class="jt ju jv"><p id="41f2" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">并发性是指通过上下文切换在一个处理器上执行多个进程，并且这些进程似乎是同时运行的。</p><p id="8428" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">并行性是指进程在多个处理器或内核上执行，并且实际上是同时运行的。</p></blockquote></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="c45f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python提供了多个库来实现并发，即— <strong class="ix hz"> <em class="jw">线程</em> </strong>、<strong class="ix hz"> <em class="jw">多处理</em> </strong>和<strong class="ix hz"> <em class="jw"> asyncio </em> </strong>。如果我们了解Python中并发性的几个方面，这些库将被更好地利用。</p><p id="bfe7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">* CPython强制执行<a class="ae kh" href="https://en.wikipedia.org/wiki/Global_interpreter_lock" rel="noopener ugc nofollow" target="_blank"> GIL(全局解释器锁</a>),它规定一次只能执行一个线程，每次执行任何字节码之前，线程都需要获取这个独占锁。</p><p id="64fe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*当进程受限于I/O或CPU时，首选并发。<em class="jw"> I/O绑定进程是那些与比处理器</em>慢的设备进行通信的进程。例如，与不良网络连接、打印机/扫描仪等对话的进程。是一个I/O绑定的进程。<em class="jw"> CPU受限进程是指那些进行大量CPU密集型计算的进程</em>。这里，限制执行速度的资源是CPU，而不是I/O绑定的进程。</p><p id="cb38" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*在I/O受限或CPU受限的进程中，线程无需争用/争夺GIL。</p><p id="fc09" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*当进程受限于I/O时，<em class="jw">线程</em>和<em class="jw"> asyncio </em>库将很好用，当进程受限于CPU时，<em class="jw">多处理</em>库将很好用。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="2719" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们详细了解如何使用这些库——</p><ol class=""><li id="ff0d" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kn ko kp kq bi translated"><strong class="ix hz"> <em class="jw">穿线</em> </strong></li></ol><p id="f089" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，“线程”库最适合处理I/O绑定函数。 </p><p id="5990" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，让我们考虑一个I/O绑定函数，用于从几个网站获取响应。让我们以常规和多线程的方式执行这个任务，并捕获从所有站点获取响应所用的时间，以证明在多线程执行的情况下速度更快，而在常规执行的情况下速度更慢。</p><ul class=""><li id="5685" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">我们首先导入必要的库和模块</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ff77" class="lb lc hy kx b fi ld le l lf lg">import threading<br/>import time<br/>import requests</span></pre><ul class=""><li id="1c21" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">然后我们定义一个函数<code class="du lh li lj kx b"><em class="jw">get_response()</em></code> <em class="jw"> </em>，它接受<code class="du lh li lj kx b"><em class="jw">site</em> </code>作为输入，并使用<code class="du lh li lj kx b"><em class="jw">requests.get()</em></code> <em class="jw"> </em>方法从那个<code class="du lh li lj kx b"><em class="jw">site</em> </code>中获取响应数据。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="dfd5" class="lb lc hy kx b fi ld le l lf lg">def get_response(site):<br/>    return requests.get(site)</span></pre><ul class=""><li id="c9a1" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">然后创建几个网站的列表。将任意站点和任意数量的站点添加到列表中。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3fdf" class="lb lc hy kx b fi ld le l lf lg">sites = ["<a class="ae kh" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">http://www.google.com</a>", "<a class="ae kh" href="http://www.linkedin.com" rel="noopener ugc nofollow" target="_blank">http://www.linkedin.com</a>", "<a class="ae kh" href="http://www.quora.com" rel="noopener ugc nofollow" target="_blank">http://www.quora.com</a>", "<a class="ae kh" href="http://www.facebook.com" rel="noopener ugc nofollow" target="_blank">http://www.facebook.com</a>"]</span></pre><ul class=""><li id="b278" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">遍历这个站点列表，并为每个站点调用<code class="du lh li lj kx b"><em class="jw">get_response() </em></code>方法。使用<code class="du lh li lj kx b"><em class="jw">time.time()</em></code> <em class="jw"> </em>方法捕获并打印这个完整迭代所用的时间。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="14a9" class="lb lc hy kx b fi ld le l lf lg">start_time = time.time()<br/>for site in sites:<br/>    get_response(site)<br/>print("Time taken for regular execution", time.time()-start_time)</span></pre><ul class=""><li id="7101" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">现在，使用<code class="du lh li lj kx b"><em class="jw">threading </em></code> <em class="jw">库</em>定义<code class="du lh li lj kx b">threads </code>，目标为<code class="du lh li lj kx b"><em class="jw">get_response()</em></code> <em class="jw"> </em>函数，参数设置为列表中的<code class="du lh li lj kx b">sites </code>。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e4aa" class="lb lc hy kx b fi ld le l lf lg">threads = [threading.Thread(target=get_response, args=(site,)) for site in sites]</span></pre><ul class=""><li id="d5db" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">迭代这些线程，使用<code class="du lh li lj kx b"><em class="jw">thread.start() </em></code>方法启动这些线程，使用<code class="du lh li lj kx b"><em class="jw">thread.join()</em></code> <em class="jw"> </em>方法等待线程执行完成。同样，使用<code class="du lh li lj kx b"><em class="jw">time.time()</em></code> <em class="jw"> </em>方法捕获时间，以查看完成执行所用的时间。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c24e" class="lb lc hy kx b fi ld le l lf lg">start_time = time.time()<br/>for thread in threads:<br/>    thread.start()<br/>for thread in threads:<br/>    thread.join()<br/>print("Time taken for multi-threaded execution", time.time()-start_time)</span></pre><p id="3eeb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以多线程方式打印出执行所花费的时间。从我的执行中，我得到了以下结果—</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/176ac02f7f4e3a4657ea4f73b26521ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKS2HALmfxqHwVbIMigSjQ.png"/></div></div></figure><p id="d339" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看出，这个I/O绑定任务的多线程执行比常规执行要快得多。在只有四个站点可以获取响应的场景中，多线程执行的效率非常重要。想象一下，当网站列表变得更长时，我们将会看到多大的优势！你是不是刚刚想到要做一个令人兴奋的网页抓取项目？</p><p id="34ff" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">合并后的代码如下所示—</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3e7b" class="lb lc hy kx b fi ld le l lf lg">import threading<br/>import time<br/>import requests</span><span id="f591" class="lb lc hy kx b fi ll le l lf lg">def get_response(site):<br/>    requests.get(site)</span><span id="dcde" class="lb lc hy kx b fi ll le l lf lg">sites = ["<a class="ae kh" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">http://www.google.com</a>", "<a class="ae kh" href="http://www.linkedin.com" rel="noopener ugc nofollow" target="_blank">http://www.linkedin.com</a>", \<br/>         "<a class="ae kh" href="http://www.quora.com" rel="noopener ugc nofollow" target="_blank">http://www.quora.com</a>", "<a class="ae kh" href="http://www.facebook.com" rel="noopener ugc nofollow" target="_blank">http://www.facebook.com</a>"]</span><span id="a666" class="lb lc hy kx b fi ll le l lf lg">start_time = time.time()<br/>for site in sites:<br/>    get_response(site)<br/>print("Time taken for regular execution", time.time()-start_time)</span><span id="9fe0" class="lb lc hy kx b fi ll le l lf lg">threads = [threading.Thread(target=get_response, args=(site,)) for site in sites]<br/><em class="jw"> </em><br/>start_time = time.time()<br/>for thread in threads:<br/>    thread.start()<br/>for thread in threads:<br/>    thread.join()<br/>print("Time taken for multi-threaded execution", time.time()-start_time)</span></pre><p id="e570" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们实际考虑一个CPU绑定函数，看看<code class="du lh li lj kx b">threading </code>库没有多大帮助。</p><ul class=""><li id="e443" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">同样，首先导入必要的库和模块</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e09b" class="lb lc hy kx b fi ld le l lf lg">import threading<br/>import time<br/>import requests</span></pre><ul class=""><li id="01a3" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">这一次，定义一个CPU密集型函数<code class="du lh li lj kx b"><em class="jw">cpu_bound()</em></code> <em class="jw"> </em>，该函数接受一个<code class="du lh li lj kx b">number</code>，将其乘以10⁶，并计算0到该乘积范围内所有数字的总和。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a0fe" class="lb lc hy kx b fi ld le l lf lg">def cpu_bound(num):<br/>    return sum([i for i in range(num*1000000)])</span></pre><ul class=""><li id="e632" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">随机创建一些数字的列表</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cb3f" class="lb lc hy kx b fi ld le l lf lg">numbers = [11,23,53,34]</span></pre><ul class=""><li id="0856" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">就像上一个例子一样，迭代这些数字并调用cpu密集型函数<code class="du lh li lj kx b"><em class="jw">cpu_bound()</em></code> <em class="jw">。</em>捕捉完成执行所用的时间。打印出常规执行所花费的时间。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a237" class="lb lc hy kx b fi ld le l lf lg">start_time = time.time()<br/>for number in numbers:<br/>    cpu_bound(number)<br/>print("Time taken for regular execution", time.time()-start_time)</span></pre><ul class=""><li id="55de" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">同样，如前所示，使用<code class="du lh li lj kx b"><em class="jw">threading.Thread()</em></code> <em class="jw"> </em>方法定义<code class="du lh li lj kx b">threads </code>，目标函数设置为<code class="du lh li lj kx b"><em class="jw">cpu_bound</em></code> <em class="jw"> </em>，参数设置为列表中的<code class="du lh li lj kx b">numbers </code></li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="216a" class="lb lc hy kx b fi ld le l lf lg">threads = [threading.Thread(target=cpu_bound, args=(number,)) for number in numbers]</span></pre><ul class=""><li id="0542" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">迭代这些线程，使用<code class="du lh li lj kx b"><em class="jw">thread.start()</em></code> <em class="jw"> </em>方法启动这些线程，使用<code class="du lh li lj kx b"><em class="jw">thread.join()</em></code> <em class="jw"> </em>方法等待线程执行完成。同样，使用<code class="du lh li lj kx b"><em class="jw">time.time()</em></code> <em class="jw"> </em>方法捕获时间，查看完成执行所用的时间，并将其打印出来。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a9db" class="lb lc hy kx b fi ld le l lf lg">start_time = time.time()<br/>for thread in threads:<br/>    thread.start()<br/>for thread in threads:<br/>    thread.join()<br/>print("Time taken for multi-threaded execution", time.time()-start_time)</span></pre><p id="52d4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是我的结果-</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/bfa0c57fceb26b54eaf5a4461d02853c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WucYUXog28mI96OirKfZg.png"/></div></div></figure><p id="398b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看出，使用线程模块并没有帮助我们在执行CPU绑定函数时提高速度，因为逐行执行可能比等待一个线程完成和另一个线程获得GIL并继续执行更快。</p><p id="5be3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">合并后的代码会像这样—</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0fd1" class="lb lc hy kx b fi ld le l lf lg">def cpu_bound(num):<br/>    return sum([i for i in range(num*1000000)])<br/>numbers = [11,23,53,34]</span><span id="c175" class="lb lc hy kx b fi ll le l lf lg">start_time = time.time()<br/>for number in numbers:<br/>    cpu_bound(number)<br/>print("Time taken for regular execution", time.time()-start_time)</span><span id="5bed" class="lb lc hy kx b fi ll le l lf lg">threads = [threading.Thread(target=cpu_bound, args=(number,)) for number in numbers]</span><span id="7d4e" class="lb lc hy kx b fi ll le l lf lg">start_time = time.time()<br/>for thread in threads:<br/>    thread.start()<br/>for thread in threads:<br/>    thread.join()<br/>print("Time taken for multi-threaded execution", time.time()-start_time)</span></pre><p id="61e4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在处理CPU绑定函数时，我们通常会看到多线程执行比常规执行花费更多或几乎相当的时间。</p><p id="81c4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对这两个例子的理解是— <em class="jw">不管你的计算机上有多少个内核；</em> <strong class="ix hz"> <em class="jw">线程</em></strong><em class="jw">Python的库不会帮助你完全利用多线程的能力。因此，任何CPU密集型功能都不会从多线程执行中受益</em>。</p><p id="cd0f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们是否有任何拯救方法，可以完全利用我们计算机拥有的所有内核，并有效处理特别是CPU绑定的功能？</p><p id="fe9b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是啊！感谢<strong class="ix hz">的库<em class="jw">多处理。</em> </strong>现在，让我们试着多了解一下。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="be0c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<strong class="ix hz"> <em class="jw">多重处理</em> </strong> —</p><p id="e45d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">多重处理</strong>允许你在不同的内核上运行独立的Python进程，尽管这些进程是独立的，但它们仍然可以相互通信(如果需要的话)。让我们看一个例子，多重处理帮助我们实现更快的速度来处理CPU受限的功能。</p><ul class=""><li id="ae59" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">导入必要的库和模块</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="55e7" class="lb lc hy kx b fi ld le l lf lg">import multiprocessing<br/>import time</span></pre><ul class=""><li id="d227" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">定义一个CPU密集型函数(使用上一个例子中的相同函数)<code class="du lh li lj kx b"><em class="jw">cpu_bound()</em></code>,该函数接受一个数，将其乘以10⁶，并计算从0到该乘积范围内所有数的和。还创建了一个随机数列表。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3990" class="lb lc hy kx b fi ld le l lf lg">def cpu_bound(num):<br/>    return sum([i for i in range(num*1000000)])</span><span id="7328" class="lb lc hy kx b fi ll le l lf lg">numbers = [11,23,53,34]</span></pre><ul class=""><li id="cdb8" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">我们已经知道了这个函数在数字列表上迭代的常规执行所花费的时间。现在，让我们使用多处理库来调用多个进程来处理这个CPU密集型函数，并捕获执行所用的时间。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="965d" class="lb lc hy kx b fi ld le l lf lg">start_time = time.time()<br/>for number in numbers:<br/>    p = multiprocessing.Process(target=cpu_bound, args=(number,))<br/>    p.start()<br/>print("Time taken for multi-threaded execution", time.time()-start_time)</span></pre><p id="19a8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我重新执行常规的多重处理代码时，下面是我的结果</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ln"><img src="../Images/ab184bd21a32318c229674478fc92932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bRaonQ-0YfvIaD-LPsh0A.png"/></div></div></figure><p id="1055" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太棒了。您可以看到，将列表中的数字作为独立的进程执行相同的<code class="du lh li lj kx b"><em class="jw">cpu_bound()</em></code> <em class="jw"> </em>功能所用的时间大幅减少。</p><p id="eab6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">合并后的代码看起来会像这样—</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2509" class="lb lc hy kx b fi ld le l lf lg">import multiprocessing<br/>import time</span><span id="6e33" class="lb lc hy kx b fi ll le l lf lg">def cpu_bound(num):<br/>    return sum([i for i in range(num*1000000)])</span><span id="4232" class="lb lc hy kx b fi ll le l lf lg">numbers = [11,23,53,34]</span><span id="f187" class="lb lc hy kx b fi ll le l lf lg">start_time = time.time()<br/>for number in numbers:<br/>    cpu_bound(number)<br/>print("Time taken for regular execution", time.time()-start_time)</span><span id="a457" class="lb lc hy kx b fi ll le l lf lg">start_time = time.time()<br/>for number in numbers:<br/>    p = multiprocessing.Process(target=cpu_bound, args=(number,))<br/>    p.start()<br/>    p.join()<br/>    <br/>print("Time taken for multi-processing execution", time.time()-start_time)</span></pre><p id="5486" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您在windows上工作，那么您可以在运行上述Python代码的同时打开任务管理器，查看为您的目的而生成的Python进程的数量</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lo"><img src="../Images/c67c48713f596ac05b794c9e1f303dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUUIpJbFw3JyR0bUaXE08A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">正在生成多个Python进程-任务管理器</figcaption></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="6659" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.<strong class="ix hz"> <em class="jw"> Asyncio — </em> </strong></p><p id="5f0c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你看，在线程和多处理库中，库不能控制上下文切换。这就是为什么程序员必须使用锁定和等待机制来处理同步问题。如果有一个库可以让应用程序控制上下文切换，并以协作的方式执行多种功能，会怎么样？这就是<strong class="ix hz"> <em class="jw"> asyncio </em> </strong>进入画面的地方。</p><p id="5079" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="jw"> asyncio </em> </strong>在3.4版本中与Python相关联，它是一个单线程-单进程协作多任务库，利用所谓的协同例程、事件循环和可实现的对象来实现并发。</p><p id="1e48" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">asyncio任务独占使用CPU，直到它希望将CPU让给事件循环。同样，asyncio在I/O受限操作的情况下非常有用，而在CPU受限操作的情况下没有太大优势。</p><p id="3337" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们考虑同一个旧的I/O绑定示例，从站点获取响应，并看看如何使用asyncio实现它</p><ul class=""><li id="a5c4" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">导入必要的库和模块</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7730" class="lb lc hy kx b fi ld le l lf lg">import asyncio<br/>import requests<br/>import time</span></pre><ul class=""><li id="1005" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">定义协同例程。协同例程可以通过在函数定义前添加关键字<code class="du lh li lj kx b">async</code>来定义。<em class="jw">asyncio协同程序是一个在执行过程中可以暂停和恢复的功能</em>。或多或少像一个产生结果而不是回报的发生器。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5a1a" class="lb lc hy kx b fi ld le l lf lg">async def get_response(site):<br/>    return requests.get(site)</span><span id="e92e" class="lb lc hy kx b fi ll le l lf lg">async def main():<br/>    # define some sites to query <br/>    tasks = []<br/>    sites = ["<a class="ae kh" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">http://www.google.com</a>", \<br/>             "<a class="ae kh" href="http://www.linkedin.com" rel="noopener ugc nofollow" target="_blank">http://www.linkedin.com</a>", \<br/>             "<a class="ae kh" href="http://www.quora.com" rel="noopener ugc nofollow" target="_blank">http://www.quora.com</a>", \<br/>             "<a class="ae kh" href="http://www.facebook.com" rel="noopener ugc nofollow" target="_blank">http://www.facebook.com</a>"]<br/>    for site in sites:<br/>        tasks.append(asyncio.ensure_future(get_response(site)))<br/>    <br/>    await asyncio.gather(*tasks)</span></pre><ul class=""><li id="72c7" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">接受一个协同例程并返回它的未来版本。基本上，它相信最终会在某个时间点给出一个结果。当一个协同例程正在等待时，它的执行被暂时挂起。一旦该协同例程的未来被设置为某个结果，则该协同例程被恢复。</li><li id="0760" class="ki kj hy ix b iy lp jc lq jg lr jk ls jo lt js kr ko kp kq bi translated">现在，让我们创建事件循环并调用协同例程来获取响应和捕获时间，以查看和比较asyncio的执行情况。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0062" class="lb lc hy kx b fi ld le l lf lg">start_time = time.time()<br/>loop = asyncio.get_event_loop()<br/>loop.run_until_complete(main())<br/>loop.close()<br/>print("Time taken for asyncio", time.time()-start_time)</span></pre><p id="fe09" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我得到了以下结果-</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/1d25a1e075fd13170683382ebb8d6816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-38mZwZi-Y3j7VVHATwbQ.png"/></div></div></figure><p id="1e04" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看出，与I/O绑定操作的常规迭代执行相比，asyncio执行花费的时间相对较少。</p><p id="9b41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">合并后的代码看起来会像这样—</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4825" class="lb lc hy kx b fi ld le l lf lg">import asyncio<br/>import requests<br/>import time</span><span id="1241" class="lb lc hy kx b fi ll le l lf lg">async def get_response(site):<br/>    return requests.get(site)</span><span id="4fff" class="lb lc hy kx b fi ll le l lf lg">async def main():<br/>    # define some sites to query <br/>    tasks = []<br/>    sites = ["<a class="ae kh" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">http://www.google.com</a>", \<br/>             "<a class="ae kh" href="http://www.linkedin.com" rel="noopener ugc nofollow" target="_blank">http://www.linkedin.com</a>", \<br/>             "<a class="ae kh" href="http://www.quora.com" rel="noopener ugc nofollow" target="_blank">http://www.quora.com</a>", \<br/>             "<a class="ae kh" href="http://www.facebook.com" rel="noopener ugc nofollow" target="_blank">http://www.facebook.com</a>"]<br/>    for site in sites:<br/>        tasks.append(asyncio.ensure_future(get_response(site)))<br/>    <br/>    await asyncio.gather(*tasks)</span><span id="bee7" class="lb lc hy kx b fi ll le l lf lg">start_time = time.time()<br/>loop = asyncio.get_event_loop()<br/>loop.run_until_complete(main())<br/>loop.close()<br/>print("Time taken for asyncio", time.time()-start_time)</span></pre><p id="54b7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="jw">结论</em></strong>——</p><p id="566e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您已经对Python中的并发库有了基本的了解——</p><ul class=""><li id="9c3a" class="ki kj hy ix b iy iz jc jd jg kk jk kl jo km js kr ko kp kq bi translated">穿线</li><li id="6b64" class="ki kj hy ix b iy lp jc lq jg lr jk ls jo lt js kr ko kp kq bi translated">多重处理</li><li id="c54f" class="ki kj hy ix b iy lp jc lq jg lr jk ls jo lt js kr ko kp kq bi translated">阿辛西奥</li></ul><p id="b661" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还学会了根据操作是受I/O限制还是受CPU限制来决定使用哪个库。总之，您现在已经对并发的基础有了更好的理解。还有更多的吗？<strong class="ix hz"> <em class="jw">决</em> </strong>！</p><p id="e5cc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能需要探索更多关于线程中的锁、多处理中的池以及asyncio中其他一些很酷的特性。我只是把你介绍给他们，我希望你喜欢过山车！</p><p id="aa15" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有任何反馈、意见或担忧，请在下面的回复中留下。这将有助于我学习和提高。</p><p id="15f7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢和问候，泰迪·温特斯</p></div></div>    
</body>
</html>