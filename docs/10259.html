<html>
<head>
<title>Exploring ELF files using pyelftools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 pyelftools 浏览 ELF 文件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploring-elf-files-using-pyelftools-93bb7665cce3?source=collection_archive---------3-----------------------#2020-10-11">https://medium.com/analytics-vidhya/exploring-elf-files-using-pyelftools-93bb7665cce3?source=collection_archive---------3-----------------------#2020-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="61a0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="14e1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有很多工具可以探索<a class="ae kb" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="noopener ugc nofollow" target="_blank"> ELF 格式</a>的可执行文件。其中大多数旨在提供从上述格式的二进制文件中提取的唯一信息。它们很棒，但有时我们需要一种通用但高度专业化的工具，允许做比标准工具更多的事情。这是<strong class="jf hj"> pyelftools </strong>发挥作用的时刻。</p><p id="132d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在这篇文章中，我想展示一些<strong class="jf hj"> pyelftools </strong>的用法示例。我没有展示如何使用 pyelftools 本身，也就是它的类和其他特性，因为你可以在<a class="ae kb" href="https://github.com/eliben/pyelftools/wiki/User's-guide" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae kb" href="https://github.com/eliben/pyelftools" rel="noopener ugc nofollow" target="_blank">源代码</a>本身中找到。相反，我专注于这个工具在特定用途上的应用。</p><h1 id="30a0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">先决条件</h1><h1 id="c994" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">环境</h1><p id="c8b8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以下信息是我的测试环境，您的可能会有所不同:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f120" class="kq ig hi km b fi kr ks l kt ku">hedin@home:~/projects/elf$ lsb_release -a<br/>    LSB Version:    core-11.1.0ubuntu2-noarch:security-11.1.0ubuntu2-noarch<br/>    Distributor ID: Ubuntu<br/>    Description:    Ubuntu 20.04.1 LTS<br/>    Release:        20.04<br/>    Codename:       focal<br/></span><span id="a47c" class="kq ig hi km b fi kv ks l kt ku">    hedin@home:~/projects/elf$ python3 --version<br/>    Python 3.8.5</span></pre><h1 id="15e1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">要求</h1><p id="e872" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本文中给出的脚本需要:</p><ul class=""><li id="ffc8" class="kw kx hi jf b jg kc jk kd jo ky js kz jw la ka lb lc ld le bi translated">Python 版或更高版本。</li><li id="093c" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">pyelftools</li></ul><h1 id="38de" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">装置</h1><p id="c155" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有些基于 Linux 的发行版不包含 python3 或 pip3。我们还需要安装<strong class="jf hj"> pyelftools </strong>。下面的代码块是如何在基于 debian 的发行版上安装所有提到的:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a7a3" class="kq ig hi km b fi kr ks l kt ku">sudo apt install python3-pip<br/>pip3 install --upgrade pip<br/>pip3 install pyelftools</span></pre><h1 id="1c11" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">用法示例</h1><p id="8c54" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好了，现在我们已经安装了<strong class="jf hj"> pyelftools </strong>。但是接下来呢？怎么用，为什么用？我想展示一些标准<a class="ae kb" href="https://interrupt.memfault.com/blog/gnu-binutils" rel="noopener ugc nofollow" target="_blank"> GNU Binutils </a>工具的输出，然后提供基于 pyelftools 的代码片段。所有的代码片段都可以在我的<a class="ae kb" href="https://github.com/Romeus/elf" rel="noopener ugc nofollow" target="_blank"> ELF github 库</a>中找到。</p><h1 id="214a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">用于内存和磁盘表示的不同大小的段</h1><p id="66af" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以下引用的规范为我们提供了关于 ELF 文件中的段的信息:</p><blockquote class="lk ll lm"><p id="8f6c" class="jd je ln jf b jg kc ji jj jk kd jm jn lo ke jq jr lp kf ju jv lq kg jy jz ka hb bi translated">可执行或共享目标文件的程序头表是一个结构数组，每个结构描述一个<em class="hi">段</em>或系统准备程序执行所需的其他信息。一个目标文件段包含一个或多个节。程序头仅对可执行文件和共享目标文件有意义。</p></blockquote><p id="f563" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">从编程的角度来看，下面的结构显示了 ELF 文件标题表中的一个段的表示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9134" class="kq ig hi km b fi kr ks l kt ku">typedef struct {<br/>    Elf32_Word p_type;<br/>    Elf32_Off p_offset;<br/>    Elf32_Addr p_vaddr;<br/>    Elf32_Addr p_paddr;<br/>    Elf32_Word p_filesz;<br/>    Elf32_Word p_memsz;<br/>    Elf32_Word p_flags;<br/>    Elf32_Word p_align;<br/>} Elf32_Phdr;</span></pre><p id="a8f7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们对该结构的两个成员感兴趣:</p><blockquote class="lk ll lm"><p id="20a4" class="jd je ln jf b jg kc ji jj jk kd jm jn lo ke jq jr lp kf ju jv lq kg jy jz ka hb bi translated">p_filesz  —该成员给出段的文件映像中的字节数；可能是零。</p><p id="3c62" class="jd je ln jf b jg kc ji jj jk kd jm jn lo ke jq jr lp kf ju jv lq kg jy jz ka hb bi translated"><strong class="jf hj"> p_memsz </strong> —该成员给出段的内存映像中的字节数；可能是零。</p></blockquote><p id="f4b9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在我们看到文件和内存中的数据段大小可能不同。这取决于路段中包含的路段数量和类型、路段的线形以及其他一些原因。我们感兴趣的是寻找具有不同大小的片段。首先，让我们看看一个伟大的<strong class="jf hj"> readelf </strong>工具的用法，它允许我们提取这些信息:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0995" class="kq ig hi km b fi kr ks l kt ku">hedin@home:~/projects/elf$ readelf --wide --segments /bin/ps</span></pre><p id="f5a1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我将全部输出缩减为分段信息:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="71c7" class="kq ig hi km b fi kr ks l kt ku">....................................................................<br/>    There are 13 program headers, starting at offset 64<br/>    Program Headers:<br/>      Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align<br/>      PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8<br/>      INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1<br/>          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<br/>      LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x009a88 0x009a88 R   0x1000<br/>      LOAD           0x00a000 0x000000000000a000 0x000000000000a000 0x00bbf1 0x00bbf1 R E 0x1000<br/>      LOAD           0x016000 0x0000000000016000 0x0000000000016000 0x006318 0x006318 R   0x1000<br/>      LOAD           0x01cf70 0x000000000001df70 0x000000000001df70 0x004190 0x025478 RW  0x1000<br/>      DYNAMIC        0x020ac0 0x0000000000021ac0 0x0000000000021ac0 0x000210 0x000210 RW  0x8<br/>      NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000020 0x000020 R   0x8<br/>      NOTE           0x000358 0x0000000000000358 0x0000000000000358 0x000044 0x000044 R   0x4<br/>      GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000020 0x000020 R   0x8<br/>      GNU_EH_FRAME   0x019e1c 0x0000000000019e1c 0x0000000000019e1c 0x0007b4 0x0007b4 R   0x4<br/>      GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10<br/>      GNU_RELRO      0x01cf70 0x000000000001df70 0x000000000001df70 0x004090 0x004090 R   0x1<br/>    ....................................................................</span></pre><p id="1d07" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们拥有所有需要的信息，但它并没有以一种让我们感到舒服的方式出现。为了找到合适的段，我们需要检查每个段并比较<strong class="jf hj"> FileSiz </strong>和<strong class="jf hj"> MemSiz </strong>列。让我们编写自己的基本脚本，它将向我们显示内存和磁盘上表示的不同大小的段。这个脚本的核心是一个简单的循环，它遍历 ELF 二进制文件的所有段，并呈现满足条件<strong class="jf hj"> p_filesz！= p_memsz </strong>:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2d41" class="kq ig hi km b fi kr ks l kt ku">#!/usr/bin/env python3</span><span id="ecfa" class="kq ig hi km b fi kv ks l kt ku">    import sys<br/>    from elftools.elf.elffile import ELFFile<br/>    from elftools.elf.segments import Segment</span><span id="27c7" class="kq ig hi km b fi kv ks l kt ku">    if __name__ == '__main__':</span><span id="708d" class="kq ig hi km b fi kv ks l kt ku">        if len(sys.argv) &lt; 2:<br/>            print("You must provide this script with an elf binary file you want to examine")<br/>            exit(1)</span><span id="3e3c" class="kq ig hi km b fi kv ks l kt ku">        print(f"Segments of the file {sys.argv[1]} which size on disk and in memory differs")</span><span id="b851" class="kq ig hi km b fi kv ks l kt ku">        with open(sys.argv[1], 'rb') as elffile:<br/>            for segment in ELFFile(elffile).iter_segments():<br/>                if segment.header.p_filesz != segment.header.p_memsz:<br/>                    seg_head = segment.header<br/>                    print(f"Type: {seg_head.p_type}\nOffset: {hex(seg_head.p_offset)}\nSize in file:{hex(seg_head.p_filesz)}\nSize in memory:{hex(seg_head.p_memsz)}")</span></pre><p id="f69f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，让我们使用以下脚本来查找所需的段:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ab27" class="kq ig hi km b fi kr ks l kt ku">hedin@home:~/projects/elf$ python3 segments.py /bin/ps<br/>    Segments of the file /bin/ps which size on disk and in memory differs<br/>    Type: PT_LOAD<br/>    Offset: 0x1cf70<br/>    Size in file:0x4190<br/>    Size in memory:0x25478</span></pre><p id="34c8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">正如你所看到的，在一个标准的/bin/ps 工具中，只有一个段在内存和磁盘上是不同的。</p><h1 id="bf3c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">段与段之间映射的表示</h1><p id="692e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从前面的例子中，我们知道每个段可以包含许多部分。readelf 工具给了我们前者和后者之间的映射。我减少了映射本身的输出，因为有很多信息不依赖于映射。看起来是这样的:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5253" class="kq ig hi km b fi kr ks l kt ku">hedin@home:~/projects/elf$ readelf — segments — wide /bin/ps</span><span id="f07d" class="kq ig hi km b fi kv ks l kt ku">Section to Segment mapping:<br/>      Segment Sections...<br/>       00     <br/>       01     .interp <br/>       02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt <br/>       03     .init .plt .plt.got .plt.sec .text .fini <br/>       04     .rodata .eh_frame_hdr .eh_frame <br/>       05     .init_array .fini_array .data.rel.ro .dynamic .got .data .bss <br/>       06     .dynamic <br/>       07     .note.gnu.property <br/>       08     .note.gnu.build-id .note.ABI-tag <br/>       09     .note.gnu.property <br/>       10     .eh_frame_hdr <br/>       11     <br/>       12     .init_array .fini_array .data.rel.ro .dynamic .got</span></pre><p id="0eb7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">嗯……信息量不大，也不方便用户使用，是吗？为了解决这种情况，我创建了一个小脚本，以更合适的形式显示映射。但是在我提供这个脚本之前，我将分享 elf 规范中的节结构<a class="ae kb" href="http://refspecs.linuxbase.org/elf/elf.pdf" rel="noopener ugc nofollow" target="_blank">的定义:</a></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6dde" class="kq ig hi km b fi kr ks l kt ku">typedef struct {<br/>    Elf32_Word sh_name;<br/>    Elf32_Word sh_type;<br/>    Elf32_Word sh_flags;<br/>    Elf32_Addr sh_addr;<br/>    Elf32_Off sh_offset;<br/>    Elf32_Word sh_size;<br/>    Elf32_Word sh_link;<br/>    Elf32_Word sh_info;<br/>    Elf32_Word sh_addralign;<br/>    Elf32_Word sh_entsize;<br/>} Elf32_Shdr;</span></pre><p id="6fd3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这个结构向我们展示了应该通过它的名字来识别这个部分。此外，我想强调一个更有趣的成员:</p><blockquote class="lk ll lm"><p id="54e2" class="jd je ln jf b jg kc ji jj jk kd jm jn lo ke jq jr lp kf ju jv lq kg jy jz ka hb bi translated"><strong class="jf hj"> sh_addr </strong> —如果该段将出现在进程的内存映像中，该成员给出该段的第一个字节应该驻留的地址。否则，该成员包含 0。</p></blockquote><p id="c290" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我认为脚本输出中的节外观应该由节名及其地址来标识，如下所示(<strong class="jf hj"> section_name </strong>，<strong class="jf hj"> sh_addr </strong>)。</p><p id="98b4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">剧本的行为是什么？很简单。循环通过段，对于每个段，循环通过属于它的部分:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7ffa" class="kq ig hi km b fi kr ks l kt ku">#!/usr/bin/env python3</span><span id="b711" class="kq ig hi km b fi kv ks l kt ku">    import sys<br/>    from elftools.elf.elffile import ELFFile</span><span id="e9f8" class="kq ig hi km b fi kv ks l kt ku">    if __name__ == '__main__':</span><span id="59a7" class="kq ig hi km b fi kv ks l kt ku">        if len(sys.argv) &lt; 2:<br/>            print("You must provide this script with an elf binary file you want to examine")<br/>            exit(1)</span><span id="4c9e" class="kq ig hi km b fi kv ks l kt ku">        print(f"Mapping between segments and sections in the file {sys.argv[1]}")</span><span id="5bdf" class="kq ig hi km b fi kv ks l kt ku">        elffile = ELFFile(open(sys.argv[1], 'rb'))</span><span id="2661" class="kq ig hi km b fi kv ks l kt ku">        segments = list()<br/>        for segment_idx in range(elffile.num_segments()):<br/>            segments.insert(segment_idx, dict())<br/>            segments[segment_idx]['segment'] = elffile.get_segment(segment_idx)<br/>            segments[segment_idx]['sections'] = list()</span><span id="21f2" class="kq ig hi km b fi kv ks l kt ku">        for section_idx in range(elffile.num_sections()):<br/>            section = elffile.get_section(section_idx)<br/>            for segment in segments:<br/>                if segment['segment'].section_in_segment(section):<br/>                    segment['sections'].append(section)</span><span id="a94f" class="kq ig hi km b fi kv ks l kt ku">        for segment in segments:<br/>            seg_head = segment['segment'].header<br/>            print("Segment:")<br/>            print(f"Type: {seg_head.p_type}\nOffset: {hex(seg_head.p_offset)}\nVirtual address: {hex(seg_head.p_vaddr)}\nPhysical address: {(seg_head.p_paddr)}\nSize in file: {hex(seg_head.p_filesz)}\nSize in memory: {hex(seg_head.p_memsz)}\n")</span><span id="718e" class="kq ig hi km b fi kv ks l kt ku">            if segment['sections']:<br/>                print("Segment's sections:")<br/>                print([(section.name, hex(section['sh_addr'])) for section in segment['sections']], sep=', ', end='\n')<br/>            else:<br/>                print('Segment contains no sections')</span><span id="067b" class="kq ig hi km b fi kv ks l kt ku">            print('\n--------------------------------------------------------------------------------')</span></pre><p id="82f4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">以下是这个脚本的输出(为了减小大小，我截掉了大部分片段):</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="934c" class="kq ig hi km b fi kr ks l kt ku">hedin@home:~/projects/elf$ python3 segments_sections.py /bin/ps</span><span id="ee0e" class="kq ig hi km b fi kv ks l kt ku">    Mapping between segments and sections in the file /bin/ps<br/>    Segment:<br/>    Type: PT_PHDR<br/>    Offset: 0x40<br/>    Virtual address: 0x40<br/>    Physical address: 64<br/>    Size in file: 0x2d8<br/>    Size in memory: 0x2d8</span><span id="f6e8" class="kq ig hi km b fi kv ks l kt ku">    Segment contains no sections                         </span><span id="ecf5" class="kq ig hi km b fi kv ks l kt ku">    ----------------------------------------------------------------<br/>    Segment:<br/>    Type: PT_INTERP<br/>    Offset: 0x318<br/>    Virtual address: 0x318<br/>    Physical address: 792<br/>    Size in file: 0x1c<br/>    Size in memory: 0x1c</span><span id="7864" class="kq ig hi km b fi kv ks l kt ku">    Segment's sections:<br/>    [('.interp', '0x318')]</span><span id="bf6c" class="kq ig hi km b fi kv ks l kt ku">    ----------------------------------------------------------------<br/>    Segment:<br/>    Type: PT_LOAD<br/>    Offset: 0x0<br/>    Virtual address: 0x0<br/>    Physical address: 0<br/>    Size in file: 0x9a88<br/>    Size in memory: 0x9a88</span><span id="c0ba" class="kq ig hi km b fi kv ks l kt ku">    Segment's sections:<br/>    [('', '0x0'), ('.interp', '0x318'), ('.note.gnu.property', '0x338'), ('.note.gnu.build-id', '0x358'), ('.note.ABI-tag', '0x37c'), ('.gnu.hash', '0x3a0'), ('.dynsym', '0x3e8'), ('.dynstr', '0xdc0'), ('.gnu.version'<br/>    , '0x121e'), ('.gnu.version_r', '0x12f0'), ('.rela.dyn', '0x13a0'), ('.rela.plt', '0x91e8')]              </span><span id="7202" class="kq ig hi km b fi kv ks l kt ku">    ----------------------------------------------------------------<br/>    ....................................................................</span></pre><h1 id="7260" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">不驻留在内存中的部分</h1><p id="0847" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我的最后一个例子展示了一些没有加载到内存中的特殊部分，也就是它们的<strong class="jf hj"> sh_addr == 0 </strong>:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8d90" class="kq ig hi km b fi kr ks l kt ku">#!/usr/bin/env python3</span><span id="49d2" class="kq ig hi km b fi kv ks l kt ku">    import sys<br/>    from elftools.elf.elffile import ELFFile</span><span id="88db" class="kq ig hi km b fi kv ks l kt ku">    if __name__ == '__main__':</span><span id="2208" class="kq ig hi km b fi kv ks l kt ku">        if len(sys.argv) &lt; 2:<br/>            print("You must provide this script with an elf binary file you want to examine")<br/>            exit(1)</span><span id="36b8" class="kq ig hi km b fi kv ks l kt ku">        print(f"Sections of the file {sys.argv[1]} that are not loaded into memory")</span><span id="fa83" class="kq ig hi km b fi kv ks l kt ku">        with open(sys.argv[1], 'rb') as elffile:<br/>            for section in ELFFile(elffile).iter_sections():<br/>                if not section.header.sh_addr:<br/>                    print(section.name)</span></pre><p id="3ea1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这是 bin/ps 的输出:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="785e" class="kq ig hi km b fi kr ks l kt ku">hedin@home:~/projects/elf$ python3 sections_not_in_memory.py /bin/ps<br/>    Sections of the file /bin/ps that are not loaded into memory</span><span id="8991" class="kq ig hi km b fi kv ks l kt ku">    .gnu_debuglink<br/>    .shstrtab</span></pre><h1 id="12a7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">摘要</h1><p id="c0fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> pyelftools </strong>是一个非常灵活方便的观测 ELF 双星的工具。它的范围远远超出了本文给出的简单示例，并允许创建成熟的探索工具。</p><h1 id="0a0f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><ol class=""><li id="29cc" class="kw kx hi jf b jg jh jk jl jo lr js ls jw lt ka lu lc ld le bi translated"><a class="ae kb" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="noopener ugc nofollow" target="_blank">可执行可链接格式</a></li><li id="a337" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lu lc ld le bi translated"><a class="ae kb" href="https://github.com/eliben/pyelftools" rel="noopener ugc nofollow" target="_blank"> pyelftools </a></li><li id="e8d6" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lu lc ld le bi translated"><a class="ae kb" href="https://interrupt.memfault.com/blog/gnu-binutils" rel="noopener ugc nofollow" target="_blank"> GNU Binutils </a></li><li id="7e13" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lu lc ld le bi translated"><a class="ae kb" href="https://github.com/Romeus/elf" rel="noopener ugc nofollow" target="_blank"> ELF 脚本库</a></li></ol></div></div>    
</body>
</html>