<html>
<head>
<title>Data Cleaning and Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据清理和预处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-cleaning-and-preprocessing-a4b751f4066f?source=collection_archive---------0-----------------------#2019-11-19">https://medium.com/analytics-vidhya/data-cleaning-and-preprocessing-a4b751f4066f?source=collection_archive---------0-----------------------#2019-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/46b28c91708a9296ffcce4a029f442fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_Dmc5XzTLds1FC-65XNnA.jpeg"/></div></div></figure><div class=""/><p id="3ff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据预处理包括将原始数据集转换成可理解的格式。数据预处理是数据挖掘中提高数据效率的基础阶段。数据预处理方法直接影响任何分析算法的结果。</p><p id="7dbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据预处理通常分7个简单步骤进行:</p><h1 id="0e3e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">数据预处理的步骤:</h1><ol class=""><li id="855f" class="km kn ht is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">收集数据</li><li id="d8de" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">导入数据集和库</li><li id="8ce4" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">处理缺失值</li><li id="a95d" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">将数据集分为因变量和自变量</li><li id="474e" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">处理分类值</li><li id="22aa" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">将数据集分为训练集和测试集</li><li id="25fc" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">特征缩放</li></ol><h1 id="c64b" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> 1。</strong>收集数据</h1><p id="fabf" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">数据是原始信息，它代表了人类和机器对世界的观察。数据集完全取决于你想解决什么类型的问题。机器学习中的每个问题都有自己独特的方法。</p><p id="68c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我与您分享一些网站来获取数据集:</p><ol class=""><li id="33ff" class="km kn ht is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">Kaggle: Kaggle是我个人最喜欢的获取数据集的一个。https://www.kaggle.com/datasets<br/>T3</li><li id="7c3c" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">UCI机器学习库:网络上获取数据集的最古老的来源之一。<br/><a class="ae li" href="http://mlr.cs.umass.edu/ml/" rel="noopener ugc nofollow" target="_blank">http://mlr.cs.umass.edu/ml/</a></li><li id="448f" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">这个令人敬畏的GitHub知识库拥有高质量的数据集。<br/><em class="lj"/><a class="ae li" href="https://github.com/awesomedata/awesome-public-datasets" rel="noopener ugc nofollow" target="_blank">https://github.com/awesomedata/awesome-public-datasets</a></li><li id="70b8" class="km kn ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">如果你在寻找政府的公开数据，这里有一些:<br/>印度政府:<a class="ae li" href="http://data.gov.in/" rel="noopener ugc nofollow" target="_blank">http://data.gov.in</a><br/>美国政府:<a class="ae li" href="https://www.data.gov/" rel="noopener ugc nofollow" target="_blank">https://www.data.gov/</a><br/>英国政府:<a class="ae li" href="https://data.gov.uk/" rel="noopener ugc nofollow" target="_blank">https://data.gov.uk/</a><br/>法国政府:<a class="ae li" href="https://www.data.gouv.fr/en/" rel="noopener ugc nofollow" target="_blank">https://www.data.gouv.fr/en/</a></li></ol><h1 id="1ebc" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2.导入数据集和库</h1><p id="0131" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">第一步通常是导入程序中需要的库。库本质上是可以被调用和使用的模块的集合。</p><p id="3be8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且可以借助'<em class="lj"> import' </em>关键字导入python代码中的库。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es lk"><img src="../Images/a18b9d6c22b681392a89c16f9ad2c161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*2nPwM3FmS0_EFdrazMheDw.png"/></div></figure><h2 id="84d5" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">导入数据集</h2><p id="13b0" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用Pandas库使用<em class="lj"> read_csv() </em>方法加载数据。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es md"><img src="../Images/a12b3d50f3f8c4b2849568036c88b773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*M8gwqEdgWy-hg8anQcrnpQ.png"/></div></figure><p id="b799" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有csv格式的数据，有很多种文件可以使用pandas库读取，如下所示:</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es me"><img src="../Images/e9fbce0f2061ed3685b72e4a4a2dbba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*AJwCNrx7gJEDTrvSB9LNBQ.png"/></div></figure><h1 id="718f" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3.处理缺失值</h1><p id="7a37" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">有时我们可能会发现数据集中缺少一些数据。如果我们找到了，那么我们将删除这些行，或者我们可以计算特征的平均值、众数或中值，并用缺失值替换它。这是一个近似值，可能会增加数据集的差异。</p><h2 id="1e27" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">#检查空值:</h2><p id="fb2a" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们可以使用pandas库检查数据集中的空值，如下所示。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/fac123a80a93f3dfc31655d1ee281595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*HRKDWv_ycefl3fEGdJfsjg.png"/></div></figure><p id="9c86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="lj"> info() </em>的帮助下，我们可以找到条目的总数以及所有特性的数据类型的非空值的计数。</p><p id="32d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以使用<em class="lj"> dataset.isna() </em>来查看数据集中的空值。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/22d32ea6fd88d3aa10966887e831c02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*8W2W7LNurCLFWXuW-tQzCw.png"/></div></figure><p id="25e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我们通常处理大型数据集，因此获得对应于每个要素的所有空值的计数将是一件好事，这将通过使用<em class="lj"> sum()来完成。</em></p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mh"><img src="../Images/ecee7733e8241f8d44ba816f65f02e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*qIPLhqccvTgC0gGNv9KCYw.png"/></div></figure><p id="62d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到'<strong class="is hu">年龄</strong>'和'<strong class="is hu">工资</strong>'包含空值。</p><h2 id="7718" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">#删除空值:</h2><p id="a7b9" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Pandas提供了一个<strong class="is hu"> dropna() </strong>函数，可以用来删除丢失数据的行或列。我们可以使用<em class="lj"> dropna() </em>删除所有丢失数据的行。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mi"><img src="../Images/2f69823b64a27a9a7aa37d803be4f2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*gX4XaGHIxoEvWNsqvOqFPQ.png"/></div></figure><p id="2a62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到在第4个和第6个索引之前有空值。如上图所示，我们可以看到缺失数据的两行都被删除了。但是这并不总是一个好主意。有时我们有一个小的数据集，就像我们在例子中使用的那样，删除整行意味着我们从数据集中删除了一些有价值的信息。</p><p id="ffb5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">#用策略替换空值:</strong></p><p id="8f8e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了替换空值，我们使用可应用于具有数字数据的特征的策略。我们可以计算特征的<em class="lj">均值、中值或众数</em>，并用缺失值替换它。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/bce8583eb9bdfbddc0c1a4ab17a88568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*wyWMPTmKP3FKVi53xLpJCw.png"/></div></div></figure><p id="b6ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码行中，它将影响整个数据集，并将每个变量的空值替换为它们各自的平均值，并且'<em class="lj"> inplace =True </em>'表示影响对数据集的更改。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mk"><img src="../Images/7162cf6165dc6e352df42e0ec6b2b330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*LGRb616qaDEb0ceMCUnw1g.png"/></div></figure><p id="e7c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们需要用策略替换特定的变量，那么我们可以使用上面的代码行。</p><h1 id="c3dd" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">4.将数据集分为因变量和自变量</h1><p id="3d6c" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">导入数据集后，下一步是确定自变量(X)和因变量(Y)。</p><p id="4056" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lj">基本上数据集可能被标记或未标记，这里我考虑机器学习分类问题的标记数据集，并考虑一个小数据集以便更好地理解，在我们的数据集中有四列</em> <strong class="is hu"> <em class="lj">国家、年龄、工资和购买的</em> </strong> <em class="lj">，实际上它是一个购物中心的数据集，处理购买或未购买该产品的客户数据。</em></p><p id="1fe4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的数据集中，有三个自变量(<strong class="is hu"> <em class="lj">国家、年龄和工资</em> </strong>)和一个因变量(<strong class="is hu"> <em class="lj">购买</em> </strong>)我们必须预测。</p><p id="10e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了读取列，我们将使用<em class="lj"> pandas </em>的<em class="lj"> iloc </em>(用于固定选择的索引)，它采用两个参数—【行选择，列选择】。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/b6b65896f9f8a6ef7335dbbb181b291d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*soXcLOFtq3Sm1Tmo1Ie4jA.png"/></div></figure><blockquote class="mm mn mo"><p id="3f19" class="iq ir lj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><em class="ht">注意:<br/></em><strong class="is hu"><em class="ht">:</em></strong><em class="ht">全选，使用</em><strong class="is hu"><em class="ht"/></strong><em class="ht">帮助你选择多列或多行，这就是如何对数据集进行切片。</em></p><p id="bee1" class="iq ir lj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><em class="ht">你可以在这里阅读更多关于</em> iloc <a class="ae li" href="https://www.shanelynn.ie/select-pandas-dataframe-rows-and-columns-using-iloc-loc-and-ix/" rel="noopener ugc nofollow" target="_blank">的用法。</a></p></blockquote><p id="e544" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们能够选择因变量(Y)和自变量(X)的方法。</p><h1 id="6f3f" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">5.处理分类值</h1><p id="3e47" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在让我们看看如何处理分类值。</p><p id="cf79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的数据集中有一个分类变量'<strong class="is hu"> Country </strong>'。现在，机器理解和处理文本变得复杂起来，而不是数字，因为模型是基于数学方程和计算的。因此，我们必须对分类数据进行编码。</p><p id="5725" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要为任务使用的库名为<a class="ae li" href="http://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"><em class="lj">Scikit Learn</em></a><em class="lj">。预处理</em>。库中有一个名为<em class="lj"> LabelEncoder </em>的类，我们将用它来编码<em class="lj">。</em></p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es ms"><img src="../Images/279e731e030403729efe8adfd588f8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*au2A9WwIGihsGu7p8EGR3g.png"/></div></figure><p id="c852" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步通常是创建该类的对象。我们将把我们的对象称为lEncoder。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mt"><img src="../Images/a54f43e92a8be2a30980dc0659e4a446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*s_KEnTrftP6ZZUDc0N0Fcg.png"/></div></figure><p id="07bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，第一列包含文本形式的数据。我们可以观察到有3类，<strong class="is hu">法国，西班牙&amp;德国</strong>。现在要将它转换成数字，我们可以使用下面的代码:</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mu"><img src="../Images/0a1767baa22a1d234561bc87acd2d915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*fyUeyL9r9kbcYTWZ5_CJmA.png"/></div></figure><p id="ec98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们看看变量x。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mv"><img src="../Images/891201749d126e79411949eca971bae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*KYfsmeE0ZcCZ0RR7h7uvtg.png"/></div></figure><p id="4429" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们可以看到所有三个文本值都被转换成了数值:</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mw"><img src="../Images/17e13c755fc49e5ed8ec5c53e9f0f5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*m4mYnrVlDDwVlDW_26qvUA.png"/></div></figure><p id="5a89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，分类值已被编码。<strong class="is hu">但是有个问题！</strong></p><p id="09db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题还是一样。机器学习模型是基于等式的，我们用数字代替文本是件好事。但是，由于1大于0，2大于1，因此模型中的等式会认为西班牙的值高于德国和法国，而德国的值高于法国。事实当然不是这样。这实际上是三个类别，它们之间没有关系顺序。因此，我们必须防止这种情况，我们将使用<strong class="is hu">虚拟变量。</strong></p><h2 id="c708" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">什么是虚拟变量？</h2><p id="ed70" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hu">虚拟变量"</strong>是一个取值为0或1的变量，表示可能会改变结果的某种分类效应的存在或不存在。</p><p id="c7b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着这里不是只有一列，而是每个类别有三列，它们的值分别为1和0。</p><p id="216a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">列数=类别类型</strong></p><p id="76fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我们有3种类型，所以我们将有3列。为此，我们将导入另一个名为<strong class="is hu">onehotencode的库。</strong></p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mx"><img src="../Images/1e68f3191817a58e25b2ce72c21286bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*fH-WAgCGmwxR59SNjikbPQ.png"/></div></figure><blockquote class="mm mn mo"><p id="8e7c" class="iq ir lj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">注意:OneHotEncoder要求所有的值都是整数，而不是我们所要求的字符串。这意味着我们首先必须将所有可能的值编码为整数。意味着它应该是整数值。</p></blockquote><p id="07c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是用一个名为categorical _ features的重要参数创建该类的对象，该参数接受列的索引值。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es my"><img src="../Images/9f09e6e08f6862ee79fe21575fbf3bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*lbvDQC-gAXuw91m4LHAaiA.png"/></div></figure><p id="ef27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对<em class="lj"> OneHotEncoder </em>使用<strong class="is hu"> fit_transform() </strong>，就像我们之前对<em class="lj"> LabelEncoder </em>使用的一样。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mz"><img src="../Images/3c12b97cfa9efb9bf45e18f1a31f3139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*RdA7m8VDH4R2YF6scHrHnQ.png"/></div></figure><p id="32ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们得到了numpy数组形式的独立变量X。同样，我们可以借助<em class="lj">类型(X) </em>进行检查。只是为了向你展示X看起来像什么，我们将使用下面的代码转换成熊猫数据帧。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es na"><img src="../Images/acfeb47d4ec9a7597d7038c888db1279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*TE1jK0CutFuVyxi5CmViWg.png"/></div></figure><p id="772d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">意味着有三个变量与类别相对应。在上面的代码中，我们使用<em class="lj"> dtype </em>将所有浮点值转换成整数。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nb"><img src="../Images/6c1510e13cf7d749a3e904f232677b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*Gy5nE2M7GfAtD_CgeHgarA.png"/></div></figure><p id="b3ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在将用因变量(Y)做标签编码</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/40db655053d4ffcdbf9e64f139474e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*iPMiOdSkhbib7Jc95CtIkg.png"/></div></figure><p id="b291" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们得到了X和Y，它们都是编码形式，现在它们都可以应用于机器学习模型。</p><h1 id="ac3d" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">6.将数据集分为训练集和测试集</h1><p id="f2ca" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在机器学习中，我们通常将数据分为训练和测试数据，以应用模型。</p><p id="4924" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常，我们将数据集分成70:30或80:20(根据要求),这意味着70%的数据用于训练，30%的数据用于测试。</p><p id="4ab5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个任务，我们将从scikit的<em class="lj">模型选择</em>库中导入<em class="lj">训练测试分割</em>。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nd"><img src="../Images/517ec6465d323a6697776fb753791b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*40H6yW3d-ap6zbJDOrHOJw.png"/></div></figure><p id="b9b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了构建我们的训练和测试集，我们将创建4个集-X _ train(特征的训练部分)、X_test(特征的测试部分)、Y_train(与X训练集相关联的因变量的训练部分，因此也是相同的指数)、Y_test(与X测试集相关联的因变量的测试部分，因此也是相同的指数)。我们将为它们分配<em class="lj"> train_test_split </em>，它接受参数——arrays(X和Y)，test_size(理想的选择是将数据集的20%分配给测试集，它通常被分配为0.2。0.25将意味着25%)。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es ne"><img src="../Images/61b8f765ca470bcfe6cda9cf31b3c6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*YPrU3SxL6EhniRgR3urL8w.png"/></div></figure><h1 id="4f2f" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">7.特征缩放</h1><p id="69d1" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">数据预处理的最后一步是应用非常重要的特征缩放。</p><p id="601f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要素缩放是一种将固定范围内数据中的独立要素标准化的技术。这是在数据预处理期间执行的。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nf"><img src="../Images/6fbf6859398b57cc4350115cef0cd800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*Uu6Fc79N1_KGIoSSi2AGNg.jpeg"/></div></figure><p id="01c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">为什么要缩放</strong> :-大多数情况下，您的数据集将包含在量级、单位和范围上变化很大的要素。但是，由于大多数机器学习算法在计算中使用两个数据点之间的欧几里德距离，这是一个问题。</p><blockquote class="mm mn mo"><p id="4947" class="iq ir lj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">特征缩放在很多方面真正影响了机器学习模型。我同意在很多情况下特性缩放是可选的或者不需要的。仍然有许多机器学习算法，其中特征缩放必须有过程。例如，回归、逻辑回归、支持向量机、k-均值(参见k-最近邻)、PCA、神经网络等。</p></blockquote><p id="6060" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缩放特征或列值的方法有很多种。它完全面向场景，而标量将更加面向性能。让我们开始一个一个地探索它们——</p><h2 id="c5b4" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">标准化:</h2><p id="20de" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">这是数据预处理中最常用的标量类型之一。这就是所谓的z分数。这样重新分配数据，使得平均值(μ) = 0，标准偏差(σ) =1。以下是计算公式</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es ng"><img src="../Images/2fd57b48f3f611e5586f23a48f15f44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*yFw-7hoa7qe0cSWAPXqsDw.png"/></div></figure><h2 id="d583" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">标准化:</h2><p id="f6fe" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">规格化在0.0和1.0之间缩放特征，保持它们彼此的比例范围。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nh"><img src="../Images/8c5ab8f85d95ed2df3bab27ebde85a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*xOuWfQsjWRlpHxhv3UhgzA.png"/></div></figure><p id="8b86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正态分布的范围是[-1，1]，均值=0。</p><h2 id="2043" class="lp jp ht bd jq lq lr ls ju lt lu lv jy jb lw lx kc jf ly lz kg jj ma mb kk mc bi translated">最小-最大标量技术；</h2><p id="f012" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">特别是当你需要在[0，1]范围内变换特征量时。这种最小-最大特征缩放技术是最佳选择之一。这是公式——</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es ni"><img src="../Images/bfaf3fb9049f1b5e555759af3d86e368.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*6wc1Vezclq9Dq0WB4q90lw.png"/></div></figure><p id="e432" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种方法中，数据被缩放到一个固定的范围—通常是0到1。</p><p id="3165" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将应用标准化公式，并使其适合一个规模。为了完成这项工作，我们将从<em class="lj"> sckit预处理</em>库中导入类<em class="lj"> StandardScaler </em>，并照常创建该类的一个对象。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nj"><img src="../Images/f7c5e8789ecce6917e8add8d43e59b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*0rJxdTDcnxLj4FlNMJ5khQ.png"/></div></figure><p id="01de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将所有数据(X_train和X_test)转换为相同的标准化比例。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es nk"><img src="../Images/0f13c1f9f953aaaf249682fb6f8cb2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*j5EicOBuCZnrEszh1yQfDg.png"/></div></figure><p id="1861" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看X_train是什么样子。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nl"><img src="../Images/acb1978bbb0897e484a2cb7342711b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*10UNIun601uKWspKsAecLQ.png"/></div></div></figure><blockquote class="mm mn mo"><p id="1c2f" class="iq ir lj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">我们需要对因变量(Y)应用特征缩放吗？</p><p id="490a" class="iq ir lj is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">答:正如我们看到的，因变量是分类的，因为它只有两个值0和1，这是一个分类问题，所以在这种情况下，我们不会缩放这个向量。但是如果我们将讨论回归问题，那么我们也将对因变量进行缩放。</p></blockquote><p id="01a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是预处理数据的一般步骤。这取决于您拥有的数据集。</p><p id="9caa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢你坚持到这里！我希望你喜欢这个！😃</p><p id="6820" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您有任何问题或建议，请告诉我！</p><p id="cff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢大家！😃😃😃</p></div></div>    
</body>
</html>