<html>
<head>
<title>Naive Bayes Algorithm from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始的朴素贝叶斯算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/naive-bayes-algorithm-from-scratch-c59d262a042?source=collection_archive---------10-----------------------#2020-10-21">https://medium.com/analytics-vidhya/naive-bayes-algorithm-from-scratch-c59d262a042?source=collection_archive---------10-----------------------#2020-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">朴素贝叶斯是一种简单的机器学习算法。它是一个求知欲很强的学习者，这意味着它花在训练上的时间比测试要多。该算法基于所有特征相互独立的假设。</p><p id="3e94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它基于贝叶斯定理。它很容易建造。它是模型的集合，而不仅仅是单一的模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ea3b7141eb7570c059d9e6815006dfd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*yufCfwfNLI3wzmv2jyo7Mw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">贝叶斯定理</figcaption></figure><p id="7cdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，</p><p id="e6a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(A|B):给定预测类的后验概率</p><p id="ee54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(A):类的先验概率</p><p id="8bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(B|A):似然性，它是给定类的预测值的概率</p><p id="8a27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(B):预测值的先验概率</p><p id="609f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">朴素贝叶斯定理有三种类型，高斯型、多项式型和贝努里型。我们将从头开始发展高斯朴素贝叶斯定理。在高斯朴素贝叶斯中，特征的分布被假定为高斯或正态分布。当绘制时，它给出了关于特征值的平均值对称的钟形曲线。</p><h1 id="d3a3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从理论开始</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kn"><img src="../Images/4ab92ce3a3c50b2abb6b373f2e513b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*1eTZdwSU6d4ApGNlvp9zHw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">我们情况下的贝叶斯定理</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kn"><img src="../Images/eb71500c92027a50308f3f79d32d7bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*7JKaSvDoyQOwGzGqCG-QDQ.png"/></div></figure><p id="207b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设这些特征相互独立后，我们可以直接将这些概率与先验概率相乘。为了获得数据点的类别，我们找到目标类别的最大概率，即，如果类别A具有最高概率，则该数据点属于类别A。由于忽略了先验概率，因此只有分子是重要的。由于条件概率给我们的值非常小，因此我们将log应用于整个分子，使其成为条件概率的总和。这些条件概率是使用高斯函数找到的。</p><h1 id="76c5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Python代码</h1><h2 id="1e9c" class="ko jq hi bd jr kp kq kr jv ks kt ku jz iq kv kw kd iu kx ky kh iy kz la kl lb bi translated">导入基本库以便执行</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/32eb8c9672de345fc7da293a47ab4c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae0IoYXUnUhs6TpjWWD5qQ.png"/></div></div></figure><p id="0db8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有进口的熊猫和numpy图书馆。</p><h2 id="6542" class="ko jq hi bd jr kp kq kr jv ks kt ku jz iq kv kw kd iu kx ky kh iy kz la kl lb bi translated">定义朴素贝叶斯类</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/7767770776e1b4a5f9b6dbc8233bcff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOzsXZpJAobOVxZhdqAXTQ.png"/></div></div></figure><p id="bb5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们看到了类中的四个函数。在拟合函数中，我们得到样本、特征的数量，以及唯一类的数量。我们还为均值和方差声明了numpy数组，所有的类和特征的大小都为零。我们还创建了一个numpy数组来表示类别大小的先验概率。此后，找出并存储均值、方差和先验概率。</p><p id="5805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测函数用于预测数据点的类别。_predict函数用于将概率最大的类返回给predict函数。正如我们看到的，在_predict函数中，prior从_pdf函数中获取其值，该函数使用高斯函数来获取条件概率，该值通过取其自然对数来存储。Class_conditional存储先验概率的总和。Posterior存储class_conditional和prior的和，稍后追加到posteriors列表中。我们将具有最大概率的类的最大值返回给先验函数。</p><p id="20d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把这种朴素贝叶斯算法应用于UCI心脏病数据集。在应用朴素贝叶斯之前，我们需要预处理这个数据集。我们用StandardScaler来做这个。我们将从头开始学习如何编写StandardScaler。</p><h1 id="0f90" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">标准缩放器</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/057bd4b06fac2c656e0cdf31c978ae21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7e2Jx48ruclQp2ovdIRpZw.png"/></div></div></figure><p id="78d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们看到StandardScaler类包含三个函数fit、transform和fit_transform。在拟合函数中，我们找到了数据集中每一列的平均值和标准方差。Transform函数用于规范化列，使用以下函数转换列中的每个值。(X —平均值)/标准方差。Fit_transform用于在一个步骤中同时拟合和转换数据集。</p><h2 id="080f" class="ko jq hi bd jr kp kq kr jv ks kt ku jz iq kv kw kd iu kx ky kh iy kz la kl lb bi translated">读取数据集并应用数据集</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/15703707b58d74f2f7466e5ade288fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tT3F_oMFLJwzveUhh_8fYA.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/ec4fe41d7d9271d321600a8408ff60c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sob7JtTevWqw3GLToH7pfw.png"/></div></div></figure><p id="8288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经阅读了UCI数据集，我们看到该数据集包括303个数据点和13个特征以及1列目标类。目标栏表示患者是否患有心脏病(用1表示)或没有心脏病(用0表示)。该数据集包含164名心脏病患者和139名非心脏病患者的数据。年龄和性别属性用于识别目的，其他11个属性包含重要的临床记录。<a class="ae lh" href="http://sersc.org/journals/index.php/IJAST/article/view/29849" rel="noopener ugc nofollow" target="_blank">【1】</a></p><p id="c8de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用的数据集包含以下特征</p><ul class=""><li id="2427" class="li lj hi ih b ii ij im in iq lk iu ll iy lm jc ln lo lp lq bi translated">年龄:患者的年龄</li><li id="ce0b" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">性别:性别(1 =男性，0 =女性)</li><li id="5483" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">cp:胸痛类型(0 =典型心绞痛，1 =非典型心绞痛，2 =非心绞痛性疼痛，3 =无症状)</li><li id="e403" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">trestbps:静息血压(入院时单位为毫米汞柱)</li><li id="4481" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">chol:血清胆固醇，单位为毫克/分升</li><li id="22b0" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">fbs:空腹血糖&gt; 120 mg/dl (0 =假，1 =真)</li><li id="cbc9" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">静息心电图:静息心电图结果(0 =正常，1 =有ST-T波</li><li id="b0b2" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">异常，2 =根据Estes标准显示可能或明确的左心室肥大)</li><li id="39c8" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">thalach:达到最低心率</li><li id="febd" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">例:运动诱发的心绞痛(0 =是，1 =否)</li><li id="966c" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">oldpeak:相对于静息运动诱发的ST段压低</li><li id="bbd1" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">斜率:运动ST段峰值的斜率(1=上坡，2 =平缓，3 =下坡)</li><li id="a64c" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">ca:透视着色的主要血管数(0-3)</li><li id="95a2" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">thal: 3 =正常；6 =修复缺陷；7 =可逆缺陷</li></ul><p id="63a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们对除目标列之外的所有列应用标准缩放器。我们还打印数据集的平均值和标准值。</p><h2 id="b394" class="ko jq hi bd jr kp kq kr jv ks kt ku jz iq kv kw kd iu kx ky kh iy kz la kl lb bi translated">分割数据集并应用朴素贝叶斯</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/345a1fa407607abb7182c95e7ed95299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diJALytQjafkIShgCZOQdA.png"/></div></div></figure><p id="5384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们引入了train_test_split模块，将数据集分成训练和测试两部分。然后，我们将除目标列之外的所有列分配给变量x，将目标分配给变量y。然后，我们使用train_test_split将数据集拆分为定型数据和测试数据，其中测试数据占数据集的20%。然后，我们应用朴素贝叶斯算法，然后使用训练数据集拟合模型。测试数据集用于使用预测函数测试数据集。在使用predict函数之前，我们需要将x_test数据帧转换成一个numpy数组。然后，我们使用如下所示的accuracy_score函数计算模型的准确性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/85c0a7c0333b2c27dc448efc757d09e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsAua9Lx6ITdMVi9Zx1H9w.png"/></div></div></figure><p id="93f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准确性是正确预测的百分比。</p><p id="8633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还设计了一个图形用户界面，它接受用户的输入，并预测用户是否患有心脏病。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/eff6e6cf54ff033159cb63e514db68d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*HboTjQMfIj8arHmeMRGjhg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">GUI预测用户有心脏病</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/8aabb17be98dd0e12d973dc6f8ee1e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*9P67evNOKK6d3NqJB48vTQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">GUI预测用户没有心脏病</figcaption></figure><h1 id="2b51" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">朴素贝叶斯算法的应用</h1><ul class=""><li id="0d51" class="li lj hi ih b ii lx im ly iq lz iu ma iy mb jc ln lo lp lq bi translated">当数据集很小且有许多参数时</li><li id="8233" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">当分类器需要易于解释时</li></ul><h1 id="1931" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">朴素贝叶斯算法的优势</h1><ul class=""><li id="6ef0" class="li lj hi ih b ii lx im ly iq lz iu ma iy mb jc ln lo lp lq bi translated">该方法易于实现，处理速度快</li><li id="14b2" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">当假设成立时，它会给出更好的结果</li><li id="8d96" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">在分类数据上表现良好</li></ul><h1 id="2507" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">朴素贝叶斯算法的缺点</h1><ul class=""><li id="7c08" class="li lj hi ih b ii lx im ly iq lz iu ma iy mb jc ln lo lp lq bi translated">如果目标类不在训练数据中，那么它就不能预测该类。</li><li id="5cda" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">在现实世界的数据集中，要素通常是相互依赖的。</li></ul><h1 id="29b1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">标准缩放器</h1><p id="36e0" class="pw-post-body-paragraph if ig hi ih b ii lx ik il im ly io ip iq mc is it iu md iw ix iy me ja jb jc hb bi translated">标准标量通过从数据中减去数据集的平均值，然后缩放至单位方差来标准化数据。单位方差是指所有值除以标准偏差。StandardAero产生的分布均值等于0，标准差等于1，大部分值介于-1和1之间。作为参考，假设数据集具有以下值([[1，-1，2]，[2，0，0]，[0，1，-1]])。应用标准标量后，值被转换为([[0，1.22，-1.22]，[- 1.22，0，1.22]，[1.33，-0.26，-1.06]])。我们可以清楚地看到，经过处理的数据集的平均值为(0，0，0)，标准差为(0.99，0.99，0.99)(几乎等于1)。尽管标准标量有助于简化数据处理，但它也有自己的局限性。在存在异常值的情况下，它不能很好地执行。异常值在计算经验平均值和标准偏差时会产生影响，这会缩小数据值的范围。由于每个要素上的异常值具有不同的大小，因此每个要素上的变换数据的分布非常不同。因此，在异常值存在的情况下，标准标量不能保证平衡的特征尺度。</p><h1 id="b75b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><ul class=""><li id="4784" class="li lj hi ih b ii lx im ly iq lz iu ma iy mb jc ln lo lp lq bi translated">我们从头开始创建了朴素贝叶斯、StandardScaler和Accuracy_score函数。</li><li id="836c" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">将它们应用于UCI心脏病数据集，取得了90.16%的准确率</li><li id="5f05" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">我们还为模型创建了一个GUI，并预测了用户输入数据的类别。</li></ul><h1 id="280b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考</h1><p id="725f" class="pw-post-body-paragraph if ig hi ih b ii lx ik il im ly io ip iq mc is it iu md iw ix iy me ja jb jc hb bi translated">[1] Swapnil Singh，Ameyaa Biwalkar。(2020).机器学习算法对心脏病数据集的影响。<em class="mf">《国际先进科技杂志》</em>，<em class="mf"> 29 </em> (3)，11786 -。检索自<a class="ae lh" href="http://sersc.org/journals/index.php/IJAST/article/view/29849" rel="noopener ugc nofollow" target="_blank">http://sersc . org/journals/index . PHP/ij astt/article/view/29849</a></p><h2 id="ef1c" class="ko jq hi bd jr kp kq kr jv ks kt ku jz iq kv kw kd iu kx ky kh iy kz la kl lb bi translated">访问<a class="ae lh" href="https://github.com/The-Swapster/NaiveBayes" rel="noopener ugc nofollow" target="_blank">https://github.com/The-Swapster/NaiveBayes</a>获取GUI代码</h2></div></div>    
</body>
</html>