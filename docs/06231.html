<html>
<head>
<title>A Neural net that plays the Chrome dino game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">玩Chrome dino游戏的神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-neural-net-that-plays-the-chrome-dino-game-95c98a61257b?source=collection_archive---------14-----------------------#2020-05-15">https://medium.com/analytics-vidhya/a-neural-net-that-plays-the-chrome-dino-game-95c98a61257b?source=collection_archive---------14-----------------------#2020-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="804f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些时候，我们都遇到过这个页面，你可能试图修复你的互联网，或按空格键玩游戏。然而，我和普里特维·阿尼尔·库马尔试图训练一个模型自己玩这个游戏。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/92d7ddeeab1cd4193ed068a3f8af6efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7Td8zjuH4QWjHbW2WitdA.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">把“chrome://dino”放在chrome上玩游戏</figcaption></figure><h1 id="ba9d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">手头的任务:</h1><ol class=""><li id="8b79" class="kt ku hi ih b ii kv im kw iq kx iu ky iy kz jc la lb lc ld bi translated">自动化数据收集流程</li><li id="24ff" class="kt ku hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">制作一个简单的网络</li><li id="93dd" class="kt ku hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">创建一个脚本来实时预测和行动</li></ol><h1 id="a17b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">创建数据集</h1><p id="c800" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">这是我们想出来的<a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet/blob/master/Training/Create_Dataset.py" rel="noopener ugc nofollow" target="_blank">剧本</a>，你可以跟着看。</p><p id="483c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建数据集，我们必须注意两件事:</p><ul class=""><li id="b630" class="kt ku hi ih b ii ij im in iq ln iu lo iy lp jc lq lb lc ld bi translated">截图</li><li id="d176" class="kt ku hi ih b ii le im lf iq lg iu lh iy li jc lq lb lc ld bi translated">记录键盘输入</li></ul><p id="0c31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们尝试了几个模块来截图，在<a class="ae lm" href="https://pypi.org/project/pyscreenshot/" rel="noopener ugc nofollow" target="_blank"> pyscreenshot </a>、<a class="ae lm" href="https://pypi.org/project/PyAutoGUI/" rel="noopener ugc nofollow" target="_blank"> pyautogui </a>和<a class="ae lm" href="https://pypi.org/project/Pillow/" rel="noopener ugc nofollow" target="_blank"> pillow </a>中，我们能够最快地从pillow中获取截图。当截图并立即保存图像时，我们得到了一个可怕的帧速率，通常低于每秒一张图片(1080*1920图像保存为。png)。为了解决这个问题，我们决定将图像保存在RAM中，稍后保存到磁盘。现在我们平均每0.07秒或14.28 FPS就能截图一次。由于内存错误，我们的脚本在保存图像之前就会崩溃。这个问题很容易解决，方法是将图像大小调整为216*384，然后保存到ram中。</p><p id="3b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录keyinput非常简单，我们使用了<a class="ae lm" href="https://pypi.org/project/keyboard/" rel="noopener ugc nofollow" target="_blank">键盘包</a>来记录输入并将图像保存在它所属的文件夹中。</p><h1 id="2079" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">模型</h1><p id="5934" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">你可以跟着<a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet/tree/master/Pynotebooks" rel="noopener ugc nofollow" target="_blank">到这里</a></p><p id="cb1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从一个简单的类似LeNet-5的架构开始，不幸的是这个模型的表现比第一次玩的玩家差。对我们来说，这些预测似乎是随机的。最后，我们增加了完全连接层的数量，并对初始Conv层的过滤器大小和数量进行了调整。当我们看到我们的模型能够达到高达98.05%的准确率时，我们非常高兴！然而，当我们试图在预测脚本中运行它时，我们的恐龙每次都会碰到第一棵仙人掌。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lr"><img src="../Images/91bcc333dfe616b9fe911be171433f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOfyNOfkjO5z4mL0KJbGZQ.jpeg"/></div></div></figure><p id="2d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们很快意识到，我们有一个学习预测0类的模型，这实际上是我们数据的98.05%。这是我们开始了解不平衡数据集的时候。</p><h2 id="4682" class="ls jw hi bd jx lt lu lv kb lw lx ly kf iq lz ma kj iu mb mc kn iy md me kr mf bi translated">不平衡数据</h2><p id="14e5" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">什么是不平衡数据？当你的大部分数据属于一个类，并盖过了其他少数类时，就是这样。对于一个模型来说，学习预测多数类并以较低的损失和良好的准确性逃脱是非常常见的。</p><p id="ff16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用一个更好的例子来理解这个问题。让我们假设有一种疾病存在于所有人中的0.1%。如果有人制作了一个准确率达到99.9%的机器学习模型，这本身不应该成为医院选择他的模型的衡量标准。一个模型可以非常容易地获得这种准确性，只需每次预测都是负面的，最终达到99.9%的准确性。这将是一个可怕的模型！你真正应该寻找的是精确和回忆。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mg"><img src="../Images/dca7fae5f55bf48885517b97912f2d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*7nd-l7kEDuP3dy01h3YQwA.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">精准Vs召回。<a class="ae lm" href="https://commons.wikimedia.org/wiki/User:Walber" rel="noopener ugc nofollow" target="_blank">创作者</a>和<a class="ae lm" href="https://en.wikipedia.org/wiki/File:Precisionrecall.svg" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="c744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时一个模型得到更好的精确度，而另一个可能得到更好的回忆。在这种情况下，你应该用F1分数来判断哪个型号更好。</p><p id="eb99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">F1得分= 2*(精确度*召回率)/(精确度+召回率)</p><p id="0e06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何修复不平衡的数据:</p><ul class=""><li id="9358" class="kt ku hi ih b ii ij im in iq ln iu lo iy lp jc lq lb lc ld bi translated">欠采样多数类</li><li id="d560" class="kt ku hi ih b ii le im lf iq lg iu lh iy li jc lq lb lc ld bi translated">过采样少数类</li><li id="c3e0" class="kt ku hi ih b ii le im lf iq lg iu lh iy li jc lq lb lc ld bi translated">类别权重</li></ul><p id="aff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前两种方法非常明显，有助于平衡类分布。第三种方法非常有趣，类权重增加了权重较高的类的损失，从而阻止了模型始终预测多数类。当正确实施时，类权重在激励模型以更好的精确度、准确度和召回率进行预测方面非常有效。</p><p id="f002" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这仍然无法执行任何地方接近我们想要的。当查看我们的数据时，我们看到了改变感受域的潜力，只包括恐龙和它附近的东西，而不是将整个屏幕截图提供给模型。这将使模型更容易知道什么时候跳跃，什么时候什么也不做。不会有其他的模型必须学习的特性是不相关的。<a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet/blob/master/Training/Preprocess.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这个</strong> </a>就是我们做的。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mh"><img src="../Images/e4c625146831ddc8690b6c56e608d35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF_KpQwwSgoHchz7Lqw4bg.png"/></div></div></figure><p id="e69f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在有了一个模型，它能够很好地执行，能够得到250分以上的分数，但通常会在400分左右崩溃。我们取得的最好成绩是470分左右。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mi"><img src="../Images/eb44e20300643fa4fd16652a287e2b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWhwNL_bUcGXVfHkP6Xvkw.png"/></div></div></figure><p id="7859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使模型更深似乎很有希望，所以我们添加了一些模式FC层。像我们之前那样肤浅的模型(2个conv+最大池+ 3个FC)不符合“深度学习”这个名字。有了这个更好的和<a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet/tree/master/Model/goodmodelv2" rel="noopener ugc nofollow" target="_blank">改进的模型</a>，我们能够得到好得多的结果。这是迄今为止表现最好的型号。它的平均得分约为500-600分，最高得分约为750分。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mj"><img src="../Images/ff8648889c37e3e191943a7027ece067.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*lzbl9KkPxJNKNPvCua-d-Q.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">GoodmodelV2架构</figcaption></figure><p id="5522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让恐龙根据我们的模型预测的输出跳跃，我们使用了这个<a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet/blob/master/Output/app2.py" rel="noopener ugc nofollow" target="_blank">预测脚本</a>。我们将模型作为json文件和权重分别保存在colab上，并在本地加载这些文件。该脚本本身非常简单，在加载模型和权重后，它截取一个截图，将其转换为(384，216，1)灰度图像，并转换为一个numpy数组。现在，根据模型被训练的图像部分，脚本必须裁剪截图以反映原始图像的相同部分。现在，它以适合模型使用的格式进行了重新整形。使用pyautogui使代理根据模型的预测进行操作。</p><p id="60c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从来没有让模型运行超过700英里，因为那时天会变暗，我们的数据集没有任何夜间图像。我们决定通过使用<a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet/blob/master/Training/Preprocess2.ipynb" rel="noopener ugc nofollow" target="_blank">这个python脚本</a>简单地反转白天的照片来增加夜晚的数据，而不是在天黑时收集一堆图像。这概括了它的平均性能。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mk"><img src="../Images/f1ecb046ba4e07dea04c0e103e0ab083.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*_-inofN9ERx7bhHZkAJVfQ.gif"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">质量非常低的gif</figcaption></figure><p id="03c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lm" href="https://www.youtube.com/watch?v=56pw_7bM2Cg&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=56pw_7bM2Cg&amp;feature = youtu . be</a></p><p id="a66d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用google colab，我们训练了大量的模型，试验了过滤器的大小、学习速度、神经元的数量、层数以及我们能得到的所有超参数。我们不能给谷歌colab足够的信任！他们真的让人在云上免费使用非常强大的GPU！</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lr"><img src="../Images/27a075981467eb6a13616fd73464ba30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjzOT39uM0HubXe-WpHEaA.jpeg"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">谢谢谷歌colab</figcaption></figure><p id="bc45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，即使有夜间数据，我们的模型也无法超越之前的最佳模型。除了夜间数据扩充，我们还为一个新的类“duck”收集数据。顾名思义，这个类包含恐龙应该闪避时的图像。这是我们目前拥有的三个职业的样子:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ml"><img src="../Images/691e300d2062e4332250e41229797e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*QeUGjqGTD4NiJQCUxvO3hw.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">0类:无</figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ml"><img src="../Images/add8c4bd025fc021f2353dbd6dd6114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*UChn_kNkN5hQeGb-rP-xBg.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">第一类:跳跃</figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ml"><img src="../Images/825dddba0136958887cfe7050cd15d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*03gHrB9W1KJ726Tk6j5H9Q.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">第二类:鸭子</figcaption></figure><p id="3eb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有一个问题变得非常明显，一旦你运行你的模型。我们看到，一旦预测了类别“duck ”,模型就不会停止预测“duck ”,当然，除非它看到了仙人掌(然后它会以很高的置信度预测jump)。我们用“鸭子”类训练的大多数模型都有同样的问题。我这样做的原因是，一旦恐龙闪避，模型就会得到一个被闪避的恐龙的截图，并且可能已经知道，只要它看到恐龙已经闪避，它就必须预测“闪避”类。我们尝试了一系列方法，如更改输入以不包含dino本身，减少“duck”类的类权重，我们甚至尝试添加一个“unduck”类(一个伪类，否则将属于类0，nothing)以防止dino进入永久的“duck”状态。这似乎有时会起作用，但恐龙有时仍然表现不佳。</p><p id="0499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在尝试以前的模型时，我们发现只根据白天数据训练的模型即使在天黑后也会继续玩。有趣的是，这个模型学会了自己对白天数据的抽象和转换，并在晚上播放！</p><p id="d4ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在我们的一个模型上看到了大约1200左右的高分。该模型在遇到飞鸟时不断失败，它试图跳入鸟中而不是躲避，因为它没有被训练来预测“鸭子”类别。当我们使用模型作为辅助，而不是一个独立的模型来玩游戏时，我们能够得到更好的分数。我们甚至能够在使用它作为辅助时越过3000大关。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mm"><img src="../Images/47170443414f2452e1cebe1fbddd4fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFTBoFZ4NBJ4VjfmYClqoQ.jpeg"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">用作辅助</figcaption></figure><p id="cb42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一天结束的时候，我们可能还没有接近最先进的水平，如果有这样的东西来完成这项任务的话。我们确实学到了很多，对于一个初学者的项目，我们认为我们已经做得很好了。即使考虑到我们花了很多时间清理数据，等待模型训练和收集数据，这绝对是我们做的一个有趣的小项目。我们一直在寻找可以尝试的建议和改进。</p><p id="2a21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经将所有的数据和代码上传到这里(小于100mb，因为这是文件大小的限制):</p><p id="6ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lm" href="https://github.com/Shreyas-MS/DinoNet" rel="noopener ugc nofollow" target="_blank">https://github.com/Shreyas-MS/DinoNet</a></p><p id="e01b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://www.youtube.com/watch?v=56pw_7bM2Cg】T2&amp;feature = youtu . be</p></div></div>    
</body>
</html>