<html>
<head>
<title>Fine tune SARIMA hyperparams using Parallel processing with joblib (Step by Step Python code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用joblib并行处理微调SARIMA超参数(逐步Python代码)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fine-tune-sarima-hyperparams-using-parallel-processing-with-joblib-step-by-step-python-code-2037fec1659?source=collection_archive---------8-----------------------#2020-04-19">https://medium.com/analytics-vidhya/fine-tune-sarima-hyperparams-using-parallel-processing-with-joblib-step-by-step-python-code-2037fec1659?source=collection_archive---------8-----------------------#2020-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="7ba1" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在使用大多数机器学习或统计模型时，有时您需要微调算法的各种参数，以获得更准确的结果。有这么多组合需要测试，这是一个耗时的过程。使用并行处理和多线程大大减少了这一时间。这里有一个关于如何在python中做到这一点的逐步指南。</p></blockquote><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div></figure><h1 id="d09e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让我们先了解一下基本情况:</h1><p id="1fd8" class="pw-post-body-paragraph ii ij hi il b im km io ip iq kn is it ko kp iw ix kq kr ja jb ks kt je jf jg hb bi translated">让我们看一段简单的代码，其中有一个<code class="du ku kv kw kx b">for </code>循环:</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="1b56" class="lc jp hi kx b fi ld le l lf lg">import numpy as np</span><span id="c020" class="lc jp hi kx b fi lh le l lf lg">def square_a_number(a):<br/>    return (a*a)</span><span id="dfc8" class="lc jp hi kx b fi lh le l lf lg">for i in np.arange(1,11):<br/>    print(square_a_number(i))</span></pre><p id="ecd4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">该代码简单地打印从1到10的每个数字的平方。然而，这是按顺序计算的。所以。输出将是:</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="9549" class="lc jp hi kx b fi ld le l lf lg">1<br/>4<br/>9<br/>16<br/>25<br/>36<br/>49<br/>64<br/>81<br/>100</span></pre><p id="4ad0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">我现在希望每个循环都由一个线程单独处理，这样所有10个值都可以同时计算。为此，我需要一个多核GPU，每个内核处理一个线程/进程。因为我没有带，所以我在网上租的。我在谷歌上搜索了最便宜的服务，得到了一个名为<em class="ik"> vast.ai的服务。</em></p><h1 id="2ac8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">租用多核GPU:</h1><p id="928b" class="pw-post-body-paragraph ii ij hi il b im km io ip iq kn is it ko kp iw ix kq kr ja jb ks kt je jf jg hb bi translated">我去<a class="ae li" href="https://vast.ai/console" rel="noopener ugc nofollow" target="_blank"> vast.ai </a>租了一个48核的机器。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/4b8f181ec48bc138250093097a554e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmR2Us3_qIH8oH0dLlcoZQ.png"/></div></div></figure><p id="20a6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">当实例就绪时，连接到计算机。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lq"><img src="../Images/48ad748c878187dc5e0e2f96527dac9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwbyoklyY2VtndxnG5GreQ.png"/></div></div></figure><p id="5dfc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">一个Jupyter笔记本将会推出，在那里你可以写你的代码。</p><p id="07ef" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">好了，现在来看看上面循环的并行代码:</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="0bd4" class="lc jp hi kx b fi ld le l lf lg">!pip install joblib</span></pre><p id="9ad1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">joblib库允许python中的并行处理。</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="575e" class="lc jp hi kx b fi ld le l lf lg">from multiprocessing import cpu_count<br/>from joblib import Parallel<br/>from joblib import delayed</span><span id="4784" class="lc jp hi kx b fi lh le l lf lg">executor = Parallel(n_jobs=cpu_count(), backend='multiprocessing') <br/>tasks = (delayed(square_a_number)(i) for i in np.arange(1,11))<br/>result = executor(tasks)<br/>result</span></pre><p id="192e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">输出:</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="640a" class="lc jp hi kx b fi ld le l lf lg">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></pre><ol class=""><li id="5498" class="lr ls hi il b im in iq ir ko lt kq lu ks lv jg lw lx ly lz bi translated">我们首先创建一个有<code class="du ku kv kw kx b"><em class="ik">n_jobs </em></code>线程的<code class="du ku kv kw kx b"><em class="ik">executor </em></code>。在这个特殊的例子中，我们将它设置为<code class="du ku kv kw kx b"><em class="ik">cpu_count()</em></code>，对于这个GPU来说是48——这是它拥有的内核数。</li><li id="724b" class="lr ls hi il b im ma iq mb ko mc kq md ks me jg lw lx ly lz bi translated">然后，使用<code class="du ku kv kw kx b"><em class="ik">delayed</em></code>关键字，我们调用我们的函数。与传统的for循环语法不同，我们将它写在如上所示的同一行中。</li><li id="be25" class="lr ls hi il b im ma iq mb ko mc kq md ks me jg lw lx ly lz bi translated"><code class="du ku kv kw kx b"><em class="ik">executor </em></code>运行任务并返回一个列表。</li></ol><blockquote class="if ig ih"><p id="09e7" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">请注意，现在输出不是像以前那样打印，而是一个列表。</p></blockquote><p id="1f00" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">基本的就这些了。现在让我们继续SARIMA超参数调谐。</p><h1 id="a4ad" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">SARIMA调谐:</h1><p id="2764" class="pw-post-body-paragraph ii ij hi il b im km io ip iq kn is it ko kp iw ix kq kr ja jb ks kt je jf jg hb bi translated">我们想尝试(P，D，Q)和(P，D，Q，m)的多种组合。如果你想阅读ARIMA、萨里玛或其他时间序列预测模型，你可以在这里<a class="ae li" href="https://otexts.com/fpp2/seasonal-arima.html#" rel="noopener ugc nofollow" target="_blank">阅读。</a></p><p id="6b3f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">我们需要多个嵌套循环，比如:</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="4ae0" class="lc jp hi kx b fi ld le l lf lg">for p in p_vals:<br/>  for d in d_vals:<br/>    for q in q_vals:<br/>      for P in P_vals:<br/>        for D in D_vals:<br/>          for Q in Q_vals:<br/>            call_sarima_model_evaluation_function(p,d,q,P,D,Q)</span></pre><p id="2fea" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">这正是我们在将其转换为并行模式后所做的。主要的两个函数如下所示:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mf jn l"/></div></figure><p id="9c15" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">如您所见，我们已经使用<code class="du ku kv kw kx b"> delayed</code>关键字调用了<code class="du ku kv kw kx b">evaluate_sarima_model</code>。</p><p id="bbbd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">我们称之为:</p><pre class="jh ji jj jk fd ky kx kz la aw lb bi"><span id="afc1" class="lc jp hi kx b fi ld le l lf lg"><em class="ik"># specify the range of values we want ot try for the different hyperprameters</em><br/>p_values = np.arange(0, 2)<br/>d_values = np.arange(1, 2)<br/>q_values = np.arange(1, 4)<br/>P_values = np.arange(0, 2)<br/>D_values = np.arange(1, 2)<br/>Q_values = np.arange(0, 3)<br/>m_values = np.arange(7, 8)<br/><br/><em class="ik"># total combinations being tried: 2*1*3*2*1*3*1 = 36</em><br/><br/>scor=evaluate_models_parallely(train, valid, p_values, d_values, q_values, P_values, D_values, Q_values, m_values)<br/><br/>scores=[]<br/><strong class="kx hj">for</strong> tup_list <strong class="kx hj">in</strong> scor:<br/>    <strong class="kx hj">for</strong> tup <strong class="kx hj">in</strong> tup_list:<br/>        scores.append(tup)<br/><br/><em class="ik"># sort the results on basis of RMSE scores (ascending)</em><br/>scores.sort(key=<strong class="kx hj">lambda</strong> x: x[0])<br/><br/>print('<strong class="kx hj">\n</strong>Top 5 SARIMA params with minimum RMSEs:<strong class="kx hj">\n</strong>')<br/><strong class="kx hj">for</strong> x <strong class="kx hj">in</strong> scores[:5]:<br/>  print(f'RMSE=<strong class="kx hj">{x[0]}</strong>  order=<strong class="kx hj">{x[1]}</strong>  seasonal_order=<strong class="kx hj">{x[2]}\n</strong>')<br/><br/>print("DONE!")</span></pre><blockquote class="if ig ih"><p id="7d3f" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这里是完整代码的链接，您可以自由使用和定制:</p><p id="efbb" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><a class="ae li" href="https://github.com/HCGrit/MachineLearning-iamJustAStudent/tree/master/Demo-Parallel_Grid_Search_SARIMAX" rel="noopener ugc nofollow" target="_blank">并行网格搜索萨里玛</a></p></blockquote><h1 id="426e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">输出:</h1><p id="1a41" class="pw-post-body-paragraph ii ij hi il b im km io ip iq kn is it ko kp iw ix kq kr ja jb ks kt je jf jg hb bi translated">在我的例子中，36个模型同时被评估，输出如下所示:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mg"><img src="../Images/bbe61df35859fc01b7cd08fe4c60c5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vw0_bc-GpfxDEG7rIvELWA.png"/></div></div></figure><h1 id="7a88" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">破坏GPU:</h1><p id="05c3" class="pw-post-body-paragraph ii ij hi il b im km io ip iq kn is it ko kp iw ix kq kr ja jb ks kt je jf jg hb bi translated">一旦你完成了，一定要记得销毁租用的GPU实例，你每一秒钟都在被收费！</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mh"><img src="../Images/1a9815f9101b4080e2ba10dce138e7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYOZJ7an4X-3hFSucLHSkQ.png"/></div></div></figure></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="4dff" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">如果你需要以上任何帮助，请大声告诉我，我很乐意帮忙！</p><p id="265f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ko iv iw ix kq iz ja jb ks jd je jf jg hb bi translated">再见。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div></figure></div></div>    
</body>
</html>