<html>
<head>
<title>Kotlin Coroutines, The Fall Of RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin Coroutines，RxJava的衰落</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/kotlin-coroutines-the-fall-of-rxjava-1888c34803e2?source=collection_archive---------18-----------------------#2020-04-17">https://medium.com/analytics-vidhya/kotlin-coroutines-the-fall-of-rxjava-1888c34803e2?source=collection_archive---------18-----------------------#2020-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c056" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RxJava长期以来一直是救命恩人。凭借其提供的所有功能，Android编程思维模式已经大大转变为一种更具反应性的方式。</p><p id="7150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了协程(Coroutines)，它在很多会谈和会议中得到了赞扬和推荐，所以我开始学习它。</p><p id="838a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协程是编写可读性和可维护性非常好的异步代码的好方法。</p><p id="54db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将尝试用简单的语言解释协程的优势，以及它是如何超越竞争对手的。为了长话短说，我不会深入研究基于协程的高级结构。重点是给出一个概述，并分享我对协程的心理模型。</p><h1 id="a710" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是Kotlin协同程序？</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/8238bdc84dcaf840c5e2875aa3d4c9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aGVYcBPntM3uOchu-q9diA.gif"/></div></div></figure><blockquote class="kn"><p id="3af0" class="ko kp hi bd kq kr ks kt ku kv kw jc dx translated">C例程是计算机程序的组成部分，它通过允许暂停和恢复执行来概括非抢占式多任务的子程序</p></blockquote><p id="1115" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">Kotlin团队将协程定义为“轻量级线程”。它们是<em class="lc">实际</em>线程可以执行的任务。</p><p id="4a33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们是一种并发设计模式，您可以在Android上使用它来简化异步执行的代码。<a class="ae ld" href="https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html" rel="noopener ugc nofollow" target="_blank">协同程序</a>在版本1.3中被添加到Kotlin中，并且基于其他语言中已建立的概念。</p><h1 id="b18a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">它解决什么问题？</h1><p id="eb6c" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在Android上，协程有助于解决两个主要问题:</p><ol class=""><li id="c6c6" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">管理长时间运行的任务，否则可能会阻塞主线程并导致应用程序冻结。</li></ol><p id="c4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Android上，每个应用都有一个处理用户界面和管理用户交互的主线程。如果你的应用程序给主线程分配了太多的工作，那么这个应用程序看起来可能会冻结或者变慢。</p><p id="4cf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kotlin使用一个<em class="lc">堆栈框架</em>来管理哪个函数与任何局部变量一起运行。当挂起协程时，当前堆栈帧被复制并保存以备后用。当恢复时，堆栈帧从它被保存的地方被复制回来，函数再次开始运行。即使代码看起来像普通的顺序阻塞请求，协程也能确保网络请求避免阻塞主线程。</p><p id="9ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.提供<em class="lc">主安全</em>，或者从主线程安全调用网络或磁盘操作。</p><p id="a872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kotlin协程使用<em class="lc">调度程序</em>来决定哪些线程用于协程执行。要在主线程之外运行代码，可以告诉Kotlin协同程序在<em class="lc">默认</em>或<em class="lc"> IO </em>调度程序上执行工作。在Kotlin中，所有协程都必须运行在调度程序中，即使它们运行在主线程上。协程可以挂起自己，调度程序负责恢复它们。</p><h1 id="cbc0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">【RxJava呢？</h1><p id="1e5f" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在kotlin的协同程序出现之前，异步任务的现有解决方案是Rxjava。</p><p id="e767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RxJava是一个库，目标是在Java编程语言中使用反应式编程。Rx代表Reactive Extensions(react vex)，这是一个为不同的编程语言提供反应式编程实现的项目。</p><p id="cf62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RxJava是一个通用的、文档完善的API，它允许将任何操作的功能性声明性表示为异步数据流，可以在任何线程中创建，并由来自不同线程的多个对象使用。</p><p id="9a8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您在Java 8上使用RxJava时，它的全部功能是显而易见的，最好是使用像retrieval这样的库。它允许您将操作简单地链接在一起，并完全控制错误处理。例如，考虑下面给出的代码<code class="du ls lt lu lv b">id</code>:指定订单的int和apiClient:订单管理微服务的改进客户端:</p><pre class="kc kd ke kf fd lw lv lx ly aw lz bi"><span id="71d0" class="ma je hi lv b fi mb mc l md me">apiClient<br/>.getOrder(id)<br/>.subscribeOn(Schedulers.io())<br/>.flatMapIterable(Order::getLineItems)<br/>.flatMap(lineItem -&gt;<br/>    apiClient.getProduct(lineItem.getProductId())<br/>             .subscribeOn(Schedulers.io())<br/>             .map(product -&gt; product.getCurrentPrice() * lineItem.getCount()),<br/>    5)<br/>.reduce((a,b)-&gt;a+b)<br/>.retryWhen((e, count) -&gt; count&lt;2 &amp;&amp; (e instanceof RetrofitError))<br/>.onErrorReturn(e -&gt; -1)<br/>.subscribe(System.out::println);</span></pre><p id="da7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将使用以下属性异步计算订单的总价:</p><ul class=""><li id="cf6e" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc mf lp lq lr bi translated">在任何时候，最多有5个针对正在运行的API的请求(您可以调整IO调度器，为所有请求设置一个硬上限，而不仅仅是针对单个可观察链)</li><li id="39b5" class="lj lk hi ih b ii mg im mh iq mi iu mj iy mk jc mf lp lq lr bi translated">网络出错时最多重试2次</li><li id="1bcf" class="lj lk hi ih b ii mg im mh iq mi iu mj iy mk jc mf lp lq lr bi translated">-1以防失败(反模式TBH，但这是另一个讨论)</li></ul><p id="8320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，在IMO中，每个网络调用之后的<code class="du ls lt lu lv b">.subscribeOn(Schedulers.io())</code>应该是隐式的——您可以通过修改创建改进客户端的方式来做到这一点。对于11+2行代码来说还不错，即使它比Android更像后端。</p><h1 id="5e82" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Kotlin协同程序的优势</h1><p id="df5c" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">与RxJava不同，协程侧重于提供一种机制来编写异步代码，这种机制也可以部分顺序运行，允许省略代码中的回调，从而转化为更紧凑的代码，易于生成和重构。</p><p id="6026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协程通过对更多并发代码使用挂起函数，使回收的回调成为更有序的代码，从而避免了回收回调的使用，这些代码仍然可以轻松地在线程间切换。协程的好处是可以直接集成到Kotlin语言中，虽然它们是最近才出现的，但是已经有多个应用程序甚至其他库支持它们。</p><h2 id="3ee1" class="ma je hi bd jf ml mm mn jj mo mp mq jn iq mr ms jr iu mt mu jv iy mv mw jz mx bi translated">Kotlin和协程是编写更简洁代码的一种方式</h2><p id="b45c" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">由于协程是用标准的Kotlin编写的，这个库适合新的Android项目，因为Google宣布Kotlin是Android的新语言。Google已经在其Android API中为Kotlin添加了强大的文档支持，所以深入研究一下可能是个更好的主意。</p><h2 id="3829" class="ma je hi bd jf ml mm mn jj mo mp mq jn iq mr ms jr iu mt mu jv iy mv mw jz mx bi translated">为管理线程提供了一种更简单的方法</h2><p id="7721" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">就协程而言，它们提供了一种管理线程的简单方法，非常适合在需要时在后台线程上执行进程。这种范式还提供了并发和结构化并发的简单实现。它易于扩展和维护，使得程序员编写代码、解决bug或组织和清理代码的时间的生产周期和效率更好。</p><h2 id="9c95" class="ma je hi bd jf ml mm mn jj mo mp mq jn iq mr ms jr iu mt mu jv iy mv mw jz mx bi translated">RxJava非常……复杂</h2><p id="8909" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">它可以优化代码以提高应用程序的响应能力，而且非常容易扩展，但由于过度使用，维护起来非常困难。它的复杂性是具有挑战性的，到处使用它的趋势使得代码非常复杂，更难调试，因此，使程序员在它上面浪费更多的时间来解决错误，围绕它开发新的代码，甚至维护或重写代码，因为它不返回错误，并且调试的唯一方法非常原始。</p><h2 id="b5f5" class="ma je hi bd jf ml mm mn jj mo mp mq jn iq mr ms jr iu mt mu jv iy mv mw jz mx bi translated">协程比RxJava更高效</h2><p id="00db" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">就性能而言，协程比RxJava更高效，因为它使用更少的资源来执行相同的任务，同时速度也更快。RxJava使用更多的内存并需要更多的CPU时间，这意味着更高的电池消耗和可能的用户界面中断。</p><h1 id="9bc1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">总之…</h1><p id="bbad" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在这篇文章的最后，我要说的是，在处理异步数据和函数时，Kotlin协同程序是一个更容易学习和使用的更快的选择</p><p id="3c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您目前对使用RxJava感到满意，我不会告诉您停止，我只是要求您看一看协程。</p><h1 id="178a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">那么，协程还是RxJava？</h1><p id="245f" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这是一个困难的选择，也很难对它们进行比较，因为Kotlin协程是一个精简的语言特性，而RxJava是一个相当庞大的库，有大量现成的操作符。</p><p id="e857" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案取决于您的用例场景。谢谢你把这个看完。</p><p id="5ef9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GitHub上关注我:<a class="ae ld" href="https://github.com/GeraudLuku" rel="noopener ugc nofollow" target="_blank">https://github.com/GeraudLuku</a></p><p id="582b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Linkedin上关注我:【www.linkedin.com/in/luku-geraud-3530b2177 T2】</p><h2 id="c9d6" class="ma je hi bd jf ml mm mn jj mo mp mq jn iq mr ms jr iu mt mu jv iy mv mw jz mx bi translated">参考</h2><div class="my mz ez fb na nb"><a href="https://exaud.com/rxjava-vs-coroutines-part-ii/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">RxJava VS Coroutines:你该选哪个？(第二部分)</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">我们回到RxJava &amp; Coroutines 101的第二部分——加入我们，继续探索这个理论分析…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">exaud.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kl nb"/></div></div></a></div><div class="my mz ez fb na nb"><a href="https://developer.android.com/kotlin/coroutines" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">借助Kotlin协同程序提高应用性能| Android开发人员</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">协程是一种并发设计模式，您可以在Android上使用它来简化异步执行的代码…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">developer.android.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np kl nb"/></div></div></a></div><div class="my mz ez fb na nb"><a href="https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">协同程序指南- Kotlin编程语言</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">作为一种语言，Kotlin在其标准库中只提供了最少的低级API来支持各种其他库…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">kotlinlang.org</p></div></div><div class="nk l"><div class="nr l nm nn no nk np kl nb"/></div></div></a></div></div></div>    
</body>
</html>