<html>
<head>
<title>Intro to the Python Walrus Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Walrus运算符简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/intro-to-the-python-walrus-operator-18097716a0b8?source=collection_archive---------10-----------------------#2019-09-29">https://medium.com/analytics-vidhya/intro-to-the-python-walrus-operator-18097716a0b8?source=collection_archive---------10-----------------------#2019-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/261d5e748fc47c20362ae5961001f05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyi4pEnP94GXWr8Z3ISD5A.jpeg"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><h2 id="069e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">介绍</h2><p id="eeb6" class="pw-post-body-paragraph jv jw hi jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hb bi translated">2018年2月28日在<a class="ae kq" href="https://www.python.org/dev/peps/pep-0572/" rel="noopener ugc nofollow" target="_blank"> PEP 572 </a>中首次提出，并由<a class="ae kq" href="https://twitter.com/emilyemorehouse" rel="noopener ugc nofollow" target="_blank"> Emily Morehouse </a>实现，即将发布的Python 3.8带来了一个新的语言功能，赋值表达式。这个新特性公开了在Python表达式中为变量赋值、计算结果，然后在变量的作用域内重用变量的功能。用于定义赋值表达式的<code class="du kr ks kt ku b">:=</code>操作符通俗地称为Walrus操作符。</p><blockquote class="kv kw kx"><p id="2247" class="jv jw ky jx b jy kz ka kb kc la ke kf lb lc kh ki ld le kk kl lf lg kn ko kp hb bi translated">在讨论该PEP时，该运营商被非正式地称为“海象运营商”。该结构的正式名称是“赋值表达式”(按照PEP的标题)，但是它们也可以被称为“命名表达式”(例如，CPython参考实现在内部使用该名称)。</p></blockquote><p id="fdf3" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">赋值表达式提供的主要好处是代码更简洁，减少了在求值前将表达式的结果赋给变量时对额外代码行的需求。</p><p id="cbe6" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">在较高的层次上，赋值表达式的工作方式是计算<code class="du kr ks kt ku b">:=</code> (walrus)操作符右边的表达式，并将其赋给操作符左边的变量。这提供了在一个简单的表达式中评估表达式的布尔结果并从中赋值以便重用的能力。</p><p id="7307" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">例如，在下面的例子中，<code class="du kr ks kt ku b">my_dict.get("name")</code>检查<code class="du kr ks kt ku b">my_dict</code>是否存在关键字为<code class="du kr ks kt ku b">name</code>的值。字典中没有该键的值，所以使用walrus操作符返回<code class="du kr ks kt ku b">None</code>并将其分配给<code class="du kr ks kt ku b">val</code>。在条件语句的上下文中，<code class="du kr ks kt ku b">val</code>随后被评估并相应地执行，并且可能在其范围内被重用。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">这是一个非常简单的例子，用来说明赋值表达式背后的基本原理。</figcaption></figure><h2 id="a6f8" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">争论</h2><p id="3e1d" class="pw-post-body-paragraph jv jw hi jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hb bi translated">正如许多人可能已经意识到的那样，提出这种新语言特性的PEP 572在Python核心开发者和整个社区中引起了很大的争议。</p><p id="8f12" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">这最终导致了Python的创造者<a class="ae kq" href="https://en.wikipedia.org/wiki/Guido_van_Rossum" rel="noopener ugc nofollow" target="_blank">吉多·范·罗苏姆</a>和长期以来的BDFL <em class="ky">(“仁慈的终身独裁者”)</em>离开BDFL的角色，正如他在2018年7月12日的Python邮件列表中标题为<a class="ae kq" href="https://www.mail-archive.com/python-committers@python.org/msg05628.html" rel="noopener ugc nofollow" target="_blank">权力转移</a>的消息所概述的那样。</p><h2 id="f289" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">语法和有效用法</h2><p id="ab46" class="pw-post-body-paragraph jv jw hi jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hb bi translated">如人教版572所述…</p><blockquote class="kv kw kx"><p id="a262" class="jv jw ky jx b jy kz ka kb kc la ke kf lb lc kh ki ld le kk kl lf lg kn ko kp hb bi translated">在大多数可以使用任意Python表达式的上下文中，可能会出现一个名为表达式的<strong class="jx hj">。它的形式是NAME := expr，其中expr是除未区分元组之外的任何有效的Python表达式，NAME是一个标识符。</strong></p></blockquote><p id="3278" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">本质上，这意味着在实现赋值表达式之前，可以在合法Python表达式可以使用的任何地方使用赋值表达式(<em class="ky">几乎是</em>),只有少数例外。</p><p id="efaa" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">赋值表达式合法的情况只是为了避免Python中赋值的两种不同语法之间的歧义。这里的目的是不要混淆给定场景的正确语法。</p><p id="3f59" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">不允许使用下面的赋值表达式(有充分的理由)。</p><ul class=""><li id="53c6" class="ls lt hi jx b jy kz kc la ji lu jm lv jq lw kp lx ly lz ma bi translated">在表达式语句的顶层。</li><li id="7c7f" class="ls lt hi jx b jy mb kc mc ji md jm me jq mf kp lx ly lz ma bi translated">位于表达式语句右侧的顶层。</li><li id="e847" class="ls lt hi jx b jy mb kc mc ji md jm me jq mf kp lx ly lz ma bi translated">作为函数调用中关键字参数的值。</li><li id="694d" class="ls lt hi jx b jy mb kc mc ji md jm me jq mf kp lx ly lz ma bi translated">作为函数定义中的顶级默认值。</li><li id="c792" class="ls lt hi jx b jy mb kc mc ji md jm me jq mf kp lx ly lz ma bi translated">作为函数参数、返回值或变量赋值的注释。</li><li id="e828" class="ls lt hi jx b jy mb kc mc ji md jm me jq mf kp lx ly lz ma bi translated">lambda函数中的非参数化表达式。</li></ul><p id="b26c" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">不过，通过将赋值表达式放在括号中(通常不允许使用),可以解决这些限制。然而，这可能是个坏主意。Python核心开发团队出于良好的理由设置了这些限制，以避免模糊和复杂的代码。从下面的例子中可以看出，这些不允许的使用并没有增加可读性，而且在很多情况下使代码很难理解。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><blockquote class="kv kw kx"><p id="8ac2" class="jv jw ky jx b jy kz ka kb kc la ke kf lb lc kh ki ld le kk kl lf lg kn ko kp hb bi translated"><em class="hi">注:这些例子是从PEP572 </em>的 <a class="ae kq" href="https://www.python.org/dev/peps/pep-0572/#exceptional-cases" rel="noopener ugc nofollow" target="_blank"> <em class="hi">异常情况</em> </a> <em class="hi">部分复制的</em></p></blockquote><p id="ffa8" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">另一个值得注意的规则是，f字符串上下文中的赋值表达式需要用括号括起来。</p><p id="0b9e" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated"><code class="du kr ks kt ku b">f"Hello, {(name := get_name())}!. Hello, again {name}!"</code></p><h2 id="eb61" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">表达式目标的范围</h2><p id="a5b8" class="pw-post-body-paragraph jv jw hi jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hb bi translated">在Python中添加赋值表达式并没有增加任何关于赋值表达式目标变量范围的新行为。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="56f4" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">这是有益的，使赋值表达式容易掌握，即使对于新开发人员也是如此，因为它符合Python的现有行为。</p><h2 id="168f" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">性能考虑因素</h2><p id="85e4" class="pw-post-body-paragraph jv jw hi jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hb bi translated">在很大程度上，当使用赋值表达式时，性能没有差别。通过移除值的重复计算，使用赋值表达式可以提高性能。</p><p id="015c" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">一个例子是当计算值以在列表理解中执行过滤时。</p><p id="1dbf" class="pw-post-body-paragraph jv jw hi jx b jy kz ka kb kc la ke kf ji lc kh ki jm le kk kl jq lg kn ko kp hb bi translated">例如，计算一系列数字的2的幂，然后在结果值列表中只过滤整数。通过使用列表理解中的赋值表达式来存储<code class="du kr ks kt ku b">pow(x, 2)</code>的计算值。在下面的例子中，运行时间提高了近20%(206毫秒)。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h2 id="42e1" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">结论</h2><p id="b27f" class="pw-post-body-paragraph jv jw hi jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hb bi translated">赋值表达式和walrus操作符是Python的一个有价值的、令人耳目一新的补充。<br/><br/>Python核心开发团队在提供一个简单易学的特性方面给予的关注。提供一个简单易用的带有少量新语法的操作符是非常好的。如果赋值表达式以实用的方式使用，它们将提高代码的可读性和简洁性。在某些情况下，通过减少重新计算值的需要，也可以提高性能。唯一需要注意的是，作为一个新的语言特性，许多开发者可能会对它的语法和行为感到陌生。在这种情况下，对于这些用户来说，代码的可读性可能会降低。</p></div></div>    
</body>
</html>