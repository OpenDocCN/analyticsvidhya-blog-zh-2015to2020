<html>
<head>
<title>Redis Data Compression — Byte manipulation for Hex strings in Lua</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis数据压缩Lua中十六进制字符串的字节操作</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/redis-data-compression-manipulating-hex-codes-in-lua-37c40283b478?source=collection_archive---------12-----------------------#2020-04-04">https://medium.com/analytics-vidhya/redis-data-compression-manipulating-hex-codes-in-lua-37c40283b478?source=collection_archive---------12-----------------------#2020-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/38e90127106fbe714c3d79120ec5defe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDXHTwcZvu8WWidYpSGLGw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自:<a class="ae iu" href="https://promotion.aliyun.com/ntms/act/redisluaedu.html" rel="noopener ugc nofollow" target="_blank">https://promotion.aliyun.com/ntms/act/redisluaedu.html</a></figcaption></figure><p id="c041" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总有一天，你必须找到一种新的数据压缩方式，并让它与现有的结构一起工作。当您在存储在<a class="ae iu" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="jt"> Redis </em> </strong> </a>存储中的实时计数器上处理大规模查询时，任务变得更具挑战性。</p><p id="a2a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章提供了—</p><ol class=""><li id="8842" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated">一种将Redis键从<a class="ae iu" href="https://redis.io/topics/data-types#lists" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="jt">列表</em> </strong> </a>数据类型转换为<a class="ae iu" href="https://redis.io/topics/data-types#hashes" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="jt">散列</em> </strong> </a>的思路</li><li id="b040" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">使用Lua以十六进制表示整数值的有效字符串操作。</li><li id="07b1" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">在redis-cli中使用Lua调试器的简单步骤。</li><li id="e746" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">使用<a class="ae iu" href="https://redis.io/topics/benchmarks" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="jt">redis-benchmark</em></strong></a>进行绩效评估。</li></ol><p id="4fc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong> : <em class="jt">假设读者熟悉Lua脚本，我们可以如何使用</em><a class="ae iu" href="https://redis.io/commands/eval" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="jt">【EVAL】</em></strong></a><strong class="ix hj"><em class="jt"/></strong><em class="jt">redis的功能来使用Lua脚本。</em></p><h2 id="1a76" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated"><strong class="ak">支持用例— </strong></h2><ol class=""><li id="00db" class="ju jv hi ix b iy ld jc le jg lf jk lg jo lh js jz ka kb kc bi translated">减小密钥大小/空间</li><li id="d559" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">该键应存储每日计数器(整数值)。</li><li id="1285" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">这些操作将增加/减少特定日期/索引的计数器。</li></ol><h2 id="4858" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">接近—</h2><ol class=""><li id="036d" class="ju jv hi ix b iy ld jc le jg lf jk lg jo lh js jz ka kb kc bi translated"><strong class="ix hj">用于压缩的数据类型转换</strong></li></ol><p id="c7d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了减少Redis中的密钥空间和压缩数据，假设我们决定使用散列，但是我们不能以串联字符串的形式直接存储每天的整数值，我们想到了两种方法——</p><ul class=""><li id="44a9" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js li ka kb kc bi translated"><strong class="ix hj"> <em class="jt">我们使用了一个分隔符</em> </strong>(例如:分号、与号等。):Lua中字符串操作的困难和对不一致性的担心使它不是一个真正健壮的解决方案。</li><li id="6434" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js li ka kb kc bi translated"><strong class="ix hj"> <em class="jt">将整数编码为十六进制值，其中两个字节由4个字符表示</em> </strong>:以列表的形式存储每天的计数器，这样可以灵活地将其存储在哈希键中。但是这变得具有挑战性，因为我们不再能够像使用<em class="jt"> lindex </em>列表操作那样灵活地使用<a class="ae iu" href="https://redis.io/commands#list" rel="noopener ugc nofollow" target="_blank"> <em class="jt">列表操作</em> </a> <em class="jt"> </em>来跳转到特定的日期进行查找。</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="b955" class="ki kj hi lo b fi ls lt l lu lv">127.0.0.1:6379&gt; TYPE oldkey<br/>list<br/>127.0.0.1:6379&gt; LRANGE oldkey 0 -1<br/>1) “280”<br/>2) “150”<br/>3) “250”<br/>4) “560”</span><span id="4399" class="ki kj hi lo b fi lw lt l lu lv">127.0.0.1:6379&gt; type newkey<br/>hash<br/>127.0.0.1:6379&gt; HGETALL newkey<br/>1) "counts"<br/>2) "0118009600fa0230"</span></pre><p id="6ff8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“0118009600fa0230”代表—</p><ol class=""><li id="8f46" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated">0x0118 = 280</li><li id="e15a" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">0x0096 = 150</li><li id="5eba" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">0x00fa = 250</li><li id="022b" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">0x0230 = 560</li></ol><p id="af28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<strong class="ix hj">读取和操作Lua中特定索引的计数器</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="dcd4" class="ki kj hi lo b fi ls lt l lu lv">-- keys <br/>--  1 = rediskey<br/>-- args<br/>--  1 = dayindex<br/>--  2 = delta<br/>redis.replicate_commands()<br/>local getData = function(str, index)<br/>    local count = str:sub(index*4 -3, index*4)<br/>    return tonumber("0x"..count)<br/>end<br/>local setData = function(str, index, data)<br/>    local str1, str2<br/>   <br/>    if index == 1 then<br/>        str1 = ""<br/>    else<br/>        str1 = str:sub(1, index*4 - 4)<br/>    end<br/>    if index*4 == string.len(str) then<br/>        str2 = ""<br/>    else<br/>        str2 = str:sub(index*4 + 1, string.len(str))<br/>    end<br/>local newcount = string.format('%04X', tonumber(data))<br/>    return str1 .. newcount .. str2<br/>end<br/>local dayindex = ARGV[1]<br/>local delta = ARGV[2]<br/>local strval = redis.call('hget', KEYS[1], "counts")<br/>local count = getData(strval, dayindex)<br/>strval = setData(strval, dayindex, count - delta)<br/>redis.call('hset', KEYS[1], strval)</span></pre><p id="894f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。使用Lua调试器— </strong></p><ul class=""><li id="3a1e" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js li ka kb kc bi translated"><strong class="ix hj">$ redis-CLI-p 6379-LD b-eval basichex . Lua new key，2 5 </strong></li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="705f" class="ki kj hi lo b fi ls lt l lu lv">Lua debugging session started, please use:<br/>quit    -- End the session.<br/>restart -- Restart the script in debug mode again.<br/>help    -- Show Lua script debugging commands.</span><span id="c571" class="ki kj hi lo b fi lw lt l lu lv">* Stopped at 7, stop reason = step over<br/>-&gt; 7   redis.replicate_commands()<br/>lua debugger&gt; b 35 36 38<br/>   34  <br/>  #35  local count = getData(strval, dayindex)<br/>   36  strval = setData(strval, dayindex, count - delta)<br/>  #35  local count = getData(strval, dayindex)<br/>  #36  strval = setData(strval, dayindex, count - delta)<br/>   37  <br/>   37  <br/>  #38  redis.call('hset', KEYS[1], strval)<br/>lua debugger&gt; c<br/>* Stopped at 35, stop reason = break point<br/>-&gt;#35  local count = getData(strval, dayindex)<br/>lua debugger&gt; p<br/>&lt;value&gt; getData = "function@0x7fbd51869350"<br/>&lt;value&gt; setData = "function@0x7fbd51869380"<br/>&lt;value&gt; dayindex = "2"<br/>&lt;value&gt; delta = "5"<br/>&lt;value&gt; <strong class="lo hj">strval = "0118009600fa0230"</strong><br/>lua debugger&gt; c<br/>* Stopped at 36, stop reason = break point<br/>-&gt;#36  strval = setData(strval, dayindex, count - delta)<br/>lua debugger&gt; p<br/>&lt;value&gt; getData = "function@0x7fbd51869350"<br/>&lt;value&gt; setData = "function@0x7fbd51869380"<br/>&lt;value&gt; dayindex = "2"<br/>&lt;value&gt; delta = "5"<br/>&lt;value&gt; strval = "0118009600fa0230"<br/>&lt;value&gt; <strong class="lo hj">count = 150</strong><br/>lua debugger&gt; c<br/>* Stopped at 38, stop reason = break point<br/>-&gt;#38  redis.call('hset', KEYS[1], strval)<br/>lua debugger&gt; p<br/>&lt;value&gt; getData = "function@0x7fbd51869350"<br/>&lt;value&gt; setData = "function@0x7fbd51869380"<br/>&lt;value&gt; dayindex = "2"<br/>&lt;value&gt; delta = "5"<br/>&lt;value&gt; <strong class="lo hj">strval = "0118009100fa0230"</strong><br/>&lt;value&gt; count = 150<br/>lua debugger&gt;</span></pre><p id="aec3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。Redis基准— </strong></p><ul class=""><li id="ca2a" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js li ka kb kc bi translated">首先，我们计算将在EVAL使用的脚本的SHA散列</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ee42" class="ki kj hi lo b fi ls lt l lu lv">SHA1=`redis-cli SCRIPT LOAD "$(cat oldscript.lua)"`<br/>SHA2=`redis-cli SCRIPT LOAD "$(cat basichex.lua)"`</span></pre><ul class=""><li id="504d" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js li ka kb kc bi translated"><strong class="ix hj">旧剧本— </strong></li></ul><p id="f686" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">$ redis-benchmark-n 10000-e eval sha $ SHA1 1 old key 2 5</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="745f" class="ki kj hi lo b fi ls lt l lu lv"><strong class="lo hj">=</strong>===== EVALSHA 6ec917c7503059c00a94e6187eef67176f701458 1 oldkey 2 5 ======<br/>10000 requests completed in 7.89 seconds<br/>50 parallel clients<br/>3 bytes payload<br/>keep alive: 1<br/>0.01% &lt;= 36 milliseconds<br/>7.09% &lt;= 37 milliseconds<br/>41.06% &lt;= 38 milliseconds<br/>64.60% &lt;= 39 milliseconds<br/>77.40% &lt;= 40 milliseconds<br/>85.24% &lt;= 41 milliseconds<br/>91.63% &lt;= 42 milliseconds<br/>95.33% &lt;= 43 milliseconds<br/>97.52% &lt;= 44 milliseconds<br/>98.67% &lt;= 45 milliseconds<br/>99.36% &lt;= 46 milliseconds<br/>99.51% &lt;= 47 milliseconds<br/>99.61% &lt;= 49 milliseconds<br/>99.63% &lt;= 51 milliseconds<br/>99.70% &lt;= 52 milliseconds<br/>99.77% &lt;= 53 milliseconds<br/>99.85% &lt;= 54 milliseconds<br/>99.96% &lt;= 278 milliseconds<br/>99.98% &lt;= 279 milliseconds<br/>99.99% &lt;= 280 milliseconds<br/>100.00% &lt;= 280 milliseconds<br/>1267.43 requests per second</span></pre><ul class=""><li id="b617" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js li ka kb kc bi translated"><strong class="ix hj">新脚本— </strong></li></ul><p id="ec57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">$ redis-benchmark-n 10000-e eval sha $ SHA1 1 new key 2 5</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="44d0" class="ki kj hi lo b fi ls lt l lu lv">====== EVALSHA 1dbad2cd256a4266ab7d680ae8059906ae40e8e5 1 newkey 2 5 ======<br/>10000 requests completed in 4.35 seconds<br/>50 parallel clients<br/>3 bytes payload<br/>keep alive: 1<br/>0.01% &lt;= 18 milliseconds<br/>1.69% &lt;= 19 milliseconds<br/>20.06% &lt;= 20 milliseconds<br/>48.56% &lt;= 21 milliseconds<br/>68.25% &lt;= 22 milliseconds<br/>81.39% &lt;= 23 milliseconds<br/>89.75% &lt;= 24 milliseconds<br/>95.01% &lt;= 25 milliseconds<br/>96.75% &lt;= 26 milliseconds<br/>97.90% &lt;= 27 milliseconds<br/>98.63% &lt;= 28 milliseconds<br/>99.25% &lt;= 29 milliseconds<br/>99.50% &lt;= 30 milliseconds<br/>99.63% &lt;= 31 milliseconds<br/>99.68% &lt;= 32 milliseconds<br/>99.84% &lt;= 33 milliseconds<br/>99.86% &lt;= 34 milliseconds<br/>99.88% &lt;= 35 milliseconds<br/>100.00% &lt;= 35 milliseconds<br/>2297.79 requests per second</span></pre><p id="4dc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几乎2倍的性能提升:)</p><h2 id="ff0d" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">资源—</h2><ol class=""><li id="f0f6" class="ju jv hi ix b iy ld jc le jg lf jk lg jo lh js jz ka kb kc bi translated"><a class="ae iu" href="https://redis.io/topics/ldb" rel="noopener ugc nofollow" target="_blank"> Lua调试器</a></li><li id="d098" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><a class="ae iu" href="https://www.digitalocean.com/community/tutorials/how-to-perform-redis-benchmark-tests" rel="noopener ugc nofollow" target="_blank"> Redis基准</a></li></ol></div></div>    
</body>
</html>