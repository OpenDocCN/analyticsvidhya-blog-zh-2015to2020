<html>
<head>
<title>Stratify k-fold splits equally and correctly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将k-fold分割成相等且正确的层</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stratify-kfold-splits-equally-and-correctly-f2f80487bb7e?source=collection_archive---------9-----------------------#2020-03-01">https://medium.com/analytics-vidhya/stratify-kfold-splits-equally-and-correctly-f2f80487bb7e?source=collection_archive---------9-----------------------#2020-03-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/64d97ff1c9f7aac2c08f91e08e894c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*a9XoTDlOyi4eqkuQwXiaIw.png"/></div></figure><p id="912f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文的目的是修复有时不正确的训练/有效分割的分层，以便多类分类模型可以被正确评估。</p><p id="40a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Sklearn具有强大的内置功能，可以执行单一分层分割</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="3a88" class="jt ju hi jp b fi jv jw l jx jy">from sklearn.model_selection import train_test_split as split</span><span id="792d" class="jt ju hi jp b fi jz jw l jx jy">train, valid = split(df, test_size = 0.3, stratify=df[‘target’])</span></pre><p id="b108" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将产生两个分割，其中训练将是df的70%,验证集将是30%,并且在两个分割中“目标”变量的分布几乎相同</p><p id="9899" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果需要对一些函数或模型的结果进行多次分割评估，可以使用分层文件夹</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="dfd9" class="jt ju hi jp b fi jv jw l jx jy">from sklearn.model_selection import StratifiedKFold</span><span id="67a7" class="jt ju hi jp b fi jz jw l jx jy">kfold = StratifiedKFold()</span><span id="7c31" class="jt ju hi jp b fi jz jw l jx jy">for train, valid in kfold.split(df.drop(‘target’, axis=1), df.target):<br/>    X_train = df.drop(‘target’, axis=1).iloc[train]<br/>    y_train = df.[‘target’].iloc[train]<br/>    X_val = df.drop(‘target’, axis=1).iloc[valid]<br/>    y_val = df[‘target’].iloc[val]</span><span id="230e" class="jt ju hi jp b fi jz jw l jx jy"># train/predict or do what you need to do</span></pre><p id="3cf8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，具有高度不平衡的多类“目标”变量的数据集在训练和验证分裂中并不总是具有相同的“目标”类变量。在这种情况下(如果您试图训练和评估一个模型)，当您试图评估由不同类别变量表示的预测和y_train之间的准确性时，您将遇到50%的错误</p><figure class="jk jl jm jn fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/ef00ae10af8fade4710318c75b55f338.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*CZLeCa298Vn6Po48zI-ZkA.gif"/></div></figure><p id="28f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我想到的解决方案是，如果目标变量的唯一类在训练之间不同，并且在任何拆分中都有效，那么就裁剪训练或验证索引</p><p id="8c8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将把它包装成一个单独的函数，并在拆分的迭代中调用它</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0acb" class="jt ju hi jp b fi jv jw l jx jy">def clip_splits(train,val):<br/> ‘’’<br/>Fixes the stratification problem of StratifiedKfold<br/>Finds outstanding target values in train, valid splits and removes indexes of those train and valid splits from consideration for further correct definition of X_train,X_val,y_train,y_val<br/>‘’’<br/>    tr_target_unique=temp.iloc[train].target.unique()<br/>    val_target_unique=temp.iloc[val].target.unique()<br/> <br/>    if len(tr_target_unique) &gt; len(val_target_unique):<br/>        outstanding_target_class = list(set(tr_target_unique)- <br/>                                   set(val_target_unique))<br/>        ix_to_remove_from_train = []<br/>    <br/>        for i in outstanding_target_class:<br/>            ix_to_remove_from_train.extend(   <br/>            temp.iloc[train].reset_index(<br/>            drop=True).index[temp.target.iloc[train] == i].tolist())</span><span id="1897" class="jt ju hi jp b fi jz jw l jx jy">        train = list(train)<br/> <br/>        for index in sorted(ix_to_remove_from_train, reverse=True):<br/>            del train[index] <br/> <br/>    elif len(tr_target_unique) &lt; len(val_target_unique):<br/> <br/>        outstanding_target_class = list(set(val_target_unique)-  <br/>                                   set(tr_target_unique))<br/>        ix_to_remove_from_val = []<br/> <br/>        for i in outstanding_target_class:<br/>            ix_to_remove_from_val.extend(<br/>            temp.iloc[val].reset_index(<br/>              drop=True).index[temp.target.iloc[val] == i].tolist())<br/>        val = list(val)</span><span id="2ef3" class="jt ju hi jp b fi jz jw l jx jy">        for index in sorted(ix_to_remove_from_val, reverse=True):<br/>            del val[index]</span><span id="925d" class="jt ju hi jp b fi jz jw l jx jy">    return train, val</span></pre><p id="a064" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，只需将对此函数的调用插入到折叠迭代管道中，如下所示</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="09b7" class="jt ju hi jp b fi jv jw l jx jy">from sklearn.model_selection import StratifiedKFold</span><span id="f44c" class="jt ju hi jp b fi jz jw l jx jy">kfold = StratifiedKFold()</span><span id="a3d5" class="jt ju hi jp b fi jz jw l jx jy">for train, valid in kfold.split(df.drop(‘target’, axis=1), df.target):</span><span id="3b38" class="jt ju hi jp b fi jz jw l jx jy">    # fix the stratification problem<br/>    train,valid = clip_splits(train,valid)</span><span id="bb06" class="jt ju hi jp b fi jz jw l jx jy">    X_train = df.drop(‘target’, axis=1).iloc[train]<br/>    y_train = df.[‘target’].iloc[train]<br/>    X_val = df.drop(‘target’, axis=1).iloc[valid]<br/>    y_val = df[‘target’].iloc[val]</span><span id="6f0e" class="jt ju hi jp b fi jz jw l jx jy"># train/predict or do what you need to do</span></pre><p id="16a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样，在您的培训和验证拆分中，您将得到完全相同的唯一“目标”值变化。</p></div></div>    
</body>
</html>