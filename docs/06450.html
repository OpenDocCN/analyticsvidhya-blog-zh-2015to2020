<html>
<head>
<title>Model Interpretation with Microsoft’s Interpret ML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用微软的解释器ML进行模型解释</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/model-interpretation-with-microsofts-interpret-ml-85aa0ad697ae?source=collection_archive---------5-----------------------#2020-05-23">https://medium.com/analytics-vidhya/model-interpretation-with-microsofts-interpret-ml-85aa0ad697ae?source=collection_archive---------5-----------------------#2020-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cad108169f2c7f85875bde0fc1fc9984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KKI6c-1lwiQ8pEIR"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Mauro Sbicego 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="829a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">机器学习模型的预测能力和它的可解释性长期以来被认为是对立的。但现在不是了！在过去的两三年里，研究人员、行业以及更广泛的数据科学界重新对机器学习产生了兴趣，让它变得更加透明，甚至让它成为“白盒”..我已经写了一系列关于模型解释的文章— <a class="ae iu" rel="noopener" href="/analytics-vidhya/why-should-i-trust-your-model-bdda6be94c6f"> ELI5 &amp;排列重要性</a>&amp;T6】时间解释了模型解释需要用到的&amp;技术。在这篇文章中，我将讨论微软的新软件包</p><h1 id="3565" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="f27f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://github.com/interpretml/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> Interpret ML </strong> </a>是一个开源包，在一个屋檐下集成了最先进的机器学习可解释性技术。有了这个包，你可以训练可解释的玻璃盒子模型和解释黑盒系统。它是以解释为重点的工具和软件包的集合，包含了许多关键的可解释技术。<a class="ae iu" href="https://github.com/interpretml/interpret-text" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">解释-文本</strong> </a> <strong class="ix hj"> </strong>支持一组针对文本数据训练的模型的可解释性技术。<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-machine-learning-interpretability" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">Azureml-Interpret</strong></a><strong class="ix hj"/>提供了一个azure ml包装器，用于在azure上运行所有的解释技术。</p><h1 id="a410" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可解释性方法</h1><p id="43b3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在《解释》中，可解释性算法分为两个主要部分——玻璃盒子模型和黑盒解释。</p><h2 id="7922" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">玻璃盒子模型</h2><p id="97af" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">玻璃盒模型是指设计成可解释的学习算法，即线性模型、决策树。Glassbox模型通常提供精确的可解释性，也就是说，您可以跟踪和推理任何Glassbox如何做出决策。除了常规的scikit学习模型，Glassbox还包含一个新的模型，叫做可解释的增强机器(EBM)</p><h2 id="12f8" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">可解释增压机(EBM)</h2><p id="4a43" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">EBM是微软研究院开发的一个可解释的模型。它使用现代机器学习技术，如装袋、梯度增强和自动交互检测以及GAMs(广义加法模型)。这使得EBMs与随机森林和梯度增强树等最先进的技术一样准确。然而，与这些黑盒模型不同，EBM产生可解释的解释。</p><p id="784f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">概念</strong></p><p id="1aad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">线性模型是高度可解释，但是通常不提供复杂模型所提供的高精确度。</p><blockquote class="lk ll lm"><p id="bc73" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">Y = B1X1 + B2X2+ ……。+ BnXn + ϵ.(1，2，n都是下标)</p></blockquote><p id="597b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，统计学家创建了gam(广义可加模型),它保持了可加结构(线性模型的互概率),但使它们更加灵活和准确。</p><blockquote class="lk ll lm"><p id="1a46" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">Y= f1(X1) + f2(X2)+f3(X3)…。fn(Xn)。(1，2，n都是下标)</p></blockquote><p id="d1fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">微软的研究人员用Boosting &amp; Bagging等技术进一步增强了GAM。EBM继续像线性模型一样可解释，同时它在复杂模型(如XgBoost等)的水平上提供准确性。</p><blockquote class="lk ll lm"><p id="b11b" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">Y=∑i fi(Xi)+∑ij fij( Xi，Xj)。(I、j均为下标)</p></blockquote><p id="c509" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，EBM以如下方式工作。假设数据集有“n”个特征。EBM将只基于特征1创建一棵树&amp;使用boosting算法将残差传递给下一棵树。现在训练一棵可以看特征2，传递残差的小树。这将持续到特征N。对于每个特征的树建模和传递残差的这种迭代可以进行例如5000次。在每个特性的迭代结束时，每个特性上训练了5000棵树。通过这种方式，它可以为每个特征找到最佳特征函数<em class="ln"> f() </em>，并显示每个特征如何有助于模型对问题的预测。所有这些模型都是并行训练的，因为我们一直在模型中循环。</p><h2 id="5c81" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated"><strong class="ak">实现</strong> ( <strong class="ak">预测&amp;解释</strong>)</h2><p id="b572" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我在Github笔记本中提供了EBM分类器的详细实现。我将使用银行营销数据集— <a class="ae iu" href="https://archive.ics.uci.edu/ml/datasets/bank+marketing" rel="noopener ugc nofollow" target="_blank"> LINK </a>。该数据与一家葡萄牙银行机构的直接营销活动相关。我们需要预测产品(银行定期存款)在此次活动中是否会被客户认购(“是”)。我们从安装InterpretML库开始</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="eb5e" class="kw ju hi lw b fi ma mb l mc md">pip install interpret</span></pre><p id="712b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在对数据进行预处理(在笔记本中描述)之后，我们将首先使用有用的<code class="du me mf mg lw b">ClassHistogram()</code>来理解数据，这使得在数据集上做EDA成为可能。为了使用它，数据集不应该有丢失的值，所以要确保预先执行预处理</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="b605" class="kw ju hi lw b fi ma mb l mc md">from interpret import show<br/>from interpret.data import ClassHistogram</span><span id="5bd8" class="kw ju hi lw b fi mh mb l mc md">hist = ClassHistogram().explain_data(X_train, y_train, name = 'Train Data')</span><span id="748c" class="kw ju hi lw b fi mh mb l mc md">show(hist)</span></pre><p id="a6d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建一个带有Plotly直方图的仪表板，其中颜色表示客户是否订购(1)产品。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/eef7b2c1dc01fd54213630428ff5121c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1z6WJt0aOB6fWPRW3lnxYA.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">所有维度的培训数据汇总</figcaption></figure><p id="45e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们试试循证医学。我们将根据训练数据进行拟合</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="8765" class="kw ju hi lw b fi ma mb l mc md">from interpret.glassbox import ExplainableBoostingClassifier<br/>ebm = ExplainableBoostingClassifier(random_state=42)<br/>ebm.fit(X_train, y_train)</span></pre><p id="a734" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拟合后，用循证医学检查G <strong class="ix hj">叶解释</strong>的时间到了</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="d302" class="kw ju hi lw b fi ma mb l mc md">ebm_global = ebm.explain_global(name='EBM')<br/>show(ebm_global)</span></pre><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/9b82719e8a63b73ea1f7808b304040c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KcDadFN4wWZf63qw0THcrw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">基于循证医学的全球解释</figcaption></figure><p id="54ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">特征重要性总结表明，两个分类特征<code class="du me mf mg lw b">contact_celluar</code>和<code class="du me mf mg lw b">contact_telephone</code>是非常重要的特征。人们也可以研究个人特征，以了解其影响，例如:年龄特征表明，该活动在老年人(60岁以上)中更为成功。</p><p id="64a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">EBM也可以用于<strong class="ix hj">局部讲解</strong>。在下面的代码片段中，我们将看到对前4条记录的解释。我们可以注意到，对于记录3，预测值是0.085，而实际值是0。尽管6月份的贡献是积极的，但不打手机和打电话似乎对结果有负面影响。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="45db" class="kw ju hi lw b fi ma mb l mc md">ebm_local = ebm.explain_local(X_test[:4], y_test[:4], name='EBM')<br/>show(ebm_local)</span></pre><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/2f575fe9bd249940385f9f6335d29479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HSJLGZ6G07zPBETX6cTEHg.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">EBM本地解释</figcaption></figure><p id="59c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用EBM预测</strong></p><p id="593a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将用ROC曲线来说明循证医学的预测质量。下面的代码可以用来绘制ROC曲线</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="5c98" class="kw ju hi lw b fi ma mb l mc md">from interpret.perf import ROC</span><span id="c6a0" class="kw ju hi lw b fi mh mb l mc md">ebm_perf = ROC(ebm.predict_proba).explain_perf(X_test, y_test, name=’EBM’)<br/>show(ebm_perf)</span></pre><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/306af6b1ac75337ade34df23eb9db37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*my8VtF0ZytTfSJnALa-41A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">循证医学的ROC曲线</figcaption></figure><p id="978a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用逻辑回归、分类树和轻型GBM来比较循证医学的预测质量。EBM的准确度(AUC = 0.77)非常接近于轻型GBM (AUC = 0.78)。结果如下</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="fa0b" class="kw ju hi lw b fi ma mb l mc md">lr_perf = ROC(lr_model.predict_proba).explain_perf(X_test, y_test, name=’Logistic Regression’)<br/>tree_perf = ROC(rf_model.predict_proba).explain_perf(X_test, y_test, name=’Classification Tree’)<br/>lgbm_perf = ROC(lgb_model.predict_proba).explain_perf(X_test, y_test, name=’Light GBM’)<br/>ebm_perf = ROC(ebm.predict_proba).explain_perf(X_test, y_test, name=’EBM’)</span><span id="a45f" class="kw ju hi lw b fi mh mb l mc md">show(lr_perf)<br/>show(tree_perf)<br/>show(ebm_perf)<br/>show(lgbm_perf)</span></pre><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/afc6dd5735bc748e274306a4a99ebe22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NvWkcW6mLoY5StYO1V73zQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">循证医学与其他模型的比较</figcaption></figure><p id="b99c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">仪表板</strong></p><p id="eb39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Dashboard是Interpret ML的一个很棒的特性，它允许你在一个视图中看到所有的结果。可用的解释被分成选项卡，每个选项卡涵盖管道的一个方面。</p><ul class=""><li id="fd03" class="mk ml hi ix b iy iz jc jd jg mm jk mn jo mo js mp mq mr ms bi translated"><strong class="ix hj">数据</strong>涵盖探索性数据分析，主要为特性级设计。</li><li id="547b" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated"><strong class="ix hj">绩效</strong>涵盖整体和用户定义组的模型绩效。</li><li id="af9d" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated"><strong class="ix hj">全局</strong>全面解释模型决策。</li><li id="61f7" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated"><strong class="ix hj">局部</strong>解释每个实例/观察的模型决策</li></ul><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="c4fc" class="kw ju hi lw b fi ma mb l mc md">lr_global = lr_model.explain_global(name=’LR’)<br/>tree_global = rf_model.explain_global(name=’Tree’)</span><span id="5cdc" class="kw ju hi lw b fi mh mb l mc md">show([hist, lr_global, lr_perf, tree_global, tree_perf,ebm_global,ebm_local,ebm_perf], share_tables=True)</span></pre><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/f3cf1d8781c26df721ebcfbed4c5f321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fKeHlvEGXhyvMwE9VD-MZQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">仪表板概述</figcaption></figure><p id="9386" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据选项卡:提供概要视图和要素级别视图。深入了解数据</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/113d182b6ad1a4611d619121e3ef1b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IgysHhfSQgxuntYSmoORCw.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据汇总视图</figcaption></figure><p id="c818" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Performance选项卡:这可以用来查看正在使用的所有模型的准确性指标。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/0129fc122edab849c56916124964dbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*61jDC_SkVHlcAeREwk_ncQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">性能视图</figcaption></figure><p id="4d36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">全局选项卡:可用于在一个视图中查看所有用于预测的模型的全局解释。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/cbed502188163894f0cc043f5d4b636b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iFydkOkzmj56a7-viKIFXg.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">全局解释视图</figcaption></figure><p id="260b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">局部选项卡:可用于在一个视图中查看所有用于预测的模型的局部解释。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/fd37182ab76fb648cc537aca4bb454e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zH5k6HrRGkURl2iiKtkROQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">局部解释视图</figcaption></figure><h1 id="ba59" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="a98b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">微软的Interpret ML提供了一种最新的造型手法可解释增强机器(EBM) &amp;统一API下的最新可解释性算法。这个API提供了对用户来说内在可理解和可解释的玻璃盒模型&amp;黑盒模型使用解释技术，如莱姆、SHAP、部分相关图等，为任何机器学习生成解释，而不管其复杂性如何。仪表板提供了很好的交互式可视化和可解释性算法比较。现在r中也支持这个包了。</p><p id="a273" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在我的<a class="ae iu" href="https://github.com/mayur29/Machine-Learning-Model-Interpretation" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到代码。在下一篇文章中，我将介绍Interpret ML提供的黑盒模型功能。</p><p id="5964" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有任何关于模型解释的问题，让我知道乐意帮忙。如果你想收到我的博客更新，请在<a class="ae iu" rel="noopener" href="/@sand.mayur"> Medium </a>或<a class="ae iu" href="https://www.linkedin.com/in/mayursand/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我！</p></div></div>    
</body>
</html>