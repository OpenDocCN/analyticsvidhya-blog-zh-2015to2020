<html>
<head>
<title>Akka Streams in Java Spring Boot!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爪哇Spring Boot的阿卡河！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/akka-streams-in-java-spring-boot-f7749cafb7f5?source=collection_archive---------5-----------------------#2020-04-12">https://medium.com/analytics-vidhya/akka-streams-in-java-spring-boot-f7749cafb7f5?source=collection_archive---------5-----------------------#2020-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/71854b43d1352c435c32de12132db889.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*PZWmwJFrF3_hMnCciD7mOw.png"/></div></figure><p id="1dd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在当今的数据处理和数据流水线系统中，将数据从源流式传输到接收器是一项非常琐碎的任务。因此，有许多流媒体解决方案，如:Kafka Stream，Spark Streaming，Apache Flink等。</p><p id="b6ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它们都以某种方式需要建立一个基础设施来充分利用它们(例如，HDFS、Spark cluster、Kafka流设置等)。)或者我们需要在流作业之间进行某种编排(例如Apache Airflow)。</p><h1 id="0e7b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">阿卡溪流</h1><p id="8ac7" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Akka streams在这场战斗中脱颖而出，拥有完全由应用程序驱动的优势。Akka stream是建立在Akka著名的演员模型(实际上是受Erlang演员模型的启发)之上的。因此，Akka streams可以利用其经过战斗考验的<a class="ae kn" href="https://www.lightbend.com/blog/why-do-we-need-a-reactive-manifesto" rel="noopener ugc nofollow" target="_blank">弹性、事件驱动和响应</a>(参见<a class="ae kn" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">反应宣言</a>)能力。</p><p id="8fd5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">【Akka的问题</p><ol class=""><li id="6747" class="ko kp hi io b ip iq it iu ix kq jb kr jf ks jj kt ku kv kw bi translated">Java开发人员社区已经远离了“为scala量身打造的”Akka平台。</li><li id="287d" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">对最流行的Java框架“Spring”没有多少文档和支持。</li></ol><p id="588b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我是来告诉你另一件事的！尽管缺乏互联网上可用的资源，我们事实上可以用Java做akka-streams，而且做起来很容易。</p><p id="8f70" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本帖中，我们将用Java 和Spring Boot<strong class="io hj">构建一个Akka流应用程序<strong class="io hj">！</strong>我们将分析使用Akka流可以获得的现成优势。所以，让我们葛开始…</strong></p><h1 id="a4a6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题陈述</h1><p id="6490" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们需要一个简单的实时流，它消耗Kafka主题上发布的所有更新，并在解析后将事件保存在SQL server数据库中。我们只想在记录插入数据库后提交Kafka偏移量。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lc"><img src="../Images/85ecc21e6eac45b47694c96883056705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rGNbm-gnpZJA7sL7Pib2A.png"/></div></div></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="c00b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">让我们从Spring Initialzr开始一个新的Spring boot项目。</strong></p><div class="ls lt ez fb lu lv"><a href="https://start.spring.io/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">弹簧初始化r</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">Initializr生成的spring boot项目正好是你快速启动所需要的！</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">start.spring.io</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ik lv"/></div></div></a></div><p id="a08c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将使项目像下面的树一样组织起来，这是一个非常标准的maven目录结构(因为我们在这里选择了使用maven)。如果你愿意，你也可以和格雷迪一起去。</p><pre class="ld le lf lg fd mk ml mm mn aw mo bi"><span id="ea52" class="mp jl hi ml b fi mq mr l ms mt">.<br/>├── pom.xml<br/>└── src<br/>    ├── main<br/>    │   ├── java<br/>    │   │   └── com<br/>    │   │       └── lprakashv<br/>    │   │           └── springalpakka<br/>    │   │               ├── SpringCommandLineApplication.java<br/>    │   │               ├── configs<br/>    │   │               │   ├── AkkaConfig.java<br/>    │   │               │   └── StreamConfig.java<br/>    │   │               ├── dtos<br/>    │   │               │   └── Event.java<br/>    │   │               ├── services<br/>    │   │               │   └── StreamService.java<br/>    │   │               └── utils<br/>    │   │                   └── StreamUtils.java<br/>    │   └── resources<br/>    │       ├── application.yml<br/>    │       └── stream.conf<br/>    └── test<br/>        └── java<br/>            └── com<br/>                └── lprakashv<br/>                    └── springalpakka</span></pre><p id="7865" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不要担心树中的代码文件，我们很快就会谈到它们。</p><p id="9eba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">添加所有必需的依赖项:</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mu"><img src="../Images/4e4b0d759766d7c715774164c266ad0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMSapi8oZTX_e650DxiO5A.png"/></div></div></figure><p id="d19d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">设置基础Akka配置</strong></p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="12da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在每个Akka/Akka-Stream应用程序中，需要的最基本组件是Akka的<strong class="io hj"> ActorSystem </strong>和<strong class="io hj"> Materializer </strong>。这是这个生态系统中很多事情所需要的，比如，产生演员，创建流组件，运行流，物化流等等。</p><p id="89fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的代码中，我们确保:</p><ol class=""><li id="c596" class="ko kp hi io b ip iq it iu ix kq jb kr jf ks jj kt ku kv kw bi translated">在整个应用程序中，我们只有一个ActorSystem和Materializer实例beans。</li><li id="9267" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">仅当<strong class="io hj"><em class="mx">akka . stream . Java DSL . source</em></strong>在范围内时才会被实例化。</li></ol><p id="fdac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">我们的卡夫卡事件DTO消费:</strong></p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="964e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">让我们编写我们的Source (Kafka) </strong>:我们希望稍后提交偏移量，因此使用一个<a class="ae kn" href="https://doc.akka.io/api/alpakka-kafka/2.0.2/akka/kafka/scaladsl/Consumer$.html#plainSource[K,V](settings:akka.kafka.ConsumerSettings[K,V],subscription:akka.kafka.Subscription):akka.stream.scaladsl.Source[org.apache.kafka.clients.consumer.ConsumerRecord[K,V],akka.kafka.scaladsl.Consumer.Control]" rel="noopener ugc nofollow" target="_blank"> committableSource </a>。我们将从可提交的源代码中创建一个Bean，并自动连接到我们的服务类中。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="6e8c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">现在让我们编写我们的流(Slick): </strong>如果我们不关心持久结果并提交Kafka offset(使用"<a class="ae kn" href="https://doc.akka.io/api/alpakka-kafka/2.0.2/akka/kafka/scaladsl/Consumer$.html#plainSource[K,V](settings:akka.kafka.ConsumerSettings[K,V],subscription:akka.kafka.Subscription):akka.stream.scaladsl.Source[org.apache.kafka.clients.consumer.ConsumerRecord[K,V],akka.kafka.scaladsl.Consumer.Control]" rel="noopener ugc nofollow" target="_blank"> plainSource </a>")，我们就可以创建一个Sink。我们使用flow而不是sink，因为我们想在数据库阶段之后传播committable-offset。我们将在同一个配置类中添加以下代码。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="981f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可能想知道<strong class="io hj"> <em class="mx"> stream.conf </em> </strong>文件中有什么，那个<strong class="io hj"><em class="mx">committableMesssageToDTO</em></strong>和<strong class="io hj"><em class="mx">insertEventQuery</em></strong>是从哪里来的？</p><p id="911a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Slick需要一个配置来创建一个会话，该会话将执行我们所有的数据库查询。该配置需要在<strong class="io hj"> <em class="mx">中遵循以下结构。conf </em> </strong>文件(这是在typesafe/lightbend环境中访问配置的标准方式)。</p><pre class="ld le lf lg fd mk ml mm mn aw mo bi"><span id="4589" class="mp jl hi ml b fi mq mr l ms mt">event-sqlserver {<br/>  profile = "slick.jdbc.SQLServerProfile$"<br/>  db {<br/>    dataSourceClass = "slick.jdbc.DriverDataSource"<br/>    properties {<br/>      driver = "com.microsoft.sqlserver.jdbc.SQLServerDriver"<br/>      url = "your-db-url!"<br/>      user = "your-db-user!"<br/>      password = "your-db-pass"<br/>    }<br/>  }<br/>}</span></pre><p id="2c38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">而<strong class="io hj"><em class="mx">committableMesssageToDTO</em></strong>和<strong class="io hj"><em class="mx">insertEventQuery</em></strong>是将我们的CommittableMessage转换为DTO(我们的记录类)然后转换为SQL插入查询的函数。</p><p id="3bef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以用静态函数编写一个Utils类来生成SQL，如下所示:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="aae1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">现在，让我们把它们拼凑起来，构建一个流:</strong></p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="c07d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是这个！我们现在可以从任何地方调用startKafkaToDatabaseStream()方法，它将完成我们的工作。</p><p id="da95" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在一个“简洁”的链中有很多突出的特性！让我来解释一下:</p><ol class=""><li id="903c" class="ko kp hi io b ip iq it iu ix kq jb kr jf ks jj kt ku kv kw bi translated"><strong class="io hj">T1。buffer(size，overflowStrategy)  </strong>:这将在我们的“流”中添加一个固定大小的<strong class="io hj"><em class="mx"/></strong>缓冲区，这将保护下游系统免受更快的上游源的影响。如果大小已满，我们可以使用丢弃消息的策略:<strong class="io hj"> <em class="mx">背压</em> </strong> —将降低消耗，<strong class="io hj"><em class="mx">drop head/drop tail/drop buffer</em></strong>—将丢弃消息并且不会背压，<strong class="io hj"> <em class="mx"> fail </em> </strong> —缓冲区已满时流失败。</li><li id="b2e4" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj"> <em class="mx">。idleTimeout(duration) </em> </strong>:在空闲超时持续时间会抛出一个<strong class="io hj"><em class="mx">Java . util . concurrent . time out exception</em></strong>，可以使用recover/recoverWith处理。</li><li id="dde7" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj"> <em class="mx">。recoverWith(ThrowableClass，fallbackSourceConsumer)</em></strong>:每当ThrowableClass.class异常被截获时，原始源将被从fallbackSourceConsumer接收的源所替换。</li><li id="9c00" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj"> <em class="mx">。throttle(elements，per，maximumburst，mode) </em> </strong>:以限制为(<strong class="io hj"> <em class="mx"> elements/per </em> </strong>)的速度向下游发送元素，mode = Shaping在发射前暂停以满足节流速率，mode = Enforcing当上游速度快于节流速率时，异常失败。</li><li id="36af" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj"> <em class="mx">。mapAsync(parallelism，()-&gt;completion stage(value))</em></strong>:以定义了并行度的异步模式处理阶段。</li><li id="be61" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj"><em class="mx">【committer settings . create(actor system)</em></strong>:创建默认的提交者设置。</li></ol><p id="41a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">排水控制可用作:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="aa54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">akka流还有很多其他特性，不在本文讨论范围之内，但仍然值得探索。请检查<a class="ae kn" href="https://doc.akka.io/docs/akka/current/stream/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> akka-stream </strong> </a>和<a class="ae kn" href="https://doc.akka.io/docs/alpakka/current/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> alpakka的</strong> </a>文档。</p><h1 id="897a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="24f6" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们看到，我们可以轻松地将Akka流集成到我们的Spring Boot项目中，并利用Spring的依赖注入来轻松管理我们的Akka/Stream bean。</p><p id="9ad7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有许多流特性，如背压和节流等，很容易占用开发人员大量的时间和精力。然而，如果没有进行彻底的测试，我们可能会错过一些关键案例。我们在akka-stream的工具包中获得了开箱即用的那些东西。</p><p id="07f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总而言之，Akka-streams和Alpakka都是数据平台堆栈中的优秀工具。</p><p id="accd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>