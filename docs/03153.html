<html>
<head>
<title>Part 3-Canny function for Edge Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第3部分-边缘检测的Canny函数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/part-3-canny-function-for-edge-detection-d96303e37439?source=collection_archive---------11-----------------------#2020-01-18">https://medium.com/analytics-vidhya/part-3-canny-function-for-edge-detection-d96303e37439?source=collection_archive---------11-----------------------#2020-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e6c8289ddc3188851d03ea96cc6b94d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd2-95YgehQe33H8LCs2pA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Canny图像(在梯度值高于阈值限制时获得)</figcaption></figure><p id="bc43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上一篇文章中，我们致力于从灰度图像中获得高斯模糊图像(通过减少图像中的噪声)。</p><p id="58c8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在这篇文章中，我们将利用精明的边缘检测。该方法仅关注于检测相邻像素之间存在显著梯度差异的边缘。这在计算机视觉技术中非常重要。图像中的边缘必须被检测到尽可能高的水平，以便从那里做出有效的决定和研究。</p><p id="7d13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们的道路示例中，我们希望系统或我们的自动驾驶汽车能够实时读取道路图像，并就车道线做出智能决策。然后，它可以容易地检测该区域，从而检测特定的感兴趣区域。</p><p id="a883" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在使用Canny边缘检测算法之前，让我们检查一下它到底是什么:</p><blockquote class="js jt ju"><p id="4449" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj"> Canny边缘检测器</strong>是一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Edge_detection" rel="noopener ugc nofollow" target="_blank">边缘检测</a>算子，它使用多阶段<a class="ae jz" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>来检测图像中的各种边缘。它是由约翰·f·坎尼于1986年发明的。Canny还提出了边缘检测的计算理论，解释了这项技术的工作原理。(维基百科)</p></blockquote><p id="c683" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们知道任何图像都可以用像素矩阵来表示。正如我们所知，灰度图像只有一个通道，因此像素值范围从0-255。</p><p id="e4bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们也可以用坐标，即x和y值来表示这个图像。x轴位于水平侧，考虑列，而Y轴位于垂直侧，用于考虑相应的行。现在，行和列的乘积为我们提供了所有像素及其值的细节。因此，图像也可以表示为数学函数，即</p><p id="8b76" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="jv"> f (x，y):像素强度的函数，在所有方向上，x和y </em> </strong></p><p id="1a36" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们的Canny边缘检测器将对图像函数进行求导，从而测量所有方向x和y上的相邻强度变化:</p><p id="2915" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="jv">导数(f(x，y)) </em> </strong></p><p id="3724" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，如下图所示，没有变化的导数为零，大的变化由大的导数表示。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/22e14e2bdbe350aa06b8a672239f0467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNEDCz6ahA17plWppp6NiA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">左(导数不变=0 &amp;右(导数大时变化大</figcaption></figure><p id="ef9f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Canny函数看起来像这样:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="39eb" class="kk kl hi kg b fi km kn l ko kp">        cv2.Canny(image, low_threshold, high_threshold)</span></pre><p id="f669" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图显示的是一条白线，除了边缘什么都没有，因为这条线是黑白颜色的分界线，或者从技术上讲，我们可以说在这些点上相邻像素的强度发生了急剧变化。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/f9dff665744939c1120d0869d87a6700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvnUPI1KBXlfgEVIvvBAQQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">右边中间的白线代表边缘线，因为它是左边图像的分割点</figcaption></figure><p id="2ee6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于Canny函数的文档建议low_threshold和high_threshold之间的比率为1:2或1:3。</p><p id="1b1b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，在我们的示例中，我们采用了1:3的比率，即</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b25d" class="kk kl hi kg b fi km kn l ko kp">          canny = cv2.Canny(blur, 50, 150)</span></pre><p id="3b19" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">边缘检测的社交应用</strong></p><ol class=""><li id="d471" class="kr ks hi iw b ix iy jb jc jf kt jj ku jn kv jr kw kx ky kz bi translated"><strong class="iw hj">车牌检测</strong>:如今，汽车随处可见。智能交通控制无疑将成为未来的趋势。车牌检测技术广泛应用于收费站以及公共场所、公司和住宅区的停车场。因此改进这项技术具有很大的实用价值。</li><li id="7516" class="kr ks hi iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated"><strong class="iw hj">检测医学图像中的隐藏信息</strong>:在分析医学图像时，最重要的是我们不仅可以检测出物体的边缘；我们还可以检测出测试对象的一些隐藏信息。这些细节不可能通过传统方法检测到，因为这些细节的颜色与其周围区域的颜色之间的差异非常小。因此，各种各样的其他边缘检测方法被开发出来，如DPC，MDPC，QDPA和QDPC。</li></ol><p id="82d2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，我以此结束这篇文章。在下一篇文章中，我们将进一步推进这个项目。让我知道，你如何看待计算机视觉和自动驾驶汽车的这一分支。</p><p id="4a9e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">参考书目</strong></p><ul class=""><li id="af50" class="kr ks hi iw b ix iy jb jc jf kt jj ku jn kv jr lf kx ky kz bi translated"><a class="ae jz" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank">https://opencv-python-tutro als . readthedocs . io/en/latest/py _ tutorials/py _ imgproc/py _ canny/py _ canny . html</a></li><li id="f9e6" class="kr ks hi iw b ix la jb lb jf lc jj ld jn le jr lf kx ky kz bi translated"><a class="ae jz" href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/canny.htm" rel="noopener ugc nofollow" target="_blank">https://homepages.inf.ed.ac.uk/rbf/HIPR2/canny.htm</a></li><li id="ed51" class="kr ks hi iw b ix la jb lb jf lc jj ld jn le jr lf kx ky kz bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Canny_edge_detector" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Canny_edge_detector</a></li></ul></div></div>    
</body>
</html>