<html>
<head>
<title>A Discussion on Data Structures — Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于数据结构——队列的讨论</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-discussion-on-data-structures-queues-99bc4f52f66e?source=collection_archive---------20-----------------------#2020-07-22">https://medium.com/analytics-vidhya/a-discussion-on-data-structures-queues-99bc4f52f66e?source=collection_archive---------20-----------------------#2020-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="778a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">实现以FIFO方式工作的简单数据结构。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3c6e00566d012f823ad3adfc8dc931fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rK3sHMuufxNRDfaZ6dyAQw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">安妮·斯普拉特在<a class="ae jn" href="https://unsplash.com/s/photos/tile-pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4e4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是关于数据结构的一系列文章中的最新一篇，记录了我实现一个类似STL的名为Telemetry的库的过程。更多信息请点击此处:</p><div class="kk kl ez fb km kn"><a rel="noopener follow" target="_blank" href="/@Utkarsh.pant/telemetry-implementing-a-library-for-data-structures-and-algorithms-in-c-dd38491d863d"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hj fi z dy ks ea eb kt ed ef hh bi translated">遥测技术——用C++实现数据结构和算法库。</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">这是记录数据结构和算法的C++库实现的系列文章的第一篇。对于…</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb jh kn"/></div></div></a></div><p id="e4da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi lc translated">今天，我们来谈谈排队。自从我的上一篇文章以来，我在遥测库中做了一些改变——首先，我写了一个不错的自述文件，并在那里添加了一个待办事项。根据 <em class="ll">优先级(</em>)执行队列😃<em class="ll">)，</em>所以我们来了！</p><h2 id="d456" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">什么是队列？</h2><p id="0745" class="pw-post-body-paragraph jo jp hi jq b jr mh ij jt ju mi im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">和往常一样，让我从什么是队列开始。据可靠的老<a class="ae jn" href="http://www.cplusplus.com/reference/queue/queue/" rel="noopener ugc nofollow" target="_blank">Cplusplus.com</a>—</p><blockquote class="mm mn mo"><p id="4bde" class="jo jp ll jq b jr js ij jt ju jv im jw mp jy jz ka mq kc kd ke mr kg kh ki kj hb bi translated">队列是一种容器适配器，专门设计用于在FIFO上下文(先进先出)中操作，其中元素被插入容器的一端并从另一端提取。</p></blockquote><p id="6a7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用图解法，队列可以表示如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/70919257b94d7b819fcd1220dd17ddc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*QX1JuZWCMf9IlzwLINsIrg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图一。标准的FIFO队列。</figcaption></figure><p id="fac9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如图1所示，队列允许从后面进入，从前面退出，让每个人都排队等待轮到他们。相当简单。</p><p id="6da2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">进一步阅读Cplusplus.com条目，我们可以看到队列<em class="ll">也是</em>容器适配器，它可以使用向量或列表来实现，因为底层容器除了允许我们访问<code class="du mt mu mv mw b">front</code>和<code class="du mt mu mv mw b">back</code>元素之外，还应该支持像<code class="du mt mu mv mw b">push_back()</code>和<code class="du mt mu mv mw b">pop_front()</code>这样的函数。幸运的是，我们可以依靠我们的Lists实现来运行这里的显示！</p><p id="d508" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们知道了队列应该如何表现，让我们看看队列的UML类图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/80c9e3e858a550c16c7239230cd9ff74.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*geXfqLamvpXidzSg5xcmTw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图二。我们队列的UML类图。</figcaption></figure><p id="ef99" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类中不需要任何特殊的数据成员。<code class="du mt mu mv mw b">static queue_count</code>和<code class="du mt mu mv mw b">ID</code>变量更多的是用于<em class="ll">诊断</em>目的，而非其他目的。如果同时使用多个对象，它们会在抛出异常时识别出有问题的对象。说到这里，自从上一篇文章以来，我做了一点事情…</p><p id="e0d3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了简单起见，我放弃了<code class="du mt mu mv mw b">StackUnderflowException</code>、<code class="du mt mu mv mw b">EmptyListException</code>和所有其他的<code class="du mt mu mv mw b">ThisAndThatException</code>，取而代之的是一个漂亮干净的<em class="ll"> EmptyContainerException。尽管如此，它的行为还是和以前一样——如果我们试图在一个空容器中翻找，它会吐出容器的<code class="du mt mu mv mw b">ID</code>,告诉我们那里没有什么可看的！</em></p><h2 id="c138" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">队列上的操作</h2><p id="2ec4" class="pw-post-body-paragraph jo jp hi jq b jr mh ij jt ju mi im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">下列操作必须在队列中可用:</p><ol class=""><li id="8015" class="my mz hi jq b jr js ju jv jx na kb nb kf nc kj nd ne nf ng bi translated">push():将一个元素从队列的<em class="ll">推回</em>。</li><li id="4658" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">pop():从队列的<em class="ll">前端</em>弹出一个元素。如果队列为空，抛出一个<code class="du mt mu mv mw b">EmptyContainerException</code>。</li><li id="3055" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">front():访问队列的<em class="ll">前端</em>，但<em class="ll">不要移除</em>元素。如果队列为空，抛出一个<code class="du mt mu mv mw b">EmptyContainerException</code>。</li><li id="c388" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">back():访问队列的<em class="ll"> back </em>但<em class="ll">不移除</em>元素。如果队列为空，抛出一个<code class="du mt mu mv mw b">EmptyContainerException</code>。</li><li id="89c3" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">size():返回队列的当前大小。</li><li id="2d98" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">empty():返回队列是否为空。</li></ol><h2 id="ace7" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">类别定义</h2><p id="e267" class="pw-post-body-paragraph jo jp hi jq b jr mh ij jt ju mi im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">Queue类归结为一个非常简单和熟悉的定义，如下:(和往常一样，我省略了像include guards、#include语句之类的无用内容。请参阅GitHub资源库以获取正确的代码。链接在最后！)</p><pre class="iy iz ja jb fd nm mw nn no aw np bi"><span id="50f5" class="lm ln hi mw b fi nq nr l ns nt"><strong class="mw hj">template &lt;class T&gt;</strong><br/>class <strong class="mw hj">Queue</strong> {<br/>private:<br/>    static int queue_count;<br/>    int ID;<br/>    List&lt;T&gt; queue;</span><span id="ee31" class="lm ln hi mw b fi nu nr l ns nt">public:<br/>   <strong class="mw hj"> // utility functions;</strong><br/>    void push(T arg);<br/>    T pop();<br/>    T front();<br/>    T back();<br/>    int size();<br/>    bool empty();<br/>    static int get_queue_count();<br/>    std::string get_ID();</span><span id="2e59" class="lm ln hi mw b fi nu nr l ns nt"><strong class="mw hj">//constructors;</strong><br/>    Queue() {<br/>        ID = ++queue_count;<br/>    }<br/>};</span></pre><p id="b995" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一些成员函数实现如下:</p><h2 id="4a18" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">推送()</h2><pre class="iy iz ja jb fd nm mw nn no aw np bi"><span id="2431" class="lm ln hi mw b fi nq nr l ns nt"><strong class="mw hj">// push arg into the queue from the rear;</strong><br/>template &lt;class T&gt;<br/>void Queue&lt;T&gt;::push(T arg) {<br/>    <strong class="mw hj">queue.push_back(arg);</strong><br/>}</span></pre><p id="ed71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，我们在底层列表中使用了<code class="du mt mu mv mw b">queue.push_back()</code>函数，从后面将元素添加到队列中。</p><h2 id="2f38" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">流行()</h2><pre class="iy iz ja jb fd nm mw nn no aw np bi"><span id="d21c" class="lm ln hi mw b fi nq nr l ns nt"><strong class="mw hj">// pop arg from the queue from the front;</strong><br/>template &lt;class T&gt;<br/>T Queue&lt;T&gt;::pop() {<br/>    if (queue.empty()) {<br/>        //throw Exception<br/>        <strong class="mw hj">throw EmptyContainerException(std::to_string(ID));</strong><br/>    } else {<br/>        return <strong class="mw hj">queue.pop();</strong><br/>    }<br/>}</span></pre><p id="41d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意新的<code class="du mt mu mv mw b">EmptyContainerException</code>类正在运行！</p><h2 id="d920" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">正面()</h2><pre class="iy iz ja jb fd nm mw nn no aw np bi"><span id="94be" class="lm ln hi mw b fi nq nr l ns nt"><strong class="mw hj">// accesses the first element in the queue but does not remove it;</strong><br/>template &lt;class T&gt;<br/>T Queue&lt;T&gt;::front() {<br/>    if (queue.empty()) {<br/>        <strong class="mw hj">throw EmptyContainerException(std::to_string(ID));</strong><br/>    } else {<br/>        <strong class="mw hj">return (queue.get_head())-&gt;data;</strong><br/>    }<br/>}</span></pre><p id="5142" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意<code class="du mt mu mv mw b">(queue.get_head())</code>是如何在需要引用前端元素的地方使用的。请记住，这将返回一个指向节点的<em class="ll">指针</em>而不是数据——指针必须被“<em class="ll">解引用”</em>才能访问数据！</p><h2 id="9dcd" class="lm ln hi bd lo lp lq lr ls lt lu lv lw jx lx ly lz kb ma mb mc kf md me mf mg bi translated">后退()</h2><pre class="iy iz ja jb fd nm mw nn no aw np bi"><span id="fd52" class="lm ln hi mw b fi nq nr l ns nt"><strong class="mw hj">// access the last element in the queue but does not remove it;</strong><br/>template &lt;class T&gt;<br/>T Queue&lt;T&gt;::back() {<br/>    if (queue.empty()) {<br/>        <strong class="mw hj">throw EmptyContainerException(std::to_string(ID));</strong><br/>    } else {<br/>        <strong class="mw hj">return (queue.get_tail())-&gt;data;</strong><br/>    }<br/>}</span></pre><p id="0a95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其他的成员函数和以前几乎一样。但是，要查看完整的头文件，请访问:</p><div class="kk kl ez fb km kn"><a href="https://github.com/utkarshpant/telemetry" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hj fi z dy ks ea eb kt ed ef hh bi translated">utkarshpant/遥测技术</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">一个数据结构和算法库，旨在以一种简化的方式复制STL的主要功能。</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">github.com</p></div></div><div class="kw l"><div class="nv l ky kz la kw lb jh kn"/></div></div></a></div><p id="4d0c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">排队到此为止！我应该提到，在我们的遥测之旅中，我们将实现另一种类型的队列——优先级队列(看我在上面做了什么？)这些队列接受任何顺序的元素，但总是弹出具有最高优先级的元素。由于引擎盖下的实现与我们今天看到的完全不同，我将在稍后讨论这个问题。但是我们仍然会把这个类的实现添加到<strong class="jq hj"> Queue.h </strong>中，就像我们的STL表兄弟一样。</p><p id="14c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ll">鳍。</em></p></div><div class="ab cl nw nx gp ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="hb hc hd he hf"><h1 id="1a8a" class="od ln hi bd lo oe of og ls oh oi oj lw io ok ip lz ir ol is mc iu om iv mf on bi translated">参考</h1><ol class=""><li id="d400" class="my mz hi jq b jr mh ju mi jx oo kb op kf oq kj nd ne nf ng bi translated">Reema Thareja，2017，<em class="ll">使用C的数据结构，第二版。，</em>牛津大学出版社。</li><li id="a256" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated"><strong class="jq hj">STD::queue</strong><em class="ll">(</em><a class="ae jn" href="http://www.cplusplus.com/reference/queue/queue/" rel="noopener ugc nofollow" target="_blank"><em class="ll">http://www.cplusplus.com/reference/queue/queue/</em></a><em class="ll">)</em></li></ol></div></div>    
</body>
</html>