<html>
<head>
<title>Tuning Random forest algorithm to predict Income</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调整随机森林算法预测收入</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tuning-random-forest-algorithm-to-predict-income-14005371656e?source=collection_archive---------3-----------------------#2020-07-10">https://medium.com/analytics-vidhya/tuning-random-forest-algorithm-to-predict-income-14005371656e?source=collection_archive---------3-----------------------#2020-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5a3e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">机器学习案例研究。</h2></div><p id="21e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated">在这个项目中，我们将使用年龄、教育和职业等各种特征来预测一个人的收入是高于50k还是低于50k。我们将要使用的数据集是来自Kaggle的成人人口普查收入数据集，它包含大约32561行和15个特征，可以在这里<a class="ae kc" href="https://www.kaggle.com/uciml/adult-census-income" rel="noopener ugc nofollow" target="_blank">下载</a>。我们还将使用Flask构建一个web应用程序，并使用Heroku进行部署。</p><blockquote class="kd ke kf"><p id="02e3" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">web app:【https://census-income-prediction.herokuapp.com/ T4】</p></blockquote><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/f0a99fb8fee75692e1280f7ff5832e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIyYWLMAQFu2yu6QDs0Rfw.jpeg"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">照片由<a class="ae kc" href="https://unsplash.com/@rupixen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">rupixen.com</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="c5ee" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">动机</h2><p id="b89a" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">建立这样的预测模型可以帮助我们更好地了解一个国家的人口以及影响经济的各种因素。政府可以理解这些因素并加以改善，从而促进国家的发展。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="5ea8" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">理解问题</h2><p id="7363" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">数据集包含我们必须预测哪个是从属特征“收入水平”的标签。该特征是离散的，包括收入低于50k和高于50k的两个类别。所以我们的问题是一个<strong class="iz hj">监督二进制分类</strong>类型。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="902e" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤0:导入库和数据集</h2><p id="703c" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">所有的标准库，如numpy、pandas、matplotlib和seaborn都是在这一步导入的。我们使用numpy进行线性代数运算，pandas使用数据框，matplotlib和seaborn绘制图形。使用pandas命令<em class="kg"> read_csv() </em>导入数据集。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="d032" class="la lb hi mi b fi mm mn l mo mp"><em class="kg"># Import libraries</em><br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="c59c" class="la lb hi mi b fi mq mn l mo mp"><em class="kg"># Importing dataset</em><br/>dataset = pd.read_csv('adult.csv')</span></pre></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="22e0" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤1:描述性分析</h2><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="af22" class="la lb hi mi b fi mm mn l mo mp"><em class="kg"># Preview dataset</em><br/>dataset.head()</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mr"><img src="../Images/8ab43525b270db78ab7d913198adfbae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDT29gjDU9YhuL8nZmtRrw.png"/></div></div></figure><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="f643" class="la lb hi mi b fi mm mn l mo mp"><em class="kg"># Shape of dataset</em><br/>print('Rows: <strong class="mi hj">{}</strong> Columns: <strong class="mi hj">{}</strong>'.format(dataset.shape[0], dataset.shape[1]))</span><span id="cba1" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>Rows: 32561 Columns: 15</span><span id="8003" class="la lb hi mi b fi mq mn l mo mp"><em class="kg"># Features data-type</em> <br/>dataset.info()</span><span id="f889" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 32561 entries, 0 to 32560<br/>Data columns (total 15 columns):<br/> #   Column          Non-Null Count  Dtype <br/>---  ------          --------------  ----- <br/> 0   age             32561 non-null  int64 <br/> 1   workclass       32561 non-null  object<br/> 2   fnlwgt          32561 non-null  int64 <br/> 3   education       32561 non-null  object<br/> 4   education.num   32561 non-null  int64 <br/> 5   marital.status  32561 non-null  object<br/> 6   occupation      32561 non-null  object<br/> 7   relationship    32561 non-null  object<br/> 8   race            32561 non-null  object<br/> 9   sex             32561 non-null  object<br/> 10  capital.gain    32561 non-null  int64 <br/> 11  capital.loss    32561 non-null  int64 <br/> 12  hours.per.week  32561 non-null  int64 <br/> 13  native.country  32561 non-null  object<br/> 14  income          32561 non-null  object<br/>dtypes: int64(6), object(9)<br/>memory usage: 3.7+ MB</span><span id="6e6a" class="la lb hi mi b fi mq mn l mo mp"><em class="kg"># Statistical summary</em><br/>dataset.describe().T</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ms"><img src="../Images/adf703e43a4d5114706a4ce89bcd814e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*69BhVOEK_Zv5Q4CkICwRQg.png"/></div></div></figure><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="677b" class="la lb hi mi b fi mm mn l mo mp"><em class="kg"># Check for null values</em><br/>round((dataset.isnull().sum() / dataset.shape[0]) * 100, 2).astype(str) + ' %'</span><span id="75d8" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:<br/></strong>age               0.0 %<br/>workclass         0.0 %<br/>fnlwgt            0.0 %<br/>education         0.0 %<br/>education.num     0.0 %<br/>marital.status    0.0 %<br/>occupation        0.0 %<br/>relationship      0.0 %<br/>race              0.0 %<br/>sex               0.0 %<br/>capital.gain      0.0 %<br/>capital.loss      0.0 %<br/>hours.per.week    0.0 %<br/>native.country    0.0 %<br/>income            0.0 %<br/>dtype: object</span><span id="97e6" class="la lb hi mi b fi mq mn l mo mp"><em class="kg"># Check for '?' in dataset</em><br/>round((dataset.isin(['?']).sum() / dataset.shape[0]) * 100, 2).astype(str) + ' %'</span><span id="e624" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>age                0.0 %<br/>workclass         5.64 %<br/>fnlwgt             0.0 %<br/>education          0.0 %<br/>education.num      0.0 %<br/>marital.status     0.0 %<br/>occupation        5.66 %<br/>relationship       0.0 %<br/>race               0.0 %<br/>sex                0.0 %<br/>capital.gain       0.0 %<br/>capital.loss       0.0 %<br/>hours.per.week     0.0 %<br/>native.country    1.79 %<br/>income             0.0 %<br/>dtype: object</span><span id="5a05" class="la lb hi mi b fi mq mn l mo mp"><em class="kg"># Checking the counts of label categories</em><br/>income = dataset['income'].value_counts(normalize=True)<br/>round(income * 100, 2).astype('str') + ' %'</span><span id="cd63" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:<br/></strong>&lt;=50K    75.92 %<br/>&gt;50K     24.08 %<br/>Name: income, dtype: object</span></pre><blockquote class="kd ke kf"><p id="e73e" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">观察结果:</p><p id="8c30" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">1.数据集没有任何空值，但它包含“？”形式的缺失值这需要进行预处理。</p><p id="453a" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">2.数据集是不平衡的，因为从属特征“收入”包含75.92%的收入低于50k的值，以及24.08%的收入高于50k的值。</p></blockquote></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="4c74" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤2:探索性数据分析</h2><p id="4af8" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated"><strong class="iz hj"> <em class="kg"> 2.1单因素分析:</em> </strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mt"><img src="../Images/e5748add8378cc1b2e61e50685be7931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*npgGqbDda4hQ8VgSHG3arA.png"/></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mu"><img src="../Images/dd0d15232efbbb0f417b4f65dd2fe8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mgEG95tbT58vAaSok62NMA.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mv"><img src="../Images/b1f8f1f787144cdee71f952e0322bab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUq9txLi-kJaFnW21dqqvg.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mw"><img src="../Images/d965703dcb98c9135ddee7aa731bb195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*6o2CgxD_NdYxtGQF0H-d9g.png"/></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mx"><img src="../Images/0520b50fb02933fbed71d084ff94c688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWkg85bYpaXN1UzMQBkRYA.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es my"><img src="../Images/ccc559027454896dde173e996f522255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSkI6kDenA-c9-RWtTO3Pw.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mz"><img src="../Images/742d33f5ca8da1c1abe0cb214ab8de6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pQzL35dv4gt7GvdtTNg5w.png"/></div></figure><p id="c409" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="kg"> 2.2二元分析:</em> </strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es na"><img src="../Images/91f466e5a336750f96a1e70f6cddc912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lB80BXrkHqiFXaHbMSMG1g.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es my"><img src="../Images/3d933116dd082429838eee405ff7a719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biaITHysHSemcpnwtAORDg.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es my"><img src="../Images/f3bb6391acbecc745b5af75cd8d516cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCXp8AKpt6_U6QOaGiwfag.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es mz"><img src="../Images/146e79d1059433011d3dacb2af0bf8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZCOOq2T-3PUcJfcU66rqw.png"/></div></figure><p id="e0c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="kg"> 2.3多元分析:</em> </strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es nb"><img src="../Images/2837db432366624052c6b8f415c93bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPcdryuM1jUBx8kaYPNDCw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">数据集的配对图</figcaption></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es nc"><img src="../Images/ecdf27b4f0686a793d4b0ef8f664c612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*QOs48Xcc3wjMJtFPFehUFw.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">相关矩阵的热图</figcaption></figure><blockquote class="kd ke kf"><p id="bc03" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">观察结果:</p><p id="2ecf" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">1.在这个数据集中，大多数人是年轻的白人男性，高中毕业，受教育9到10年，每周工作40小时。</p><p id="1d3a" class="ix iy kg iz b ja jb ij jc jd je im jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated">2.从相关热图中，我们可以看到，从属特征“收入”与年龄、受教育年限、资本收益和每周工作小时数高度相关。</p></blockquote></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="ff94" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤3:数据预处理</h2><p id="8357" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">空值的形式为“？”使用<em class="kg"> fillna() </em>命令可以很容易地用最频繁的值(模式)替换它。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="6c26" class="la lb hi mi b fi mm mn l mo mp">dataset = dataset.replace('?', np.nan)</span><span id="3dfd" class="la lb hi mi b fi mq mn l mo mp"><em class="kg"># Checking null values</em><br/>round((dataset.isnull().sum() / dataset.shape[0]) * 100, 2).astype(str) + ' %'</span><span id="2182" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>age                0.0 %<br/>workclass         5.64 %<br/>fnlwgt             0.0 %<br/>education          0.0 %<br/>education.num      0.0 %<br/>marital.status     0.0 %<br/>occupation        5.66 %<br/>relationship       0.0 %<br/>race               0.0 %<br/>sex                0.0 %<br/>capital.gain       0.0 %<br/>capital.loss       0.0 %<br/>hours.per.week     0.0 %<br/>native.country    1.79 %<br/>income             0.0 %<br/>dtype: object</span><span id="de9a" class="la lb hi mi b fi mq mn l mo mp">columns_with_nan = ['workclass', 'occupation', 'native.country']</span><span id="6098" class="la lb hi mi b fi mq mn l mo mp">for col in columns_with_nan:<br/>    dataset[col].fillna(dataset[col].mode()[0], inplace = True)</span></pre><p id="1bf6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据集中的对象列需要编码，以便可以进一步使用。这可以通过使用sklearn预处理库中的<strong class="iz hj">标签编码器</strong>来完成。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="d732" class="la lb hi mi b fi mm mn l mo mp">from sklearn.preprocessing import LabelEncoder</span><span id="a06c" class="la lb hi mi b fi mq mn l mo mp">for col in dataset.columns:<br/>  if dataset[col].dtypes == 'object':         <br/>    encoder = LabelEncoder()         <br/>    dataset[col] = encoder.fit_transform(dataset[col])</span></pre><p id="2531" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，数据集被分成包含所有独立特征的X和包含从属特征“收入”的Y。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="962c" class="la lb hi mi b fi mm mn l mo mp">X = dataset.drop('income', axis = 1) <br/>Y = dataset['income']</span></pre><p id="9ad4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多重共线性的诅咒和过度拟合的问题可以通过执行<strong class="iz hj">特征选择</strong>来解决。使用<em class="kg">提取树分类器</em>可以很容易地找到特征的重要性。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="c124" class="la lb hi mi b fi mm mn l mo mp">from sklearn.ensemble import ExtraTreesClassifier<br/>selector = ExtraTreesClassifier(random_state = 42)</span><span id="7a4c" class="la lb hi mi b fi mq mn l mo mp">selector.fit(X, Y)</span><span id="9fb2" class="la lb hi mi b fi mq mn l mo mp">feature_imp = selector.feature_importances_</span><span id="a65a" class="la lb hi mi b fi mq mn l mo mp">for index, val in enumerate(feature_imp):<br/>    print(index, round((val * 100), 2))</span><span id="2ab2" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>0 15.59<br/>1 4.13<br/>2 16.71<br/>3 3.87<br/>4 8.66<br/>5 8.04<br/>6 7.27<br/>7 8.62<br/>8 1.47<br/>9 2.84<br/>10 8.83<br/>11 2.81<br/>12 9.64<br/>13 1.53</span><span id="bcf9" class="la lb hi mi b fi mq mn l mo mp">X = X.drop(['workclass', 'education', 'race', 'sex', 'capital.loss', 'native.country'], axis = 1)</span></pre><p id="50e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<strong class="iz hj">特征缩放</strong>我们可以标准化数据集，以帮助模型学习模式。这可以用sklearn预处理库中的<em class="kg"> StandardScaler() </em>来完成。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="b3ef" class="la lb hi mi b fi mm mn l mo mp">from sklearn.preprocessing import StandardScaler</span><span id="8871" class="la lb hi mi b fi mq mn l mo mp">for col in X.columns:     <br/>  scaler = StandardScaler()     <br/>  X[col] = scaler.fit_transform(X[col].values.reshape(-1, 1))</span></pre><p id="3b9b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从属特征“收入”非常不平衡，75.92%的值的收入低于50k，24.08%的值的收入高于50k。这个问题需要解决，因为它会导致F1分数很低。由于我们有一个小数据集，我们可以使用RandomOverSampler等技术执行<strong class="iz hj">过采样</strong>。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="0e14" class="la lb hi mi b fi mm mn l mo mp">round(Y.value_counts(normalize=True) * 100, 2).astype('str') + ' %'</span><span id="9633" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:<br/></strong>0    75.92 %<br/>1    24.08 %<br/>Name: income, dtype: object</span><span id="7275" class="la lb hi mi b fi mq mn l mo mp">from imblearn.over_sampling import RandomOverSampler <br/>ros = RandomOverSampler(random_state = 42)</span><span id="ff0f" class="la lb hi mi b fi mq mn l mo mp">ros.fit(X, Y)</span><span id="42d3" class="la lb hi mi b fi mq mn l mo mp">X_resampled, Y_resampled = ros.fit_resample(X, Y)</span><span id="3b32" class="la lb hi mi b fi mq mn l mo mp">round(Y_resampled.value_counts(normalize=True) * 100, 2).astype('str') + ' %'</span><span id="ed0e" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:<br/></strong>1    50.0 %<br/>0    50.0 %<br/>Name: income, dtype: object</span></pre><p id="b13a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<em class="kg"> train_test_split() </em>命令将数据集分成比例为80:20的训练数据和测试数据。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="dd9b" class="la lb hi mi b fi mm mn l mo mp">from sklearn.model_selection import train_test_split<br/>X_train, X_test, Y_train, Y_test = train_test_split(X_resampled, Y_resampled, test_size = 0.2, random_state = 42)</span><span id="67af" class="la lb hi mi b fi mq mn l mo mp">print("X_train shape:", X_train.shape) <br/>print("X_test shape:", X_test.shape) <br/>print("Y_train shape:", Y_train.shape) <br/>print("Y_test shape:", Y_test.shape)</span><span id="6087" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>X_train shape: (39552, 8)<br/>X_test shape: (9888, 8)<br/>Y_train shape: (39552,)<br/>Y_test shape: (9888,)</span></pre></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="517d" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤4:数据建模</h2><p id="d10f" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated"><strong class="iz hj">随机森林分类器:</strong></p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="3896" class="la lb hi mi b fi mm mn l mo mp">from sklearn.ensemble import RandomForestClassifier<br/>ran_for = RandomForestClassifier(random_state = 42)</span><span id="e3a7" class="la lb hi mi b fi mq mn l mo mp">ran_for.fit(X_train, Y_train)</span><span id="8501" class="la lb hi mi b fi mq mn l mo mp">Y_pred_ran_for = ran_for.predict(X_test)</span></pre><blockquote class="nd"><p id="bc14" class="ne nf hi bd ng nh ni nj nk nl nm js dx translated">理解算法:</p></blockquote><p id="2d8d" class="pw-post-body-paragraph ix iy hi iz b ja nn ij jc jd no im jf jg np ji jj jk nq jm jn jo nr jq jr js hb bi translated">随机森林是一种监督学习算法，用于分类和回归。这是一种bagging集成算法，它同时创建多个决策树，试图从彼此独立的数据集学习。使用多数投票选择最终预测。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ns"><img src="../Images/e62cedd9197ea0de942c4ac566c4770d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmtbIgxoflflJqMJ_UHwXw.jpeg"/></div></div></figure><p id="c5a4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随机森林非常灵活，并且具有很高的准确性，因为它通过组合多个决策树的结果来克服过度拟合的问题。即使对于大型数据集，随机森林也能提供良好的性能。如果我们的数据集有大量缺失值，它们也能提供很好的准确性。但是随机森林比决策树更复杂，计算量更大，导致模型构建过程非常耗时。它们也比决策树更难解释，更不直观。</p><p id="a79d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法有一些重要的参数，如最大深度、最大特征、n估计量和最小样本叶。可用于建立模型的树的数量由n个估计器定义。Max_features确定随机森林在单个树中可以使用的最大功能数。决策树的最大深度由参数max_depth给出。叶节点所需的最小样本数由min_sample_leaf给出。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="e50e" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">第五步:模型评估</h2><p id="1a11" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">在这一步中，我们将使用两个指标来评估我们的模型，这两个指标是<strong class="iz hj">准确性分数</strong>和<strong class="iz hj"> f1分数</strong>。准确度是正确预测值与总预测值的比率。它告诉我们我们的预测有多准确。F1分数是精确度和召回率的加权平均值，其值越高，模型越好。我们将使用f1得分的准确性得分，因为我们有一个不平衡的数据集。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="4ca3" class="la lb hi mi b fi mm mn l mo mp">from sklearn.metrics import accuracy_score<br/>from sklearn.metrics import f1_score</span><span id="dc16" class="la lb hi mi b fi mq mn l mo mp">print('Random Forest Classifier:')<br/>print('Accuracy score:',round(accuracy_score(Y_test, Y_pred_ran_for) * 100, 2))<br/>print('F1 score:',round(f1_score(Y_test, Y_pred_ran_for) * 100, 2))</span><span id="dd0e" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>Random Forest Classifier:<br/>Accuracy score: 92.6<br/>F1 score: 92.93</span></pre></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="4a3f" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤6:超参数调整</h2><p id="6fdd" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">我们将使用<strong class="iz hj"> RandomizedSearchCV </strong>来调整我们的随机森林分类器的超参数，该分类器通过随机搜索来找到最佳超参数，从而避免不必要的计算。我们将尝试找到‘n _ estimators’和‘max _ depth’的最佳值。</p><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="bfcb" class="la lb hi mi b fi mm mn l mo mp">from sklearn.model_selection import RandomizedSearchCV</span><span id="e63b" class="la lb hi mi b fi mq mn l mo mp">n_estimators = [int(x) for x in np.linspace(start = 40, stop = 150, num = 15)]<br/>max_depth = [int(x) for x in np.linspace(40, 150, num = 15)]</span><span id="362c" class="la lb hi mi b fi mq mn l mo mp">param_dist = {<br/>    'n_estimators' : n_estimators,<br/>    'max_depth' : max_depth,<br/>}</span><span id="56ce" class="la lb hi mi b fi mq mn l mo mp">rf_tuned = RandomForestClassifier(random_state = 42)</span><span id="cd64" class="la lb hi mi b fi mq mn l mo mp">rf_cv = RandomizedSearchCV(estimator = rf_tuned, param_distributions = param_dist, cv = 5, random_state = 42)</span><span id="1c52" class="la lb hi mi b fi mq mn l mo mp">rf_cv.fit(X_train, Y_train)</span><span id="adac" class="la lb hi mi b fi mq mn l mo mp">rf_cv.best_score_</span><span id="3884" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>0.9131271105332539</span><span id="bde9" class="la lb hi mi b fi mq mn l mo mp">rf_cv.best_params_</span><span id="1397" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:<br/></strong>{'n_estimators': 40, 'max_depth': 102}</span><span id="6371" class="la lb hi mi b fi mq mn l mo mp">rf_best = RandomForestClassifier(max_depth = 102, n_estimators = 40, random_state = 42)</span><span id="02ef" class="la lb hi mi b fi mq mn l mo mp">rf_best.fit(X_train, Y_train)</span><span id="5fcc" class="la lb hi mi b fi mq mn l mo mp">Y_pred_rf_best = rf_best.predict(X_test)</span><span id="cfdb" class="la lb hi mi b fi mq mn l mo mp">print('Random Forest Classifier:') <br/>print('Accuracy score:',round(accuracy_score(Y_test, Y_pred_rf_best) * 100, 2)) <br/>print('F1 score:',round(f1_score(Y_test, Y_pred_rf_best) * 100, 2))</span><span id="ea6d" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong><br/>Random Forest Classifier:<br/>Accuracy score: 92.77<br/>F1 score: 93.08</span><span id="e1cb" class="la lb hi mi b fi mq mn l mo mp">from sklearn.metrics import confusion_matrix <br/>cm = confusion_matrix(Y_test, Y_pred_rf_best)</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es nt"><img src="../Images/d2b9931b9290eb10751367bc29c15f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lH_LM2WgBcFT9DZqiVrgXA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">混淆矩阵的热图</figcaption></figure><pre class="kl km kn ko fd mh mi mj mk aw ml bi"><span id="c387" class="la lb hi mi b fi mm mn l mo mp">from sklearn.metrics import classification_report<br/>print(classification_report(Y_test, Y_pred_rf_best))</span><span id="b4df" class="la lb hi mi b fi mq mn l mo mp"><strong class="mi hj">Output:</strong></span><span id="9d6c" class="la lb hi mi b fi mq mn l mo mp">               precision    recall   f1-score  support<br/><br/>           0       0.97      0.88      0.92      4955<br/>           1       0.89      0.98      0.93      4933<br/><br/>    accuracy                           0.93      9888<br/>   macro avg       0.93      0.93      0.93      9888<br/>weighted avg       0.93      0.93      0.93      9888</span></pre><p id="3944" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在调整其超参数后，该模型为我们提供了92.77的准确度分数和93.08的f1分数的最佳值。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="7509" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">步骤7:模型部署</h2><p id="716b" class="pw-post-body-paragraph ix iy hi iz b ja lv ij jc jd lw im jf jg lx ji jj jk ly jm jn jo lz jq jr js hb bi translated">为了部署我们的模型，我们将首先使用<strong class="iz hj"> Flask </strong>微框架构建一个web应用程序。这个应用程序可以使用<strong class="iz hj"> Heroku </strong>部署到网络上。Heroku是一个平台即服务(PaaS ),使开发人员能够完全在云中构建、运行和操作应用程序。应用程序在这里找到了<a class="ae kc" href="https://census-income-prediction.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es nu"><img src="../Images/7374971a9cdce7437dc2033266fcbfc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5HzXMDxV0e51HeVilAiUVA.gif"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">Heroku上部署的Flask WebApp</figcaption></figure></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="6009" class="la lb hi bd lc ld le lf lg lh li lj lk jg ll lm ln jk lo lp lq jo lr ls lt lu bi translated">未来工作:</h2><ul class=""><li id="6a91" class="nv nw hi iz b ja lv jd lw jg nx jk ny jo nz js oa ob oc od bi translated">我们有一个足够大的数据集，所以我们可以使用人工神经网络等神经网络来建立一个可以产生更好性能的模型。</li></ul></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><div class="kl km kn ko fd oe"><a href="https://github.com/Aditya-Mankar/Census-Income-Prediction" rel="noopener  ugc nofollow" target="_blank"><div class="of ab dw"><div class="og ab oh cl cj oi"><h2 class="bd hj fi z dy oj ea eb ok ed ef hh bi translated">aditya-Mankar/人口普查-收入-预测</h2><div class="ol l"><h3 class="bd b fi z dy oj ea eb ok ed ef dx translated">使用成人人口普查收入数据集构建预测收入的分类模型。在本笔记本中，我们…</h3></div><div class="om l"><p class="bd b fp z dy oj ea eb ok ed ef dx translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ku oe"/></div></div></a></div></div></div>    
</body>
</html>