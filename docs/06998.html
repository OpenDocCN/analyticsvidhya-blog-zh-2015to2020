<html>
<head>
<title>Geospatial adventures. Step 3. Polygons grow on R-Trees.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地理空间冒险。第三步。多边形生长在R树上。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/geospatial-adventures-step-3-polygons-grow-on-r-trees-2f15e2712537?source=collection_archive---------6-----------------------#2020-06-10">https://medium.com/analytics-vidhya/geospatial-adventures-step-3-polygons-grow-on-r-trees-2f15e2712537?source=collection_archive---------6-----------------------#2020-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/71cfef7b3932f78433456cc4cf657929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znG9LlPMkGhUWWut5nDDqg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">使用KeplerGL生成</figcaption></figure><div class=""/><p id="0d01" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">在本系列的前几期文章中，我们已经讨论了在shapely </em>  <em class="js">中使用</em> <a class="ae jt" rel="noopener" href="/@datingpolygons/geospatial-adventures-step-1-shapely-e911e4f86361"> <em class="js">几何对象，并对GeoPandas </em> </a> <em class="js">做了一个温和的</em> <a class="ae jt" rel="noopener" href="/@datingpolygons/geospatial-adventures-step-2-pandas-vs-geopandas-16e842d0e3a7"> <em class="js">介绍。这意味着我们现在准备谈论一些更令人兴奋的事情。我将简要介绍如何处理大量的多边形和一些基本的方法，这些方法有助于保持这项任务的可控性。</em></a></p><p id="feee" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，让我们得到一些数据来玩。在<a class="ae jt" rel="noopener" href="/@datingpolygons/geospatial-adventures-step-2-pandas-vs-geopandas-16e842d0e3a7">步骤2 </a>中，我们查看了英国地方当局的边界地图，我还在文章末尾发布了一些地理空间数据集的链接，其中包括英国OSM数据的链接(开放街道地图对象)。在这篇文章中，我将使用地方当局和建筑多边形。文件很充实，所以我建议只看英格兰。</p><p id="5a94" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事实上，我在之前的帖子中使用了2017年地方当局的文件，让我们来点更新鲜的东西，并下载2019年12月版:</p><p id="48e0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae jt" href="https://geoportal.statistics.gov.uk/datasets/local-authority-districts-december-2019-boundaries-uk-bfc" rel="noopener ugc nofollow" target="_blank">https://geo portal . statistics . gov . uk/datasets/local-authority-districts-December-2019-boundaries-uk-bfc</a></p><p id="8891" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">OSM:</p><p id="1755" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae jt" href="http://download.geofabrik.de/europe/great-britain.html" rel="noopener ugc nofollow" target="_blank">http://download.geofabrik.de/europe/great-britain.html</a>(这里是英国的. shp.zip文件，1.62 GB——注意)</p><p id="f257" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">太好了。</p><p id="d1fd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你打开OSM的压缩文件，你会发现里面有太多的东西值得一看。在这篇文章中，我们只对建筑感兴趣，但是你绝对可以继续玩其他的。铁路、公路、水路、名胜古迹、宗教场所等。等等。这是一场有用信息的盛宴。(我想象着一个茫然的眼神和“耶…哦…好吧…”我得到的回应是…哦，好吧。继续前进)</p><p id="71bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们把它们装进去。我们还需要在这里导入我们的主要库。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5ceb" class="kd ke hx jz b fi kf kg l kh ki">import geopandas as gpd<br/>import swifter<br/>import numpy as np</span><span id="abb1" class="kd ke hx jz b fi kj kg l kh ki">la = gpd.read_file( 'Downloads/Local_Authority_Districts_December_2019_Boundaries_UK_BFC/Local_Authority_Districts_December_2019_Boundaries_UK_BFC.shp'<br/>)</span><span id="993b" class="kd ke hx jz b fi kj kg l kh ki">bd = gpd.read_file(<br/>'Downloads/england-latest-free.shp/gis_osm_buildings_a_free_1.shp'<br/>)</span></pre><p id="99ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">惊喜，惊喜…英格兰有很多建筑，所以文件很大，只有1gb多一点。加载需要一点时间，不过还是很容易控制的。从好的方面来说，你可以在装咖啡的时候去买一杯。</p><p id="e9dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们要尝试解决的问题是——通过简单地观察几何图形，我们将尝试识别哪些建筑位于哪个地方政府。事实上，对于仅仅尝试一些东西来说，这可能是一个太大的项目。我们将确定哪些建筑位于约克郡的东车道。喜欢这个名字…它坐落在约克的东部(喜欢那个地方！)并环绕赫尔(没去过，但听说很精彩)。</p><p id="7c44" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这次演习中选择它的一个原因是它复杂的海岸线。当然，我们可以求助于Shapely的简化方法，让它变得平滑，但是我们冒着把婴儿和洗澡水一起倒掉的风险。赫尔市就在它旁边，所以如果我们不小心的话，一些建筑会小到最终被完全忽略或者被错误地归类。</p><p id="5083" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还有另一个同样重要的原因，我现在要保密。(很刺激，不是吗？…嗯…对…)</p><p id="44d1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们走得更远之前，我们必须做一些真正重要的事情，我必须承认，这在过去曾让我绊倒过几次。养成检查数据集是否引用相同CRS的习惯是个好主意。如果您是本系列的新手，请查看第2步，了解更多信息和一些有用的链接。让我们来看看这两个公司使用的是什么样的CRS:</p><p id="5b90" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2cb6" class="kd ke hx jz b fi kf kg l kh ki">la.crs</span></pre><p id="4f96" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">出局:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2f4b" class="kd ke hx jz b fi kf kg l kh ki">&lt;Projected CRS: PROJCS["OSGB_1936_British_National_Grid",GEOGCS["G ...&gt;<br/>Name: OSGB_1936_British_National_Grid<br/>Axis Info [cartesian]:<br/>- E[east]: Easting (metre)<br/>- N[north]: Northing (metre)<br/>Area of Use:<br/>- undefined<br/>Coordinate Operation:<br/>- name: unnamed<br/>- method: Transverse Mercator<br/>Datum: OSGB 1936<br/>- Ellipsoid: Airy 1830<br/>- Prime Meridian: Greenwich</span></pre><p id="c6b8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于建筑物:</p><p id="64e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="9248" class="kd ke hx jz b fi kf kg l kh ki">bd.crs</span></pre><p id="f1d0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">出局:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="c5a7" class="kd ke hx jz b fi kf kg l kh ki">&lt;Geographic 2D CRS: EPSG:4326&gt;<br/>Name: WGS 84<br/>Axis Info [ellipsoidal]:<br/>- Lat[north]: Geodetic latitude (degree)<br/>- Lon[east]: Geodetic longitude (degree)<br/>Area of Use:<br/>- name: World<br/>- bounds: (-180.0, -90.0, 180.0, 90.0)<br/>Datum: World Geodetic System 1984<br/>- Ellipsoid: WGS 84<br/>- Prime Meridian: Greenwich</span></pre><p id="8bc1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还好我们检查过了！OSGB 1936本质上和我们在上一篇文章中使用的epsg: 27700是一样的。我确实提到过我更喜欢使用格网，因为它更直观，所以让我们继续将建筑物数据集转换为相同的crs，即使它更大，因此需要更长的时间。振作起来:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5779" class="kd ke hx jz b fi kf kg l kh ki">bd = bd.to_crs(epsg=27700)</span></pre><p id="98f8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以在这个阶段尝试一种强力方法，看看我们是否可以在每个6.5米的建筑多边形上应用intersects方法，以将它们与我们选择的地方当局区域匹配，但是，这将需要一段时间，所以让我们看看是否可以找到一种更好的方法。</p><p id="00b1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我马上想到的一个想法是——如果我们先用一个简单的形状代替复杂的多边形，会怎么样？毕竟我们使用的是网格方法，所以我们可以为每个多边形取一个边界框，然后过滤掉在我们的地方当局的边界框中至少有一个角的多边形。对熊猫来说，这既容易做到，也相对较快。当然有一个警告。还记得我们选择约克郡东区作为例子的特殊原因吗？该出牌了。事实上，它是围绕赫尔周围的踢脚线真的把事情弄糟了——整个城市最终将被包含在我们的边界框中。不酷。它有相当多的建筑物，所以我们最终不得不筛选我们的误报，并正确地检查它们与我们的多边形的交集。</p><p id="df01" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以先把我们的地方当局分割成一堆更小的多边形，然后再对它们进行搜索。事实上，在整个地图上使用这样的网格还有其他优点。它将允许我们以非常有效的方式搜索最近的邻居，而不必计算所有6.5毫米建筑多边形之间的距离。</p><p id="14f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这正是我们要做的。让我们从创建一个标准网格开始，它将跨越我们选择的地方当局。当然，我们可以使用整个英格兰或整个英国的大小，但是使用大小也会导致性能损失。我认为，如果我们想对所有事情进行归因，最好的方法是对每个县分别进行归因，然后合并结果。</p><p id="5cea" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">准备好了吗？</p><p id="7329" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们开始吧:</p><p id="861a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们获得跨越整个本地机构的边界框的坐标。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="9f01" class="kd ke hx jz b fi kf kg l kh ki">ery = la[<br/>    la['lad19nm'] == 'East Riding of Yorkshire'<br/>]['geometry'].iloc[0]<br/>xmin = ery.bounds[0]<br/>xmax = ery.bounds[2]<br/>ymin = ery.bounds[1]<br/>ymax = ery.bounds[3]<br/>xmin, xmax, ymin, ymax</span></pre><p id="ff57" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">得到</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a8fe" class="kd ke hx jz b fi kf kg l kh ki">(459323.7011000002, 542151.1449999996, 410360.27600000054, 476832.8973999992)</span></pre><p id="d255" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当然，我们不需要那么精确。事实上，值得记住的是，数据集并没有首先为我们提供这些，但我们会保持这种方式。不疼。但是，我们将在构建网格时删除它:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="eda5" class="kd ke hx jz b fi kf kg l kh ki">X, Y = np.mgrid[int(xmin): round(xmax, -3) + 2000: 2000,<br/>                int(ymin): round(ymax, -3) + 2000: 2000]</span></pre><p id="5c03" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您还没有遇到过numpy mgrid函数，我强烈建议您快速浏览一下文档并使用一些示例。简而言之，我们在这里所做的是创建一个数值网格，其跨度从<em class="js"> xmin </em>向下舍入到整数值到<em class="js"> xmax </em>舍入到最接近的1000，然后向上舍入到2000。我们网格的步长设置为2000。这可能有助于更好地理解它:<em class="js"> np.mgrid[ xmin : xmax : step，ymin : ymax : step ] </em></p><p id="5282" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">结果是在X分量和Y分量之间分割的坐标矩阵。</p><p id="75e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们有了网格，我们需要把它转换成正确的格式，为每个网格单元创建多边形。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7a82" class="kd ke hx jz b fi kf kg l kh ki">grid = list(<br/>            map(<br/>                list,<br/>                list(<br/>                    zip(<br/>                        list(<br/>                            zip(X.flatten(), Y.flatten())<br/>                        ),<br/>                        list(<br/>                            zip(X.flatten(), Y.flatten() + 2000)<br/>                        ),<br/>                        list(<br/>                            zip(X.flatten() + 2000, Y.flatten() + 2000)),<br/>                        list(<br/>                            zip(X.flatten() + 2000, Y.flatten())<br/>                        )<br/>                    )<br/>                )<br/>            )<br/>        )</span></pre><p id="bade" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们将矩阵展平成长列表，然后压缩成元组列表。我们重复四次——对我们正在构建的正方形的每个角重复一次，最后我们得到一个元组列表。有点拗口，我知道…基本上是一个预期多边形列表，其中每个元素都是一个角坐标列表。更清楚？没有吗？好吧…就在你的笔记本上玩玩它，获得一些直觉。</p><p id="9156" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是这个网格的前几个元素的样子:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="66e8" class="kd ke hx jz b fi kf kg l kh ki">[[(459323.0, 410360.0),<br/>  (459323.0, 412360.0),<br/>  (461323.0, 412360.0),<br/>  (461323.0, 410360.0)],<br/> [(459323.0, 412360.0),<br/>  (459323.0, 414360.0),<br/>  (461323.0, 414360.0),<br/>  (461323.0, 412360.0)],<br/> [(459323.0, 414360.0),<br/>  (459323.0, 416360.0),<br/>  (461323.0, 416360.0),<br/>  (461323.0, 414360.0)]...</span></pre><p id="b078" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们继续把它们转换成多边形。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="fbda" class="kd ke hx jz b fi kf kg l kh ki">from shapely.geometry import Polygon<br/>grid_poly = [Polygon(a) for a in grid]</span></pre><p id="05bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还有一步——这些覆盖了所有的边界框，我们特别想雕刻出尽可能接近我们原始形状的东西(例如，我们想去掉外壳)。在这种情况下，我们可以遍历它们，并检查与本地机构的交集:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="971a" class="kd ke hx jz b fi kf kg l kh ki">grid_poly = [a for a in grid_poly if a.intersects(ery)]</span></pre><p id="a346" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好了，我们快到了。我们已经有了多边形网格。我们如何有效地搜索这些信息？</p><p id="15f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">R-Trees来拯救。你可以在这里阅读它们<a class="ae jt" href="https://en.wikipedia.org/wiki/R-tree" rel="noopener ugc nofollow" target="_blank">，在这里</a>阅读它们的实现<a class="ae jt" href="https://shapely.readthedocs.io/en/latest/manual.html#str-packed-r-tree" rel="noopener ugc nofollow" target="_blank">。这个想法在原理上非常简单:我们将空间分成一堆矩形(在我们的例子中是正方形)，这些矩形被分组并映射到更大的边界矩形，等等。等等。我们的正方形是多边形树中的叶子，连接到小树枝，然后是大树枝，以此类推。因此，如果我们正在比较一个位于很远很远的地方的面，只需检查它是否属于不同的分支，然后就在那里停止检查。</a></p><p id="0323" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在要做的就是跑:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="510d" class="kd ke hx jz b fi kf kg l kh ki">from shapely.strtree import STRtree<br/>s = STRtree(grid_poly)</span></pre><p id="83c6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后—对我们的整个bd表进行检查(在我的笔记本电脑上，这大约需要35秒):</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="bbb9" class="kd ke hx jz b fi kf kg l kh ki">bd['grid'] = bd['geometry'].apply(lambda x: s.query(x))</span></pre><p id="defe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，熊猫设计师和纯粹主义者会在这一点上生气，因为我刚刚用列表填充了熊猫专栏，其中一些是空列表。是的，我知道，它不应该被这样使用。但是你知道吗？咬我！它完成了任务。</p><p id="d7a8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们来看看返回匹配项的记录:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a119" class="kd ke hx jz b fi kf kg l kh ki">bd_ery = bd[bd['grid'].apply(len) &gt; 0].reset_index(drop=True)</span></pre><p id="3e71" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从技术上讲，这里我们还应该运行类似于:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7881" class="kd ke hx jz b fi kf kg l kh ki">bd_ery['check'] = bd_ery['geometry'].swifter.apply(lambda x: x.intersects(ery))</span></pre><p id="e937" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">来检查一些接近边界的多边形，它们设法进入了我们的集合。然而，当我们在更大的范围内这样做时，我们可以跳过这一步来处理分别属于多个区域的多边形。这样会快很多。或者，我们可以识别边界网格多边形，并仅对与这些边界网格单元匹配的建筑物运行检查。</p><p id="5540" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们快速浏览一下数据集:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d912" class="kd ke hx jz b fi kf kg l kh ki">bd_ery.head()</span></pre><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kk"><img src="../Images/dc5110514e56b687986a7b59aed9e816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69GWY93MzFu43LVHT3Cy9w.png"/></div></div></figure><p id="633e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们能一起看吗？绝对的。虽然161K多边形可能不会被你的计算机普遍喜欢。我们去看看所有的住宅楼怎么样？</p><p id="ad27" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">记住，我们需要几何图形集合来将它们集合起来。让我们也添加实际的地方当局多边形，看看他们真的坐在对方的顶部。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="c256" class="kd ke hx jz b fi kf kg l kh ki">from shapely.geometry import GeometryCollection<br/>gc = GeometryCollection(<br/>    list(<br/>        bd_ery[<br/>            bd_ery['type'] == 'residential'<br/>        ]['geometry']<br/>    )+[ery]<br/>)<br/>gc</span></pre><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kl"><img src="../Images/2a9a6e6f6536a296334e351bd0b5d74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*4n4UvrG66xaAzmrnKmVWag.png"/></div></figure><p id="3013" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不是世界上最好的图形表示，但你可以在我们的地方当局多边形上看到一些更暗的小点。有一对夫妇坐在边界外面，所以我们也需要清理一下。</p><p id="33e1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但今天够了。</p><p id="c058" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们能用观想做得更好吗？绝对的。这正是我在下一篇文章中所要讨论的。敬请期待！</p></div></div>    
</body>
</html>