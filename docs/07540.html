<html>
<head>
<title>Basics for network communication in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中的网络通信基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basics-for-network-communication-on-python-af3f677af42c?source=collection_archive---------10-----------------------#2020-06-29">https://medium.com/analytics-vidhya/basics-for-network-communication-on-python-af3f677af42c?source=collection_archive---------10-----------------------#2020-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8d60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是一个在Pygame上制作一个在线乒乓球游戏，以及使用pickle制作你的后端和前端框架的教程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e3dafc0508d356ecc336bc5a87ac2d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urY5gucYctSz_vEd-4maXw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">经典的乒乓球</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/94ca6dc952dfa8b158a9227e0279e2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30RoLEq__QUzH-Y7NgPVAA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">网络游戏的流程</figcaption></figure><p id="d135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，当玩家1或玩家2移动他们的球拍时，他们会将球拍坐标发送到服务器，作为回报，他们会收到其他玩家的球拍位置和球的位置</p><p id="c589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始吧:</p><p id="cf77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，创建一个文件夹，在其中创建以下文件:</p><p id="20d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ball.py</p><p id="d49d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">main.py</p><p id="459e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">network.py</p><p id="5e3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">paddle.py</p><p id="bf7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记分牌. py</p><p id="6c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">server.py</p><p id="89db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并下载这些图片:</p><p id="3911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ju" href="https://github.com/Shubhaankar-sharma/ping-pong-online/blob/master/background.png?raw=true" rel="noopener ugc nofollow" target="_blank">背景</a></p><p id="f54c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ju" href="https://github.com/Shubhaankar-sharma/ping-pong-online/blob/master/pong.png?raw=true" rel="noopener ugc nofollow" target="_blank">图标</a></p><p id="758d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从编辑main.py文件开始</p><p id="cddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首次下载Pygame:</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="392a" class="ka kb hi jw b fi kc kd l ke kf">On CMD:<br/>pip install pygame</span></pre><p id="61d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在打开main.py:</p><p id="967b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并开始编写初始化屏幕的基本代码…现在我喜欢全屏，所以我使用了全屏选项，这是声明屏幕的高度，宽度变量的最佳实践，因此它是可调整大小的，而不是硬编码的…但为了本教程的缘故，我将使用全屏。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="1ed4" class="ka kb hi jw b fi kc kd l ke kf">import pygame<br/>import sys, os<br/>#now import the background<br/>#As i like to be safe i always import from os<br/>def resource_path(relative_path):<br/>        if hasattr(sys, '_MEIPASS'):<br/>            return os.path.join(sys._MEIPASS, relative_path)<br/>        return os.path.join(os.path.abspath("."), relative_path)</span><span id="c179" class="ka kb hi jw b fi kg kd l ke kf"># initialization (do this in every game pygame.init())<br/>pygame.init()</span><span id="717a" class="ka kb hi jw b fi kg kd l ke kf">#Declaring colors so that we don't have to set rgb values again<br/>BLACK = (0, 0, 0)<br/>WHITE = (255, 255, 255)<br/>RED = (255, 0, 0)<br/>BLUE = (0, 0, 255)</span><span id="bad5" class="ka kb hi jw b fi kg kd l ke kf"># creating a screen<br/>screen = pygame.display.set_mode((960, 720), pygame.DOUBLEBUF | pygame.FULLSCREEN)</span><span id="90c6" class="ka kb hi jw b fi kg kd l ke kf"># title and icon<br/>pygame.display.set_caption("Pong by shubhaankar")<br/>icon = pygame.image.load(resource_path('pong.png')) <br/>pygame.display.set_icon(icon)</span><span id="a1b4" class="ka kb hi jw b fi kg kd l ke kf"># background<br/>background = pygame.image.load(resource_path('background.png'))</span><span id="1e72" class="ka kb hi jw b fi kg kd l ke kf">#main game<br/>def main():<br/>     #initialization of game<br/>     clock =  pygame.time.Clock()  #FPS<br/>     running = True<br/>     pos = []   #list of positions of objects                             <br/>     #main game loop(always running)<br/>     while running:  <br/>         for event in pygame.event.get():<br/>              if event.type == pygame.KEYDOWN:<br/>                  if event.key == pygame.K_ESCAPE: ##Hit Esc to quit<br/>                          running = False<br/>         screen.blit(background, (0, 0))#refresh screen<br/>         pygame.display.flip()<br/>         clock.tick(120)     #FPS</span><span id="c7da" class="ka kb hi jw b fi kg kd l ke kf">main()<br/>pygame.quit()</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="f2b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在打开您创建的paddle.py文件…我们将在其中创建一个paddle类…</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="94f0" class="ka kb hi jw b fi kc kd l ke kf">import pygame<br/>RED = (0,0,0)<br/>class Paddle(pygame.sprite.Sprite):<br/>	def __init__(self,color,width,height):<br/>		super().__init__()</span><span id="145e" class="ka kb hi jw b fi kg kd l ke kf">self.image = pygame.Surface([width,height])<br/>		self.image.fill(RED)<br/>		self.image.set_colorkey(RED)</span><span id="4ba1" class="ka kb hi jw b fi kg kd l ke kf">#drawing the paddle<br/>		pygame.draw.rect(self.image,color,[0,0,width,height])<br/>		self.rect = self.image.get_rect()</span></pre><p id="443c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这基本上是做的是，我们从Pygame中的一个精灵类继承我们的桨…..(精灵对象是可以制作动画的对象)</p><p id="1e08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在init方法中，我们输入颜色、宽度、高度并绘制一个矩形…</p><p id="c31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你一定在想为什么我们要用精灵</p><p id="62a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好处是，当所有的精灵对象移动时，我们可以在一行代码中将它们添加到屏幕上，而对于单独的类，我们必须分别添加它们。</p><p id="9e6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将添加以下功能:向上移动，向下移动，和用键划水移动。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="ab92" class="ka kb hi jw b fi kc kd l ke kf">def moveUp(self,pixels):<br/>		self.rect.y -= pixels<br/>		#to check if the paddle does not go off the screen<br/>		if self.rect.y &lt; 0 :<br/>			self.rect.y = 0<br/>	def moveDown(self,pixels):<br/>		self.rect.y += pixels<br/>		#to check if the paddle does not go off the screen<br/>		if self.rect.y &gt; 620 :<br/>			self.rect.y = 620<br/>	def paddle_movement(self):<br/>			keys = pygame.key.get_pressed()<br/>			# Player A<br/>			if keys[pygame.K_UP]:<br/>				self.moveUp(15)<br/>			if keys[pygame.K_DOWN]:<br/>				self.moveDown(15)</span></pre><p id="5c84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是不言自明的…当移动时，你将减少y坐标，反之亦然</p><p id="e99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是paddle.py文件的完整代码:</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="2d51" class="ka kb hi jw b fi kc kd l ke kf">import pygame<br/>RED = (0,0,0)<br/>class Paddle(pygame.sprite.Sprite):<br/>	def __init__(self,color,width,height):<br/>		super().__init__()</span><span id="c6c3" class="ka kb hi jw b fi kg kd l ke kf">self.image = pygame.Surface([width,height])<br/>		self.image.fill(RED)<br/>		self.image.set_colorkey(RED)</span><span id="dd37" class="ka kb hi jw b fi kg kd l ke kf">#drawing the paddle<br/>		pygame.draw.rect(self.image,color,[0,0,width,height])<br/>		self.rect = self.image.get_rect()<br/>	def moveUp(self,pixels):<br/>		self.rect.y -= pixels<br/>		#to check if the paddle does not go off the screen<br/>		if self.rect.y &lt; 0 :<br/>			self.rect.y = 0<br/>	def moveDown(self,pixels):<br/>		self.rect.y += pixels<br/>		#to check if the paddle does not go off the screen<br/>		if self.rect.y &gt; 620 :<br/>			self.rect.y = 620<br/>	def paddle_movement(self):<br/>			keys = pygame.key.get_pressed()<br/>			# Player A<br/>			if keys[pygame.K_UP]:<br/>				self.moveUp(15)<br/>			if keys[pygame.K_DOWN]:<br/>				self.moveDown(15)</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="6202" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们将在ball.py文件中创建一个ball类</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="e3be" class="ka kb hi jw b fi kc kd l ke kf">import pygame<br/>from random import randint<br/>BLACK = (0,0,0)<br/>class Ball(pygame.sprite.Sprite):<br/>	def __init__(self,color,width,height,v,u):<br/>		super().__init__()</span><span id="e301" class="ka kb hi jw b fi kg kd l ke kf">self.image = pygame.Surface([width,height])<br/>		self.image.fill(BLACK)<br/>		self.image.set_colorkey(BLACK)</span><span id="e57a" class="ka kb hi jw b fi kg kd l ke kf">#drawing the ball<br/>		pygame.draw.rect(self.image,color,[0,0,width,height])<br/>		self.rect = self.image.get_rect()</span><span id="e504" class="ka kb hi jw b fi kg kd l ke kf">self.velocity = [v,u]</span><span id="3ace" class="ka kb hi jw b fi kg kd l ke kf"># Fetch the rectangle object that has the dimensions #of the image.<br/>		self.rect = self.image.get_rect()</span></pre><p id="14e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这几乎和桨一样，除了我们取球的初速度…</p><p id="2190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将添加球的运动:</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="856a" class="ka kb hi jw b fi kc kd l ke kf">def update(self):<br/>	        self.rect.x += self.velocity[0]<br/>	        self.rect.y += self.velocity[1]</span><span id="edb3" class="ka kb hi jw b fi kg kd l ke kf">def bounce(self):<br/>		self.velocity[0] = -self.velocity[0]<br/>		self.velocity[1] = randint(-8, 8)</span></pre><p id="39f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这仅仅是更新球的速度，(速度已经以类似于运动学中的向量的格式声明)并且当被调用时反弹函数通过改变方向来反弹球(就像光线从表面反弹)。</p><p id="92b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将确定球、球拍和边界之间的碰撞…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ko"><img src="../Images/f4c022555fef78093f3b8814f703477c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPpjtnDjwTpJCG-C7RYGDg.png"/></div></div></figure><p id="c9be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个图表将解释拍球的机制</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="f597" class="ka kb hi jw b fi kc kd l ke kf">def movement(self,player,p2,scoreA,scoreB):<br/>		if self.rect.x &gt;= 950:<br/>			scoreA += 1<br/>			self.velocity[0] = -self.velocity[0]<br/>		if self.rect.x &lt;= 0:<br/>			scoreB += 1<br/>			self.velocity[0] = -self.velocity[0]<br/>		if self.rect.y &gt; 710:<br/>			self.velocity[1] = -self.velocity[1]<br/>		if self.rect.y &lt; 0:<br/>			self.velocity[1] = -self.velocity[1]<br/>		if pygame.sprite.collide_mask(self, player) or pygame.sprite.collide_mask(self, p2):<br/>			self.velocity[0] = -self.velocity[0]<br/>			self.velocity[1] = self.velocity[1]</span></pre><p id="98e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在这决定了碰撞是否发生，如果碰撞发生了，我们就改变速度并反弹回来…</p><p id="a060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有使用我们之前定义的反弹函数，好像我们调用这个函数每个球员的系统都可以取一个不同的随机整数，并改变球的路线…</p><p id="bd85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你会问是什么阻止了球只在x轴上运动…我们马上就会看到这将如何发生…</p><p id="92e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码行中，我们采用不同的桨，分数，然后调用它们的属性或特性，如速度、位置、高度、宽度来检查碰撞。现在，我已经硬编码了边框和拨片，但是你可以尝试添加一个屏幕属性，然后调用screen.x或screen.y，然后尝试做同样的事情。</p><p id="eefc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在整个ball.py代码:</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="5765" class="ka kb hi jw b fi kc kd l ke kf">import pygame<br/>from random import randint<br/>BLACK = (0,0,0)<br/>class Ball(pygame.sprite.Sprite):<br/>	def __init__(self,color,width,height,v,u):<br/>		super().__init__()<br/></span><span id="5bd4" class="ka kb hi jw b fi kg kd l ke kf">		self.image = pygame.Surface([width,height])<br/>		self.image.fill(BLACK)<br/>		self.image.set_colorkey(BLACK)</span><span id="a95c" class="ka kb hi jw b fi kg kd l ke kf">		#drawing the ball<br/>		pygame.draw.rect(self.image,color,[0,0,width,height])<br/>		self.rect = self.image.get_rect()<br/></span><span id="d793" class="ka kb hi jw b fi kg kd l ke kf">		self.velocity = [v,u]</span><span id="93e4" class="ka kb hi jw b fi kg kd l ke kf">		# Fetch the rectangle object that has the dimensions of the image.<br/>		self.rect = self.image.get_rect()<br/></span><span id="5fed" class="ka kb hi jw b fi kg kd l ke kf">	def update(self):<br/>			self.rect.x += self.velocity[0]<br/>			self.rect.y += self.velocity[1]</span><span id="cfd5" class="ka kb hi jw b fi kg kd l ke kf">	def bounce(self):<br/>		self.velocity[0] = -self.velocity[0]<br/>		self.velocity[1] = randint(-8, 8)</span><span id="7359" class="ka kb hi jw b fi kg kd l ke kf">	def movement(self,player,p2,scoreA,scoreB):<br/>		if self.rect.x &gt;= 950:<br/>			scoreA += 1<br/>			self.velocity[0] = -self.velocity[0]<br/>		if self.rect.x &lt;= 0:<br/>			scoreB += 1<br/>			self.velocity[0] = -self.velocity[0]<br/>		if self.rect.y &gt; 710:<br/>			self.velocity[1] = -self.velocity[1]<br/>		if self.rect.y &lt; 0:<br/>			self.velocity[1] = -self.velocity[1]<br/>		if pygame.sprite.collide_mask(self, player) or pygame.sprite.collide_mask(self, p2):<br/>			self.velocity[0] = -self.velocity[0]<br/>			self.velocity[1] = self.velocity[1]</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="684a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在打开Network.py</p><p id="d373" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将定义一些函数，我们的客户端将使用这些函数与服务器进行通信。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="1821" class="ka kb hi jw b fi kc kd l ke kf">import socket<br/>import pickle<br/></span><span id="d80c" class="ka kb hi jw b fi kg kd l ke kf">class Network:<br/>    def __init__(self): ##this will connect to the server initially<br/>        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>        self.server = '192.168.1.3' #server ip #&lt;---<br/>        self.port = 5555   #server port #&lt;---<br/>        self.addr = (self.server, self.port)<br/>        self.p = self.connect()<br/></span><span id="9ef7" class="ka kb hi jw b fi kg kd l ke kf">    def getP(self):<br/>        return self.p</span><span id="f083" class="ka kb hi jw b fi kg kd l ke kf">    def connect(self):<br/>        try:<br/>            self.client.connect(self.addr)<br/>            return pickle.loads(self.client.recv(2048))<br/>        except:<br/>            pass</span><span id="4e2c" class="ka kb hi jw b fi kg kd l ke kf">    def send(self, data):<br/>        try:<br/>            self.client.send(pickle.dumps(data))<br/>            return pickle.loads(self.client.recv(2048))<br/>        except socket.error as e:<br/>            print(e)</span></pre><p id="5dd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这主要是语法…这里我们最初与服务器连接，并通过python类Pickle发送我们的初始数据，您可以在文档中阅读用法…</p><p id="2743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些功能基本上执行以下操作:</p><p id="4842" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">getP仅用于在服务器发送数据时从服务器接收数据</p><p id="a927" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发送功能是发送数据和从服务器接收数据，正如我们之前所说的…</p><p id="38d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这一切都结束了…</p><p id="ad71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:根据您的需要更改IP和端口，我建议您在测试时可以检查您机器的本地IPV4地址，它可能有点像192.168.0.1</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="51c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将打开server.py脚本并开始在其中编码…</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="203f" class="ka kb hi jw b fi kc kd l ke kf">import socket<br/>from _thread import *<br/>from random import randint<br/>import sys</span><span id="412a" class="ka kb hi jw b fi kg kd l ke kf">import pickle<br/></span><span id="bab0" class="ka kb hi jw b fi kg kd l ke kf">BLACK = (0, 0, 0)<br/>WHITE = (255, 255, 255)<br/>RED = (255, 0, 0)<br/>BLUE = (0, 0, 255)</span><span id="bf06" class="ka kb hi jw b fi kg kd l ke kf">server = '192.168.1.3'<br/>port = 5555<br/>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><span id="4c7f" class="ka kb hi jw b fi kg kd l ke kf">try:<br/>    s.bind((server, port))<br/></span><span id="9e3c" class="ka kb hi jw b fi kg kd l ke kf">except socket.error as e:<br/>    str(e)</span><span id="b27f" class="ka kb hi jw b fi kg kd l ke kf">s.listen()<br/>print("Waiting For a connection, Server Started")</span></pre><p id="d6a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也只是基本的连接性内容，我们试图绑定在一个开放端口上，通常web服务器运行在8000或8001上，但由于我们只运行一个脚本…为了避免错误或传入连接，我们使用5555</p><p id="73ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">s.listen()打开连接端口</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="3e19" class="ka kb hi jw b fi kc kd l ke kf">v,y = randint(4, 8), randint(-8, 8)<br/>while y ==0:<br/>    y = randint(-8,8)</span></pre><p id="bf0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前一段代码下面写下:</p><p id="6194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这基本上是从服务器端声明球的速度，以便两个客户端接收相同的球速度。</p><p id="9aa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我之前提到的，我们要做的是，防止球侧向移动，我们将运行一个while循环，如果y速度为零，我们将再次产生y速度</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="6f2d" class="ka kb hi jw b fi kc kd l ke kf">players = [  [ [BLUE, 20, 90],[70,300],[v,y] ]   ,[ [BLUE, 20, 90], [870,300], [v,y] ]   ]</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/a8d151d700b369a3a30c2ffc7dc7008a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsjVfEn2C9XWotEuyA9uBQ.png"/></div></div></figure><p id="fe32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在列表中，玩家[0]是玩家1，玩家[1]是玩家2</p><p id="8ddb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该流程图解释了列表的信息流程</p><p id="01de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个球员名单有三个组成部分:</p><ol class=""><li id="9c71" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">桨的颜色、长度、宽度</li><li id="1bd0" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">x，y位置</li><li id="27c5" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">球的速度</li></ol><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="a89d" class="ka kb hi jw b fi kc kd l ke kf"># When Player initialy connects<br/>def threaded_client(conn, player):<br/>    conn.send(pickle.dumps(players[player]))<br/>    reply = ''<br/>    while True:<br/>        try:<br/>            data = pickle.loads(conn.recv(2048))<br/>            players[player][1] = data[0]</span><span id="3b69" class="ka kb hi jw b fi kg kd l ke kf">            if not data:<br/>                print("Disconnected")<br/>                break</span><span id="0f03" class="ka kb hi jw b fi kg kd l ke kf">            else:<br/>                if player == 1:<br/>                    reply = players[0][1]</span><span id="161c" class="ka kb hi jw b fi kg kd l ke kf">                else:<br/>                    reply = players[1][1]</span><span id="0247" class="ka kb hi jw b fi kg kd l ke kf">                print("Recieved: ", data)<br/>                print("Sending:", reply)<br/>            conn.sendall(pickle.dumps(reply))<br/>        except:<br/>            break</span><span id="3a22" class="ka kb hi jw b fi kg kd l ke kf">    print("Lost Connection")<br/>    conn.close()</span></pre><p id="769c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这是非常简单的，当一个玩家连接服务器时，服务器根据玩家编号给玩家发送列表，然后它进入一个循环，当它接收到玩家列表时，它附加列表，然后它发送回其他玩家的列表</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="c573" class="ka kb hi jw b fi kc kd l ke kf">currentPlayer = 0<br/>total = []<br/>lst = []<br/>while True:<br/>    conn, addr = s.accept()<br/>    print("Connected to:", addr)<br/>    total.append(addr)<br/>    lst.append(conn)<br/>    lst.append(addr)<br/></span><span id="d438" class="ka kb hi jw b fi kg kd l ke kf">    if len(total) &gt;1:<br/>        conn_1 = lst[0]<br/>        addr_1 = lst[1]<br/>        conn_2 = lst[2]<br/>        addr_2 = lst[3]<br/>        print(len(total))<br/>        start_new_thread(threaded_client, (conn_1, currentPlayer))<br/>        currentPlayer += 1<br/>        start_new_thread(threaded_client, (conn_2, currentPlayer))</span></pre><p id="a390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将第一个玩家声明为0，因此我们可以使用players[0]来发送各自的玩家列表，同样，第二个玩家将为1，因此我们将发送players[1]。</p><p id="342c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们放了一个if语句，这样我们就可以在两个玩家连接的时候开始发送信息，否则如果第一个玩家连接，他的游戏就会开始，球就会失控。</p><p id="8ab4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这基本上只是为我们上面声明的不同播放器启动了两个线程…</p><p id="547a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，整个server.py脚本</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="b238" class="ka kb hi jw b fi kc kd l ke kf">import socket<br/>from _thread import *<br/>from random import randint<br/>import sys</span><span id="4667" class="ka kb hi jw b fi kg kd l ke kf">import pickle<br/></span><span id="d1ca" class="ka kb hi jw b fi kg kd l ke kf">BLACK = (0, 0, 0)<br/>WHITE = (255, 255, 255)<br/>RED = (255, 0, 0)<br/>BLUE = (0, 0, 255)</span><span id="cb04" class="ka kb hi jw b fi kg kd l ke kf">server = '192.168.1.3'<br/>port = 5555<br/>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><span id="855f" class="ka kb hi jw b fi kg kd l ke kf">try:<br/>    s.bind((server, port))<br/></span><span id="e967" class="ka kb hi jw b fi kg kd l ke kf">except socket.error as e:<br/>    str(e)</span><span id="eecc" class="ka kb hi jw b fi kg kd l ke kf">s.listen()<br/>print("Waiting For a connection, Server Started")<br/>v,y = randint(4, 8), randint(-8, 8)<br/>while y ==0:<br/>    y = randint(-8,8)<br/>l = randint(-8,8)<br/>players = [[[BLUE, 20, 90],[70,300],[v,y]],[ [BLUE, 20, 90],[870,300],[v,y]]]<br/></span><span id="32c4" class="ka kb hi jw b fi kg kd l ke kf"># When Player initialy connects<br/>def threaded_client(conn, player):<br/>    conn.send(pickle.dumps(players[player]))<br/>    reply = ''<br/>    while True:<br/>        try:<br/>            data = pickle.loads(conn.recv(2048))<br/>            players[player][1] = data[0]</span><span id="e720" class="ka kb hi jw b fi kg kd l ke kf">            if not data:<br/>                print("Disconnected")<br/>                break</span><span id="ef7f" class="ka kb hi jw b fi kg kd l ke kf">            else:<br/>                if player == 1:<br/>                    reply = players[0][1]</span><span id="1185" class="ka kb hi jw b fi kg kd l ke kf">                else:<br/>                    reply = players[1][1]</span><span id="78a4" class="ka kb hi jw b fi kg kd l ke kf">                print("Recieved: ", data)<br/>                print("Sending:", reply)<br/>            conn.sendall(pickle.dumps(reply))<br/>        except:<br/>            break</span><span id="7af0" class="ka kb hi jw b fi kg kd l ke kf">    print("Lost Connection")<br/>    conn.close()<br/></span><span id="c4f6" class="ka kb hi jw b fi kg kd l ke kf">currentPlayer = 0<br/>total = []<br/>lst = []<br/>while True:<br/>    conn, addr = s.accept()<br/>    print("Connected to:", addr)<br/>    total.append(addr)<br/>    lst.append(conn)<br/>    lst.append(addr)<br/></span><span id="f8a9" class="ka kb hi jw b fi kg kd l ke kf">    if len(total) &gt;1:<br/>        conn_1 = lst[0]<br/>        addr_1 = lst[1]<br/>        conn_2 = lst[2]<br/>        addr_2 = lst[3]<br/>        print(len(total))<br/>        start_new_thread(threaded_client, (conn_1, currentPlayer))<br/>        currentPlayer += 1<br/>        start_new_thread(threaded_client, (conn_2, currentPlayer))</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="17fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将打开记分板文件并添加一个记分板</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="44af" class="ka kb hi jw b fi kc kd l ke kf">import pygame</span><span id="2a94" class="ka kb hi jw b fi kg kd l ke kf">def score(Ball, screen, WHITE, score_A,score_B ):<br/></span><span id="4dc3" class="ka kb hi jw b fi kg kd l ke kf">            font = pygame.font.Font(None, 74)<br/>            text = font.render(str(score_A), 1, WHITE)<br/>            screen.blit(text, (250, 10))<br/>            text = font.render(str(score_B), 1, WHITE)<br/>            screen.blit(text, (710, 10))</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="17f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">咻！！！</p><p id="1d65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在最后一部分将在main.py脚本中</p><p id="b88d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里我们将添加球员和球，并使用网络模块</p><p id="d7da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要在main.py文件中进行一些导入</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="2660" class="ka kb hi jw b fi kc kd l ke kf">from paddle import Paddle<br/>from ball import Ball<br/>from network import Network<br/>from scoreboard import score</span></pre><p id="0dda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将声明一个精灵列表</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="dec0" class="ka kb hi jw b fi kc kd l ke kf">sprites_lists = pygame.sprite.Group()</span></pre><p id="b1d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我正在重新编写整个main函数，然后我会解释它:</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="6ee2" class="ka kb hi jw b fi kc kd l ke kf">def main():<br/>        clock =  pygame.time.Clock()<br/>        scoreA = 0<br/>        scoreB = 0<br/>        running = True<br/>        n = Network()<br/>        pos = []</span><span id="0161" class="ka kb hi jw b fi kg kd l ke kf">        while n.getP() is None:<br/>            _ = 0<br/>        player_1_list = n.getP()<br/>        P = Paddle(player_1_list[0][0],player_1_list[0][1],player_1_list[0][2])</span><span id="a123" class="ka kb hi jw b fi kg kd l ke kf">        P.rect.x = player_1_list[1][0]<br/>        P.rect.y = player_1_list[1][1]<br/>        pos.append(player_1_list[1])<br/>        p2 = Paddle(RED, 20, 90)<br/>        sprites_lists.add(P)<br/>        sprites_lists.add(p2)</span><span id="b86b" class="ka kb hi jw b fi kg kd l ke kf">        ball = Ball(WHITE, 20, 20,player_1_list[2][0],player_1_list[2][1])<br/>        ball.rect.x = 472<br/>        ball.rect.y = 350<br/>        sprites_lists.add(ball)<br/>        while running:<br/></span><span id="bd8e" class="ka kb hi jw b fi kg kd l ke kf">                    p2_pos = n.send(pos)<br/>                    print(p2_pos)<br/>                    if type(p2_pos) == list:<br/>                        p2.rect.x = p2_pos[0]<br/>                        p2.rect.y = p2_pos[1]<br/>                    for event in pygame.event.get():</span><span id="30c2" class="ka kb hi jw b fi kg kd l ke kf">                        if event.type == pygame.KEYDOWN:<br/>                            if event.key == pygame.K_ESCAPE:<br/>                                running = False</span><span id="dd8d" class="ka kb hi jw b fi kg kd l ke kf">                    P.paddle_movement()</span><span id="2982" class="ka kb hi jw b fi kg kd l ke kf">                    ball.movement(P, p2, scoreA, scoreB)<br/>                    if ball.rect.x &gt;= 950:<br/>                        scoreA += 1<br/>                    if ball.rect.x &lt;= 0:<br/>                        scoreB += 1<br/>                    sprites_lists.update()</span><span id="e7f3" class="ka kb hi jw b fi kg kd l ke kf">                    screen.blit(background, (0, 0))<br/>                    sprites_lists.draw(screen)<br/>                    # Score<br/>                    pos = [[P.rect.x,P.rect.y]]</span><span id="ee09" class="ka kb hi jw b fi kg kd l ke kf">                    score(ball,screen,WHITE,scoreA,scoreB)<br/>                    pygame.display.flip()<br/>                    clock.tick(120)</span></pre><p id="fae0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们基本上只是用0初始化得分a和b</p><p id="be97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们调用网络方法来初始化我们与服务器的连接</p><p id="6255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们还初始化了一个pos列表，在那里我们将存储我们的桨的速度，并将接收其他人的速度</p><p id="59b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们使用getP函数，它将给出我们的初始属性</p><p id="a32e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，当getP为空时，我们等待，直到另一个玩家没有连接</p><p id="c91e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们调用球拍，球类，并把我们从服务器收到的信息提供给他们</p><p id="89b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对手永远是红色的</p><p id="a036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在将所有的桨球添加到精灵列表中</p><p id="bf23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在主循环中，我们发送我们的信息并接收其他玩家的信息，我们将这些信息提供给我们在本地声明的对手的球拍</p><p id="2b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们调用桨移动函数，这样我们就可以移动我们的桨了</p><p id="cf29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们说，如果球到了一个球员的边界，那么给另一个球员得分</p><p id="d33c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们只是刷新屏幕来显示运动</p><p id="a0d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们用我们改变的速度重新声明列表</p><p id="695b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及显示分数</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="a382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码已经完成，现在你可以运行服务器脚本，然后运行main.py脚本，或者在同一台机器上运行一个脚本，在另一台机器上运行一个脚本，然后享受游戏</p><p id="934d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道这个代码有错误，因为我没有通过服务器发送整个类，代码本来可以更干净，但为了解决基本问题，这是一个好的开始。</p></div></div>    
</body>
</html>