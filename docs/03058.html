<html>
<head>
<title>TensorFlow Lite on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的TensorFlow Lite</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tensorflow-lite-on-android-4ba47742a67f?source=collection_archive---------17-----------------------#2020-01-14">https://medium.com/analytics-vidhya/tensorflow-lite-on-android-4ba47742a67f?source=collection_archive---------17-----------------------#2020-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="fb09" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">TensorFlow Lite？</h1><p id="b486" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">TensorFlow Lite是一套帮助开发人员在移动、嵌入式和物联网设备上运行TensorFlow模型的工具。它支持设备上的机器学习推理，具有低延迟和小二进制大小。</p><p id="5498" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它目前通过C++ API在Android和iOS上得到支持，并为Android开发者提供了一个Java包装器。此外，在支持它的Android设备上，解释器也可以使用Android神经网络API进行硬件加速，否则它将默认由CPU执行。在本文中，我将重点介绍如何在Android应用程序中使用它。</p><p id="32fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> TensorFlow Lite由两个主要组件组成:</strong></p><ul class=""><li id="9aea" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated"><a class="ae kp" href="https://www.tensorflow.org/lite/guide/inference" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite解释器</a>，它在许多不同的硬件类型上运行特别优化的模型，包括手机、嵌入式Linux设备和微控制器。</li><li id="72f6" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><a class="ae kp" href="https://www.tensorflow.org/lite/convert/index" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite converter </a>，它将TensorFlow模型转换成高效的形式供解释器使用，并可以引入优化来提高二进制大小和性能。</li></ul><p id="1e06" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这些是关于缩写的细节</p><ul class=""><li id="a717" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated"><em class="kv">延迟:</em>没有到服务器的往返</li><li id="fd3d" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><em class="kv">隐私:</em>没有数据需要离开设备</li><li id="4346" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><em class="kv">连接:</em>不需要互联网连接</li><li id="da35" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><em class="kv">功耗:</em>网络连接非常耗电</li></ul><p id="1082" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面我将分享如何在Android项目中实现和使用<strong class="jf hj">tensor flow</strong>s<strong class="jf hj">library lite</strong>。</p><p id="00f7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">注意→在阅读下面的代码之前，你可以查看github链接</strong><a class="ae kp" href="https://github.com/amitshekhariitbhu/Android-TensorFlow-Lite-Example" rel="noopener ugc nofollow" target="_blank"><strong class="jf hj">https://github . com/amitshekharitbhu/Android-TensorFlow-Lite-Example</strong></a><strong class="jf hj">关于tensor flow的Lite实现，我也关注了他的链接。这是github中一个最好的维护项目。</strong></p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es kw"><img src="../Images/ab0058e0cc17e02dfba50eabe48a1aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*ULJO3_AH-tomcl-NoOCtlw.jpeg"/></div></figure><p id="7675" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">步骤一。添加依赖关系</strong></p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="a2fc" class="lj ig hi lf b fi lk ll l lm ln">dependencies {<br/>    implementation 'org.tensorflow:tensorflow-lite:0.0.0-nightly'<br/>}</span></pre><p id="5670" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">第二步。</strong>(可选)为了实现<code class="du lo lp lq lf b">x86</code>、<code class="du lo lp lq lf b">x86_64</code>和<code class="du lo lp lq lf b">arm32</code> ABIs，在你的gradle中添加下面的依赖项。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="74df" class="lj ig hi lf b fi lk ll l lm ln">android {<br/>    defaultConfig {<br/>        ndk {<br/>            abiFilters 'armeabi-v7a', 'arm64-v8a'<br/>        }<br/>    }<br/>}</span></pre><p id="f987" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">步骤3 - &gt; </strong>为摄像机视图创建布局<em class="kv">activity _</em>tensor flow<em class="kv">。xml </em></p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="2264" class="lj ig hi lf b fi lk ll l lm ln">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:id="@+id/activity_main"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:paddingBottom="@dimen/activity_vertical_margin"<br/>    android:paddingLeft="@dimen/activity_horizontal_margin"<br/>    android:paddingRight="@dimen/activity_horizontal_margin"<br/>    android:paddingTop="@dimen/activity_vertical_margin"<br/>    tools:context="com.example.myapp.tancerflow.TenserFlowActivity"&gt;<br/><br/>    &lt;com.wonderkiln.camerakit.CameraView<br/>        android:id="@+id/cameraView"<br/>        android:layout_width="300dp"<br/>        android:layout_height="300dp"<br/>        android:layout_gravity="center|top" /&gt;<br/><br/><br/>    &lt;LinearLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="80dp"<br/>        android:layout_gravity="center|top"<br/>        android:layout_marginTop="300dp"<br/>        android:gravity="center"<br/>        android:orientation="horizontal"&gt;<br/><br/>        &lt;ImageView<br/>            android:id="@+id/imageViewResult"<br/>            android:layout_width="75dp"<br/>            android:layout_height="75dp"<br/>            android:padding="2dp" /&gt;<br/><br/>        &lt;TextView<br/>            android:id="@+id/textViewResult"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="80dp"<br/>            android:fadeScrollbars="false"<br/>            android:gravity="center"<br/>            android:maxLines="15"<br/>            android:scrollbars="vertical"<br/>            android:textColor="@android:color/black" /&gt;<br/><br/>    &lt;/LinearLayout&gt;<br/><br/><br/>    &lt;Button<br/>        android:id="@+id/btnToggleCamera"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="48dp"<br/>        android:layout_gravity="bottom|center"<br/>        android:layout_marginBottom="50dp"<br/>        android:text="toggle_camera"<br/>        android:textAllCaps="false"<br/>        android:textColor="@android:color/black" /&gt;<br/><br/>    &lt;Button<br/>        android:id="@+id/btnDetectObject"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="48dp"<br/>        android:layout_gravity="bottom|center"<br/>        android:text="detect_object"<br/>        android:textAllCaps="false"<br/>        android:textColor="@android:color/black"<br/>        android:visibility="gone" /&gt;<br/><br/>&lt;/FrameLayout&gt;</span></pre><p id="e05a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">注</strong> →在你的项目中实现gradle的从属摄像机视图</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="5eb5" class="lj ig hi lf b fi lk ll l lm ln">implementation 'com.wonderkiln:camerakit:0.13.1'</span></pre><p id="db30" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">步骤4 → </strong>在你的assets文件夹中添加<em class="kv">mobilenet _ quant _ v1 _ 224 . tflite文件。</em></p><p id="2925" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要下载文件，请查看github<a class="ae kp" href="https://github.com/amitshekhariitbhu/Android-TensorFlow-Lite-Example/tree/master/app/src/main/assets" rel="noopener ugc nofollow" target="_blank">https://github . com/amitshekharitbhu/Android-tensor flow-Lite-Example/tree/master/app/src/main/assets</a></p><p id="9e39" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">第五步→ </strong>创建一个<strong class="jf hj"> TensorFlowActivity.class </strong>并在modelPath处给出tflite文件的正确路径。</p><p id="6689" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面全班应该是这样的</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="3596" class="lj ig hi lf b fi lk ll l lm ln">public class <strong class="lf hj">TensorFlowActivity </strong>extends AppCompatActivity {<br/><br/>    private static final String <em class="kv">MODEL_PATH </em>= "mobilenet_quant_v1_224.tflite";<br/>    private static final boolean <em class="kv">QUANT </em>= true;<br/>    private static final String <em class="kv">LABEL_PATH </em>= "labels.txt";<br/>    private static final int <em class="kv">INPUT_SIZE </em>= 224;<br/><br/>    private Classifier classifier;<br/><br/>    private Executor executor = Executors.<em class="kv">newSingleThreadExecutor</em>();<br/>    private TextView textViewResult;<br/>    private Button btnDetectObject, btnToggleCamera;<br/>    private ImageView imageViewResult;<br/>    private CameraView cameraView;<br/><br/>    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        setContentView(R.layout.<em class="kv">activity_tesnsorflow</em>);<br/>        cameraView = findViewById(R.id.<em class="kv">cameraView</em>);<br/>        imageViewResult = findViewById(R.id.<em class="kv">imageViewResult</em>);<br/>        textViewResult = findViewById(R.id.<em class="kv">textViewResult</em>);<br/>        textViewResult.setMovementMethod(new ScrollingMovementMethod());<br/><br/>        btnToggleCamera = findViewById(R.id.<em class="kv">btnToggleCamera</em>);<br/>        btnDetectObject = findViewById(R.id.<em class="kv">btnDetectObject</em>);<br/><br/>        cameraView.addCameraKitListener(new CameraKitEventListener() {<br/>            @Override<br/>            public void onEvent(CameraKitEvent cameraKitEvent) {<br/><br/>            }<br/><br/>            @Override<br/>            public void onError(CameraKitError cameraKitError) {<br/><br/>            }<br/><br/>            @Override<br/>            public void onImage(CameraKitImage cameraKitImage) {<br/><br/>                Bitmap bitmap = cameraKitImage.getBitmap();<br/><br/>                bitmap = Bitmap.<em class="kv">createScaledBitmap</em>(bitmap, <em class="kv">INPUT_SIZE</em>, <em class="kv">INPUT_SIZE</em>, false);<br/><br/>                imageViewResult.setImageBitmap(bitmap);<br/><br/>                final List&lt;Classifier.Recognition&gt; results = classifier.recognizeImage(bitmap);<br/><br/>                textViewResult.setText(results.toString());<br/><br/>            }<br/><br/>            @Override<br/>            public void onVideo(CameraKitVideo cameraKitVideo) {<br/><br/>            }<br/>        });<br/><br/>        btnToggleCamera.setOnClickListener(new View.OnClickListener() {<br/>            @Override<br/>            public void onClick(View v) {<br/>                cameraView.toggleFacing();<br/>            }<br/>        });<br/><br/>        btnDetectObject.setOnClickListener(new View.OnClickListener() {<br/>            @Override<br/>            public void onClick(View v) {<br/>                cameraView.captureImage();<br/>            }<br/>        });<br/><br/>        initTensorFlowAndLoadModel();<br/>    }<br/><br/>    @Override<br/>    protected void onResume() {<br/>        super.onResume();<br/>        cameraView.start();<br/>    }<br/><br/>    @Override<br/>    protected void onPause() {<br/>        cameraView.stop();<br/>        super.onPause();<br/>    }<br/><br/>    @Override<br/>    protected void onDestroy() {<br/>        super.onDestroy();<br/>        executor.execute(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                classifier.close();<br/>            }<br/>        });<br/>    }<br/><br/>    private void initTensorFlowAndLoadModel() {<br/>        executor.execute(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                try {<br/>                    classifier = TensorFlowImageClassifier.<em class="kv">create</em>(<br/>                            getAssets(),<br/>                            <em class="kv">MODEL_PATH</em>,<br/>                            <em class="kv">LABEL_PATH</em>,<br/>                            <em class="kv">INPUT_SIZE</em>,<br/>                            <em class="kv">QUANT</em>);<br/>                    makeButtonVisible();<br/>                } catch (final Exception e) {<br/>                    throw new RuntimeException("Error initializing TensorFlow!", e);<br/>                }<br/>            }<br/>        });<br/>    }<br/><br/>    private void makeButtonVisible() {<br/>        runOnUiThread(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                btnDetectObject.setVisibility(View.<em class="kv">VISIBLE</em>);<br/>            }<br/>        });<br/>    }<br/>}</span></pre><p id="6059" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">步骤6 → </strong>创建一个类TensorFlowImageClassifier.class进行图像处理，获取图像的信息。</p><p id="b375" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意-要获得关于图像的信息，你只需要调用Interpeter的run方法，并传递图像数据和标签数组。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="935c" class="lj ig hi lf b fi lk ll l lm ln">interpreter.run(byteBuffer, result);</span></pre><p id="f62a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是完整的代码。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="320a" class="lj ig hi lf b fi lk ll l lm ln">public class TensorFlowImageClassifier implements Classifier {<br/><br/>    private static final int <em class="kv">MAX_RESULTS </em>= 3;<br/>    private static final int <em class="kv">BATCH_SIZE </em>= 1;<br/>    private static final int <em class="kv">PIXEL_SIZE </em>= 3;<br/>    private static final float <em class="kv">THRESHOLD </em>= 0.1f;<br/><br/>    private static final int <em class="kv">IMAGE_MEAN </em>= 128;<br/>    private static final float <em class="kv">IMAGE_STD </em>= 128.0f;<br/><br/>    private Interpreter interpreter;<br/>    private int inputSize;<br/>    private List&lt;String&gt; labelList;<br/>    private boolean quant;<br/><br/>    private TensorFlowImageClassifier() {<br/><br/>    }<br/><br/>    static Classifier create(AssetManager assetManager,<br/>                             String modelPath,<br/>                             String labelPath,<br/>                             int inputSize,<br/>                             boolean quant) throws IOException {<br/><br/>        TensorFlowImageClassifier classifier = new TensorFlowImageClassifier();<br/>        classifier.interpreter = new Interpreter(classifier.loadModelFile(assetManager, modelPath), new Interpreter.Options());<br/>        classifier.labelList = classifier.loadLabelList(assetManager, labelPath);<br/>        classifier.inputSize = inputSize;<br/>        classifier.quant = quant;<br/><br/>        return classifier;<br/>    }<br/><br/>    @Override<br/>    public List&lt;Recognition&gt; recognizeImage(Bitmap bitmap) {<br/>        ByteBuffer byteBuffer = convertBitmapToByteBuffer(bitmap);<br/>        if (quant) {<br/>            byte[][] result = new byte[1][labelList.size()];<br/>            interpreter.run(byteBuffer, result);<br/>            return getSortedResultByte(result);<br/>        } else {<br/>            float[][] result = new float[1][labelList.size()];<br/>            interpreter.run(byteBuffer, result);<br/>            return getSortedResultFloat(result);<br/>        }<br/><br/>    }<br/><br/>    @Override<br/>    public void close() {<br/>        interpreter.close();<br/>        interpreter = null;<br/>    }<br/><br/>    private MappedByteBuffer loadModelFile(AssetManager assetManager, String modelPath) throws IOException {<br/>        AssetFileDescriptor fileDescriptor = assetManager.openFd(modelPath);<br/>        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());<br/>        FileChannel fileChannel = inputStream.getChannel();<br/>        long startOffset = fileDescriptor.getStartOffset();<br/>        long declaredLength = fileDescriptor.getDeclaredLength();<br/>        return fileChannel.map(FileChannel.MapMode.<em class="kv">READ_ONLY</em>, startOffset, declaredLength);<br/>    }<br/><br/>    private List&lt;String&gt; loadLabelList(AssetManager assetManager, String labelPath) throws IOException {<br/>        List&lt;String&gt; labelList = new ArrayList&lt;&gt;();<br/>        BufferedReader reader = new BufferedReader(new InputStreamReader(assetManager.open(labelPath)));<br/>        String line;<br/>        while ((line = reader.readLine()) != null) {<br/>            labelList.add(line);<br/>        }<br/>        reader.close();<br/>        return labelList;<br/>    }<br/><br/>    private ByteBuffer convertBitmapToByteBuffer(Bitmap bitmap) {<br/>        ByteBuffer byteBuffer;<br/><br/>        if (quant) {<br/>            byteBuffer = ByteBuffer.<em class="kv">allocateDirect</em>(<em class="kv">BATCH_SIZE </em>* inputSize * inputSize * <em class="kv">PIXEL_SIZE</em>);<br/>        } else {<br/>            byteBuffer = ByteBuffer.<em class="kv">allocateDirect</em>(4 * <em class="kv">BATCH_SIZE </em>* inputSize * inputSize * <em class="kv">PIXEL_SIZE</em>);<br/>        }<br/><br/>        byteBuffer.order(ByteOrder.<em class="kv">nativeOrder</em>());<br/>        int[] intValues = new int[inputSize * inputSize];<br/>        bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());<br/>        int pixel = 0;<br/>        for (int i = 0; i &lt; inputSize; ++i) {<br/>            for (int j = 0; j &lt; inputSize; ++j) {<br/>                final int val = intValues[pixel++];<br/>                if (quant) {<br/>                    byteBuffer.put((byte) ((val &gt;&gt; 16) &amp; 0xFF));<br/>                    byteBuffer.put((byte) ((val &gt;&gt; 8) &amp; 0xFF));<br/>                    byteBuffer.put((byte) (val &amp; 0xFF));<br/>                } else {<br/>                    byteBuffer.putFloat((((val &gt;&gt; 16) &amp; 0xFF) - <em class="kv">IMAGE_MEAN</em>) / <em class="kv">IMAGE_STD</em>);<br/>                    byteBuffer.putFloat((((val &gt;&gt; 8) &amp; 0xFF) - <em class="kv">IMAGE_MEAN</em>) / <em class="kv">IMAGE_STD</em>);<br/>                    byteBuffer.putFloat((((val) &amp; 0xFF) - <em class="kv">IMAGE_MEAN</em>) / <em class="kv">IMAGE_STD</em>);<br/>                }<br/><br/>            }<br/>        }<br/>        return byteBuffer;<br/>    }<br/><br/>    @SuppressLint("DefaultLocale")<br/>    private List&lt;Recognition&gt; getSortedResultByte(byte[][] labelProbArray) {<br/><br/>        PriorityQueue&lt;Recognition&gt; pq =<br/>                new PriorityQueue&lt;&gt;(<br/>                        <em class="kv">MAX_RESULTS</em>,<br/>                        new Comparator&lt;Recognition&gt;() {<br/>                            @Override<br/>                            public int compare(Recognition lhs, Recognition rhs) {<br/>                                return Float.<em class="kv">compare</em>(rhs.getConfidence(), lhs.getConfidence());<br/>                            }<br/>                        });<br/><br/>        for (int i = 0; i &lt; labelList.size(); ++i) {<br/>            float confidence = (labelProbArray[0][i] &amp; 0xff) / 255.0f;<br/>            if (confidence &gt; <em class="kv">THRESHOLD</em>) {<br/>                pq.add(new Recognition("" + i,<br/>                        labelList.size() &gt; i ? labelList.get(i) : "unknown",<br/>                        confidence, quant));<br/>            }<br/>        }<br/><br/>        final ArrayList&lt;Recognition&gt; recognitions = new ArrayList&lt;&gt;();<br/>        int recognitionsSize = Math.<em class="kv">min</em>(pq.size(), <em class="kv">MAX_RESULTS</em>);<br/>        for (int i = 0; i &lt; recognitionsSize; ++i) {<br/>            recognitions.add(pq.poll());<br/>        }<br/><br/>        return recognitions;<br/>    }<br/><br/>    @SuppressLint("DefaultLocale")<br/>    private List&lt;Recognition&gt; getSortedResultFloat(float[][] labelProbArray) {<br/><br/>        PriorityQueue&lt;Recognition&gt; pq =<br/>                new PriorityQueue&lt;&gt;(<br/>                        <em class="kv">MAX_RESULTS</em>,<br/>                        new Comparator&lt;Recognition&gt;() {<br/>                            @Override<br/>                            public int compare(Recognition lhs, Recognition rhs) {<br/>                                return Float.<em class="kv">compare</em>(rhs.getConfidence(), lhs.getConfidence());<br/>                            }<br/>                        });<br/><br/>        for (int i = 0; i &lt; labelList.size(); ++i) {<br/>            float confidence = labelProbArray[0][i];<br/>            if (confidence &gt; <em class="kv">THRESHOLD</em>) {<br/>                pq.add(new Recognition("" + i,<br/>                        labelList.size() &gt; i ? labelList.get(i) : "unknown",<br/>                        confidence, quant));<br/>            }<br/>        }<br/><br/>        final ArrayList&lt;Recognition&gt; recognitions = new ArrayList&lt;&gt;();<br/>        int recognitionsSize = Math.<em class="kv">min</em>(pq.size(), <em class="kv">MAX_RESULTS</em>);<br/>        for (int i = 0; i &lt; recognitionsSize; ++i) {<br/>            recognitions.add(pq.poll());<br/>        }<br/><br/>        return recognitions;<br/>    }<br/><br/>}</span></pre><p id="b4e6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">步骤7 →创建接口Classifier.class以获取活动中图像的信息。</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="7230" class="lj ig hi lf b fi lk ll l lm ln">public interface Classifier {<br/><br/>    class Recognition {<br/>        <em class="kv">/**<br/>         * A unique identifier for what has been recognized. Specific to the class, not the instance of<br/>         * the object.<br/>         */<br/>        </em>private final String id;<br/><br/>        <em class="kv">/**<br/>         * Display name for the recognition.<br/>         */<br/>        </em>private final String title;<br/><br/>        <em class="kv">/**<br/>         * Whether or not the model features quantized or float weights.<br/>         */<br/>        </em>private final boolean quant;<br/><br/>        <em class="kv">/**<br/>         * A sortable score for how good the recognition is relative to others. Higher should be better.<br/>         */<br/>        </em>private final Float confidence;<br/><br/>        public Recognition(<br/>                final String id, final String title, final Float confidence, final boolean quant) {<br/>            this.id = id;<br/>            this.title = title;<br/>            this.confidence = confidence;<br/>            this.quant = quant;<br/>        }<br/><br/>        public String getId() {<br/>            return id;<br/>        }<br/><br/>        public String getTitle() {<br/>            return title;<br/>        }<br/><br/>        public Float getConfidence() {<br/>            return confidence;<br/>        }<br/><br/>        @Override<br/>        public String toString() {<br/>            String resultString = "";<br/>            if (id != null) {<br/>                resultString += "[" + id + "] ";<br/>            }<br/><br/>            if (title != null) {<br/>                resultString += title + " ";<br/>            }<br/><br/>            if (confidence != null) {<br/>                resultString += String.<em class="kv">format</em>("(%.1f%%) ", confidence * 100.0f);<br/>            }<br/><br/>            return resultString.trim();<br/>        }<br/>    }<br/><br/><br/>    List&lt;Recognition&gt; recognizeImage(Bitmap bitmap);<br/><br/>    void close();<br/>}</span></pre><p id="aa35" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">结论</p><p id="8d82" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以这些就是在你的android项目中实现TensorFlow的lite的步骤。</p></div></div>    
</body>
</html>