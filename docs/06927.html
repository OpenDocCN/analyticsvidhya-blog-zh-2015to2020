<html>
<head>
<title>Time-Series Cluster Analysis of US COVID-19 Deaths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">美国新冠肺炎死亡人数的时间序列聚类分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-cluster-analysis-of-us-covid-19-deaths-b31da03000b7?source=collection_archive---------21-----------------------#2020-06-07">https://medium.com/analytics-vidhya/time-series-cluster-analysis-of-us-covid-19-deaths-b31da03000b7?source=collection_archive---------21-----------------------#2020-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="35b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本练习旨在通过时间序列聚类分析，了解哪些州以类似的方式发生了与新冠肺炎相关的死亡。</p><p id="2ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新冠肺炎出乎意料地在美国经济增长的高峰期袭击了美国。本练习旨在获得一些关于哪些州以类似的方式发生新冠肺炎相关死亡的见解。我们将使用KMeans聚类方法。</p><p id="8b27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先加载这个分析所需的包。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="d574" class="jm jn hi ji b fi jo jp l jq jr"># Importing libraries<br/>import numpy as np <br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from tqdm import tqdm</span><span id="b0ac" class="jm jn hi ji b fi js jp l jq jr"># Hide unnecessary warnings<br/>import warnings<br/>warnings.filterwarnings('ignore')</span><span id="c636" class="jm jn hi ji b fi js jp l jq jr"># Clustering<br/>from sklearn.cluster import KMeans<br/>from yellowbrick.cluster import KElbowVisualizer</span><span id="5f07" class="jm jn hi ji b fi js jp l jq jr">pd.plotting.register_matplotlib_converters()</span></pre><ol class=""><li id="0f0e" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><strong class="ih hj">读入数据</strong></li></ol><p id="6502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用来自约翰·霍普金斯大学(JHU·CSSE)系统科学与工程中心的新冠肺炎数据集，该数据集作为Github库免费提供。特别是，我们使用美国死亡人数时间序列数据，每天更新。</p><p id="7331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kc">克隆JHU CSSE的新冠肺炎储存库</em> </strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="af2d" class="jm jn hi ji b fi jo jp l jq jr">!git clone <a class="ae kd" href="https://github.com/CSSEGISandData/COVID-19.git" rel="noopener ugc nofollow" target="_blank">https://github.com/CSSEGISandData/COVID-19.git</a></span></pre><p id="4382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kc">读入死亡人数时序数据</em> </strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2a43" class="jm jn hi ji b fi jo jp l jq jr">data = pd.read_csv("COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_US.csv")<br/>data.head()</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ke"><img src="../Images/e9e772e5376c33c78a163f4ed4803dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiynpRnSp4UsvEKSAcwpSQ.jpeg"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">美国新冠肺炎死亡数据</figcaption></figure><p id="d1e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每行代表美国一个省/州的一个FIPS地区。列包含从2020年1月22日到2020年6月6日新冠肺炎死亡人数的累积增长。</p><p id="0eb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查数据，我们首先创建一个国家级的聚合时间序列数据。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e91a" class="jm jn hi ji b fi jo jp l jq jr">us_ts = data.iloc[:,12:]<br/>us_ts = pd.DataFrame(us_ts.sum(axis=0)).reset_index()<br/>us_ts.columns = ["Date","NoOfCases"]<br/>us_ts["Date"] = pd.to_datetime(us_ts["Date"])<br/>us_ts.set_index('Date', inplace=True)<br/>us_ts.tail()</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div class="er es kq"><img src="../Images/d01693a5ea57103ef13f56181f7f2fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*a1qPYKtjvh6JPqOZtdqc7w.jpeg"/></div></figure><p id="441f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">截至2020年6月的第一周，美国的新冠肺炎死亡人数接近11万。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="91ec" class="jm jn hi ji b fi jo jp l jq jr">us_ts.plot()</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div class="er es kr"><img src="../Images/7f4e249b109100a6d342dea64d3c70c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*f75sO5TPTRs2xIEplb04jQ.jpeg"/></div></figure><p id="0e55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kc">按状态</em> </strong>创建死亡时间序列数据</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a398" class="jm jn hi ji b fi jo jp l jq jr">data_by_state = data.groupby("Province_State").agg(’sum’).reset_index() # Data grouped by states to create clusters at state level<br/>data_by_state = data_by_state.drop(columns=[’UID’, 'code3’, 'FIPS’, 'Lat’, 'Long_’, 'Population’])<br/>data_by_state.head()</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ks"><img src="../Images/bf07d3d2cb757812814cae8a734e1ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NZ4yq3qE59_qw68ACPaZA.jpeg"/></div></div></figure><p id="eed1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。时间序列聚类模型</strong></p><p id="f2b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将使用KMeans聚类算法来开发州级死亡时间序列数据的聚类模型。KMeans聚类是一种无监督学习算法，用于将项目分组到k个聚类中。在k-means中，每个项目都被放置在其最近的聚类中。计算聚类中心，作为聚类成员的平均值。重复执行该程序，直到中心稳定。k-means聚类算法的基本概念是这样的:结果分两部分产生:首先产生聚类中心作为输出，然后每个实体被分配到特定的聚类。最近的聚类通常取决于与欧几里德的距离，但也使用其他距离度量(例如曼哈顿、闵可夫斯基距离)。k-means程序迭代运行，直到达到指定的终止条件(例如中心移动小于1e-10)。</p><p id="8492" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kc"> 2a。选择最佳集群数</em> </strong></p><p id="df09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在KMeans聚类中，需要在计算之前指定要形成的聚类数。我们可以使用yellowbrick包中的KElbowVisualizer类来找到这个最佳数字。KElbowVisualizer应用“肘”方法，通过用一系列K值拟合模型来帮助数据科学家选择最佳聚类数。如果图表看起来像一只手臂，那么“肘”(曲线上的拐点)是从属模型的最佳排列的基础的良好指示。可视化工具中的“肘部”用虚线标记。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0505" class="jm jn hi ji b fi jo jp l jq jr">model = KMeans(init='k-means++')<br/>visualizer = KElbowVisualizer(model, k=(4,12),metric="distortion") <br/>visualizer.fit(data_by_state.iloc[:,1:])<br/>visualizer.show()</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div class="er es kt"><img src="../Images/528564ffcabb80984b5c1b96b6c89f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*HCPwCZRo0voj7VmP10qjGg.jpeg"/></div></figure><p id="f398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面由KElbowVisualizer类生成的图表明最佳的集群数量是6。</p><p id="388d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kc"> 2b。拟合KMeans聚类算法</em> </strong></p><p id="d231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过指定n_clusters=6，我们用最佳的分类数来拟合KMeans分类模型，并将分类数分配给每个州。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="06b7" class="jm jn hi ji b fi jo jp l jq jr"># Clustering with 6 clusters<br/>kmeans = KMeans(n_clusters=6,init='k-means++',random_state=0)  <br/>y_kmeans = kmeans.fit_predict(data_by_state.iloc[:,1:])  <br/>data_by_state["Cluster"] = y_kmeans</span></pre><p id="d47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kc"> 2c。集群的分布</em> </strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5791" class="jm jn hi ji b fi jo jp l jq jr">for i in range(1,6):<br/>    print("States in cluster {} are {}".format(i,list(data_by_state[data_by_state.Cluster==i]["Province_State"].unique())))</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ku"><img src="../Images/b8a1044662313c7714dccae00a467dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkqoYxsguC9OHKrz7hPE7g.jpeg"/></div></div></figure><p id="fa32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们马上创建集群标签以供使用。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="168c" class="jm jn hi ji b fi jo jp l jq jr">cluster_labels =['Cluster0 - Other', 'Cluster1 - NY', 'Cluster2 - CA-CT-LA', 'Cluster3 - IL, MA, MI, PA','Cluster4 - CO-FL-GA-IN-MD-OH-TX-VA-WA', 'Cluster5 - NJ']</span></pre><p id="dd30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。集群的可视化</strong></p><p id="3edb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可视化这些集群有助于更好地理解集群的相似性。可视化这些聚类的一个好方法是绘制一个时间序列，该时间序列聚集了指定聚类中所有州每天的平均死亡人数，置信区间为95%。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c667" class="jm jn hi ji b fi jo jp l jq jr">## For generating 95% confidence interval <br/>def get_cluster_intervals(cluster):<br/>    df = pd.DataFrame() <br/>    df["mean"] = cluster.mean(axis=0)<br/>    df["lower_bound"] = df["mean"] - (1.96 * cluster.std(axis=0))/np.sqrt(len(df["mean"]))<br/>    df["upper_bound"] = df["mean"] + (1.96 * cluster.std(axis=0))/np.sqrt(len(df["mean"]))<br/>    df.index = us_ts.index<br/>    return df</span><span id="486a" class="jm jn hi ji b fi js jp l jq jr">clusters = [get_cluster_intervals(data_by_state[data_by_state["Cluster"]==n].iloc[:,1:-1]) for n in range(6)]</span><span id="7701" class="jm jn hi ji b fi js jp l jq jr">K = 6<br/>cols = 2<br/>rows = int(math.ceil(K / cols))</span><span id="a774" class="jm jn hi ji b fi js jp l jq jr">gs = gridspec.GridSpec(rows, cols)<br/>fig = plt.figure( figsize=(18, 12))<br/>for n in range(K):<br/>    ax = fig.add_subplot(gs[n])<br/>    ax.plot(clusters[n].index,clusters[n]["mean"],label=cluster_labels[n])<br/>    ax.fill_between(clusters[n].index, clusters[n]["lower_bound"], clusters[n]["upper_bound"], alpha=.4)<br/>    plt.legend()<br/>    <br/>plt.xlabel('Date')<br/>plt.ylabel('Number of Deaths')<br/>plt.show()<br/>fig.tight_layout()</span></pre><figure class="jd je jf jg fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kv"><img src="../Images/a68cc66a1338d64b67a7d781585609dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHDu_9yY5XhGy-Y47TkzuQ.png"/></div></div></figure><ul class=""><li id="b61a" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc kw jz ka kb bi translated">聚类1仅包括纽约州，截至2020年6月6日，该州已有超过30，000人死亡。</li><li id="77cb" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">第二组包括“加利福尼亚”、“康涅狄格”、“路易斯安那”三个州，截至2020年6月6日，平均死亡人数为3862人。</li><li id="5a42" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">四个州(“伊利诺伊州”、“马萨诸塞州”、“密歇根州”和“宾夕法尼亚州”)属于同一个聚类(聚类3)，截至2020年6月6日，该聚类平均有6000+例死亡。</li><li id="1e93" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">九个州(“科罗拉多”、“佛罗里达”、“佐治亚”、“印第安纳”、“马里兰”、“俄亥俄”、“得克萨斯”、“弗吉尼亚”、“华盛顿”)形成另一个聚类(聚类4)，截至2020年6月6日，该聚类为大约2000+死亡。</li><li id="2497" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">“新泽西州”单独形成一个聚类(聚类3)，截至2020年6月6日，该州约有12，000人死亡。</li><li id="4285" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">其余40个州/地区成为一个群集(群集0)，每个州/地区的死亡人数少于350人。</li></ul><p id="314c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。进一步工作</strong></p><p id="58c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过以下方式扩展这一练习:</p><ul class=""><li id="bb4b" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc kw jz ka kb bi translated">按人口标准化时间序列数据</li><li id="31d0" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">将这些星团在地图上可视化。</li><li id="7256" class="jt ju hi ih b ii kx im ky iq kz iu la iy lb jc kw jz ka kb bi translated">开发时间序列预测模型</li></ul></div></div>    
</body>
</html>