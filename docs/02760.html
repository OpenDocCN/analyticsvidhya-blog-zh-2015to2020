<html>
<head>
<title>[Time Series Forecast] Anomaly detection with Facebook Prophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[时间序列预测]脸书预言家的异常检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-forecast-anomaly-detection-with-facebook-prophet-558136be4b8d?source=collection_archive---------0-----------------------#2020-01-01">https://medium.com/analytics-vidhya/time-series-forecast-anomaly-detection-with-facebook-prophet-558136be4b8d?source=collection_archive---------0-----------------------#2020-01-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9d30" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">总结</strong></h1><p id="6824" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们构建了一个方便的时间序列异常检测模块，通过可视化和在<code class="du kb kc kd ke b"><em class="kf">pyplot</em></code> <br/> - <strong class="jf hj">实验中标记异常值，使用不同的时间窗口和模型参数</strong>如置信区间，快速地:<br/> - <strong class="jf hj">发现和诊断模式，并做出调整</strong></p><p id="7cd0" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">代码片段分享在github repo上，请随时查看<a class="ae kl" href="https://github.com/paullo0106/prophet_anomaly_detection/" rel="noopener ugc nofollow" target="_blank">代码</a>和<a class="ae kl" href="https://github.com/paullo0106/prophet_anomaly_detection/blob/master/example.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a> <em class="kf"> <br/>(环境:python 3、</em> <code class="du kb kc kd ke b"><em class="kf">matplotlib</em></code> <em class="kf">、</em> <code class="du kb kc kd ke b"><em class="kf">seaborn</em></code>、 <code class="du kb kc kd ke b"><em class="kf">fbprophet v0.5</em></code> <em class="kf"> ) </em></p><div class="km kn ko kp fd ab cb"><figure class="kq kr ks kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/491a47d1d2b5248b92b07dceb1f1da11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5NrNjCv0orwpUkvFNE6HIg.png"/></div></figure><figure class="kq kr ld kt ku kv kw paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/b473548821a3ff8ae021c02a166a2058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*dBZ_zorGBz7R_N6bt7FcaQ.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx li di lj lk translated">使用不同的训练窗口(灰色基线区域)进行测试，并在图上用红点突出显示异常值</figcaption></figure></div><h1 id="eb3e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">背景</strong></h1><p id="3e42" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我最近的一个项目中，我们的团队希望检测成千上万个具有不同特征的时间序列数据中的异常，这些异常是由市场动态和特定区域的应用引起的。由于这些极高或极低的值可能会直接或间接影响我们的客户和业务(以不良方式)，因此开发了检测模型的日常运行，旨在提供警报，以便及时调整系统中断、人为错误等。</p><h1 id="9475" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">模型和用例(需求)</strong></h1><ul class=""><li id="10f0" class="ll lm hi jf b jg jh jk jl jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj">置信区间灵活预测</strong>:我们的项目中主要使用<a class="ae kl" href="https://github.com/facebook/prophet" rel="noopener ugc nofollow" target="_blank"> Prophet </a>，是脸书开发的开源库。时间序列预测是一个受欢迎的领域，我们也评估了其他模型，从早期的<code class="du kb kc kd ke b">ARIMA</code>到最近的<code class="du kb kc kd ke b">Neural Network</code>类型的方法，我们必须将范围缩小到几个模型/框架，这些模型/框架<strong class="jf hj">自然地支持置信区间</strong>(参见<a class="ae kl" href="https://datascience.stackexchange.com/questions/24403/prediction-interval-around-lstm-time-series-forecast" rel="noopener ugc nofollow" target="_blank">【stack exchange】LSTM时间序列预测的预测区间</a>中的讨论，指出为什么它可能对某些模型(如神经网络)没有意义)——我们希望在我们的警报系统中灵活地设置<code class="du kb kc kd ke b"><em class="kf">alpha</em></code>(如异常阈值)。</li><li id="2469" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj">相当大的数据量</strong>:我们有大量的时间序列数据要处理，<strong class="jf hj">如果我们想回溯几个月以上的时间，存储和数据收集过程可能会效率低下</strong>。因此，我们创建了带有参数的模块，以评估我们拟合和预测1-3个月大小的训练窗口的情况，并验证该大小是否可以应用于我们所有的大多数时间序列。</li></ul><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lz"><img src="../Images/d2b3b6b918acf8581579221ee36490c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0-G4GKEanz8bk1F6.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">(图摘自优步英语博客优步<a class="ae kl" href="https://eng.uber.com/forecasting-introduction/" rel="noopener ugc nofollow" target="_blank">天气预报)</a></figcaption></figure><ul class=""><li id="746c" class="ll lm hi jf b jg kg jk kh jo ma js mb jw mc ka lq lr ls lt bi translated"><strong class="jf hj">监控和可观察性:</strong>我们有多个利益相关者，包括PM、Eng、营销和运营团队，我们希望使检测结果易于消化，并为模型提供一定程度的可解释性。通过这样做，我们将能够收集反馈并快速迭代。</li></ul><h1 id="b232" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">给我看看🖥的代码</h1><p id="ef0c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">加载数据</strong></p><p id="e34f" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">为了说明该模块，我们使用了<a class="ae kl" href="https://github.com/facebook/prophet/tree/master/examples" rel="noopener ugc nofollow" target="_blank">example _ WP _ log _ peyton _ manning . CSV</a>，这是脸书预言家网站github示例文件夹中提供的数据集</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="6072" class="mh ig hi ke b fi mi mj l mk ml">import pandas as pd<br/>df = pd.read_csv('<a class="ae kl" href="https://raw.githubusercontent.com/facebook/prophet/master/examples/example_wp_log_peyton_manning.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/facebook/prophet/master/examples/example_wp_log_peyton_manning.csv'</a>)<br/>df.head()</span></pre><figure class="km kn ko kp fd kr er es paragraph-image"><div class="er es mm"><img src="../Images/834be08269869d781aa4bbb91c915787.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*Z8Te-nKwGs2At6c2gk0hKg.png"/></div></figure><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="15b0" class="mh ig hi ke b fi mi mj l mk ml">import matplotlib.pyplot as plt<br/>df.ds = pd.to_datetime(df.ds) # properly convert to datetime type<br/>df.index = df.ds # make x-axis naturally appear in the datetime format<br/>df.y.plot()<br/>plt.show()</span></pre><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mn"><img src="../Images/4afc4bf5fffb30a49ecbd32fc4fff5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1MzDfEQaCtGlEuRdmXHSQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">样本数据集包含2008年至2016年维基百科页面的每日流量</figcaption></figure><p id="d37b" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">型号</strong></p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="ba9e" class="mh ig hi ke b fi mi mj l mk ml">from fbprophet import Prophet</span><span id="6209" class="mh ig hi ke b fi mo mj l mk ml"># configure the model<br/>model = Prophet(interval_width=0.98, yearly_seasonality=True, changepoint_prior_scale=0.5)<br/>model.add_seasonality(name=’monthly’, period=30.5, fourier_order=5)<br/>model.add_seasonality(name=’weekly’, period=7, fourier_order=3)<br/><br/># fit the time-series data<br/>model.fit(df)</span><span id="eb33" class="mh ig hi ke b fi mo mj l mk ml"># predict next 52 weeks<br/>future = model.make_future_dataframe(periods=7*52)  <br/>forecast = model.predict(future)</span><span id="800b" class="mh ig hi ke b fi mo mj l mk ml">model.plot(forecast)  # visualise the result</span></pre><p id="be0f" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><em class="kf">(注:详见</em> <a class="ae kl" href="https://facebook.github.io/prophet/docs/seasonality,_holiday_effects,_and_regressors.html#fourier-order-for-seasonalities" rel="noopener ugc nofollow" target="_blank"> <em class="kf">傅立叶_阶</em> </a> <em class="kf"> ( </em> <a class="ae kl" href="https://en.wikipedia.org/wiki/Fourier_series#/media/File:Fourier_Series.svg" rel="noopener ugc nofollow" target="_blank"> <em class="kf">维基</em> </a> <em class="kf">)，</em><a class="ae kl" href="https://facebook.github.io/prophet/docs/trend_changepoints.html" rel="noopener ugc nofollow" target="_blank"><em class="kf">change point _ scale</em></a><em class="kf">具体通过先知文档链接)</em></p><p id="3f95" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">我们成功地使用了数据框架<code class="du kb kc kd ke b"><em class="kf">df</em></code>，数据范围从2008年到2016年，并用几行代码预测了2017年的趋势！正如您在下图中看到的，<code class="du kb kc kd ke b">Prophet</code>有一个相当不错的内置可视化功能</p><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mp"><img src="../Images/69901b618aa29235729baf44305eaf1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99lv7CE8ycEe2lefJsXZPw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">图:用2008年到2016年的数据点对2017年进行预测</figcaption></figure><p id="2d3e" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">为了使这个简单的例子更适合我们的异常检测用例，我们将做一些小的调整，比如说，在<code class="du kb kc kd ke b">day N</code>，我们有1年的历史数据，即从<code class="du kb kc kd ke b">day (N-365)</code>到<code class="du kb kc kd ke b">day (N-1)</code>，让我们在<code class="du kb kc kd ke b">day (N-15)</code>将这个范围分成两部分，并基于<code class="du kb kc kd ke b">day (N-365)</code>到<code class="du kb kc kd ke b">(N-15)</code> <em class="kf">构建我们的预测模型。</em></p><p id="041a" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">在<em class="kf"> </em>生成最近2周的预测:<code class="du kb kc kd ke b">day (N-14)</code>到<code class="du kb kc kd ke b">(N-1)</code> <em class="kf">，</em>然后<em class="kf"> </em> <strong class="jf hj">与最近2周的实际值进行比较，并标记出超出预测区间</strong>的值(在Prophet的结果数据帧中，<em class="kf"> yhat_upper </em>和<em class="kf"> yhat_lower </em>列)，当用更高的<em class="kf">初始化模型时，预计范围会更大</em></p><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mq"><img src="../Images/7bcc15132a84766b4a56f3402ef11f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_w01VMG5tu8Zg4YkFUG2A.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">注意:预测是从model.predict(future)调用中得到的pandas.dataframe</figcaption></figure><p id="762d" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">因此，我们调整代码以适应增加的功能:</p><ul class=""><li id="4acf" class="ll lm hi jf b jg kg jk kh jo ma js mb jw mc ka lq lr ls lt bi translated"><strong class="jf hj">窗口参数</strong>:这是我们可以划分训练(第<code class="du kb kc kd ke b">0</code>天到<code class="du kb kc kd ke b">day N-x</code>天)和预测(<code class="du kb kc kd ke b">day N-x</code>到<code class="du kb kc kd ke b">day N</code>天)段的地方。</li><li id="2c3e" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj">异常值的可视化</strong>:一幅好的图片总是最直观地告诉我们模型是如何工作并做出预测的，事实证明，通过图表从PM、工程和其他用户那里获得反馈非常有帮助——预测范围、实际值和异常值都可以在异常警报报告中得到很好的说明。</li></ul><p id="cc33" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">窗口参数</strong></p><p id="91a0" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">我们引入一个名为<code class="du kb kc kd ke b">prophet_fit()</code> <em class="kf"> ( </em> <a class="ae kl" href="https://github.com/paullo0106/prophet_anomaly_detection/blob/master/utils.py#L8" rel="noopener ugc nofollow" target="_blank"> <em class="kf">见这里的完整实现</em> </a> <em class="kf"> ) </em>的函数，在这里我们输入数据、模型和时间窗口。<code class="du kb kc kd ke b">today_index</code>、<code class="du kb kc kd ke b">lookback_days</code>、<code class="du kb kc kd ke b">predict_days</code>是定义训练和预测段的参数。</p><figure class="km kn ko kp fd kr"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="4687" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">如<a class="ae kl" href="https://github.com/paullo0106/prophet_anomaly_detection/blob/master/example.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a>所示，现在用<code class="du kb kc kd ke b">prophet_fit()</code>迭代几个模型参数和截止日期非常容易。</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="754c" class="mh ig hi ke b fi mi mj l mk ml"># Setting 1<br/>alpha=0.95<br/>model = Prophet(interval_width=alpha, <br/>                yearly_seasonality=False, <br/>                weekly_seasonality=False,<br/>                changepoint_prior_scale=0.5)<br/>model.add_seasonality(name='monthly', period=30.5, fourier_order=5)<br/>model.add_seasonality(name='weekly', period=7, fourier_order=3, prior_scale=0.1)</span><span id="8a22" class="mh ig hi ke b fi mo mj l mk ml">today_index = 48<br/>print('Cutoff date:', df.index[today_index])<br/>predict_n = 14<br/>results = prophet_fit(df, model, today_index,<br/>                      predict_days=predict_n)</span><span id="6334" class="mh ig hi ke b fi mo mj l mk ml"># Setting 2<br/>alpha=0.98<br/>model = Prophet(interval_width=alpha, <br/>                yearly_seasonality=False, <br/>                weekly_seasonality=False, <br/>                changepoint_prior_scale=0.1)<br/>model.add_seasonality(name='monthly', period=30.5, fourier_order=5)<br/>model.add_seasonality(name='weekly', period=7, fourier_order=3, prior_scale=0.1)<br/><br/>today_index = 48<br/>print('Cutoff date:', df.index[today_index])<br/>predict_n = 14<br/>lookback_n = 35<br/>results = prophet_fit(df, model, today_index, <br/>                      lookback_days=lookback_n, <br/>                      predict_days=predict_n)</span></pre><p id="d11e" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">异常值的可视化</strong></p><ol class=""><li id="4251" class="ll lm hi jf b jg kg jk kh jo ma js mb jw mc ka mt lr ls lt bi translated">过滤离群值</li></ol><p id="4091" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">代码片段:</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="5945" class="mh ig hi ke b fi mi mj l mk ml">def get_outliers(df, forecast, today_index, predict_days=21):<br/>    df_pred = forecast<br/>    df_pred.index = df_pred[‘ds’].dt.to_pydatetime()<br/>    df_pred.columns = [‘ds’, ‘preds’, ‘lower_y’, ‘upper_y’]<br/>    df_pred[‘actual’] = df[‘y’][today_index: today_index+predict_days].values<br/>    print(df_pred.head())</span><span id="8d5e" class="mh ig hi ke b fi mo mj l mk ml">    # .... and then flag 'actual' values which fall outside of lower_y and upper_y<br/>    # more code here</span></pre><p id="10e0" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">在同一个数据框架内将预测值和实际值对齐后，我们就能看到什么是“异常”。</p><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mu"><img src="../Images/9e77a40247ec1fd614580a94e05839c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GU8vx_8-GMdkC5KOa1IMg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">df_pred数据帧中的异常</figcaption></figure><p id="aafb" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">在本例中，<code class="du kb kc kd ke b">02–20</code>上的7.51被标记为异常，因为其值落在预测区间(7.61至8.67)之外。我们希望用一个简单的过滤条件突出显示数据帧中的所有异常，并将其放在图像上，如下所示。</p><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mv"><img src="../Images/06aa8a628d493acc9cb70c1f319d9395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeqvuD6ei0oC5vmDgFiIEg.png"/></div></div></figure><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="b1b1" class="mh ig hi ke b fi mi mj l mk ml">print('Predictions')<br/>print(df_pred.head())</span><span id="1b14" class="mh ig hi ke b fi mo mj l mk ml">df_outlier = df_pred[(df_pred.actual &gt; df_pred.upper_y) | (df_pred.actual &lt; df_pred.lower_y)]</span><span id="6794" class="mh ig hi ke b fi mo mj l mk ml">print('Outliers')<br/>print(df_outlier.head())</span></pre><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mw"><img src="../Images/54a33c1af62343cc8126a0a92759bbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aE_qhFl4xJmq7Ki1wHxWdw.png"/></div></div></figure><p id="c251" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">2.将所有信息放在一个图中</p><p id="45f1" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">如果我们仔细看看，Prophet的<a class="ae kl" href="https://github.com/facebook/prophet/blob/master/python/fbprophet/plot.py#L41" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> plot() </em> </a>返回如下图的matplotlib图，我们想在上面添加更多的信息</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="8866" class="mh ig hi ke b fi mi mj l mk ml">model.plot(forecast)</span></pre><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mv"><img src="../Images/d01631883085b7052734cccd287594a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixUMb5ryi1gVBgsgPaIbMg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">Prophet的内置绘图功能:该图显示了模型从1月到2月中旬的流量(点表示实际值),并生成一条到3月底的拟合线</figcaption></figure><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="59e5" class="mh ig hi ke b fi mi mj l mk ml">fig = model.plot(forecast)</span><span id="8aa3" class="mh ig hi ke b fi mo mj l mk ml">#add lines, points, text to the figure<br/>ax = fig.get_axes()[0]<br/>ax.plot(.....)<br/>ax.scatter(.....)<br/>ax.text(.....)</span></pre><p id="31a0" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">通过上面的代码，我们获取了<code class="du kb kc kd ke b">matplotlib figure</code>对象的第一个(也是唯一的)轴，然后我们就可以给图像添加额外的东西了！</p><p id="fd17" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">现在，在<code class="du kb kc kd ke b"><a class="ae kl" href="https://github.com/paullo0106/prophet_anomaly_detection/blob/master/utils.py#L71" rel="noopener ugc nofollow" target="_blank">prophet_plot()</a></code>函数中，我们有了所有的数据来:</p><p id="5732" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">a)用红点标出每个异常值，并注明日期</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="80c9" class="mh ig hi ke b fi mi mj l mk ml"># plot each outlier in red dot and annotate the date<br/>for<strong class="ke hj"> </strong>outlier in<strong class="ke hj"> </strong>outliers:<br/>    ax.scatter(outlier[0], outlier[1], color='red', label='Anomaly')<br/>    ax.text(outlier[0], outlier[1], str(outlier[0])[:10], color='red')</span></pre><p id="54ac" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">b)用颜色突出显示时间框架，并对区域进行注释</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="a3ce" class="mh ig hi ke b fi mi mj l mk ml"># highlight baseline time frame with gray background<br/>if<strong class="ke hj"> </strong>lookback_days:<br/>    start = today_index - lookback_days<br/>ax.axvspan(x_pydatetime[start],<br/>           x_pydatetime[today_index],<br/>           color=sns.xkcd_rgb['grey'],<br/>           alpha=0.2)</span><span id="6a9b" class="mh ig hi ke b fi mo mj l mk ml"># annotate the areas with text at the bottom <br/>ymin, ymax = ax.get_ylim()[0], ax.get_ylim()[1]<br/>ax.text(x_pydatetime[int((start + today_index) / 2)], ymin + (ymax - ymin) / 20, 'Baseline area')<br/>ax.text(x_pydatetime[int((today_index * 2 + predict_days) / 2)], ymin + (ymax - ymin) / 20, 'Prediction area')</span></pre><p id="830c" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">使用这些函数，我们将能够生成如下所示的直观图形</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="0520" class="mh ig hi ke b fi mi mj l mk ml">outliers, df_pred = get_outliers(df, forecast, today_index, predict_days=predict_n)<br/><br/>prophet_plot(df, fig, today_index, lookback_days=lookback_n, <br/>             predict_days=predict_n, outliers=outliers)</span></pre><figure class="km kn ko kp fd kr er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mx"><img src="../Images/38627c8fce4695dd8a5f79cae8c03dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2_Jd72zTS0UqCRswnAntA.png"/></div></div></figure><p id="a23a" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj">其他注释🗒 </strong></p><p id="226b" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">在开发过程中，我遇到了一些问题，记录了适合我的解决方案</p><ol class=""><li id="9fa8" class="ll lm hi jf b jg kg jk kh jo ma js mb jw mc ka mt lr ls lt bi translated"><strong class="jf hj"> TypeError: float()参数必须是字符串或数字，而不是“句点”</strong></li></ol><p id="5748" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">这并不总是可重复的，但我在绘制图形时遇到过几次。下面的一行代码解决了我的问题，正如这里的stackoverflow <a class="ae kl" href="https://stackoverflow.com/a/57148021/2547739" rel="noopener ugc nofollow" target="_blank">中所讨论的。</a></p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="641e" class="mh ig hi ke b fi mi mj l mk ml">pd.plotting.register_matplotlib_converters() </span></pre><p id="617f" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj"> 2。根据画布上现有的x轴类型绘制(x，y)</strong></p><p id="878b" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">我们重用Prophet的拟合函数生成的<code class="du kb kc kd ke b">matplotlib figure</code>，x轴有一个现有的datetime格式。因此，当我们向图中添加线条或点时，我们需要确保我们有兼容<code class="du kb kc kd ke b">x</code>的<em class="kf"> datetime64[ns] dtype </em></p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="af76" class="mh ig hi ke b fi mi mj l mk ml">x_pydatetime = df['ds'].dt.to_pydatetime()<br/>ax.plot(x_pydatetime[start:end],<br/>        df.y[start:end],<br/>        color='orange', label='Actual')</span></pre><p id="5c03" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">同样的概念也适用于异常值可视化，我们使用正确的日期时间格式为稍后的绘图构建x坐标的异常值列表</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="14be" class="mh ig hi ke b fi mi mj l mk ml"># construct outlier list with the right datetime format in x coordinate<br/>df_pred.index = df_pred['ds'].dt.to_pydatetime()<br/>for ......<br/>    outliers.append((df_pred.index[i], actual_value))</span><span id="74ce" class="mh ig hi ke b fi mo mj l mk ml"># and then plot outliers on the figure<br/>for outlier in outliers:<br/>    ax.scatter(outlier[0], outlier[1], color='red', label='Anomaly')<br/>    ax.text(outlier[0], outlier[1], str(outlier[0])[:10], color='red')</span></pre><p id="9f7e" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated"><strong class="jf hj"> 3。“‘ds’既是索引级别又是列标签”错误</strong></p><p id="620d" class="pw-post-body-paragraph jd je hi jf b jg kg ji jj jk kh jm jn jo ki jq jr js kj ju jv jw kk jy jz ka hb bi translated">为了方便绘图，我们在开始时设置了<em class="kf"> df.index = df.ds </em>来制作data frame<em class="kf">datetime index</em>的索引(dtype:<em class="kf">datetime 64【ns】</em>)。我在一些排序和预测任务中遇到了警告/错误:<em class="kf">‘ds’既是索引级别，也是列标签“</em>”。在Prophet项目的第891期 中提到的一个非常快速的解决方法是简单地将索引的名称重置为<code class="du kb kc kd ke b">None</code>以避免这种歧义。</p><pre class="km kn ko kp fd md ke me mf aw mg bi"><span id="f8ea" class="mh ig hi ke b fi mi mj l mk ml">df.index.name = None</span></pre><h1 id="dd07" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">参考资料(对我很有帮助的资源！)</strong></h1><ul class=""><li id="7d9f" class="ll lm hi jf b jg jh jk jl jo ln js lo jw lp ka lq lr ls lt bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=95-HMzxsghY" rel="noopener ugc nofollow" target="_blank">【Youtube】用Python算命:脸书先知介绍——芝加哥Python用户组Jonathan Balaban</a></li><li id="d772" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae kl" href="https://amzn.to/2S7xxuV" rel="noopener ugc nofollow" target="_blank">【书】熊猫食谱:使用Python进行科学计算、时间序列分析和数据可视化的食谱</a>，作者Theodore Petrou</li><li id="484c" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae kl" href="https://amzn.to/37ADuF5" rel="noopener ugc nofollow" target="_blank">【本书】时间序列分析</a>，作者詹姆斯·d·汉密尔顿</li><li id="b70e" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae kl" href="https://bit.ly/forecast_principle_amzn" rel="noopener ugc nofollow" target="_blank">【书】预测:原理与实践</a></li><li id="bb96" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><a class="ae kl" href="https://towardsdatascience.com/predicting-the-future-with-facebook-s-prophet-bdfe11af10ff" rel="noopener" target="_blank">[文章]走向数据科学:用脸书的先知预测“未来”</a></li></ul><h1 id="9fba" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">结尾注释</strong></h1><blockquote class="my"><p id="7cf1" class="mz na hi bd nb nc nd ne nf ng nh ka dx translated">感谢您阅读本文，非常感谢您的任何反馈/问题。请随时寻求进一步的合作😃</p></blockquote></div></div>    
</body>
</html>