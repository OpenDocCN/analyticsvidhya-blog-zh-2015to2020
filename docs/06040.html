<html>
<head>
<title>Logistic Regression!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistic-regression-37955f041b27?source=collection_archive---------20-----------------------#2020-05-09">https://medium.com/analytics-vidhya/logistic-regression-37955f041b27?source=collection_archive---------20-----------------------#2020-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/839f815a88e787b993ba96ce5fb69011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BB_ZgWthCTn6mJuo.jpg"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><blockquote class="ix iy iz"><p id="c853" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">我们将从回归的定义开始，然后解析什么是逻辑回归。因此，作为一个通用术语，回归是一个估计变量之间关系的统计过程。这通常用来预测某个结果。线性回归是当您有一个连续的目标变量时使用的一种回归类型。例如，在这种情况下，我们试图通过降雨量来预测雨伞的销量，线性回归的算法定义是y = mx + b，这就是线性回归。但是让我们回到逻辑回归。</p><p id="f327" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">逻辑回归是一种回归形式，其中目标变量或您试图预测的事物是二元的。所以只有0或1，或真或假，或类似的东西。为什么我们需要两种不同的回归算法？为什么线性回归不适用于二元目标变量？想象一个图，我们只是用一个x轴上的x特征来预测一个二进制的y结果。如果我们对这样的二元目标使用线性回归，用一条最佳拟合线就可以了。线性回归会尝试拟合一条适合所有数据的直线，最终会预测负值和大于1的值，这是不可能的。</p><p id="a979" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">逻辑回归是建立在逻辑曲线或sigmoid曲线的基础上的，就像你在下面看到的这个S形。。这将总是在0和1之间，这使得它更适合二进制分类问题。我们看到了这个方程，它代表了逻辑回归的方程是什么样的？逻辑回归的方程是什么样的？基本上，它只是采用线性回归算法， 它只对mx + b线采用线性回归算法，对mx + b线采用线性回归算法，把它作为e的负指数，把它作为e的负指数，所以我们的完整方程是1/1+e到负mx + b，所以我们的完整方程是1/1+e到负mx + b，这就产生了这条很好的S形曲线，非常适合二进制分类问题。 这使得它非常适合二进制分类问题。</p></blockquote><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/74445cfc187fd228ba401e55dfdc7388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTrY5hMvzVAwCq6BbzI35A.png"/></div></div></figure><p id="ca02" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">所以什么时候用逻辑回归，什么时候不用！！</p><h2 id="5cfc" class="kh ki hi bd kj kk kl km kn ko kp kq kr ke ks kt ku kf kv kw kx kg ky kz la lb bi translated">何时使用</h2><blockquote class="ix iy iz"><p id="c660" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">二元目标变量</p><p id="e21e" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">透明度很重要，或者对预测值的显著性感兴趣。</p><p id="9532" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">表现相当好的数据</p><p id="1712" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">需要一个快速的初始基准..</p></blockquote><h2 id="7d54" class="kh ki hi bd kj kk kl km kn ko kp kq kr ke ks kt ku kf kv kw kx kg ky kz la lb bi translated">何时不使用</h2><blockquote class="ix iy iz"><p id="ebc0" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">连续目标变量</p><p id="d69c" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">海量数据</p><p id="0a2f" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">性能是唯一重要的东西</p></blockquote><h1 id="cb29" class="lc ki hi bd kj ld le lf kn lg lh li kr lj lk ll ku lm ln lo kx lp lq lr la ls bi translated">让我们建立逻辑回归模型，预测用户是否会购买该产品。</h1><p id="aeb3" class="pw-post-body-paragraph ja jb hi jd b je lt jg jh ji lu jk jl ke lv jo jp kf lw js jt kg lx jw jx jy hb bi translated">输入库</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="955d" class="kh ki hi lz b fi md me l mf mg"><strong class="lz hj">import</strong> <strong class="lz hj">pandas</strong> <strong class="lz hj">as</strong> <strong class="lz hj">pd</strong> <br/><strong class="lz hj">import</strong> <strong class="lz hj">numpy</strong> <strong class="lz hj">as</strong> <strong class="lz hj">np</strong> <br/><strong class="lz hj">import</strong> <strong class="lz hj">matplotlib.pyplot</strong> <strong class="lz hj">as</strong> <strong class="lz hj">plt</strong></span><span id="c39a" class="kh ki hi lz b fi mh me l mf mg">dataset = pd.read_csv('...<strong class="lz hj">\\</strong>User_Data.csv')</span></pre><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/593729c6b61f67a9a2624bd6000a1d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*alfiuXojEl8iDIrh.jpg"/></div></figure><p id="56a5" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">现在，要预测用户是否会购买该产品，需要找出年龄和估计工资之间的关系。在这里，用户ID和性别不是发现这一点的重要因素。</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="b693" class="kh ki hi lz b fi md me l mf mg"><em class="jc"># input </em><br/>x = dataset.iloc[:, [2, 3]].values <br/>  <br/><em class="jc"># output </em><br/>y = dataset.iloc[:, 4].values</span></pre></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="d4e8" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">拆分数据集以进行训练和测试。75%的数据用于训练模型，25%的数据用于测试模型的性能。</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="2de8" class="kh ki hi lz b fi md me l mf mg"><strong class="lz hj">from</strong> <strong class="lz hj">sklearn.cross_validation</strong> <strong class="lz hj">import</strong> train_test_split <br/>xtrain, xtest, ytrain, ytest = train_test_split( <br/>x, y, test_size = 0.25, random_state = 0)</span></pre><p id="a672" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">现在，在这里执行特征缩放非常重要，因为年龄和估计工资值位于不同的范围内。如果我们不缩放特征，那么当模型在数据空间中找到数据点的最近邻居时，估计工资特征将支配年龄特征。</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="428c" class="kh ki hi lz b fi md me l mf mg"><strong class="lz hj">from</strong> <strong class="lz hj">sklearn.preprocessing</strong> <strong class="lz hj">import</strong> StandardScaler <br/>sc_x = StandardScaler() <br/>xtrain = sc_x.fit_transform(xtrain) <br/>xtest = sc_x.transform(xtest) <br/><br/>print (xtrain[0:10, :])</span></pre><p id="07b1" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated"><strong class="jd hj">输出:</strong></p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="4489" class="kh ki hi lz b fi md me l mf mg">[[ 0.58164944 -0.88670699]<br/> [-0.60673761  1.46173768]<br/> [-0.01254409 -0.5677824 ]<br/> [-0.60673761  1.89663484]<br/> [ 1.37390747 -1.40858358]<br/> [ 1.47293972  0.99784738]<br/> [ 0.08648817 -0.79972756]<br/> [-0.01254409 -0.24885782]<br/> [-0.21060859 -0.5677824 ]<br/> [-0.21060859 -0.19087153]]</span></pre><p id="ff67" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">这里曾经看到年龄和估计的工资特征值被缩放，现在在-1到1之间。因此，每个特征在决策中的贡献是相等的，即最终确定假设。</p><p id="8d89" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">最后，我们正在训练我们的逻辑回归模型。</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="f284" class="kh ki hi lz b fi md me l mf mg"><strong class="lz hj">from</strong> <strong class="lz hj">sklearn.linear_model</strong> <strong class="lz hj">import</strong> LogisticRegression <br/>classifier = LogisticRegression(random_state = 0) <br/>classifier.fit(xtrain, ytrain)</span></pre><p id="6901" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">训练完模型后，就可以用它对测试数据进行预测了。</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="9f87" class="kh ki hi lz b fi md me l mf mg">y_pred = classifier.predict(xtest)</span></pre><p id="7881" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">让我们测试一下我们的模型——混淆矩阵的性能</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="f355" class="kh ki hi lz b fi md me l mf mg"><strong class="lz hj">from</strong> <strong class="lz hj">sklearn.metrics</strong> <strong class="lz hj">import</strong> confusion_matrix <br/>cm = confusion_matrix(ytest, y_pred) <br/><br/>print ("Confusion Matrix : <strong class="lz hj">\n</strong>", cm)</span><span id="1bb7" class="kh ki hi lz b fi mh me l mf mg">Confusion Matrix : <br/> [[65  3]<br/> [ 8 24]]</span></pre><p id="2a62" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">满分100分:<br/>真正+真负= 65 + 24 <br/>假正+假负= 3 + 8</p><p id="1443" class="pw-post-body-paragraph ja jb hi jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hb bi translated">绩效衡量——准确性</p><pre class="ka kb kc kd fd ly lz ma mb aw mc bi"><span id="d7e8" class="kh ki hi lz b fi md me l mf mg"><strong class="lz hj">from</strong> <strong class="lz hj">sklearn.metrics</strong> <strong class="lz hj">import</strong> accuracy_score <br/>print ("Accuracy : ", accuracy_score(ytest, y_pred))</span><span id="bba8" class="kh ki hi lz b fi mh me l mf mg">Accuracy :  0.89</span></pre></div></div>    
</body>
</html>