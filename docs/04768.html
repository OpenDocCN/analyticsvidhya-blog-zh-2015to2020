<html>
<head>
<title>Windows User Anomaly Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Windows用户异常检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cyber-security-in-machine-learning-windows-user-anomaly-detection-e0d3457dea32?source=collection_archive---------3-----------------------#2020-03-31">https://medium.com/analytics-vidhya/cyber-security-in-machine-learning-windows-user-anomaly-detection-e0d3457dea32?source=collection_archive---------3-----------------------#2020-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3d8f53db50bd5908d1a45565e15ebfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFOenuXbXcOAzJUQXrVljQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://pixabay.com/images/id-385993/" rel="noopener ugc nofollow" target="_blank"> nvtrlab </a> @pixalbay</figcaption></figure><h2 id="99e7" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph">网络安全中的机器学习</h2><div class=""/><div class=""><h2 id="97d6" class="pw-subtitle-paragraph je ih hy bd b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dx translated">通过机器学习检测异常用户登录的用例</h2></div><blockquote class="jw jx jy"><p id="58f5" class="jz ka kb kc b kd ke ji kf kg kh jl ki kj kk kl km kn ko kp kq kr ks kt ku kv hb bi translated">SOC分析师通常是网络威胁的第一响应者。soc分析师的日常工作是从成千上万的合法事件中搜寻恶意事件。然而，我们中的大多数人，比如我自己，在用尽了所有传统的方法(比如MITRE mapping)之后，经常会纠结于我们应该从“什么”开始。在本文中，我将介绍一个用例，说明我们如何通过机器学习来实现用户登录活动的异常检测，这可能会为其他分析师提供一个基准/参考。</p></blockquote><p id="9eef" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">什么是Windows事件日志？</strong></p><p id="3e28" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">Windows事件日志是Windows存储的系统、安全和应用程序通知的详细记录，供管理员用来诊断系统问题和预测未来问题。Windows事件日志中有几个不同的类别。从安全的角度来看，我们将始终研究存储在% SystemRoot % \ System32 \ wine vt \ Logs \ security . evtx下的安全事件。</p><p id="3e33" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">Microsoft在其Windows服务器和客户端操作系统中包含了事件查看器，用于查看Windows事件日志。用户通过单击开始按钮并在搜索字段中输入事件查看器来访问事件查看器。然后，用户可以选择并检查所需的日志。</p><figure class="la lb lc ld fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kz"><img src="../Images/d9cfb00b7433270830515975268b690f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2ySIbMW6z2fsPyvO.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片来自techtarget.com<a class="ae hv" href="https://searchwindowsserver.techtarget.com/definition/Windows-event-log" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="1a91" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">什么是EventCode 4624:帐户成功登录？</strong></p><p id="d6b0" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">事件代码4624是网络安全分析师或事件响应者最常关注的事件之一。它捕获一个人登录到设备的时间和其他信息，并提供有价值的信息来确定任何受损事件的时间表。事件示例如下所示，可从<a class="ae hv" href="https://www.ultimatewindowssecurity.com/" rel="noopener ugc nofollow" target="_blank"> Windows事件查看器</a>中查看:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="a55a" class="lj lk hy lf b fi ll lm l ln lo">An account was successfully logged on.<br/><br/>Subject:<br/>    Security ID: SYSTEM<br/>    Account Name: DESKTOP-LLHJ389$<br/>    Account Domain: WORKGROUP<br/>    Logon ID: 0x3E7<br/><br/>Logon Information:<br/>    Logon Type: 7<br/>    Restricted Admin Mode: -<br/>    Virtual Account: No<br/>    Elevated Token: No<br/><br/>Impersonation Level: Impersonation<br/><br/>New Logon:<br/>    Security ID: AzureAD\RandyFranklinSmith<br/>    Account Name: rsmith@montereytechgroup.com<br/>    Account Domain: AzureAD<br/>    Logon ID: 0xFD5113F<br/>    Linked Logon ID: 0xFD5112A<br/>    Network Account Name: -<br/>    Network Account Domain: -<br/>    Logon GUID: {00000000-0000-0000-0000-000000000000}<br/><br/>Process Information:<br/>    Process ID: 0x30c<br/>    Process Name: C:\Windows\System32\lsass.exe<br/><br/>Network Information:<br/>    Workstation Name: DESKTOP-LLHJ389<br/>    Source Network Address: -<br/>    Source Port: -<br/><br/>Detailed Authentication Information:<br/>    Logon Process: Negotiate<br/>    Authentication Package: Negotiate<br/>    Transited Services: -<br/>    Package Name (NTLM only): -<br/>    Key Length: 0</span></pre><p id="cc39" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">对于我们将要开发的用例，我们将依赖于此事件代码生成的活动，特别是我们将查看以下字段:</p><ul class=""><li id="2090" class="lp lq hy kc b kd ke kg kh kw lr kx ls ky lt kv lu lv lw lx bi translated"><strong class="kc ii">帐户名</strong>:用于访问特定主机的帐户名</li><li id="1056" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii">工作站名称</strong>:端点主机名</li><li id="9286" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii">源网络地址</strong>:发起登录的IP地址</li></ul><p id="fb4a" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">我们想解决的问题是什么？</strong></p><p id="392c" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">用户异常是指寻找罕见登录模式的练习。例如，如果谷歌/脸书发现你的尝试来自一个未知的IP地址，他们会提示你进行额外的认证。根据我的日常经验，您会知道每台设备都有稳定的登录模式，因为大多数IT操作都是重复的，所以它们的登录模式非常简单。但是，如果您的设备遭到破坏，会发生什么情况？我假设—在事件中，您的设备受到黑客的完全控制，他们需要执行的第一步是收集有关您的IT环境的信息，因此我们很可能会看到正常用户不会触发的不同设备的异常登录 —这是我们希望通过机器学习来验证的。</p><p id="5596" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">我们的实验室设置</strong></p><p id="bb80" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">现在我们有了基本的。我们需要数据来开始我们的开发。因此，我在虚拟机中创建了一个实验室:</p><figure class="la lb lc ld fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/8bc8f4cba45856354eeb5e6bf70b3bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Om6XjdJsfUhDA2u1x2r6A.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">基本的实验室设置</figcaption></figure><p id="616d" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">这是一个相当基本的设置，其中有一个活动目录。所有的服务器和笔记本电脑可以互相通信。活动目录也是使用模拟工具用不同的用户名和密码生成的。还创建了一个脚本来生成来自不同服务器/笔记本电脑的每日登录。我还参考了一些真实的生活数据，以防万一，以模拟现实生活中的情况。</p><p id="c8de" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">接下来，为了执行一些已知的不良行为，我执行了两次攻击:</p><ul class=""><li id="a5f0" class="lp lq hy kc b kd ke kg kh kw lr kx ls ky lt kv lu lv lw lx bi translated">横向移动使用<a class="ae hv" href="https://attack.mitre.org/techniques/T1097/" rel="noopener ugc nofollow" target="_blank">的<strong class="kc ii">传票</strong>的</a></li><li id="1d87" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated">用户和设备枚举使用<strong class="kc ii"/><a class="ae hv" href="https://attack.mitre.org/techniques/T1484/" rel="noopener ugc nofollow" target="_blank"><strong class="kc ii">blood hound</strong></a></li></ul><p id="09ed" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">这两个都是一些常见的侦察和横向移动技术。这构成了我们“正常”和“恶意”数据的基础。</p><p id="8a13" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">模型选择— <em class="kb"> K-最近邻</em> </strong></p><p id="c74b" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">生成原始日志样本后，我通过Eric Zimmerman提供的我最喜欢的工具之一将evtx事件转换成csv格式— <a class="ae hv" href="https://ericzimmerman.github.io/" rel="noopener ugc nofollow" target="_blank"> EvtxECmd </a></p><p id="03f2" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">我们需要选择正确的算法来开始我们的工作。在我写这篇文章之前，我尝试使用一些不同的算法和特性生成方法。最后，我选了K个最近的邻居。</p><p id="cc22" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">K-最近邻是a</p><ul class=""><li id="8e6a" class="lp lq hy kc b kd ke kg kh kw lr kx ls ky lt kv lu lv lw lx bi translated"><strong class="kc ii">监督机器学习算法</strong>因为我们需要知道目标变量。</li><li id="70d3" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated">不要对数据分布模式做任何假设</li><li id="02ab" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated">使用<strong class="kc ii">特征相似度</strong>预测聚类和新点将落入的位置。</li></ul><p id="2756" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">KNN最大的优点是，它们可以帮助您选择正确的邻域来决定新数据点的归属。在我们的活动中，每个IT环境都是不同的，因此根据功能相似性做出决定对我们来说似乎是理想的。</p><p id="364e" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">关于KNN如何运作的细节，你可以点击这里查看。</p><p id="2a9b" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">特征生成</strong></p><p id="e1b5" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">特征生成也是我们需要解决的另一个问题。把我们所有的日志做成有意义的事件，让机器学习去学习。我们需要将我们的日志转换成机器学习功能和数据集。我已经尝试了一些不同的功能，包括登录时间，登录的变化。</p><p id="587d" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">最后，我生成了下面的特性:</p><ul class=""><li id="abe0" class="lp lq hy kc b kd ke kg kh kw lr kx ls ky lt kv lu lv lw lx bi translated"><strong class="kc ii"> islan </strong> —检查源IP地址是否是局域网IP地址(如果是局域网IP地址，会标记为1。对于其他IP地址，它将被标记为0。)</li><li id="97b3" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii"> isnewip </strong> —检查源ip地址是否是访问服务器或工作站的新IP地址(例如，在过去7天内，我们是否看到来自该IP地址的任何类似登录尝试？)</li><li id="e22a" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii"> isvpn </strong> —检查源IP地址是否为VPN IP地址(如果是VPN IP地址，会标记为1。对于其他IP地址，它将被标记为0。)</li><li id="3fe2" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii">百分比</strong> —来自该IP地址的登录事件总数/该服务器的登录事件总数(过去1天)</li><li id="76a6" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii">src _ IP _ c</strong>—15分钟滑动窗口内成功登录的计数。</li><li id="90b9" class="lp lq hy kc b kd ly kg lz kw ma kx mb ky mc kv lu lv lw lx bi translated"><strong class="kc ii">标签</strong> — 1代表恶意流量，0代表正常流量。</li></ul><p id="da0f" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">使用的Python脚本</strong></p><p id="8f2d" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">设置好一切后，最后一件事是将所有这些信息放入要运行的sklearn python脚本中:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="9140" class="lj lk hy lf b fi ll lm l ln lo">from sklearn.neighbors import KNeighborsClassifier<br/>from sklearn import metrics<br/>from sklearn.model_selection import train_test_split<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="f15c" class="lj lk hy lf b fi me lm l ln lo"># loading data - for my case, I divided my dataset into good data and malicious data <br/>df1 = pd.read_csv("&lt;path&gt;\\user_good.csv")<br/>df2 = pd.read_csv("&lt;path&gt; \\user_bad.csv")<br/>df = pd.concat([df1,df2])</span><span id="508f" class="lj lk hy lf b fi me lm l ln lo"># feature used <br/>feature_cols = ['isnewuser','isnewip','isvpn','islan','percent','src_ip_c']<br/>X = df[feature_cols]<br/>y = df['tag']</span><span id="a60e" class="lj lk hy lf b fi me lm l ln lo"># train and split data for testing <br/>X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.4)<br/>k_range= range(1,26)<br/>scores = []</span><span id="0ae4" class="lj lk hy lf b fi me lm l ln lo"># Finding the best K <br/>for k in k_range: <br/>    knn = KNeighborsClassifier(n_neighbors=k)<br/>    knn.fit(X_train, y_train)<br/>    y_pred = knn.predict(X_test)<br/>    scores.append(metrics.f1_score(y_test, y_pred))<br/>  <br/>    targetname = ['Normal','Malicious']<br/>    result = metrics.classification_report(y_test,y_pred,target_names=targetname)<br/>    matrix = metrics.confusion_matrix(y_test, y_pred, labels = [0,1]) <br/>    print ('Currently running K:' + str(k))<br/>    print (result)<br/>    print (matrix)</span><span id="2af4" class="lj lk hy lf b fi me lm l ln lo"># Plotting as graph </span><span id="5abf" class="lj lk hy lf b fi me lm l ln lo">plt.plot(k_range, scores)<br/>plt.xlabel('Value of K for KNN')<br/>plt.ylabel('Testing Accuracy')<br/>plt.show()</span></pre><p id="f182" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">上面我们使用的脚本也是为了找到邻居的最佳数量。</p><p id="fadb" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">结果</strong></p><p id="a1e5" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">结果，我用不同数量的K对模型的F1分数绘制了一个图表。</p><figure class="la lb lc ld fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/6ec9fc5458e7ed27f783b481431a0529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*qZ4JMxWDpVGNKyzD3rZxlQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">测试F1分数</figcaption></figure><p id="adfd" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">结果实际上表明，当K = 4时，模型表现最佳。</p><figure class="la lb lc ld fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/f4ba192960e2ced3b3a67301a4a10d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*c59QeCKdqk2yBD4aWDRajg.png"/></div></figure><p id="7ad1" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">结果表明，当K = 4时，模型表现最好。</p><p id="61dc" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated"><strong class="kc ii">把这个放进SOC警报</strong></p><p id="7019" class="pw-post-body-paragraph jz ka hy kc b kd ke ji kf kg kh jl ki kw kk kl km kx ko kp kq ky ks kt ku kv hb bi translated">有了上面的准确性和f1分数，我将模型作为每日报告运行。平均来说，我意识到我在寻找恶意登录上至少少花了5到10分钟。该模型也非常有助于实现取证分析。当我从映像设备中提取eventlog out时，我可以快速运行模型来识别任何异常的设备登录，以确认初始入口点:)。</p></div></div>    
</body>
</html>