<html>
<head>
<title>Searching in AI — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能中的搜索—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/searching-in-ai-e05973068c8e?source=collection_archive---------6-----------------------#2020-01-24">https://medium.com/analytics-vidhya/searching-in-ai-e05973068c8e?source=collection_archive---------6-----------------------#2020-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6b5f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这个系列将引导你了解人工智能中使用的搜索算法的可视化。第1部分探讨了著名的图遍历DFS，BFS和Dijkstra的算法，有趣的可视化。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/625c64ee40abd6a0da968c46bed57626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVleYRlsMDMRFXi7slCECg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">A*搜索算法。</figcaption></figure></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="78a2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">介绍</h1><p id="a8f1" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku kv kw kx ky kz la lb lc ld le lf lg lh hb bi translated">我们将通过可视化来了解人工智能中使用的搜索算法是如何工作的。我建议阅读《人工智能:Russel和Norvig的现代方法》一书的第三章和第四章，以获得详细的分析和完整的伪代码。根据本书的约定，本文将探讨图搜索算法。本文不提供算法分析，而是集中探讨不同搜索算法的行为。</p><p id="dac0" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">文章中使用的数据结构和对陈述的证明可以在托马斯·h·科尔曼的《T2【2】算法导论》一书的第22章和第24章中找到。</p><p id="4cf6" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">计算机科学和编程背景会有所帮助，但不是必需的。如果你对图论入门不太熟悉的话，可能会有点难掌握。</p><p id="e6e5" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">在下一节中设置了问题陈述。第2节讨论解决这个问题的方法，最后一节我们在更大的范围内比较这些算法。</p><p id="179e" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">算法的详细代码没有在文章中涉及，但可以在GitHub上作为一个项目获得<a class="ae li" href="https://github.com/aimacode" rel="noopener ugc nofollow" target="_blank">艾玛代码/艾玛python </a>，它是由本书的作者发起的【1】。</p><p id="3c3b" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">用于动画的代码可以在这个<a class="ae li" href="https://github.com/tirthasheshpatel/Searching-in-AI" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上获得。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="bfad" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">规划</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/d924d6eb2c6edf71dfd90118224fc57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMPJRUZG9ZoHtxo04ouwtA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图1:抽象之前的问题(<a class="ae li" href="https://www.google.com/url?sa=i&amp;source=images&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjo8JmlzpXnAhWQ8XMBHbBXDssQjRx6BAgBEAQ&amp;url=https%3A%2F%2Fwww.123rf.com%2Fphoto_6641728_beautiful-park.html&amp;psig=AOvVaw3I1uYD81A_48PKugdyulyw&amp;ust=1579727635765778" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="db39" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">假设，你家附近新开了一个公园(图1 ),你决定去野餐。当你到达公园时，你发现它相当大，有许多随意的墙。你很饿，整个公园只有一个小吃摊。所以，你开始探索公园找到摊位。这是一个简单的问题，假设你在公园的某个地方，目标是到达小吃摊。</p><blockquote class="lp"><p id="faec" class="lq lr hi bd ls lt lu lv lw lx ly lh dx translated">我们的第一步是将问题转化为一个数学实体，并删除尽可能多的细节，同时保留原始问题提供的目标。</p></blockquote><figure class="lz ma mb mc md jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b9a43f06bf5261ac1b554f39e15bcc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U567xFo2OX6etHTFkdRl9Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图2:我们问题的抽象表示。绿点是我们的初始状态，红点是目标状态，灰点是不可及的状态或墙壁。</figcaption></figure><p id="4d97" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">在我们的例子中，公园可以被视为由整数坐标点组成的2D平面(图2)。公园位于平面的第一象限，由长度和宽度与公园的实际大小成比例的墙所包围。</p><p id="7a09" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">让我们定义一个<strong class="ko hj">状态</strong>为这个平面上的一个点。现在，您的位置可以表示为公园中的2D点。姑且称这种<strong class="ko hj">初始</strong>状态。类似地，也可以使用公园中的2D点来表示小吃摊。姑且称这种<strong class="ko hj">目标为</strong>状态。壁可以表示为在壁的方向上延伸的一系列相邻点，其长度与壁的长度成比例。让我们将所有这些点的集合定义为“<strong class="ko hj">不可到达的</strong>状态或带有“<strong class="ko hj">障碍的</strong>状态”。我们的目标是到达给定初始状态的目标状态，而不进入“不可到达”状态。</p><p id="ba04" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">一个细心的读者可能已经注意到，你饿了的事实已经不重要了！你骑自行车或步行去小吃摊的事实也是如此！这个从问题中去除细节的过程叫做<strong class="ko hj"> <em class="me">抽象</em> </strong>。抽象帮助我们将问题转化为一个数学实体，它的解比原始问题的解更容易找到。我们还没完。我们现在需要定义新世界的规则或“物理学”。这些规则可以定义如下:</p><ol class=""><li id="8284" class="mf mg hi ko b kp lj ks lk kv mh kz mi ld mj lh mk ml mm mn bi translated">可以进入任何相邻状态或与当前状态对角相邻的状态。</li><li id="2bb8" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">一个人不能进入无法到达的状态(墙或障碍物)。</li><li id="5dab" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">进入一个新状态的代价总是1。(我们以后可能会更改此规则，但正式来说，一旦设置，规则就不能更改)</li></ol></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="ebc5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">搜索</h1><p id="d1d4" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku kv kw kx ky kz la lb lc ld le lf lg lh hb bi translated">正式定义了问题之后，下一步就是设计一个搜索算法来解决手头的问题。有很多这样的算法，我们将在本系列的后面讨论。通过询问以下问题来分析搜索算法:</p><ol class=""><li id="2fc6" class="mf mg hi ko b kp lj ks lk kv mh kz mi ld mj lh mk ml mm mn bi translated">算法会在有限时间内找到解吗？"<em class="me">完整性</em>"</li><li id="599e" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">算法需要多长时间？<em class="me">时间复杂度</em></li><li id="84e2" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">算法完成需要多少内存？<em class="me">空间复杂度</em></li></ol><p id="8784" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">我们的例子可以看作一个图(如果你熟悉图论的话)，每个状态作为一个节点，相邻的节点通过一条无向边连接起来，如图3所示。我们还可以为每条边分配一个权重，作为通过该边移动到相邻状态的成本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/fe11411729298bccc6420f3c1a7920b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*AQ8aJqG8FTNCM0Z97s2o9g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图3:问题图和从中间绿色节点到达节点的相应动作。</figcaption></figure><p id="91e2" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">我们进一步定义一个“<strong class="ko hj"> <em class="me">动作</em> </strong>”(它只是图中的一条边)作为从某个当前状态移动到一个新状态的方法。在我们的问题中，我们可以定义动作“向北”、“向南”、“向东”、“向西”、“东北”、“西北”、“东南”和“西南”。这些行为可以在搜索过程中被探索、尝试。还有一个“允许”行为的概念。比方说，你在我们公园的坐标(0，0)处，尝试“向北走”动作。这将产生(1，0)作为新的状态。类似地，允许“向东北”和“向东”动作，但不允许其他动作，因为它们会产生位于公园外的负坐标。产生包含障碍的状态的动作也是不允许的！</p><p id="bd47" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">这就完成了问题的公式化，但是“状态”和“节点”之间的区别还没有确定。</p><p id="dd74" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">一个“<strong class="ko hj">节点</strong>”将一个“状态”、它的“路径开销”、它的“父节点”以及从父状态到达该状态所需的“动作”包含在它自身中。路径成本是指从初始节点到达该节点的“成本”。父节点指向到达该节点的节点。</p><p id="dab7" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">在我们的例子中，2D点(如(0，0)，(0，1)等)是状态，从初始状态到达一个状态所需的步骤数是路径成本。可以创建一个节点来帮助记录不同的属性。</p><p id="7a55" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">这个问题定义了设计一个可以解决这个问题的算法所需的所有术语。接下来的小节将讨论解决这个问题的不同方法。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="ed8c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">使用BFS搜索</h1><blockquote class="lp"><p id="b71a" class="lq lr hi bd ls lt lu lv lw lx ly lh dx translated">广度优先搜索(BFS)是一种技术，用于在每个方向上均匀地遍历图形，而不考虑路径开销。</p></blockquote><p id="63e9" class="pw-post-body-paragraph km kn hi ko b kp mu ij kr ks mv im ku kv mw kx ky kz mx lb lc ld my lf lg lh hb bi translated">现在，当一个新的状态被访问时，我们需要将它标记为“已访问”或者将相应的节点存储在某个地方，以便我们可以在需要时检索信息。否则，算法可能会一次又一次地进入相同的状态，很可能会陷入无限循环。让我们将所有已经被访问(到达)的节点存储在一个名为“已到达<strong class="ko hj"/>”的<em class="me">集合</em>中。</p><p id="906c" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">我们还需要存储其动作有待探究的节点。姑且称此为“<strong class="ko hj">边疆</strong>”。搜索算法的最大不同在于它们用来对<strong class="ko hj">边界中的节点进行排序的方法。</strong></p><p id="aca5" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">我们另外将已经浏览过的节点存储在一个名为“<strong class="ko hj"> explored </strong>”的集合中。这不是必需的，因为信息包含在可达集合中，但是用于理解搜索算法的行为。</p><p id="7226" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">该算法使用一种称为<a class="ae li" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="ko hj">队列</strong> </a> <strong class="ko hj"> </strong>(有时称为先进先出队列的FIFOQueue)的数据结构来排序和存储<strong class="ko hj">边界</strong>中的节点。现在，我们可以开始形式化算法:</p><ol class=""><li id="e7bc" class="mf mg hi ko b kp lj ks lk kv mh kz mi ld mj lh mk ml mm mn bi translated">将对应于初始状态的节点存储在<strong class="ko hj">边界</strong>队列中。</li><li id="fa52" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">如果队列不为空，从<strong class="ko hj">边界</strong>队列中弹出一个节点进行探索(最初是我们的初始节点),否则转到步骤5。</li><li id="5b23" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">如果结果状态不包含任何<strong class="ko hj">障碍</strong>并且不存在于<strong class="ko hj">到达</strong>集合中，则在将结果节点存储在<strong class="ko hj">到达</strong>集合中的那个节点的状态下，一次尝试一个动作。如果任何结果节点包含目标状态，则转到步骤5。</li><li id="c2d2" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">将该节点添加到浏览集，并转到步骤2。</li><li id="06d9" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">结束。</li></ol><p id="860d" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">图4显示了这种算法。您可以看到，该算法在探索任何具有更高路径开销的节点之前，首先探索具有相同路径开销的所有节点(位于距初始状态相同距离的节点)。这就是它被称为“广度”优先搜索的原因。它通过首先沿着网格的宽度探索节点来探索网格。</p><p id="a726" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">可以证明，如果所有节点从一个状态移动到另一个状态的步长开销相同，则BFS搜索具有最小路径开销的路径。参考文献[2]以获得该陈述的正式证明。</p><p id="0b93" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">我们可以看到，BFS已经在96个可探索的州中的69个州寻找解决方案。在我们的情况下，这个解决方案是最优的，因为从一个状态移动到另一个相邻状态的成本是1。该解决方案的路径开销为10。</p><blockquote class="mz na nb"><p id="dd19" class="km kn me ko b kp lj ij kr ks lk im ku nc ll kx ky nd lm lb lc ne ln lf lg lh hb bi translated">探索:69，路径成本:10</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图4: BFS可视化。蓝色节点对应已达到的状态，黑色十字对应已探索的状态，深蓝色对应达到目标的路径。请注意，该算法如何探索具有相同路径开销的节点，然后继续探索具有更高路径开销的节点。</figcaption></figure><p id="c78d" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">请注意，我没有提供算法中节点的任何路径开销和其他属性的簿记。此外，没有提供算法的分析，留给读者去探索。详细算法参考文献[1]。</p><h1 id="288e" class="ju jv hi bd jw jx nh jz ka kb ni kd ke io nj ip kg ir nk is ki iu nl iv kk kl bi translated">使用DFS搜索</h1><blockquote class="lp"><p id="3f99" class="lq lr hi bd ls lt lu lv lw lx ly lh dx translated">深度优先搜索(DFS)是一种遍历图的技术，它首先探索最深的节点，而不考虑路径开销。</p></blockquote><p id="ffa5" class="pw-post-body-paragraph km kn hi ko b kp mu ij kr ks mv im ku kv mw kx ky kz mx lb lc ld my lf lg lh hb bi translated">已到达和已探索的节点将被存储在类似于BFS的<strong class="ko hj">已到达</strong>和<strong class="ko hj">已探索</strong> <em class="me">集合</em>中。边界将包含有待探索的节点。但是<strong class="ko hj"> frontier </strong>在这里被实现为<strong class="ko hj"><em class="me"/></strong>(也称为<em class="me"> LIFOQueue </em>用于后进先出队列)<strong class="ko hj"> <em class="me"> </em> </strong>不像BFS的<em class="me">队列</em>。使用这些符号，我们可以进一步形式化算法:</p><ol class=""><li id="7706" class="mf mg hi ko b kp lj ks lk kv mh kz mi ld mj lh mk ml mm mn bi translated">将初始状态对应的节点存储在<strong class="ko hj">边界</strong>堆栈中。</li><li id="022f" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">从<strong class="ko hj">边界</strong>堆栈中弹出一个节点进行探索。</li><li id="7d50" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">选择一个未探索的动作来探索并在<strong class="ko hj">边界</strong>堆栈和<strong class="ko hj">到达</strong>集合中存储结果节点(如果尚未出现在其中),并且结果节点不包含<strong class="ko hj">障碍</strong>,否则继续。重复此步骤，直到到达最深的节点，否则无法执行进一步的操作。如果在探索过程中达到了目标状态，请转到步骤6。</li><li id="a938" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">将节点添加到<strong class="ko hj">浏览的</strong>集合。</li><li id="a059" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">转到步骤2。</li><li id="7ccc" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">结束。</li></ol><p id="75da" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">图5提供了DFS的可视化。请注意算法如何越来越深入地探索状态，直到用尽所有选项。这就是它被称为深度优先搜索的原因。</p><p id="d1f1" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated"><strong class="ko hj">它不保证任何安排的最优解</strong>。还应注意的是，与BFS相比，它需要相对较长的时间来求解，并且会到达网格中96个州中的95个。但好处是内存需求。</p><p id="4998" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">它需要与边界堆栈中存在的节点成比例的内存，这些节点不超过最大深度乘以被浏览节点的最大分支(分支是该状态下可用的动作)。而BFS需要与节点的最大分支成比例的存储器，该节点具有作为其指数的最大深度(解持续存在的深度)。DFS消除了BFS内存需求中的指数，这是一个巨大的改进。但是它在时间上是低效的，并且通常需要更长的时间来搜索目标。(如果你熟悉时空权衡，这个会很清楚。)</p><blockquote class="mz na nb"><p id="ec10" class="km kn me ko b kp lj ij kr ks lk im ku nc ll kx ky nd lm lb lc ne ln lf lg lh hb bi translated">探索:95，路径成本:14</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图5:深度优先搜索可视化。需要更长的时间来寻找解决方案，并且解决方案不是最优的。但是它需要线性记忆，不像BFS需要指数记忆。</figcaption></figure></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="c1ea" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">统一成本搜索</h1><blockquote class="lp"><p id="0ee2" class="lq lr hi bd ls lt lu lv lw lx ly lh dx translated">统一成本搜索(UCS)是一种通过根据路径成本改变搜索队列中节点的顺序来寻找最优解的技术。</p></blockquote><p id="39a4" class="pw-post-body-paragraph km kn hi ko b kp mu ij kr ks mv im ku kv mw kx ky kz mx lb lc ld my lf lg lh hb bi translated">该算法使用一个优先级队列来对要探索的节点进行排序。优先级队列根据节点的<em class="me">优先级</em>(只是分配给该节点的一个值)对节点进行排序。可以选择最小或最大优先级值位于队列的前面。出于我们的目的，具有最小优先级值的节点位于优先级队列的前面。</p><p id="a176" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">统一成本搜索，也称为Dijkstra算法，非常类似于BFS，但在以下三个方面有所不同:</p><ol class=""><li id="f03b" class="mf mg hi ko b kp lj ks lk kv mh kz mi ld mj lh mk ml mm mn bi translated">队列中节点的顺序不同。</li><li id="5422" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">如果在探索期间发现，我们可以替换边界中具有较低优先级值的节点。</li><li id="5fd0" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">我们在探索之后检查节点是否包含目标状态(不像BFS在探索期间检查这个条件)。</li></ol><p id="3b95" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">当我们看算法时，这将变得清楚。</p><p id="100f" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">我们使用路径成本(从初始状态到达一个状态)作为队列中节点的优先级值。因此，具有最小路径开销的节点位于队列的最前面，首先被探索。</p><ol class=""><li id="f302" class="mf mg hi ko b kp lj ks lk kv mh kz mi ld mj lh mk ml mm mn bi translated">将初始节点存储在<strong class="ko hj">边界</strong>优先级队列中。</li><li id="16ad" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">如果不为空，从<strong class="ko hj">边界</strong>弹出一个节点，否则进入步骤6。如果节点包含目标状态，则转到步骤6。</li><li id="34cd" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">一个接一个地探索节点的每个动作，如果结果节点不在其中一个中，并且结果状态不包含<strong class="ko hj">障碍</strong>，则将结果节点添加到<strong class="ko hj">边界</strong>和<strong class="ko hj">到达</strong>集合中。如果其中一个结果节点的状态已经存在于具有更高路径开销的队列中，则用该结果节点替换该节点。</li><li id="2630" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">将节点添加到<strong class="ko hj">浏览的</strong>集合。</li><li id="8ff8" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">重复步骤2，直到弹出的节点包含目标状态。</li><li id="c932" class="mf mg hi ko b kp mo ks mp kv mq kz mr ld ms lh mk ml mm mn bi translated">结束。</li></ol><p id="ed55" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">第三步包含了许多读者忽略的微妙之处。最后一条语句要求用另一个包含相同状态但路径开销更低的节点替换队列中存在的节点。这一步尤其重要，因为找到了一个节点，该节点包含比队列中存在的路径具有更低成本的路径，同时两者都从初始状态到达相同的状态。如果我们不替换队列中的那个节点，那么有可能通过另一个节点存在更好的解决方案。这有点令人困惑，但随着你对算法的深入研究，它会变得清晰。</p><p id="e012" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">该算法的可视化如图6所示。当从一个州迁移到邻近的州的成本相同时，它就像BFS一样，但是当我们引入不同的成本时，它的功能就不同了。图6中的可视化使用了“加权”网格，该网格引入了从一个状态移动到相邻状态的正成本。</p><p id="83d7" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">需要注意的非常重要的一点是，如果问题的任何地方出现负权重，该算法并不能保证找到最优解。证明可以在[2]的第24章中找到。</p><p id="739a" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">显然，路径成本增加了，因为现在成本不是1。可以看出，如果权重大于某个正常数ε，则该算法达到最优解。</p><blockquote class="mz na nb"><p id="f9da" class="km kn me ko b kp lj ij kr ks lk im ku nc ll kx ky nd lm lb lc ne ln lf lg lh hb bi translated">探索:55，路径成本:84</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图6: Dijkstra的算法。它主要探索路径开销小于最佳路径开销的节点。这里使用的像元权重定义了从一个像元移动到另一个像元的成本。这就是路径成本增加的原因。</figcaption></figure></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h1 id="8695" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">比较BFS、DFS和UCS</h1><p id="a352" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku kv kw kx ky kz la lb lc ld le lf lg lh hb bi translated">BFS、DFS和UCS在小网格上产生类似的结果，因此需要更大的网格来理解算法的实际行为。让我们创建一个大网格，比较这三种算法。此网格是加权的，成本是从均匀分布中随机生成的。</p><p id="2017" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">结果如下所示:</p><p id="835f" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">BFS搜索了396个州，找到了一个路径开销为565的解决方案。这是BFS的预期行为。</p><blockquote class="mz na nb"><p id="79e9" class="km kn me ko b kp lj ij kr ks lk im ku nc ll kx ky nd lm lb lc ne ln lf lg lh hb bi translated">BFS —探索:396，路径开销:565</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="a01a" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">DFS(意外地)很快找到了解决方案，但最终找到了一条非常低效的路径，路径开销为1005。在实践中，DFS将花费更多的时间来寻找解决方案，并最终探索许多不必要的状态。</p><blockquote class="mz na nb"><p id="7151" class="km kn me ko b kp lj ij kr ks lk im ku nc ll kx ky nd lm lb lc ne ln lf lg lh hb bi translated">DFS已探测:222，路径开销:1005</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="e245" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku kv ll kx ky kz lm lb lc ld ln lf lg lh hb bi translated">UCS搜索了370个州，找到了一条最小路径开销为542的路径。由于该网格使用使用均匀分布初始化的权重，因此在达到目标之前，搜索必须探索几乎所有的状态。实际上，搜索以循环方式扩展，首先探索路径成本较低的州。</p><blockquote class="mz na nb"><p id="1e17" class="km kn me ko b kp lj ij kr ks lk im ku nc ll kx ky nd lm lb lc ne ln lf lg lh hb bi translated">UCS —探索:370，路径开销:542</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>