<html>
<head>
<title>Chapter 4.2 — Linear Regression Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第4.2章—线性回归模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/chapter-4-2-linear-regression-using-pytorch-built-ins-6cba7900e779?source=collection_archive---------26-----------------------#2020-06-29">https://medium.com/analytics-vidhya/chapter-4-2-linear-regression-using-pytorch-built-ins-6cba7900e779?source=collection_archive---------26-----------------------#2020-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a675" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用PyTorch内置</h2></div><p id="604a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇博客<a class="ae jt" rel="noopener" href="/analytics-vidhya/chapter-4-1-linear-regression-model-using-pytorch-built-ins-53e8be20fb96">第4.1章</a>中，我们详细讨论了一些常用的内置PyTorch包，以及我们将用来构建线性回归模型的一些基本概念。在这篇博客中，我们将使用PyTorch内置工具来构建我们的模型。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/5546d2f14ff76289876acf4b096050aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFLF3sBYV601ZHDQkjQxZQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated"><a class="ae jt" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fquantumcomputingtech.blogspot.com%2F2019%2F04%2Flinear-regression-machine-learning.html&amp;psig=AOvVaw2WW3z45m4vGVKnnjoCtYWh&amp;ust=1592674209224000&amp;source=images&amp;cd=vfe&amp;ved=0CAMQjB1qFwoTCNio1pm1juoCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="e6e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我们将使用个人年龄、性别、身体质量指数、孩子数量和吸烟习惯等信息来准确预测保险费用。这种模型有助于保险公司确定一个人的年度保险费。这个问题的数据集取自:【https://www.kaggle.com/mirichoi0218/insurance<a class="ae jt" href="https://jovian.ml/outlink?url=https%3A%2F%2Fwww.kaggle.com%2Fmirichoi0218%2Finsurance" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d56c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将通过以下步骤创建一个模型:</p><ol class=""><li id="0a75" class="kk kl hi iz b ja jb jd je jg km jk kn jo ko js kp kq kr ks bi translated">下载并探索数据集，</li><li id="5559" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">准备用于训练的数据集，</li><li id="dc52" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">创建线性回归模型，</li><li id="dd33" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">训练模型以适应数据，</li><li id="6c7b" class="kk kl hi iz b ja kt jd ku jg kv jk kw jo kx js kp kq kr ks bi translated">使用训练好的模型进行预测。</li></ol><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ky"><img src="../Images/f323ce123fafb1a0869c398943af8df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxs0822WzpgqCpjKkbqnNg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="d64c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从导入所需的包开始。我们已经讨论了前一篇博客中使用的大多数包。</p><h2 id="11aa" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated"><strong class="ak">步骤1 :-下载并浏览数据</strong></h2><p id="8542" class="pw-post-body-paragraph ix iy hi iz b ja lu ij jc jd lv im jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">对于这个博客，我们将使用Kaggle平台来构建我们的模型。我们可以直接从Kaggle加载数据集。</p><p id="e08a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了将数据集加载到内存中，我们将使用pandas库中的read_csv函数。这些数据将作为熊猫数据框架加载。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lz"><img src="../Images/37e90e2e6e79516a50ac8f9a03a0ca72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJ9VnbSe1Db_CWcccwzjcA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="9890" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用Pandas中的head函数打印数据集的前五行。</p><p id="5fed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将对数据集做一个小的定制，这样每个读者都能得到一个稍微不同的数据集。这一步不是强制性的。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ma"><img src="../Images/bd56e08a12ec9b65dcbc58976de53b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8TcFlHnZejyI_9Ap8r3NA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mb"><img src="../Images/0b6d79dbd44b934b06c1fb0bc573de4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P96BEvATAbETK07k5nR4w.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="7d85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">customize_dataset函数将使用您的姓名作为随机数的来源来稍微定制数据集。</p><p id="e0b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们调用customize函数，将dataset和your_name作为参数传递，并使用head函数检查数据集的前几行。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mc"><img src="../Images/f93bb254afdb93fe433c1beb66dd18f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhf3K3MmJqrDqPVPvHzrQQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="8297" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们找出数据集中的行数和列数。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es md"><img src="../Images/a7ca31f80e76863e251886a339fb9fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXBjsc-oZwCTeMxQWToGqA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es me"><img src="../Images/61b76a49aaa9896f02c1e456568be4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29NEtzDeF3e5Z1y-j64M4w.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="1cab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们应该分配输入、输出和分类列(非数字的输入列)。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mf"><img src="../Images/3dff673a46bbb5da31d097025a3ad0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfYmE0_JTx7mSlPZu8msqQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mg"><img src="../Images/f7d8865f9309d472d335649f0eb71323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2-6pMvyWF9MmsYZNiZAtg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mh"><img src="../Images/de650925e7c219284e28f727805d37c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwSL4Vu8EdKqeVS0oaeRNQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="5761" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以找到输出列“电荷”的最小值、最大值和平均值。我们也可以在图表中画出电荷的分布。作为参考，请看看https://jovian.ml/aakashns/dataviz-cheatsheet。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mi"><img src="../Images/ecb074ee91e89685daeb3e6e7241998f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FIA7z9TF44Bwtag2W0DjA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><h2 id="fff7" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated"><strong class="ak">步骤2 :-准备用于训练的数据集</strong></h2><p id="ffa4" class="pw-post-body-paragraph ix iy hi iz b ja lu ij jc jd lv im jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">我们需要将熊猫数据框架中的数据转换成PyTorch张量用于训练。为此，第一步是将其转换为numpy数组，第二步是将分类列转换为数字。</p><p id="a8da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通读<a class="ae jt" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html" rel="noopener ugc nofollow" target="_blank">熊猫文档</a>，了解我们如何将分类变量转换成数字。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mj"><img src="../Images/518e9805ad873ef8008de0596341955b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5wAEhBv4-FPk9WVfxttrw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mk"><img src="../Images/288f4a24107c0a998d87d9be2bd12f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NCgKv8rkxspMN2GBOzU6w.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="addf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一步是将这些numpy数组转换成PyTorch张量。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ml"><img src="../Images/ef4402103e8b6d307ccaf6018be5c779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hBk74v1xm9m_iSBN8wUTw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="85e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用输入和目标张量来创建PyTorch数据集和数据加载器，用于训练和验证。我们将首先创建一个TensorDataset，然后创建训练和验证数据集。我们将使用random_split函数来分割数据集，以获得训练和验证数据集。最后，选择一个批量大小来创建用于训练和验证的数据加载器。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mm"><img src="../Images/7df313d24f9efa6af9382c1896298960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNMA_GllGdZPm_fspgOiAQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mn"><img src="../Images/4918b4aa458a0ddfe49fe6d333af5b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3osLsYs4rCCIDIzmmDIwA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mo"><img src="../Images/571931bbb3f8f1c4fa73090ba979bccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhOW7UIlcfnLwbsiGnR2Eg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="8eae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们进入下一步之前，让我们来看一组数据。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mp"><img src="../Images/ecb07fd9f02b4662c5f5133bd1b2a99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEa-Vc5W2Hsv56KI6QX8PQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><h2 id="9d71" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated"><strong class="ak">步骤3 :-创建一个线性回归模型</strong></h2><p id="3058" class="pw-post-body-paragraph ix iy hi iz b ja lu ij jc jd lv im jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">让我们创建保险模型的类定义。在创建类之前，我们必须找到输入和输出列的大小。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mq"><img src="../Images/13daf426ba49076b73466ec0a0d8be0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaKl0ZaAKtZkLir9rX4fKA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mr"><img src="../Images/4830c64517d671b7ccb3b0a8fb94ca34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWXg6k71hHWP4s-YvY1n0g.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="733c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们讨论一下每个函数的作用。training_step函数获取一批数据。从batch中我们得到输入，self(输入)，self表示模型本身，它调用forward函数并将输入作为参数传递。在nn.module中，实现了一个可调用的方法，该方法只接受输入并传递给forward函数。</p><p id="15ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">validation_step函数也遵循与training_step函数相同的方法。此外，我们还计算并返回验证损失。</p><p id="e43e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们运行完所有的批处理之后，我们得到了输出列表。我们提取出每一批的损失，并求出该批损失值的平均值，从而得到每个时期的验证损失。这是由validation_epoch_end函数完成的。</p><p id="9b33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在每个时期之后，我们记录该时期的时期号和验证损失。我们显示每个第20个时期和最后一个时期的时期编号和验证损失。这是由epoch_end函数完成的。</p><p id="9f78" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们使用InsuranceModel()类创建一个模型，并使用model.parameters检查模型的权重和偏差。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ms"><img src="../Images/c48da196ad1e301ec29aaa97cf19435c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDzih4zuLxjOb8WqurlMsw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mt"><img src="../Images/d95e13388e9f3c310c694e16488b9ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loD5PkeuFJowPMVGLncOzQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><h2 id="010a" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated"><strong class="ak">步骤4 :-训练模型</strong></h2><p id="87e9" class="pw-post-body-paragraph ix iy hi iz b ja lu ij jc jd lv im jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">为了训练我们的模型，我们将使用拟合方法。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mu"><img src="../Images/36610a6bef97c243a030cf685777e18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_KW7aHgiuiQbqoyFoI_Gw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="89ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">evaluate函数接受两个参数模型和val_loader。它迭代验证数据集中的批次，并为每个批次调用validation_step函数。对于每一批，它都将验证损失作为一个对象取回。所有这些被组合成列表，我们得到返回的对象列表作为输出。</p><p id="30b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，我们称之为validation_epoch_end(输出)。这将返回包含验证数据集平均损失的对象。</p><p id="fc68" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拟合函数创建一个优化器，默认情况下使用torch.optim.SGD对模型参数(权重和偏差)执行梯度下降。它还将历元数、学习率、模型、train_loader和val_loader作为输入。我们声明history[]来存储每个时期的验证损失。</p><p id="6dd7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在训练之前，调用evaluate函数来计算验证集的损失。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mv"><img src="../Images/3d3bad07cbae1043cec444732fd0db36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MFjBFcBOlLHzLRStjCPlw.png"/></div></div></figure><p id="bfb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在准备训练模型。您可能需要多次运行训练循环，针对不同的时期数和不同的学习率，以获得良好的结果。此外，如果您的损失变得太大(或nan)，您可能需要通过运行model = InsuranceModel()来重新初始化模型。尝试一段时间，尽量降低损失。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mw"><img src="../Images/4d20239eca5427f54429dd357e392ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*re4wLzNda9Ss2_k7PXhwLA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mx"><img src="../Images/8e03c0e0834720227028425da328a08e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGpZ8_7SXCXWfBb911D16A.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es my"><img src="../Images/e563e51a355c2dccb4b512f1a77f2af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2d5xC6Tdao0gIkaULocyKQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="9b08" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到了6369.4995的最终确认损失。重新初始化模型，并尝试不同的批量大小、时期数、学习率等，以获得更低的验证损失。</p><h2 id="c225" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated"><strong class="ak">步骤5 :-使用训练好的模型进行预测</strong></h2><p id="4b19" class="pw-post-body-paragraph ix iy hi iz b ja lu ij jc jd lv im jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">让我们写一个函数来做一些预测。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mz"><img src="../Images/721ef1ecc04859cf1c2d41527122debe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtRGdewX6fBJk08FRZDIBw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">由作者生成</figcaption></figure><p id="4949" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用unsqueeze(0)方法来给出一个额外的维度，以便它表示一批图像。正如我们所看到的，预测值非常接近目标值。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="4b95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="nh">感谢阅读，下期再见！</em></p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><blockquote class="ni nj nk"><p id="ace8" class="ix iy nh iz b ja jb ij jc jd je im jf nl jh ji jj nm jl jm jn nn jp jq jr js hb bi translated">如果你需要这个博客的链接，请留下你的评论。</p></blockquote></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><blockquote class="ni nj nk"><p id="f83f" class="ix iy nh iz b ja jb ij jc jd je im jf nl jh ji jj nm jl jm jn nn jp jq jr js hb bi translated">对于博客的进一步阅读，</p></blockquote><div class="no np ez fb nq nr"><a href="https://data36.com/pandas-tutorial-1-basics-reading-data-files-dataframes-data-selection/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab dw"><div class="nt ab nu cl cj nv"><h2 class="bd hj fi z dy nw ea eb nx ed ef hh bi translated">熊猫教程1:熊猫基础(read_csv，DataFrame，数据选择等。)</h2><div class="ny l"><h3 class="bd b fi z dy nw ea eb nx ed ef dx translated">Pandas是最受欢迎的用于数据科学和分析的Python库之一。我喜欢说它是“SQL of…</h3></div><div class="nz l"><p class="bd b fp z dy nw ea eb nx ed ef dx translated">data36.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ke nr"/></div></div></a></div><div class="no np ez fb nq nr"><a href="https://pytorch.org/docs/stable/nn.functional.html#loss-functions" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab dw"><div class="nt ab nu cl cj nv"><h2 class="bd hj fi z dy nw ea eb nx ed ef hh bi translated">torch.nn.functional - PyTorch主文档</h2><div class="ny l"><h3 class="bd b fi z dy nw ea eb nx ed ef dx translated">在某些情况下，将CUDA后端与CuDNN一起使用时，该操作员可能会选择一个不确定的算法来…</h3></div><div class="nz l"><p class="bd b fp z dy nw ea eb nx ed ef dx translated">pytorch.org</p></div></div></div></a></div></div></div>    
</body>
</html>