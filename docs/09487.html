<html>
<head>
<title>Building RGB Color Classifier: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建RGB颜色分类器:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-rgb-color-classifier-part-1-af58e3bcfef7?source=collection_archive---------0-----------------------#2020-09-08">https://medium.com/analytics-vidhya/building-rgb-color-classifier-part-1-af58e3bcfef7?source=collection_archive---------0-----------------------#2020-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="62c2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><a class="ae ix" href="#5e08" rel="noopener ugc nofollow">数据集创建</a>、<a class="ae ix" href="#4140" rel="noopener ugc nofollow">预处理</a>、&amp;、<a class="ae ix" href="#023b" rel="noopener ugc nofollow">构建人工神经网络模型</a>及其<a class="ae ix" href="#607f" rel="noopener ugc nofollow">性能评估</a></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/076e41e33f8ff8c1b561537434c52f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t97HCg6I69ecIR9q3TRvDA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><a class="ae ix" href="https://rgb-color-classifier.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jo"> RGB颜色分类器</strong> </a> <strong class="bd jo"> </strong>(图片由作者提供)</figcaption></figure><p id="7868" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在一级防范禁闭期间，我正在试验从Youtube、Coursera、NPTEL等各种渠道学到的<em class="kl">机器学习</em>和<em class="kl">深度学习</em>概念。将这些概念应用到项目中帮助我更深入地理解它们。因此，我们将建立一个非常有趣的项目，帮助我们深入了解数据科学的世界。此外，我希望如果你正在做一个类似的项目，这个博客将有助于减少你在构建项目时可能面临的时间和困难！</p><p id="cc22" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这里有<a class="ae ix" href="https://github.com/AjinkyaChavan9/RGB-Color-Classifier-with-Deep-Learning-using-Keras-and-Tensorflow" rel="noopener ugc nofollow" target="_blank"> Github回购链接</a>和<a class="ae ix" href="https://rgb-color-classifier.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> App链接</a>如果你着急的话！！别再浪费时间了，让我们开始吧。</p><h1 id="0431" class="km kn hi bd jo ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">项目描述</h1><p id="6669" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">顾名思义，RGB颜色分类器是一个基于三个输入预测不同颜色类别的应用程序- R:红色，G:绿色，B:蓝色；每个值基本上是一个从0到255的整数，这些组合的红色、绿色和蓝色值用于为计算机、手机或任何电子屏幕上的每个像素生成独特的纯色。因此，我们的分类器预测这种纯色的颜色类别。</p><h1 id="0d99" class="km kn hi bd jo ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">资料组</h1><p id="0f96" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">获取数据集是我们必须解决的第一个问题。我找不到任何与我的项目完全匹配的相关数据集。所以，我决定创建一个符合我喜好的数据集。此外，我希望数据集是人工制作的，因为这样我们就能够让人工模型(分类器)尽可能人性化地对颜色进行分类。接下来，我们必须决定我们的分类器必须分类的颜色类别的数量。我找到一篇<a class="ae ix" href="https://europepmc.org/backend/ptpmcrender.fcgi?accid=PMC1618485&amp;blobtype=pdf" rel="noopener ugc nofollow" target="_blank">研究论文</a>提到了11种基本的颜色分类。这些基本颜色是红色、绿色、蓝色、黄色、橙色、粉色、紫色、棕色、灰色、黑色和白色。因此，我使用同样的11个颜色类别作为我们的分类器。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es li"><img src="../Images/3de9100a2d2e2435398b678c781a25a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*5mbRG6GY0IwrGEOsEMxWQg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">刘易斯·格里芬的照片显示了11种基本颜色的心理结构。</figcaption></figure><h1 id="5e08" class="km kn hi bd jo ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">数据集创建</h1><p id="530c" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">这可能是我做过的项目中最乏味的部分😅。可能有更有效的方法来创建数据集，我会带你走一遍我的路:这里是数据集创建者的<a class="ae ix" href="https://colab.research.google.com/github/AjinkyaChavan9/RGB-Color-Classifier-with-Deep-Learning-using-Keras-and-Tensorflow/blob/master/Dataset%20Creator/Color_Dataset_Creator.ipynb" rel="noopener ugc nofollow" target="_blank">谷歌实验室链接</a>。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0291" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">上面代码中的注释解释了重要的步骤。简而言之，<strong class="jr hj"> colorDataCreator() </strong>函数用于标记随机生成的RGB颜色，当该函数要求输入随机RGB颜色的标签时，如果用户输入<em class="kl"> done </em>，它会生成标记的数据集—‘T6】data . CSV文件。下面是如何使用<em class="kl"> colorDataCreator() </em>函数的演示:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ll"><img src="../Images/c9c077114893893d00357866e0d18111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*WebuHWqipPOHZBav4prcOg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo"> colorDataCreator()演示输出</strong>(图片由作者提供)</figcaption></figure><p id="ebf2" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">不过，Colab有一个警告，即由于任何网络问题或超过笔记本电脑的空闲时间而导致的断开连接问题。为了解决这个问题，我创建了另一个代码块，它使用了相同的<strong class="jr hj"> colorDataCreator() </strong>函数。您所要做的就是将最后保存的“<em class="kl"> data.csv </em>”文件上传到Colab并运行以下代码:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="c2ad" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">因此，我使用colorDataCreator()为我们的数据集标记了大约5000种RGB颜色。是的，这是我之前提到的乏味的部分😅<br/>现在，通过将用作颜色名称标签的首字母缩略词扩展到数据集，然后下载最终数据集，即“<a class="ae ix" href="https://github.com/AjinkyaChavan9/RGB-Color-Classifier-with-Deep-Learning-using-Keras-and-Tensorflow/blob/master/Dataset/final_data.csv" rel="noopener ugc nofollow" target="_blank"><em class="kl">final _ data . CSV</em></a>”文件。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="6214" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">瞧啊。我们最终的数据集准备好了。让我们从有趣的部分开始，即建立和训练我们的神经网络模型。如果你着急的话，这里有同样的<a class="ae ix" href="https://colab.research.google.com/github/AjinkyaChavan9/RGB-Color-Classifier-with-Deep-Learning-using-Keras-and-Tensorflow/blob/master/RGB%20Color%20Classifier%20ML%20Model/Color_Classifier_ML_Model_Tuned.ipynb" rel="noopener ugc nofollow" target="_blank"> Google Colab链接</a>！</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="4140" class="km kn hi bd jo ko lt kq kr ks lu ku kv io lv ip kx ir lw is kz iu lx iv lb lc bi translated">模型的预处理数据集</h1><p id="1b33" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">让我们查看数据集“final_data.csv”文件，如下所示:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ly"><img src="../Images/408c087bb27c68c3beb66e572ee90795.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*Mf-SXd7cln7MDYD9o8NnlA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">查看数据集“final _ data . CSV”</strong>(图片由作者提供)</figcaption></figure><p id="4bfd" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">正如我们所看到的，我们的数据集包含3个RGB(红、绿、蓝)输入以及相应RGB颜色所属的颜色类的标签输出。现在，对于任何要工作的最大似然模型，我们都希望有数字数据，因为在任何最大似然算法的核心，大量的数学涉及线性代数、微积分、统计、概率等。被使用。<br/>这里，我们已经有了数字格式的3个RGB输入。因此，我们已经完成了将任何数据转换成相应数值的一半工作。我们所要做的只是将文本的<em class="kl">标签</em>列数据转换成它的数字等价物。</p><h2 id="31d3" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">将“标签”列的分类数据转换为数字数据</h2><p id="d766" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">因此，我们的<em class="kl">标签</em>列在技术上被称为<em class="kl">分类</em>列，因为它包含11个颜色类别/类，我们希望在其中对RGB颜色进行分类。原来有一种很棒的技术叫做<em class="kl">分类编码</em>，用于将类别转换成数字。两种广泛使用的分类编码方法是<em class="kl">一键编码</em>和<em class="kl">标签编码</em>。</p><ul class=""><li id="b40a" class="mn mo hi jr b js jt jv jw jy mp kc mq kg mr kk ms mt mu mv bi translated"><strong class="jr hj"> <em class="kl">一键编码</em> </strong>为“n”个类别创建“n”个不同的列，如果数据点属于第<em class="kl"> i </em>个类别，则第<em class="kl"> i </em>列被赋予值<em class="kl">1，该行的所有其他列值被赋予值<em class="kl">0</em>。通过这种方式，人们可以以数字上有意义的方式跟踪类别。如果您不能完全理解这一点，请不要担心，当我们在本博客的后面部分实现它时，这个概念会更加清晰。</em></li><li id="3aba" class="mn mo hi jr b js mw jv mx jy my kc mz kg na kk ms mt mu mv bi translated">在<strong class="jr hj"> <em class="kl">标签编码</em> </strong>中，每个标签类别根据某种排序被赋予一个唯一的整数。这里，没有创建新的列，只是使用数字来表示同一“标签”列中的相应类别。</li></ul><p id="4abf" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">基于DL实践者的指导方针，当类别是序数<em class="kl">时，使用<em class="kl">标签编码</em>，这意味着类别之间具有某种相对重要性顺序。此外，当我们有大量的类别，并且使用一键编码在计算上变得昂贵，因为它创建了大量的列时，就使用它。</em></p><p id="3cf1" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在我们的例子中，我们没有那么多的颜色类别，而且每个颜色类别都同样重要，它们之间没有相对的顺序。因此，我们将使用<em class="kl">一键编码</em>将我们的11个颜色类别转换成数字形式。下面是实现:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nb"><img src="../Images/5cd9a643bc3aa753b86437be80433233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLJzDNJmj9lpKT1M7LP7cA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">数据集中目标标签的一键编码</strong>(图片由作者提供)</figcaption></figure><p id="eff7" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">正如我们在这里看到的，One-Hot编码为我们的11个类别创建了11个列。注意，第一种颜色被标记为蓝色，因为在<em class="kl"> label_Blue </em>列中有值1，第二种颜色被标记为棕色，因为相应的<em class="kl"> label_Brown </em>列有条目1。这样，我们就把分类数据转换成了数字数据。</p><h2 id="8acb" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">将数据分为训练集和测试集</h2><p id="6718" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated"><em class="kl"> train-test split </em>程序用于评估机器学习算法的性能，当它们用于对未用于训练模型的数据进行预测时。</p><ul class=""><li id="eaf7" class="mn mo hi jr b js jt jv jw jy mp kc mq kg mr kk ms mt mu mv bi translated"><strong class="jr hj"> <em class="kl">训练数据集</em> </strong>:用于训练机器学习模型。</li><li id="344d" class="mn mo hi jr b js mw jv mx jy my kc mz kg na kk ms mt mu mv bi translated"><strong class="jr hj"> <em class="kl">测试数据集</em> </strong>:用于评估经过训练的机器学习模型，即它给出了模型性能的无偏估计，因为这些数据没有用于训练模型。</li></ul><p id="c437" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们将数据集的80%分割为训练集，剩下的20%作为测试集。注意，这里我们用pandas DataFrame方法<em class="kl"> sample()随机分割数据集。</em></p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nc"><img src="../Images/3043d222b05c863f6729776ac1d6537f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xT4sIhqRsfss5f33sAobcw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">train _ test _ split:train _ dataset的输出</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nd"><img src="../Images/fc4a0ff285e076c31c41110d6e8925cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAmJuKhrjgCsZTyx-7W-kg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">train _ test _ split:test _ dataset的输出</strong>(图片由作者提供)</figcaption></figure><h2 id="9ffd" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">分割输入要素和输出标注</h2><p id="3253" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">输入特性，即<em class="kl">红色</em>、<em class="kl">绿色</em>、<em class="kl">蓝色</em>输入栏必须与输出<em class="kl">标签</em>栏分开。这是因为ML算法需要输入数据和目标/输出数据分别用于训练。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ne"><img src="../Images/8dfaed8361a82f626bab7fcaf426f230.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*ioZscPl6gfA2O1WN1_foGg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo"> train_dataset(输入要素)</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nf"><img src="../Images/43ac316725e9f21b19a412715aabeb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1icgyAE6RBODFLejWkIAng.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo"> train_labels(输出)</strong>(图片由作者提供)</figcaption></figure><p id="cdd0" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">类似地，我们为测试数据集拆分</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="023b" class="km kn hi bd jo ko lt kq kr ks lu ku kv io lv ip kx ir lw is kz iu lx iv lb lc bi translated">构建和编译模型</h1><p id="968b" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">正如副标题中提到的，我们将使用Keras和Tensorflow库构建一个人工神经网络(ANN)模型。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ng"><img src="../Images/e60ff4ab736a337ff0e22ed57e02e25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90AOFJyYoHhQkrjgbQhj6w.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">一个神经元的正向传播</strong></figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nh"><img src="../Images/971228985a7be4ae1f20e282bb89833b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*EK58UqRsibb_wOlwRIg9Gg.gif"/></div></figure><p id="627f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">简而言之，人工神经网络模型由一组顺序堆叠的层组成。每一层由一组神经元组成。第一层的每个神经元取<strong class="jr hj"> <em class="kl">输入特征</em> </strong>(在我们的例子中是红、绿、蓝值)， 然后<strong class="jr hj">将</strong>乘以它们各自初始化的<strong class="jr hj"> <em class="kl">权重</em> </strong>，然后计算它们的<strong class="jr hj"> <em class="kl">和</em> </strong>以及<strong class="jr hj"> <em class="kl">偏差</em> </strong>，并将该结果通过<strong class="jr hj"> <em class="kl">激活函数</em> </strong>，然后再次将其作为输入提供给下一层神经元，并且该过程在层中的每个神经元上继续，直到我们在最后一层获得输出。 这就是所谓的<em class="kl">正向传播</em>。</p><p id="6961" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了训练神经网络，从输出层返回到输入的<em class="kl">反向传播</em>被完成，其计算关于神经网络的<em class="kl">权重</em>和<em class="kl">偏差</em>的成本<em class="kl">函数</em>的<em class="kl">梯度</em>，并且这被用于更新<strong class="jr hj"> <em class="kl">参数</em> </strong>，即<strong class="jr hj"> <em class="kl">权重</em> </strong>和<strong class="jr hj"> <em class="kl">偏差</em> </strong>使输出值尽可能接近目标值。</p><p id="ce82" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">谢天谢地，我们不必实现这种复杂的数学运算，因为<strong class="jr hj"> <em class="kl"> TensorFlow </em> </strong>库会处理如何高效地实现这种数学运算！！我们将使用<a class="ae ix" href="https://www.tensorflow.org/api_docs/python/tf/keras" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> tf.keras </em> </a>，这是一个运行在TensorFlow之上的高级API，帮助我们通过简单的代码轻松使用Tensorflow。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="e394" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">设置各层并编译人工神经网络模型</h2><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ni"><img src="../Images/f5baff8685c689a0c3a51ed55f973e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*aLll3gf2MNr0RafOVx2lHQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">车型概要</strong>(图片由作者提供)</figcaption></figure><p id="ab58" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">正如你所看到的，我们的人工神经网络模型有5层。所有层的层类型是<em class="kl">密集</em>，这意味着一层中的每个神经元接收来自前一层的每个神经元的输入，因此它是一个<em class="kl">密集连接的神经网络</em>。换句话说，<em class="kl">密集</em>层是完全连接的，这意味着一层中的所有神经元都与下一层中的神经元相连。</p><ul class=""><li id="a4c1" class="mn mo hi jr b js jt jv jw jy mp kc mq kg mr kk ms mt mu mv bi translated">带有【T43个神经元的<em class="kl">第一层</em>有<em class="kl">12个参数</em>(<em class="kl">9个权重+3个偏差</em>)。<br/>这里我们有9个<em class="kl">权重</em>(3个输入特征×3个神经元【第一层】)&amp; 3个<em class="kl">偏差</em>(1个偏差×3个神经元)</li><li id="2dae" class="mn mo hi jr b js mw jv mx jy my kc mz kg na kk ms mt mu mv bi translated">具有<em class="kl">24个神经元</em>的<em class="kl">第二</em>T55】层有96个<em class="kl">参数</em>(<em class="kl">72个权重+24个偏差</em>)。<br/>即72个<em class="kl">权重</em>(3个输入压力层×24个神经元【2个层】)&amp; 24个<em class="kl">偏差</em>(1个偏差×24个神经元)等等……</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nj"><img src="../Images/d8daa0a937ea3d98ecdc6356ff67cb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*JrGdwOTBZh5GekkprXZHbg.png"/></div></figure><p id="f891" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">请注意，我使用了<strong class="jr hj"> ReLU </strong>(校正线性单位)作为我们NN模型中所有层的激活函数。<strong class="jr hj"> <em class="kl">激活函数</em> </strong> <em class="kl"> </em>用于添加非线性，以便帮助神经网络学习数据中的复杂模式。</p><p id="929c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">此外，我已经使用了<em class="kl">正则化。l2 </em>执行<strong class="jr hj"> L2正则化</strong>。应用正则化来减少<strong class="jr hj"> <em class="kl">过拟合</em> </strong> <em class="kl">。过度拟合</em>意味着我们的模型在训练集上做得太好，即它学习训练集中的微小细节和噪声，以至于它无法概括预测新数据所需的趋势，这将对性能产生负面影响。</p><p id="e87f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><a class="ae ix" href="https://www.tensorflow.org/api_docs/python/tf/keras/losses/CategoricalCrossentropy" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hj"> <em class="kl">分类交叉熵损失</em> </strong> </a>函数用于计算实际和预测分类标签之间的损失。还因为我们的分类标签是如前面的<a class="ae ix" href="#31d3" rel="noopener ugc nofollow">所解释的</a>的独热格式。</p><p id="86f8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我已经选择了<a class="ae ix" href="https://arxiv.org/pdf/1412.6980.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hj"> <em class="kl">亚当</em> </strong> <em class="kl">(自适应矩估计)</em> <strong class="jr hj"> <em class="kl"> </em> </strong>算法</a>作为我们的优化器/优化算法，其更新参数，即<em class="kl">权重</em>和<em class="kl">偏差</em>，使得<em class="kl">加速</em>达到<em class="kl">成本函数</em>(平均值)的<em class="kl">最小值</em></p><p id="3543" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj"> <em class="kl">学习率</em> </strong>是优化算法中的一个超参数，它确定每次迭代的步长，同时向<em class="kl">成本函数的最小值移动。</em>我们模型的<em class="kl">学习率</em>为0.001</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nk"><img src="../Images/98a0975b88fcf01d6a7840ec4a8be046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*An4tZEyQAYgPAZl396JzWg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">选择一个学习速率(</strong> <a class="ae ix" href="https://www.jeremyjordan.me/nn-learning-rate/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jo">图像信用</strong> </a> <strong class="bd jo"> ) </strong></figcaption></figure><h1 id="b62d" class="km kn hi bd jo ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">训练模型</h1><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ea62" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在上面的代码中，我们将输入数据给了<strong class="jr hj"> <em class="kl"> x </em> </strong>，将目标数据即输出标签给了<strong class="jr hj"> <em class="kl"> y </em> </strong> <em class="kl">。</em> <strong class="jr hj"> <em class="kl">历元</em> </strong> <em class="kl"> </em>表示模型迭代整个<em class="kl"> x </em>和<em class="kl"> y </em>数据进行训练的次数。<strong class="jr hj"> <em class="kl">批量</em> </strong>是训练时<em class="kl">参数</em>更新后的样本数。<em class="kl"> Verbose </em>用于显示训练进度。我们将它设置为0，因为我们不使用tf.keras.Sequential.fit()方法来显示训练进度，而是使用callbacks =[<a class="ae ix" href="https://github.com/tensorflow/docs/blob/master/tools/tensorflow_docs/modeling/__init__.py" rel="noopener ugc nofollow" target="_blank">TF docs . modeling . epochdots()</a>]来显示训练进度，这是每100个时期显示训练进度的一种更简洁的方式。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nl"><img src="../Images/c5f997cd9f5fdf790bd7cdcb34d16960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*0AkZHavTL08_WzOQPbY52g.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">过度拟合，因为验证损失增加，而训练损失减少</strong> ( <a class="ae ix" href="https://www.slideshare.net/xavigiro/training-deep-networks-d1l6-deep-learning-for-speech-and-language" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="52b5" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">还有一个<em class="kl">关键点</em>需要注意的是<strong class="jr hj"><em class="kl">validation _ split = 0.2</em></strong>的使用，这意味着20%的训练数据集被用作<em class="kl">验证集</em>。<strong class="jr hj"> A <em class="kl">验证集</em>是<em class="kl">从训练你的模型</em>中保留的训练集的样本，这意味着它不用于训练<em class="kl"> g </em> </strong> <em class="kl">。</em>而是用于在训练自身时给出模型性能<em class="kl">的<em class="kl">无偏估计</em>。这仅仅意味着我们正在用<em class="kl">验证集</em>检查我们模型的<em class="kl">损失</em>和<em class="kl">精度</em>。简而言之，我们在训练的同时验证我们的模型性能，因此命名为“验证集”。这对于预测我们的模型对训练集是过拟合还是欠拟合非常重要。通过这样做，我们可以调整我们模型的<em class="kl">超参数，</em>不会与模型<em class="kl">参数</em>混淆</em></p><p id="f189" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">模型<em class="kl">参数</em>是ML模型在训练期间学习的训练数据的属性。在我们的例子中，<em class="kl">权重</em>和<em class="kl">偏差</em>是学习到的参数，将被模型用于预测。所有其他的都是<em class="kl">超参数</em>，如学习速率、神经元数量、隐藏层数、批量大小等。简而言之，超参数用于控制参数，而不是相反。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nm"><img src="../Images/a148ac82a975841da2dcb426ab6b7c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6pakN4K5v5urCe0UY4xtw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">训练输出</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nn"><img src="../Images/0b72fd8ea63889dd529ce319e646ee15.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*lSxePwCFJB2pKBFZaycRFA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">模型精度图</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nn"><img src="../Images/93869e208e796045911bb90ed9a7cd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*YB19O_g9UjCC8bdaWk6arg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">模型损耗图</strong>(图片由作者提供)</figcaption></figure><p id="0f94" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">从模型精度图中，我们可以看到我们的模型运行良好，训练精度约为90%，验证精度约为87%。从模型损失图中，我们可以观察到我们的训练和验证损失都在减少，这意味着我们没有过度拟合我们的训练集。</p><h1 id="6656" class="km kn hi bd jo ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">根据训练好的模型对测试数据集进行预测</h1><p id="0f57" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">我们的ANN模型的预测为每个测试示例返回11个浮点数的Numpy数组。它们代表输入RGB颜色对应的11个不同颜色类别的模型的<em class="kl">置信度</em>。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es no"><img src="../Images/0eda955d927dbd729caad75a59c19d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*hkNrvfCXDe_Lpo-ny_uRWw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">测试预测的输出</strong>(图片由作者提供)</figcaption></figure><p id="4c91" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">'<em class="kl">test _ predictions '</em>NumPy数组的形状是(1010，11)，这意味着我们已经为所有1010个测试示例预测了11个置信浮点数。<br/>让我们观察第一个输入的预测:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es np"><img src="../Images/49e0c47901541a417c8a24359c6320e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*DiCZ6XsQG350XiStBq83hg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">(图片由作者提供)</figcaption></figure><p id="fb83" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们可以看到11个浮点值，代表11个类别中每个类别的置信度。浮动值越大，表示可信度越高。因此，<em class="kl">最高置信度值代表由我们的模型</em>预测的类别。出于模型评估的目的，我们将使用sk learn . metrics . confusion _ matrix，它要求实际类和预测类采用标签编码格式。因此，我们将通过标签编码对它们进行编码:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nq"><img src="../Images/c3b22a4d8a55ea752183a4dfe099b143.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*iXA0n1zWJyL6ssxHeaBPDg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">颜色分类标签的标签编码</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nr"><img src="../Images/e67dfcd76bf5bcfd24a0676cb70cae8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*JgJGupKrLlvSBfezXb3U5Q.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">预测标签(测试集)</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ns"><img src="../Images/df839ad9ee90f92b01f52723f5b31c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*krnOeo_Ewvxts6-VAc-1pQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">实际标签(测试集)</strong>(图片由作者提供)</figcaption></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="607f" class="km kn hi bd jo ko lt kq kr ks lu ku kv io lv ip kx ir lw is kz iu lx iv lb lc bi translated">评估模型性能</h1><p id="c2a9" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">模型评估是模型开发过程不可或缺的一部分。它帮助我们找到代表我们的数据的最佳模型，以及所选模型在未来的工作情况。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nt"><img src="../Images/e049a785748b5a398f0e695c0dc96c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiRa8-8KFc3UnEJXh0soeQ.png"/></div></div></figure><p id="b85f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">所以，我们的<em class="kl">测试集准确率为89% </em></p><h2 id="b13f" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">混淆矩阵</h2><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nu"><img src="../Images/6dbbc20f51b454dce05e909f5668af0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcxLNWvYi0cZRSi4AQzwYw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">混淆矩阵可视化</strong>(图片由作者提供)</figcaption></figure><p id="8f27" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj"> <em class="kl">混淆矩阵</em> </strong>是用于评价分类模型(分类器)性能的矩阵。<em class="kl">行</em>代表<em class="kl">实际</em>标签，而<em class="kl">列</em>代表我们的<a class="ae ix" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" rel="noopener ugc nofollow" target="_blank">滑雪套件学习混淆矩阵</a>的<em class="kl">预测</em>标签。例如:在我们的例子中，第一个值42表示有42种<em class="kl">实际上是</em>红色，它们被我们的模型<em class="kl">预测为</em>红色。现在，看第6行的第一个值(粉色):值是6，这意味着6个<em class="kl">实际上</em>粉色被<em class="kl">预测</em>为红色(列)。</p><p id="1cf8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">请注意，所有<strong class="jr hj"> <em class="kl">对角线元素</em> </strong> <em class="kl"> </em>都具有<em class="kl">相同的</em>实际和预测标签，这意味着这些颜色被我们的模型正确分类为<strong class="jr hj"><em class="kl"/></strong>，因为预测标签等于实际标签。因此，所有的<strong class="jr hj"> <em class="kl">非对角线元素</em> </strong>都表示被我们的分类器误标的<strong class="jr hj"><em class="kl"/></strong>颜色。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nv"><img src="../Images/60abfc0285b0022dc3f29356ff309f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*zbx_-xs2xBs9D_ntCez-iw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">测试数据集</strong>的精度计算(图片由作者提供)</figcaption></figure><h2 id="d317" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">分类报告</h2><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nw"><img src="../Images/06cd2757deb36e330aa76d85f9bd5cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*MxW-9zQlJmkE4YqbmyymIA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">分类报告</strong>(图片由作者提供)</figcaption></figure><p id="5159" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">除了<strong class="jr hj">精确度<em class="kl">精确度</em>精确度</strong>之外，还有其他重要指标也与混淆矩阵相关联:</p><ul class=""><li id="39b0" class="mn mo hi jr b js jt jv jw jy mp kc mq kg mr kk ms mt mu mv bi translated"><strong class="jr hj"> <em class="kl">精度</em> </strong>:表示分类器将<strong class="jr hj"><em class="kl"/></strong><em class="kl">正确分类</em>的<em class="kl">分数的多少。</em></li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nx"><img src="../Images/fadd46536e22a89317743569184bcae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*rEeYRTKEOZzrXvUGiUjM3g.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">精度公式</strong>(图片作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ny"><img src="../Images/9aef3057933779b2485ba07e84914caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*UuNoYZrRb05wLKihTVJTOg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">红色等级的精度计算示例</strong>(图片由作者提供)</figcaption></figure><ul class=""><li id="c4d1" class="mn mo hi jr b js jt jv jw jy mp kc mq kg mr kk ms mt mu mv bi translated"><strong class="jr hj"> <em class="kl">回忆</em> </strong>:表示分类器将<strong class="jr hj"><em class="kl"/></strong>中的<em class="kl">分数</em>正确分类<em class="kl">。</em></li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nz"><img src="../Images/b1553e0f1a6056b07209582574788f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*gs4Da1pIIrcKxXdAW-knZg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">回忆公式</strong>(图片作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es oa"><img src="../Images/053b7253e5bfb4dd08797bc3d8a03c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*AHrt0l1p6hMsqncXiI6MZw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">回忆红色等级</strong>的计算示例(图片由作者提供)</figcaption></figure><p id="2cfd" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">然而，在<strong class="jr hj">精度</strong>和<strong class="jr hj">召回</strong>之间有一个<strong class="jr hj"> <em class="kl">权衡</em> </strong> <em class="kl"> </em>即提高精度通常会降低召回，反之亦然。因此，有一个叫做<em class="kl"> F1的指标——结合了精确度和召回率的分数</em>。</p><ul class=""><li id="d534" class="mn mo hi jr b js jt jv jw jy mp kc mq kg mr kk ms mt mu mv bi translated"><strong class="jr hj"><em class="kl">-得分</em> </strong>是<em class="kl">精度</em>和<em class="kl">召回</em>的<em class="kl">调和平均值</em>，因此它给出了关于这两个指标的组合概念。</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ob"><img src="../Images/76bedbf812c52d0e5d5b9ad19efe8a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*TiQiHb5kcB8qpMShWdwN4w.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">F1-得分公式</strong>(图片由作者提供)</figcaption></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es oc"><img src="../Images/317147dd23db9752293de547fa7e1e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EB7-OQ5H3T1NSTppR9TNXw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd jo">F1-红色等级分数计算示例</strong>(图片由作者提供)</figcaption></figure><p id="0a74" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们的数据集是<em class="kl">不平衡的</em>，也就是说，每个类的实例数量不一样(你可以从<a class="ae ix" href="#d317" rel="noopener ugc nofollow">分类报告</a>中的<em class="kl">支持</em>指标<em class="kl"> </em>中看到这一点)。因此，我使用f1分数作为评估标准来决定我们的模型在各个颜色类别上的表现。<br/>我还通过调整超参数训练了多个模型，并使用<em class="kl">加权平均f1得分</em>指标来决定哪个模型表现更好。</p><p id="e61c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">最后要做的一件事是保存我们训练好的模型，在部署它的时候会用到它(在第2部分中完成)。代码如下所示:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="2fb0" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在，您可以使用超参数和数据集来创建一个模型，其性能甚至可能超过模型的89%😁😀</p><p id="4356" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这就把我们带到了第1部分的结尾！我知道这个故事太长了，因为我想涵盖其中的大部分概念😅</p><div class="od oe ez fb of og"><a rel="noopener follow" target="_blank" href="/@ajinkyashailendrachavan/building-rgb-color-classifier-part-2-8c49a57f6b91"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hj fi z dy ol ea eb om ed ef hh bi translated">构建RGB颜色分类器:第2部分</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">使用Streamlit创建Web应用程序并使用Heroku进行部署</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ji og"/></div></div></a></div></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="8ba2" class="km kn hi bd jo ko lt kq kr ks lu ku kv io lv ip kx ir lw is kz iu lx iv lb lc bi translated">感谢您的阅读。希望你喜欢这个故事！</h1><p id="91f2" class="pw-post-body-paragraph jp jq hi jr b js ld ij ju jv le im jx jy lf ka kb kc lg ke kf kg lh ki kj kk hb bi translated">我对写博客有点陌生。如果您发现任何错误或有任何建议，欢迎您这样做😃</p><p id="1095" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在那之前保持微笑，快乐学习😊</p><h2 id="f875" class="lz kn hi bd jo ma mb mc kr md me mf kv jy mg mh kx kc mi mj kz kg mk ml lb mm bi translated">阿金基亚·查万</h2></div></div>    
</body>
</html>