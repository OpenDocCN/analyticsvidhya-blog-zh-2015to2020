<html>
<head>
<title>Advanced-Data Wrangling In R — 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R-4中的高级数据争论</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/advanced-data-wrangling-in-r-4-f98693b92851?source=collection_archive---------4-----------------------#2019-10-29">https://medium.com/analytics-vidhya/advanced-data-wrangling-in-r-4-f98693b92851?source=collection_archive---------4-----------------------#2019-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2168" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如果您还没有阅读R数据分析系列的第3部分，请阅读下面的文章，其中我们讨论了R-3</em><em class="jd">中的</em> <a class="ae je" rel="noopener" href="/@viveksrinivasan/group-manipulation-in-r-3-5554a0c1b544"> <em class="jd">组操作。</em></a></p><p id="9690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章的内容是我在IIM-B时代得到的几本书的要点。</p><p id="64ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">人人为我——贾里德·p·兰德</em></p><p id="65a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">实用数据科学与R —妮娜·祖梅尔&amp;约翰·芒特</em></p><p id="f69d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">文中讨论的所有代码块都以R markdown的形式出现在</em> <a class="ae je" href="https://github.com/viveksrinivasanss/Data_Science_Using_R" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Github链接</em> </a> <em class="jd">中。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/ccf1293e9a44ffbca6dfe4aca5d16a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*dFnQPExeA_VFusNK6Z9fdw.png"/></div></figure><p id="4358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jn translated">如果你是一个速度迷；比起代码的可读性，你更喜欢速度，并且每天都要处理非常大的数据集，那么你就在正确的地方学习正确的工具。在<code class="du jw jx jy jz b">R</code>中有一个名为<code class="du jw jx jy jz b">data.table</code>的包，它扩展了<code class="du jw jx jy jz b">data.frames</code>的功能。语法与常规的<code class="du jw jx jy jz b">data.frames</code>有些不同，所以需要时间来适应，这可能是它没有被广泛采用的主要原因。</p><p id="28aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且<code class="du jw jx jy jz b">data.table</code>并不是唯一有助于数据框操作的软件包。还有一个<code class="du jw jx jy jz b">Hadley Wickham</code>的优秀包叫<code class="du jw jx jy jz b">dplyr</code>。它有自己的数据操作语法，提供一组一致的动词，帮助您解决最常见的数据操作。</p><ul class=""><li id="b93c" class="ka kb hi ih b ii ij im in iq kc iu kd iy ke jc kf kg kh ki bi translated"><code class="du jw jx jy jz b">filter()</code>根据值选择案例。</li><li id="de49" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jw jx jy jz b">arrange()</code>对案例进行重新排序。</li><li id="7276" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jw jx jy jz b">select()</code>和<code class="du jw jx jy jz b">rename()</code>根据名称选择变量。</li><li id="d4ce" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jw jx jy jz b">mutate()</code>和<code class="du jw jx jy jz b">transmute()</code>添加新变量，这些变量是现有变量的函数。</li><li id="5ae4" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jw jx jy jz b">summarise()</code>将多个值浓缩为一个值。</li><li id="7561" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jw jx jy jz b">sample_n()</code>和<code class="du jw jx jy jz b">sample_frac()</code>随机抽取样本。</li></ul><p id="d0fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个包在可用性、可读性和速度方面一直存在争议。一个<a class="ae je" href="https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly" rel="noopener ugc nofollow" target="_blank"><em class="jd">stack overflow</em></a>的讨论值得一读，以便更多地了解一个包能做什么，另一个不能做什么。一般来说，如果你在寻找速度，那么<code class="du jw jx jy jz b">data.tables </code>是最优选的，但是代码的可读性是你最关心的，那么<code class="du jw jx jy jz b">dplyr </code>是通向速度的途径</p><p id="90d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将重点放在<code class="du jw jx jy jz b">data.table</code>上，速度的秘密在于<code class="du jw jx jy jz b">data.table</code>有一个类似数据库的索引。这允许更快的访问、分组操作和连接。</p><p id="3081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创造<code class="du jw jx jy jz b">data.table</code>就像创造<code class="du jw jx jy jz b">data.frames</code>，两者非常相似。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="ffc4" class="ks kt hi jz b fi ku kv l kw kx">require(data.table)<br/>## Create a regular data.frame<br/>theDf &lt;- data.frame(A=1:10,B=letters[1:10],C=LETTERS[1:10],D=rep(c("One","Two","Three"),length.out=10))</span><span id="0470" class="ks kt hi jz b fi ky kv l kw kx">## Create a data.table<br/>theDt = data.table(A=1:10,B=letters[1:10],C=LETTERS[1:10],D=rep(c("One","Two","Three"),length.out=10))</span><span id="a6e9" class="ks kt hi jz b fi ky kv l kw kx">## Print and compare<br/>theDt</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/b7e26b189a4587bbb28babd48cf2db71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87j--Qu_N8tF_X6srdoeQQ.png"/></div></div></figure><p id="309b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面可以注意到，默认情况下<code class="du jw jx jy jz b">data.frame</code>将<code class="du jw jx jy jz b">character</code>数据转化为<code class="du jw jx jy jz b">factors </code>，而<code class="du jw jx jy jz b">data.table</code>没有。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="aa3a" class="ks kt hi jz b fi ku kv l kw kx">class(theDf$B)</span><span id="8842" class="ks kt hi jz b fi ky kv l kw kx">class(theDt$B)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/e3e96aa0314d3c18e68605d06c20f8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRLq8BQti57IDcbU6nFdSg.png"/></div></div></figure><p id="a7cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<code class="du jw jx jy jz b">data.frame</code>把<code class="du jw jx jy jz b">B</code>变成了<code class="du jw jx jy jz b">factor </code>而<code class="du jw jx jy jz b">data.table</code>没有之外，数据是相同的。</p><p id="8fd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以从现有的<code class="du jw jx jy jz b">data.frame</code>中创建一个<code class="du jw jx jy jz b">data.table</code>，如下所示。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="f438" class="ks kt hi jz b fi ku kv l kw kx">require(ggplot2)<br/>diamondsDT &lt;- data.table(diamonds)<br/>diamondsDT</span></pre><p id="d84d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看如何使用<code class="du jw jx jy jz b">data.table</code>执行一些常见和高级的数据操作。</p><h2 id="64c0" class="ks kt hi bd lf lg lh li lj lk ll lm ln iq lo lp lq iu lr ls lt iy lu lv lw lx bi translated">访问行</h2><p id="b973" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">访问行可以类似于访问<code class="du jw jx jy jz b">data.frame</code>中的行来完成。以下代码将数据子集化到前两行。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="a0e9" class="ks kt hi jz b fi ku kv l kw kx">theDt[1:2,]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es md"><img src="../Images/011eb93f63751f4594fa6198c48ef155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZzVqwCd2C2zWCUCJ07eBMA.png"/></div></div></figure><p id="3e24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了根据某种条件过滤行，我们可以使用下面的一行程序。尽管一行程序是有效的语法，但它不一定是有效的语法。该行创建一个由<code class="du jw jx jy jz b">True </code>或<code class="du jw jx jy jz b">False </code>条目组成的长度为<code class="du jw jx jy jz b">nrow=10</code>的向量，这是一个向量扫描。在我们为<code class="du jw jx jy jz b">data.tables</code>创建一个键之后，我们可以使用不同的语法通过二分搜索法来挑选行，这样会快得多，这将在下一节中介绍。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="86af" class="ks kt hi jz b fi ku kv l kw kx">theDt[theDt$A &gt;=7,]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es me"><img src="../Images/08fa2a3d685f08f8193c0143d28ea93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOgVS95IBDJNhzIimWXtEA.png"/></div></div></figure><h2 id="5109" class="ks kt hi bd lf lg lh li lj lk ll lm ln iq lo lp lq iu lr ls lt iy lu lv lw lx bi translated">访问列</h2><p id="88b3" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">访问单个列的方式必须与访问<code class="du jw jx jy jz b">data.frames</code>中的列稍有不同。在<code class="du jw jx jy jz b">data.frames</code> to子集中，多个列名应该被指定为<code class="du jw jx jy jz b">character </code>向量。用<code class="du jw jx jy jz b">data.tables</code>应该将列指定为实际名称的列表，而不是字符。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="6c39" class="ks kt hi jz b fi ku kv l kw kx">theDt[,list(A,C)]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/07be7400eaacaccf023cf5da699900e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LtR8exJzhptzeT7ougw_A.png"/></div></div></figure><p id="2f34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们必须将列名指定为<code class="du jw jx jy jz b">characters</code>(可能因为它们是作为参数传递给函数的)，那么<code class="du jw jx jy jz b">with </code>参数应该设置为<code class="du jw jx jy jz b">FALSE</code>。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="e79c" class="ks kt hi jz b fi ku kv l kw kx">theDt[,c("A","C"),with=FALSE]</span></pre><p id="4186" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我们使用了一个<code class="du jw jx jy jz b">vector</code>来保存列名，而不是一个<code class="du jw jx jy jz b">list</code>。这些细微差别对<code class="du jw jx jy jz b">data.table</code>的正常功能很重要，但会导致大量的挫折。</p><h2 id="5a42" class="ks kt hi bd lf lg lh li lj lk ll lm ln iq lo lp lq iu lr ls lt iy lu lv lw lx bi translated">键</h2><p id="bebd" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">既然我们在内存中有一些<code class="du jw jx jy jz b">data.tables</code>，我们可能有兴趣看看关于它们的一些信息。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="d27a" class="ks kt hi jz b fi ku kv l kw kx">## show tables<br/>tables()</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mg"><img src="../Images/d98a06ebe22fbe78ee67beb3130d5bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2KW-Mk8DpemF9pM8hfXiA.png"/></div></div></figure><p id="34a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这显示了内存中每个<code class="du jw jx jy jz b">data.table</code>的名称、行数、兆字节大小、列名和键。我们没有为任何表分配<code class="du jw jx jy jz b">keys </code>,因此到目前为止该列为空。该键用于索引<code class="du jw jx jy jz b">data.table</code>并将提供额外的速度。</p><p id="b559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从给<code class="du jw jx jy jz b">theDt</code>添加密钥开始。我们将使用<code class="du jw jx jy jz b">D</code>列来索引<code class="du jw jx jy jz b">data.table</code>。这是使用<code class="du jw jx jy jz b">set.key</code>完成的，它将<code class="du jw jx jy jz b">data.table</code>的名称作为第一个参数，将所需列的名称(没有引号，与列部分一致)作为第二个参数。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="01a3" class="ks kt hi jz b fi ku kv l kw kx">## set the key<br/>setkey(theDt, D)</span><span id="850e" class="ks kt hi jz b fi ky kv l kw kx">## show the data.table again<br/>theDt</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mh"><img src="../Images/a9a0edee3856dd915c4764ba9f67f961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZjZ8hgY0jP3fFHSOo27MA.png"/></div></div></figure><p id="219c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据已根据按字母顺序排序的列<code class="du jw jx jy jz b">D</code>重新排序。我们可以确认该键是用<code class="du jw jx jy jz b">key </code>功能设定的。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="0560" class="ks kt hi jz b fi ku kv l kw kx">key(theDt)</span></pre><p id="da7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这为从<code class="du jw jx jy jz b">data.tables</code>中选择行添加了一些新功能。除了通过行号或计算结果为<code class="du jw jx jy jz b">TRUE </code>或<code class="du jw jx jy jz b">FALSE</code>的表达式选择行之外，还可以指定键列的值。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="a111" class="ks kt hi jz b fi ku kv l kw kx">theDt[c("One","Two"),]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mi"><img src="../Images/ed48c3799f634b94e1ac943bf8fd3875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dv-JlUUmdkkDmzHGnXJ8lg.png"/></div></div></figure><p id="0f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以将多列设置为<code class="du jw jx jy jz b">data.tables</code>中的<code class="du jw jx jy jz b">key </code>，如下所示。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="3e17" class="ks kt hi jz b fi ku kv l kw kx">setkey(diamondsDT,cut,color)</span></pre><p id="5a0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要按两个键访问行，有一个特殊功能<code class="du jw jx jy jz b">J</code>。它需要多个参数，每个参数都是要选择的值的<code class="du jw jx jy jz b">vector </code>。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="52b6" class="ks kt hi jz b fi ku kv l kw kx">diamondsDT[J("Ideal"),c("E","D")),]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es md"><img src="../Images/6cbe1308a35b80681373ba8c2bfef929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsXkR62X598ZTcqBO2FflQ.png"/></div></div></figure><h2 id="51f4" class="ks kt hi bd lf lg lh li lj lk ll lm ln iq lo lp lq iu lr ls lt iy lu lv lw lx bi translated">聚合</h2><p id="aaf3" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">索引的主要好处是聚合速度更快。虽然<code class="du jw jx jy jz b">aggregate </code>和各种d*ply功能可以工作，因为<code class="du jw jx jy jz b">data.table</code>只是增强了<code class="du jw jx jy jz b">data.frames</code>，但它们会比使用<code class="du jw jx jy jz b">data.tables</code>的内置<code class="du jw jx jy jz b">aggregate </code>功能慢。让我们快速比较一下内置和外部<code class="du jw jx jy jz b">aggregate </code>功能之间的语法差异。</p><p id="ff37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算每种切割类型的钻石平均价格，让我们使用我们在上一篇文章中使用的<code class="du jw jx jy jz b">aggregate</code>函数。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="81e4" class="ks kt hi jz b fi ku kv l kw kx">aggregate(price~cut,diamonds,mean)</span></pre><p id="5562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用<code class="du jw jx jy jz b">data.table</code>聚合功能获得相同的结果，我们使用下面的代码。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="0ff1" class="ks kt hi jz b fi ku kv l kw kx">diamondsDT[,mean(price),by=cut]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mj"><img src="../Images/556950f440cc168ec48f18e955662e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ba8QPrlMsbTpVEOjX4bobw.png"/></div></div></figure><p id="a27e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个结果之间的唯一区别是列的名称不同。在<code class="du jw jx jy jz b">data.tables</code>中，默认名称<code class="du jw jx jy jz b">V1</code>被分配给聚合列。要指定结果列的名称，请将聚合函数作为命名的<code class="du jw jx jy jz b">list</code>进行传递。要在多个列上聚合，请将它们指定为<code class="du jw jx jy jz b">list()</code>。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="db26" class="ks kt hi jz b fi ku kv l kw kx">diamondsDT[,list(price=mean(price)),by=cut]</span><span id="5846" class="ks kt hi jz b fi ky kv l kw kx">## Aggreagate on  multiple columns<br/>diamondsDT[,list(price=mean(price)),by=list(cut,color)]</span></pre><p id="f02b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了聚合多个参数，将它们作为<code class="du jw jx jy jz b">list</code>传递。与聚合函数不同，可以为每一列测量不同的指标。</p><pre class="jg jh ji jj fd ko jz kp kq aw kr bi"><span id="e65a" class="ks kt hi jz b fi ku kv l kw kx">diamondsDT[,list(price=mean(price), carat=mean(carat), caratSum=sum(carat)),by=list(cut,color)]</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mk"><img src="../Images/f4763cdedf8118d6621fb6b32e258484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lV04RqrbCUfjyy7j0E4XA.png"/></div></div></figure><p id="a2b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据争论是任何分析管道中非常重要的一步。有时它是最终目标，有时它是为应用更先进的方法做准备。不管是什么原因，有大量的功能使其成为可能。其中包括R中的<code class="du jw jx jy jz b">aggregate</code>、<code class="du jw jx jy jz b">apply </code>系列和<code class="du jw jx jy jz b">data.table</code>中的按功能分组。</p><p id="0aea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">使用R-5-的统计简介即将出版</em></p><blockquote class="ml mm mn"><p id="ecf3" class="if ig jd ih b ii ij ik il im in io ip mo ir is it mp iv iw ix mq iz ja jb jc hb bi translated">请通过评论和在你的同辈群体中分享这篇文章来分享你的想法和支持。</p></blockquote></div></div>    
</body>
</html>