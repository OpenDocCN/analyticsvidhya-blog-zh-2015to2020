<html>
<head>
<title>Playing with Scala — Merge Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scala——合并排序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/playing-with-scala-merge-sort-d382fb1a32ff?source=collection_archive---------5-----------------------#2019-10-13">https://medium.com/analytics-vidhya/playing-with-scala-merge-sort-d382fb1a32ff?source=collection_archive---------5-----------------------#2019-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scala的模式匹配真的真的很强大。为了体验它的强大，我尝试使用模式匹配实现一个非常基本但强大的排序算法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/45e2be52ba7719e441a8b9d096d2c8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LKy7ZaPcyje5DSMD"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">安德鲁·雷德利在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本合并排序算法包括两个函数</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e296" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj"><em class="kf">def mergeSort(seq: List[Int]): List[Int]</em></strong></span></pre><p id="aa63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">→它接受一个未排序的集合并返回一个排序的集合。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7671" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj"><em class="kf">def merge(seq1: List[Int], seq2: List[Int]): List[Int]</em></strong></span></pre><p id="0e76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">→这需要两个排序的集合，并通过合并它们返回一个排序的集合。</p><p id="99c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个版本非常简单，使用了模式匹配的能力。</p><p id="355e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并排序函数→</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="a53f" class="jz ka hi jv b fi kb kc l kd ke">def mergeSort(seq: List[Int]): List[Int] = seq match {<br/>  case <em class="kf">Nil </em>=&gt; <em class="kf">Nil <br/>  </em>case xs::<em class="kf">Nil </em>=&gt; <em class="kf">List</em>(xs) <br/>  case _ =&gt; <br/>    val (left, right) = seq splitAt seq.length/2<br/>    <em class="kf">merge</em>(<em class="kf">mergeSort</em>(left), <em class="kf">mergeSort</em>(right))<br/>}</span></pre><p id="b47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并功能→</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7a74" class="jz ka hi jv b fi kb kc l kd ke">def merge(seq1: List[Int], seq2: List[Int]): List[Int] = <br/>        (seq1, seq2) match {<br/>           case (<em class="kf">Nil</em>, _) =&gt; seq2<br/>           case (_, <em class="kf">Nil</em>) =&gt; seq1<br/>           case (x::xs, y::ys) =&gt;<br/>            if(x&lt;y) x::<em class="kf">merge</em>(xs,seq2)<br/>            else y::<em class="kf">merge</em>(seq1,ys)<br/>}</span></pre><p id="2a9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对于较小的输入非常有效，但是对于较大的输入，由于显而易见的原因，它会抛出StackOverflow异常。我将它的性能与Scala中标准的<strong class="ih hj"> <em class="kf">排序</em> </strong>函数进行了比较。</p><p id="4f97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">100个数字，标准排序:71毫秒，合并排序(上图):10毫秒</p><p id="823c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1000个数字，标准排序:76毫秒，合并排序(上图):15毫秒</p><p id="ed1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10000个数字，标准排序:82ms，合并排序(上图):<strong class="ih hj"> <em class="kf">堆栈溢出</em> </strong></p><p id="cf5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kf">如何修复堆栈溢出错误？</em>T15】</strong></p><p id="2b83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尾部递归:马丁·奥德斯基解释如下:</p><blockquote class="kg"><p id="5552" class="kh ki hi bd kj kk kl km kn ko kp jc dx translated">将自己作为最后动作的函数称为尾递归函数。Scala编译器会检测到尾部递归，并在用新值更新函数参数后，用跳回到函数开头来代替它…只要你做的最后一件事是调用自己，它就会自动进行尾部递归(即优化)。</p></blockquote><p id="308f" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">现在我们如何优化我们的功能？</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e5ea" class="jz ka hi jv b fi kb kc l kd ke">def merge(seq1: List[Int], seq2: List[Int]): List[Int] = <br/>        (seq1, seq2) match {<br/>           case (<em class="kf">Nil</em>, _) =&gt; seq2<br/>           case (_, <em class="kf">Nil</em>) =&gt; seq1<br/>           case (x::xs, y::ys) =&gt;<br/>            if(x&lt;y) x::<em class="kf">merge</em>(xs,seq2)<br/>            else y::<em class="kf">merge</em>(seq1,ys)<br/>}</span></pre><p id="2f61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最后做的其实是<strong class="ih hj"> <em class="kf"> x::merge(xs，seq2) </em> </strong>或者<strong class="ih hj"> <em class="kf"> y::merge(seq1，ys)。没有资格打最后一个电话吗？尾音？</em> </strong></p><p id="d8f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不会。如果你再想想，最后发生的事情实际上是将x或y的<strong class="ih hj"><em class="kf"/></strong>和<strong class="ih hj"> <em class="kf"> merge() </em> </strong>函数调用的结果串联起来形成一个链表。</p><p id="141a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何解决它？</p><p id="643d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在这个函数中传递一个累加器，并在那里附加我们的结果。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="a9e8" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj"><em class="kf">@tailrec</em></strong><br/>def merge(seq1: List[Int], seq2: List[Int], <strong class="jv hj"><em class="kf">accumulator: List[Int] = List()</em></strong>):List[Int] = (seq1, seq2) match {<br/>  case (<em class="kf">Nil</em>, _) =&gt; <strong class="jv hj"><em class="kf">accumulator</em></strong> ++ seq2<br/>  case (_, <em class="kf">Nil</em>) =&gt; <strong class="jv hj"><em class="kf">accumulator</em></strong> ++ seq1<br/>  case (x::xs, y::ys) =&gt;<br/>    if(x&lt;y) <em class="kf">merge</em>(xs,seq2, <strong class="jv hj"><em class="kf">accumulator</em> :+ x</strong>)<br/>    else <em class="kf">merge</em>(seq1,ys, <strong class="jv hj"><em class="kf">accumulator</em> :+ y</strong>)<br/>}</span></pre><p id="84aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kf"> @tailrec </em> </strong> →这个注释帮助我们验证是否真的是尾调用。如果不是，编译器抛出一个错误。</p><p id="4def" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">比较性能:</strong></p><p id="7757" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> 100个数字，标准排序:74毫秒，合并排序(上图):15毫秒</em></p><p id="a3df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> 1000个数字，标准排序:72毫秒，合并排序(上图):40毫秒</em></p><p id="c350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf">10000个数字，标准排序:82毫秒，合并排序(上图):1236毫秒</em></p><p id="4969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> 10万个数字，标准排序:171毫秒，合并排序(上图):90秒</em></p><p id="c3c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管标准算法在较大的输入上表现得更好，但这个版本至少让我们避免了StackOverflow。多亏了尾部递归。</p><p id="d558" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有其他更好的版本吗？与我分享。我会尝试一下。</p><p id="f435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢了。</p></div></div>    
</body>
</html>