<html>
<head>
<title>🐍 Snake and Ladders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🐍蛇和梯子</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lets-play-snake-and-ladders-620cb7f217bc?source=collection_archive---------18-----------------------#2020-06-12">https://medium.com/analytics-vidhya/lets-play-snake-and-ladders-620cb7f217bc?source=collection_archive---------18-----------------------#2020-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/58349232e03734da9362952d52bd76ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRs4LMIVdJLyPewGC-IU_Q.jpeg"/></div></div></figure><p id="975a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好，今天我们要解决一个著名的<strong class="is hj">编程面试问题</strong>，这个问题在很多公司都被问到过，比如巨头<strong class="is hj">亚马逊，微软，D . E . Shaw</strong>等等。</p><p id="2158" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">《蛇梯》是一个大问题，我强烈建议你在继续阅读之前先看一遍。</p><div class="jo jp ez fb jq jr"><a href="https://www.geeksforgeeks.org/snake-ladder-problem-2/" rel="noopener  ugc nofollow" target="_blank"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">蛇和梯子问题- GeeksforGeeks</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">给定一条蛇和一个梯子板，找出到达目的地或最后一个格子所需的掷骰子的最少次数…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">www.geeksforgeeks.orgr</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf io jr"/></div></div></a></div><p id="7408" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个问题中给你一个<strong class="is hj">棋盘</strong>的中的<strong class="is hj"> N个格子，每个格子代表三种类型的东西{ <strong class="is hj">空</strong>、<strong class="is hj">梯</strong>、<strong class="is hj">蛇</strong> }。你是玩家，你最初站在1号单元格，现在你必须玩游戏，以最少的掷骰子数到达最后一个单元格。</strong></p><p id="5515" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例如</strong>我们的电路板看起来像这样</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="921f" class="kp kq hi kl b fi kr ks l kt ku">      [-1,-1,-1,-1,-1,-1] <strong class="kl hj">END</strong><br/>      [-1,-1,-1,-1,-1,-1]<br/>      [-1,-1,-1,-1,-1,-1]<br/>      [-1,35,-1,-1,13,-1]<br/>      [-1,-1,-1,-1,-1,-1]<br/><strong class="kl hj">START </strong>[-1,15,-1,-1,-1,-1]</span></pre><p id="133f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在board -1中，这里意味着您可以安全地进入该单元格，但是如果单元格的值不是-1，则意味着将会有<strong class="is hj">蛇</strong>或<strong class="is hj">梯子。</strong>如果某个单元格的值越来越接近终点，这意味着它是一个梯子，否则它就是一条蛇。</p><p id="bd22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，掷骰子的最少次数是4次。</p><p id="93bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是怎么做呢？🙄</p><p id="dc3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以答案是，最初你在底部的单元1，现在你掷一个正面为1的骰子，你在上面找到了一个梯子，然后你掷正面为2的骰子，到达17号方块，蛇咬了你，然后你下到13号方块，然后你掷正面为1的骰子，通过梯子到达35号方块，之后你只需要再掷一个正面为1的骰子，然后你到达目的地。</p><p id="276d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果板子的大小是1000或更大，人类很容易得到最小化的答案吗？</strong></p><p id="3da6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不😶</p><p id="edda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是进入画面的程序。我们可以编制程序，这样我们的计算机就可以很容易地计算它。</p><p id="c944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们写代码吧</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="cc40" class="kp kq hi kl b fi kr ks l kt ku">vector&lt;int&gt; board(size+1);     //replace size with the size of board<br/>vector&lt;bool&gt; vis(size+1,false);  //keep track of each cell</span></pre><p id="3702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用-1值初始化电路板，其中-1代表没有阶梯或蛇形线的单元。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="abdd" class="kp kq hi kl b fi kr ks l kt ku">for(int i=1;i&lt;=board.size();i++)<br/>board[i]=-1;</span></pre><p id="2e7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，从梯子的用户那里获取输入，并将它们存储到板上。假设用户以下面的形式{a，b}给你输入，这意味着在单元格a中存储值b。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d776" class="kp kq hi kl b fi kr ks l kt ku">cin&gt;&gt;a&gt;&gt;b;<br/>board[a]=b;</span></pre><p id="b525" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，也接受蛇的输入。</p><p id="3fb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">主代码现在开始</strong></p><p id="7ca3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个成对队列来存储单元信息，每个信息将包括到目前为止最后遍历的具有最小投掷的单元号。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d7d8" class="kp kq hi kl b fi kr ks l kt ku">queue&lt;array&lt;int,2&gt;&gt; q;<br/>q.push({1,0});<br/>vis[1]=true;</span></pre><p id="f619" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经用初始位置1初始化队列，最小投掷骰子数为0，并使<strong class="is hj">相对于</strong>为真。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8edd" class="kp kq hi kl b fi kr ks l kt ku">        while(!q.empty())<br/>        {<br/>            array&lt;int,2&gt; top=q.front();<br/>            q.pop();<br/>            <br/>            int ind=top[0];<br/>            <br/>            if(ind&gt;=size)<br/>            {<br/>                cout&lt;&lt;top[1]&lt;&lt;endl;<br/>                break;<br/>            }<br/>         }</span></pre><p id="6032" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，到目前为止，我们已经用初始位置初始化队列，并在队列不为空或找到最后一个单元时遍历队列。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4057" class="kp kq hi kl b fi kr ks l kt ku">            for(int i=ind+1; i&lt;size+1 &amp;&amp; i&lt;=(ind+6);i++)<br/>            {<br/>                if(vis[i]==false)<br/>                {<br/>                    array&lt;int,2&gt; temp;<br/>                    temp[1]=top[1]+1;<br/>                    vis[i]=true;<br/>                    <br/>                    if(board[i]!=0)<br/>                    {<br/>                        temp[0]=board[i];<br/>                    }<br/>                    else<br/>                    temp[0]=i;<br/>                    <br/>                    q.push(temp);<br/>                }<br/>            }</span></pre><p id="ce82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经用条件<strong class="is hj">I&lt;size+1&amp;&amp;I ≤( ind+6)</strong>初始化了一个for循环，因为从一个特定的位置可以前进到6个单元格，所以我们尝试了所有的可能性，并使掷骰子的次数比先前掷骰子的次数增加1，即<strong class="is hj">(新掷骰子的次数=先前掷骰子的次数+1) </strong>，并检查在掷骰子之后我们是否在一个特定的位置，如果该位置的值为-1，那么我们将top[0]作为I，否则我们将top[0]作为棋盘</p><p id="d675" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">所有代码一起</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="fb61" class="kp kq hi kl b fi kr ks l kt ku">        vector&lt;int&gt; board(size+1,-1);<br/>        vector&lt;bool&gt; vis(size+1,false);</span><span id="6794" class="kp kq hi kl b fi kv ks l kt ku">        for(int i=0;i&lt;size;i++)<br/>        {<br/>            int a,b;<br/>            cin&gt;&gt;a&gt;&gt;b;<br/>            board[a]=b;<br/>        }<br/>        <br/>        queue&lt;array&lt;int,2&gt;&gt; q;<br/>        q.push({1,0});<br/>        vis[1]=true;<br/>        <br/>        while(!q.empty())<br/>        {<br/>            array&lt;int,2&gt; top=q.front();<br/>            q.pop();<br/>            <br/>            int ind=top[0];<br/>            <br/>            if(ind&gt;=size)<br/>            {<br/>                cout&lt;&lt;top[1]&lt;&lt;endl;<br/>                break;<br/>            }<br/>            <br/>            for(int i=ind+1; i&lt;size+1&amp;&amp; i&lt;=(ind+6);i++)<br/>            {<br/>                if(vis[i]==false)<br/>                {<br/>                    array&lt;int,2&gt; temp;<br/>                    temp[1]=top[1]+1;<br/>                    vis[i]=true;<br/>                    <br/>                    if(board[i]!=0)<br/>                    {<br/>                        temp[0]=board[i];<br/>                    }<br/>                    else<br/>                    temp[0]=i;<br/>                    <br/>                    q.push(temp);<br/>                }<br/>            }<br/>        }</span></pre><h1 id="7423" class="kw kq hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">暂时就这样吧！</h1><p id="9fe7" class="pw-post-body-paragraph iq ir hi is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hb bi translated">希望这篇文章对想学习编程的人或者想提升技能的人有所帮助。</p></div></div>    
</body>
</html>