<html>
<head>
<title>Learn to use TPOT: An AutoML Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用TPOT:一个自动化工具</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/learn-to-use-tpot-an-automl-tool-4c52148c2bc9?source=collection_archive---------8-----------------------#2020-03-07">https://medium.com/analytics-vidhya/learn-to-use-tpot-an-automl-tool-4c52148c2bc9?source=collection_archive---------8-----------------------#2020-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0d69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将分享我基于TPOT(基于树的管道优化工具)的一些见解。我将通过我使用的一个数据集来解释这个工具。</p><h1 id="29bb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是TPOT？</h1><p id="1e6f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">TPOT代表基于树的管道优化工具。它用于解决或给出机器学习问题的思路。这有助于我们探索一些我们之前在模型中没有考虑到的管道配置。它有助于我们找到解决问题的最佳算法。我们输入数据，即训练输入和训练输出。它分析数据，并告诉我们最佳的机器学习模型。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/566fead9ad279b52262f9a22e7cae73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Spr8OgkLSZVF6y2w.png"/></div></div></figure><p id="bc10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TPOT是开源的，是scikit学习库的一部分。它可用于回归和分类模型。每一个库的实现和加载都是不同的。</p><h1 id="6160" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">TPOT的工作(使用数据集)</h1><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ks"><img src="../Images/1b799c03fc0bc8b88db538b740898fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xNa4P4rJVgqgRUUJ.png"/></div></div></figure><p id="61ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就像一个<strong class="ih hj">搜索算法</strong>通常会搜索最佳算法。最终的搜索结果基本上取决于性能，即哪个算法比其他算法提供更大的准确性。它还调整了一些超参数，以获得更好的性能和评估。所以不能认为是随机搜索算法。</p><p id="6244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在一般有两种类型的TPOT:</p><ul class=""><li id="2e81" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">TPOT分类器</li><li id="5262" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">TPOT回归者。</li></ul><p id="9c84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用一个数据集来研究它们的工作原理。</p><h1 id="9044" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">TPOT分类器</h1><p id="8d3c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为此，我们获取了一个包含客户信息的银行数据集。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lh"><img src="../Images/8b020a9772fc72f801b32eedcdd93ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*MgIFiVTeUwjA5Thh.PNG"/></div></figure><p id="9216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行数据清理是为了将数据转换成所需的形式。在完成几个功能后，我们将数据转换成所需的形式。</p><p id="4974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应变量:下月违约付款<br/>探索变量:身份证、婚姻、年龄、Bill_AMT1…Bill_AMT5</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="3f40" class="ln je hi lj b fi lo lp l lq lr">train=df.drop('default payment next month',axis=1)<br/>test=df['default payment next month']</span><span id="e65e" class="ln je hi lj b fi ls lp l lq lr">from sklearn.preprocessing import StandardScaler<br/>sc=StandardScaler()<br/>train=sc.fit_transform(train)</span><span id="71c8" class="ln je hi lj b fi ls lp l lq lr">from sklearn import model_selection<br/>x_train,x_test,y_train,y_test=model_selection.train_test_split(train,test)</span></pre><h1 id="0a78" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">实现TPOT分类器</h1><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="07dc" class="ln je hi lj b fi lo lp l lq lr">from tpot import TPOTClassifier<br/>from sklearn.metrics import roc_auc_score</span></pre><p id="f13a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认TPOTClassifier参数:</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="9b93" class="ln je hi lj b fi lo lp l lq lr">generations=100, <br/>population_size=100, <br/>offspring_size=None  # Jeff notes this gets set to population_size<br/>mutation_rate=0.9, <br/>crossover_rate=0.1, <br/>scoring="Accuracy",  # for Classification<br/>cv=5, <br/>subsample=1.0, <br/>n_jobs=1,<br/>max_time_mins=None, <br/>max_eval_time_mins=5,<br/>random_state=None, <br/>config_dict=None,<br/>warm_start=False, <br/>memory=None,<br/>periodic_checkpoint_folder=None, <br/>early_stop=None<br/>verbosity=0<br/>disable_update_check=False</span></pre><p id="7dcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的模型:</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="5935" class="ln je hi lj b fi lo lp l lq lr">pot = TPOTClassifier(<br/>    generations=5,<br/>    population_size=20,<br/>    verbosity=2,<br/>    scoring='roc_auc',<br/>    random_state=42,<br/>    disable_update_check=True,<br/>    config_dict='TPOT light'<br/>)<br/>tpot.fit(x_train, y_train)</span></pre><p id="df77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行模型后，我们得到了结果:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lt"><img src="../Images/7bea346dbe1494fa179aff5f7056232e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*axgYrXCcvg7pihi1.PNG"/></div></div></figure><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="018e" class="ln je hi lj b fi lo lp l lq lr">tpot_auc_score = roc_auc_score(y_test, tpot.predict_proba(x_test)[:, 1])<br/>print(f'\nAUC score: {tpot_auc_score:.4f}')</span></pre><p id="dfdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="1983" class="ln je hi lj b fi lo lp l lq lr">0.660</span></pre><p id="3ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要了解最佳模式:</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="a3b0" class="ln je hi lj b fi lo lp l lq lr">print('\nBest pipeline steps:', end='\n')<br/>for idx, (name, transform) in enumerate(tpot.fitted_pipeline_.steps, start=1):<br/>    print(f'{idx}. {transform}')</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lu"><img src="../Images/c76aca87620bc269bf7b8ae994f9abb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C2Rc77eZskxiH-xz.PNG"/></div></div></figure><p id="a73e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，您可以执行GridSearchCV之类的其他算法来优化超参数。</p><p id="8be0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用tpot提出的算法后得到的结果</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lv"><img src="../Images/3c1735757aa98ae77a1341cf8c202398.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*ED8usdDZxuXijOfP.png"/></div></figure><h1 id="abf3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">TPOT回归量</h1><p id="5125" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为此，我们考虑了RBI网站上的一个数据集。<br/>我们执行了数据清理部分，并以要求的形式接收数据</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lw"><img src="../Images/46e11a3bba5e4ab5ff5e40dc9dcc5555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dOYG-bIb8IiWW7mu.PNG"/></div></div></figure><p id="5af0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应变量:增长</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="fad7" class="ln je hi lj b fi lo lp l lq lr">from sklearn.preprocessing import StandardScaler<br/>sc=StandardScaler()<br/>df=sc.fit_transform(df)</span><span id="3ad5" class="ln je hi lj b fi ls lp l lq lr">y=df[' Y-o-Y Growth in (7) (%)']<br/>x=df.drop(' Y-o-Y Growth in (7) (%)',axis=1)</span><span id="7644" class="ln je hi lj b fi ls lp l lq lr">from sklearn import model_selection<br/>x_train,x_test,y_train,y_test=model_selection.train_test_split(x,y)</span></pre><p id="86f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变量与响应变量的相关性</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lx"><img src="../Images/635a9ae3fa86cc12831e254f04152667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eKw8_6ZCKzOI2YcM.PNG"/></div></div></figure><h1 id="b2f8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">模型实现</h1><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="cd94" class="ln je hi lj b fi lo lp l lq lr">from tpot import TPOTRegressor<br/>from sklearn.metrics import roc_auc_score</span><span id="e71c" class="ln je hi lj b fi ls lp l lq lr">tpot = TPOTRegressor(<br/>    generations=5,<br/>    population_size=50,<br/>    verbosity=2,<br/>)<br/>tpot.fit(x_train, y_train)</span></pre><p id="08cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行模型后，我们得到了结果:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ly"><img src="../Images/84c8c93105e25faf4d685919c43a7cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YVIBNk1Pr7Ji2LuF.PNG"/></div></div></figure><p id="4fde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用了TPOT告诉我们的算法后，我们得到了很好的结果</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lz"><img src="../Images/3fc2a3f8760de1f72b49dd53aee23f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/0*poqR0_d0llt_N2jr.png"/></div></figure><h1 id="9d17" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">关于TPOT的有用信息</h1><p id="88e1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">tpot根据一些参数来确定要搜索的管道数量</p><ul class=""><li id="ad5b" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">世代</strong> : int，可选(默认值:100) <br/>运行流水线优化过程的迭代次数。总的来说，当你给TPOT更多代(因此也给它更多时间)来优化管道时，它会做得更好。TPOT将评估总人口规模+世代x后代规模管道(强调我)。</li><li id="e294" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> population_size </strong> : int，可选(默认值:100) <br/>每一代在GP种群中保留的个体数量。<br/>一般来说，如果你让更多的人(因此也有更多的时间)来优化渠道，TPOT会做得更好。</li><li id="12d6" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">后代_大小</strong> : int，可选(默认:无)<br/>每个GP世代要产生的后代数量。默认情况下，后代大小=人口大小。</li></ul><p id="d050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最新tpot更新中包含的算法:</p><pre class="kh ki kj kk fd li lj lk ll aw lm bi"><span id="1ea3" class="ln je hi lj b fi lo lp l lq lr">‘sklearn.naive_bayes.BernoulliNB’: { ‘alpha’: [1e-3, 1e-2, 1e-1, 1., 10., 100.], ‘fit_prior’: [True, False] }, <br/>‘sklearn.naive_bayes.MultinomialNB’: { ‘alpha’: [1e-3, 1e-2, 1e-1, 1., 10., 100.], ‘fit_prior’: [True, False] }, <br/>‘sklearn.tree.DecisionTreeClassifier’: { ‘criterion’: [“gini”, “entropy”], ‘max_depth’: range(1, 11), ‘min_samples_split’: range(2, 21), ‘min_samples_leaf’: range(1, 21) }, <br/>‘sklearn.ensemble.ExtraTreesClassifier’: { ‘n_estimators’: [100], ‘criterion’: [“gini”, “entropy”], ‘max_features’: np.arange(0.05, 1.01, 0.05), ‘min_samples_split’: range(2, 21), ‘min_samples_leaf’: range(1, 21), ‘bootstrap’: [True, False] },<br/>‘sklearn.ensemble.RandomForestClassifier’: { ‘n_estimators’: [100], ‘criterion’: [“gini”, “entropy”], ‘max_features’: np.arange(0.05, 1.01, 0.05), ‘min_samples_split’: range(2, 21), ‘min_samples_leaf’: range(1, 21), ‘bootstrap’: [True, False] }, <br/>‘sklearn.ensemble.GradientBoostingClassifier’: { ‘n_estimators’: [100], ‘learning_rate’: [1e-3, 1e-2, 1e-1, 0.5, 1.], ‘max_depth’: range(1, 11), ‘min_samples_split’: range(2, 21), ‘min_samples_leaf’: range(1, 21), ‘subsample’: np.arange(0.05, 1.01, 0.05), ‘max_features’: np.arange(0.05, 1.01, 0.05) },<br/>‘sklearn.neighbors.KNeighborsClassifier’: { ‘n_neighbors’: range(1, 101), ‘weights’: [“uniform”, “distance”], ‘p’: [1, 2] }, <br/>‘sklearn.svm.LinearSVC’: { ‘penalty’: [“l1”, “l2”], ‘loss’: [“hinge”, “squared_hinge”], ‘dual’: [True, False], ‘tol’: [1e-5, 1e-4, 1e-3, 1e-2, 1e-1], ‘C’: [1e-4, 1e-3, 1e-2, 1e-1, 0.5, 1., 5., 10., 15., 20., 25.] }, <br/>‘sklearn.linear_model.LogisticRegression’: { ‘penalty’: [“l1”, “l2”], ‘C’: [1e-4, 1e-3, 1e-2, 1e-1, 0.5, 1., 5., 10., 15., 20., 25.], ‘dual’: [True, False] }, <br/>‘xgboost.XGBClassifier’: { ‘n_estimators’: [100], ‘max_depth’: range(1, 11), ‘learning_rate’: [1e-3, 1e-2, 1e-1, 0.5, 1.], ‘subsample’: np.arange(0.05, 1.01, 0.05), ‘min_child_weight’: range(1, 21), ‘nthread’: [1] }</span></pre><h1 id="b01f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">限制</h1><ul class=""><li id="0dd0" class="kt ku hi ih b ii kb im kc iq ma iu mb iy mc jc ky kz la lb bi translated">TPOT有时需要很长时间来寻找算法。因为它搜索所有算法，应用于我们提供的数据，这可能需要很长时间。如果我们在没有任何预处理步骤的情况下提供数据，它将花费更多的时间，因为它首先实现这些步骤，然后应用算法。</li><li id="1772" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">在某些情况下，TPOT对提供的相同数据显示不同的结果。当我们在复杂数据集上工作时会发生这种情况</li></ul></div></div>    
</body>
</html>