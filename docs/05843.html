<html>
<head>
<title>Increase maximum recursion depth in Python using Context Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用上下文管理器增加Python中的最大递归深度</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/increase-maximum-recursion-depth-in-python-using-context-manager-1c67eaf4e71b?source=collection_archive---------36-----------------------#2020-05-03">https://medium.com/analytics-vidhya/increase-maximum-recursion-depth-in-python-using-context-manager-1c67eaf4e71b?source=collection_archive---------36-----------------------#2020-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cb5b2646a697a75bbe35dc62dbb65d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QqR5YwavV3RUVeMsbPQfA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae iu" href="https://unsplash.com/s/photos/think-twice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="407b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上下文管理器是一个对象，它定义了在执行带有语句的<strong class="ix hj">时要建立的运行时上下文。上下文管理器处理代码块执行所需的运行时上下文的进入和退出。</strong></p><p id="2cbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看下面的例子，假设我想计算一个数的斐波纳契数-</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c4c9" class="kc kd hi jy b fi ke kf l kg kh">def fib_cal(fib_num, memo):<br/>    if memo[fib_num] is not None:<br/>        return memo[fib_num]<br/>    elif fib_num == 1 or fib_num == 2:<br/>        result = 1<br/>    else:<br/>        result = fib_cal(fib_num-1, memo) + fib_cal(fib_num-2, memo)<br/>    memo[fib_num] = result<br/>    return result<br/></span><span id="c2d6" class="kc kd hi jy b fi ki kf l kg kh">def get_fibonacci(fib_num):<br/>    memo = [None] * (fib_num+1)<br/>    return fib_cal(fib_num, memo)</span><span id="a41a" class="kc kd hi jy b fi ki kf l kg kh">print(fibonacci(100))</span></pre><p id="3867" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kj">输出-</em></strong>354224848179261915075</p><ul class=""><li id="01be" class="kk kl hi ix b iy iz jc jd jg km jk kn jo ko js kp kq kr ks bi translated">假设我的数字更大，比如3000</li></ul><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b311" class="kc kd hi jy b fi ke kf l kg kh">print(fibonacci(3000))</span></pre><ul class=""><li id="59c1" class="kk kl hi ix b iy iz jc jd jg km jk kn jo ko js kp kq kr ks bi translated">在上面的例子中，它会抛出一个错误-</li></ul><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7c8d" class="kc kd hi jy b fi ke kf l kg kh">RecursionError: maximum recursion depth exceeded in comparison</span></pre><p id="03df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为已经超过了操作系统的最大递归限制。您可以按如下方式检查递归限制</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9731" class="kc kd hi jy b fi ke kf l kg kh">import sys<br/>sys.getrecursionlimit()</span></pre><p id="5ab2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在这种情况下，我们可以使用上下文管理器，它允许我们在需要时精确地分配和释放资源。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1e4a" class="kc kd hi jy b fi ke kf l kg kh">import sys<br/></span><span id="9676" class="kc kd hi jy b fi ki kf l kg kh">class RecursionLimit:<br/>    def __init__(self, limit):<br/>        self.limit = limit<br/>        self.cur_limit = sys.getrecursionlimit()</span><span id="98e3" class="kc kd hi jy b fi ki kf l kg kh">    def __enter__(self):<br/>        sys.setrecursionlimit(self.limit)</span><span id="0071" class="kc kd hi jy b fi ki kf l kg kh">    def __exit__(self, exc_type, exc_value, exc_traceback):<br/>        sys.setrecursionlimit(self.cur_limit)<br/></span><span id="625b" class="kc kd hi jy b fi ki kf l kg kh">MAX_LIMIT = 10000</span><span id="ca02" class="kc kd hi jy b fi ki kf l kg kh">with RecursionLimit(MAX_LIMIT):<br/>    print(fibonacci(3000))</span></pre><p id="79aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出</strong>-4106158863079712603335683787192671052201251086373692524……..6000</p><p id="2ba4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kt ku kv jy b">__enter__()</code>返回需要管理的资源，而<code class="du kt ku kv jy b">__exit__()</code>不返回任何东西，而是执行清理操作。</p><p id="60ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上下文管理器还可以用于其他目的，如简单的文件I/O，如打开和关闭套接字，在测试期间实现设置和拆除功能。</p><p id="744d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢读这篇文章，如果你有什么建议，请在评论中告诉我。</p></div></div>    
</body>
</html>