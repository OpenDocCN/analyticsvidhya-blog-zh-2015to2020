<html>
<head>
<title>Docker For Data Engineers-I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据工程师Docker</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/docker-for-data-engineers-i-c6ec41b2e7f4?source=collection_archive---------10-----------------------#2020-06-13">https://medium.com/analytics-vidhya/docker-for-data-engineers-i-c6ec41b2e7f4?source=collection_archive---------10-----------------------#2020-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="510b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博客是面向数据工程师的docker系列的第一篇，这篇博客将让你开始使用docker。</p><p id="2b25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下当你想测试一些软件或者像spark这样的框架时的情况。传统的方法是下载zip文件，然后执行一组命令。如果有一些兼容性问题，这是所有安装软件真的会很痛苦。相反，如果我说，我们只需运行一行命令就可以启动并运行任何软件。有意思吧！！！。</p><p id="1a05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是docker所做的</p><p id="548d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们详细看看下面的事情。为了简化事情，我假设我有一个从dockerfile构建的图像</p><p id="d82f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker是什么？</p><p id="3741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经营码头工人</p><p id="2d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker卷的数据持久性</p><p id="18e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向外界展示码头工人</p><p id="6652" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一篇博客:从Docker文件构建自定义Docker图像。</p><h1 id="66e6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">什么是docker？</strong></h1><p id="7771" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我想从我的理解中给出一个定义docker是一个类似于在python中运行虚拟env的虚拟环境，但不同的是Docker应用了相同的概念但在应用程序级别。</p><p id="4b60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，如果我们有一个应用程序，它是用我们当前环境中没有的某些包编写的，那么我们将创建一个虚拟环境权限。</p><blockquote class="kg kh ki"><p id="8e91" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">同样，如果我们安装了docker应用程序，那么我们可以运行任何软件，例如我们有一个ubuntu 16.04版本，我们想在Cent OS上测试一些应用程序，我们可以从docker注册表中提取CENT OS映像(顾名思义)，然后我们现在可以在这个OS上进行测试。</p></blockquote><p id="29df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们可以在同一台机器上运行不同版本的MYSQL</p><h1 id="a3aa" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">docker给开发者带来了什么？</strong></h1><ol class=""><li id="abe7" class="kn ko hi ih b ii kb im kc iq kp iu kq iy kr jc ks kt ku kv bi translated">减少测试应用对基础设施的依赖</li><li id="ff0f" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">易于部署不同版本的应用程序</li><li id="fc52" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">易于测试任何软件</li></ol><h1 id="0028" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">docker给组织带来了什么？</h1><ol class=""><li id="8634" class="kn ko hi ih b ii kb im kc iq kp iu kq iy kr jc ks kt ku kv bi translated">易于生产的应用</li><li id="cf55" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">运行独立的应用程序，而不是安装的版本有问题</li><li id="7263" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">易于扩展</li><li id="8051" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">比虚拟机便宜</li></ol><h1 id="449d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">安装Docker:</h1><p id="c7b1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">它可以很容易地安装在ubuntu和非Windows 0S上</p><blockquote class="kg kh ki"><p id="7c91" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><a class="ae lb" href="https://get.docker.com/" rel="noopener ugc nofollow" target="_blank">https://get.docker.com/</a></p></blockquote><p id="e6df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:上面的方法是为了在本地开发应用。</p><p id="d6b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有windows或者您喜欢少安装，那么使用</p><blockquote class="kg kh ki"><p id="9381" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><a class="ae lb" href="https://labs.play-with-docker.com/" rel="noopener ugc nofollow" target="_blank">https://labs.play-with-docker.com/</a></p></blockquote><p id="39a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">docker是如何工作的？</strong></p><p id="857b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker围绕三件事</p><ol class=""><li id="794a" class="kn ko hi ih b ii ij im in iq lc iu ld iy le jc ks kt ku kv bi translated">码头引擎</li><li id="02d6" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">Docker图像</li><li id="0f6e" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">Docker注册表</li></ol><figure class="lg lh li lj fd lk er es paragraph-image"><div class="er es lf"><img src="../Images/a574ff00a6603f1ee01f044544d0d1dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*DQ2tNPnsmqchgEpwy8sAUA.png"/></div></figure><p id="38ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker引擎:</p><blockquote class="kg kh ki"><p id="f5fe" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">docker的组件提供了docker运行的环境。它类似于java应用程序的JVM</p></blockquote><p id="d984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker图像:</p><blockquote class="kg kh ki"><p id="eff6" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">它是保存软件的组件。比方说，如果我们想运行一个mysql服务器，我们必须从docker registry下载mysql镜像。它是从DockerFile构建的</p></blockquote><p id="bf5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">码头中心:</p><blockquote class="kg kh ki"><p id="8c00" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">它是所有类似于github repo的图像的存储库</p></blockquote><h2 id="c150" class="ln je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">要运行的步骤</h2><p id="259c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">假设我们没有安装MySQL，我们决定用docker探索MySQL</p><p id="38c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docker中的命令类似于git</p><p id="fda6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤1:我们可以使用pull命令从docker hub中提取docker映像</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/2eb69150c5b4a3d6459a85680ed37a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w18B4_QKhJrdLixMmK0T-Q.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">Docker第一次从docker hub中拉出mysql</figcaption></figure><p id="2933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤2:一旦我们发出pull命令，docker将检查映像的本地副本，如果它可用，它会将映像的哈希值与docker hub的表单进行比较，以检查任何更新。如果有一些更新，它将从docker拉最近的图像</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mk"><img src="../Images/0f67729e14508add6900a7b863b427cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNGmuIjnc9LvkgF7YzVzEg.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">Docker使用本地镜像，而不是像上面那样下载</figcaption></figure><h2 id="1335" class="ln je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">步骤3:使用run命令启动docker容器</h2><blockquote class="kg kh ki"><p id="91ec" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">docker容器运行—名称C1-e MYSQL _ ROOT _ PASSWORD = my-secret-pw-d MYSQL</p></blockquote><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ml"><img src="../Images/7f7d1944647e028442e3bcca3d8c7b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gd9YSXSxvS54IOP07AQSHg.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">Docker运行mysql容器</figcaption></figure><p id="9d33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们运行一个名为c1的容器，mysql password=my-secret-pwd (-e用于设置env密码)，它是在后台从图像mysql构建的(使用-d)</p><h2 id="4327" class="ln je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">步骤4:在容器内工作</h2><p id="6708" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们已经启动了容器，我们可以使用命令<strong class="ih hj"> exec -it </strong>在容器内部进行交互</p><blockquote class="kg kh ki"><p id="a44a" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">docker容器exec -it c1 bash</p></blockquote><p id="e5db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在这里，我们使用exec -it进入容器c1，并运行命令bash。在执行命令时，我们将与容器交互，并进入容器内部，我们可以看到命令提示符从home/somanath更改为<container-id/></p><p id="eb9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们使用mysql -u root和我们之前给出的root密码，我们将使用exit退出容器</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mm"><img src="../Images/605948b7ce0f23039f0711853ceb2b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hs5xufhLLY6Ms491rZJyTw.png"/></div></div></figure><h1 id="0fe3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">容器和图像之间的差异</h1><p id="e16c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">图像是只读的，当我们运行图像时，我们创建一个容器。</p><p id="d781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器就像物体，它没有持久的意义</p><p id="7905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们退出容器，关闭机器并重新创建一个容器，那么我们将丢失所有数据。检查这个</p><p id="b433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker是基于层的概念。比方说，我们有一个mysql映像，当我们运行mysql映像时，我们将创建一个容器C1，并在容器内创建一个数据库。现在我们将有原始图像，并在它的顶部添加一层变化，如下所示</p><figure class="lg lh li lj fd lk er es paragraph-image"><div class="er es mn"><img src="../Images/390a816ed7e8fe1138507397a2f4cdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*GcSZ9IowqcFMYOC0TWvVdg.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">容器顶部的容器层</figcaption></figure><p id="374b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们退出容器，关闭机器并重新创建一个容器，那么我们将丢失所有数据。</p><h1 id="2b84" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">Docker卷的数据持久性</strong></h1><p id="db73" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如果我们想保存数据以备将来使用，该怎么办？假设我们对docker mysql容器进行了大量分析，并创建了一个测试数据库，因此如果容器在关闭期间丢失，所有数据都将丢失。因此，为了避免这种情况，我们将使用mount挂载一个卷，这样容器内的数据更改就可以映射到我的机器上的某个物理位置</p><p id="b092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用— mount标志将本地系统中的卷附加到容器中的卷</p><blockquote class="kg kh ki"><p id="3771" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">为了找到我们想要附加卷的位置，我们必须检查docker文件中的卷关键字</p></blockquote><div class="mo mp ez fb mq mr"><a href="https://github.com/docker-library/mysql/blob/bc6e37a2bed792b1c4fc6ab1ec3ce316e6a5f061/8.0/Dockerfile#L77" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hj fi z dy mw ea eb mx ed ef hh bi translated">docker-library/mysql</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">Permalink GitHub是5000多万开发人员的家园，他们一起工作来托管和审查代码、管理项目以及…</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ll mr"/></div></div></a></div><p id="bc72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过检查，我发现它在/var/lib/mysql下</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ng"><img src="../Images/edf6ad4b47d4b612be1c85c7ee7be87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6RHEzKjjGr_SMX_R0Ad_A.png"/></div></div></figure><blockquote class="kg kh ki"><p id="219f" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">docker容器run-name C2-mount source = MYSQL data，target =/var/lib/MYSQL/-e MYSQL _ ROOT _ PASSWORD = myscretpw-d MYSQL</p></blockquote><p id="c16e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的命令创建了一个卷mysqldata，因此我们将登录容器并创建一个db测试</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es nh"><img src="../Images/4e30eb063c4982b066d431c86cab6159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLMTEANDXZ3bFviepX6j9g.png"/></div></div></figure><p id="4a6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以在下面看到测试数据库</p><p id="8a77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">/var/lib/docker/volumes</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ni"><img src="../Images/34b8b5b09fdb72c98637821f734098fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AaoghihfasS3PYqoE85V6w.png"/></div></div></figure><h1 id="4274" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">向外界展示码头工人</h1><p id="3ecf" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们有了持久卷，但唯一的问题是我每次都必须进入docker容器来执行查询，从长远来看这是非常困难的。</p><p id="ade3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时我们可能会使用workbench，所以我们可能需要用它连接docker容器中的mysql。因此，我们必须将连接从docker端口(3306)转移到某个本地主机的可用端口(例如33360)</p><p id="464b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，最后一步不是在docker中运行mysql，而是使用端口转发将docker端口暴露给运行机器的ip</p><blockquote class="kg kh ki"><p id="581e" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">docker容器运行—名称c3 -p 33360:3306 —挂载source=mysqldata，target =/var/lib/MYSQL/-e MYSQL _ ROOT _ PASSWORD = myscretpw-d MYSQL</p></blockquote><p id="faa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有一个docker暴露给一个特定的端口，我们将能够访问它在我的本地主机端口33360。</p><p id="a6d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试这一点，我使用spark查询这个新的mysql数据库</p><blockquote class="kg kh ki"><p id="8e77" class="if ig kj ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated">&gt; &gt; &gt; jdbcDF = spark.read.format("jdbc ")。选项(" url "，" jdbc:mysql://localhost:33360 ")。选项(“用户”，“根”)。选项(" password "，" mysecretpw ")。选项(" dbtable "，" mysql.user ")。负载()</p></blockquote><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es nj"><img src="../Images/36e8d20ff3881ddd25c8527852b335bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlvCcJ8lqoJO2IMODNs1JQ.png"/></div></div></figure><p id="fa72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="2f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们安装了docker，我们将使用卷安装来存储持久数据，最后我们将使用端口转发向外界公开docker</p><p id="8399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将允许您使用localhost:33360访问docker中3306内部运行的mysql(端口从3306转发到33360)。</p><p id="84ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天就到这里吧！！:)</p><p id="829a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Github链接:<a class="ae lb" href="https://github.com/SomanathSankaran/spark_medium/tree/master/spark_csv" rel="noopener ugc nofollow" target="_blank">https://github . com/SomanathSankaran/spark _ medium/tree/master/spark _ CSV</a></p><p id="9852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"/></p></div></div>    
</body>
</html>