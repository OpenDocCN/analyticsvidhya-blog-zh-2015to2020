<html>
<head>
<title>PyTest Fixtures for Fun and Profit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTest夹具的乐趣和利润</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pytest-fixtures-for-fun-and-profit-9109d5ac2895?source=collection_archive---------23-----------------------#2020-04-26">https://medium.com/analytics-vidhya/pytest-fixtures-for-fun-and-profit-9109d5ac2895?source=collection_archive---------23-----------------------#2020-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6734c09967f2ebdfc605ae92afce4a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3z9ohSMO5UjgbxmO"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克里斯里德在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="dfb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" rel="noopener" href="/analytics-vidhya/3-ways-to-test-any-application-effectively-with-pytest-35f2e99b2a1a">我的上一篇文章</a>中，我谈到了为什么PyTest是对任何应用程序进行功能测试的伟大工具，以及将它集成到您的开发环境中的不同方法。现在，我将更深入地研究PyTest中对于编写好的功能测试至关重要的一个方面:fixtures。Fixtures是用于建立和拆除测试环境的模块化工具，正确使用它们将允许您更好地构建测试代码，并使用更少的代码进行更多的测试。</p><p id="4304" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">使用夹具安装和拆卸</strong></p><p id="f356" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个具体的例子，我将使用一个用Go编写的(非常)简单的应用程序，它启动一个HTTP服务器进程。我使用Go的原因是为了展示PyTest如何用于测试用任何语言编写的应用程序，而不仅仅是Python。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个超级基本的HTTP服务器，用Go写的</figcaption></figure><p id="7a8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我将使用PyTest为这个应用程序编写一个测试。应用程序的运行时状态封装在一个类中，该类公开start()和stop()方法。单个测试用例启动应用程序，发出HTTP请求，断言响应的状态和内容，然后停止应用程序。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">测试我们应用的起点</figcaption></figure><p id="34c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从表面上看，这段代码可能看起来完全合理，但它实际上有一个严重的问题。如果我改变我的应用程序，返回一个不同的文本，打破第49行的断言，会发生什么？嗯，测试当然会失败——这是我们希望发生的。但这还不是全部:由于断言失败，测试用例的其余部分将不会执行，这意味着我们的应用程序的stop()代码永远不会运行。如果您自己尝试，您会看到应用程序进程仍然在运行，即使python进程已经退出。</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="7b86" class="ke kf hi ka b fi kg kh l ki kj">ps -ef | grep '\./app'<br/>  501  1656     1   0 12:54pm ttys001    0:00.01 ./app</span></pre><p id="c8f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使测试失败，它们也不应该泄漏资源，如进程、线程、文件句柄或套接字。它们不仅浪费您的系统资源，泄漏的资源还会通过交互以意想不到的方式导致后续测试失败。例如，如果我测试的应用程序总是在同一个端口上侦听，在测试结束时未能正确停止应用程序将意味着重新运行测试将总是失败，因为端口仍在使用中。</p><p id="49ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了确保<code class="du kk kl km ka b">stop()</code>总是被调用，你可以将测试用例断言包装在一个<code class="du kk kl km ka b">try...finally</code>块中，或者你可以将App类放入一个<a class="ae iu" href="https://alysivji.github.io/managing-resources-with-context-managers-pythonic.html" rel="noopener ugc nofollow" target="_blank">上下文管理器</a>中，或者使用老式的<a class="ae iu" href="https://docs.pytest.org/en/latest/xunit_setup.html" rel="noopener ugc nofollow" target="_blank">安装和拆卸函数</a>来达到同样的效果。然而，有一个更好的方法:夹具。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将应用程序设置分解到一个设备中</figcaption></figure><p id="238c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意<code class="du kk kl km ka b">app</code>夹具如何使用<code class="du kk kl km ka b">yield</code>关键字将启动的<code class="du kk kl km ka b">App</code>对象传递到测试函数中。测试用例完成后，不管它是通过还是失败，app fixture都将恢复并终止app进程。通过将应用程序的安装和拆卸代码放在同一个函数中，可以很容易地看到拆卸代码是如何对应于用单独的安装和拆卸方法无法获得的安装内容的。在我们的测试函数中使用fixture所要做的就是将fixture名称作为测试函数的参数，因此我们的测试函数中的代码只需要处理正在进行的实际的<em class="kn">测试</em>。</p><p id="a16b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">更进一步:夹具范围</strong></p><p id="507e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">夹具是可重用的，所以当你开发你的应用程序时，你可以继续添加更多依赖于同一个应用程序夹具的测试。然而，当你这样做的时候，你需要记住夹具的范围。默认情况下，fixture有“function”作用域，这意味着fixture的一个新实例将被建立，然后为每个使用它的函数而被拆除。我上面的示例应用程序应该为任何HTTP方法返回完全相同的响应，所以我将为PUT和POST方法添加几个测试。当我运行测试并用<code class="du kk kl km ka b">-s</code>标志禁用stdout捕获时，我可以看到我的应用程序启动和停止了3次:</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="d67c" class="ke kf hi ka b fi kg kh l ki kj">test_app.py::test_app Starting app<br/>PASSEDStopping app</span><span id="6925" class="ke kf hi ka b fi ko kh l ki kj">test_app.py::test_app_put Starting app<br/>PASSEDStopping app</span><span id="e380" class="ke kf hi ka b fi ko kh l ki kj">test_app.py::test_app_post Starting app<br/>PASSEDStopping app</span></pre><p id="56da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">保持fixture范围较小有一个好处——通过为每个测试创建一个新实例，您可以防止其他测试对应用程序的副作用影响后续测试。然而，缺点是当您添加更多的测试用例时，您的测试将需要更长的时间来运行。我们可以通过将fixture的范围改为“模块”来加快我们的测试:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在测试函数之间共享相同的应用程序实例</figcaption></figure><p id="9896" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，该模块中依赖于app fixture的所有测试都将使用一个共享实例。PyTest将启动应用程序进程，对它运行我们所有的测试，然后停止应用程序。Fixture作用域也可以设置为“class”、“package”或“session ”,分别应用于同一类、包或测试会话中的所有测试。对于您应该使用哪个作用域，并没有严格的规则，但是作为一般的经验法则，您应该使用最低级别的作用域，它允许您的测试在合理的时间长度内完成。因为我们的应用程序启动非常快，而且我们现在只有三个测试，所以在我们的小例子中使用函数作用域fixture是很好的，但是对于一个实际复杂的应用程序以及数十或数百个测试用例，至少在模块作用域共享应用程序实例是有意义的。如果您的fixture设置非常昂贵，例如，如果您的测试需要在单独的docker容器中运行大量服务(看一看<a class="ae iu" href="https://github.com/avast/pytest-docker" rel="noopener ugc nofollow" target="_blank"> pytest-docker </a>)，您可能会希望将fixture留在会话范围内。请记住，您需要特别小心，以避免在使用共享fixture实例的测试之间出现意外的副作用。</p><p id="b626" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用参数化增加你的测试</strong></p><p id="62ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数化是一种非常有用的增加测试覆盖率的技术。您可能知道，参数化可以应用于测试函数，以从单个模板生成多个测试。例如，我可以使用参数化简化我之前对各种HTTP方法的测试。</p><p id="4cba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这还不是全部:您还可以参数化fixture函数，从单个模板生成多个不同的fixture。对于夹具的每个参数化，所有使用参数化夹具的测试将运行一次。参数化夹具函数的方式与测试函数略有不同，但效果是相同的。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">参数化我们的夹具和测试</figcaption></figure><p id="e407" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">灯具可以依赖其他灯具</strong></p><p id="e2df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">夹具是模块化的，这意味着夹具功能可以依赖于其他夹具，而其他夹具又可以依赖于其他夹具等。Fixture模块化证明是非常强大的，因为它允许您将多个相互依赖的应用程序和服务编排到一个测试环境中。一个简单而常见的例子是当您需要使用一个客户端来连接到您的被测服务器进程时。通过将测试客户机包装在依赖于服务器夹具的夹具中，客户机可以(例如)提取服务器的监听地址以允许它连接，而不依赖于硬编码的端口。</p><p id="7c59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到我们前面的例子，我们可以创建一个AppClient类来存储应用程序地址，并使访问服务器上的URL稍微简单一些。请注意，我不再需要使<code class="du kk kl km ka b">app</code> fixture成为<code class="du kk kl km ka b">test_app</code>函数的显式依赖项，因为它现在通过<code class="du kk kl km ka b">app_client</code>间接依赖。还要注意<code class="du kk kl km ka b">app_client</code> fixture是如何具有“function”作用域的，因此将为每个测试创建一个新实例——这很好，因为初始化客户机的成本很低。<code class="du kk kl km ka b">app</code> fixture仍然是“模块”范围的，所以只启动了一个应用程序实例。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">添加app_client设备</figcaption></figure><p id="9ead" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">总之</strong></p><p id="63ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经讨论了如何在PyTest中使用fixtures将安装和拆卸从测试代码中分离出来。除此之外，我们还通过一个例子展示了如何使用fixture来管理运行在独立进程中的应用程序，fixture作用域的重要性，以及如何使用参数化和模块化fixture来用更少的代码进行更多的测试。</p></div></div>    
</body>
</html>