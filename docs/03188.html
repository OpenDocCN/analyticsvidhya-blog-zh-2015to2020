<html>
<head>
<title>Pandas Masterclass — Your Foundation To Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫大师班——你的数据科学基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-5-5e86b812f6c3?source=collection_archive---------23-----------------------#2020-01-19">https://medium.com/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-5-5e86b812f6c3?source=collection_archive---------23-----------------------#2020-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f071" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第5部分:多索引数据帧，处理na值和组合数据帧</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e83fd8df934251affb9e947083116e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMN7XGhKnNt-eQzS35bRVg.jpeg"/></div></div></figure><p id="0e69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 1。从数据框架中删除数据<br/> </strong>在Pandas框架中提供了两种不同的方法来删除数据。第一个是<code class="du kf kg kh ki b">del</code>关键字，另一个选项是<code class="du kf kg kh ki b">drop()</code>函数。<code class="du kf kg kh ki b">del</code>只能用来删除一列，而<code class="du kf kg kh ki b">drop()</code>功能可以根据需要删除行或列。我们将首先讨论如何在我们之前讨论的泰坦尼克号乘客数据上使用<code class="du kf kg kh ki b">del</code>,其结构如下所示，我们可以注意到它有12列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/62ae628767400cf01078569a6b0873c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*I-YJYSJ2FybLskFNNHvfvg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">显示titanicData数据帧第一行的内容</figcaption></figure><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="cbe1" class="ks kt hi ki b fi ku kv l kw kx">del titanicData['Cabin']<br/>del titanicData['Embarked']<br/>print(titanicData.head())<br/>print(titanicData.shape)</span></pre><p id="7702" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用<code class="du kf kg kh ki b">del</code>非常简单，我们必须指定我们想要一次删除数据帧中的哪一列。一旦我们运行该行代码，就对数据帧进行了更改，我们可以通过调用数据帧的<code class="du kf kg kh ki b">shape()</code>来验证这一点，它显示现在只有10列，因为我们已经从<code class="du kf kg kh ki b">titanicData</code>数据帧中删除了<code class="du kf kg kh ki b">'Cabin'</code>和<code class="du kf kg kh ki b">'Embarked'</code>列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/1f5756b0b7d3a719dcb132e7745de1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*ER9mZwmHSqI9DhCbrZs6CA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除2列后的titanicData数据帧的结构</figcaption></figure><p id="2c04" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如前所述，<code class="du kf kg kh ki b">drop()</code>函数能够删除行和列。我们可以使用函数的<code class="du kf kg kh ki b">axis</code>参数来指示我们是否想要删除行或列。轴的默认值是<code class="du kf kg kh ki b">0</code>,表示对行的拖放操作，我们可以设置<code class="du kf kg kh ki b">axis = 1</code>表示对列的拖放操作。此外，更改不会直接反映在数据帧上，我们必须设置<code class="du kf kg kh ki b">inplace = True</code>或重新分配给数据帧以反映更改。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="2eb1" class="ks kt hi ki b fi ku kv l kw kx">titanicData.drop(['PassengerId', 'Age'], axis = 1, inplace = True)<br/>print(titanicData.head())<br/>print(titanicData.shape)</span></pre><p id="ebbd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的代码暗示我们希望从<code class="du kf kg kh ki b">titanicData</code>数据帧中删除<code class="du kf kg kh ki b">'PassengerId'</code>和<code class="du kf kg kh ki b">'Age'</code>列，同时提交对数据帧的更改。打印出数据帧的形状，我们可以看到列数从10列进一步减少到现在的8列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/6fc5115b3420804c15cb0e8620419f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*c5GesMgwdK2rg6gwa_IxCg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">显示实现drop()后的titanicData数据帧结构和形状</figcaption></figure><p id="428f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们也可以使用drop函数通过用索引值替换列值来删除行。首先举一个简单的例子，注意在<code class="du kf kg kh ki b">156</code>中实现drop on rows之前的行数。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="908a" class="ks kt hi ki b fi ku kv l kw kx">titanicData.drop(0, inplace = True)<br/>print(titanicData.shape())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/f1096c083fbf410e30999f073a67d02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*J__QD1J9AXfM7DBZegpNVg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除1行后的titanicData数据帧的形状</figcaption></figure><p id="40a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以删除一系列行，让我们看看如何删除索引号<code class="du kf kg kh ki b">1 to 9</code>。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="17f2" class="ks kt hi ki b fi ku kv l kw kx">titanicData.drop(range(1,10), inplace = True)<br/>print(titanicData.shape())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/c9b76904c94c2d6b99ee8339a4b6817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*gCO0f-KpllftuOjAw0zlSg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除9行后titanicData数据帧的形状</figcaption></figure><p id="a71b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们所看到的，数据帧中的行数从之前的155减少到了146。</p><p id="10c6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 2。设置和重置索引值<br/> </strong>创建数据帧时，索引值默认从<code class="du kf kg kh ki b">0</code>开始设置，并为下一行增加1，但我们可以根据需要灵活设置任何索引值。让我们通过在现有索引值上添加字母<code class="du kf kg kh ki b">A</code>来为<code class="du kf kg kh ki b">titanicData</code>数据帧创建一个新的索引范围。这可以通过首先使用如下的列表理解从现有索引值创建新索引值的列表来容易地完成</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="3e96" class="ks kt hi ki b fi ku kv l kw kx">newIndex = ['A'+x for x in titanicData.index]<br/>print(newIndex)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/2bc7f88282ec38cb2c4a0ad4de8bcbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*pjyUZl-Daj9Apbp_iXlI1g.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">列表新索引的内容</figcaption></figure><p id="a37f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，我们可以在<code class="du kf kg kh ki b">titanicData</code>数据帧中创建一个新列，并将其设置为数据帧的新索引，如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/9d0f94f36a30caf2ddb95c6134bbde77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*3V2Tv94HUWKDkQAb5leRUg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">数据框架中添加了新的索引列</figcaption></figure><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="ba16" class="ks kt hi ki b fi ku kv l kw kx">titanicData['newIndex'] = newIndex<br/>titanicData.set_index('newIndex', inplace = True)<br/>print(titanicData.head())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/2fbf6b242019e4b9338630c05eb5645c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*pCuKe6VeV72XzYZJEfxxWA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">列newIndex设置为DataFrame的索引值</figcaption></figure><p id="285b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果出于某种原因，我们想要设置数据帧的默认索引值，我们可以通过使用<code class="du kf kg kh ki b">reset_index()</code>函数轻松实现。请注意，默认情况下，使用<code class="du kf kg kh ki b">reset_index()</code>函数还会将当前索引值保留为表中的一个单独列，为了避免这种情况，我们必须设置<code class="du kf kg kh ki b">drop = True</code>参数。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="459d" class="ks kt hi ki b fi ku kv l kw kx">titanicData.reset_index(inplace = True) #drop = False by default<br/>print(titanicData.head())</span><span id="b135" class="ks kt hi ki b fi lb kv l kw kx">titanicData.set_index('newIndex', inplace = True) #setting new index again</span><span id="28d0" class="ks kt hi ki b fi lb kv l kw kx">titanicData.reset_index(inplace = True, drop = True)<br/>print(titanicData.head())</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/a2939a2d27769101e32109c4c56da33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*XLJtZGFuuiMYdEtCMabEjA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">使用reset_inde()，默认drop = False，然后drop = True</figcaption></figure><p id="955f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 3。使用多索引数据帧<br/> </strong>一个数据帧可以有多个索引，这样的数据帧索引称为多索引。使用它们会增加一层复杂性，但是一旦我们知道如何使用它们来检索必要的数据，这就非常容易了，几乎就像处理普通的数据帧一样。首先，让我们看看如何构建一个多索引数据框架。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="8c61" class="ks kt hi ki b fi ku kv l kw kx">outside = ['G1', 'G1', 'G1', 'G2', 'G2', 'G2']<br/>inside = [1, 2, 3, 1, 2, 3]<br/>arrayIndex = np.array([outside, inside])<br/>heir_index = pd.MultiIndex.from_arrays(arrayIndex) #forming multi index from arrays</span></pre><p id="72b1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们首先创建两个列表，第一个表示第一级索引值，下一个表示第二级索引值。然后，我们创建一个数组，该数组包含多对形式为<code class="du kf kg kh ki b">[[‘G1’ ‘G1’ ‘G1’ ‘G2’ ‘G2’ ‘G2’]<br/> [‘1’ ‘2’ ‘3’ ‘1’ ‘2’ ‘3’]]</code>的索引值，然后使用<code class="du kf kg kh ki b">MultiIndex.from_arrays()</code>函数创建一个多重索引。</p><p id="caee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦我们准备好了多索引，我们就可以创建一个形状为<code class="du kf kg kh ki b">(6, 3)</code>的数据帧，其中填充了一些随机数和上面创建的来自<code class="du kf kg kh ki b">heir_index</code>的索引值。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="cf73" class="ks kt hi ki b fi ku kv l kw kx">data = np.round(np.random.rand(6,3),2)<br/>df = pd.DataFrame(data = data, index= heir_index)<br/>print(df)</span></pre><p id="f6ad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们正在生成一个大小为6行2列的嵌套列表的矩阵形式，随机数被截断到两位小数，然后创建一个多索引数据帧，如上所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/099b99ddc2e0c442a392de97e29fa60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*pjdtWFNoO34ZPuY6M2wd8g.png"/></div></figure><p id="97db" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果需要，我们甚至可以指定索引名。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="cdea" class="ks kt hi ki b fi ku kv l kw kx">df.index.names = ['Outer', 'Inner']<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lc"><img src="../Images/2c9a8df68e7a511420f8b0d1cceefd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*t_GoI0bX4C3X9wExt7cfcA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">多指标标记</figcaption></figure><p id="d594" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在访问数据非常容易。要访问第一级(or) <code class="du kf kg kh ki b">'Outer'</code>索引，我们可以直接使用下面的<code class="du kf kg kh ki b">loc()</code>函数。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="757e" class="ks kt hi ki b fi ku kv l kw kx">print(titanicData.loc['G1'])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/bbceb5f4c240cc4059e57bd6cde4dbf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*L2nf4ORVvARi8SpdP9UlzA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">调用外部索引G1的所有列</figcaption></figure><p id="6e5b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要调用内部索引，我们可以在一级索引上调用的现有<code class="du kf kg kh ki b">loc</code>函数之上使用<code class="du kf kg kh ki b">loc</code>函数，如下所示。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="6044" class="ks kt hi ki b fi ku kv l kw kx">print(titanicData.loc['G1'].loc['2', 0:3]</span></pre><p id="3215" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以上数据打印<code class="du kf kg kh ki b">'G1'</code>索引的索引<code class="du kf kg kh ki b">'2'</code>，打印索引<code class="du kf kg kh ki b">'2'</code>的所有列值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/41c9d7163ddff0491dda297d410f0c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*E3lqFlbySgz6V8MtCobUPg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">“G1”索引的索引“2”的数据</figcaption></figure><p id="9472" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 4。在DataFrame <br/> </strong>中传递NaN值，即使在我们处理的最完美的数据集中，我们最终也会遇到至少两个NaN值。了解在数据帧中清除和填充NaN值的基本操作是很重要的。</p><p id="15fc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们首先创建一个非常基本的样本数据框架。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="c9ac" class="ks kt hi ki b fi ku kv l kw kx">df = pd.DataFrame({'A':[1, 2, np.nan], 'B':[5, np.nan, np.nan], 'C':[1, 2, 3]})<br/>df['States'] = "CA NV AZ".split()<br/>df.set_index('States', drop = True, inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/1d12556cf2c1077ad4fbcc685342f0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*T6-onquHHJOE_UdDpRrRjw.png"/></div></div><figcaption class="kk kl et er es km kn bd b be z dx translated">测向数据帧的内容</figcaption></figure><p id="54f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，让我们看看<code class="du kf kg kh ki b">dropna()</code>函数，它可以帮助我们删除具有<code class="du kf kg kh ki b">NaN</code>值的行或列。</p><p id="8537" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要删除任何有<code class="du kf kg kh ki b">NaN</code>值的行，我们可以如下使用<code class="du kf kg kh ki b">dropna()</code>函数。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="c9cc" class="ks kt hi ki b fi ku kv l kw kx">df.dropna(axis = 0, inplace = True) #default axis value is 0 as well<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/3485649f2320b33f84fb09bd119af751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*6w532EtQv2rBPHG2pCdQXg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除具有NaN值的行的结果</figcaption></figure><p id="0100" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在原始数据帧<code class="du kf kg kh ki b">df</code>中，我们可以看到索引<code class="du kf kg kh ki b">'NV'</code>和<code class="du kf kg kh ki b">'AZ'</code>都至少有1个<code class="du kf kg kh ki b">NaN</code>值，因此对行调用<code class="du kf kg kh ki b">dropna()</code>函数会删除这两个索引。</p><p id="76ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要删除具有<code class="du kf kg kh ki b">NaN</code>值的列，我们可以使用相同的语法，但是使用<code class="du kf kg kh ki b">axis = 1</code>来表示列方式操作。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="7bc6" class="ks kt hi ki b fi ku kv l kw kx">df.dropna(axis = 1, inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/bb49f61426143546764f662b741fd9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*xteZTcvCreYUuofKBtcijw.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除具有NaN值的列的结果</figcaption></figure><p id="8b58" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们来看看一些有用的参数，这些参数使<code class="du kf kg kh ki b">dropna()</code>功能更强大。</p><p id="7b54" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kf kg kh ki b">thresh</code>参数也表示阈值，意味着不删除至少有<code class="du kf kg kh ki b">thresh</code>个非NaN值的任何行/列。例如，如果我们指定<code class="du kf kg kh ki b">thresh = 2</code>，那么<code class="du kf kg kh ki b">dropna()</code>函数将不会删除任何至少有2个非NaN值的行/列。在我们的数据帧df中，索引<code class="du kf kg kh ki b">'CA'</code>和<code class="du kf kg kh ki b">'NV'</code>都至少有2个非NaN值，因此即使在调用了<code class="du kf kg kh ki b">dropna()</code>函数之后，这两行在最终结果中都将保持不变。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="1370" class="ks kt hi ki b fi ku kv l kw kx">df.dropna(thresh = 2, inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/2dcb86fbb9aa5890bcc816c8fe3415cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*xSihXKg15jy4HkhX33G8Bg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除具有NaN值且thresh = 2的行的结果</figcaption></figure><p id="43f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一个有用的参数是<code class="du kf kg kh ki b">how</code>参数，它有两个值，或者是<code class="du kf kg kh ki b">'all'</code>或者是<code class="du kf kg kh ki b">'any'</code>。当我们选择<code class="du kf kg kh ki b">'all'</code>时，它删除所有值都为<code class="du kf kg kh ki b">NaN</code>的任何行/列，当我们选择<code class="du kf kg kh ki b">'any'</code>时，它删除至少有一个<code class="du kf kg kh ki b">NaN</code>值的任何行/列。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="4e4e" class="ks kt hi ki b fi ku kv l kw kx">df.dropna(how="any", axis = 1, inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/bb49f61426143546764f662b741fd9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*xteZTcvCreYUuofKBtcijw.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">删除具有NaN值和how = 'any '的列的结果</figcaption></figure><p id="50d9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们有一个有用的函数可以帮助我们填充数据帧<code class="du kf kg kh ki b">NaN</code>的值，它叫做<code class="du kf kg kh ki b">fillna()</code>。让我们从一个用<code class="du kf kg kh ki b">NaN</code>填充所有单元格的基本用例开始。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="3a37" class="ks kt hi ki b fi ku kv l kw kx">df.fillna("fill value", inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/6eb8e2b4271bc389fddb89541739afe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*YNFWzc51Q_Fqxc0_f2JzwQ.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">用“填充值”填充的df数据帧的所有NaN值</figcaption></figure><p id="51d7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以将它提升一个等级，并填充特定的列值。让我们看看如何用非NaN值的平均值填充<code class="du kf kg kh ki b">'A'</code>列的<code class="du kf kg kh ki b">NaN</code>值。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="2683" class="ks kt hi ki b fi ku kv l kw kx">df['A'].fillna(value = df['A'].mean(), inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/c43b58298a21cc5065cc067d4e452443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*ou4GwJ_2I9znvF2Fi5QnWQ.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">用非NaN值的平均值填充的列“A”NaN值</figcaption></figure><p id="78d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以进一步扩展它，用下面的代码将相同的逻辑应用于<code class="du kf kg kh ki b">df</code>数据帧的所有列。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="4e79" class="ks kt hi ki b fi ku kv l kw kx">for column in df.columns.values:<br/>    df[column].fillna(value = df[column].mean(), inplace = True)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/b22f748914fd4f683456de0eeef9e78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*_M-xjf8ObcOXyGKLkkq0tQ.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">所有列的NaN值填充了相应列的平均非NaN值</figcaption></figure><p id="1fd3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 5。使用concat()函数连接数据帧<br/> </strong>我们在Pandas中有一个内置函数，可以帮助我们将任意数量的数据帧连接在一起。串联可以按行或按列发生，分别由设置为0或1的<code class="du kf kg kh ki b">axis</code>参数指示。</p><p id="3149" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们创建三个数据帧来显示各种连接操作。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="47a9" class="ks kt hi ki b fi ku kv l kw kx">df1 = pd.DataFrame({'A':['A0', 'A1', 'A2', 'A3'], 'B':['B0', 'B1', 'B2', 'B3'], 'C':['C0', 'C1', 'C2', 'C3'], 'D':['D0', 'D1', 'D2', 'D3']}, index = [0, 1, 2, 3])</span><span id="37a5" class="ks kt hi ki b fi lb kv l kw kx">df2 = pd.DataFrame({'A':['A4', 'A5', 'A6', 'A7'], 'B':['B4', 'B5', 'B6', 'B7'], 'C':['C4', 'C5', 'C6', 'C7'], 'D':['D4', 'D5', 'D6', 'D7']}, index = [4, 5, 6, 7])</span><span id="637d" class="ks kt hi ki b fi lb kv l kw kx">df3 = pd.DataFrame({'A':['A8', 'A9', 'A10', 'A11'], 'B':['B8', 'B9', 'B10', 'B11'], 'C':['C8', 'C9', 'C10', 'C11'], 'D':['D8', 'D9', 'D10', 'D11']}, index = [8, 9, 10, 11])</span><span id="a2c4" class="ks kt hi ki b fi lb kv l kw kx">print(df1)<br/>print(df2) <br/>print(df3)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/32b45461dfbabb47150d5d522f251a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*3Rmwna_m5dvIMzSevOuyyA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">数据帧df1、df2和df3的内容</figcaption></figure><p id="eb66" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们不指定任何<code class="du kf kg kh ki b">axis</code>值时，缺省情况下会按行进行串联。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="6b67" class="ks kt hi ki b fi ku kv l kw kx">import pandas as pd</span><span id="4c34" class="ks kt hi ki b fi lb kv l kw kx">dfCat = pd.concat([df1, df2, df3])<br/>print(dfCat)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/88b744b80c27f1158b873361824bab8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*VhqtHLY3yJ6jeWQ52mq3Bg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">按行连接的结果</figcaption></figure><p id="b6c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于我们在所有数据帧中都有相似的列名，这很容易理解，现在让我们看一下<code class="du kf kg kh ki b">df3</code>数据帧的一个小变化。如果列<code class="du kf kg kh ki b">'B'</code>被标记为<code class="du kf kg kh ki b">'E'</code>，则</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="4dca" class="ks kt hi ki b fi ku kv l kw kx">df3 = pd.DataFrame({'A':['A8', 'A9', 'A10', 'A11'], 'B':['B8', 'B9', 'B10', 'B11'], 'C':['C8', 'C9', 'C10', 'C11'], 'D':['D8', 'D9', 'D10', 'D11']}, index = [8, 9, 10, 11])</span><span id="80af" class="ks kt hi ki b fi lb kv l kw kx">dfCat = pd.concat([df1, df2, df3])<br/>print(dfCat)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/d24ab0c4cf780ca1a2834e5c4f8736b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*9MiJS0GE5nMTvSJ1fskr6A.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">逐行连接</figcaption></figure><p id="5e56" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在数据帧<code class="du kf kg kh ki b">df1</code>和<code class="du kf kg kh ki b">df2</code>中，我们没有列<code class="du kf kg kh ki b">'E'</code>，因此在结果<code class="du kf kg kh ki b">dfCat</code>中用<code class="du kf kg kh ki b">NaN</code>值填充。类似地，在数据帧<code class="du kf kg kh ki b">df3</code>中，我们没有列<code class="du kf kg kh ki b">'B'</code>，因此它在结果<code class="du kf kg kh ki b">dfCat</code>中有<code class="du kf kg kh ki b">NaN</code>值。</p><p id="4736" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们通过在初始DataFrame数据上设置<code class="du kf kg kh ki b">axis = 1</code>来看看按列连接的结果。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="9999" class="ks kt hi ki b fi ku kv l kw kx">dfCat = pd.concat([df1, df2, df3], axis = 1)<br/>print(dfCat)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/83f2382b77fa7e0fe59b07385e3de163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*cVrv7gKg-NnuxaSe8YDqbw.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">逐列连接</figcaption></figure><p id="aa8a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们看到的第二个按行连接的例子，由于所有三个数据帧中的列的索引值不同，所以连接以这种方式发生。如果所有数据帧具有相似的索引值，那么<code class="du kf kg kh ki b">dfCat</code>的数据将如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/19f414aad213da11f6db1b03341fa2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*63RIPXR-3ZbL7SYNA-Tj1A.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">当所有数据帧具有相同的索引值时，按列连接</figcaption></figure><p id="350a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 6。使用merge()函数合并数据帧<br/></strong>Pandas中提供的另一个有用的函数是<code class="du kf kg kh ki b">merge()</code>函数，它具有许多类似于SQL的<code class="du kf kg kh ki b">join</code>操作的强大功能。这是一个通过例子更容易理解的函数。</p><p id="edf9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们创建一些样本数据框架来处理。数据帧的名称将是<code class="du kf kg kh ki b">left</code>和<code class="du kf kg kh ki b">right</code>。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="afdd" class="ks kt hi ki b fi ku kv l kw kx">left = pd.DataFrame({'key':['K0', 'K1', 'K2', 'K3'], 'A':['A0', 'A1', 'A2', 'A3'], 'B':['B0', 'B1', 'B2', 'B3']}, index = [0, 1, 2, 3])</span><span id="f536" class="ks kt hi ki b fi lb kv l kw kx">right = pd.DataFrame({'key':['K1', 'K1', 'K2', 'K4'], 'C':['C0', 'C1', 'C2', 'C3'], 'D':['D0', 'D1', 'D2', 'D3']}, index = [4, 5, 6, 7])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/c9c47cb8517d97cc7abf77c350b348d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*TYB-9s04RtUZzv3IPwWGdQ.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">左右数据帧</figcaption></figure><p id="2856" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我们继续之前，让我们花点时间看看有哪些典型的合并操作。我们有四种不同的合并操作</p><p id="e736" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">I)内部——表示从两个不同的数据集中选择公共数据的内部合并<br/> ii)外部——从两个数据集中选择所有数据，并在特定数据集中发现一些缺失数据时用<code class="du kf kg kh ki b">NaN</code>值填充<br/> iii)左侧——选择所有左侧数据集，并在右侧数据集中缺失数据的地方填充<code class="du kf kg kh ki b">NaN</code>值<br/> iv)右侧——选择所有右侧数据集，并在左侧数据集中缺失数据的地方填充<code class="du kf kg kh ki b">NaN</code>值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/f2eea96ab37ca5edc747f712c3a98133.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*LtS6Qe2ovDeu3Hmbbb8uzQ.jpeg"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">各种合并操作的可视化表示</figcaption></figure><p id="cab5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">函数<code class="du kf kg kh ki b">merge()</code>的默认值是<code class="du kf kg kh ki b">inner</code>，但是我们可以使用<code class="du kf kg kh ki b">how = 'outer'</code>等指定其他类型的合并操作。</p><p id="5e45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们深入一些例子。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="11ef" class="ks kt hi ki b fi ku kv l kw kx">df = pd.merge(left, right, how = 'inner', on= 'key')<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/2112823f8447334e2ccfcc2490ecf02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*9BgyVXOOPzPYr4tJ_ZekyA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">应用于数据帧的内部合并操作</figcaption></figure><p id="8cff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们合并时，被认为实现合并操作的默认<code class="du kf kg kh ki b">key</code>将是第一列，但是使用<code class="du kf kg kh ki b">on = 'key'</code>参数我们可以指定哪一列被认为是用于合并的<code class="du kf kg kh ki b">key</code>。由于<code class="du kf kg kh ki b">k0</code>不存在于<code class="du kf kg kh ki b">right</code>数据帧中，该行在生成的数据帧中被完全省略。</p><p id="5d69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设我们在数据帧中没有相同的列名作为<code class="du kf kg kh ki b">key</code>，那么我们可以使用<code class="du kf kg kh ki b">left_on</code>和<code class="du kf kg kh ki b">right_on</code>参数来分别指示来自左表和右表的<code class="du kf kg kh ki b">key</code>值。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="f090" class="ks kt hi ki b fi ku kv l kw kx">left = pd.DataFrame({'key1':['K0', 'K1', 'K2', 'K3'], 'A':['A0', 'A1', 'A2', 'A3'], 'B':['B0', 'B1', 'B2', 'B3']}, index = [0, 1, 2, 3])<br/>right = pd.DataFrame({'key2':['K1', 'K1', 'K2', 'K4'], 'C':['C0', 'C1', 'C2', 'C3'], 'D':['D0', 'D1', 'D2', 'D3']}, index = [4, 5, 6, 7])</span><span id="c7e2" class="ks kt hi ki b fi lb kv l kw kx">df = pd.merge(left, right, how = 'inner', left_on = 'key1', right_on = 'key2') <br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/4075a2739496a23f7d4bb83318ab90f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*9GWi7qHJxZTp75OssnOb7Q.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">在两个数据帧中使用不同关键字的合并操作</figcaption></figure><p id="8402" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们实现与<code class="du kf kg kh ki b">how = 'right'</code>的合并，我们可以看到下面的结果</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="b77f" class="ks kt hi ki b fi ku kv l kw kx">df = pd.merge(left, right, how = 'right', on= 'key')<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kj"><img src="../Images/0219e2ca202c317ea0a588203b8faf22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*ns3rrLUBERl2Kj7I6GGQyA.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">用how = 'right '合并运算</figcaption></figure><p id="0a46" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于数据帧<code class="du kf kg kh ki b">left</code>没有<code class="du kf kg kh ki b">key</code>值<code class="du kf kg kh ki b">K4</code>，因此在<code class="du kf kg kh ki b">'A'</code>和<code class="du kf kg kh ki b">'B'</code>列中填充了<code class="du kf kg kh ki b">NaN</code>值。</p><p id="9b31" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 7。使用join()操作<br/> </strong>连接数据函数<code class="du kf kg kh ki b">join()</code>与<code class="du kf kg kh ki b">merge()</code>非常相似，唯一不同的是<code class="du kf kg kh ki b">join()</code>认为操作是在<code class="du kf kg kh ki b">index</code>值上完成的，而在merge中我们使用<code class="du kf kg kh ki b">column</code>值作为<code class="du kf kg kh ki b">key</code>。我们可以在join中使用<code class="du kf kg kh ki b">on</code>参数，使其与<code class="du kf kg kh ki b">merge()</code>完全相同。</p><p id="7b31" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">考虑以下示例数据帧来展示<code class="du kf kg kh ki b">join()</code>操作。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="807b" class="ks kt hi ki b fi ku kv l kw kx">df1 = pd.DataFrame({'A':['A0', 'A1', 'A2', 'A3'], 'B':['B0', 'B1', 'B2', 'B3']}, index = ['K0', 'K1', 'K2', 'K3'])</span><span id="9450" class="ks kt hi ki b fi lb kv l kw kx">df2 = pd.DataFrame({'C':['C0', 'C1', 'C2', 'C3'], 'D':['D0', 'D1', 'D2', 'D3']}, index = ['K0', 'K2', 'K3', 'K4'])</span><span id="b5c9" class="ks kt hi ki b fi lb kv l kw kx">print(df1)<br/>print(df2)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/9493f6aba288e75499fcce36adf1197a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*Jz_zKli0XtSCPPysbAwN6w.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">样本数据帧df1和df2内容</figcaption></figure><p id="645d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们看一些例子。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="a4dc" class="ks kt hi ki b fi ku kv l kw kx">print(df1.join(df2))</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/8925f025486355d4a34fa92295b280fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*dCQGtejPaLKyjn4M6bR_3g.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">df1和df2上的默认联接操作</figcaption></figure><p id="99fd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">默认情况下，它在用于调用<code class="du kf kg kh ki b">join()</code>函数的数据帧<code class="du kf kg kh ki b">df1</code>上执行<code class="du kf kg kh ki b">left</code>连接。</p><p id="6323" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看在<code class="du kf kg kh ki b">df1</code>和<code class="du kf kg kh ki b">df2</code>上执行<code class="du kf kg kh ki b">outer</code>连接的结果。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="e8fd" class="ks kt hi ki b fi ku kv l kw kx">print(df1.join(df2, how = 'outer'))</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/bf12cd559a8d4e158781d8293c8a761e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*flYxx1j8EiJ7rrXw1GJEuQ.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">df1和df2数据帧上的外部连接</figcaption></figure><p id="3217" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> 8。对数据帧内容应用函数<br/> </strong> Pandas有一个名为<code class="du kf kg kh ki b">apply()</code>的函数，可以使用数据帧调用。<code class="du kf kg kh ki b">apply()</code>函数的参数是另一个函数。当我们在某些列上调用<code class="du kf kg kh ki b">apply()</code>函数时，它将列数据作为参数传递给我们在<code class="du kf kg kh ki b">apply()</code>中传递的函数，并执行函数中的语句。为了消除歧义，让我们看一些例子。</p><p id="3c06" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要考虑的样本数据帧</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="c218" class="ks kt hi ki b fi ku kv l kw kx">df = pd.DataFrame(np.array(range(100,110)), index = list(range(0,10)))<br/>df[1] = np.array(range(200,210))<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/60cce9e2dbcebf59bc8db492906ab319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*aufzVI82lNiWDwXno5YkEw.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">数据帧df的内容</figcaption></figure><p id="0d7f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们定义一个简单的函数<code class="du kf kg kh ki b">testFunc</code>，它返回传递给它的<code class="du kf kg kh ki b">list</code>的总和。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="7ede" class="ks kt hi ki b fi ku kv l kw kx">def testFunc(x):<br/>    return sum(x)</span></pre><p id="c2be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用<code class="du kf kg kh ki b">apply</code>函数将列<code class="du kf kg kh ki b">'0'</code>和<code class="du kf kg kh ki b">'1'</code>传递给<code class="du kf kg kh ki b">testFunc()</code>，如下所示。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="9ecf" class="ks kt hi ki b fi ku kv l kw kx">df['Sum'] = df[[0,1]].apply(testFunc, axis = 1)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/7f80235ec201db1357d4601022f195ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*O8N3Qg9aT7cJKPgLCUb63Q.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">列“Sum”是调用apply()函数的结果</figcaption></figure><p id="e1a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看如何将整个列的细节传递给一个函数，以对其执行乘法运算，并将结果追加到现有的数据帧<code class="du kf kg kh ki b">df</code>。</p><pre class="iy iz ja jb fd ko ki kp kq aw kr bi"><span id="db41" class="ks kt hi ki b fi ku kv l kw kx">def mul(x):<br/>    return x[0] * x[1]<br/>df['Multiply'] = df.apply(mul, axis = 1)<br/>print(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/a274702a9e9321ff58e0895e822b6308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*leip6CqqQ3c2JFUwYbHWCg.png"/></div><figcaption class="kk kl et er es km kn bd b be z dx translated">应用结果(mul)</figcaption></figure><p id="7b14" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们在整个数据帧上调用<code class="du kf kg kh ki b">apply()</code>函数而没有指定哪些列必须被传递时，所有的列都将被传递给<code class="du kf kg kh ki b">apply()</code>中提到的函数。</p><p id="cdd0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">结论:<br/> </strong>虽然我已经尽了最大努力来涵盖Pandas中尽可能多的功能和用例，但这仍然是一个未涉及的详尽列表。我已经尽了最大努力来确保一个人能够学到足够的知识，如果情况需要学习更多知识的话，可以开始对熊猫的进一步探索。</p><p id="42d2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你想让我包含更多关于熊猫的话题，请给我写关于raghupro@gmail.com的信。祝你好运！</p><p id="4c32" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">系列各部分:</strong><br/><a class="ae le" rel="noopener" href="/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-1-136474104d57">Pandas master class——你的数据科学基础(第1部分:基本数据帧操作)</a><br/><a class="ae le" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-2-e0abda580cc3">Pandas master class——你的数据科学基础(第2部分:特殊文件格式的数据帧操作)</a><br/><a class="ae le" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-3-220cd683540e">Pandas master class——你的数据科学基础(第3部分:排序、 过滤和分组数据帧数据并写入文件)</a><br/><a class="ae le" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-4-736a233b0b70">Pandas master class—您的数据科学基础(第4部分:Pandas功能)</a><br/><a class="ae le" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-5-5e86b812f6c3">Pandas master class—您的数据科学基础(第5部分:多索引数据帧、处理na值和组合数据帧)</a></p></div></div>    
</body>
</html>