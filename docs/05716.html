<html>
<head>
<title>Clean Data Science workflow with Sklearn Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sklearn管道清理数据科学工作流</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clean-data-science-workflow-with-sklearn-pipeline-2b648634b29f?source=collection_archive---------11-----------------------#2020-04-30">https://medium.com/analytics-vidhya/clean-data-science-workflow-with-sklearn-pipeline-2b648634b29f?source=collection_archive---------11-----------------------#2020-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">管道是步骤的容器，它们用于打包工作流并将模型放入单个对象中。流水线堆叠在彼此之上，从一个块获取输入，将输出发送到下一个块，下一个块获取输入并给出输出。就这么简单！</p><p id="e3d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，有一个包含两个步骤的管道(I)规格化器和(ii)线性回归模型。数据将首先被传递到规格化器块，规格化器块将转换数据并将其发送到线性回归模型，线性回归模型将利用规格化器块的数据拟合模型。然后，线性回归可以训练模型并进行预测。<em class="jd">使用管道时，数据源保持不变，数据转换更改在内存中完成，因此数据源保持不变。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/2ac3fe21bf85e7764721c9497c7fe85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*GXgr-z1r9-xQaupuOWkZBg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">两步流水线</figcaption></figure><p id="65d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过以<strong class="ih hj"> ((name，task())) </strong> → <strong class="ih hj"> (('Norm '，Normalizer()) </strong>或<strong class="ih hj">(' LR '，LinearRegression()) </strong>的形式传递元组列表来初始化管道。管道可以执行的一些基本步骤:</p><ol class=""><li id="9006" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">变压器</li></ol><p id="0af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">transformation(x，[y])对X应用变换</p><p id="cb23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.估计量</p><p id="58ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fit(X，Y)根据数据拟合模型对象</p><p id="a8e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.预言</p><p id="c1f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">predict(X_test)预测结果</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="54ea" class="ke kf hi ka b fi kg kh l ki kj">#importing libraries<br/>from sklearn.datasets import load_boston<br/>from sklearn.preprocessing import StandardScaler<br/>from sklearn.decomposition import PCA,KernelPCA<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.model_selection import cross_val_score,GridSearchCV<br/>from sklearn.metrics import mean_squared_error<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.pipeline import FeatureUnion<br/>import pandas as pd<br/>import numpy as np</span></pre><ol class=""><li id="b555" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">变换、估计和预测</strong></li></ol><p id="a1d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我将使用<strong class="ih hj">波士顿数据集</strong>。第一步，我们将使用<strong class="ih hj"> StandardScaler </strong>转换数据，然后将数据放入<strong class="ih hj"> RandomForestRegressor </strong>中。最后一步，我们将把模型传递到<strong class="ih hj">交叉值得分</strong>。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="ad5f" class="ke kf hi ka b fi kg kh l ki kj">X=load_boston()<br/>df=pd.DataFrame(X.data,columns=X.feature_names)<br/>y=X.target</span><span id="f609" class="ke kf hi ka b fi kk kh l ki kj"><strong class="ka hj">#initializing and defining a Pipeline<br/></strong>pipe=[] <br/>pipe.append(('SC',StandardScaler()))<br/>pipe.append(('rfr',RandomForestRegressor(n_estimators=200)))<br/>model=Pipeline(pipe)</span><span id="76e4" class="ke kf hi ka b fi kk kh l ki kj"><strong class="ka hj">#cross val score <br/></strong>cv_results = cross_val_score(model, df, y, cv=5)<br/>msg = "%s: %f (%f)" % ('Pipeline', cv_results.mean(), cv_results.std())<br/>print(msg)</span></pre><p id="6bae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以根据需要在流水线中增加n个步骤。让我们将<strong class="ih hj"> PCA </strong>添加到<strong class="ih hj">标准定标器</strong>和<strong class="ih hj">随机森林</strong>之间的管道中。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="b458" class="ke kf hi ka b fi kg kh l ki kj">pipe=[]<br/>pipe.append(('SC',StandardScaler())) #step 0<br/>pipe.append(('pca', PCA(n_components=8))) #step 1<br/>pipe.append(('rfr',RandomForestRegressor())) #step 2<br/>model=Pipeline(pipe)</span></pre><p id="4f0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<strong class="ih hj"> model.steps[0] </strong>来访问管道的单独步骤</p><p id="04ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<strong class="ih hj"> model.named_steps </strong>访问管道的所有步骤</p><p id="eb08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。带管道的网格搜索CV</strong></p><p id="bf08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GridSearchCV作为pipeline的一部分可以让你避免编写大量不需要的代码，如果你想在项目中执行多个超参数调优，Pipeline会非常有用。根据上面创建的管道示例，我们可以执行两个超参数搜索(i)PCA和(ii) RandomForestRegressor。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="00ff" class="ke kf hi ka b fi kg kh l ki kj"># defining the params for hyper-parameters<br/>params = dict(pca__n_components=[2, 5, 10],<br/>                  rfr__n_estimators=[100,200,300,400],<br/>                  rfr__max_depth=[2,4,6,8,10])</span><span id="0fb8" class="ke kf hi ka b fi kk kh l ki kj">#Grid Search CV<br/>gcv=GridSearchCV(model,param_grid=params,n_jobs=-1).fit(df,y)</span><span id="7311" class="ke kf hi ka b fi kk kh l ki kj">gcv.best_params_<br/><strong class="ka hj">{'pca__n_components': 10, 'rfr__max_depth': 8, 'rfr__n_estimators': 200}</strong></span></pre><p id="ae8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.特征联合</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kl"><img src="../Images/066988b206762810892bdeea89dfc7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*7pkFVU2WdvSfCHhixihTuw.png"/></div></figure><p id="e38c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特征联合是将几个转换器的输出连接成一个的水平管道。在拟合过程中，每一个都独立地拟合到数据。转换器并行应用，它们输出的特征矩阵并排连接成一个更大的矩阵。我们可以使用<strong class="ih hj"> PCA </strong>和<strong class="ih hj">内核PCA </strong>来转换数据，并获得两种分解的混合输出。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="7828" class="ke kf hi ka b fi kg kh l ki kj">pipe=[]<br/>pipe.append(('kernel_pca',KernelPCA(n_components=5)))<br/>pipe.append(('pca',PCA(n_components=5)))<br/>model=FeatureUnion(pipe)</span><span id="d650" class="ke kf hi ka b fi kk kh l ki kj">model.fit(df,y).shape<br/><strong class="ka hj">(506, 10)</strong></span></pre><p id="13d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是来自PCA的5个分量和来自内核PCA的5个分量的组合，连接成一个。我们可以尝试任何数量的组合，如[PCA，SelectKBest]最好的部分是代码将看起来干净和像样。如果你想取出一个零件并用其他零件替换它，这是非常模块化的。查看这个<a class="ae km" href="https://scikit-learn.org/stable/auto_examples/compose/plot_feature_union.html#sphx-glr-auto-examples-compose-plot-feature-union-py" rel="noopener ugc nofollow" target="_blank">链接</a>，了解更复杂的管道示例。</p><p id="ea6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">管道的优势:</p><ul class=""><li id="b863" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc kn jw jx jy bi translated">好写。写一次，用多次。</li><li id="99a6" class="jq jr hi ih b ii ko im kp iq kq iu kr iy ks jc kn jw jx jy bi translated">容易交换棋子。</li><li id="5830" class="jq jr hi ih b ii ko im kp iq kq iu kr iy ks jc kn jw jx jy bi translated">不乱，干净，像样。</li><li id="ee93" class="jq jr hi ih b ii ko im kp iq kq iu kr iy ks jc kn jw jx jy bi translated">将所有中间步骤放在一起。</li></ul></div></div>    
</body>
</html>