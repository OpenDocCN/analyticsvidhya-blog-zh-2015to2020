<html>
<head>
<title>Space Weather Dashboard: Part 2— Designing the Layout of a Custom Space Weather Dashboard in Dash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">空间天气仪表板:第2部分—在Dash中设计自定义空间天气仪表板的布局</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/space-weather-dashboard-part-2-designing-the-layout-of-a-custom-space-weather-dashboard-in-dash-66622775e084?source=collection_archive---------16-----------------------#2020-09-22">https://medium.com/analytics-vidhya/space-weather-dashboard-part-2-designing-the-layout-of-a-custom-space-weather-dashboard-in-dash-66622775e084?source=collection_archive---------16-----------------------#2020-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/50df872a433105e515b73d6792bb6bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olRD5GHtC1BEKsN2azJ9Ig.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">SpaceX SAOCOM 1A任务长曝光照片(鸣谢<a class="ae hv" href="https://unsplash.com/photos/6SbFGnQTE8s" rel="noopener ugc nofollow" target="_blank">Unspash.com</a>和SpaceX)</figcaption></figure><div class=""/><p id="bb1d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae hv" rel="noopener" href="/analytics-vidhya/space-weather-dashboard-part-1-making-a-basic-etl-data-pipeline-using-python-sqlite-and-cron-ee590b718f86">的上一篇文章</a>中，我们经历了构建一个快速而肮脏的数据管道的过程，用与空间天气相关的三个信息源(例如，太阳黑子、磁场、等离子体密度/速度/温度)来填充本地数据库。现在我们已经将这些数据提取、转换并加载到我们的数据仓库系统中，我们将在最终产品中使用这些数据:一个交互式仪表板，它具有我们在相对较新的仪表板和数据可视化工具的帮助下设计的自定义布局——由<a class="ae hv" href="https://plotly.com/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>设计的<a class="ae hv" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> Dash </a>。</p><p id="7214" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们深入太空气象仪表盘的细节之前，让我们快速回顾一下Dash到底是什么。维基百科将Dash描述为一个"<a class="ae hv" href="http://open-source Python and R framework for building web-based analytic applications." rel="noopener ugc nofollow" target="_blank">开源Python和R框架，用于构建基于web的分析应用程序。</a>《Dash用户指南》更详细地解释了Dash的实际工作原理:</p><blockquote class="jt ju jv"><p id="6fa0" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">“Dash基于Flask、Plotly.js和React.js编写，非常适合用纯Python构建具有高度自定义用户界面的数据可视化应用程序。它特别适合任何使用Python处理数据的人。</p><p id="1cb5" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">通过几个简单的模式，Dash抽象出了构建基于web的交互式应用程序所需的所有技术和协议。Dash非常简单，您可以在一个下午的时间里围绕您的Python代码绑定一个用户界面。</p><p id="5e53" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">Dash应用程序在web浏览器中呈现。您可以将应用程序部署到服务器，然后通过URL共享它们。由于Dash应用程序是在网络浏览器中查看的，因此Dash本身就具备跨平台和移动性。"</p></blockquote><p id="a9a6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从我使用Dash的经验来看(当然是有限的)，它的一个主要好处是能够以简单和逻辑的方式制作<a class="ae hv" href="https://dash-gallery.plotly.host/Portal/" rel="noopener ugc nofollow" target="_blank">高度精细和可定制的基于web的分析界面</a>，仅使用Python和相关库(不需要学习如何编写React.js代码！).</p><p id="067e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">为空间天气仪表盘设置Python代码</strong></p><p id="54e5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，我们的重点是空间天气分析和预报中最常见的天气因素，包括:</p><ul class=""><li id="8d10" class="ka kb hy ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><a class="ae hv" href="https://en.wikipedia.org/wiki/Sunspot" rel="noopener ugc nofollow" target="_blank">太阳黑子的数量</a>(在任何给定的日历日，#/count)，</li><li id="762a" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><a class="ae hv" href="https://en.wikipedia.org/wiki/Earth%27s_magnetic_field" rel="noopener ugc nofollow" target="_blank">地球磁场</a>(实时，单位特斯拉)，以及</li><li id="285c" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><a class="ae hv" href="https://en.wikipedia.org/wiki/Solar_wind" rel="noopener ugc nofollow" target="_blank">太阳风</a>(实时，包括等离子体密度、速度和温度)</li></ul><p id="6e38" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的SQLite数据库中已经有了这些数据，这很好。因此，让我们从dashboard Python脚本开始，导入相关的Dash和Plotly库:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ad81" class="kx ky hy kt b fi kz la l lb lc">import dash<br/>import dash_core_components as dcc<br/>import dash_html_components as html<br/>from dash.dependencies import Input, Output<br/>import plotly.express as px<br/>import plotly.graph_objs as go</span></pre><p id="959f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们也导入一些其他库来帮助我们处理数据和连接到我们的数据库:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a743" class="kx ky hy kt b fi kz la l lb lc">import pandas as pd<br/>import numpy as np<br/>import sqlite3<br/>import ipdb<br/>from datetime import datetime as dt</span></pre><p id="8938" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Dash构建在Flask库之上，这意味着我们可以为dashboard CSS文件定义外部样式表。然后使用<em class="jw"> external_stylesheets </em>作为输入参数初始化Dash应用程序:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3dc9" class="kx ky hy kt b fi kz la l lb lc">external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']<br/><br/>app = dash.Dash(__name__, external_stylesheets=external_stylesheets)</span></pre><p id="ae47" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并连接到数据库:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ad85" class="kx ky hy kt b fi kz la l lb lc">conn = sqlite3.connect("space.db")<br/>cur = conn.cursor()</span></pre><p id="5cae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">黑子数据/可视化</strong></p><p id="b908" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将首先提取与太阳黑子(每日计数)相关的数据，然后将这些数据加载到一个Plotly图中。太阳黑子数据包含在<em class="jw">太阳黑子</em>表中，因此我们可以通过SQL查询提取自1900年1月1日以来的太阳黑子数，并将结果插入数据帧，如下所示:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4cb9" class="kx ky hy kt b fi kz la l lb lc">cur.execute("SELECT * FROM sunspots WHERE CAST(strftime('%Y', date) AS INTEGER) &gt; 1900")</span><span id="8adb" class="kx ky hy kt b fi ld la l lb lc">sunspots = cur.fetchall()</span><span id="239d" class="kx ky hy kt b fi ld la l lb lc">df_ss = pd.DataFrame(columns = ["Date", "Sunspot_count", "Sunspot_sd", "Observ_No"])<br/><br/>df_ss = df_ss.append([pd.Series(row[1:], index = df_ss.columns) for row in sunspots])</span></pre><p id="62bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了生成我们的时间序列图，我们将使用<em class="jw">plot ly . graph _ objs</em>(as<em class="jw">go</em>)库实例化一个折线图，x轴是黑子日期，y轴是黑子数:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cf95" class="kx ky hy kt b fi kz la l lb lc">fig2 = go.Figure(data=[go.Scatter(x=df_ss.Date, y=df_ss.Sunspot_count)])</span></pre><p id="ed72" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<em class="jw"> fig2.show() </em>我们可以看到我们的太阳黑子图是什么样子:</p><figure class="ko kp kq kr fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es le"><img src="../Images/96cfe9170eede9d9c89d26f0c5d9c121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2g_xPDkNX1MiMv0EqYsHiA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">自1900年以来的太阳黑子计数数据(<a class="ae hv" href="https://en.wikipedia.org/wiki/Solar_cycle" rel="noopener ugc nofollow" target="_blank"> 11年太阳黑子周期</a>清晰可见)</figcaption></figure><p id="d32c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">太阳风数据/可视化</strong></p><p id="8094" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们对存储在<em class="jw"> mag </em>表中的太阳风数据重复上述过程。</p><p id="091b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们提取数据，然后加载到数据帧中:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="238a" class="kx ky hy kt b fi kz la l lb lc">cur.execute("SELECT * FROM mag")<br/><br/>mag = cur.fetchall()</span><span id="c999" class="kx ky hy kt b fi ld la l lb lc">df_mg = pd.DataFrame(columns = ["Datetime", "Bx", "By", "Bz", "Bt"])</span><span id="1ea4" class="kx ky hy kt b fi ld la l lb lc">df_mg = df_mg.append([pd.Series(row[1:], index = df_mg.columns) for row in mag])</span></pre><p id="f3cb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们实例化我们的<em class="jw"> Figure() </em>对象，并添加对应于太阳风Bx、By、Bz和Bt向量的多个轨迹:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="764b" class="kx ky hy kt b fi kz la l lb lc">fig1.add_trace(<br/>    go.Scatter(<br/>        x=df_mg.Datetime,<br/>        y=df_mg.Bx,<br/>        name="Bx"<br/>    ))<br/> <br/>fig1.add_trace(<br/>    go.Scatter(<br/>        x=df_mg.Datetime,<br/>        y=df_mg.By,<br/>        name="By"<br/>    ))<br/><br/>fig1.add_trace(<br/>    go.Scatter(<br/>        x=df_mg.Datetime,<br/>        y=df_mg.Bz,<br/>        name="Bz"<br/>    ))<br/><br/>fig1.add_trace(<br/>    go.Scatter(<br/>        x=df_mg.Datetime,<br/>        y=df_mg.Bt,<br/>        name="Bt"<br/>    ))</span></pre><p id="2621" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也需要对我们的太阳风密度、速度和温度做同样的事情:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="dd03" class="kx ky hy kt b fi kz la l lb lc">cur.execute("SELECT * FROM plasma")</span><span id="4da6" class="kx ky hy kt b fi ld la l lb lc">df_pl = pd.DataFrame(columns = ["Datetime", "density", "speed", "temp"])</span><span id="2b26" class="kx ky hy kt b fi ld la l lb lc">plasma = cur.fetchall()<br/><br/>df_pl = df_pl.append([pd.Series(row[1:], index = df_pl.columns) for row in plasma])<br/><br/>fig = go.Figure()<br/><br/>fig.add_trace(go.Scatter(<br/>    x=df_pl.Datetime,<br/>    y=df_pl.density,<br/>    name="D"<br/>))<br/><br/>fig.add_trace(go.Scatter(<br/>    x=df_pl.Datetime,<br/>    y=df_pl.speed,<br/>    name="S",<br/>    yaxis="y2"<br/>))<br/><br/>fig.add_trace(go.Scatter(<br/>    x=df_pl.Datetime,<br/>    y=df_pl.temp,<br/>    name="T",<br/>    yaxis="y3"<br/>))</span></pre><p id="983e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<em class="jw"> update_layout() </em>方法，我们可以更新图表的布局，以包含我们用于同一图表的3个不同y轴刻度的刻度线:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3040" class="kx ky hy kt b fi kz la l lb lc">fig.update_layout(<br/>    yaxis=dict(<br/>        tickfont=dict(<br/>            color="#1f77b4"<br/>        ),<br/>        side="left"<br/>    ),<br/>    yaxis2=dict(<br/>        tickfont=dict(<br/>            color="#ff7f0e"<br/>        ),<br/>        anchor="free",<br/>        overlaying="y",<br/>        side="left",<br/>        position=0.3<br/>    ),<br/>    yaxis3=dict(<br/>        tickfont=dict(<br/>            color="#d62728"<br/>        ),<br/>        anchor="x",<br/>        overlaying="y",<br/>        side="right"<br/>    )<br/>)</span></pre><p id="4aba" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出产品:</p><figure class="ko kp kq kr fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lf"><img src="../Images/6af752c8fe8cdfa8e8c117cb3a2c3cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQizcyX3vJ-4nyqCG8d-HQ.png"/></div></div></figure><p id="5782" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">地磁数据/可视化</strong></p><p id="241a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们最后添加到仪表板上的图表是一张地图，显示了分布在世界各地的各个记录站的本地磁场强度(数据由Intermagnet提供)。鉴于我们的最后两个图形是相当简单的折线图，显示这些地磁数据将需要使用Dash/Plotly工具箱中的不同工具:<a class="ae hv" href="https://plotly.com/python/scattermapbox/" rel="noopener ugc nofollow" target="_blank"><em class="jw">【scatter _ mapbox()</em></a>。</p><p id="cf58" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，<em class="jw"> scatter_mapbox() </em>接受几个参数，包括我们感兴趣绘制的数据帧对象、所述数据帧的纬度和经度列、缩放的颜色等。</p><p id="248e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在我们开始绘制数据之前，我们需要进行所有常规的数据提取，为我们绘制的图形准备数据:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="68dd" class="kx ky hy kt b fi kz la l lb lc">cur.execute("SELECT station, strftime('%H',date_time) AS hour, avg(lat), avg(long), max(bf)-min(bf) AS bf_range FROM geo_mag WHERE bf != 99999 AND bf != 88888 GROUP BY station, hour")</span><span id="9176" class="kx ky hy kt b fi ld la l lb lc">geo_mag = cur.fetchall()</span><span id="72c6" class="kx ky hy kt b fi ld la l lb lc">df_gm = pd.DataFrame(columns = ["Station","Time", "Lat", "Long", "Bf"])<br/><br/>df_gm = df_gm.append([pd.Series(row, index = df_gm.columns) for row in geo_mag])<br/><br/>df_gm['Log_Bf'] = np.log(df_gm['Bf'])</span></pre><p id="22ac" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的查询比上面的查询稍微复杂一些，因为我们感兴趣的是磁场的小时偏差(参见<a class="ae hv" href="https://www.intermagnet.org/activitymap/activitymap-val-eng.php?year=2020&amp;month=09&amp;day=13&amp;component=f" rel="noopener ugc nofollow" target="_blank"> Intermagnet的表格数据</a>，其中提到了“小时范围”)。这就是为什么我们需要取磁场的最大值和最小值之间的差，按站和小时分组(为了一致性，离群值也被去除)。</p><p id="702e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还计算了一个导出列，即总磁场的对数(<em class="jw"> Log_Bf </em>)以便在我们的地图绘图中进行颜色缩放。</p><p id="0bcd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们的地磁数据存储在一个数据帧中，我们可以实例化我们的地图对象，使用<em class="jw"> Log_Bf </em>作为我们的色标参数:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b515" class="kx ky hy kt b fi kz la l lb lc">fig3 = px.scatter_mapbox(df_gm, lat="Lat", lon="Long", hover_name="Station", hover_data=["Time","Bf"], color="Log_Bf", color_continuous_scale=px.colors.sequential.Viridis, zoom = 0.65, center=dict(lat=17.41, lon=9.33), height=780)</span><span id="5089" class="kx ky hy kt b fi ld la l lb lc">fig3.update_layout(mapbox_style="open-street-map")</span></pre><p id="ccec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果如下:</p><figure class="ko kp kq kr fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/2df13a9cdfbc86a915740197756539f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfqalgHeM6fmSTS_n7SarQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">根据<a class="ae hv" href="https://www.intermagnet.org/activitymap/activitymap-val-eng.php?year=2020&amp;month=09&amp;day=13&amp;component=f" rel="noopener ugc nofollow" target="_blank"> Intermagnet的表格数据</a>检查/验证数据</figcaption></figure><p id="7cd9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">汇总所有信息:仪表板布局</strong></p><p id="ea20" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了我们新生成的图形，我们可以开始构建我们的<a class="ae hv" href="https://dash.plotly.com/layout" rel="noopener ugc nofollow" target="_blank">布局</a>的过程。我们将使用<em class="jw"> app.layout </em>来分配我们的布局，这将在我们代码末尾的<em class="jw"> app.run_server() </em>行中使用:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4371" class="kx ky hy kt b fi kz la l lb lc">app.layout = html.Div([<br/>    html.Div([html.H3(children='Space Weather Dashboard')], id="title"),<br/>    <br/>    html.Div([<br/>        html.Div([<br/>            html.H6('Sunspot Count'),<br/>            dcc.Graph(id='sunspots', figure=fig2),<br/>        ], className="row pretty_container"),<br/>                    <br/>        html.Div([     <br/>            html.H6('Solar Wind Magnetic Field and Plasma'),<br/>            dcc.Graph(id='mag', figure=fig1),<br/>            dcc.Graph(id='plasma', figure=fig4)<br/>        ], className="row pretty_container"),<br/>    ], className="six columns"),<br/>    <br/>    html.Div([<br/>        html.H6('Earth Magnetic Field Map'),<br/>        dcc.Graph(id='geo_mag_map', figure=fig3)   <br/>    ], className="six columns pretty_container")<br/>])</span></pre><p id="5fc4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在dash中配置布局的一个好处是能够使用<em class="jw"> dash_core_components </em>和<em class="jw"> dash_html_components </em>，它们作为模块化的构建模块，可以用来构建最终的Dash应用。例如，Dash <em class="jw"> html </em>库可以用来在html中生成header ( <em class="jw"> H1，H2… </em>)或<em class="jw"> div </em>标签，或者通过简单地将一个figure对象传递到<em class="jw"> dcc中来呈现绘图和图形。</em>图()。然后可以在CSS中配置布局的美感(内联、本地或外部)。</p><p id="4b8c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">配置仪表板回调</strong></p><p id="998a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们对仪表板进行最后的润色之前，让我们首先为Dash应用程序添加一点交互性。<a class="ae hv" href="https://dash.plotly.com/basic-callbacks" rel="noopener ugc nofollow" target="_blank"> Dash回调文档</a>将<em class="jw">回调函数</em>描述为“每当输入组件的属性改变时，Dash自动调用的Python函数”</p><p id="0a4d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我们将在地图框图中添加一个时间滑块来显示时间维度(例如，地磁场随时间的变化)。可以通过添加一个<em class="jw"> dcc将时间滑块添加到我们的布局中。Slider() </em>对象紧跟在<em class="jw"> html之后。H6(《地球磁场图》)，</em>:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7cf0" class="kx ky hy kt b fi kz la l lb lc">dcc.Slider(<br/>            id='time-slider',<br/>            min=0,<br/>            max=len(df_gm.Time.unique())-1,<br/>            value=0,<br/>            marks={int(i):(str(j)+":00") for i,j in zip(range(len(df_gm.Time.unique())), df_gm.Time.unique())}<br/>        ),</span></pre><p id="232d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我们以小时为单位显示时间滑块的刻度。</p><p id="0551" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于实际的交互方面，我们需要创建一个Dash回调函数。在我们的例子中，我们希望应用程序的功能是这样的，当用户调整滑块时，地图更新/刷新所有显示的数据。这可以使用下面的自定义回调函数来实现:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d8bb" class="kx ky hy kt b fi kz la l lb lc">@app.callback(<br/>    Output('geo_mag_map', 'figure'),<br/>    [Input('time-slider', 'value')])<br/>def update_figure(selected_time):<br/>       <br/>    actual_selected_time={int(i):str(j) for i,j in zip(range(len(df_gm.Time.unique())), df_gm.Time.unique())}[selected_time]<br/>     <br/>    filtered_df = df_gm[df_gm.Time == actual_selected_time]<br/> <br/>    fig_new = px.scatter_mapbox(filtered_df, lat="Lat", lon="Long", hover_name="Station", hover_data=["Time","Bf"], color="Log_Bf", <br/>                      color_continuous_scale=px.colors.sequential.Viridis, zoom = 0.65, center=dict(lat=17.41, lon=9.33), height=780)</span><span id="3fbf" class="kx ky hy kt b fi ld la l lb lc">    fig_new.update_layout(mapbox_style="open-street-map")<br/>    fig_new.update_layout(margin={"r":0,"t":0,"l":0,"b":0})<br/> <br/>    return fig_new</span></pre><p id="1eed" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，上面的许多代码都是从最初创建的<em class="jw">图3 </em>(在我们的代码的前面)中复制的，稍微增加了一点，我们使用我们的filtered dataframe，<em class="jw"> filtered_df </em>(通过我们在滑块中的选择进行筛选)，作为输入到我们的<em class="jw"> mapbox </em>对象中的dataframe。</p><p id="176a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，让我们为太阳黑子时间序列图添加一个范围选择器(6个月，1/5/10/20/50年，全部):</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cdc3" class="kx ky hy kt b fi kz la l lb lc">fig2.update_layout(<br/>    xaxis=dict(<br/>        rangeselector=dict(<br/>            buttons=list([<br/>                dict(count=6,<br/>                     label="6m",<br/>                     step="month",<br/>                     stepmode="backward"),<br/>                dict(count=1,<br/>                     label="1y",<br/>                     step="year",<br/>                     stepmode="backward"),<br/>                dict(count=5,<br/>                     label="5y",<br/>                     step="year",<br/>                     stepmode="backward"),<br/>                dict(count=10,<br/>                     label="10y",<br/>                     step="year",<br/>                     stepmode="backward"),<br/>                dict(count=20,<br/>                     label="20y",<br/>                     step="year",<br/>                     stepmode="backward"),<br/>                dict(count=50,<br/>                     label="50y",<br/>                     step="year",<br/>                     stepmode="backward"),<br/>                dict(step="all")<br/>            ])<br/>        ),<br/>        rangeslider=dict(<br/>            visible=True<br/>        ),<br/>        type="date"<br/>    )<br/>)</span></pre><p id="a239" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">最终仪表板布局</strong></p><p id="f950" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在对我们的图形布局进行了一些小的更新以调整边距、高度/宽度等之后。(使用以下代码):</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6b3b" class="kx ky hy kt b fi kz la l lb lc">fig1.update_layout(<br/>    height=200,<br/>    margin=dict(t=10, b=10, l=20, r=20)<br/>)</span><span id="e36f" class="kx ky hy kt b fi ld la l lb lc">fig2.update_layout(<br/>    height=380,<br/>    margin=dict(t=20, b=20, l=20, r=20)<br/>)<br/><br/>fig2.update_layout(<br/>    yaxis=dict(<br/>        title="# of Sunspots (raw count)",<br/>        side="right"<br/>    )<br/>)</span><span id="3bcb" class="kx ky hy kt b fi ld la l lb lc">fig3.update_layout(margin=dict(t=20, b=20, l=20, r=20))</span><span id="4fb7" class="kx ky hy kt b fi ld la l lb lc">fig4.update_layout(<br/>#     title_text="multiple y-axes example",<br/>    height=200,<br/>    margin=dict(t=10, b=10, l=20, r=20)<br/>)</span></pre><p id="5c00" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并将另一个<a class="ae hv" href="https://dash-gallery.plotly.host/dash-oil-and-gas/" rel="noopener ugc nofollow" target="_blank"> Dash app </a>中的<em class="jw"> style.css </em>文件添加到我们的<em class="jw"> /assets </em>目录中，我们得到最终产品:</p><figure class="ko kp kq kr fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/98e88305c1fb490de2d06bc12f674e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IE97gTrgC8528RDJZScM-Q.png"/></div></div></figure><p id="3450" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看起来相当光滑！不是吗？我发现非常有趣的一件事是，根据左上角的图表，我们正处于11年太阳黑子周期的平静期。事实上，根据科学家的说法，<a class="ae hv" href="https://scitechdaily.com/solar-cycle-25-has-begun-experts-from-nasa-and-noaa-explain-what-it-means/" rel="noopener ugc nofollow" target="_blank">2019年12月</a>第24太阳周期结束，第25太阳周期开始。虽然设置我们的仪表板可能需要一点时间，但是一旦基本的框架(如上)组装好了，对您的基本仪表板布局进行一些整洁的添加/定制就相对容易了。</p><p id="0e7f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">改进我们的空间天气仪表板的一些可能的想法:</p><ul class=""><li id="b616" class="ka kb hy ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">将条形图添加到地图底部(右侧)以通过单击进行筛选；添加回调函数将地图链接到底部条形图(类似于图间地图图<a class="ae hv" href="https://www.intermagnet.org/activitymap/activitymap-eng.php" rel="noopener ugc nofollow" target="_blank">这里的</a>)。</li><li id="af78" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">改变滑块，使其包含一个“播放”按钮，用于显示地图随时间的变化。</li><li id="505e" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">对太阳黑子数据进行预测建模(例如，叠加拟合曲线)</li><li id="260e" class="ka kb hy ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">将<a class="ae hv" href="https://services.swpc.noaa.gov/json/goes/primary/xrays-7-day.json" rel="noopener ugc nofollow" target="_blank"> x射线数据</a>与<a class="ae hv" href="https://services.swpc.noaa.gov/json/goes/primary/xray-flares-7-day.json" rel="noopener ugc nofollow" target="_blank"> x射线耀斑数据</a>(来自NOAA)叠加，以查看两者之间的相关性。</li></ul><figure class="ko kp kq kr fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es li"><img src="../Images/b205bfa5f8735464c6b145c25cd0de82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kWkr-6aaXY-x-15b42OUA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">活跃的太阳与安静的太阳(鸣谢:NASA/SDO)</figcaption></figure><p id="01fe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Dash的定制选项几乎是无穷无尽的。因此，只要您有一点时间来学习一种新的、有用的基于Python的工具，请查看<a class="ae hv" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> Dash </a>以满足您的报告、商业智能和数据可视化需求！</p><p id="56f3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Github上的代码:<a class="ae hv" href="https://github.com/vincent86-git/Space_Weather_Dash" rel="noopener ugc nofollow" target="_blank">https://github.com/vincent86-git/Space_Weather_Dash</a></p><p id="7d53" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">本文介绍的结果依赖于在地磁观测站收集的数据。我们感谢支持他们的国家机构和INTERMAGNET促进高标准的磁观测实践(www.intermagnet.org)。</em></p></div></div>    
</body>
</html>