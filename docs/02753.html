<html>
<head>
<title>Dart Programming : Part-4 : Functions &amp; Collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart编程:第4部分:函数和集合</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dart-programming-part-4-functions-collection-cc621a704a9a?source=collection_archive---------15-----------------------#2019-12-31">https://medium.com/analytics-vidhya/dart-programming-part-4-functions-collection-cc621a704a9a?source=collection_archive---------15-----------------------#2019-12-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/798d982c2e08c06f4a9c9b772d5471c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*Teg4RBmlErVdNFgPnPJyLg.png"/></div></figure><p id="83eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">函数是可读的、可维护的和可重用的代码的组成部分。函数是执行特定任务的一组语句。函数将程序组织成逻辑代码块。一旦定义好，就可以调用函数来访问代码。这使得代码可重用。此外，函数使得阅读和维护程序代码变得容易。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="8681" class="jt ju hi jp b fi jv jw l jx jy">void main() { <br/>   print(factorial(6));<br/>}  <br/>factorial(number) { <br/>   if (number &lt;= 0) {         <br/>      // termination case <br/>      return 1; <br/>   } else { <br/>      return (number * factorial(number - 1));    <br/>      // function invokes itself <br/>   } <br/>}</span><span id="151a" class="jt ju hi jp b fi jz jw l jx jy">Output :<br/>720</span></pre><blockquote class="ka kb kc"><p id="00aa" class="im in kd io b ip iq ir is it iu iv iw ke iy iz ja kf jc jd je kg jg jh ji jj hb bi translated"><strong class="io hj">λ函数</strong></p></blockquote><p id="b4e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Lambda函数是一种简洁的函数表示机制。这些函数也称为箭头函数。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2ce5" class="jt ju hi jp b fi jv jw l jx jy">oid main() { <br/>   printMsg(); <br/>   print(test()); <br/>}  <br/>printMsg()=&gt;<br/>print("hello"); <br/><br/>int test()=&gt;123;</span><span id="56b1" class="jt ju hi jp b fi jz jw l jx jy">Output :<br/>hello 123</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="dd45" class="ko ju hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">接口</h1><p id="efb0" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">一个<strong class="io hj">接口</strong>定义了任何实体都必须遵守的语法。接口定义了一组在对象上可用的方法。Dart没有用于声明接口的语法。类声明本身就是Dart中的接口。</p><p id="3562" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">类</strong>应该使用implements关键字来使用接口。实现类必须提供实现接口的所有函数的具体实现。换句话说，一个类必须重新定义它希望实现的接口中的每一个函数。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="9e8e" class="jt ju hi jp b fi jv jw l jx jy">void main() { <br/>   ConsolePrinter cp= new ConsolePrinter(); <br/>   cp.print_data(); <br/>}  <br/>class Printer { <br/>   void print_data() { <br/>      print("__________Printing Data__________"); <br/>   } <br/>}  <br/>class ConsolePrinter implements Printer { <br/>   void print_data() {  <br/>      print("__________Printing to Console__________"); <br/>   } <br/>}</span><span id="c579" class="jt ju hi jp b fi jz jw l jx jy">Output :<br/>__________Printing to Console__________</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="95f9" class="ko ju hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">收藏品</h1><blockquote class="ka kb kc"><p id="6007" class="im in kd io b ip iq ir is it iu iv iw ke iy iz ja kf jc jd je kg jg jh ji jj hb bi translated"><strong class="io hj">列表</strong></p></blockquote><p id="60bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">列表只是一组有序的对象。<strong class="io hj"> dart:core </strong>库提供了List类，可以创建和操作列表。</p><ul class=""><li id="3c11" class="lq lr hi io b ip iq it iu ix ls jb lt jf lu jj lv lw lx ly bi translated"><strong class="io hj">固定长度列表</strong>——列表的长度不能在运行时改变。</li><li id="4bbb" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><strong class="io hj">可增长列表</strong>——列表的长度可以在运行时改变。</li></ul><blockquote class="ka kb kc"><p id="1483" class="im in kd io b ip iq ir is it iu iv iw ke iy iz ja kf jc jd je kg jg jh ji jj hb bi translated"><strong class="io hj">设置</strong></p></blockquote><p id="d8ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Set表示对象的集合，其中每个对象只能出现一次。dart:core库提供了实现相同功能的Set类。</p><blockquote class="ka kb kc"><p id="0c07" class="im in kd io b ip iq ir is it iu iv iw ke iy iz ja kf jc jd je kg jg jh ji jj hb bi translated"><strong class="io hj">地图</strong></p></blockquote><p id="2beb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Map对象是一个简单的键/值对。映射中的键和值可以是任何类型。地图是一个动态集合。换句话说，地图可以在运行时增长和收缩。dart:core库中的Map类也提供了同样的支持。</p><blockquote class="ka kb kc"><p id="2cd6" class="im in kd io b ip iq ir is it iu iv iw ke iy iz ja kf jc jd je kg jg jh ji jj hb bi translated"><strong class="io hj">队列</strong></p></blockquote><p id="87ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">队列是可以在两端操作的集合。当您希望构建一个先进先出的集合时，队列非常有用。简单地说，队列从一端插入数据，从另一端删除。按照插入的顺序移除/读取这些值。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="898d" class="ko ju hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">例外</h1><p id="a615" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">try 块嵌入了可能导致异常的代码。当需要指定异常类型时，使用on块。当处理程序需要异常对象时，使用<strong class="io hj"> catch </strong>块。</p><p id="d0c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> try </strong>程序块后必须紧跟一个<strong class="io hj"> on / catch </strong>程序块或一个<strong class="io hj"> finally </strong>程序块(或两者之一)。当try块中出现异常时，控制转移到<strong class="io hj"> catch </strong>。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0bb4" class="jt ju hi jp b fi jv jw l jx jy">main() { <br/>   try { <br/>      test_age(-2); <br/>   } <br/>   catch(e) { <br/>      print('Age cannot be negative'); <br/>   } <br/>}  <br/>void test_age(int age) { <br/>   if(age&lt;0) { <br/>      throw new FormatException(); <br/>   } <br/>}</span><span id="c04f" class="jt ju hi jp b fi jz jw l jx jy">Output :<br/>Age cannot be negative</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="7ee4" class="ko ju hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">你如何能有所贡献？</h1><ul class=""><li id="bd72" class="lq lr hi io b ip ll it lm ix me jb mf jf mg jj lv lw lx ly bi translated">在<a class="ae mh" href="https://twitter.com/jayeshpatel1995" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae mh" href="https://in.linkedin.com/in/jayeshpansheriya" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>或<a class="ae mh" href="https://www.instagram.com/jay_pansheriya" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上与我联系。</li><li id="5547" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated">在<a class="ae mh" href="https://github.com/jayeshpansheriya" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</li></ul><h1 id="d250" class="ko ju hi bd kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg mm li lj lk bi translated">本系列中的帖子</h1><ul class=""><li id="2c65" class="lq lr hi io b ip ll it lm ix me jb mf jf mg jj lv lw lx ly bi translated"><a class="ae mh" href="https://link.medium.com/oxIF3JCgO2" rel="noopener"> Dart编程:Part-1:环境&amp;第一个Dart代码&amp;注释&amp;面向对象编程&amp;变量&amp;最终和常量&amp;决策</a></li><li id="4c0b" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><a class="ae mh" href="https://link.medium.com/nosKDep4P2" rel="noopener">飞镖编程:第二部分:操作员</a></li><li id="9a67" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><a class="ae mh" href="https://link.medium.com/PJMZ55jFR2" rel="noopener"> Dart编程:第三部分:数据类型</a></li><li id="80c4" class="lq lr hi io b ip lz it ma ix mb jb mc jf md jj lv lw lx ly bi translated"><a class="ae mh" href="https://link.medium.com/u74hfhbPR2" rel="noopener">飞镖编程:第四部分:函数&amp;集合</a></li></ul><h1 id="b826" class="ko ju hi bd kp kq mi ks kt ku mj kw kx ky mk la lb lc ml le lf lg mm li lj lk bi translated">表示你的支持</h1><p id="d2a1" class="pw-post-body-paragraph im in hi io b ip ll ir is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj hb bi translated">如果你喜欢阅读这篇文章，请点击下面的按钮。你鼓掌越多，就越能激励我写得更好！</p></div></div>    
</body>
</html>