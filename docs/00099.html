<html>
<head>
<title>A Gentle Introduction to Handling a Non-Stationary Time Series in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python处理非平稳时间序列的简明介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-gentle-introduction-to-handling-a-non-stationary-time-series-in-python-8be1c1d4b402?source=collection_archive---------1-----------------------#2018-09-13">https://medium.com/analytics-vidhya/a-gentle-introduction-to-handling-a-non-stationary-time-series-in-python-8be1c1d4b402?source=collection_archive---------1-----------------------#2018-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="49ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些应用程序有什么共同点:预测一个家庭未来三个月的用电量，估计特定时段的道路交通流量，以及预测纽约证券交易所的股票交易价格？</p><p id="eb46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">都属于时间序列数据的概念！如果没有“时间”这个因素，你就无法准确预测这些结果中的任何一个。随着我们周围的世界产生越来越多的数据，时间序列预测不断成为数据科学家掌握的越来越重要的技术。</p><p id="8c38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是时间序列是一个复杂的话题，同时涉及多个方面。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cbbd2c74038102ca4573e1bf6a4d33b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*flEjunhLd_5uQoHm.jpg"/></div></figure><p id="9957" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，如果我们想让预测模型很好地工作，使时间序列平稳是至关重要的。为什么？因为你收集的大部分数据都会有非平稳趋势。如果尖峰是不稳定的，你怎么能确定模型会正常工作呢？</p><p id="3f6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文的重点是检查时间序列数据平稳性的方法。本文假设读者熟悉时间序列、ARIMA和平稳性的概念。下面是一些复习基础知识的参考资料:</p><ul class=""><li id="fed1" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><a class="ae ju" href="https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/" rel="noopener ugc nofollow" target="_blank">时间序列建模完整教程</a></li><li id="3d02" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><a class="ae ju" href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="noopener ugc nofollow" target="_blank">综合初学者指南创建时间序列预测</a></li></ul><h1 id="4367" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目录</h1><ol class=""><li id="2474" class="jl jm hi ih b ii ky im kz iq la iu lb iy lc jc ld jr js jt bi translated">平稳性简介</li><li id="91a7" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc ld jr js jt bi translated">加载数据</li><li id="0830" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc ld jr js jt bi translated">检查平稳性的方法<br/> 3.1 ADF测试<br/> 3.2 KPSS测试</li><li id="70c2" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc ld jr js jt bi translated">平稳性的类型<br/> 4.1严格平稳<br/> 4.2差分平稳<br/> 4.3趋势平稳</li><li id="1c89" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc ld jr js jt bi translated">使时间序列平稳<br/> 5.1差分<br/> 5.2季节差分<br/> 5.3对数变换</li></ol><h1 id="d074" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.平稳性介绍</h1><p id="13ef" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">“平稳性”是你在处理时间序列数据时会遇到的最重要的概念之一。<strong class="ih hj">平稳序列是指其属性(均值、方差和协方差)不随时间变化的序列。</strong></p><p id="0afc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用一个直观的例子来理解这一点。考虑下面显示的三幅图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/c137ab1d9548ad17a8e370b598fceabb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fef4DDos435uz3Z3.png"/></div></div></figure><ul class=""><li id="f3ee" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">在第一幅图中，我们可以清楚地看到平均值随时间变化(增加),这导致了上升趋势。因此，这是一个非平稳序列。<strong class="ih hj">对于要归类为平稳的系列，它不应显示趋势。</strong></li><li id="97b4" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">转到第二个图，我们当然看不到序列中的趋势，但是序列的方差是时间的函数。如前所述，平稳序列必须有一个恒定的方差。</li><li id="c5c5" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated">如果看第三个图，随着时间的增加，分布变得更接近，这意味着协方差是时间的函数。</li></ul><p id="c32e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面显示的三个例子代表非平稳时间序列。现在来看第四个情节:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lm"><img src="../Images/8772fb991ece7ef598a48701fca52444.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*TRSJBwljEJdeO3Q-.png"/></div></figure><p id="ae61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，均值、方差和协方差随时间保持不变。这就是平稳时间序列的样子。</p><p id="c13b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想一想这个问题——使用上面哪个图预测未来值更容易？第四个情节吧？大多数统计模型要求序列是平稳的，以便进行有效和精确的预测。</p><p id="32b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，平稳时间序列是指其性质(即均值、方差和协方差)不依赖于时间的序列。在下一节中，我们将介绍检查给定序列是否平稳的各种方法。</p><h1 id="6b01" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.加载数据</h1><p id="c86d" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在本节和接下来的几节中，我将介绍检查时间序列数据平稳性的方法，以及处理任何非平稳序列所需的技术。我还提供了应用每种技术的python代码。<strong class="ih hj">你可以从这个链接下载我们将要使用的数据集:</strong> <a class="ae ju" href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2018/09/AirPassengers.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">航空乘客</strong> </a> <strong class="ih hj">。</strong></p><p id="d16b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们继续分析数据集之前，让我们先加载和预处理数据。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="ca43" class="ls kb hi lo b fi lt lu l lv lw">#loading important libraries<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/><br/>#reading the dataset<br/>train = pd.read_csv('AirPassengers.csv')<br/><br/>#preprocessing<br/>train.timestamp = pd.to_datetime(train.Month , format = '%Y-%m')<br/>train.index = train.timestamp<br/>train.drop('Month',axis = 1, inplace = True)<br/><br/>#looking at the first few rows<br/>#train.head()</span><span id="4039" class="ls kb hi lo b fi lx lu l lv lw">#Passengers  Month <br/>1949–01–01    112 <br/>1949–02–01    118 <br/>1949–03–01    132 <br/>1949–04–01    129 <br/>1949–05–01    121</span></pre><p id="2d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来我们准备好了！</p><h1 id="d531" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.检验平稳性的方法</h1><p id="123f" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">下一步是确定一个给定的序列是否是平稳的，并相应地处理它。本节将介绍一些我们可以用来执行这种检查的常用方法。</p><h1 id="6652" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">目视检查</h1><p id="7f20" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">考虑我们在上一节中使用的图。我们能够识别出均值和方差随时间变化的序列，只需查看每个图。类似地，我们可以绘制数据并确定序列的属性是否随时间变化。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="fc93" class="ls kb hi lo b fi lt lu l lv lw">train['#Passengers'].plot()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ly"><img src="../Images/06826e7ad21e87519f96ec9a18093a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dEWagOd5h06iLIGO.png"/></div></div></figure><p id="b92e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管很明显我们在上面的系列中有一个趋势(变化的平均值),这种可视化的方法可能并不总是给出准确的结果。最好使用一些统计测试来确认观察结果。</p><h1 id="c4d8" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">统计检验</h1><p id="96f8" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">除了视觉测试，我们可以使用统计测试，比如单位根平稳测试。单位根表示给定序列的统计性质不随时间恒定，这是平稳时间序列的条件。下面是相同的数学解释:</p><p id="79dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个时间序列:</p><p id="6bd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y(t) = a*y(t-1) + ε( t)</p><p id="9dfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中y(t)是t时刻的值，ε(t)是误差项。为了计算y(t ),我们需要y(t-1)的值，即:</p><p id="99c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y(t-1) = a*y(t-2) + ε (t-1)</p><p id="0e3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们对所有观测值都这样做，yt的值将会是:</p><p id="52d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y(t)= a^n*y(t-n)+σε(t-i)*a^i</p><p id="27f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果上式中a的值为1(单位)，那么预测值将等于y(t-n)和从t-n到t的所有误差之和，这意味着方差将随时间增加。这就是时间序列中的单位根。我们知道，对于一个平稳的时间序列，方差一定不是时间的函数。单位根测试通过检查a值是否=1来检查数列中单位根的存在。下面是两个最常用的单位根平稳测试:</p><h2 id="6bab" class="ls kb hi bd kc lz ma mb kg mc md me kk iq mf mg ko iu mh mi ks iy mj mk kw ml bi translated">ADF试验</h2><p id="9714" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">迪基富勒测试是最流行的统计测试之一。它可以用来确定数列中单位根的存在，从而帮助我们理解数列是否平稳。该检验的无效假设和替代假设是:</p><p id="58c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">零假设</strong>:数列有单位根(a =1)</p><p id="d265" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">交替假设</strong>:数列没有单位根。</p><p id="cc1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们不能拒绝零假设，我们可以说这个序列是非平稳的。这意味着序列可以是线性的或差分平稳的(我们将在下一节了解更多关于差分平稳的内容)。</p><p id="9ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Python代码:</strong></p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="46a5" class="ls kb hi lo b fi lt lu l lv lw">#define function for ADF test<br/>from statsmodels.tsa.stattools import adfuller<br/>def adf_test(timeseries):<br/>    #Perform Dickey-Fuller test:<br/>    print ('Results of Dickey-Fuller Test:')<br/>    dftest = adfuller(timeseries, autolag='AIC')<br/>    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])<br/>    for key,value in dftest[4].items():<br/>       dfoutput['Critical Value (%s)'%key] = value<br/>    print (dfoutput)<br/><br/>#apply adf test on the series<br/>adf_test(train['#Passengers'])</span></pre><p id="27cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">ADF测试结果:</strong>ADF测试给出了以下结果——测试统计量、p值以及1%、5%和10%置信区间的临界值。我们对这一特定系列的测试结果如下:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="7767" class="ls kb hi lo b fi lt lu l lv lw">Results of Dickey-Fuller Test:<br/>Test Statistic                   0.815369<br/>p-value                          0.991880<br/>#Lags Used                      13.000000<br/>Number of Observations Used    130.000000<br/>Critical Value (1%)             -3.481682<br/>Critical Value (5%)             -2.884042<br/>Critical Value (10%)            -2.578770<br/>dtype: float64</span></pre><p id="9410" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">平稳性检验</strong>:如果检验统计量小于临界值，我们可以拒绝零假设(也就是序列是平稳的)。当检验统计量大于临界值时，我们无法拒绝零假设(这意味着序列不是平稳的)。</p><p id="42b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，检验统计量&gt;临界值，这意味着序列不是平稳的。这证实了我们最初在视觉测试中看到的原始观察。</p><h2 id="92e2" class="ls kb hi bd kc lz ma mb kg mc md me kk iq mf mg ko iu mh mi ks iy mj mk kw ml bi translated">2 .KPSS(科维亚特科夫斯基-菲利普-施密特-申)试验</h2><p id="a8ab" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">KPSS是另一种检验时间序列平稳性的测试(比迪基·富勒测试稍逊一筹)。KPSS检验的无效假设和替代假设与ADF检验的相反，这经常造成混淆。</p><p id="b3ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">KPSS测试的作者定义了零假设，因为过程是趋势平稳的，到一个单位根序列的替代假设。我们将在下一节详细了解<em class="mm">趋势平稳性</em>。现在，让我们把重点放在实现上，看看KPSS测试的结果。</p><p id="b565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">零假设:</strong>过程是趋势平稳的。</p><p id="7a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">交替假设:</strong>数列有单位根(数列不是平稳的)。</p><p id="5b80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Python代码:</strong></p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="fcd3" class="ls kb hi lo b fi lt lu l lv lw">#define function for kpss test<br/>from statsmodels.tsa.stattools import kpss<br/>#define KPSS<br/>def kpss_test(timeseries):<br/>    print ('Results of KPSS Test:')<br/>    kpsstest = kpss(timeseries, regression='c')<br/>    kpss_output = pd.Series(kpsstest[0:3], index=['Test Statistic','p-value','Lags Used'])<br/>    for key,value in kpsstest[3].items():<br/>    kpss_output['Critical Value (%s)'%key] = value<br/>print (kpss_output)</span></pre><p id="add7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">KPSS检验结果</strong>:以下是KPSS检验的结果——检验统计量、p值、1%、2.5%、5%、10%置信区间的临界值。对于航空乘客数据集，以下是结果:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="cd79" class="ls kb hi lo b fi lt lu l lv lw">Results of KPSS Test:<br/>Test Statistic            1.052175<br/>p-value                   0.010000<br/>Lags Used                14.000000<br/>Critical Value (10%)      0.347000<br/>Critical Value (5%)       0.463000<br/>Critical Value (2.5%)     0.574000<br/>Critical Value (1%)       0.739000<br/>dtype: float64</span></pre><p id="0384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">平稳性检验</strong>:如果检验统计量大于临界值，我们拒绝零假设(序列不是平稳的)。如果检验统计量小于临界值，如果不能拒绝零假设(序列是平稳的)。对于航空旅客数据，检验统计量的值在所有置信区间都大于临界值，因此我们可以说该序列不是平稳的。</p><p id="7519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在为我的时间序列数据准备模型之前，我通常会执行这两种统计测试。有一次，两次测试显示出相互矛盾的结果。其中一个测试显示该系列是稳定的，而另一个测试显示该系列不是！我在这一部分被困了几个小时，试图弄明白这怎么可能。事实证明，平稳性的类型不止一种。</p><p id="32ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，总而言之，ADF检验有一个线性或差异平稳的替代假设，而KPSS检验确定一个序列的趋势平稳性。</p><h1 id="c1db" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.平稳性的类型</h1><p id="19df" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">让我们了解不同类型的平稳性以及如何解释上述测试的结果。</p><ul class=""><li id="0ab4" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj">严格平稳</strong>:严格平稳序列满足平稳过程的数学定义。对于严格平稳序列，均值、方差和协方差都不是时间的函数。目的是将一个非平稳序列转换成一个严格的平稳序列来进行预测。</li><li id="cce5" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><strong class="ih hj">趋势平稳</strong>:没有单位根但呈现趋势的序列称为趋势平稳序列。一旦趋势被去除，产生的序列将是严格平稳的。KPSS检验将没有单位根的序列归类为平稳序列。这意味着序列可以是严格平稳的或趋势平稳的。</li><li id="79b2" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><strong class="ih hj">差分平稳</strong>:可以通过差分使之严格平稳的时间序列属于差分平稳。ADF检验也称为差异平稳性检验。</li></ul><p id="5d26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好同时应用这两个检验，这样我们就能确定这个序列是真正平稳的。让我们看看应用这些静态测试的可能结果。</p><ul class=""><li id="223b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj">情况1 </strong>:两个测试的结论都是序列不平稳- &gt;序列不平稳</li><li id="50a8" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><strong class="ih hj">情况2 </strong>:两个测试的结论都是序列是平稳的- &gt;序列是平稳的</li><li id="0b8a" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><strong class="ih hj">情况3 </strong> : KPSS =平稳，ADF =不平稳- &gt;趋势平稳，去除趋势使序列严格平稳</li><li id="2591" class="jl jm hi ih b ii jv im jw iq jx iu jy iy jz jc jq jr js jt bi translated"><strong class="ih hj">情况4 </strong> : KPSS =不平稳，ADF =平稳- &gt;差分平稳，使用差分使序列平稳</li></ul><h1 id="85a8" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">4.使时间序列平稳</h1><p id="ea1b" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">既然我们已经熟悉了平稳性的概念及其不同的类型，我们终于可以继续实际上使我们的系列平稳。请记住，为了使用时间序列预测模型，必须先将任何非平稳序列转换为平稳序列。</p><h1 id="4ba5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">区别</h1><p id="dfde" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在这种方法中，我们计算序列中连续项的差。通常执行差分来消除变化的平均值。数学上，差异可以写成:</p><p id="2836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y(t)'= y(t) — y(t-1)</p><p id="d6ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mm">其中y(t)是时间t </em>的值</p><p id="8b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我们的系列应用差分并绘制结果:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="c797" class="ls kb hi lo b fi lt lu l lv lw">train['#Passengers_diff'] = train['#Passengers'] - train['#Passengers'].shift(1) train['#Passengers_diff'].dropna().plot()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mn"><img src="../Images/5dfe123c8d3d09e311d91c8d65060b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IdjBJ_vLqbDLKx95.png"/></div></div></figure><h1 id="5ef1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">季节性差异</h1><p id="76eb" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在季节差异中，我们不是计算连续值之间的差异，而是计算同一季节的一个观测值与前一个观测值之间的差异。例如，在星期一进行的观察将从上一个星期一进行的观察中减去。数学上可以写成:</p><p id="f63f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y(t)'= yt — y(t-n)</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="5726" class="ls kb hi lo b fi lt lu l lv lw">n=7 train['#Passengers_diff'] = train['#Passengers'] - train['#Passengers'].shift(n)</span></pre><h1 id="c31c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">转换</h1><p id="c359" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">变换用于稳定序列的非恒定方差。常见的变换方法包括幂变换、平方根和对数变换。让我们对我们的航空乘客数据集进行快速对数转换和差分:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="6a86" class="ls kb hi lo b fi lt lu l lv lw">train['#Passengers_log'] = np.log(train['#Passengers'])<br/>train['#Passengers_log_diff'] = train['#Passengers_log'] - train['#Passengers_log'].shift(1)<br/>train['#Passengers_log'] = np.sqrt(train['#Passengers'].dropna())</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mo"><img src="../Images/b081c541c5f4c5383ef00d93347f92e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kyvn2iZqzxxdPcdW.png"/></div></div></figure><p id="1b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，这个图比之前的图有了很大的改进。你可以在级数上使用平方根或幂变换，看看他们是否能得出更好的结果。欢迎在下面的评论区分享你的发现！</p><h1 id="042e" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结束注释</h1><p id="80e5" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在本文中，我们介绍了不同的方法，可以用来检查时间序列的平稳性。但是责任并不止于此。下一步是对我们获得的序列应用预测模型。可以参考下面这篇文章来建立这样一个模型:<a class="ae ju" href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="noopener ugc nofollow" target="_blank">时间序列预测初学者指南</a>。</p><p id="bc5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您对本文有任何问题或反馈，可以在下面的评论部分与我联系。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="a2e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mm">原载于2018年9月13日</em><a class="ae ju" href="https://www.analyticsvidhya.com/blog/2018/09/non-stationary-time-series-python/" rel="noopener ugc nofollow" target="_blank"><em class="mm">www.analyticsvidhya.com</em></a><em class="mm">。</em></p></div></div>    
</body>
</html>