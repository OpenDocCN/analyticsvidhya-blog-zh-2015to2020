<html>
<head>
<title>Adaptive machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自适应机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/adaptive-machine-learning-f4fba2f50bc1?source=collection_archive---------8-----------------------#2020-05-17">https://medium.com/analytics-vidhya/adaptive-machine-learning-f4fba2f50bc1?source=collection_archive---------8-----------------------#2020-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同的方法被用于将机器学习模型投入生产。很多时候，模型是在一次性训练后投入生产的(静态模型)。为了使这种模型能够随着时间的推移保持准确的预测，它进行预测的数据必须与模型的定型数据具有相似的分布。然而，分布会随时间漂移。</p><p id="968a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种偏差被称为概念漂移。</p><p id="8805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(“概念漂移”中的一个概念是指输入和输出变量之间未知的、隐藏的关系。概念也称为协变量。)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/31441b3f15064c48b5b890038be5e359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*uK8702aHNSGkEME1W4T_Cw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp"> <em class="jq">图1:概念漂移的类型</em> </strong></figcaption></figure><p id="a366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理概念随时间变化的技术可以大致分为:</p><p id="f8ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.在线/增量技术:</p><p id="71d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一种机器学习类型，在假设初始静态模型后利用动态输入(实时输入，例如传感器数据)。输入被逐一处理。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jr"><img src="../Images/a7a1f79d9dd9eab1119723b55548d732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBUEl1tuM72hijsnXn8tiw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp"> <em class="jq">图2:线上模型流程图</em> </strong></figcaption></figure><p id="5ad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，纯粹的在线技术受到检测到的概念变化可能只是噪声的影响，因此随后的计算也将变得不准确</p><blockquote class="jw jx jy"><p id="97f6" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">模型性能只能在多个输入的范围内测量，其中模型必须多次改变行为</p></blockquote><p id="6c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.基于批次的非平稳技术:</p><p id="d792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于批处理的模型允许训练和测试样本随着时间的推移而累积，以实现持续的模型增强</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kd"><img src="../Images/d6305dea0fd608127b0c7979c5991619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lvDGiFBlaEQ4GwbFkLmYA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp"> <em class="jq">图3:批量非平稳模型流程图</em> </strong></figcaption></figure><p id="89b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所探索的各种基于批次的技术包括</strong>:</p><p id="1438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">观察管理</strong>:描述新的数据点如何被合并以更新现有的模型</p><p id="f775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">适应技术</strong>:强调模型如何从新数据中学习</p><p id="7a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">遗忘机制</strong>:描述不相关的数据点如何随着时间的推移从模型的学习行为模式中消失</p><p id="eaf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于非平稳概念的所有机器学习算法可以基于它们各自的学习技术分类为:</p><p id="7353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">开窗</strong>:想法是让窗口一直增长到没有变化被检测到，当检测到变化时缩小它的尺寸，确保保存在窗口中的观察结果与当前概念相关。窗口不能很好地处理反复出现的概念漂移。</p><p id="fbc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加权</strong>:在训练模型时，加权算法将较高的权重分配给较新的观察值。加权不适用于反复出现的概念漂移。</p><p id="52b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">采样</strong>:采样算法通过将根据给定的概率分布选择的观察值保存到存储器中来总结整个流的特征。这种概率分布可能偏向于最近的观测结果，以便考虑漂移。由于与过去的概念相关的观察所带来的信息可能非常少，因此抽样并不奏效。</p><p id="96f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集成方法</strong>:将一组模型保存在内存中并组合其预测的集成方法。最终的预测可以通过不同的聚合方法得到。当概念不再出现时，这可能被证明是一个无用的策略。</p><p id="6394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jz">下面讨论的是一种算法，它通过结合加权和集成方法进行学习，以在非平稳环境中进行预测。此外，这种算法已经被选中，因为它在理论实践之外也被广泛使用。</em> </strong></p><p id="0b9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Learn++ NSE(针对非平稳概念的Learn++算法)</strong></p><p id="a89c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一种基于集成的非平稳机器学习算法，通过对批量数据进行学习来更新自身。++代表了算法从增量可用批处理数据中学习的能力。这种批量数据将包括标记的数据点以及用于评分的数据点。标记数据集可以进一步分为训练和测试数据集，就像静态ML算法一样。</p><p id="9a02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，假设训练数据集在特定间隔(可能在时间上不一致)可用，并标记为-D1，D2 … Dt，对应于实例1，2…t</p><p id="eb88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个新的数据集都代表了最新概念的快照。自前一数据集以来概念的变化量可能很小/很大，这是通过在最近标记的数据集上的现有集成的性能来跟踪的。</p><p id="a9b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建Learn++ NSE模型集合的步骤可以分解如下:</p><p id="96d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基础模型</strong>:基础模型在第一次投产前，根据历史数据进行一次训练和优化</p><p id="6400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模型集合:</strong>每个可用数据实例训练一个模型。例如:一个模型将在一审时仅在D1上训练，一个模型在二审时仅在D2上训练(t)</p><p id="51f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模型误差更新</strong>:在Dt(最近的训练数据集)上评估模型集合中的每个模型，并为其在实例t的性能分配误差分数基础</p><p id="e95e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总误差分数</strong>:对于实例‘t’处的每个模型，它是其所有过去误差率的加权平均值(较高的权重分配给较新的误差分数)</p><p id="e04e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集合重要性权重</strong>:集合的模型被分配一个与其总错误率成反比的权重(具有较高错误的模型被分配一个较低的权重)</p><p id="b5dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">净集成输出</strong>:净集成输出是由相应的重要性权重加权的每个模型的输出的平均值</p><p id="4c2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集成性能</strong>:在最近的训练数据集Dt上评估模型性能</p><blockquote class="jw jx jy"><p id="7a07" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">数学上，分类学习++ NSE算法如下:</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ke"><img src="../Images/aab828dd1b72bb39e65878bc8c52ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t36_TgR_YTb_fJr8NjKjxw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd jp"> <em class="jq">图4:Learn ++ NSE</em></strong>的伪代码</figcaption></figure><p id="2c0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。</strong> <strong class="ih hj">计算现有集成对最新标注数据的性能:</strong></p><p id="224e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式2:每个标记为数据点的训练被赋予初始值= 1/mt，其中mt是基数Dt。净误差为et</p><p id="e091" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Et:净计算误差是所有误分类的总和乘以1/mt</p><p id="00f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Bt:它是模型集合的归一化误差，如等式2所示。3</p><p id="30c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式4:Dt中的数据点如图所示进行加权</p><p id="b2a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式5:分配的权重然后被归一化以创建Dt的误差分布</p><p id="d3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该误差分布将被用于将误差分配给模型集合中的所有模型。</p><p id="b486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。</strong> <strong class="ih hj"> A仅在Dt上被训练以创建最新的模型来添加到模型集合中。</strong></p><p id="b866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。</strong> <strong class="ih hj">在Dt上计算个别车型的性能:</strong></p><p id="e281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式6:在Dt上计算来自模型集合的每个分类器的误差</p><p id="b7e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。</strong> <strong class="ih hj">错误阈值:</strong></p><p id="7f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最新模型:如果最新模型的计算误差大于阈值，则再次训练模型，直到满足阈值标准</p><p id="53e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他模型:如果计算出的误差大于0.5，则为其分配一个对应于数据集Dt的值0.5，这样，这样的模型在以后的另一次迭代中可能变得不重要(等式1)。6)</p><p id="b69a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算出的误差被归一化，如公式。每个型号7个。</p><p id="03de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。</strong> <strong class="ih hj">计算每个分类器模型对应的时间加权平均值:</strong></p><p id="1ecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式8:使用sigmoid函数计算每个误差的权重并归一化</p><p id="b86c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式9:根据等式计算的重量。8乘以计算误差</p><p id="a30e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 6。</strong> <strong class="ih hj">分类器投票权按照公式计算。10 </strong></p><p id="5731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 7。</strong> <strong class="ih hj">整体模型输出根据公式11 </strong>生成</p><h1 id="9c99" class="kf kg hi bd jp kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">参考文献</strong></h1><p id="cc4f" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">1.针对受概念漂移影响的数据流的自适应机器学习算法:<a class="ae lh" href="https://tel.archives-ouvertes.fr/tel-01812044v2/document" rel="noopener ugc nofollow" target="_blank">https://tel.archives-ouvertes.fr/tel-01812044v2/document</a></p><p id="24c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.用于学生分类的基于实例与基于批量的增量学习方法:</p><p id="d5dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://pdfs.semanticscholar.org/f90e/42ca8c80c75bc28a74d4419c837871679720.pdf" rel="noopener ugc nofollow" target="_blank">https://pdfs . semantic scholar . org/f90e/42 ca 8 c 80 c 75 BC 28 a 74d 4419 c 837871679720 . pdf</a></p><p id="dd9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.适应变化环境的自适应机器学习；</p><p id="8504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://www.turing.ac.uk/research/research-projects/adaptive-machine-learning-changing-environments" rel="noopener ugc nofollow" target="_blank">https://www . turing . AC . uk/research/research-projects/adaptive-machine-learning-changing-environments</a></p><p id="d5db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.在线机器学习简介:简化版:</p><p id="434d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2015/01/introduction-online-machine-learning-simplified-2/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2015/01/简介-在线-机器学习-简化-2/ </a></p><p id="5d21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.概念漂移:在流式机器学习应用中监控模型质量:<a class="ae lh" href="https://www.youtube.com/watch?v=woRmeGvOaz4" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=woRmeGvOaz4</a></p><p id="7702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.将机器学习(ML)模型投入生产的不同方法概述:</p><p id="ece8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" rel="noopener" href="/analytics-and-data/overview-of-the-different-approaches-to-putting-machinelearning-ml-models-in-production-c699b34abf86">https://medium . com/analytics-and-data/overview-of-the-different-approach-to-put-machine learning-ml-models-in-production-c 699 b 34 abf 86</a></p><p id="4b19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.概念漂移适应研究综述；</p><p id="5fc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="http://users.ics.aalto.fi/indre/surv.pdf" rel="noopener ugc nofollow" target="_blank">http://users.ics.aalto.fi/indre/surv.pdf</a></p><p id="66b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8.非平稳环境中增量学习的集成方法；</p><p id="0d60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="http://users.rowan.edu/~polikar/RESEARCH/PUBLICATIONS/mcs07b.pdf" rel="noopener ugc nofollow" target="_blank">http://users . rowan . edu/~ poli kar/RESEARCH/PUBLICATIONS/MCS 07 b . pdf</a></p><p id="0c93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">9.概念漂移数据和软件的资源集合:</p><p id="81ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://github.com/gditzler/ConceptDriftResources" rel="noopener ugc nofollow" target="_blank">https://github.com/gditzler/ConceptDriftResources</a></p><p id="d724" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10.概念漂移下的学习，概述；</p><p id="2205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://arxiv.org/pdf/1010.4784.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1010.4784.pdf</a></p><p id="7bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">11.从示例流中学习灵活的概念:FLORA2:</p><p id="e53c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lh" href="https://pdfs.semanticscholar.org/ee21/fe39d99bd233dbf092f5cd21a50df28c7b04.pdf?_ga=2.226304664.306480498.1567516954-319752636.1567076557" rel="noopener ugc nofollow" target="_blank">https://pdfs . semantic scholar . org/ee21/Fe 39d 99 BD 233 DBF 092 f 5 CD 21 a 50 df 28 c 7 b 04 . pdf？_ ga = 2.2263054-31975</a>46656.66666666667</p></div></div>    
</body>
</html>