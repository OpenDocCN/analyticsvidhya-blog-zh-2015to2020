<html>
<head>
<title>Basic Ideas about Image Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像预处理的基本思想</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basic-ideas-about-image-preprocessing-244fdb72765d?source=collection_archive---------11-----------------------#2020-04-04">https://medium.com/analytics-vidhya/basic-ideas-about-image-preprocessing-244fdb72765d?source=collection_archive---------11-----------------------#2020-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="63f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面列出了我们计划在这个博客中涵盖的内容</p><ol class=""><li id="9ab7" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">转换</li><li id="776f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">旋转</li><li id="0e3d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">缩放比例</li><li id="82c4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">图像金字塔</li><li id="73fe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">种植</li><li id="a6e8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">盘旋和模糊</li><li id="2e7e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">磨刀</li><li id="26a2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">阈值化和二值化</li><li id="8ec8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">边缘检测和图像梯度</li></ol><h2 id="b39b" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">转换</h2><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/1985d83714fb0f35b46d66406ec24ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqNbhhHX0ltwjmaDBkfxWA.png"/></div></div></figure><p id="daa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变换是对图像的扭曲。我们可以用这些变换来做什么，我们用它们来校正从拍摄图像的角度产生的失真或透视问题。</p><p id="bffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种众所周知的变换，一种是仿射变换，另一种是非仿射变换。</p><p id="32b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">仿射与非仿射</strong></p><p id="aa67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仿射变换包括缩放、旋转和平移。重要的因素是，如果原始图像中的线是平行的，那么在变换之后，线也将是平行的。我在简单的话中所说的行与行之间的排比也在转换后得到保持。</p><p id="f5ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在非仿射变换中，将不会保持并行性。非仿射变换不会保留平行度、长度和角度。但是，它保留了共线性和关联。</p><h2 id="fecc" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">旋转</h2><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es ky"><img src="../Images/5259fa114142da1c59bda51ce28fbcc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nepPKia2vQK0MzxxAX0OUQ.jpeg"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">由<a class="ae ld" href="https://unsplash.com/@ripato?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ricardo Gomez Angel </a>在<a class="ae ld" href="https://unsplash.com/s/photos/rotation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="0e08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">轮换，你知道的。旋转图像很容易。我们可以围绕一个点旋转，这个点通常是图像的中心。我们如何使用OpenCV进行旋转将在下面看到</p><p id="bcd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于旋转，我们有下面给出的M矩阵</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es le"><img src="../Images/e21b16db79d241e0f25a8e3bfa39bbf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*DMVhTjTWEyTTxB0iNdNsvA.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">x-旋转的角度</figcaption></figure><p id="e35a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该角度从从中心画出的水平线开始逆时针测量。</p><p id="ff32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV允许您使用名为getRotationMatrix2D的函数同时缩放和旋转。</p><p id="0d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">getRotationMatrix2D函数的参数是我们需要旋转的点(在我们的例子中是中心点)、旋转角度(逆时针90°)和比例(1)因子。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="213a" class="jr js hi lg b fi lk ll l lm ln">iamge = cv2imread(iamge_path)<br/>height, width = iamge.shape[:2]</span><span id="2f79" class="jr js hi lg b fi lo ll l lm ln">#Center point is (width/2, height/2)</span><span id="add4" class="jr js hi lg b fi lo ll l lm ln">rotatation_matrix = cv2.getRotationMatrix2D((width/2, height/2),90,1)</span><span id="6a8c" class="jr js hi lg b fi lo ll l lm ln">rotated_image = cv2.warpAffine(image, rotation_matrix, (width,height))<br/>cv2.imshow('Rotated Image', rotated_iamge)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><h2 id="03d4" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">调整大小或缩放</h2><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lp"><img src="../Images/f895b5e79d3e13218406359fa12180c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXoi6LJbG8snrsIhka3f6w.jpeg"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">照片由<a class="ae ld" href="https://unsplash.com/@siora18?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae ld" href="https://unsplash.com/s/photos/scale?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6666" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很简单，但在这里，我们需要关心的一件事是插值。什么是插值？简单地说，它是一种在已知数据点的离散集合范围内构建新数据点的方法。基本上，当我们调整大小时，意味着我们在扩展点或像素。当我们从大到小或从小到大调整图像大小时，我们如何找到像素之间的间隙？我们做插值来填充像素的空隙。</p><p id="860f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV有许多类型的插值。</p><p id="70f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cv2。INTER_AREA →适合缩小或缩减采样<br/> cv2。INTER _ NEAREST→fast<br/>cv2。INTER_LINEAR →适合缩放或上采样(默认)<br/> cv2。INTER_CUBIC →更好的<br/> cv2。INTER_LANCZOS4 →最佳</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="fa27" class="jr js hi lg b fi lk ll l lm ln">image = cv2.imread(image_path)<br/>image_scaled_default = cv2.resize(image, None, fx=0.75, fy =0.75)<br/>cv2.imshow('Scaling Default', image_scaled_default)</span><span id="7b66" class="jr js hi lg b fi lo ll l lm ln">img_scaled_cubic = cv2.resize(image, None,fx =2, fy=2, interpolation = cv2.INTERCUBIC)<br/>cv2.imshow('Scaling Cubic Interpolation', img_scaled_cubic)</span><span id="c3c1" class="jr js hi lg b fi lo ll l lm ln">img_scaled = cv2.resize(image, (800,600), interpolation = cv2.INTER_AREA)<br/>cv2.imshow("scaling - exact size", img_scaled)</span><span id="491f" class="jr js hi lg b fi lo ll l lm ln">cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="8232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cv2.resize函数可以用来调整图像的大小。我们可以像前两个缩放示例一样，使用原始图像的比率(fx，fy)来缩放图像。</p><p id="76b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以像上一个例子一样设置精确的尺寸来缩放图像。</p><h2 id="8357" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">种植</h2><p id="c7d5" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在OpenCV中裁剪非常容易。在openCV中，图像被表示为Numpy数组。所以我们可以用它来裁剪图像。当我们知道需要裁剪的确切的四个坐标时，我们可以使用Numpy数组方法</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="2abd" class="jr js hi lg b fi lk ll l lm ln">cropped = image[x1:x2, y1:y2]</span></pre><p id="2c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里x1和x2是行坐标，y1和y2是列坐标。</p><h2 id="5176" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">卷积(*)和模糊</h2><p id="3e80" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">卷积是对两个函数执行的数学运算，产生第三个函数，该函数通常是其他原始函数之一的修改版本</p><p id="bdc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出图像=图像*函数(内核大小)</p><p id="bb0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算机视觉中，我们使用内核来指定我们在图像上运行操作函数的大小。</p><p id="ab1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积基本上是一次一个像素地操作。因此，当卷积在一个像素上操作时，它将考虑包含在内核中的像素周围。卷积查看内核像素的值，然后一次操作每个像素。</p><p id="a41c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模糊是一种操作，其中我们对区域(内核)内的像素进行平均。</p><p id="0fcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cv2.filter2D是OpenCV中基本的模糊方法</p><p id="3a3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义了一个3×3的内核，如下所示</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="ee79" class="jr js hi lg b fi lk ll l lm ln">              | 1 1 1 |<br/>kernel = 1/9 *| 1 1 1 |<br/>              | 1 1 1 |</span></pre><p id="557b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们乘以1/9来标准化，否则我们将增加强度。当我们除以9时，总和将是1。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="9218" class="jr js hi lg b fi lk ll l lm ln">img = cv2.imread(image_path)<br/>kernel = np.ones((3,3), np.float32)/9</span><span id="9717" class="jr js hi lg b fi lo ll l lm ln">blurred_img = cv2.filter(img, -1, kernel)<br/></span></pre><p id="5593" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们增加内核大小时，模糊程度会很高。</p><p id="ea22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV中也有其他模糊功能，如方块模糊和高斯模糊。</p><p id="9990" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">箱式过滤器是一种平均过滤器。这将获取盒子下面的像素并替换中心元素。所以盒子的大小需要一个奇数和正数。下面是在opencv中使用盒子过滤器的方法</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="47ac" class="jr js hi lg b fi lk ll l lm ln">blur_img = cv2.blur(img, (3,3))</span></pre><p id="aae3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">medianBlur是另一种模糊滤镜，它采用中值而不是平均值。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="0def" class="jr js hi lg b fi lk ll l lm ln">median = cv2.medianBlur(img,5)</span></pre><p id="d9b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">双边滤波器在去除噪声的同时保持边缘清晰非常有效。它还需要一个空间中的高斯滤波器，但是又多了一个高斯滤波器，它是像素差的函数。像素差函数确保只有那些与中心像素具有相似亮度的像素才被考虑模糊。所以它保留了边缘，因为边缘处的像素将具有大的亮度变化。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="2bdc" class="jr js hi lg b fi lk ll l lm ln">bilateral_img = cv2.bilateralFilter(img, 9, 75, 75)</span></pre><p id="ab17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高斯模糊滤波器是另一种使用高斯矩阵的滤波器。高斯矩阵具有不同的权重，而不是相同的数字。高斯核在中心具有峰值，并向角落减慢。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="3866" class="jr js hi lg b fi lk ll l lm ln">guassian_img = cv2.GuassianBlur(img, (7,7),0)</span></pre><p id="4204" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像去噪-非局部-意味着去噪滤波器不同于上述滤波器。这个滤镜其实源于计算摄影方法。需要一些时间来运行。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="53e6" class="jr js hi lg b fi lk ll l lm ln">flitered_img = cv2.fastNlMeanDenoisingColored(image, None, 6,6,7,21)</span></pre><h2 id="dd15" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">磨刀</h2><p id="62c4" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">锐化是模糊的反义词。它强化或强调图像中的边缘。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="b719" class="jr js hi lg b fi lk ll l lm ln">sharpening_kernel = np.array([[-1,-1,-1],<br/>                              [-1,9,-1],<br/>                              [-1,-1,-1]<br/>                              ])<br/>sharped_img = cv2.filter2D(img, -1,sharpening_kerne)</span></pre><p id="3a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的核和等于1，所以我们不需要再次归一化。</p><h2 id="defe" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">阈值化和二值化</h2><p id="b2c4" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">阈值处理是将图像转换成二进制形式的行为。所有阈值类型都适用于灰度图像。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="b339" class="jr js hi lg b fi lk ll l lm ln">cv2.threshold(image, Threshold value, Max value, Threshold type)</span><span id="2c94" class="jr js hi lg b fi lo ll l lm ln">ret, thresh = cv2.threshold(image, 127,255,cv2.THRESH_BINARY)</span></pre><p id="07b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用上述函数值时，127以下的值将变为0，其他值将变为255</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="4ef1" class="jr js hi lg b fi lk ll l lm ln">ret, thresh = cv2.threshold(image, 127,255,cv2.THRESH_BINARY_INV)</span></pre><p id="eb14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用上面的函数值时，127以下的是255，其他的是零。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="bff1" class="jr js hi lg b fi lk ll l lm ln">ret, thresh = cv2.threshold(image, 127,255,cv2.THRESH_TRUNC)</span></pre><p id="0e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用上述函数时，大于127的值在127处被截断(255参数未使用)</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="96cf" class="jr js hi lg b fi lk ll l lm ln">ret, thresh = cv2.threshold(image, 127,255,cv2.THRESH_TOZERO)</span></pre><p id="78bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当调用上述函数时，127以下的值变为0，127以上的值不变。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="9111" class="jr js hi lg b fi lk ll l lm ln">ret, thresh = cv2.threshold(image, 127,255,cv2.THRESH_TOZERO_INV)</span></pre><p id="830f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上述函数时，127以下不变，127以上变为0。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="d483" class="jr js hi lg b fi lk ll l lm ln">thresh = cv2.adaptiveThreshold(image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY,3,5)</span></pre><p id="5fd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的函数中，我们使用了一个自适应阈值。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="4c40" class="jr js hi lg b fi lk ll l lm ln">thresh_vl, thresh_img = cv2.threshold(image, 0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span></pre><p id="c1e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单阈值或全局阈值要求我们提供阈值。自适应阈值方法消除了这种不确定性。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="2094" class="jr js hi lg b fi lk ll l lm ln">cv2.adaptiveThreshold(image, Max Value, Adaptive Type, Thresold Type, Block size, Constant that is subtracted from mean)</span></pre><p id="c872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，块大小应该是奇数。</p><p id="ce0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自适应阈值类型</p><p id="83a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.ADAPTIVE_THRESH_MEAN_C →基于像素邻域的平均值<br/> 2。ADAPTIVE_THRESH_GAUSSIAN_C →高斯核下邻域像素的加权和<br/> 3。THRESH_OTSU → Clever算法假设图像的灰度直方图中有两个峰值，然后试图找到一个最佳值来分离这些峰值以找到t</p><h2 id="2ad2" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">边缘检测</h2><p id="cbc1" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">边缘不仅是图像的边界，图像中的突变也可能是边缘。</p><p id="fcbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">边缘可以被定义为图像中的突然变化，它们可以编码和像素一样多的信息。</p><p id="c474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV有三种主要的边缘检测算法</p><ol class=""><li id="9934" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Sobel →强调垂直或水平边缘</li><li id="ef50" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">拉普拉斯→获得所有方向</li><li id="187e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Canny →由于错误率低、边缘清晰和检测准确，因此是最佳选择。</li></ol><p id="b276" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Canny算法是一种优秀的边缘检测算法。它是由约翰·F·坎尼在1986年开发的</p><p id="5036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Canny边缘检测的步骤</p><ol class=""><li id="4803" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">应用高斯模糊</li><li id="fcf1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">查找图像的强度梯度</li><li id="6df2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">应用非最大抑制(删除不是边缘的像素)</li><li id="187c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">滞后-应用阈值(如果像素在上阈值和下阈值范围内，则将其视为边缘)</li></ol><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="3895" class="jr js hi lg b fi lk ll l lm ln">sobel_x = cv2.Sobel(img, cv2.CV_64F, 0,1,ksize =5)<br/>sobel_y = cv2.Sobel(img, cv2.CV_64F, 1,0,ksize =5)</span></pre><p id="59b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Sobel可以分别检测水平和垂直边缘。</p><p id="fdf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Canny边缘检测只需要两个阈值来检测边缘。任何大于thresh_high的梯度值都被认为是边缘。任何低于threshold_low值的值都不会被视为边缘。基于它们的强度是如何连接的，阈值之间的值被分类为边缘或非边缘。</p><pre class="kn ko kp kq fd lf lg lh li aw lj bi"><span id="ff0d" class="jr js hi lg b fi lk ll l lm ln">edges_detection = cv2.Canny(img,thresh_low, thresh_high)</span></pre></div></div>    
</body>
</html>