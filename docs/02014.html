<html>
<head>
<title>Matrix multiplication in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的矩阵乘法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matrix-multiplication-in-python-cc5f14b4f735?source=collection_archive---------7-----------------------#2019-11-26">https://medium.com/analytics-vidhya/matrix-multiplication-in-python-cc5f14b4f735?source=collection_archive---------7-----------------------#2019-11-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6e83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们经常遇到数据排列成由行和列组成的表格，这种数据结构称为矩阵。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/9bc6ea4dee037942ef1524174405c48b.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*ZHcQ3qtP6TUhAR-k83dvow.png"/></div></figure><p id="e786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以对矩阵进行数学运算，但是我们必须遵守某些规则。当第一个矩阵的列数等于第二个矩阵的行数时，我们只能将两个矩阵相乘。首先，我们需要将第一个矩阵中每一行的元素乘以第二个矩阵中每一列的元素。然后，我们需要添加产品。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/8b2353f159999ca328282ded726b7de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LTuNJRV8mJ1wYSEl_MsPFw.gif"/></div></div></figure><p id="0ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python没有内置的矩阵类型。我们可以将矩阵实现为2D列表(列表中的列表)。我们可以从初始化两个矩阵开始，使用下面几行代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/fb334c4a2ad07cbe6242e4e10ae4be7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*ta774-y7DO8G_GLsw4zRNg.png"/></div></figure><p id="fc98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，第一个矩阵中的列数与第二个矩阵中的行数相同。</p><p id="2fac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，要真正看到性能速度的差异，我们需要更大的矩阵，这将需要大量的计算。我们将实现以下函数，该函数使用列表理解来初始化我们的矩阵:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jr"><img src="../Images/9e79a0f8c3f2e992e1ff7de65e4e9e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8Hr22zz5-sHYmv2ID2vng.png"/></div></div></figure><p id="9fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助Python的灵活性，我们可以用多种方式执行几乎任何任务。让我们看看执行矩阵乘法的不同方法。</p><p id="16f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先使用列表理解将两个矩阵相乘:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es js"><img src="../Images/c9b3fb8eacf86e42f68e818ff032cfd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-Bs4nTzrIjLAf5Qqh26VA.png"/></div></div></figure><p id="3c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅仅使用for循环:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jt"><img src="../Images/933f38dcc151915c09832a06a7a5c8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmXySXTeO4_egJe3Y-e8gA.png"/></div></div></figure><p id="d560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">矩阵乘法的列表理解版本的代码更简洁，运行速度也更快。Python解释器在循环期间发现可预测的模式，使得列表理解比for循环更快。</p><p id="6ad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用Numpy库来加速矩阵的乘法。Numpy利用了矢量化，这基本上是用对多个数据元素同时进行的操作来取代循环(对单个数据元素的操作)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/b19853385d3ead313d639e02e3ba37f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*4MYqf8Joh7kIcy7SxG_mAw.png"/></div></figure><p id="567b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用NumPy的强大功能，我们需要将列表转换成NumPy数组。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/5f681e423233c7559d0d15a251c27436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*mILKZaMSpngWOUpzHf8Emg.png"/></div></figure><p id="1c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们执行NumPy矩阵乘法，我们确实看到了计算速度的提高！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jw"><img src="../Images/34cf3a70217d2ea35970b26f58fac3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EFtWKYqVUxzsSRAFfJ7vw.png"/></div></div></figure><p id="9755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候加快速度了！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/05cf5cc102517ba42db97eb814278d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/1*M3AeVMQeu9Oto5exFmXzyg.gif"/></div></figure><p id="ef5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用Pytorch库将我们的计算转移到GPU，它具有并行架构，非常适合计算大型矩阵的乘法。首先，我们必须将列表转换成张量——这将允许我们使用GPU和CPU。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jy"><img src="../Images/689486282c31a137de5c9d4124b44da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8AH9KLSSkJfebImdZrmyQ.png"/></div></div></figure><p id="fc99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">倍增时间:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jz"><img src="../Images/6bd407dcc228a30b7932d635fd58f1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5I5PfuN5q5LQldEkbUT6Zg.png"/></div></div></figure><p id="a872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结论:如果你有一个有大量矩阵乘法的应用程序，你可以通过将计算转移到GPU来显著加快它的速度。</p><p id="07e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带有完整代码的colab笔记本可以在这里找到<a class="ae ka" href="https://colab.research.google.com/drive/1F3EKMP3Vq6oylh8w8HLowYRwpU9x9tAi" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1 F3 ekmp 3 VQ 6 oyl h8 w 8 hlowyrwpu 9 x 9 tai</a></p><p id="cec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GitHub上</p><div class="kb kc ez fb kd ke"><a href="https://github.com/forfireonly/Matrix-Multiplication-in-Python/blob/master/Testing_Matrix_multiplication.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">for fire only/Python中的矩阵乘法</h2><div class="kl l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">github.com</p></div></div><div class="km l"><div class="kn l ko kp kq km kr jj ke"/></div></div></a></div><p id="06c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码我的朋友们！</p></div></div>    
</body>
</html>