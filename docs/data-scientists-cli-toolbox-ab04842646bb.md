# 数据科学家的 CLI 工具箱

> 原文：<https://medium.com/analytics-vidhya/data-scientists-cli-toolbox-ab04842646bb?source=collection_archive---------19----------------------->

![](img/ea3ee5cfb1d00efd91f22ae0b6d83ce8.png)

由[谷仓图片](https://unsplash.com/@barnimages?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

命令行是任何数据人饮食中必不可少的一部分。

它是我开发的大多数数据产品以及无数商业依赖的精美图表和 excel 文件背后的**无名英雄**。

本指南旨在介绍构建数据管道的**构件**。我有意让一切保持简单，这样我们**就能直觉地发现哪种工具做得最好**。在后面的文章中，我们将使用这些知识来创建越来越复杂的管道。

让我们开始吧。这是我们为你准备的—

*   处理数据源
*   加工语言 **awk，sed** 和 **jq**
*   bash 循环
*   实用程序，如 **wc** 、 **grep、sort、uniq** 等

# **数据源模式—**

重要的事情先来。我们需要从某个地方获取数据。根据我的经验，它通常是一个纯文本或 json 文件。我们还可以动态生成数据，或者硬编码一些东西用于测试。即使我的数据源是一个数据库，假设数据集不是特别大，我也会把它转储到一个 csv 文件中进行处理。如果是，我将使用一个样本来微调管道。

1.  **纯文本**。空格、逗号或制表符分隔。

```
cat data.txt
```

2. **JSON 文件**。为了向前馈送这些数据，我们需要使它变平，所以 jq 非常适合这个任务。稍后我会在帖子中更详细地介绍 jq。对于这个例子，假设我们有一个{用户名，出生日期}的列表，我们打算把它转换成制表符分隔的文本格式。

```
cat data.json | jq -r '.[] | [.username, birth_date] | @tsv'
```

3.**生成输入**。通常是一串数字。从 1 到 10，包括 1 和 10—

```
seq 10
```

4.**硬编码字符串**。非常有助于测试管道，尤其是那些涉及正则表达式的管道。

```
echo "Lorem ipsum dolor sit amet"
```

# **Awk 模式** —

1.  获取一列数据。

假设您有一个制表符分隔的文件，其中有 3 列数据，您需要第二列。

```
cat data.txt | awk -F'\t' '{print $2}'
```

$0 表示整行，而$N 表示第 N 个字段。基于 1。

2.确保你的文件每行都有相同数量的列。

```
cat data.txt | awk -F'\t' '{print NF}' | sort -u
```

NF 代表“字段数”。

如果它返回一个数字，并且是您期望的数字，那么一切都很好。有时候，如果你不信任来源或者你的文件是由多个来源拼接而成的，那么做这个检查会很有帮助。**最好安全**。

3.你需要拿到**最后一栏**。是的，有时那会派上用场。这是 NF 的一个变化——它可以被引用为$1、$2 等等。

```
cat data.txt | awk -F'\t' '{print $NF}'
```

4.**数学**表达式作为**过滤器**。假设我们需要所有能被 3 整除的数。

```
cat integers.txt | awk '$0 % 3 == 0'
```

默认情况下，awk 打印输出，因此如果您的主块中只有一个 print 语句，那么可以省略它。

# **Sed 模式** —

1.  从文件中取出一个**单行。假设我们需要第 10 行(从 1 开始计数)。**

```
cat data.txt | sed -n '10p'
```

sed 就像 awk 一样默认打印出输入行。这里我们传递-n 来抑制这种行为，并在需要时使用显式指令“p”来打印。

一个好的做法是在 sed 满足条件并且不期望产生更多输出后退出。对于小文件来说，这不是问题，但是如果我们要处理如此大规模的日志或文件，我们可以做以下事情。

```
cat data.txt | sed -n '10{p;q;}'
```

它在打印完第 10 行后立即退出。

2.获取**行范围**。例如，第 10 行到第 20 行。

```
cat data.txt | sed -n '10,20p'
```

3.从**特定行开始打印，直到文件**结束。最后一行数字由特殊字符$表示。

```
cat data.txt | sed -n '10,$p'
```

4.执行**字符串替换**。假设我们想用“bbb”替换所有出现的“aaa”。

```
cat data.txt | sed 's/aaa/bbb/g'
```

5.**打印两个正则表达式之间的行**匹配。这里我们打印匹配' aaa '的行和匹配' bbb '的行之间的所有内容。包括起始行和结束行。

```
cat data.txt | sed -n '/aaa/,/bbb/p'
```

6.我们可以**混搭**线匹配条件。例如，我们可以打印从匹配' aaa '的一行到文件结尾的所有内容。

```
cat data.txt | sed -n '/aaa/,$p'
```

# **Jq 模式** —

1.  **漂亮打印**一个 JSON 文件。

```
cat data.json | jq
```

2.从对象列表中提取一个字段。假设您有一个包含名字、姓氏和年龄的人员列表。我们想要年龄。

```
cat data.json | jq -r '.[] | .age'
```

。[]打开一个数组，把它变成一个记录流。age 访问每个记录的特定字段。正如你所注意到的，我们这里也有管道。

3.**将数据**展平成一个 tsv(与 csv 相同，但用制表符分隔)。我更喜欢使用制表符，因为我不太可能在以后遇到解析问题。

```
cat data.json | jq -r '.[] | [.first, .last, .age] | @tsv'
```

在这里，我们用我们想要的字段为每个记录创建一个新的数组，然后通过管道将它传送到一个特殊的处理器‘tsv’。注意，我们将-r 传递给 jq。它确保所有的文字都被打印为“原始的”,即它们周围没有任何引号。我不记得上一次不用 jq 是什么时候了。

4.**滤镜。**假设我们希望所有 40 岁以上的人。

```
cat data.json | jq -r '.[] | select(.age > 40)'
```

我们也可以有多个条件。

```
cat data.json | jq -r '.[] | select(.age > 40 and .first == "Bob")'
```

5.**阵长。**

```
cat data.json | jq 'length'
```

确保**不是**在输入数组到“长度”之前打开它。

我强烈推荐阅读 jq 的手册和**食谱**。他们有很多好吃的。

6.**转储所有可能的路径。**

```
cat data.json | jq -r 'paths(scalars) | join(".")'
```

# **痛击**

啊啊。不错的老聚会。

1.  **while 循环。如果我需要一步做多件事，我会经常使用它们。在这个例子中，我们用 curl 获取一些数据。我们正在访问的远程服务返回 json，但都在一行中。我希望它印得漂亮些。**

```
cat -n long_lat.txt | while read idx long lat; do curl -X GET "https://api.fancyservice.com/search?latitude=$lat&longitude=$long" | jq > $idx.json; sleep 2; done
```

这里发生了一些事情。

*   我用-n 调用“cat”。这将从 1 开始对所有行进行编号。现在我可以用索引遍历数据。
*   我将 3 列数据——索引、经度和纬度——读入它们各自的变量。
*   我打印了 curl 的输出，并将其转储到一个文件中。
*   休眠 2 秒钟，这样我就不会发出任何危险信号(除非这个 api 是专门设计来被攻击的)

# **漂亮的实用程序—**

1.  **行数**

```
cat data.txt | wc -l
```

2.**字符串过滤器。**awk 非常适合处理数字的过滤器，而 grep 或 sed 却非常喜欢字符串。

给我所有以“mary”开头的行，忽略大小写。

```
cat data.txt | grep -i '^mary'
```

我们可以翻转它，要求所有的行都以别的开头。

```
cat data.txt | grep -vi '^mary'
```

或者与“玛丽”完全匹配。

```
cat data.txt | grep -wi 'mary'
```

3.**排序。假设我想用人名对一个文件进行排序。**

```
cat names.txt | sort
```

如果我想让它逆序排列—

```
cat names.txt | sort -r
```

如果我们处理的是数字，那么使用-n

```
cat integers.txt | sort -nORcat integers.txt | sort -nr
```

4.**独特性。如果某处有排序，uniq 就潜伏在拐角处。假设我们想要一个不同的人名列表。**

```
cat names.txt | sort -u
```

然而，如果我们想要更多，想要计算每个名字出现的次数——

```
cat names.txt | sort | uniq -c
```

从 **uniq** 返回的计数没有排序。我们可以很容易地补救这一点。

```
cat names.txt | sort | uniq -c | sort -nr
```

这将给我们以降序排列的计数和它们各自的单词。为了把它限制在前 5 名，我们可以做—

```
cat names.txt | sort | uniq -c | sort -nr | head -5
```

# **结论**

希望你喜欢这本书。

这里介绍的工具比本文中介绍的要多得多。希望您发现了命令行错误，并继续自己探索。

请记住，有时一个特定命令必须提供的强大功能可能会以牺牲可读性为代价。

下次见！