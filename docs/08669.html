<html>
<head>
<title>Anomaly Detection Using Isolation Forest Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于隔离森林算法的异常检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/anomaly-detection-using-isolation-forest-algorithm-8cf36c38d6f7?source=collection_archive---------5-----------------------#2020-08-08">https://medium.com/analytics-vidhya/anomaly-detection-using-isolation-forest-algorithm-8cf36c38d6f7?source=collection_archive---------5-----------------------#2020-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4ddb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从一个简单的游戏开始——“找出怪人”。我会给你看一张图片，你必须识别出图片中的奇怪物体。</p><p id="77b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备好了吗？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ca6a4dbb5a7fc7e10c808ab7179514b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*KiwwpbLD_YjCUc4zed0vig.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">找出古怪的人</figcaption></figure><p id="68a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那一定很容易。绿柠檬是独一无二的。<br/>让我们试试下一个:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/2527bac8590808b7f0a94e3dc5c5da27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*p5sLQkeYHsjPG1QhbidUZg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">找出奇怪的人。</figcaption></figure><p id="e8af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我敢打赌，这会更困难。</p><p id="eafc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能需要更多的时间来识别闭上嘴的表情符号。</p><p id="d133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个古怪的人只不过是一个与众不同的异类。对于较小的数据集，我们在识别异常时不会遇到困难，但是当规模增大时，人和机器在识别该异常时都会遇到困难。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="81a9" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">什么是异常，如何识别异常？</h1><p id="97c6" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><strong class="ih hj">异常</strong>是数量少且不同的数据点。它有一个模式，看起来与正常数据点有不同的特征。</p><p id="3744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="la">异常情况示例:</em> <br/> 1)欺诈性使用信用卡通常会被视为异常情况，因为欺诈者可能会尝试在新的商户进行交易或进行高额交易。<br/> 2)对计算机网络的攻击等</p><p id="6644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">检测异常的方法:</strong></p><p id="ca91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检测异常的三种基本方法基于:</p><ol class=""><li id="ae12" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">密度</li><li id="7650" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">距离</li><li id="9dab" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">孤立。</li></ol><p id="3a37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在下面详细讨论它们。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="0b14" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">基于密度和距离的方法</h1><p id="f97e" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">使用密度和距离的基本方法的用于异常检测的大多数现有方法如下:<br/> 1)复制器神经网络(RNN)——它是具有前馈多层感知器的神经网络，其训练网络相对良好地复制看不见的正常实例。在RNN，那些重建很差的被视为异常。<br/> 2)一类SVM-它找到包含大多数正常数据点的最小区域，该区域之外的点被视为异常。<br/> 3)基于聚类的方法，构建正常实例的简档，然后将异常识别为不符合正常简档的那些。</p><h1 id="4591" class="jx jy hi bd jz ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku bi translated"><strong class="ak">密度和距离测量异常检测的假设:</strong></h1><p id="1120" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">对于密度测量，“正常点出现在密集区域，而异常点出现在稀疏区域”。例如:RNN和一等SVM <br/>对于距离的度量，“正常点靠近其邻居，异常点远离其邻居”。例如:基于聚类的方法。</p><p id="1326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，它们的异常检测能力通常是算法的“副作用”或副产品，该算法最初被设计用于除异常检测之外的目的，导致如下的缺点:<br/> a)太多的错误警报<br/>例如:将正常实例识别为异常或检测到太少的异常。<br/> b)许多现有方法受限于低维数据和小数据量<br/>，因为它们的原始算法存在遗留问题。</p><p id="18f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，在密度和距离测量异常检测的假设中存在违规，例如，高密度和短距离并不总是意味着正常情况；同样，低密度和长距离并不总是意味着异常。</p><p id="9895" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决密度和距离测量异常检测的缺点，我们有隔离森林。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="263b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">隔离森林</h1><p id="363b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">让我们详细了解什么是隔离林，以及它如何有助于识别异常。</p><p id="b9a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隔离:</strong>术语隔离的意思是“将一个实例与其余的实例分离开来”。因为异常是“少数和不同的”,因此它们更容易被隔离。</p><p id="5279" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是隔离林？<br/> </strong>隔离林通过随机选择一个特征，然后随机选择所选特征的最大值和最小值之间的分割值来“隔离”观察值。</p><p id="3fa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一种无监督算法，因此不需要标签来识别异常值/异常值。</p><p id="b2ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它遵循以下步骤:</p><ol class=""><li id="37b1" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">对数据进行随机递归划分，表示为一棵树(随机森林)。这是用户定义子样本参数和树数的训练阶段。</li><li id="9aa0" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">一旦数据的递归划分完成，就到达了树的末尾。预计到达异常值所需的距离远小于正常数据所需的距离(见图)。</li><li id="e948" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">路径的距离被平均和标准化以计算异常分数。</li><li id="5fc8" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">异常值的判断是基于分数进行的。</li></ol><p id="1416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是同样的数字:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/4e41782bf4b1bebcc66841b81af99e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*pq-WoGd8Qfe1V8QCyw3KOA.png"/></div></figure><p id="07bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Isolation Forest纯粹基于隔离概念检测异常<br/>,而不采用任何距离或密度测量，这与所有现有方法完全不同。</p><p id="9c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隔离林利用子采样来实现较低的线性时间复杂度和较小的内存需求。以处理淹没效应和掩蔽效应。</p><p id="0bba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它利用了异常的两个定量属性:<br/> 1)它们是由少数实例组成的少数群体<br/> 2)它们具有与正常实例非常不同的属性值。<br/>换句话说，异常是“少数和不同的”，这使得它们更容易受到我们称为隔离的机制的影响。</p><p id="ec22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隔离森林为给定的数据集建立隔离树的集合，异常是那些在隔离树上具有短平均路径长度的实例。接近1的分数被认为是正常的，而接近0的分数被认为是异常的。<br/>隔离森林具有线性时间复杂度，常数小，内存需求最小。<br/>隔离林是专门为异常检测而建立的。</p><p id="6402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，您可能已经很好地理解了隔离森林及其相对于其他基于距离和密度的算法的优势。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="c9ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用python中的隔离森林来识别异常。</p><p id="11cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据描述:<br/> </strong>我们使用的数据集是1999年KDDCUP的Http <a class="ae lv" href="http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html" rel="noopener ugc nofollow" target="_blank">数据集</a>。<br/>该数据集包含来自七周网络流量的623091条HTTP连接记录。<br/>数据集已经过预处理，包含41个独立TCP连接特征、内容特征和流量特征。<br/>每个连接被标记为正常或攻击，只有一种特定的攻击类型。</p><p id="d258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题定义:<br/> </strong>是识别连接，是正常还是攻击。</p><h1 id="f732" class="jx jy hi bd jz ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku bi translated"><strong class="ak"> Python代码:</strong></h1><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="be2d" class="mb jy hi lx b fi mc md l me mf"># Loading respective Library FIle <br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>plt.style.use(“ggplot”)<br/>%matplotlib inline</span><span id="95d0" class="mb jy hi lx b fi mg md l me mf"># Loading respective Library FIle <br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>plt.style.use(“ggplot”)<br/>%matplotlib inline</span><span id="5c86" class="mb jy hi lx b fi mg md l me mf"># Loading DATA<br/>cols = [“duration”, “protocol_type”, “service”, “flag”, “src_bytes”, “dst_bytes”, “land”, “wrong_fragment”, “urgent”,<br/> “hot”, “num_failed_logins”, “logged_in”, “num_compromised”, “root_shell”, “su_attempted”, “num_root”, <br/> “num_file_creations”, “num_shells”, “num_access_files”, “num_outbound_cmds”, “is_host_login”,<br/> “is_guest_login”, “count”, “srv_count”, “serror_rate”, “srv_serror_rate”, “rerror_rate”, “srv_rerror_rate”,<br/> “same_srv_rate”, “diff_srv_rate”, “srv_diff_host_rate”, “dst_host_count”, “dst_host_srv_count”, <br/> “dst_host_same_srv_rate”, “dst_host_diff_srv_rate”, “dst_host_same_src_port_rate”, “dst_host_srv_diff_host_rate”,<br/> “dst_host_serror_rate”, “dst_host_srv_serror_rate”, “dst_host_rerror_rate”, “dst_host_srv_rerror_rate”]<br/>kdd_data = pd.read_csv(“…./Issolation_forest_data/kddcup.data/kddcup.data.corrected”, sep=”,”, names=cols + [“label”], index_col=None)</span><span id="0f44" class="mb jy hi lx b fi mg md l me mf">#Viewing The data.<br/>kdd_data.head()</span><span id="3b85" class="mb jy hi lx b fi mg md l me mf"># Dropping unwanted variable<br/>kdd_data = kdd_data[kdd_data[“service”] == “http”]<br/>kdd_data = kdd_data.drop(“service”, axis=1)<br/>cols.remove(“service”)<br/>kdd_data.shape</span></pre><p id="8256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="1868" class="mb jy hi lx b fi mc md l me mf">(623091, 41)</span><span id="67a9" class="mb jy hi lx b fi mg md l me mf">## Encoding the categorical column <br/>from sklearn.preprocessing import LabelEncoder<br/>encs = dict()<br/>kdd_data_1 = kdd_data.copy() #.sample(frac=1)<br/>for c in kdd_data_1.columns:<br/> if kdd_data_1[c].dtype == “object”:<br/> encs[c] = LabelEncoder()<br/> kdd_data_1[c] = encs[c].fit_transform(kdd_data_1[c])</span><span id="e167" class="mb jy hi lx b fi mg md l me mf">#### Implementing Isolation forest <br/>from sklearn.ensemble import IsolationForest<br/>#### Spliting the data into Train, Test and validation dataset <br/>X_train, y_train = kdd_data_1[cols][:300000], kdd_data_1[“label”][:300000].values<br/>X_valid, y_valid = kdd_data_1[cols][300000:500000], kdd_data_1[“label”][300000:500000].values<br/>X_test, y_test = kdd_data_1[cols][500000:], kdd_data_1[“label”][500000:].values</span></pre><p id="8d03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><br/>隔离林参数:<strong class="ih hj"> n_estimators: </strong>要使用的树木数量。论文建议了100棵树，因为路径长度通常在此之前就收敛了。<br/> max_samples:构建单棵树时要绘制的样本数。该参数在本文中被称为子采样，他们建议<strong class="ih hj"> max_samples </strong> =256，因为它通常提供足够的细节来跨大范围的数据执行异常检测。<br/> <strong class="ih hj">污染:</strong>数据集的污染量，即数据集中离群点的比例。在拟合以定义决策函数的阈值时使用。稍后我会告诉你如何挑选这个门槛。</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="1e0e" class="mb jy hi lx b fi mc md l me mf">### Building isolation forest <br/>iso_Forest = IsolationForest(n_estimators=100, max_samples=256, contamination=0.2, random_state=2018)</span><span id="3ecd" class="mb jy hi lx b fi mg md l me mf">## Fitting the model <br/>iso_Forest.fit(X_train)</span><span id="4d26" class="mb jy hi lx b fi mg md l me mf">#### Ploting the graph to identify the anomolie score .<br/>plt.figure(figsize=(12, 8))<br/>plt.hist(scores, bins=50);</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/8d6ae2a633b4af59002f2ba3351c5b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vl2bVhddRRY9g9ijYKhKWg.png"/></div></div></figure><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="eaaa" class="mb jy hi lx b fi mc md l me mf">From the plot we clearly get the cluster under -0.2. Hence we can consider average path lengths shorter than -0.2 as anomalies.</span><span id="78d0" class="mb jy hi lx b fi mg md l me mf">from sklearn.metrics import roc_auc_score<br/>print(“AUC: {:.1%}”.format(roc_auc_score((-0.2 &lt; scores), y_valid == list(encs[“label”].classes_).index(“normal.”))))</span></pre><p id="e0a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong></p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="6c05" class="mb jy hi lx b fi mc md l me mf">AUC: 99.0%</span></pre><p id="05d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">挺好的。现在让我们检查测试数据集。</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="08cd" class="mb jy hi lx b fi mc md l me mf">### getting score for test <br/>scores_test = iso_Forest.decision_function(X_test)<br/>print(“AUC: {:.1%}”.format(roc_auc_score((-0.2 &lt; scores_test),<br/> y_test == list(encs[“label”].classes_).index(“normal.”))))</span></pre><p id="0a70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出:</strong></p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="7a6c" class="mb jy hi lx b fi mc md l me mf">AUC: 99.3%</span></pre><p id="203e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它在识别测试数据集上的异常时也给了我们很好的准确性。</p><p id="1f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们能够使用python中的隔离林成功地实现异常检测。</p></div></div>    
</body>
</html>