<html>
<head>
<title>The very fundamentals of Docker images management (1/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker图像管理的基础知识(1/2)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-very-fundamentals-of-docker-images-management-1-2-820676ac40dc?source=collection_archive---------22-----------------------#2020-03-24">https://medium.com/analytics-vidhya/the-very-fundamentals-of-docker-images-management-1-2-820676ac40dc?source=collection_archive---------22-----------------------#2020-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/391cfaae4cba27180240a4fbee968d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q7VYRVWmIPqKtnNY"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="2f4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Docker令人着迷，只要你习惯了容器化的概念，你就会知道这种技术可以在任何地方实现。</p><p id="6469" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现代软件实际上使用了很多容器，就容器技术而言，不仅仅是Docker，但是在某一点上，Docker被广泛采用，并且向前迈进了一步。</p><p id="16bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请和我一起参加这个讲座，对它有更多的了解。我假设你已经在你的电脑上安装了至少<code class="du jt ju jv jw b">Docker</code>，使用这个指南作为安装后的步骤，相信我，这是一个非常简单的过程。</p><p id="3487" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">准备好了吗？</p><p id="7758" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">Docker</code>的第一个基本概念是<code class="du jt ju jv jw b">Docker Image</code>，基本上，这是一个包含运行应用程序所需的一切的包:代码、运行时、库、环境变量和配置文件。如果你熟悉<strong class="ix hj"> OOP编程</strong>，你可以把一个<code class="du jt ju jv jw b">Docker Image</code>当做一个<code class="du jt ju jv jw b">Class</code>。</p><p id="be5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好，让我们继续第二个概念，这里是<code class="du jt ju jv jw b">Docker Image</code>的补充，是<code class="du jt ju jv jw b">Docker Container</code>，这是一个图像的运行时实例。回到<strong class="ix hj"> OOP关系</strong>中，<code class="du jt ju jv jw b">Docker container</code>是一个<code class="du jt ju jv jw b">Object</code>(<code class="du jt ju jv jw b">Class</code>的实例)</p><p id="9e40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在您的本地<code class="du jt ju jv jw b">Docker</code>安装中，您实际上是从某个特定的来源下载<code class="du jt ju jv jw b">Docker Images</code>(稍后解释)。这些下载的映像是只读的，所以您可以使用它们作为模板(基础映像)来构建新的映像。</p><h2 id="5eb0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">了解Docker图像</h2><p id="8aac" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在内部，<code class="du jt ju jv jw b">Docker</code>映像由层组成，这些内部层文件系统允许<code class="du jt ju jv jw b">Docker</code>在可重用性方面灵活高效，特别是在创建容器时，因为您可以一次创建X个容器，而不会相互冲突。</p><p id="b35a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在底层，当一个容器被实例化时，一个顶部可写层被创建，它将接收开发人员在运行时所做的所有更改，一旦实例被删除，该层也将被删除。</p><p id="8e3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">Docker</code>使用存储驱动程序管理图像层和可写容器层的内容。每个存储驱动程序处理实施的方式不同，但所有驱动程序都使用可堆叠的图像层和CoW策略。</p><p id="81d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了快速理解在运行时如何编写层，您需要理解<code class="du jt ju jv jw b">UFS</code>(联合文件系统)的概念。这篇文章<a class="ae iu" href="https://www.terriblecode.com/blog/how-docker-images-work-union-file-systems-for-dummies/" rel="noopener ugc nofollow" target="_blank">非常好，因为它从Linux实现开始，这是一个非常值得推荐的讲座。</a></p><p id="ab62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">Docker Image Union FS</code>(称为DIUFS)包含集装箱的清单文件，这类似于集装箱的文档描述)，以及:</p><p id="e71a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.用于创建新容器实例的容器层(构建说明)</p><p id="d5a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.实例完成后将执行的配置更改</p><p id="cfbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.为便于用户访问而运行的应用程序</p><p id="d01b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这对于刚开始使用来说是非常明显的，可以认为这是一个必须知道的理论，但在课程中很少使用或提及。</p><p id="550f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在继续之前，让我们回顾一下。在<code class="du jt ju jv jw b">DIUFS</code>的帮助下构建的整个先前的映像还包括一个在实例化时创建的顶部可写层。一旦执行完成，层被移除，但是图像保留，这概括了容器是无状态的。</p><h2 id="76e1" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">让我们从代码开始:让我们从图像开始</h2><p id="2706" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我个人会(盲目地)推荐在CLI中使用<code class="du jt ju jv jw b">Docker</code>，有GUI的工具，但不提供最好的使用深度。如果你愿意，你可以使用<code class="du jt ju jv jw b">Docker Toolbox</code>的一个GUI工具部分<code class="du jt ju jv jw b">Kitematic</code>，它是可以使用的。</p><p id="b83e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在的基础命令是<code class="du jt ju jv jw b">docker image</code>。这将处理系统中本地和远程映像的完整管理。</p><p id="890d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您有一个全新的安装，因此，没有图像安装在您的系统中，那么下一步是什么？</p><h2 id="1a50" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">归零地</h2><p id="41f5" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们可以使用以下内容向您展示安装了哪些<code class="du jt ju jv jw b">Docker Images</code></p><p id="05e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">docker image ls</code>(这列出了存储库、标签、图像ID、大小等等)</p><p id="9b2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果为零，那么，我们可以执行图像搜索。</p><h2 id="c540" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">搜索图像</h2><p id="d52f" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><code class="du jt ju jv jw b">docker search &lt;image&gt;</code>将在<code class="du jt ju jv jw b">Docker Hub</code>(系列的第2部分)中搜索图像。这个命令处理多个选项，我将向您展示其中的一些。</p><ul class=""><li id="20a7" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated"><code class="du jt ju jv jw b">docker search — limit=1 &lt;Name&gt;</code>这限制了特定图像名称的查询结果</li><li id="218d" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">这将只检查官员Docker图像(更多内容在本系列的第2部分)</li><li id="d7d0" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><code class="du jt ju jv jw b">docker search --filter "stars=80” &lt;name&gt;</code>这将找到排名中有80颗或更多星星的图片(Docker hub)</li></ul><h2 id="8366" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">下载图像</h2><p id="a333" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">这里我们要做一点小小的改变，因为我们要引入<code class="du jt ju jv jw b">pull</code>命令，这将抓取(下载)并安装某个来源的特定镜像，该镜像将在本系列的后面解释。</p><p id="2a4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<code class="du jt ju jv jw b">docker pull &lt;name:tag&gt;</code>您可以选择任何特定的映像和版本，并将其安装在本地。</p><p id="a9b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个例子</p><p id="5284" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">docker pull nginx:latest</code></p><p id="7141" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将抓取并下载设置了<code class="du jt ju jv jw b">latest</code>标签的<code class="du jt ju jv jw b">Nginx</code>图像。执行后会在您的计算机上安装一份副本。</p><h2 id="965a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">磨尖</h2><p id="1811" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">图像可能会随着时间的推移而改变和改进，因此版本控制是关键。<code class="du jt ju jv jw b">Docker</code>图像需要标签来识别，有了标签，您还可以执行直接搜索。您可以在处理容器时执行标记，如下所示:</p><p id="f72f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">docker image tag &lt;container&gt;:&lt;your-tag&gt;</code></p><p id="5c18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它们都与同一个原始图像相关，可以使用<code class="du jt ju jv jw b">rm</code>命令移除标签</p><h2 id="05c3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">消除</h2><p id="4e17" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">它说了什么，没什么好解释的。移除会从您的硬盘上删除图像。</p><ol class=""><li id="a9f6" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js ll ld le lf bi translated"><code class="du jt ju jv jw b">docker image rm [TAG or ID]</code>从磁盘上删除已安装的特定映像。如果图像被容器使用，必须用<code class="du jt ju jv jw b">--force</code>标志强制</li><li id="d58f" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated"><code class="du jt ju jv jw b">docker image prune</code>将删除未使用和未标记的图像</li></ol><p id="4af1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有类似<code class="du jt ju jv jw b">docker rmi [TAG]</code>的变体，用于删除一个或多个图像，或者<code class="du jt ju jv jw b">docker image prune</code>用于删除未使用的图像</p><p id="fa10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有很多，这只是给你一个想法。</p><h1 id="0778" class="lm jy hi bd jz ln lo lp kd lq lr ls kh lt lu lv kk lw lx ly kn lz ma mb kq mc bi translated">离开基础</h1><h2 id="f0b3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">检查图像</h2><p id="e5e8" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在<code class="du jt ju jv jw b">docker inspect</code>命令的帮助下，您可以查看任何JSON数组格式的已安装映像的详细信息，这里有关于网络、层、id、版本的信息，以及许多相关信息。</p><p id="995b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您也可以使用<code class="du jt ju jv jw b">docker image inspect &lt;image&gt;:&lt;tag&gt;</code>来执行</p><p id="645a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我建议过滤输出，如下例。</p><ol class=""><li id="7f40" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js ll ld le lf bi translated">使用Linux命令过滤</li></ol><p id="9459" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">-<code class="du jt ju jv jw b">docker image inspect ubuntu:latest | grep Os</code>-<br/>-<code class="du jt ju jv jw b">docker image inspect ubuntu:latest &gt; ubuntu-inspect.txt</code>(IO重定向)</p><p id="34f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.直接的方法</p><p id="8806" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">-<code class="du jt ju jv jw b">docker image inspect ubuntu:latest --help</code><br/>-<code class="du jt ju jv jw b">docker image inspect ubuntu:latest --format=’{{.Id}}’</code>(sha 256 ID)<br/>-<code class="du jt ju jv jw b">docker image inspect test:1.0 --format=’{{json .ContainerConfig}}’</code></p><p id="9ca1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是标准输出格式:</p><p id="085c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">- <code class="du jt ju jv jw b">docker image inspect test:1.0 --format=’{{.ContainerConfig.ID}}’</code></p><h2 id="350e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">著名的码头文件</h2><p id="534f" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><code class="du jt ju jv jw b">Dockerfile</code>是从文件中提取图像的方式。它是一个文本文件，包含构建给定图像所需的所有命令。一个<code class="du jt ju jv jw b">Dockerfile</code>由docker构建命令执行。</p><p id="3f96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<code class="du jt ju jv jw b">Dockerfile</code>执行构建的<code class="du jt ju jv jw b">Docker</code>客户端，其中:</p><ol class=""><li id="0625" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js ll ld le lf bi translated"><code class="du jt ju jv jw b">docker build</code>将图像发送到创建图像的Docker守护进程。</li><li id="f197" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated">生成的图像可用于创建容器</li><li id="d8e6" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated">图像可以从<code class="du jt ju jv jw b">registries</code>到<code class="du jt ju jv jw b">pulled</code>或<code class="du jt ju jv jw b">pushed</code></li></ol><p id="a38a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在官方文档(<code class="du jt ju jv jw b">Dockerfile</code>部分)中找到说明</p><h2 id="f1d4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">说明列表</h2><p id="53ea" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">以下是可在<code class="du jt ju jv jw b">Dockerfile</code>上使用的命令(指令)列表</p><p id="5521" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">添加</strong>:将文件复制到镜像中但支持tar和远程<code class="du jt ju jv jw b">URLs</code> <br/> <strong class="ix hj">复制</strong>:将文件复制到镜像中，优先于<code class="du jt ju jv jw b">ADD</code>(为简单起见 被认为是最佳实践)<br/> <strong class="ix hj">卷</strong>:在容器运行时创建定义的挂载点<br/> <strong class="ix hj">入口点</strong>:在容器运行时运行可执行文件<br/> <strong class="ix hj">暴露</strong>:记录应该发布的端口<br/> <strong class="ix hj"> CMD </strong>:为<strong class="ix hj">入口点</strong>(只允许一个)<br/> <strong class="ix hj"> ENV </strong>提供参数:用于定义容器中的环境变量 <code class="du jt ju jv jw b">FROM</code>指令必须是<code class="du jt ju jv jw b">Dockerfile</code> <br/> <strong class="ix hj">维护者</strong>上的第一条指令:电子邮件地址(记录<code class="du jt ju jv jw b">Dockerfile</code>的作者)<br/> <strong class="ix hj"> ONBUILD </strong>:仅在该映像用于构建其他映像时用作触发器；将定义命令运行" on build" <br/> <strong class="ix hj"> RUN </strong>:在新层运行新命令<br/> <strong class="ix hj"> WORKDIR </strong>:定义容器的工作目录</p><h2 id="ab60" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">从Dockerfile构建</h2><p id="c236" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">一旦你准备好了，就该把它转换成我们容器的工作基础图像了。Docker的<code class="du jt ju jv jw b">build</code>命令也可以通过Github库、tarballs和stdins来执行。</p><p id="448f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">docker build</code>从指定的目录中读取文件，并根据文件中的内容构建图像</p><p id="abf5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:<br/> - <code class="du jt ju jv jw b">docker build -f ./Dockerfile</code>这将启动用<code class="du jt ju jv jw b">-f</code>标志指定的文件的构建过程</p><p id="40ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，您可以强制不使用缓存</p><p id="619a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">- <code class="du jt ju jv jw b">docker build --no-cache=true -f ./Dockerfile</code></p><h2 id="1213" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">Dockerfiles提示</h2><ol class=""><li id="9c94" class="kx ky hi ix b iy ks jc kt jg md jk me jo mf js ll ld le lf bi translated">检查使用<code class="du jt ju jv jw b">.dockerignore</code>文件的文档</li><li id="4be4" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated">将<code class="du jt ju jv jw b">\</code>用于多行图像(更好的组织)</li><li id="e063" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js ll ld le lf bi translated">用<code class="du jt ju jv jw b">&amp;&amp;</code>符号将命令绑定在一起(如果它是多行的),命令将被缓存</li></ol><p id="818d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，您可以使用<code class="du jt ju jv jw b">inspect</code>轻松查看内容，获取图像细节。</p><h2 id="a244" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">修改图层</h2><p id="65fe" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">拥有多个图层并不总是有效的，如果你检查你的图像大小，实际上是相当大的，所以可能会想，我们如何才能减少图像的大小？</p><p id="0a69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了部署，性能是一个很好的选择，找到一种优化的方法，一个很好的选择是<strong class="ix hj">挤压</strong></p><p id="a374" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">压缩一个图像，成为一个单一的图像层。检查docker服务器上的实验选项是否设置为true <br/> 2。如果是，则使用选项<code class="du jt ju jv jw b">--squash</code>进行构建</p><p id="8ae2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">docker build --squash -f Dockerfile -t ubuntu:&lt;your-new-tag&gt; .</code></p><p id="cc53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后的<code class="du jt ju jv jw b">.</code>代表<code class="du jt ju jv jw b">Dockerfile</code>所在的目录。</p><p id="f4f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">毕竟，您也可以对图像执行一个<code class="du jt ju jv jw b">export</code>并使用<code class="du jt ju jv jw b">history</code>命令检查新版本(从-)</p><ul class=""><li id="e286" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated"><code class="du jt ju jv jw b">docker container export &lt;name&gt; &gt; nginx.tar</code><br/>-<code class="du jt ju jv jw b">docker image import nginx.tar</code>-<br/>-<code class="du jt ju jv jw b">docker tag &lt;tag&gt; &lt;name&gt;</code>-<br/>-<code class="du jt ju jv jw b">docker image history &lt;name&gt;</code></li></ul><p id="ec14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我试图涵盖许多主题，只关注<code class="du jt ju jv jw b">Docker Image</code>的创建和管理，当然，不接触<code class="du jt ju jv jw b">Docker Containers</code>很难找到这篇文章的好感觉，但我会非常大，我相信周围有很多信息。</p><p id="a6dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将很快为容器添加一个完整的实用部分。</p><p id="8f8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目前我已经完成了，在本系列的第二部分，我将讨论从<code class="du jt ju jv jw b">Docker Hub</code>、<code class="du jt ju jv jw b">DTR</code>和来自<code class="du jt ju jv jw b">Google</code>或<code class="du jt ju jv jw b">VMWare</code>的其他第三方注册中心的拉取和推送</p><p id="1fc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐编码:)</p></div></div>    
</body>
</html>