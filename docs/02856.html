<html>
<head>
<title>U-net Engineering using TPE Hyper-Parameter Optimization.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TPE超参数优化的U-net工程。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/u-net-engineering-5a84ee193aaf?source=collection_archive---------11-----------------------#2020-01-05">https://medium.com/analytics-vidhya/u-net-engineering-5a84ee193aaf?source=collection_archive---------11-----------------------#2020-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f058" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">语义分割</h2></div><h1 id="c964" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">TLDR</h1><p id="188f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">CNN U-net工程使用Tensorflow Tensorboard和TPE超参数优化。添加自定义层以增加CNN预测能力。所有代码都可以在这个小小的<a class="ae kl" href="https://github.com/boggis30/SpaceNetUnet" rel="noopener ugc nofollow" target="_blank">项目</a>中获得。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/1852ed2283a2945c4fb445351b43086f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShJDE9EjaGBbvbNjhfpstQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">基准和改进模型在测试图像上的输出</figcaption></figure><h1 id="e7af" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">动机</h1><p id="39c6" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">开发一个神经网络结构是一门艺术。有时它就像一个盲人摸象游戏。尽管对于相当多的问题已经有了许多先进的神经网络设计，但是每个问题都是独特的，并且没有理论预先提供指导，准确地说应该使用什么来实现最佳解决方案。在这篇文章中，我想分享我的想法和经验，用系统的方法解决这个问题。我试图利用两种方法:分析权重分布和超参数优化的TPE算法。在权重分析的基础上，我添加了一个自定义图层，以便在我认为缺乏概化能力的地方增加概化能力。我将这些方法应用到卫星影像的语义分割问题(建筑物足迹提取)中。</p><h1 id="b14d" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">关心的领域</h1><p id="6892" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">作为展示，我使用<a class="ae kl" href="https://github.com/SpaceNetChallenge/SpaceNetChallenge.github.io/blob/master/AOI_Lists/AOI_2_Vegas.md" rel="noopener ugc nofollow" target="_blank">太空网挑战拉斯维加斯的数据</a>。作为基线模型，我选择了U-net，就像CNN在微软Azure <a class="ae kl" href="https://azure.microsoft.com/en-us/blog/how-to-extract-building-footprints-from-satellite-images-using-deep-learning/" rel="noopener ugc nofollow" target="_blank">的博客文章</a>中提出的那样。我尝试对其设计进行更改，并在基线和改进架构的相同次数的学习迭代后比较验证集损失和视觉掩蔽。改进的体系结构有一些卷积滤波器作为附加定制层的超参数。这个超参数由树形结构的Parzen估计器(超点库)优化。</p><h1 id="37f5" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">改进的U形网设计</h1><h2 id="1e22" class="lc iy hi bd iz ld le lf jd lg lh li jh jy lj lk jj kc ll lm jl kg ln lo jn lp bi translated">权重分布分析</h2><p id="4274" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">神经网络通常被认为是一个黑箱。然而，也有一些研究试图揭示NNs的内部结构。他们中的一些人试图发现参数分布和外推能力之间的关系(例如<a class="ae kl" href="https://arxiv.org/pdf/1504.08291.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1504.08291.pdf</a>)。有一种观点认为，权重分布为高斯型分布的神经网络可能具有更好的性能。虽然这种说法没有得到严格的证明，但我的经验和直觉使我推测，权重分布形状平滑、看起来像高斯分布(或多或少)、逐代平缓变化的模型往往表现更好。让我们试着看看这如何应用于展示问题。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lq"><img src="../Images/94b449304716c1789a83159bd7a4cad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XP7myHKOhS1Y3QzuppmDaw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">U-net CNN架构</figcaption></figure><p id="ca54" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">原始的U-net有三个过滤器的最终conv层。每个过滤器必须能够在最终特征图上区分目标类别。每个过滤器只有65个参数的容量，这可能是不够的。让我们看看不同层的过滤器权重是如何分布的。</p><p id="e7bd" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">幸运的是，有Tensorflow tensorboard工具可以让我们在神经网络黑盒学习时看到内部发生的事情。它就像黑暗房间里的手电筒。Tensorboard有许多不错的功能。在这里，我们正在检查层权重直方图。下面是倒数第二个卷积层(conv2d_9)和最后一个卷积层(conv2d_10)的分布。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es lw"><img src="../Images/14bdf987b80c26628aaaba1f3a92a07b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*y2h7ztlAtCCMkBO9D0FQjA.png"/></div></figure><p id="e01e" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">最后一个和倒数第二个分别有195和2359808个参数。根据上面做出的权重分布形状假设，可以假定最后一个没有足够的能力在当前数据集上很好地概括。让我们努力改善这一点。<br/>分割模型试图将给定图像的每个像素分类为三类之一(背景/建筑物/建筑物边界)。因此，在最终的卷积运算中，只有65个参数对应于每个类别。改进的U-net增加了最终conv层中每个类的过滤器数量。<br/>每个类别有三组过滤器。在激活之前，对应于<br/>一类的过滤器在最终层中相加。让我们比较基线和改进模型的层权重分布。</p><p id="4e7d" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">基线:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es lw"><img src="../Images/e2fe3c89fc84d70f4099727996eb8868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*eCG8mJZR1WkAaA79ISvTcw.png"/></div></figure><p id="091b" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">改进型号:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div class="er es lw"><img src="../Images/0423737410741ae976095d48840e53e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DWJMP6kNAi9hJ83Pw5fJNw.png"/></div></figure><p id="79ce" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">可以推测，改良后的重量看起来没那么不堪一击，而且每一个时代都在发生变化。稍后我们将看到这是如何影响分割质量的。</p><h1 id="ee0f" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">超参数优化</h1><p id="7dd7" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">改进模型中的自定义层可以具有不同数量的过滤器。我试图用树形结构的Parzen估计器(<a class="ae kl" href="https://github.com/hyperopt/hyperopt" rel="noopener ugc nofollow" target="_blank"> hyperopt </a>库)找到最佳数量的过滤器。这是一种贝叶斯优化方法，是不可微随机问题的合理选择。它用随机抽样的参数变量计算目标函数，并试图以一种非常巧妙的方式估计后验目标函数分布。关于算法背景的更多信息可以在本文中找到:<a class="ae kl" href="https://papers.nips.cc/paper/4443-algorithms-for-hyper-parameter-optimization.pdf" rel="noopener ugc nofollow" target="_blank">https://papers . nips . cc/paper/4443-algorithms-for-hyper-parameter-optimization . pdf</a></p><p id="e25b" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">在我的例子中，我估计了损失函数分布与自定义层中滤波器数量的关系。I滤波器的型号为均匀(3，120)分布，基本上是均匀整数。三个过滤器相当于基线模型(每个类一个过滤器)。120个过滤器(每个类40个过滤器)是16G GPU内存的上限。如果滤波器数量的增加并没有改善损失函数，它可能以接近3的估计值结束。我在这个项目中使用Google Colab作为免费的GPU运行时环境。我运行100次损失函数评估，这是受Google GPU时间限制的。谷歌将GPU时间限制在4小时，以避免像加密货币挖掘这样肆无忌惮的运行时使用。虽然我没有在文档中找到明确的时间限制，但我在经验上遇到了四个小时的限制。值得一提的是，hyperopt可以选择在MongoDB中并行存储评估结果。因此，如果一个人需要更多的GPU时间，那么另一个免费的GPU运行时可以像Kaggle这样同时配对。如果对如何实现这一点感兴趣，我可以发布一个全面的指南，介绍如何只使用免费工具获得更多的GPU运行时间。如果你想了解更多，请在评论中告诉我。</p><p id="5212" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">下面是一个图，显示了远视运行以及各自的损耗和通道数之间的关系。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lx"><img src="../Images/054de45092d72f6c54667f4667db1c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9JQmLOiP-76cZD-q-NkAg.png"/></div></div></figure><p id="6c74" class="pw-post-body-paragraph jp jq hi jr b js lr ij ju jv ls im jx jy lt ka kb kc lu ke kf kg lv ki kj kk hb bi translated">正如可以观察到的，最好的结果是用57个通道实现的，即每类19个通道。让我们看看它如何从测试集中寻找一个示例图像。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/1852ed2283a2945c4fb445351b43086f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShJDE9EjaGBbvbNjhfpstQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">基准和改进模型在测试图像上的输出</figcaption></figure><h1 id="d711" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">结论</h1><p id="ac5f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在这篇短文中，我展示了深度学习模型工程和进化的一种有意识的方式。非常感谢您对任何缺失或下一步改进的反馈和想法。</p></div></div>    
</body>
</html>