<html>
<head>
<title>Simple Templates for Visualizing Time Series Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python可视化时间序列数据的简单模板</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-templates-for-visualizing-time-series-data-in-python-84cc9cf15443?source=collection_archive---------16-----------------------#2020-04-11">https://medium.com/analytics-vidhya/simple-templates-for-visualizing-time-series-data-in-python-84cc9cf15443?source=collection_archive---------16-----------------------#2020-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="21ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近在工作中经常使用时间序列数据集，这使得在数据探索过程中需要频繁的可视化，以至于我为它开发了一个例程。我想我应该分享我的过程，希望其他人也能从中受益。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/292ca2296dd7cba5dd165d447a42ef07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*9iu0xCLASg3opYOculsEIg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">前几天，我的同事请求帮助标记他的地块。</figcaption></figure><p id="c578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我假设读者对<a class="ae jp" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>、<a class="ae jp" href="http://matplotlib.org" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>和<a class="ae jp" href="http://numpy.org" rel="noopener ugc nofollow" target="_blank"> NumPy </a>有基本的了解，并且你已经使用这些库有一段时间了。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="1bdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A .进口</strong></p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="3e3c" class="kc kd hi jy b fi ke kf l kg kh">import os</span><span id="8d0c" class="kc kd hi jy b fi ki kf l kg kh">import pandas as pd<br/>import numpy as np<br/>import datetime</span><span id="6d5e" class="kc kd hi jy b fi ki kf l kg kh">import matplotlib.pyplot as plt<br/>import matplotlib.dates as mdates</span></pre><p id="5ed8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> B .数据集</strong></p><p id="09dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们使用的是时间序列数据集，所以数据集应该包含一个时间列，其中包含名为<code class="du kj kk kl jy b">Time</code>或<code class="du kj kk kl jy b">date</code>等的时间戳。，以及每个预测值的其他列。如果您没有要处理的时间序列数据集，您可以对模拟数据集运行以下代码(这也是我们将在本文中处理的数据集):</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="2358" class="kc kd hi jy b fi ke kf l kg kh">import pandas as pd<br/>import numpy as np</span><span id="f547" class="kc kd hi jy b fi ki kf l kg kh"># generate a range of dates <br/>date_rg = pd.date_range(start = '1/1/2020',<br/>                        end = '2/1/2020',<br/>                        freq = 'H')</span><span id="312c" class="kc kd hi jy b fi ki kf l kg kh"># for each column in our mock dataset, we will sample n random<br/># numbers within a certain range<br/>n = len(date_rg)</span><span id="8d9f" class="kc kd hi jy b fi ki kf l kg kh"># set this to your prefered number of columns excluding the time column<br/>m = 10</span><span id="4540" class="kc kd hi jy b fi ki kf l kg kh"># creating the dataset<br/>A = {'Time': date_rg}<br/>for j in range(m):<br/>    low = random.randint(0, 10) * 10<br/>    high = low + 10<br/>    A['Tag' + str(j)] = np.random.uniform(low=low, high=high, size=(n,))</span><span id="9e35" class="kc kd hi jy b fi ki kf l kg kh">df = pd.DataFrame(A)</span><span id="4182" class="kc kd hi jy b fi ki kf l kg kh"># saving the dataset<br/>df.to_csv('Basic_Time_Series_Dataset.csv', index = False)</span></pre><p id="3f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将数据集上传为pandas dataframe，并使用以下代码将time列设置为索引:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="f516" class="kc kd hi jy b fi ke kf l kg kh">import pandas as pd</span><span id="3d2b" class="kc kd hi jy b fi ki kf l kg kh"># Path to your dataset<br/>df_path = 'Basic_Time_Series_Dataset.csv'</span><span id="19f5" class="kc kd hi jy b fi ki kf l kg kh"># Uploading dataset<br/>df = pd.read_csv(df_path,<br/>                parse_dates = ['Time'],<br/>                index_col = ['Time']<br/>                )</span></pre><p id="827b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，pandas会将时间列中的值视为字符串。在<code class="du kj kk kl jy b">pd.read_csv</code>中设置<code class="du kj kk kl jy b">parse_date</code>将它们转换成<code class="du kj kk kl jy b"><a class="ae jp" href="https://docs.python.org/3/library/datetime.html" rel="noopener ugc nofollow" target="_blank">datetime</a></code>对象。这很重要，因为我们希望在绘制数据时考虑日期之间的持续时间。<code class="du kj kk kl jy b">index_col</code>将时间列设置为数据帧的索引。</p><p id="7720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果由于时间戳的格式而无法解析时间列，那么可以使用其他方法。首先，上传没有上述两个附加参数的数据集:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="759d" class="kc kd hi jy b fi ke kf l kg kh">df = pd.read_csv(df_path)</span></pre><p id="0190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，使用下列方法之一:</p><p id="4f49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">🌸方法一:<strong class="ih hj"> </strong>使用<code class="du kj kk kl jy b">pd.to_datetime</code> <a class="ae jp" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html" rel="noopener ugc nofollow" target="_blank">🔗</a></p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="d22e" class="kc kd hi jy b fi ke kf l kg kh">df.index = pd.to_datetime(df['Time'])</span></pre><p id="4412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">🌸方法二:<strong class="ih hj"> </strong>使用<code class="du kj kk kl jy b">datetime.strptime</code> <a class="ae jp" href="https://www.journaldev.com/23365/python-string-to-datetime-strptime" rel="noopener ugc nofollow" target="_blank">🔗</a></p><p id="f817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是一个非常有用的模块，它提供了处理日期和时间的类。</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="cd47" class="kc kd hi jy b fi ke kf l kg kh">import datetime</span><span id="f0cc" class="kc kd hi jy b fi ki kf l kg kh">df.index = df['Time'].apply(<br/>    lambda x: datetime.datetime.strptime(x, '%Y-%m-%d %H:%M:%S')<br/>)</span></pre><p id="6668" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要做的下一件事是从数据帧中删除时间列:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="ec45" class="kc kd hi jy b fi ke kf l kg kh">df.drop('Time', axis = 1, inplace = True)</span></pre><p id="17d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保修改就地完成，这样我们就不必给df重新分配数据帧的新版本。将<code class="du kj kk kl jy b">axis</code>设置为1告诉该方法沿着列搜索一个名为“Time”的值。</p><p id="4387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du kj kk kl jy b">df.head()</code>查看数据框的前五行:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es km"><img src="../Images/0421e79219ad173ffe5e8732779766e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEANtZ9YJHEY6Da87qYeKQ.png"/></div></div></figure><p id="14d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> C .模板</strong></p><p id="a579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望将生成的图形保存在一个公共文件夹中，并且希望仅在尚未创建文件夹时才创建该文件夹，例如第一次创建时:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="26d0" class="kc kd hi jy b fi ke kf l kg kh">import os</span><span id="997c" class="kc kd hi jy b fi ki kf l kg kh">outpath = 'figs'<br/>if not os.path.exists(outpath): <br/>    if not os.path.exists(outpath):<br/>        os.mkdir(outpath)</span></pre><p id="3c2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将为每个图形命名一个唯一生成的名称，这样新图形在保存时不会替换旧图形。为此目的创建时间戳是一个很好的解决方案:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="045f" class="kc kd hi jy b fi ke kf l kg kh">import datetime</span><span id="c51e" class="kc kd hi jy b fi ki kf l kg kh">TS = datetime.datetime.now().strftime('%Y%m%d%H%M%S')</span></pre><p id="192d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kj kk kl jy b">datetime.datetime.now()</code>返回代表当前时间的datetime对象。<code class="du kj kk kl jy b">strftime</code>将日期时间对象转换成指定<a class="ae jp" href="https://www.journaldev.com/23365/python-string-to-datetime-strptime" rel="noopener ugc nofollow" target="_blank">格式</a>的字符串。将所有这些放在一起，我们有以下基本模板来保存您自动生成的每个图形:</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="3e81" class="kc kd hi jy b fi ke kf l kg kh">import matplotlib.pyplot as plt</span><span id="3af9" class="kc kd hi jy b fi ki kf l kg kh">plt.figure()</span><span id="6ba6" class="kc kd hi jy b fi ki kf l kg kh">df.plot()</span><span id="3577" class="kc kd hi jy b fi ki kf l kg kh">TS = datetime.datetime.now().strftime('%Y%m%d%H%M%S')<br/>fname = '%s.png' % TS<br/>plt.savefig(os.path.join(outpath, fname), bbox_inches = 'tight')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kr"><img src="../Images/0351db6402d75c80549449be6585d06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AjIhX2ZiU0hPbBdVN0zrg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">一个简单的情节。</figcaption></figure><p id="d619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kj kk kl jy b">plot</code>是<code class="du kj kk kl jy b">pandas.DataFrame</code>的一种方法，它可以让你快速绘制出数据框中任何可用的数据。默认情况下，该函数在后端使用matplotlib，因此您必须包含常规导入才能正常工作。您还可以使用许多参数来快速调整绘图的外观，例如使用元组<code class="du kj kk kl jy b">figsize</code>来设置绘图的维度，或者如果您想要以对数比例绘图，则使用布尔值<code class="du kj kk kl jy b">logy</code>。文档列出了一堆你可以使用的其他参数。在从<code class="du kj kk kl jy b">df</code>调用<code class="du kj kk kl jy b">plot</code>后，您还可以使用<code class="du kj kk kl jy b">pyplot</code>功能进一步定制您的图形，如设置标题、刻度标签等。</p><p id="dbfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就个人而言，我喜欢使用<code class="du kj kk kl jy b">pyplot</code>函数而不是<code class="du kj kk kl jy b">df.plot</code>函数，因为它给了我更多的灵活性。因此，我向您展示了一些代码模板，其中包含我在可视化时间序列数据集时通常使用的所有常见定制:</p><p id="78e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📈<strong class="ih hj">模板1 </strong></p><p id="cb72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绘制数据帧子集的简单代码，包括标题和图例。您可以在第一行的<code class="du kj kk kl jy b">df_tmp</code>处设置要可视化的子集。</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="22b7" class="kc kd hi jy b fi ke kf l kg kh">df_tmp = df.iloc[:, 1:5]</span><span id="aea2" class="kc kd hi jy b fi ki kf l kg kh">plt.figure(figsize = (20, 5))</span><span id="124e" class="kc kd hi jy b fi ki kf l kg kh">for j in df_tmp:<br/>    X = df_tmp.index<br/>    Y = df_tmp[j].values<br/>    plt.plot(X, Y, label = j)<br/>    <br/>plt.title('A Simple Plot')<br/>plt.legend(loc = 'upper left')</span><span id="a3df" class="kc kd hi jy b fi ki kf l kg kh">TS = datetime.datetime.now().strftime('%Y%m%d%H%M%S')<br/>fname = '%s.png' % TS<br/>plt.savefig(os.path.join(outpath, fname), bbox_inches = 'tight')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ks"><img src="../Images/f282290d543e078550acfda72902899f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMES14yGNCu_Xof8eBMP3w.png"/></div></div></figure><p id="e503" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📈<strong class="ih hj">模板2 </strong></p><p id="c7ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个模板使用了<a class="ae jp" href="https://realpython.com/python-matplotlib-guide/#understanding-pltsubplots-notation" rel="noopener ugc nofollow" target="_blank">面向对象的方法</a>。这个方法给了我们进一步定制x标签记号的灵活性(这里有很好的资源:<a class="ae jp" href="https://brohrer.github.io/matplotlib_ticks.html" rel="noopener ugc nofollow" target="_blank">🔗</a> <a class="ae jp" href="https://www.earthdatascience.org/courses/use-data-open-source-python/use-time-series-data-in-python/date-time-types-in-pandas-python/customize-dates-matplotlib-plots-python/" rel="noopener ugc nofollow" target="_blank">🔗</a>)。与上一个模板相比，这个模板的主要改进是它将x轴上的主要刻度设置为每1周一次，将次要刻度设置为1天一次。</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="79c3" class="kc kd hi jy b fi ke kf l kg kh">import matplotlib.dates as mdates</span><span id="b75a" class="kc kd hi jy b fi ki kf l kg kh">df_tmp = df.iloc[:, 1:5]</span><span id="b62e" class="kc kd hi jy b fi ki kf l kg kh">fig, ax = plt.subplots(figsize = (20, 5))</span><span id="720b" class="kc kd hi jy b fi ki kf l kg kh">for j in df_tmp:<br/>    X = df_tmp.index<br/>    Y = df_tmp[j].values<br/>    ax.plot(X, Y, label = j)</span><span id="b199" class="kc kd hi jy b fi ki kf l kg kh">ax.legend(loc = 'upper right')</span><span id="aa13" class="kc kd hi jy b fi ki kf l kg kh"># Set title and labels for axes<br/># Set the limits of the x-axis<br/># Set the limits of the y-axis so that the legend would not overlap with the plots<br/>ax.set(xlabel = 'Time',<br/>       ylabel = 'Values',<br/>       title = 'A Simple Plot',<br/>       xlim = [df_tmp.index[0], df_tmp.index[-1]],<br/>       ylim = [ax.get_yticks()[0], ax.get_yticks()[-1] + 30]<br/>      )</span><span id="728a" class="kc kd hi jy b fi ki kf l kg kh"># Define the date format<br/>date_form = mdates.DateFormatter("%m-%d-%y")<br/>ax.xaxis.set_major_formatter(date_form)</span><span id="4ccc" class="kc kd hi jy b fi ki kf l kg kh"># Ensure a major tick for each week<br/>ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1))<br/># Add minor ticks representing the days<br/>ax.xaxis.set_minor_locator(mdates.DayLocator())<br/># rotate the labels 90 degrees<br/>ax.tick_params( axis="x", labelrotation = 90)</span><span id="05d5" class="kc kd hi jy b fi ki kf l kg kh">TS = datetime.datetime.now().strftime('%Y%m%d%H%M%S')<br/>fname = '%s.png' % TS<br/>plt.savefig(os.path.join(outpath, fname), bbox_inches = 'tight')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kt"><img src="../Images/9a05af9b3a57c612919e26da3504b8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdCSR7t185Q4ULm-9oGZkg.png"/></div></div></figure><p id="b4b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">📈<strong class="ih hj">模板3 </strong></p><p id="6e47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在单独的图中可视化每个时间序列。</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="5b5d" class="kc kd hi jy b fi ke kf l kg kh">df_tmp = df.iloc[:, 1:5]</span><span id="46c0" class="kc kd hi jy b fi ki kf l kg kh"># We are going to plot each column on a separate plot<br/>r = df_tmp.shape[1]</span><span id="e0c8" class="kc kd hi jy b fi ki kf l kg kh"># pass r in plt.subplots to set the number of plots in our figure<br/>fig, ax = plt.subplots(r, 1, figsize = (20, r * 4))</span><span id="c320" class="kc kd hi jy b fi ki kf l kg kh"># adjust distances between each plot in the figure<br/>fig.tight_layout(pad = 10)</span><span id="0b49" class="kc kd hi jy b fi ki kf l kg kh"># <br/>date_form = mdates.DateFormatter("%y-%m-%d %H")</span><span id="8e6f" class="kc kd hi jy b fi ki kf l kg kh"># when we create more than 1 subplots, a numpy array of axes objects is returned<br/># we access each using the counter i<br/>i = 0<br/>for j in df_tmp:<br/>    X = df_tmp.index<br/>    Y = df_tmp[j].values<br/>    ax[i].plot(X, Y, label = j)<br/>    <br/>    # all the common customizations<br/>    ax[i].set(xlabel = 'Time',<br/>       ylabel = 'Values',<br/>       title = j,<br/>       xlim = [df_tmp.index[0], df_tmp.index[-1]],<br/>       ylim = [ax[i].get_yticks()[0], ax[i].get_yticks()[-1]]<br/>      )<br/>    ax[i].xaxis.set_major_formatter(date_form)<br/>    ax[i].xaxis.set_major_locator(mdates.WeekdayLocator(interval=1))<br/>    ax[i].xaxis.set_minor_locator(mdates.DayLocator())<br/>    ax[i].tick_params( axis="x", labelrotation = 90)<br/>    <br/>    i += 1</span><span id="e328" class="kc kd hi jy b fi ki kf l kg kh"># Set main title<br/>fig.suptitle('Individual Time Series Visualized', position = (0.5, 0.98), fontsize = 24)</span><span id="e9cf" class="kc kd hi jy b fi ki kf l kg kh">TS = datetime.datetime.now().strftime('%Y%m%d%H%M%S')<br/>fname = '%s.png' % TS<br/>plt.savefig(os.path.join(outpath, fname), bbox_inches = 'tight')<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ku"><img src="../Images/0de2bafd117540179888d4a829de049b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYh6P1725emff0gi8snNxA.png"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="5dcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，暂时就这样了。当我想出新的模板时，我会经常更新这个帖子。希望对你有帮助！:-)</p></div></div>    
</body>
</html>