<html>
<head>
<title>Whatsapp Chat Analysis using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的Whatsapp聊天分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/whatsapp-chat-analysis-using-python-88123e63c8ae?source=collection_archive---------4-----------------------#2020-01-12">https://medium.com/analytics-vidhya/whatsapp-chat-analysis-using-python-88123e63c8ae?source=collection_archive---------4-----------------------#2020-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="116f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Whatsapp已经迅速成为世界上最受欢迎的文本和语音信息应用。专注于跨平台消息传递，每月活跃用户超过15亿，这使其成为全球最受欢迎的移动信使应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f7dbbdda8c25dd99721cb9dec04bd5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiQ7tDVAvdqc_2PuzBtTPA.jpeg"/></div></div></figure><p id="2d10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据Whatsapp官方统计，截至2018年5月，Whatsapp用户每天发送650亿条消息。平均每分钟有2900万条WhatsApp信息被发送。</p><p id="97c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将学习如何使用Python及其库开发我们自己的Whatsapp聊天分析器。</p><h1 id="39b4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">导入必要的库</h1><p id="7a82" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们将使用:</p><p id="289c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1) <strong class="ih hj"> Regex(re) </strong>根据特定模式提取和操作字符串</p><p id="a10c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2) <strong class="ih hj">熊猫</strong>进行分析</p><p id="f190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3) <strong class="ih hj"> Matplotlib </strong>进行可视化</p><p id="093d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4) <strong class="ih hj">表情符号</strong>处理表情符号</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="fd92" class="kx jq hi kt b fi ky kz l la lb">import re<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import emoji</span></pre><h1 id="c647" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从哪里获取数据</h1><p id="6ef1" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">第一步:进入你想分析的Whatsapp聊天</p><p id="ead7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:点击右上角的3个点</p><p id="b3b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三步:选择导出聊天选项并将其发送给自己</p><p id="af86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第四步:下载并开始探索</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="bcf1" class="kx jq hi kt b fi ky kz l la lb">file = open(r'./WhatsApp Chat with Manish AG.txt',mode='r',encoding="utf8")<br/>data = file.read()<br/>file.close()<br/>data</span></pre><p id="a9ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lc">注意:在导出数据时，避免包含媒体文件，因为如果媒体文件的数量大于某个数字，则不会导出所有媒体文件。</em></p><p id="5c83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将我们的聊天内容存储在我们的<strong class="ih hj">数据</strong>变量中之后，我们将决定聊天内容的格式</p><p id="a98e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的数据看起来像这样:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="6b14" class="kx jq hi kt b fi ky kz l la lb">12:24 - Suyash: Hey\n03/01/2020, 12:25 - Manish AG: Hello\n03/01/2020, 12:26 - Manish AG: This message was deleted\n03/01/2020, 12:49 - Suyash: You deleted this message\n03/01/2020, 13:01 - Manish AG: &lt;Media omitted&gt;\n</span></pre><p id="8080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从计算每个发件人的邮件数量开始。为此，我们需要定义一个regex模式，将信使姓名与文本数据分开。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="5963" class="kx jq hi kt b fi ky kz l la lb">pattern = re.compile('\d+:\d+\s+-\s+([a-zA-Z0-9]+\s?[a-zA-Z0-9]+\s?[a-zA-Z0-9]+\s?):\s+')<br/>messengers = re.findall(pattern,data)</span></pre><p id="2372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们使用regex的<strong class="ih hj"> () </strong>符号对所需的messenger名称进行了分组。()内的图案和符号的大小可以根据联系人的姓名进行更改。</p><p id="d098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要理解这个正则表达式模式是如何设计的，需要正则表达式符号的基本知识。供参考:<a class="ae ld" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">https://regex101.com/</a></p><h1 id="49bd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">每个用户的邮件数量</h1><p id="017b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">统计每个发送者的消息数量，并将结果存储在字典中。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="6e72" class="kx jq hi kt b fi ky kz l la lb">count_messages={}<br/>for each in messengers:<br/>    if each in count_messages.keys():<br/>        count_messages[each]+=1<br/>    else:<br/>        count_messages[each]=1<br/>count_messages</span></pre><p id="cdc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="a5f8" class="kx jq hi kt b fi ky kz l la lb">{'Suyash': 387, 'Manish AG': 321}</span></pre><p id="11a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了分别获取消息，我们将对之前用来获取发件人姓名的regex模式执行拆分操作。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="c978" class="kx jq hi kt b fi ky kz l la lb">messages_split = pattern.split(data)<br/>messages_split[9:11]</span></pre><p id="79c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="94bb" class="kx jq hi kt b fi ky kz l la lb">['Suyash', 'Okay\n18/11/2017, ']</span></pre><h1 id="2b48" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">清除消息和创建数据帧</h1><p id="6049" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">清理消息对于获取数据非常重要，在这些数据上可以在将来执行各种nlp任务。</p><p id="db36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lc"> messages_split </em>变量包含发件人姓名，后跟他的消息作为下一个索引。因此，我们将来自<em class="lc"> messages_split </em>的字符串追加到一个新列表中，该字符串出现在messneger name旁边的索引处。消息按用户顺序附加在列表中。首先，来自一个用户的所有消息将被追加，然后是来自其他用户的消息。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="1de3" class="kx jq hi kt b fi ky kz l la lb">sep_msgs=[]<br/>for each in count_messages.keys():<br/>    for msg in range(len(messages_split)):<br/>        if each == messages_split[msg]:<br/>            sep_msgs.append(messages_split[msg+1])   #obtaining the message mentioned after sender along with dates</span><span id="53ff" class="kx jq hi kt b fi le kz l la lb">print(len(sep_msgs))   <br/>sep_msgs[7]</span></pre><p id="0d14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="ddfa" class="kx jq hi kt b fi ky kz l la lb">708<br/>'Waiting\n18/11/2017,'</span></pre><p id="a3fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的输出是交换的消息总数，它相当于<em class="lc"> count_messages </em>字典中的值之和。</p><p id="a81b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们存储在sep_msgs变量中的分离消息在末尾出现了不需要的<em class="lc">\ n【date】</em>。由于日期从0、1、2或3开始，因此我们对' \n0 '、' \n1 '、' \n2' &amp; '\n3 '执行拆分，并保存包含所需消息的拆分的第一个元素。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="8d9f" class="kx jq hi kt b fi ky kz l la lb">cleaned_sep_msg = []<br/>for each in sep_msgs:<br/>    if '\n0' in each:<br/>        cleaned_sep_msg.append(each.split('\n0'))<br/>    elif '\n1' in each:<br/>        cleaned_sep_msg.append(each.split('\n1'))<br/>    elif '\n2' in each:<br/>        cleaned_sep_msg.append(each.split('\n2'))<br/>    elif '\n3' in each:<br/>        cleaned_sep_msg.append(each.split('\n3'))</span><span id="27b8" class="kx jq hi kt b fi le kz l la lb">my_msg = []<br/>for each in cleaned_sep_msg:<br/>    my_msg.append(each[0])</span><span id="bac0" class="kx jq hi kt b fi le kz l la lb">print(len(my_msg))<br/>my_msg[7]</span></pre><p id="f53c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="44d8" class="kx jq hi kt b fi ky kz l la lb">707<br/>'Waiting'</span></pre><p id="26c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将消息存储在<em class="lc"> my_msg </em>变量中，但是我们注意到消息的数量现在减少了1。这是因为交换的最后一条消息的尾部没有跟随<em class="lc"> \n【日期】</em>，因此在执行分割时，不会考虑该消息。所以我们可以在变量<em class="lc"> my_msg </em>的末尾单独添加消息。</p><p id="9de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为<em class="lc"> messages_split </em>变量包含发件人姓名，后跟他的消息作为下一个索引。我们将检查倒数第二个索引，并在<em class="lc"> my_msg </em>变量中的适当位置添加遗漏消息。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="978a" class="kx jq hi kt b fi ky kz l la lb">for each in count_messages.keys():<br/>    if messages_split[-2] == each:<br/>        my_msg.insert(count_messages[each]-1,messages_split[-1])<br/>len(my_msg)</span></pre><p id="4444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="18fe" class="kx jq hi kt b fi ky kz l la lb">708</span></pre><p id="235d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样我们所有的信息都被捕捉到了。</p><h2 id="081f" class="kx jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">创建数据框架</h2><p id="30d8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在，在下面的代码中，我们将创建一个数据帧，以messengers作为列名，messages作为值。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="2518" class="kx jq hi kt b fi ky kz l la lb">who_sent_what = []<br/>prev = 0<br/>for each in count_messages.keys():<br/>    num = count_messages[each]<br/>    <br/>    nex = num+prev<br/>    messages = my_msg[prev:nex]<br/>    who_sent_what.append(messages)<br/>    prev = nex<br/>who_sent_what<br/>my_df=pd.DataFrame(who_sent_what)<br/>my_df = my_df.transpose()<br/>my_df.columns = [list(count_messages.keys())[0],list(count_messages.keys())[1]]</span></pre><p id="3d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们使用键和它们的值为每个messenger分隔了一个消息列表。'<em class="lc"> count_messages[each] </em>'包含来自用户的消息数量。我们使用该信息对<em class="lc"> my_msg </em>变量执行切片，变量<em class="lc"> who_sent_what </em>将是包含2个列表的列表，每个用户一次。</p><p id="1727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该列表稍后用于创建数据帧。</p><h1 id="e61c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">获得洞察力</h1><h2 id="17cb" class="kx jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">邮件已删除</h2><p id="7777" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们可以查看谁删除了多少邮件。这里我们需要使用'<em class="lc">你删除了这条消息</em> ' &amp; ' <em class="lc">这条消息被明确删除</em>，因为发送方&amp;接收方删除的消息没有类似的描述。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="1e95" class="kx jq hi kt b fi ky kz l la lb">suyash_deleted = my_df['Suyash'].value_counts()['You deleted this message']<br/>manish_deleted = my_df['Manish AG'].value_counts()['This message was deleted']<br/>print('Suyash deleted '+ str(suyash_deleted) + ' messages')<br/>print('Manish deleted '+ str(manish_deleted) +' messages')</span></pre><p id="d614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="287a" class="kx jq hi kt b fi ky kz l la lb">Suyash deleted 8 messages<br/>Manish deleted 4 messages</span></pre><h2 id="82ee" class="kx jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">表情符号计数</h2><p id="33cd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们还可以通过使用一个<em class="lc">表情库和定义一个从消息中提取所有用户表情的函数，来查看哪个用户最常使用哪个表情。我们将使用的函数定义如下。它将按列解析dataframe中的每个字符串，并返回一个表情列表。</em></p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="fa90" class="kx jq hi kt b fi ky kz l la lb">def extract_emojis(columnname):<br/>    emojis=[]<br/>    for string in my_df[columnname]:<br/>        my_str = str(string)<br/>        for each in my_str:<br/>            if each in emoji.UNICODE_EMOJI:<br/>                emojis.append(each)<br/>    return emojis</span></pre><p id="e11f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按用户创建表情数据帧，并提取每个人使用的前5个表情。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="ef4f" class="kx jq hi kt b fi ky kz l la lb">emoji_dict={}<br/>for keys in count_messages.keys():<br/>    print(keys)<br/>    emoji_dict[keys] = extract_emojis(keys)<br/>    emoji_df = pd.DataFrame(emoji_dict[keys])<br/>    print(emoji_df[0].value_counts()[:5])</span></pre><p id="e60f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="2f80" class="kx jq hi kt b fi ky kz l la lb">Suyash<br/>😂    92<br/>🏻    13<br/>😇    10<br/>🤣     7<br/>🐒     7<br/>Name: 0, dtype: int64<br/>Manish AG<br/>🤣    28<br/>😂    12<br/>😍    10<br/>😅     8<br/>🏻     6<br/>Name: 0, dtype: int64</span></pre><h2 id="47bf" class="kx jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">谁发送了更多的媒体消息</h2><p id="b53a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">由于我们在导入文件时没有包括媒体文件，因此它们在我们的数据帧中用“<em class="lc"> &lt;媒体省略&gt; </em>”表示。因此，我们可以查看谁发送了多少媒体文件。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="12ff" class="kx jq hi kt b fi ky kz l la lb">suyash_media = my_df['Suyash'].value_counts()['&lt;Media omitted&gt;']<br/>manish_media = my_df['Manish AG'].value_counts()['&lt;Media omitted&gt;']</span><span id="f510" class="kx jq hi kt b fi le kz l la lb">print('Suyash sent ' + str(suyash_media) + ' media files')<br/>print('Manish sent ' + str(manish_media) + ' media files')</span></pre><p id="30d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="b5bc" class="kx jq hi kt b fi ky kz l la lb">Suyash sent 79 media files<br/>Manish sent 32 media files</span></pre><h2 id="5bbe" class="kx jq hi bd jr lf lg lh jv li lj lk jz iq ll lm kd iu ln lo kh iy lp lq kl lr bi translated">一天中的哪个小时交换的消息最多？</h2><p id="fa5e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们将使用前面使用的相同regex模式从数据中获取日期，并通过使用regex的group方法来分隔小时值。Matplotlib用于可视化</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="b473" class="kx jq hi kt b fi ky kz l la lb">hour_pattern = '(\d+):\d+\s+-\s+\w+\s?\w+?\s?\w+\s?\w+:\s'<br/>hours = re.findall(hour_pattern,data)</span><span id="8742" class="kx jq hi kt b fi le kz l la lb">time = pd.DataFrame({'hours':hours})</span><span id="c3a1" class="kx jq hi kt b fi le kz l la lb">busy_hours = time['hours'].value_counts()</span><span id="1992" class="kx jq hi kt b fi le kz l la lb">busy_hours.sort_index(inplace=True)<br/>plt.axes([1,1,1,0.98])<br/>plt.grid(True)<br/>busy_hours.plot.bar()<br/>plt.xlabel('Hour')<br/>plt.ylabel('No. of Messages')<br/>plt.xticks(rotation=0)</span><span id="b30d" class="kx jq hi kt b fi le kz l la lb">plt.show()<br/>%matplotlib inline</span></pre><p id="ecbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/9ae8edc5abc67be95323315e53103312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*ZJ5x52Wtm04OdnqxYllV_Q.png"/></div></figure><p id="b4e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢你的阅读，希望你学到了新的有趣的东西！</p><p id="ed37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在LinkedIn上和我联系:<a class="ae ld" href="https://www.linkedin.com/in/suyash-gupta-9b247b154" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/</a>suya G10</p></div></div>    
</body>
</html>