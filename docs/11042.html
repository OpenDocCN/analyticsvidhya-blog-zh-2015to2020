<html>
<head>
<title>Python - Introduction to Natural Language Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python -自然语言处理简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-introduction-to-natural-language-processing-d5323b0f8fcd?source=collection_archive---------13-----------------------#2020-11-15">https://medium.com/analytics-vidhya/python-introduction-to-natural-language-processing-d5323b0f8fcd?source=collection_archive---------13-----------------------#2020-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6fe6264de7da225c74e54457eabafc91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xINIPCVv3ZAIQ_zt"/></div></div></figure><p id="817d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好，在这篇博文中我将介绍自然语言处理这个主题。自然语言处理是人工智能的一个子类。今天它被用于许多领域。语言翻译、自动文本翻译、自动语音和命令理解、通过搜索给定文本或单词找到所需结果、自动拼写纠正键盘、单词预测等等。</p><p id="7c80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博文中，我将只讲述我在Python中对一些文本进行自然语言处理工作的一部分。我会在我的下一篇博文中谈论另一部分。可以在这里获取完整代码:<a class="ae jo" href="https://github.com/minnela/IntroductionNaturalDataProcessing" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">https://github . com/minnela/IntroductionNaturalDataProcessing</strong></a></p><h1 id="63f1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak"> RegEx(正则表达式)</strong></h1><p id="42c0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">正则表达式是一种算法，可以很容易地在字符串中找到某个字符集。</p><p id="d67a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我想找到给定文本中的所有句子及其编号。首先获取文本:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c9a1" class="lb jq hi kx b fi lc ld l le lf">def getText():<br/>    file = open("hw01_FireFairies.txt")<br/>    data = file.read()<br/>    return data</span></pre><p id="0c16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后拆分成句子:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7638" class="lb jq hi kx b fi lc ld l le lf">def split_into_sentences(text):<br/>   text = text.lower()<br/>   sentences = re.split(r'(?&lt;!\w\.\w.)(?&lt;![A<strong class="kx hj">-</strong>Z][a<strong class="kx hj">-</strong>z]\.)(&lt;=\.|\?)\s', text)<br/>   return sentences</span></pre><p id="f070" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们看到一个正则表达式，我想解释一下它是如何工作的:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3d97" class="lb jq hi kx b fi lc ld l le lf"><strong class="kx hj">1)</strong> <strong class="kx hj">(?&lt;!\w\.\w.) -----&gt;</strong> "<strong class="kx hj">?&lt;!</strong>" This expression indicates a negative loop.</span><span id="7248" class="lb jq hi kx b fi lg ld l le lf">It ensured that an abbreviation term such as "one character, dot, another character, dot" is not perceived as a sentence due to dots. To give an example of this: "I like ice cream i.e. chocolate ice cream". Here "i.e."  abbreviation, was not taken as a sentence thanks to this regular expression.</span><span id="fc3f" class="lb jq hi kx b fi lg ld l le lf"><strong class="kx hj">2) (?&lt;![A-Z][a-z]\.) -----&gt;</strong> "<strong class="kx hj">?&lt;!</strong>" This expression indicates a negative loop.</span><span id="783e" class="lb jq hi kx b fi lg ld l le lf">This expression was put in order to avoid taking abbreviations starting with a capital letter and a lowercase letter as sentences. For example, "Mr." The abbreviation was not taken as a sentence.</span><span id="622d" class="lb jq hi kx b fi lg ld l le lf"><strong class="kx hj">3)(?&lt;=\.|\?)----&gt;</strong> "<strong class="kx hj">?&lt;=</strong>" This expression indicates a positive loop.</span><span id="9fce" class="lb jq hi kx b fi lg ld l le lf">This expression accepts the part up to the point or the question mark as a sentence and cuts off after the period.<br/></span><span id="f34d" class="lb jq hi kx b fi lg ld l le lf"><strong class="kx hj">4) \s ----&gt;</strong> space expression</span><span id="00d6" class="lb jq hi kx b fi lg ld l le lf">This expression says that a space must come after a period at the end of a sentence. For example there is a mail in the  text "cheapsite.com" and it does not take it as a sentence since the period is combined with both words.</span></pre><h1 id="0c0f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">创建单字和双字</strong></h1><p id="6b99" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们希望机器能够理解语言。对于语言分析，我们将文本中的单词一个接一个地或者两个或更多地分开。让我们想想你的电话键盘。当你输入信息时，它会自动完成你的句子，当你写错一个单词时，它会猜测你想写什么。为此，句子被分组。将单词放在一起，计算句子概率，让机器完成句子。这叫做n-gram。一克是一克。句子中的每一个单词都叫做单字。如果每个单词的前后都有一个单词，那么就产生了二元模型。比如我有一句“我要去上学了”。</p><p id="4273" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">单字:</strong>“我”、“我”、“去”、“去”、“学校”</p><p id="9189" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">二元组:</strong>"(我，我)"，"(我，去"，"去，到"，"到，学校"，"学校，。)"</p><p id="91bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了进行文本分析，我接受了点(。)作为一个单词，因为它在将文本拆分成句子时很重要。在找到二元模型和一元模型后，我们找到二元模型的概率来确定哪两组单词最常一起使用。</p><p id="ccf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要找出二元模型(I，am)的概率，</p><p id="a570" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">二元组总数(I，am) /一元组总数(I) </strong></p><p id="bf48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在python中，我创建了给定文本的一元模型、二元模型及其概率，如下所示:</p><p id="8d64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">创建二元模型:</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e966" class="lb jq hi kx b fi lc ld l le lf">def createBigram(data):<br/>    listOfBigrams = []<br/>    bigramCounts = {}<br/>    unigramCounts = {}<br/>    text = data.lower()<br/>    words= re.findall(r'\b[a<strong class="kx hj">-</strong>zA<strong class="kx hj">-</strong>Z]+|[.!?]', text)<br/><br/>    for i in range(len(words)):<br/>        if i &lt; len(words) - 1:<br/><br/>          listOfBigrams.append((words[i], words[i + 1]))<br/><br/>          if (words[i], words[i + 1]) in bigramCounts:<br/>              bigramCounts[(words[i], words[i + 1])] += 1<br/>          else:<br/>              bigramCounts[(words[i], words[i + 1])] = 1<br/><br/>        if words[i] in unigramCounts:<br/>            unigramCounts[words[i]] += 1<br/>        else:<br/>            unigramCounts[words[i]] = 1<br/><br/>    return words,listOfBigrams, unigramCounts, bigramCounts</span></pre><p id="5de9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">计算他们的概率:</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0989" class="lb jq hi kx b fi lc ld l le lf">def calcBigramProb(words,listOfBigrams, unigramCounts, bigramCounts):<br/>    listOfProbBigram = {}<br/>    listOfProbUnigram = {}<br/><br/>    for bigram in listOfBigrams:<br/>        word1 = bigram[0]<br/>        word2 = bigram[1]<br/>        listOfProbBigram[bigram] = (bigramCounts.get(bigram)) / (unigramCounts.get(word1))<br/><br/>    for unigram in words:<br/>        word = unigram<br/>        listOfProbUnigram[unigram]=(unigramCounts.get(word)) / len(words)<br/><br/><br/>    return listOfProbBigram, listOfBigrams,listOfProbUnigram,words</span></pre><p id="0433" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在有了二进制词组的可能性。我们可以在给定的文本中计算一个句子的概率。</p><p id="df1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">P(我要去上学)= P(我，是)。P(am，走了)。p(去，去)。警察(到学校)</p><p id="c678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的下一篇博客中，我将解释<strong class="is hj">平滑方法</strong>,该方法用于计算一个句子包含文本中没有的单词的概率。谢谢你看我的博客。:)</p></div></div>    
</body>
</html>