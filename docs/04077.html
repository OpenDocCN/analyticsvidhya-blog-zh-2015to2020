<html>
<head>
<title>Guide to Object Detection using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch进行物体探测的指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/guide-to-object-detection-using-pytorch-3925e29737b9?source=collection_archive---------2-----------------------#2020-03-04">https://medium.com/analytics-vidhya/guide-to-object-detection-using-pytorch-3925e29737b9?source=collection_archive---------2-----------------------#2020-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="21b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">#Part1 #day12 of #100daysofcode</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/96e227e6666838c91006214636cff513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*fxphsQWtfkuwqL4W0AMiZg.gif"/></div></figure><p id="8412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机视觉有很多应用。我们可以解决许多问题，并通过使用能够看到和处理它的机器来摆脱大量重复性的工作。在本文中，我们将讨论计算机视觉的一些应用，以及它们如何工作和如何实现。</p><h1 id="3a72" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">使用视频</strong></h1><p id="e53e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">对于实时动作和结果，我们必须处理视频数据。而视频是由帧组成的。我们将这些帧视为单个图像，并对其进行相应的处理。所以处理图像和视频是相似的。在处理一帧之后，我们将它组合起来以获得处理后的视频。我讨论这个是因为我们要处理实时物体检测。为了处理视频或图像数据，我们将使用<a class="ae ko" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCv </a>库。这是一个很棒的库，提供了很好的功能。</p><p id="c683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将讨论图像分类、目标定位和目标检测。这些是计算机视觉的一些应用。这些会让你对这个领域有更深刻的了解。</p><h1 id="86ce" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">图像分类</strong></h1><p id="cd57" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在分类中，任务是判断一个对象是否出现在图像中。例如:-我们想知道图像是狗还是猫。因此，我们训练一个图像分类器，它将预测图像属于哪一类。</p><h1 id="0a64" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">物体定位</strong></h1><p id="fcaf" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在定位中，任务是判断物体在图像中的位置。我们希望在对象周围绘制一个边界框。我们的模型不仅可以判断出图像是狗的，还可以预测图像中物体的坐标位置。这一次只处理一种类型的对象。</p><h1 id="e63d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">物体检测</strong></h1><p id="b805" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">如果我们的图像包含多个对象，并且我们想要检测它们，并且还想要知道它们在图像中的位置，那么该任务被称为对象检测。定位只处理单个对象，但是在对象检测中，我们有多个对象。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/36b7797ae799562d08f85ac18f94b3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GtIydeECbhuttnx-JaIUg.png"/></div></div></figure><p id="4608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们一步一步来:</p><ol class=""><li id="b15e" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">图像分类</li><li id="e6c1" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">本地化</li><li id="2d63" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">目标检测</li></ol><p id="b709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在PyTorch中实现这些解决方案，并详细讨论它们。在物体检测中，我们将使用迁移学习。有各种各样的架构可以用于迁移学习。我们只需要加载架构并下载权重。迁移学习节省时间和资源，因为我们不需要从头开始训练整个大型架构。</p><h1 id="692b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">各种CNN架构:</strong></h1><ol class=""><li id="f7f6" class="ku kv hi ih b ii kj im kk iq li iu lj iy lk jc kz la lb lc bi translated">LeNet</li><li id="5362" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">AlexNet</li><li id="e478" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">VGG</li><li id="a900" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">雷斯内特</li><li id="a25d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">开始</li></ol><h1 id="6cc1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">用于对象检测的数据集</h1><p id="0a8d" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><a class="ae ko" href="http://cocodataset.org/#home" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">可可</strong> </a></p><p id="7fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ko" href="http://host.robots.ox.ac.uk/pascal/VOC/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">帕斯卡VOC数据集</strong> </a></p><p id="6695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ko" href="http://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> ImageNet数据集</strong> </a></p><p id="f7a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ko" href="https://opensource.google/projects/open-images-dataset" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">打开图像数据集</strong> </a></p><h1 id="13e6" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">分类:-手写数字。</strong></h1><p id="03fb" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们训练一个模型，将一个给定的图像分为十类，并预测数字。MNIST数据集是非常著名的hello world数据集。这是一个标签清晰的数据集。它和PyTorch一起提供，所以我们可以直接调用它。让我们看一下它的实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ll"><img src="../Images/74c25a0b3bba4e0b2e367aef2b9741cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebJ29H5uae3V3zW-BxGCWw.png"/></div></div></figure><p id="417e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入PyTorch库。它被命名为PyTorch，但是当我们安装和导入它时，我们只使用Torch。我们导入的另一个库是<em class="lm"> torchvision </em>。它有许多预定义的函数，对于像我们这样的计算机视觉问题非常有用。之后，我们检查GPU是否存在。“cuda:0”表示GPU存在。接下来，我们定义了一些将在整个代码中使用的参数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ln"><img src="../Images/8de0e11f888ec3bba99d8fa377e8e38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqPAf25zNMpQgTwOUnVGxA.png"/></div></div></figure><p id="5f0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们定义了我们的数据加载器。我们正在使用<em class="lm"> torchvision </em>库下载MNIST数据集。MNIST数据集将被下载一次。<em class="lm"> DataLoader </em>非常有用，因为它批量返回数据。如果我们的数据集非常大，我们不能一次将所有数据加载到RAM中，那么数据加载器将只将所需的批次加载到RAM中。我们还定义了“转换”。它包含了我们想要在图像上执行的所有操作，如增强等。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lo"><img src="../Images/fb9051844c63293143dbef14c1260477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynA1daZ3-Itrz1HsGwXCjw.png"/></div></div></figure><p id="3d3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们检查一下我们的数据看起来怎么样。这也确认了数据被正确加载。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lp"><img src="../Images/92ffe79ba6bbfd301aa22e120e973a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_uyZgLoxxEtYBkc6Q4V4w.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/ae4743c046931f9c7ab34d0101b4781e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*nnECncldq3uTIwJjNg43jg.png"/></div></figure><p id="2d31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们已经定义了我们的模型。我们实现了一个继承神经网络的类网。模块类。我们需要覆盖forward()函数。上面的代码是不言自明的。这是一个小网络，但它很适合我们的问题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/2b2124aa76e349bfe8420ecda8a43252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*t9tTYcnpOAO5_LMQwc3mmQ.png"/></div></figure><p id="ccd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建了一个我们定义的模型类的对象。PyTorch风格的代码是pythonic式的，所以不像TensorFlow那样容易理解。我们还设置了优化器。为了看到模型的层和细节，我们简单的打印它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ls"><img src="../Images/e1bf149e5592d81ffb57c9430f16d58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQxDW4ffR3mzDZK0UjAk-g.png"/></div></div></figure><p id="77f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在它上面有一个函数，我们将用它来训练我们的模型。步骤很简单。我们向前通过我们的模型，计算损失，找到梯度和更新权重。在特定的时期之后，我们保存模型以备后用或将来进一步训练。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lt"><img src="../Images/432cf4c69d1b47caf89894752be90405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPy94ehvKtFXRhPxdjmw3w.png"/></div></div></figure><p id="6cbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">test()函数用于预测输出。在这种情况下，我们只需要向前传球，就能得到我们想要的结果。上面的代码很容易理解。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lu"><img src="../Images/34ace7ec6ff6fe4c18b6645c79028192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXQ-jSOrr8PxDLm37-BbQQ.png"/></div></div></figure><p id="e841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们只为2个时期训练我们的模型。除此之外的训练将会进一步提高成绩。我得到了大约94%的准确率，但如果你进一步训练，你可以很容易地得到大约97-98%的准确率。整个代码呈现在<a class="ae ko" href="https://github.com/karanjakhar/pytorch-programs/blob/master/digit%20recognition.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里</strong> </a>。你必须亲自尝试，做一些调整和实验来了解更多。</p><h1 id="34a1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">一个物体的定位</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lv"><img src="../Images/a93acaf09ac5de161f6b51a9656c5270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udYAHnpC6jsksGgntngtRQ.png"/></div></div></figure><p id="e0ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在分类中，我们还必须预测对象是否出现在图像中，但是在定位中，我们必须预测对象出现在图像中的什么位置。现在我们需要输出四个额外的值，它们将是对象周围边界框的坐标。我们还将预测图像中是否包含物体。所以我们总共要输出五个值。我们需要最小化两个损失函数，一个是二元损失，一个是回归损失。我们将在下一篇文章中实现它，并进行更详细的讨论。</p><h1 id="18a1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">物体检测</strong></h1><p id="4a47" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">现在，我们想检测图像中的不同对象，还想知道它们在图像中的位置。这变得有点困难，但我们已经在这个问题上做了一些伟大的工作。就像我们有YOLO(你只看一次)。YOLO的概念很简单。将图像分成网格，每个网格输出是否是物体的中心。如果它是对象的中心网格，那么它预测对象的边界框。我们通过使用具有适当步幅的卷积层来实现这一点。我们将在本文的下一部分详细讨论。在这篇文章中，我只想介绍一下YOLO。在下一部分，我们也将在PyTorch中实现它并训练它。下面是YOLO的建筑方案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lw"><img src="../Images/44ee9d5b8f4cf450c876a720bd1a8837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9Cc2ePfKg9fuHkm-x8bEg.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/d24a12433670a382dd04fcdf999ff573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*9Xf_kTeJr6M5_7EGjiswPw.png"/></div></figure><h1 id="ee7e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论</h1><p id="5d51" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们讨论了图像分类、定位和目标检测。用PyTorch库在python中实现图像分类。在下一部分，我们将实现定位和物体检测。</p><h1 id="7cad" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">快乐学习！！！</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ly lz l"/></div></figure></div></div>    
</body>
</html>