<html>
<head>
<title>Minimax Algorithm in Tic-Tac-Toe: Adversarial Search Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">井字游戏中的极大极小算法:对抗性搜索示例</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/minimax-algorithm-in-tic-tac-toe-adversarial-search-example-702c7c1030eb?source=collection_archive---------6-----------------------#2020-12-16">https://medium.com/analytics-vidhya/minimax-algorithm-in-tic-tac-toe-adversarial-search-example-702c7c1030eb?source=collection_archive---------6-----------------------#2020-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f59b96e3191d46ec9a25c261fcc3f994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdinTUyf-YWOMLSISObfSA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@freeche" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Kvistholt</strong></a><strong class="bd iv"/><a class="ae iu" href="https://unsplash.com/photos/oZPwn40zCK4" rel="noopener ugc nofollow" target="_blank"><strong class="bd iv">Unsplash</strong></a></figcaption></figure><p id="52d0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我那时大约八岁。我们会和比我大五岁的叔叔玩井字游戏，每次他不是赢就是平。我不怪他伤了我的自尊，但我在那个年纪一定是挺傻的。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="4c9b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">今天，经过多年的学习和一年半的大学生活，我终于可以说，我实现了一个算法，可以玩井字游戏，从来没有输过。它被称为<strong class="iy hj"> Minimax决策规则</strong>，这是一种<strong class="iy hj">对抗性搜索</strong>的类型，意味着这个算法面对的是一个正在与机器对抗的对手。例如，在井字游戏中，人工智能与人类对弈；AI还<strong class="iy hj">知道游戏的完整状态</strong>(它可以看到整个情况，不像扑克的游戏)，这是Minimax算法的一个要求。</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/39a2e44a9c688e3b53c9633479885942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*3TVQr_FLLL48eiOxxV4bOA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自我的GitHub的演示<a class="ae iu" href="https://github.com/dtemir/harvard-CS50AI" rel="noopener ugc nofollow" target="_blank">回购</a></figcaption></figure><p id="67af" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Minimax使用每个状态的表示，将一个<strong class="iy hj">获胜条件</strong>标记为1，将<strong class="iy hj">失败情况</strong>标记为-1，将<strong class="iy hj">中立条件</strong>标记为0。因此，进入细节可能会让它听起来很复杂(至少对我来说是这样)，但让我们想象一下你和自己玩井字游戏<strong class="iy hj">的情况。你可能想要<strong class="iy hj">最大化</strong>你的分数<strong class="iy hj">最小化</strong>你的组件分数(也是你，哈哈)，因此得名<strong class="iy hj"> Minimax </strong>。当你为另一方比赛时，选择最大化你的分数和最小化你对手的分数的动作。你最终可能会做的是，你可能会开始<strong class="iy hj">考虑你可以做的每一个动作</strong>和你的对手可能做的<strong class="iy hj">动作</strong>。计算每一个可能的结果是Minimax的基石，因为这有助于人工智能选择最佳行动，这对对手来说也是最糟糕的。</strong></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="ebca" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">好吧，如果这对你来说还不够专业，让我们更深入地研究一下。我们需要为Minimax算法实现的函数是<code class="du kg kh ki kj b">player</code>来确定哪个玩家当前正在采取行动(X或O)；<code class="du kg kh ki kj b">actions</code>查询哪些动作还可用(自由单元格)；<code class="du kg kh ki kj b">result</code>用提议的动作构建一个<strong class="iy hj">假设</strong>板，这意味着它是一个完整的副本，我们可以在上面放置我们的潜在动作(它必须是一个副本，以便在不修改原始动作的情况下探索所有可用状态)；<code class="du kg kh ki kj b">winner</code>确定游戏是否结束，谁是赢家；<code class="du kg kh ki kj b">terminal</code>看比赛是平局还是有人赢了；<strong class="iy hj">重要</strong>、<strong class="iy hj">、</strong>、<code class="du kg kh ki kj b">utility</code>计算<strong class="iy hj">假想</strong>棋盘的一个动作是导致<strong class="iy hj">赢</strong>还是<strong class="iy hj">输</strong>(minimax的面包和黄油)；最后的<code class="du kg kh ki kj b">minimax</code>就是拿一块板，应用上面提到的所有函数，并返回<strong class="iy hj">最优移动</strong>。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="f715" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">所以，让我们回顾一下这些函数的实现。听起来工作量很大，但是大部分花费<strong class="iy hj">不超过10行代码</strong>。给定一个棋盘(这是一个简单的2D列表3x3)，函数<code class="du kg kh ki kj b">player</code>告诉我们<strong class="iy hj">该轮到谁了</strong>。我们这里的目标是计算x和o的数量，找出哪个比另一个小，这意味着该轮到它们采取行动了。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="1d6d" class="ko kp hi kj b fi kq kr l ks kt">def player(board):<br/>    Xs = 0<br/>    Os = 0<br/>    # simply iterate over the given 2D array and calculate how many Xs and Os are there<br/>    for y_axis in board: <br/>        for x_axis in y_axis:<br/>            if x_axis == X:<br/>                Xs += 1<br/>            elif x_axis == O:<br/>                Os += 1<br/>    # if numer of Xs is smaller or equal to Os, it is a turn for an X because it always goes first<br/>    if Xs &lt;= Os: <br/>        return X<br/>    else:  # otherwise it is a turn for an O<br/>        return O</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="58ef" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对于给定的电路板，函数<code class="du kg kh ki kj b">actions</code>告诉我们<strong class="iy hj">可以采取什么行动</strong>。我们在这里的目标是保存一组元组<code class="du kg kh ki kj b">(i, j)</code>，其中<code class="du kg kh ki kj b">i</code>是的行，<code class="du kg kh ki kj b">j</code>是表示空单元格的棋盘列。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="5697" class="ko kp hi kj b fi kq kr l ks kt">def actions(board):<br/>    possible_actions = set() # set is used just to be sure there will only be unique tuples</span><span id="fb88" class="ko kp hi kj b fi ku kr l ks kt">    for y, y_axis in enumerate(board):<br/>        for x, x_axis in enumerate(y_axis):<br/>            # initial implementation puts variable EMPTY in all cells, which is equal to None<br/>            if x_axis == EMPTY: <br/>                possible_actions.add((y, x))</span><span id="d8c2" class="ko kp hi kj b fi ku kr l ks kt">    return possible_actions</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="2173" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">给定一个棋盘和一个动作(这是我们应该填写的单元格的元组)，函数<code class="du kg kh ki kj b">result</code>返回棋盘的深度副本。什么是<strong class="iy hj">深度复制</strong>？这是一个完全相同的副本，但是是一个<strong class="iy hj">独立的</strong>对象，不与原始对象共享任何指针。我们需要一个深入的副本来探索我们可以采取什么行动来找到最大化或最小化分数的状态，而不修改原件。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="0ab5" class="ko kp hi kj b fi kq kr l ks kt">def result(board, action):<br/>    if len(action) != 2:  # check if given action is a tuple of two elements<br/>        raise Exception("result function: incorrect action")<br/>    # check if given action is within the boundaries of the board (3x3)<br/>    if action[0] &lt; 0 or action[0] &gt; 2 or action[1] &lt; 0 or action[1] &gt; 2:<br/>        raise Exception("result function: incorrect action value")</span><span id="7233" class="ko kp hi kj b fi ku kr l ks kt">    y, x = action[0], action[1]<br/>    board_copy = copy.deepcopy(board) # using the imported library 'copy'</span><span id="0ace" class="ko kp hi kj b fi ku kr l ks kt">    # check if action is already there (even though we will call 'actions' before it)<br/>    if board_copy[y][x] != EMPTY:<br/>        raise Exception("suggested action has already been taken")<br/>    else:  # here we use the player function to know which letter to put in the copy<br/>        board_copy[y][x] = player(board)</span><span id="e00c" class="ko kp hi kj b fi ku kr l ks kt">    return board_copy</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="5aa1" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><code class="du kg kh ki kj b">winner</code>函数，给定一个棋盘，<strong class="iy hj">告知是否有赢家</strong>。只在你和我之间，试图弄清楚如何写这个是一个忙乱的经历(当我想起它是一个3x3的网格时，它变得更好了)。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="7d48" class="ko kp hi kj b fi kq kr l ks kt">def winner(board):<br/>    # Since the board is always 3x3, I believe this approach is reasonable<br/>    for y in range(3):<br/>        # Check horizontal lines<br/>        if (board[y][0] == board[y][1] == board[y][2]) and (board[y][0] != EMPTY):<br/>            return board[y][0]<br/>        # check vertical lines<br/>        if (board[0][y] == board[1][y] == board[2][y]) and (board[0][y] != EMPTY):<br/>            return board[0][y]</span><span id="8629" class="ko kp hi kj b fi ku kr l ks kt">    # Check diagonals<br/>    if (board[0][0] == board[1][1] == board[2][2]) or (board[0][2] == board[1][1] == board[2][0]) \<br/>            and board[1][1] != EMPTY:<br/>        return board[1][1]</span><span id="827c" class="ko kp hi kj b fi ku kr l ks kt">    return None</span></pre><p id="f99c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">给定一个棋盘，函数<code class="du kg kh ki kj b">terminal</code>告知游戏是否结束。真的。就是这样，lol。<strong class="iy hj">重要</strong>，它很有用，因为我们想知道我们游戏的预期状态是否已经结束，这就是为什么它是一个独立的功能。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="84e2" class="ko kp hi kj b fi kq kr l ks kt">def terminal(board):<br/>    if winner(board) == X or winner(board) == O: # check if there is a winner<br/>        return True<br/>    # check if there is a tie (if no cells left and neither X nor O won)<br/>    elif EMPTY not in board[0] and EMPTY not in board[1] and EMPTY not in board[2]:<br/>        return True<br/>    else: # otherwise return that the game is still going on<br/>        return False</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="6d9f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><code class="du kg kh ki kj b">utility</code>函数，给定一个棋盘，<strong class="iy hj">通过返回1、-1或0来告诉X或O </strong> <strong class="iy hj">是否赢了</strong>。<strong class="iy hj">重要的</strong>，它在选择Minimax中的最优选择时很有用，因为它告诉我们给定的状态是赢还是输。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="d789" class="ko kp hi kj b fi kq kr l ks kt">def utility(board):<br/>    if winner(board) == X:<br/>        return 1<br/>    elif winner(board) == O:<br/>        return -1<br/>    else:<br/>        return 0</span></pre><p id="4c12" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">最后，<code class="du kg kh ki kj b">minimax</code>函数，给定一个棋盘，<strong class="iy hj">返回当前玩家的最佳行动</strong>。该算法首先检查棋盘是否是<code class="du kg kh ki kj b">terminal</code>，这意味着游戏已经结束，不能采取任何行动。如果没有，它接着检查该轮到谁采取行动。<strong class="iy hj">重要</strong>，如果AI玩<strong class="iy hj"> X </strong>，它会尝试从所有最大值中选出最好的最小值；同样，如果人工智能为<strong class="iy hj">或</strong>比赛，它会尝试从最小值中选出最差的最大值。</p><pre class="kc kd ke kf fd kk kj kl km aw kn bi"><span id="4dec" class="ko kp hi kj b fi kq kr l ks kt">def minimax(board):<br/>    if terminal(board):<br/>        return None</span><span id="6968" class="ko kp hi kj b fi ku kr l ks kt">    if player(board) == X:<br/>        score = -math.inf<br/>        action_to_take = None</span><span id="d44c" class="ko kp hi kj b fi ku kr l ks kt">        for action in actions(board):<br/>            min_val = minvalue(result(board, action))</span><span id="43ef" class="ko kp hi kj b fi ku kr l ks kt">            if min_val &gt; score:<br/>                score = min_val<br/>                action_to_take = action</span><span id="f5af" class="ko kp hi kj b fi ku kr l ks kt">        return action_to_take</span><span id="4665" class="ko kp hi kj b fi ku kr l ks kt">    elif player(board) == O:<br/>        score = math.inf<br/>        action_to_take = None</span><span id="3790" class="ko kp hi kj b fi ku kr l ks kt">        for action in actions(board):<br/>            max_val = maxvalue(result(board, action))</span><span id="7f55" class="ko kp hi kj b fi ku kr l ks kt">            if max_val &lt; score:<br/>                score = max_val<br/>                action_to_take = action</span><span id="a1a3" class="ko kp hi kj b fi ku kr l ks kt">        return action_to_take</span><span id="dce8" class="ko kp hi kj b fi ku kr l ks kt">def minvalue(board):<br/>    # if game over, return the utility of state<br/>    if terminal(board):<br/>        return utility(board)<br/>    # iterate over the available actions and return the minimum out of all maximums<br/>    max_value = math.inf  <br/>    for action in actions(board):<br/>        max_value = min(max_value, maxvalue(result(board, action)))</span><span id="08df" class="ko kp hi kj b fi ku kr l ks kt">    return max_value</span><span id="477c" class="ko kp hi kj b fi ku kr l ks kt">def maxvalue(board):<br/>    # if game over, return the utility of state<br/>    if terminal(board):<br/>        return utility(board)<br/>    # iterate over the available actions and return the maximum out of all minimums<br/>    min_val = -math.inf<br/>    for action in actions(board):<br/>        min_val = max(min_val, minvalue(result(board, action)))</span><span id="0ca5" class="ko kp hi kj b fi ku kr l ks kt">    return min_val</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="2682" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">很难理解<code class="du kg kh ki kj b">minimax</code>函数，因为它涉及到调用一个函数(例如maxvalue ),然后调用另一个函数(例如minvalue ),后者调用第一个函数，这比递归(双递归？相互递归？).如果您对这些功能有任何疑问，请告诉我。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="5782" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">复杂性肯定不是该项目的最大优势，因为它涉及计算3x3板上的每个状态。你可以在为O比赛时感觉到这一点，因为AI在采取任何行动之前必须计算所有可能的状态。请注意，这个项目是我哈佛CS50人工智能课程的一部分；你可以在这里找到更多关于它的信息。我的GitHub报告和课程演示在<a class="ae iu" href="https://github.com/dtemir/harvard-CS50AI" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>