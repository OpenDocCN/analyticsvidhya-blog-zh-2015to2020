<html>
<head>
<title>An Entry Point to Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的切入点</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-entry-point-to-data-science-vector-projections-with-r-and-c-34ff2e5d608c?source=collection_archive---------11-----------------------#2020-02-12">https://medium.com/analytics-vidhya/an-entry-point-to-data-science-vector-projections-with-r-and-c-34ff2e5d608c?source=collection_archive---------11-----------------------#2020-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ba72" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">向量投影(使用R和C++)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/47c7798b895422203475329683c59770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1w8jQWeIOsYhFDSIAG3gQ.jpeg"/></div></div></figure><h1 id="618a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">入口点</h1><p id="1b15" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">矢量投影的想法并不新鲜，也不先进。这是你在线性代数课程中甚至在高中学到的东西。矢量投影本身并不性感。尽管如此，这个主题仍然是进入数据科学的绝佳入口，原因有三:</p><h2 id="f6fb" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">1.直觉的</h2><p id="a033" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">它是直观的，因为一旦你在头脑中建立了抽象的形象，你总是可以回到它。在某种程度上，这是数学对现实世界进行抽象的完美例子。</p><h2 id="62b4" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">2.在许多应用中立即有用</h2><p id="7e24" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">紧随其后的应用包括</p><ul class=""><li id="961f" class="lm ln hi kd b ke lo kh lp kk lq ko lr ks ls kw lt lu lv lw bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/QR_decomposition" rel="noopener ugc nofollow" target="_blank"> QR </a>、<a class="ae kx" href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix" rel="noopener ugc nofollow" target="_blank">特征值</a>和<a class="ae kx" href="https://en.wikipedia.org/wiki/Singular_value_decomposition" rel="noopener ugc nofollow" target="_blank"> SVD </a>矩阵分解。</li><li id="5779" class="lm ln hi kd b ke lx kh ly kk lz ko ma ks mb kw lt lu lv lw bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/Least_squares" rel="noopener ugc nofollow" target="_blank">最小二乘法</a>，线性回归，多元线性回归。</li><li id="9a20" class="lm ln hi kd b ke lx kh ly kk lz ko ma ks mb kw lt lu lv lw bi translated">降维，<a class="ae kx" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析</a>，<a class="ae kx" href="https://en.wikipedia.org/wiki/Multidimensional_scaling" rel="noopener ugc nofollow" target="_blank"> MDS </a>。</li></ul><p id="1719" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">这些是我计划在以后的文章中探讨的一些话题。</p><h2 id="958d" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">3.一个不错的编程练习</h2><p id="217f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果你是一个有经验的R用户，并且你编写的函数被其他R函数调用了成百上千次，那么也许你已经考虑过学习如何使用Rcpp用C++扩展/优化你的R代码。这是我个人一直在做的事情，我发现用C++实现简单的函数是一个非常好的练习。</p><h1 id="8bd7" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">议程</h1><ol class=""><li id="b762" class="lm ln hi kd b ke kf kh ki kk mf ko mg ks mh kw mi lu lv lw bi translated">复习向量投影(一点数学和直觉)。</li><li id="e7c6" class="lm ln hi kd b ke lx kh ly kk lz ko ma ks mb kw mi lu lv lw bi translated">在R中实现并检查数学。</li><li id="6b22" class="lm ln hi kd b ke lx kh ly kk lz ko ma ks mb kw mi lu lv lw bi translated">用C++实现并以r为基准。</li><li id="d2cf" class="lm ln hi kd b ke lx kh ly kk lz ko ma ks mb kw mi lu lv lw bi translated">后续步骤</li></ol><h1 id="f22e" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">概念</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/e7f70a1b6e25c15436c74b115c672fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HQ8r-HGfZM47R30j"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">Martino Pietropoli 在<a class="ae kx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7cc7" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">想象一下站在街上，太阳在你的头顶上。看着地面，你会看到你的影子被投射到地面上。通过这种方式，你身体的3D形状被投射到地面的2D表面上。这就是投影背后的想法。你的影子是你的身体，但它在地上。换句话说，它是在地面的<em class="mo">方向</em>上。同理，想象你身体的影子在你旁边的建筑上。仍然是你的2D投影，但是现在在不同的<em class="mo">方向</em>。现在取两个抽象矢量<code class="du mp mq mr ms b">a</code>和<code class="du mp mq mr ms b">u</code>，想象将<code class="du mp mq mr ms b">a</code>的影子投射到<code class="du mp mq mr ms b">u</code>上。你得到的是一个方向为<code class="du mp mq mr ms b">u</code>的矢量。这个向量就是所谓的<code class="du mp mq mr ms b">a</code>到<code class="du mp mq mr ms b">u</code>的投影。</p><h1 id="165a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">公式</h1><p id="2f5a" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">有两种方法可以计算投影。第一步是找到与<code class="du mp mq mr ms b">u</code>相乘的正确标量。第二步是找到与<code class="du mp mq mr ms b">a</code>相乘的正确矩阵。这个矩阵叫做投影矩阵，它很特别。当您将<code class="du mp mq mr ms b">a</code>投影到单个向量或整个平面/超平面时，可以计算出该投影矩阵。</p><h2 id="7ad5" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">乘以一个标量:</h2><p id="f6c6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">以下表达式给出了<code class="du mp mq mr ms b">a</code>到<code class="du mp mq mr ms b">u</code>的投影。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/9e17e8aedf5aa676527a26fddf469732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*ardmk5jeiEijJI5vP3fJNw.png"/></div></figure><h2 id="2629" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">乘以投影矩阵:</h2><p id="15f9" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">或者，我们可以为<code class="du mp mq mr ms b">u</code>找到一个投影矩阵<code class="du mp mq mr ms b">P</code>，并找到如下投影:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/3ffa745273c9635f4ae690bdea5ae0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*Th4zUGWmpv6Pump08BoAXw.png"/></div></figure><p id="47d7" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">在哪里</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/e9ae39ec5c517bc674c56010da2b4d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*-Zqz4-qz7L6udap9uxW9EA.png"/></div></figure><p id="1f1f" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">U可以是只有一列的矩阵。</p><h1 id="5761" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">用R计算</h1><p id="cd78" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">让我们首先看一个例子，如何在R中计算投影，并检查两种方法是否产生相同的结果。让我们从标准正态分布中生成两个长度为<code class="du mp mq mr ms b">4</code>的小随机向量。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/ad4a539d95170a14271649e8d6589abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JD-5L8wOkPz41yuDTHWz3w.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><p id="3f8e" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">使用第一种方法，我们简单地计算一个标量，并将其应用到我们要投影的向量上。这是我们从<code class="du mp mq mr ms b">a</code>到<code class="du mp mq mr ms b">u</code>的投影。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/c8861a871f5fbe1c8155e3fe67f450c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygz1HMhAyD7pmWenKhAlnQ.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><p id="bad4" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">使用第二种方法，我们首先计算投影矩阵<code class="du mp mq mr ms b">Pmat</code>，然后将其应用于<code class="du mp mq mr ms b">a</code>以获得投影。要做到这一点，我们可以定义一个只有一列的矩阵，然后应用上面的公式。这是矩阵的样子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/cf9bb0ed7aac6176ab3cccf1527d32cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Q7VgN-woixCbv5splbnAQ.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><p id="2403" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">这是我们之前得到的同样的投影向量:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/9665a75a0d898ffddce016dc4770d73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsa24A6YYF-J5omV-2cIuw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><h1 id="7edd" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">性能</h1><p id="1d12" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们计算了<code class="du mp mq mr ms b">a</code>到<code class="du mp mq mr ms b">u</code>的投影，但是我们如何检查这实际上是一个投影，以及它的特殊之处？要看到这一点，我们可以看看几个重要的属性，并检查它们。</p><p id="9c29" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">说那个</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/dbc41e7e1f6ba9e7d422e532eebcde63.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*I0Br5XRg3uhwgNVmCUenIg.png"/></div></figure><p id="60f3" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">和</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nb"><img src="../Images/88e2e02c4cc035af03d08a8edbb3dbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*YTH0CiJtB5Oi1hKxmdF7vA.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/f47e6ac82cd03c108ab4444bdf34196d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_T554Z1jCfr8p3J3TtWu6g.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><h2 id="5733" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">1.方向</h2><p id="162e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先要检查的是，我们计算的投影与我们将<code class="du mp mq mr ms b">a</code>投影到的矢量<code class="du mp mq mr ms b">u</code>方向相同。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nd"><img src="../Images/16e2e2afa6fa4bb929db0cee05800e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*N_nRFsFuWHpC4ZDYpVDf5g.png"/></div></figure><p id="a976" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">其中<code class="du mp mq mr ms b">c</code>是某个常量向量。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/30f76b6716b7e4c642bea115f8871715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRh0ofzRZ0W4sb7bb0_NWg.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><p id="f3f4" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">如你所见，这是真的。</p><h2 id="16a3" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">2.正交性</h2><p id="bb66" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果我们将<code class="du mp mq mr ms b">a</code>投影到<code class="du mp mq mr ms b">u</code>上，那么矢量<code class="du mp mq mr ms b">e</code>应该与<code class="du mp mq mr ms b">u</code>和投影成90度。我们可以通过计算<code class="du mp mq mr ms b">e</code>和<code class="du mp mq mr ms b">u</code>或<code class="du mp mq mr ms b">v</code>的点积来检查这一点，并检查它是否为0。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nf"><img src="../Images/375b77dc9e9fd3a86724edda99996edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*WGwxLIyYGdEjtaTHucuDww.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/b18132ad20223f479b07df4e2858c816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSfLuqDHGVYx24JLon0BRw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><p id="b48f" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">这也证实了。</p><h2 id="2f3a" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated"><code class="du mp mq mr ms b">3. `P` </code>是幂等的</h2><p id="ffbf" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这是一个很酷的特性，据说如果你将投影<code class="du mp mq mr ms b">v</code>投影到<code class="du mp mq mr ms b">u</code>上，那么你将得到相同的投影矢量<code class="du mp mq mr ms b">v</code>。算术地</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ng"><img src="../Images/516be97caba3d9b833e024e13105bbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*J2LmOv7Rt9vkzeflamBkcg.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/0e40e463f82311449b051c53dd212c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rmzv1duKRyX50BsRtmHzsw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><p id="b3ff" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">我们看到这是正确的，并且意味着Pa=PPa=Pv=v。</p><h1 id="b6ec" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">一点编程</h1><p id="b6ae" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在实践中，R对于与数据分析相关的任何事情都是极好的。但是在某些情况下，通过Rcpp用C++扩展时，它可以变得更加强大。正如我们将在未来看到的，投影函数是一个完美的例子。在这里，我用R和C++实现了相同的函数，并在不同长度的向量上比较了它们。</p><h2 id="e535" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">R函数</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/8491b4ed224dc9ba1e8f8c68121d2c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ka6PjWl1tNRYFmxwLOMlPg.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><h2 id="19e5" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">C++函数</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/bdee71787a49c2980d133f6892416847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3BN3nr8nNMFDwedpT0j7A.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><p id="e289" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">正如你所看到的，R函数要简洁得多，只需要30秒就可以写完。C++比较长但不算太差。最终，它们会产生完全相同的结果。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/41a1c8a0451138e6ef3227013b1b229b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oto9cXMVwMnNQ51qTVMPw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><h1 id="41d9" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">标杆管理</h1><p id="acd7" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我来做三个对比。1st将查看我们所查看的长度为<code class="du mp mq mr ms b">4</code>的原始小向量的基准。第二个将查看相同的基准，但是是长度为<code class="du mp mq mr ms b">2000</code>的向量。最后，我们将看看这两个函数如何缩放从<code class="du mp mq mr ms b">4</code>到<code class="du mp mq mr ms b">1,000,000.</code>的向量长度</p><h2 id="634a" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">小矢量</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/41a1c8a0451138e6ef3227013b1b229b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oto9cXMVwMnNQ51qTVMPw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处代码可用</a></figcaption></figure><p id="4c7e" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">看起来C++版本不值得在这种情况下使用，因为我们在R中调用它，当我们使用Rcpp时会有一些开销。也就是说，我们在这里看着<code class="du mp mq mr ms b">nanoseconds</code>，所以实际上没有什么不同。</p><h2 id="f54b" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">更大的向量</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/5ad8a2e3c6454ee2476bd8f65dd6b16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03qhlXGq_D5kdqEcmp707w.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><p id="7280" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">在这里，我们清楚地看到，C++平均快了大约3倍。尽管如此，我们仍然在考虑<code class="du mp mq mr ms b">microseconds</code>，所以如果我们必须这样做一次，R是完全足够的。</p><h2 id="5a50" class="ky jk hi bd jl kz la lb jp lc ld le jt kk lf lg jv ko lh li jx ks lj lk jz ll bi translated">缩放至更大的向量</h2><p id="f0ff" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了查看这两个函数随着向量大小的增长而扩展的程度，我们可以编写一个函数，它将采用两个向量，并返回使用两个版本计算投影所花费的时间。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/0f5fd43389804ca36693465e5bfbfb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2R2hzegNUnQCkSupGZn05Q.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><p id="997c" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">现在生成一个向量长度序列和向量对本身，我们可以应用R和C++函数，并再次绘制它们的执行时间向量长度。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/4118713acc9c6e0056f86b4da6d8cdd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGV__KXDFjbR4sjh4Nx1Zg.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><a class="ae kx" href="https://bdshaff.github.io/blog/2020-01-28-vector-projections/" rel="noopener ugc nofollow" target="_blank">此处提供代码</a></figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nj"><img src="../Images/fe668ff5bba3aca4598a84fc665fcb29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhdMppOvVH1kLbUbgGBGCA.png"/></div></div></figure><p id="9100" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">从图中我们可以看到，随着向量长度的增长，性能的差异确实在增长。这意味着与R函数相比，我们的C++函数将变得越来越高效。</p><p id="78ca" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated">你可以想象，如果我们需要依次计算大向量的投影，时间差会变得很大。</p><h1 id="e57d" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">后续步骤</h1><p id="67ec" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process" rel="noopener ugc nofollow" target="_blank">Gram–Schmidt过程</a> —一种寻找与原始向量组跨越相同空间的正交向量组的方法。</p><p id="e834" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/QR_decomposition" rel="noopener ugc nofollow" target="_blank"> QR矩阵分解</a> —矩阵表示为正交矩阵<code class="du mp mq mr ms b">Q</code>和上三角矩阵<code class="du mp mq mr ms b">R</code>的乘积。这种分解可以用来找到<a class="ae kx" href="https://en.wikipedia.org/wiki/Least_squares" rel="noopener ugc nofollow" target="_blank">最小二乘</a>解，这对回归分析显然是重要的。</p><h1 id="4f84" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">学习资源</h1><p id="01bc" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">麻省理工学院开放课程线性代数课程——本课程的第二单元更详细地讲述了这个主题，并且有更多的数学知识。视频讲座非常棒，所以如果你想要更多的数学知识，这是一个好地方。</p><p id="fc22" class="pw-post-body-paragraph kb kc hi kd b ke lo ij kg kh lp im kj kk mc km kn ko md kq kr ks me ku kv kw hb bi translated"><a class="ae kx" href="https://adv-r.hadley.nz/rcpp.html" rel="noopener ugc nofollow" target="_blank"> R和C++ </a> — <a class="ae kx" href="https://adv-r.hadley.nz/rcpp.html" rel="noopener ugc nofollow" target="_blank">高级R书</a>的Ch 25是对Rcpp的完美介绍，如果你想学习如何用C++扩展R，也是一个很好的资源。我可以推荐的另一个资源是DataCamp课程<a class="ae kx" href="https://www.datacamp.com/courses/optimizing-r-code-with-rcpp" rel="noopener ugc nofollow" target="_blank">用Rcpp </a>优化R代码，这是我最喜欢的学习R的方法。</p></div></div>    
</body>
</html>