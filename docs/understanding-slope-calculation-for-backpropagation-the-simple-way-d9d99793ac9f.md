# 理解反传斜率计算的简单方法

> 原文：<https://medium.com/analytics-vidhya/understanding-slope-calculation-for-backpropagation-the-simple-way-d9d99793ac9f?source=collection_archive---------12----------------------->

我们都知道反向传播是神经网络中最难的概念之一。学习者在探索算法时最头疼的是如何计算后续权重的斜率。

提示:为了更好地理解，建议在桌面上查看这篇文章，因为有许多图像形式的数学方程。

在本文中，我们将理解如何使用计算图的简单概念来计算实现反向传播算法所需的梯度下降中的斜率。

让我们考虑一个等式，

*F(a，b，c)=5*(a*b+c)*

让我们，

*u = a * b；v = u+c；F = 5v*

上述等式的计算图可以绘制为:

![](img/32e465676dd8e8a8c5b8524216339d79.png)

图一

从图 1 中可以看出 *F* 依赖于 *v，v* 依赖于 *u* 并且*u*随后依赖于 *a* 以及*b*我们可以得出 *a* 和 *F* 之间的关系

![](img/1cafdd20ab3d47122ab633ae832e03d8.png)

图 2

现在我们来谈谈衍生品:

*F* w.r.t .变量 *v* 的导数简单地由下式给出:

![](img/208e465ba70547d06713658cf3efaa54.png)

现在为了计算 *F* w.r.t *u* 的导数，由于 *F* 是从 *v* 计算的，而 *v* 依赖于 *u* ，因此，我们需要通过*v*从 *F* 遍历回 *u*

![](img/a81336016920e0fe6c8703fd2d26f793.png)

图 3

因此我们会得到，

![](img/cd8e7852e631e1164345453c2862c785.png)

同样，对于 F 的导数，我们必须遵循这条路径

![](img/b16c69b50c1ecf64e9b71886cf72302e.png)

图 4

我们得到了

![](img/d0f13e048e471dbccb3bbb13a6c69c6f.png)

# 神经网络

现在就神经网络而言，这里，后续层中的节点值是通过称为前向传播的乘加过程来计算的，在该过程中，假设 L 与相应的权重 W 相乘并相加，通过将相加的结果传递通过激活函数来计算最终值。这里我们将考虑 sigmoid 激活函数。

我们可以画出神经网络的计算图

![](img/df4b880fb5df233ce193d311d099b30d.png)

图 5

请记住，图 5 不是实际的神经网络表示，而是它的计算图。

从上图我们可以观察到:

我们有

**输入**

![](img/d833abf9d28c6ccb20c125f56338bc49.png)

**重量**

![](img/48fb1ed10e35264046eb3a1527e6862c.png)

**隐藏层的乘加处理**

![](img/79a204b6c74c6fc2ed7b0f0e23f5d9bd.png)

**替换我们的 Sigmoid 激活函数**中最后一次操作的输出

![](img/96df63b5983e6e3c0ca15b1ceac2687c.png)

**输出层的乘加处理**

![](img/2f61d887c76e5694a0142292d242f007.png)

**应用 s 形激活功能**

![](img/8d0852549b6e02da6028998c3ac4e0e3.png)

这就完成了我们对 ***正向传播的处理。***

计算输出 *O* 与实际值 *Y* 相差多少的误差函数我们将使用 ***均值*** ***平方误差函数。***

![](img/5133dac849411f3963eb67cc9f017960.png)

注意:这里我们只演示了单个样本的计算

# 反向传播

反向传播算法的主要目的是通过梯度下降改变权重来计算权重的最佳值，直到我们获得最佳权重。

获得最佳权重的梯度下降方程由下式给出:

![](img/722c10ae72010cbe6d02a9fd8d5051ac.png)

在哪里

![](img/820b0dff16ec0518f9f60a1d9f616268.png)

表示要更新的权重。

![](img/d96a9eabb6b6ccbb0c7dfab3fb67c33f.png)

代表学习率。

![](img/10450c740c09670d785679318846bd5a.png)

> ***是我们的损失函数 w.r.t .的导数，要更新的权重***

现在我们主要关心的是如何计算损失函数相对于待更新权重的斜率。为此，我们将不得不再次为我们的计算图(图 5)中的变量绘制一个关系图，用于正向传播。

![](img/ae074e40e3ce219467b636b9b1fb39e1.png)

图 6

![](img/92878aa9bd6ea55719d8e46250dd9f7b.png)![](img/510fc1a41e781f99f862a94c9a4e5d37.png)

图 7

我们得到，

![](img/21a9a4b345f156cfa18e14688809d4fe.png)

等式 1

![](img/9c8dc8b63fff95afc039060c9f277f17.png)![](img/c259ea000cc120c1ad275fd75a3f7de5.png)

图 8

我们获得，

![](img/4729d520c8b05170a3c393c78a92edad.png)

因此，通过这种简单的追踪权重 w.r.t .的方法，我们可以很容易地使用反向传播和梯度下降来更新我们的权重。

*我希望这篇文章对你有用！*

*在 LinkedIn 上联系我:*[【https://www.linkedin.com/in/suyag10/】T21](https://www.linkedin.com/in/suyash-gupta-9b247b154/)