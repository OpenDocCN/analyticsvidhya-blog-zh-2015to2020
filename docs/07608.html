<html>
<head>
<title>Simple Chat room in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的简单聊天室</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-chat-room-in-python-b2cb0b2bf38c?source=collection_archive---------8-----------------------#2020-07-01">https://medium.com/analytics-vidhya/simple-chat-room-in-python-b2cb0b2bf38c?source=collection_archive---------8-----------------------#2020-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d245" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">插座+t inter</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/346573623d6b1f562dd837b20fd8a56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*acODWI94bBBUj5PmW8iK7g.jpeg"/></div></div></figure><p id="6cc9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在直接进入教程之前，首先让我们回到过去，了解聊天应用程序发展的原因和历史。尽管如果你对发展的历史不感兴趣，你可以直接进入教程。</p><h1 id="eb49" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">简史:</strong></h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f0f1d0ee4fd0295739e7f271d4fa0aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FlrfcrcrEvy_Rn7w3IXM9A.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">追踪聊天应用的历史</figcaption></figure><p id="c53f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">信不信由你，聊天应用实际上可以追溯到20世纪80年代，当时Compuserve发布了CB Simulator，这是第一个面向公众的专用在线聊天服务。第一条短信是由沃达丰GSM在1992年推出的，当时贯穿了整个90年代中后期，如MSN和Yahoo！变得流行起来。最著名的聊天应用出现在2000年代末，被称为黑莓信使，它彻底改变了现代聊天应用的世界。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="ccde" class="kf kg hi bd kh ki li kk kl km lj ko kp io lk ip kr ir ll is kt iu lm iv kv kw bi translated"><strong class="ak">教程:</strong></h1><p id="a1db" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">一个简单的聊天应用程序，带有相当精辟的Python代码。有趣的是，整个代码是在没有任何第三方依赖的情况下完成的！所以让我们开始吧！</p><h2 id="8fc0" class="lt kg hi bd kh lu lv lw kl lx ly lz kp js ma mb kr jw mc md kt ka me mf kv mg bi translated">服务器</h2><p id="7664" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">在本教程中，我们将使用TCP套接字，因此我们使用<code class="du mh mi mj mk b">AF_INET</code>和<code class="du mh mi mj mk b">SOCK_STREAM</code>标志。我们在UDP套接字上使用它们，因为它们越来越电话化，在通信开始之前，受益人需要确认接近的关联，UDP附件更像是邮件后的东西(利用这一点，任何人都可以向任何知道其电子邮件地址的人发送电子邮件)，所以在通信开始之前，它们不需要任何类型的连接。显然，TCP比UDP套接字更符合我们的目标，因此我们将使用它们。<strong class="jl hj"> <em class="ls">套接字可以被认为是双向通信信道中的端点，在服务器和一个或多个客户端</em> </strong> <em class="ls">之间建立通信。</em>你可以在这里了解更多关于插座的<a class="ae ml" href="https://en.wikipedia.org/wiki/Network_socket" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="iy iz ja jb fd mm mk mn mo aw mp bi"><span id="8ad7" class="lt kg hi mk b fi mq mr l ms mt">#!/usr/bin/env python3<br/>"""Server for multithreaded (asynchronous) chat application."""from socket import AF_INET, socket, SOCK_STREAM<br/>from threading import Thread</span></pre><p id="b5fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">导入后，我们设置了一些<em class="ls">常量</em>以备后用:</p><pre class="iy iz ja jb fd mm mk mn mo aw mp bi"><span id="d9fc" class="lt kg hi mk b fi mq mr l ms mt">clients = {}<br/>addresses = {}HOST = ''<br/>PORT = 33000<br/>BUFSIZ = 1024<br/>ADDR = (HOST, PORT)<br/>SERVER = socket(AF_INET, SOCK_STREAM)<br/>SERVER.bind(ADDR)</span></pre><p id="fe1c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">目前，我们将我们的服务分为接受新连接、广播消息和处理特定客户。让我们从接受连接开始:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/82f05c9a298694dcb041d30896a3d61e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Okhcckr2bff9YsCBORaVSw.png"/></div></div></figure><p id="f003" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这只是一个循环，它永远支持接近关联，当它得到一个关联时，它记录连接(打印一部分微妙的关联)并向关联的客户发送invite消息。之后，它将客户的地址保存在<code class="du mh mi mj mk b">addresses</code>字典中，稍后为该客户端启动处理线程。显然，我们还没有描述目标容量handle_client()的特征，但是我们可以这样做:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/a23e475bfa9e7999dfa895a86191656c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcnG7jE_xx1ODEDhNuMsrw.png"/></div></div></figure><p id="b930" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通常，在我们向新客户发送邀请消息后，它会回复一个他/她需要用于其他通信的姓名。在我们的<code class="du mh mi mj mk b">handle_client()</code>方法中，首先我们保存这个名字，然后向客户端发送另一个消息，以获得进一步的指示。从这里开始是通信的主要循环:在这里，我们接收来自客户的进一步消息，如果消息不包含停止指南，我们基本上将该消息传达给其他相关客户(我们将在一秒钟内描述广播技术)。万一我们确实遇到了带有退出指令的消息(例如，客户端发送退出命令it <code class="du mh mi mj mk b">{quit}</code>，并将相同的消息回滚到客户端(这调用客户端的关闭操作)，然后我们关闭它的连接套接字。在这一点上，我们做一些清理工作，为客户删除该段落，并最终向其他相关人员大喊，这个特定的人已经离开了讨论。</p><p id="17f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的<code class="du mh mi mj mk b">broadcast()</code>函数来了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/b3c178147f8ff3593d4d0e8d9714378c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnmAUTfyRZVXO947_QkQQQ.png"/></div></div></figure><p id="c161" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这本质上像水晶一样清晰(我希望如此)；它只是将消息发送给所有相关的客户，如果重要的话，还会添加一个任意前缀。在我们的<code class="du mh mi mj mk b">handle_client()</code>方法中，我们确实给<code class="du mh mi mj mk b">broadcast()</code>传递了一个前缀，我们这样做的目的是让个人能够准确地看到特定消息的发送者是谁。</p><p id="6d6e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们服务器的所有必要功能。之后，我们将输入一些代码来启动我们的服务器，开始监听传入的连接:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/38140e60698e7108e615513305f6b24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_U9W0A3AcPccSsTrSUwuCw.png"/></div></div></figure><p id="f70b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们<code class="du mh mi mj mk b">join()</code> <code class="du mh mi mj mk b">ACCEPT_THREAD</code>的目标是主脚本等待它完成，而不跳转到下一行，这将关闭服务器。</p><p id="fca3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就完成了我们的服务器脚本:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/245599dd5c0acdf0282bfa3df585c965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGMl86uGN_Lefz9ZrZoJLg.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/7e608617d6ed1266568fbe5339da4bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDIckVRXZpxihRW4jGxOQQ.png"/></div></div></figure><h2 id="e091" class="lt kg hi bd kh lu lv lw kl lx ly lz kp js ma mb kr jw mc md kt ka me mf kv mg bi translated">客户:</h2><p id="f370" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">这越来越有趣，因为我们将编写一个GUI！为了我们已经提到的目的，我们将使用Tkinter，Python的工具来创建基于GUI的应用程序。在此之前，让我们先做一些导入:</p><pre class="iy iz ja jb fd mm mk mn mo aw mp bi"><span id="4d3e" class="lt kg hi mk b fi mq mr l ms mt">#!/usr/bin/env python3<br/>"""Script for Tkinter GUI chat client."""from socket import AF_INET, socket, SOCK_STREAM<br/>from threading import Thread<br/>import tkinter</span></pre><p id="ee12" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们将编写负责发送和接收消息的方法。我们从接收开始:</p><pre class="iy iz ja jb fd mm mk mn mo aw mp bi"><span id="3a78" class="lt kg hi mk b fi mq mr l ms mt">def receive():<br/>    """Handles receiving of messages."""<br/>    while True:<br/>        try:<br/>            msg = client_socket.recv(BUFSIZ).decode("utf8")<br/>            msg_list.insert(tkinter.END, msg)<br/>        except OSError:  # Possibly client has left the chat.<br/>            break</span></pre><p id="07bc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为什么又是无限循环？因为我们将收到几乎无法确定的消息，并且不受我们发送消息的方式和时间的限制。我们不需要这是一个对讲机聊天应用程序，可以发送或接收一次；我们需要尽可能地获取信息，并在需要时发送它们。循环内部的有用性是真正直接的；<code class="du mh mi mj mk b">recv()</code>是阻挡部分。它中断执行，除非它收到任何消息，当它收到消息时，我们继续前进，然后将消息追加到<code class="du mh mi mj mk b">msg_list</code>。然后我们将定义<code class="du mh mi mj mk b">msg_list</code>，它基本上是一个Tkinter特性，用于在屏幕上显示消息列表。</p><p id="7e15" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们定义<code class="du mh mi mj mk b">send()</code>函数:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/9b044a0ffa2cdb9674bb900f257126e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*PyYF9DD-y6TmuGJrerWkmA.png"/></div></figure><p id="0cc2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们使用<code class="du mh mi mj mk b">event</code>作为参数，因为当GUI上的<code class="du mh mi mj mk b">send</code>按钮被点击时，它被Tkinter隐式传递。<code class="du mh mi mj mk b">my_msg</code>是GUI上要输入的字段，因此我们将使用<code class="du mh mi mj mk b">msg = my_msg.get()</code>提取要发送的消息。之后，我们将清除用户输入字段，然后我们将消息发送到服务器，正如我们之前已经看到的，服务器将此消息广播给所有客户(如果不是退出消息)。如果是退出消息，我们关闭套接字，然后关闭GUI应用程序(通过<code class="du mh mi mj mk b">top.close()</code>)</p><p id="5f11" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们定义了另一个函数，当我们选择关闭GUI窗口时，这个函数将被调用。这也是一种关闭前清理功能，将在<strong class="jl hj"> GUI关闭之前关闭套接字连接:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/37682b8738678ac54f636c1f42f7f21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91padD2p7EMJHHHe1mK1iw.png"/></div></div></figure><p id="8c6e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将输入字段设置为<code class="du mh mi mj mk b">{quit}</code>，然后调用<code class="du mh mi mj mk b">send()</code>，然后按照我们预期的那样工作。现在我们开始构建GUI，在主名称空间中(即，在任何函数之外)。我们首先启动顶级小部件，并将其设置为title:</p><p id="6310" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> top = tkinter。Tk() <br/> top.title("喋喋不休")</strong></p><p id="748f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，我们将创建一个框架来存储消息列表。接下来，我们创建一个字符串变量，主要用于存储我们从输入字段(我们将定义它)中获得的值。我们将该变量设置为<code class="du mh mi mj mk b">"Type your messages here."</code>来提示用户输入他们的消息。之后，我们制作一个滚动条来向下滚动这个消息框。代码如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/2280f91b95a7d7d9ecb6c7f3ad3d2f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ut-C9zW9rvDKwjrsCUx_0g.png"/></div></div></figure><p id="4c19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们现在将定义将存储在<code class="du mh mi mj mk b">messages_frame</code>中的消息列表，然后将我们到目前为止创建的所有代码打包(在适当的位置):</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/51e98d0b68011692e8412f835f1902ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cmo8mN6Y0czVM8cvV_-cqw.png"/></div></div></figure><p id="d122" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，我们为用户创建输入字段来输入他们的消息，并将其绑定到上面声明的字符串变量。我们还将其绑定到<code class="du mh mi mj mk b">send()</code>函数，这样每当用户点击return时，消息就被发送到服务器。然后，如果用户希望通过点击发送按钮来发送消息，我们就构造发送按钮。同样，我们将按钮的按下绑定到<code class="du mh mi mj mk b">send()</code>功能。然后，我们还将刚才创建的所有内容打包。此外，不要忘记使用清理功能<code class="du mh mi mj mk b">on_closing()</code>，当用户想要关闭GUI窗口时，应该调用这个功能。我们将使用我们的<code class="du mh mi mj mk b">top</code>的<code class="du mh mi mj mk b">protocol</code>方法来完成。这是所有这些的代码:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/815410b4a4ff948a5c2717b40dda63f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiAmECrNXEXnPVKeSpkf3g.png"/></div></div></figure><p id="cae3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是，我们还没有编写连接到服务器的代码。为此，我们必须向用户询问服务器的地址。我们可以使用<code class="du mh mi mj mk b">input()</code>快速完成这项工作，因此在GUI开始之前，用户会收到一些命令行提示，要求输入主机地址。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/1a89eb6cfcfdcb51359f1b8e968925ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcfXvLAqllHwAUApjK58Gg.png"/></div></div></figure><p id="6c7b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦我们获得了地址并创建了一个连接到它的套接字，我们就开始接收消息的线程，然后是GUI应用程序的主循环:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/d622d1b6110cf00625eb4a637c6395dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUszn-Cwpwl3IzHyT9fhcg.png"/></div></div></figure><p id="11bd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">我们已经编写了聊天应用程序！</strong></p><p id="8b69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以下是您可以参考的完整代码:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/98e96824cd30bd1ffd0b576505136b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5HEwjyPwyxU8DhNZAJHNQ.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/d1e3fe6acddc2cda3c0309ab063f2330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lp2S68uImNDRGLXGV99Y4Q.png"/></div></div></figure><p id="c510" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">显然，您可以在同一台设备上运行服务器和客户机，以便进行测试(在您的客户机中使用<code class="du mh mi mj mk b">127.0.0.1</code>代替<code class="du mh mi mj mk b">HOST</code>)</p><p id="1a3b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">下面这里你可以参考我的github的全部源代码；</strong></p><div class="nj nk ez fb nl nm"><a href="https://github.com/antimatter01/Chat-app" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hj fi z dy nr ea eb ns ed ef hh bi translated">反物质01/聊天应用</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">基于python的简单GUI聊天室。通过在…上创建帐户，为anti matter 01/聊天应用程序的开发做出贡献</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jh nm"/></div></div></a></div></div></div>    
</body>
</html>