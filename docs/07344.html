<html>
<head>
<title>Apache Spark: Window function vs Struct function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Spark:窗口函数与结构函数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/apache-spark-window-function-vs-struct-function-9b564a398092?source=collection_archive---------15-----------------------#2020-06-22">https://medium.com/analytics-vidhya/apache-spark-window-function-vs-struct-function-9b564a398092?source=collection_archive---------15-----------------------#2020-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a52fedf07b841a8ba0e759eb648798ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sa5keMDzFfg2MGmRxlP3vQ.png"/></div></div></figure><p id="0cd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文的目标是比较两种数据处理方式的性能。第一种方式是基于<a class="ae jo" href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/expressions/Window.html" rel="noopener ugc nofollow" target="_blank">窗口函数</a>。第二种方式是基于<a class="ae jo" href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/types/StructType.html" rel="noopener ugc nofollow" target="_blank">结构</a>。这两种处理数据的方法有时有助于以不同的方式获得相同的结果。</p><p id="c209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">窗口函数对一组被称为<strong class="is hj">窗口</strong>的记录执行计算，这些记录与当前记录有<em class="jp">某种</em>关系。</p><p id="2aaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.functions$@struct(cols:org.apache.spark.sql.Column*):org.apache.spark.sql.Column" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> struct </strong>函数</a>用于将StructType列追加到数据帧中。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h2 id="dea8" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">目标是为每个孩子找到最后一个父母。</h2><p id="5160" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们来看一个数据:</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/ae10251d5dc820b47b0b265073347c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*m8n2q1cEwX-UQGnXnEEIfQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated"><strong class="bd jz">图一。</strong>输入数据</figcaption></figure><p id="9efc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">父字段是<em class="jp"> StringType </em>。时间字段是<em class="jp"> TimeStampType </em>。子字段是<em class="jp">字符串类型</em>。</p><p id="95b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个孩子应该属于几个父母。在这种情况下，我们需要为每个孩子找到最后一个父母。最后一个父代是具有最后时间戳的父代。在结果中，我们将有对父子。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/3d591724914f5abaa65f1b8f3c21e090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*oa9jWTPvUMI8lCQS9q9RjQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated"><strong class="bd jz">图二。</strong>输出数据</figcaption></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h2 id="e20c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">我们试试在Apache Spark上实现吧！</h2><p id="1f19" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">有几种方法可以在Apache Spark上实现它。从我的角度来看，可以使用两种可读性最强、最优雅的解决方案。</p><p id="d1c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">窗口功能</strong></p><p id="b7ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案看起来像:</p><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="a209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，使用UDF函数将带有子列表的字符串转换为数组。</p><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="25c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，如果存在空数组，应该过滤数据。前面的步骤是清理数据所必需的。现在数据准备好了，我们可以<a class="ae jo" href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/sql/functions.html#explode-org.apache.spark.sql.Column-" rel="noopener ugc nofollow" target="_blank"> <em class="jp">展开</em> </a>我们的数组。正因为如此，我们得到了亲子配对，但目标是为我们的孩子找到最后一个父母。窗口功能可以帮助我们完成这笔交易。<em class="jp">max($ " utc _ timestamp ")over by child</em>返回与当前子代相关的一组记录的最大值<em class="jp"> utc_timestamp </em>。一旦为每个孩子找到了最大utc_timestamp,我们只需要将当前utc_timestamp与最大utc _ timestamp进行比较。如果它们是一样的，那就意味着我们找到了我们要找的东西。是最后一个家长。</p><p id="9122" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结构功能</strong></p><p id="dee2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案看起来像:</p><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="f26c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们做了相同的步骤来清除数据。下面的步骤是用struct函数准备一对<em class="jp"> utc_timestamp </em>与parent。它类似于元组。之后，我们可以通过一个孩子使用一个简单的<em class="jp"> max </em>函数找到一个具有<em class="jp">最大utc_timestanp </em>的父母。在对struct列使用<em class="jp"> max </em>函数的情况下，该函数通过struct中的第一个字段比较值，如果这些值相同，该函数将通过struct中的第二个字段进行比较。在最后一步中，可以使用下面的代码从struct中获取父级:<em class="jp">select($ " p . parent))</em>。</p><p id="700f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样。我们得到了与前一个选项相同的结果。</p><h1 id="6fb3" class="lk jy hi bd jz ll lm ln kd lo lp lq kh lr ls lt kk lu lv lw kn lx ly lz kq ma bi translated">摘要</h1><p id="1295" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这个故事显示了转换数据的两个选项，以找到孩子的最后一个父代。两个选项看起来都不错，你可以选择任何你更喜欢的选项。在我看来，第二个选项看起来更具可读性，但是它需要了解struct列如何与聚合函数一起工作。</p></div></div>    
</body>
</html>