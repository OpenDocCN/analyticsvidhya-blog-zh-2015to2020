<html>
<head>
<title>Grabcut algorithm —An OpenCV feature that might improve image handling model’s performance greatly.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Grabcut算法OpenCV的一个特性，可以极大地提高图像处理模型的性能。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/grabcut-algorithm-an-opencv-feature-that-might-improve-image-handling-models-performance-greatly-cfc39de90d58?source=collection_archive---------18-----------------------#2020-06-30">https://medium.com/analytics-vidhya/grabcut-algorithm-an-opencv-feature-that-might-improve-image-handling-models-performance-greatly-cfc39de90d58?source=collection_archive---------18-----------------------#2020-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="838c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事背后的目标不是从数学上说明Grabcut背后的算法，而是演示该功能可以如何极大地提高模型的性能。请记住，这个故事并没有从任何意义上推断出该特性在所有图像处理模型上都可以很好地工作。最近，在参加由5个不同问题陈述组成的计算机视觉黑客马拉松时，我决定阅读著名的OpenCV文档。在尝试使用不同的工具进行数据预处理时，我最初选择了Grabcut。我将讨论我的模型性能有和没有Grabcut。</p><p id="748f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题陈述是将叶子的图像分类为健康和非健康类别。虽然我最初打算使用一个更大更好的模型，但是五个小时的时间限制使我无法这样做。数据集由带有一些背景细节的树叶图片组成。然而，ROI(感兴趣区域)主要是叶子的表面。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ae6af48d8b94f211d1a4966b25e3e099.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*QJoHAdG8uv81rWlTST13Gg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">来自数据集的样本图像</figcaption></figure><p id="d641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">背景不需要推断结果的原因是，我决定去掉它，而没有明确地训练一个模型来这样做。因此，我决定使用Grabcut。如前所述，这个故事不会涉及算法的复杂性，除了关键点，我不会讨论功能。代码中的<strong class="ih hj"> <em class="jp"> rect </em> </strong>变量存储图像中里约的尺寸。所以，这个要明智的选择。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/8659b55529a89dc5f66e3bc2af9f4502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZF21LyUq3jVhKOG7l_s3GA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">用于实现Grabcut的函数</figcaption></figure><p id="24af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用该算法后，我可以很容易地获得没有背景的图像。看下面。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/8cf52b4bb9d28e136fa8f0c28c93a159.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*IRy02tUGsCA6n2NV8bi0gw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图像后剪切</figcaption></figure><p id="5f9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于算法移除了完整叶子的图像，我选择了那些使用<em class="jp">图像阈值</em>的图像，并在它们周围创建了一个简单的黑色边框。见下图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jw"><img src="../Images/e7a6a28eb5ad2233fee83d39b0d00583.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*_CGCZJb9-uFVJcBM7-k3DQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">Grabcut无法正常工作的图像</figcaption></figure><p id="bd91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果，我得到了高度改进的模型精度。前一个模型在95%的准确率时饱和，而后者在较短的时期内达到了99%以上。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/ec637de7ef2cd68b4e4836789cc74a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*SxSMmFNaOzuHrTgkMMv6MQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">前一种模式</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/ded0c72270a4fb2c75ca158626ae8bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*wkohu6fU-Zyfz5h0-6Ejcw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">后一种模式</figcaption></figure><p id="e70b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我如何在时间限制内建立一个图像分类模型。但是，请不要忘记以类似的方式增加测试数据:-)。特别感谢谷歌的免费TPU帮助我在黑客马拉松中排名前十。</p></div></div>    
</body>
</html>