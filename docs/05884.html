<html>
<head>
<title>NST — Creating Artworks with the help of machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NST——借助机器创作艺术品</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/nst-creating-artworks-with-the-help-of-machine-56ebd3eb780c?source=collection_archive---------31-----------------------#2020-05-04">https://medium.com/analytics-vidhya/nst-creating-artworks-with-the-help-of-machine-56ebd3eb780c?source=collection_archive---------31-----------------------#2020-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="492d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过操纵基础图像以采用不同图像的外观来产生新的艺术</h2></div><p id="72b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们很多人都知道创作一件杰出的艺术品有多难，在创作过程中付出的努力和经历是值得称赞的。虽然这看起来像是一项耐心且难以获得的技能，但实际上，只要借助深度学习算法，你就可以创作出令人印象深刻的艺术品。</p><p id="fede" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">神经风格转移(NST) </strong>是一种深度学习算法，它可以帮助我们在没有任何艺术知识的情况下创作出令人惊叹的艺术品。该算法的基本思想是获取一个我们归类为<strong class="iz hj">内容图像</strong>的基础图像，然后尝试并操纵其像素来覆盖另一个称为<strong class="iz hj">风格图像</strong>的图像，以产生所需的艺术效果！</p><p id="8b80" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然看起来具有欺骗性，但这是真的，而且这种方法确实有效。看看用这种算法生成的图像。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/ff08ddb99ade89a75b888378526b783b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vNRUqLMKe_L-7hNmkuJfA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">左图:<a class="ae kj" href="https://commons.wikimedia.org/wiki/File:YellowLabradorLooking_new.jpg" rel="noopener ugc nofollow" target="_blank">黄色拉布拉多表情</a>，来自维基共享；中间:<a class="ae kj" href="https://commons.wikimedia.org/wiki/File:Vassily_Kandinsky,_1913_-_Composition_7.jpg" rel="noopener ugc nofollow" target="_blank">康定斯基的画</a>；右图:模型输出的图像</figcaption></figure><p id="a484" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个上下文中的<strong class="iz hj">内容图像</strong>是左边的一个，中间的一个是<strong class="iz hj">样式图像</strong>，右边的一个是<strong class="iz hj">目标图像</strong>，我们将在整个阅读中使用上述术语来称呼它们。</p><p id="15c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在沉迷于作品的技术细节之前，我将首先尝试建立作品背后的直觉。每当我们想到图像编辑时，我们真正想到的是跨越三个颜色通道(即RGB)的像素值的不同组合。因此，可以将NST想象为获取内容图像，然后将样式图像作为一个新的图层放在上面，就像在图像上应用滤镜一样，唯一的区别是它实际上不是直接应用于像素，而是在各种图像特征组合的帮助下学习的。</p><p id="8178" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你来自ML/DL社区，你可能知道没有比CNN(卷积神经网络)更好的算法来从图像中提取丰富的特征。使用足够深的CNN，我们可以提取NST所需的高级特征。为了完成我们的任务，我们需要CNN找到<strong class="iz hj">“图像中有什么？”</strong>给我们，以便我们可以用它来创建目标图像。随着CNN的层次越来越深，他们学会了许多复杂的功能，这些功能可以告诉我们图像实际上是由什么组成的。</p><p id="cf55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们把我们的内容图像和T2风格图像传送给T4的CNN网络。一旦它学习了图像的特征，我们就计算总损失函数。该损失函数是两个损失的加权平均，即<strong class="iz hj">内容损失</strong>和<strong class="iz hj">风格损失</strong>。直觉上，我们迭代地更新我们的输出图像，通过使输出尽可能接近目标图像的内容和参考图像的风格，使我们的总损失最小化。</p><p id="91bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">内容损失:</strong>内容损失被定义为输入图像和目标图像的中间内容表示之间的L2距离，该距离取自预训练神经网络的较高层。由于较高级别的层产生拥有输入图像的复杂原始信息的过滤器，这是判断内容相似性的合适近似。该等式如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kk"><img src="../Images/ef452228941861f6840bad504ab6ed07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OPlsoJamM3ccG2dZfRiWg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">内容损失的等式，定义为特定层L中目标和输出图像的两个特征表示之间的平方误差损失</figcaption></figure><p id="725f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">风格损失:</strong>类似地，我们将风格损失定义为风格图像(取自预训练神经网络的较低层)的中间风格表示的格拉姆矩阵和输出图像之间的L2距离。较低级别的层捕获更简单的图像特征，这些特征最好地编码了风格的概念。此外，通过使用Gram矩阵，我们分布和离域图像中的空间信息，并近似图像的<strong class="iz hj">风格</strong>。数学上就是图像矩阵和它的转置的矩阵乘法。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kl"><img src="../Images/06a5fd1acae38c7b66ebfa397a3beda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dku-tGVqNieEnEKXTUT7A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">格拉姆矩阵方程。g是特定层L中的矢量化特征图I和j之间的内积</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es km"><img src="../Images/14d995f7ea09172c859628774946cadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjnYfBShodiH2-N3DQFESQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">样式损失的等式，定义为特定图层子集上样式参考和输出图像的gram矩阵之间的平方损失误差。</figcaption></figure><p id="4f8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们将这两个损耗加到总损耗中，并训练网络使损耗最小。</p><h2 id="4683" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">履行</h2><p id="3d9a" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">现在，在掌握了网络的主要元素之后，我们将借助<strong class="iz hj"> Tensorflow实现NST。</strong></p><p id="5385" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们将加载实现所需的所有包</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5dbc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一步中，您将编写一个助手函数，该函数将在数字数组中加载这两个图像(因为计算机只理解数字)，并对它们进行整形，使它们与模型兼容。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="fdea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在使用上面创建的函数并加载我们的<strong class="iz hj">内容</strong>和<strong class="iz hj">样式</strong>图片</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1fa6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图像被重塑。现在，您将加载一个预训练的VGG19模型来提取特征。由于您将使用模型来提取特征，因此不需要模型的分类器部分。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="6b5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将查看您刚刚加载的VGG19模型，并打印网络中所有层的名称。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="86fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，您对以下用于获取样式特性的方法感兴趣:</p><ul class=""><li id="1c6f" class="lp lq hi iz b ja jb jd je jg lr jk ls jo lt js lu lv lw lx bi translated">conv1_1 '</li><li id="5e6d" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">' conv2_1 '</li><li id="c090" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">' conv3_1 '</li><li id="a041" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">' conv4_1 '</li><li id="ac27" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">' conv5_1 '</li></ul><p id="5d55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于内容特性，您需要conv4_2。您将相应地将这些存储在变量中。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="2052" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在创建一个自定义的VGG模型，它将由指定的层组成。这将有助于您向前运行图像，并在运行过程中提取必要的特征。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="be87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在TensorFlow中定义gram矩阵非常简单，您可以通过以下方式完成:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b56b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在将使用mini_model()函数定义一个定制模型。这将用于从相应的图像中返回内容和样式特征。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="d905" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经定义了自定义模型，让我们在图像上使用它来获得相应的内容和样式特性。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="4f66" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将加载优化函数。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="f11d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们定义整体内容和样式权重，以及前面讨论的每个样式表示的权重。请注意，这些是超参数，是您应该使用的东西。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="8bb2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在到了最关键的部分，它让神经风格转移的过程有趣了很多——损失函数。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="cee9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您将编写另一个函数，它将:</p><ul class=""><li id="895e" class="lp lq hi iz b ja jb jd je jg lr jk ls jo lt js lu lv lw lx bi translated">计算你刚刚定义的损失函数的梯度。</li><li id="b361" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">使用这些渐变来更新目标图像。</li></ul><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="cefd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在开始时将目标图像设置为内容图像。然后我们准备训练出模型。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="08a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">万岁！我们在这里的工作都完成了。在短短的几分钟内，你创造了一个全新的属于你自己的艺术品，而且也是在没有任何先验知识的情况下。</p><p id="7d73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是机器学习赋予你的力量。拥抱它！增强它！并探索它！如果你喜欢这篇文章，请鼓掌。快乐学习！</p></div></div>    
</body>
</html>