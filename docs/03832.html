<html>
<head>
<title>Spark Parallelism Deep Dive-Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">火花并行深入探讨-第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spark-parallelism-deep-dive-part-ii-95a06e2443c4?source=collection_archive---------11-----------------------#2020-02-21">https://medium.com/analytics-vidhya/spark-parallelism-deep-dive-part-ii-95a06e2443c4?source=collection_archive---------11-----------------------#2020-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我在《火花深潜》中的一个故事</p><p id="ce32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/@somanathsankaran">https://medium.com/@somanathsankaran</a></p><p id="955e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spark是一个分布式并行处理框架，它的并行性是由分区定义的。让我们详细讨论一下spark的分区。</p><p id="5f41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">spark中有3种类型的并行。</p><ol class=""><li id="ecb0" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">阅读中的平行</li><li id="54e1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">洗牌中的平行</li><li id="d55b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">写作中的平行</li></ol><p id="ea5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读中的并行性在之前的博客中已经讨论过了</p><div class="js jt ez fb ju jv"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/spark-parallelism-deep-dive-i-reading-8d63e22f3bce"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">火花并行性深潜-I(阅读)</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">这是我在火花深潜系列中的一个故事。</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">medium.com</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj kk jv"/></div></div></a></div><p id="b0fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">混洗中并行将发生在3个过程中</p><ol class=""><li id="bfbe" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">分组依据</li><li id="6584" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">加入</li><li id="1205" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">窗口函数</li></ol><p id="9c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在洗牌时看到分区之前，我们将在阅读时看到分区</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kl"><img src="../Images/c9fd3522ceb197dde224175045d4c204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*bFuSDdCf6btlPNO1Xx_yhA.png"/></div></figure><p id="bf95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分组通过</strong></p><p id="8801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们取一个样本df并按Id分组。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es ks"><img src="../Images/24056e48289611d264c840dd3eb956eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*avrmcRtcH9EOEnGQrQ3bqQ.png"/></div></figure><p id="f242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在spark sql选项卡下看到UI时</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es kt"><img src="../Images/77921b507cd934bb39ab4d479765d62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJtEofqyLPASaCRaLPGFSQ.png"/></div></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ky"><img src="../Images/3612b36ebf798664f93b2ef85d74532c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HffY8thpLr-N6Nk6CQVBbw.png"/></div></div></figure><p id="20e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在看到图像时，我们可以看到交换正在发生，因为我们需要一些分组，它被分配了200个分区</p><p id="5ebf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么会这样呢？尽管数据可以加载到单个分区中。这是因为以下属性</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kz"><img src="../Images/e3c9a26765b9715a3f9798a4c4a8253f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*2P_d7-vZo6oQnkUKzjFwFw.png"/></div></figure><p id="47cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们将值设置为1，因为数据很小，我们不需要任何洗牌</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ky"><img src="../Images/1ca2a258cee602845fa5b2991a805ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPNvZ7IbQLMmHbdPvwSn3Q.png"/></div></div></figure><p id="d245" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以看到一个交换，分区数量为1</p><p id="6ccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有另一个属性将控制洗牌分区</p><p id="4141" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用列</strong>重新划分api</p><p id="5a77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们基于相同的字段(如唯一id或日期)重复进行分组和连接，这将非常有用。</p><p id="0ccc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们按id重新划分，看看情况如何</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es la"><img src="../Images/c78c8bb128edc5b3f0e6d56cff380c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_VlmKu-xpDZA13uD1DTcw.png"/></div></div></figure><p id="d5fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们看到上面，我们可以看到2个交换</p><ol class=""><li id="b277" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">这是由于按id重新分区</li><li id="fa55" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">这是由于spark.sql.shuffle.partitions设置为1而导致的洗牌</li></ol><p id="edf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么按id重新分区有什么用呢？如果我们基于某个被反复使用的特定列进行分组，这是为了避免混乱。因此，如果我们按id分组并进行计数，让我们看看会发生什么</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lb"><img src="../Images/c9f5aa527831c8f73d96f76323807f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQWwSQkyw6lpKK7Ou4jUqA.png"/></div></div></figure><p id="ff79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如上所示，我们将只有一个洗牌或交换发生</p><p id="2677" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加入</strong></p><p id="49ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们使用上面的df_src1，它按id重新分区为2个分区，新的df_src2是第二个csv文件，让我们看看发生了多少次洗牌</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lc"><img src="../Images/250990bdec9bb61a5ab53a980f385f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWbfReKw_O09wSMWxox5jw.png"/></div></div></figure><p id="8911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在这里看到的，我们有1个交换，随机分区的数量是2，这是(df_src1.rdd.getNumpartitions和spark.sql.shuffle.partitions (1)的最小值，因为df_src2没有重新分区)</p><p id="4b33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，总结来说，如果您要使用基于同一列的重复连接，您可以基于某个列进行重新分区，这样就不会有任何交换，如果有不同的df，并且由同一列一次又一次地连接，只要您按照某个唯一的字段统一进行重新分区</p><p id="e2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">窗口功能</strong></p><p id="1035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">情况1通过重新分区的列进行分区</p><p id="e727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将只有一个洗牌，如下所示</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ld"><img src="../Images/eb00828fea25cecdc4ee09a7df7acb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyRgOURRvWdiE-p3lcH3zw.png"/></div></div></figure><p id="63a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例2基于未重新分区的列</p><p id="1207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们在queryplan 1中有两个交换，一个用于重新分配值，另一个用于洗牌交换</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es le"><img src="../Images/7a20ccea923d223702186b56ffd12232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lu0-nbiQXrQ-W7fbSBdrVQ.png"/></div></div></figure><p id="3897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong></p><p id="d230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lf">因此，总结来说，如果你期望在一个唯一的键上有很多分组，最好使用列重组</em> </strong>来控制洗牌</p><p id="7fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">或者，如果我们要处理各种字段的大量聚合，我们可以控制它</strong></p><p id="ad37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天就到这里吧！！:)</p><p id="4915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Github链接:<a class="ae jd" href="https://github.com/SomanathSankaran/spark_medium/tree/master/spark_csv" rel="noopener ugc nofollow" target="_blank">https://github . com/SomanathSankaran/spark _ medium/tree/master/spark _ CSV</a></p><p id="8c1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lf">请给我发spark中我必须涉及的话题，并给我改进写作的建议:)</em> </strong></p><p id="d2cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">学习并让别人学习！！</strong></p></div></div>    
</body>
</html>