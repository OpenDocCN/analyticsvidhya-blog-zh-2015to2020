<html>
<head>
<title>Big O Notations and Its Examples in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号及其在Python中的例子</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/big-o-notations-and-its-examples-in-python-9d7e3c1ef09d?source=collection_archive---------1-----------------------#2020-04-23">https://medium.com/analytics-vidhya/big-o-notations-and-its-examples-in-python-9d7e3c1ef09d?source=collection_archive---------1-----------------------#2020-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="72be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jd" rel="noopener" href="/@manikanthgoud123/big-o-notation-58614f2b6318">博客</a>中，我们已经看到了为什么使用大O符号以及各种大O符号。现在我们将深入研究三种类型大o符号及其示例python代码。</p><h1 id="8aa4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">O(1)常数:</h1><p id="46e4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们能想到的最简单的大O符号是常数。我们可以将常量的大O定义为无论我们的输入有多大，它总是花费相同的时间来计算事物。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/f26e7b2ae058fb9ebd0235b22ec13fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*9lmwalYyU_zMfYBqBpLGSQ.png"/></div></figure><p id="ee2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意这个函数是如何保持不变的，因为无论列表大小如何，这个函数都只取一个恒定的步长，在本例中为1，打印列表中的第一个值。因此我们可以看到，一个包含100个值的输入列表将只打印1项，一个包含10，000个值的列表将只打印1项，而一个包含<strong class="ih hj"> n </strong>个值的列表将只打印1项！</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/619455567ebb2ac66097d0e3f357f9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oh9NwbJpzaZxaXtdxIU1cQ.png"/></div></div></figure><p id="48e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的图表中我们可以观察到，无论输入值是多少，运行时间都是恒定的</p><h1 id="dac0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">O(n)线性:</h1><p id="acee" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这种情况下，运行时间取决于它接受的输入数量。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ku"><img src="../Images/9ace8ae0223b8eaef9ea6975c38026de.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*-WJ1DxaZhYDcoqL8pgf_6Q.png"/></div></figure><p id="d3c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的函数运行时间为O(n)(线性时间)。这意味着发生的操作数量与n成线性比例，因此我们可以看到，100个值的输入列表将打印100次，10，000个值的列表将打印10，000次，而<strong class="ih hj"> n </strong>个值的列表将打印<strong class="ih hj"> n </strong>次。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kv"><img src="../Images/f36373182c4f7a44860218e6ce9e81ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Azo54ln7sKr6Z_30yZIYg.png"/></div></div></figure><p id="9f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图我们可以看出，运行时间取决于输入值，随着输入值的增加，运行时间也会增加。</p><h1 id="744e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">O(n)二次:</h1><p id="83cf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在下面的python代码中，我们有两个循环，一个嵌套在另一个中。这意味着对于一个包含n个条目的列表，我们必须对列表中的每个条目执行n次操作！这意味着我们总共将执行n次n次赋值，即n。因此一个包含10个项目的列表将有10或100个操作。您可以看到对于非常大的输入来说这有多危险！这就是为什么Big-O如此重要的原因！</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kx"><img src="../Images/0bef3c1b127a2a4485f326eeeffc0f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*G8Th0sCOZztrBe1-VGSSUQ.png"/></div></figure><p id="ffe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下图中，我们可以观察到，与O(1)和O(N)符号相比，运行时的变化取决于输入值。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ky"><img src="../Images/5ea13772dd3056dbb113fb8395325f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7_fzBx0CNcvZGQiiL8e4g.png"/></div></div></figure><ul class=""><li id="d0cb" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">1项:1秒</li><li id="38cf" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">10个项目:100秒</li><li id="df09" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">100件物品:10000秒</li></ul><p id="9e0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，项目数量增加了10倍，但是时间增加了102倍。基本上，n=10，因此O(n2)给出的比例因子n2为102。</p><h1 id="4cc2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">计算大O的规模:</h1><p id="efec" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">一个函数可能会变得更复杂(更多的循环和条件语句),在这种情况下，我们有比大O符号更多的符号，如下面的代码片段所示</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ln"><img src="../Images/19bb937802f9c71e8f3bde4c48752100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*iYpYM4daNDLiOojW0GpriA.png"/></div></figure><p id="89a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们来分解一下这里的操作。我们可以将每个运算组合起来，得到函数的总Big-O:</p><p id="a2ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">𝑂(1+𝑛/2+10)</p><p id="b745" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，随着n变大，1和10项变得无关紧要，1/2项乘以n也不会有太大影响，因为n趋向于无穷大。这意味着函数只是O(n)。</p><h1 id="4164" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">空间复杂性:</h1><p id="78ab" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">很多时候，我们也关心算法使用多少内存/空间。空间复杂度的符号是相同的，但是我们不是检查操作的时间，而是检查内存分配的大小。</p><p id="23c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lo"><img src="../Images/53994458e5747c77492b6c2883403055.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*4KNdnEYqIx43QDBFNa4miw.png"/></div></figure><p id="62bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们只对“大O符号”变量赋值一次，而不是每次打印时都赋值。因此，该算法具有O(1) <strong class="ih hj">空间</strong>复杂度和O(n) <strong class="ih hj">时间</strong>复杂度，因为它依赖于n值的大小</p><p id="b060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们看一个O(n)空间复杂度的例子:</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lp"><img src="../Images/72c06f4beb5421a2a7903805347a8913.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*HU33ni5LXrp8zmTjv1pq5A.png"/></div></figure><p id="0dbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的函数中，我们可以观察到new_list对象的大小如何随着输入<strong class="ih hj"> n </strong>而缩放，这表明它的时间复杂度和空间复杂度都是O(n)算法，因为每次迭代它都向列表添加“新”字符串，所以它的空间复杂度是O(n)，如果n变大，运行时间也相对于n而增加。因此它的空间和时间的大O符号都是O(n)。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="3f84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何反馈或批评，请随时与我分享。如果本演练对您有所帮助，请喜欢👏文章。干杯！🍻</p></div></div>    
</body>
</html>