<html>
<head>
<title>What is Huffman Coding?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是霍夫曼编码？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-huffman-coding-ea36379da63e?source=collection_archive---------6-----------------------#2019-11-24">https://medium.com/analytics-vidhya/what-is-huffman-coding-ea36379da63e?source=collection_archive---------6-----------------------#2019-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2708" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">霍夫曼码是一种特殊类型的最佳前缀码，通常用于无损数据压缩。这是来自维基百科的定义。霍夫曼对电信专业人士很感兴趣，因为这种编码方法可以大大提高编码效率。对于计算机科学家或程序员来说，这很有趣，因为它使用了贪婪算法和优先级队列数据结构。贪婪算法是一种重要的算法，优先级队列是一种重要的数据结构。</p><p id="3de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得你没有完全理解霍夫曼编码过程，这里有两个很好的视频可以观看。</p><p id="ae51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://youtu.be/fPthQE7Li8M" rel="noopener ugc nofollow" target="_blank">https://youtu.be/fPthQE7Li8M</a></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="5346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看完这两个视频，我想你已经完全理解了霍夫曼编码算法。对于所有的贪婪算法，至少在实践过程中，我们总要问一个问题:如何证明？</p><p id="ea92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非正式的证明可以在这里找到:</p><div class="jl jm ez fb jn jo"><a href="https://www.quora.com/How-do-we-prove-that-the-Huffman-coding-algorithm-is-optimal" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">我们如何证明霍夫曼编码算法是最优的？</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">答案(2之1):霍夫曼码是最佳的，因为:1。它减少了来自终端的未使用码字的数量。</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">www.quora.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc kd jo"/></div></div></a></div><p id="908b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正式的证明可以在这里找到:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ke jk l"/></div></figure><p id="9383" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两点如果能有更深入的了解会有帮助。从</p><ol class=""><li id="af38" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated"><strong class="ih hj">“在最佳代码中，出现频率较高(出现概率较高)的符号将比出现频率较低的符号具有更短的码字。”</strong></li><li id="815c" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">“在最佳码中，出现频率最低的两个符号将具有相同的长度。”</strong></li></ol><p id="66ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此，你可能对霍夫曼编码有了更好的理解。现在，让我们做一些练习。问题是1199。从leetcode构建块的最短时间。</p><div class="jl jm ez fb jn jo"><a href="https://leetcode.com/problems/minimum-time-to-build-blocks/" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">帐户登录- LeetCode</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">leetcode.com</p></div></div><div class="jx l"><div class="kt l jz ka kb jx kc kd jo"/></div></div></a></div><p id="d0dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个难题。然而，这个问题将完全遵循霍夫曼编码方法。如果你觉得把问题转化成霍夫曼问题有困难，这意味着你还需要更多的努力来理解霍夫曼代码。对于这个问题，我们可以看到，如果一个块需要更多的时间来构建，那么覆盖该块的分支将有更少的工人。同时，在建造昂贵的街区期间，我们可以有一些时间来分割更多的工人。这完全可以遵循霍夫曼编码方法。</p><p id="fe82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过一个例子来分析这个问题:分割成本为3的blocks [1，2，4，7，10]。</p><p id="d65d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有几个步骤，这些步骤如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/f7a6c2d2eefcceeb97dc96d41848e5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YcwTOBDUCqhLLI9xoQ_7w.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图1:步骤1:对块进行排序，并将最上面的两个最小的节点涂成绿色。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/1379ddd4b954714a8c2fb5aa832ec787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuLaAZXZHcaWD4DoLilxTA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图2:第二步:通过合并前面两个最小的节点+分割成本，生成一个父节点。两个新的最小节点将以绿色显示。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/408162000b1e343f6ed020ffdf8bde3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgbj1hKNrjk495nJgZ0GdA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图3:步骤3:重复步骤2。浏览过的节点将显示为绿色，最近浏览过的节点将显示为黄色。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/e507f05b941c7e0d08ebacab3fb21a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QKX6xKM0xx3pTRB51IMHQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图4:步骤4</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/da9b1eff6ad569f73905ed2f77a16ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GN9ljrTolPx8XLw43P_vFw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图5:第5步:完成。</figcaption></figure><p id="f90b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看这些步骤，从步骤5开始，如果我们从根节点到叶节点，我们将清楚整个过程:第一层:将一个工人分成2个，一个为具有10个时间单位的块工作，一个为具有11个成本的节点工作。然后，对于为区块11工作的工人，它被进一步分成两个工人，一个为区块7工作，另一个为区块8工作。…它完全遵循霍夫曼编码过程，对吗？唯一稍微不同的是父节点生成必须考虑分裂成本。</p><p id="49ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们构建另一个示例，使其结构类似于此处视频中显示的示例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="105f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Blocks = [2，3，4，5，6]，拆分成本为2。图6中只显示了最终的最优树。此示例还显示了问题描述的场景“请注意，如果两个工人同时拆分，他们将并行拆分，因此成本将被拆分”。从图6中，我们可以看到它的结构与上面给出的视频相似。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/391da2e760ce4dd773e47f5c42e0f10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcUT1UVpaX_EKX6kK-3YVw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图6:第二个例子的最后一步:Blocks = [2，3，4，5，6]，拆分成本为2。在本例中，在生成2和3的父节点后，我们有两个5可供选择。在这个例子中，我们首先考虑2和3的父代5。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/a1e5a2567aa48cedc48019cde125cde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3OTLRkiUrQ8q880plTtZjA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">图7:第二个例子的最后一步:Blocks = [2，3，4，5，6]，拆分成本为2。在本例中，在生成2和3的父节点后，我们有两个5可供选择。在这个例子中，我们首先考虑作为叶节点的5。</figcaption></figure><p id="9510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果理解了Huffman编码部分，代码就简单了(我假设读者熟悉heap。如果没有，我强烈建议读者先找一些教程来理解heap。如果heap适合您，那么代码可以很简单)。解决方案就在这里:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="de22" class="lj lk hi lf b fi ll lm l ln lo">class Solution:<br/>    def minBuildTime(self, blocks: List[int], split: int) -&gt; int:<br/>        heapq.heapify(blocks)<br/>        while True:<br/>            if len(blocks)==1:return blocks[0]<br/>            a, b = heapq.heappop(blocks), heapq.heappop(blocks)<br/>            heapq.heappush(blocks, b+split) # as b is great or eqaul to a, so no need to max(a,b) + split</span></pre><p id="f7ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>