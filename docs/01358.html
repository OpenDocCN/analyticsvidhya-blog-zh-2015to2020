<html>
<head>
<title>Python: Objects everywhere</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:无处不在的对象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-objects-everywhere-a415b3226273?source=collection_archive---------20-----------------------#2019-10-16">https://medium.com/analytics-vidhya/python-objects-everywhere-a415b3226273?source=collection_archive---------20-----------------------#2019-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7f8bf9d5485037db23b928f9a6947433.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*l6SQplsILMRhS1LZf3Zw1Q.jpeg"/></div></figure><p id="0234" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Python语言是一种强大的编程语言，简单易学，优雅的语法和动态类型。它本可以在面向对象编程中使用得更多，是由吉多·范·罗苏姆创建的，Tim Peters在那里创建了Python 的<a class="ae jk" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank"> Zen来描述一些规则，以了解Python如何工作以及幕后的魔力。</a></p><p id="34dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以你需要理解的第一件事是Python中的一切都是一个对象，这意味着每个变量持有一个对象实例，这意味着当你初始化一个对象时，它被赋予一个唯一的对象id，它的类型在运行时被定义，一旦设置就永远不能改变，但是这些对象可以是<strong class="io hj"> <em class="jl">【可变】</em> </strong>或<strong class="io hj"> <em class="jl">不可变</em> </strong>，这取决于它们的状态。</p><p id="3f67" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看看什么是内置类型的对象，如果它们是可变的或不可变的，这个表可以帮助我们理解类型，如果它是可变的或不可变的。</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es jm"><img src="../Images/758ee4a959d0b969559e7c6e25cb2bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*mlY6TNtXby36WGuMVPLp6w.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">内置类型的对象</figcaption></figure><p id="9f2e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，我们如何知道我们的变量是可变的还是不可变的呢？答案很简单，你应该理解<strong class="io hj"> <em class="jl"> id() </em> </strong>和<strong class="io hj"> <em class="jl"> type() </em> </strong>函数。</p><h2 id="7fb4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ix kg kh ki jb kj kk kl jf km kn ko kp bi translated"><strong class="ak"> <em class="kq"> id() </em> </strong>和<strong class="ak"> <em class="kq"> type() </em> </strong>功能</h2><p id="ec57" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj hb bi translated">id()函数以整数的形式返回对象的标识，这个整数通常对应于对象在内存中的位置。</p><p id="0c18" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">type()函数返回一个对象的类型。</p><p id="6e1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来看一个例子，这个例子可以帮助我们理解它是如何工作的</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/fcfad282bbcd2f51c8975eecfaf08a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*wJ29L8BSaQ01lpsvtkbGWw.png"/></div></figure><p id="94b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你在上一部分看到的，我们使用的<strong class="io hj"> <em class="jl">是</em> </strong>运算符，这两个对象的身份是相同的。让我们看另一个使用type()的例子</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/fcfad282bbcd2f51c8975eecfaf08a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*wJ29L8BSaQ01lpsvtkbGWw.png"/></div></figure><p id="67a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们知道了如何比较两个简单的字符串变量来找到类型和id。使用这两个函数，我们可以检查不同类型的对象与变量相关联，以及如何改变对象。如果你不知道一个对象是可变的还是不可变的，最好的方法是看它的标识(id()函数)。</p><h2 id="e29e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ix kg kh ki jb kj kk kl jf km kn ko kp bi translated">可变和不可变对象</h2><p id="3872" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj hb bi translated">正如我们前面讨论的，可变对象可以改变它的状态或内容，而不可变对象不能。</p><blockquote class="kx ky kz"><p id="ea4f" class="im in jl io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated"><strong class="io hj"><em class="hi"/></strong><em class="hi">:</em></p><p id="6d87" class="im in jl io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated"><em class="hi">列表、字典、集合、字节数组</em></p><p id="5386" class="im in jl io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated"><strong class="io hj"> <em class="hi">不可变对象:</em> </strong></p><p id="2341" class="im in jl io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated"><em class="hi"> int，float，complex，string，tuple，冻结集【注:不可变版本集】，bytes </em></p></blockquote><p id="ca83" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个发现对象类型可变性的实例</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="3bd1" class="jv jw hi le b fi li lj l lk ll">x = 10<br/>x = y</span></pre><p id="9d69" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们正在创建一个int类型的对象。标识符x和y指向同一个对象。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="f79d" class="jv jw hi le b fi li lj l lk ll">id(x) == id(y)<br/>id(y) == id(10)</span></pre><p id="1d21" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们做一个简单的手术</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="c5ff" class="jv jw hi le b fi li lj l lk ll">x = x + 1</span></pre><p id="526f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="978a" class="jv jw hi le b fi li lj l lk ll">id(x) != id(y)<br/>id(x) != id(10)</span></pre><p id="9ae6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">标记x的对象被更改。对象10从未被修改。<strong class="io hj">不可变对象创建后不允许修改</strong></p><p id="1a63" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<strong class="io hj">可变对象</strong>的情况下</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="cc45" class="jv jw hi le b fi li lj l lk ll">m = list([1, 2, 3])<br/>n = m</span></pre><p id="3a4e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们正在创建一个list类型的对象。标识符m和m被标记到同一个列表对象，这是3个不可变int对象的集合。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="6b35" class="jv jw hi le b fi li lj l lk ll">id(m) == id(n)</span></pre><p id="0d1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在从列表对象中弹出一个项目确实会改变对象，</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="c976" class="jv jw hi le b fi li lj l lk ll">m.pop()</span></pre><p id="90a7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对象id将不会更改</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="6fa2" class="jv jw hi le b fi li lj l lk ll">id(m) == id(n)</span></pre><p id="1c5b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">修改后，m和n将指向同一个列表对象。列表对象现在将包含[1，2]。</p><p id="ef80" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么从上面的例子中我们看到了什么？</p><ul class=""><li id="794a" class="lm ln hi io b ip iq it iu ix lo jb lp jf lq jj lr ls lt lu bi translated">Python以不同的方式处理可变和不可变对象。</li><li id="0f07" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">不可变对象比可变对象访问起来更快。</li><li id="b2b4" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">当你需要改变对象、例子列表、字典等的大小时，可变对象非常有用..当你需要确保你制作的对象总是保持不变时，就使用不变。</li><li id="0571" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">不可变对象从根本上说“改变”是昂贵的，因为这样做涉及到创建一个副本。改变可变对象的成本很低。</li></ul><h1 id="a94e" class="ma jw hi bd jx mb mc md kb me mf mg kf mh mi mj ki mk ml mm kl mn mo mp ko mq bi translated">不变性中的例外。</h1><p id="b9a3" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj hb bi translated">如前所述，Python容器像元组一样是不可变的。这意味着<code class="du mr ms mt le b">tuple</code>的值在创建后不能更改。但是元组的“值”实际上是一个名称序列，具有不可改变的对象绑定。需要注意的关键是<em class="jl">绑定</em>是不可更改的，而不是它们绑定到的对象。</p><p id="e765" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们考虑一个元组<strong class="io hj"> t =('霍尔伯顿'，[1，2，3]) </strong></p><p id="88bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的tuple <strong class="io hj"> t </strong>包含不同数据类型的元素，第一个是不可变字符串，第二个是可变列表。元组本身是不可变的。即它没有任何改变其内容的方法。同样，字符串是不可变的，因为字符串没有任何可变的方法。但是list对象确实有变异方法，所以它可以被改变。这是一个微妙的点，但仍然很重要:不可变对象<em class="jl">的“值”不能</em>改变，但它的组成对象<em class="jl">可以</em>改变。</p><h1 id="2185" class="ma jw hi bd jx mb mc md kb me mf mg kf mh mi mj ki mk ml mm kl mn mo mp ko mq bi translated">对象如何传递给函数</h1><p id="5f2b" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj hb bi translated">了解可变类型和不可变类型之间的区别，以及它们在传递给函数时是如何被处理的，这对我们来说很重要。当使用适当的对象时，内存效率会受到很大影响。</p><p id="9d9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果一个可变对象在函数中被引用调用，它可以改变原始变量本身。因此，为了避免这种情况，需要将原始变量复制到另一个变量中。不可变对象可以通过引用调用，因为它的值无论如何都不能改变。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="cb1c" class="jv jw hi le b fi li lj l lk ll">def updateList(list1):<br/>    list1 += [10]n = [5, 6]<br/>print(id(n))                  # 140312184155336updateList(n)<br/>print(n)                      # [5, 6, 10]<br/>print(id(n))                  # 140312184155336</span></pre><p id="9559" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从上面的例子中我们可以看到，我们通过引用调用<strong class="io hj">调用了列表，所以对原始列表本身进行了修改。</strong></p><p id="425b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看另一个例子:</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="6bda" class="jv jw hi le b fi li lj l lk ll">def updateNumber(n):<br/>    print(id(n))<br/>    n += 10b = 5<br/>print(id(b))                   # 10055680<br/>updateNumber(b)                # 10055680<br/>print(b)                       # 5</span></pre><p id="0006" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的例子中，同一个对象被传递给函数，但是变量的值没有改变，即使对象是相同的。这就叫<strong class="io hj">传</strong> <strong class="io hj">传值</strong>。这里到底发生了什么？当函数调用该值时，只传递变量的值，而不是对象本身。所以引用对象的变量没有改变，但是对象本身被改变了，但是只是在函数范围内。因此，这种变化没有反映出来。</p><h2 id="e5f0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ix kg kh ki jb kj kk kl jf km kn ko kp bi translated">NSMALLPOSINTS和NSMALLNEGINTS</h2><p id="6c2f" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj hb bi translated">最后一个要知道和理解的主题是Python中为最常用的整数定义的两个宏。这个宏实际上是一个由262个整数组成的数组，以尽可能最快地访问，它们在你初始化<strong class="io hj"> NSMALLPOSINTS </strong>和<strong class="io hj"> NSMALLNEGINTS </strong>时被分配，范围从-5(含)到257(不含)。</p></div></div>    
</body>
</html>