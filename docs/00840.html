<html>
<head>
<title>Create Logistic Regression algorithm from scratch and apply it on data set</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始创建逻辑回归算法，并将其应用于数据集</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/create-logistic-regression-algorithm-from-scratch-and-apply-it-on-data-set-3f16ca5dbdb9?source=collection_archive---------7-----------------------#2019-09-12">https://medium.com/analytics-vidhya/create-logistic-regression-algorithm-from-scratch-and-apply-it-on-data-set-3f16ca5dbdb9?source=collection_archive---------7-----------------------#2019-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="683f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">先决条件</h1><ol class=""><li id="476a" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">基础微积分</li><li id="8e0f" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">Python编程</li></ol><h1 id="6f4f" class="im in hi bd io ip kh ir is it ki iv iw ix kj iz ja jb kk jd je jf kl jh ji jj bi translated">设置环境</h1><ol class=""><li id="0d26" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Jupyter笔记本</li></ol><p id="3bd5" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">Jupyter笔记本是交互式开发和展示数据科学项目的强大工具。Jupyter笔记本将您的代码及其输出集成到一个单独的文档中。该文档将包含文本、数学公式以及代码直接在同一页面中生成的可视化效果。要开始使用Jupyter笔记本，您需要从Python安装Jupyter库。最简单的方法是通过pip:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="3bc2" class="lm in hi li b fi ln lo l lp lq">pip3 install jupyter</span></pre><p id="e8f7" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">这些天我一直推荐使用<code class="du lr ls lt li b">pip3</code>而不是<code class="du lr ls lt li b">pip2</code>，因为从2020年1月1日开始Python 2将不再被支持。</p><p id="0c4b" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">2.NumPy</p><p id="d4bf" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">NumPy是最强大的Python库之一。NumPy是一个开源的数值Python库。NumPy包含一个多维数组和矩阵数据结构。它可以用来在数组上执行许多数学运算，如三角函数、统计和代数例程。NumPy是一个用c实现的库的包装器。Pandas(我们稍后将探讨它们是什么)对象严重依赖于NumPy对象。熊猫扩展NumPy。</p><p id="99fa" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">使用pip安装NumPy包:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="7b9a" class="lm in hi li b fi ln lo l lp lq">pip3 install numpy</span></pre><p id="bdfd" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">3.熊猫</p><p id="848e" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated"><a class="ae lu" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>已经成为Python编程语言中用于数据争论和分析的最流行和最受欢迎的数据科学工具之一。在现实世界中，数据不可避免地是杂乱的。在清理、转换、操作和分析数据方面，熊猫<em class="lv">真的</em>是游戏规则的改变者。简单来说，熊猫帮助收拾残局。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="647b" class="lm in hi li b fi ln lo l lp lq">pip3 install pandas</span></pre><p id="5037" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">4.<a class="ae lu" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a></p><p id="78ae" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">当然，有大量的数据可视化库——但是如果您想知道为什么应该使用Seaborn，简单地说，它为桌面带来了其他工具无法比拟的强大功能。你也可以使用Matplotlib来创建我们将要做的可视化。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="f352" class="lm in hi li b fi ln lo l lp lq">pip3 install seaborn</span></pre><p id="d3fa" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">5.随意</p><p id="07ba" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">顾名思义，我们将使用它来获得数据集的随机分区。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="d568" class="lm in hi li b fi ln lo l lp lq">pip3 install random</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="2871" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">逻辑回归算法</h1><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es lw"><img src="../Images/7b0a542b4b6f503127eae2c891c9ff23.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/1*zI75OEfR6DcvYjHPu2Ddyw.gif"/></div></figure><ul class=""><li id="262a" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">使用乙状结肠激活功能-</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es me"><img src="../Images/9800217904dd02d64d68c91335da700e.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/0*EXIqC5RgnLP5GHGh"/></div></figure><ul class=""><li id="fa62" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">记住线性回归的梯度下降公式，其中使用了均方误差，但我们不能在这里使用均方误差，所以用一些误差E替换</li><li id="4930" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx md jz ka kb bi translated">梯度下降-</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mf"><img src="../Images/944a9ecbc279f97651d17a56639f0ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/0*NvRIVKwdf1vJlCkk"/></div></figure><ul class=""><li id="b6b9" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">逻辑回归-</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mg"><img src="../Images/3e47e79b2704b678ae4bb0eb6de427e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/0*jxsoSed7ERno-KuN"/></div></figure><ul class=""><li id="72e0" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">E的条件:</li></ul><ol class=""><li id="da68" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx jy jz ka kb bi translated">凸的或尽可能凸的</li><li id="5aed" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">应该是θ的函数</li><li id="608d" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">应该是可微的</li></ol><ul class=""><li id="866f" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">所以用，熵=</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mh"><img src="../Images/da163abf70459188cb21a52f9865ef5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:114/0*oFdal2BYbTV_U0hC"/></div></figure><ul class=""><li id="7a52" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">因为我们不能同时使用y hat和y，所以使用交叉熵</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mi"><img src="../Images/7f3d0b3d34b1706a96027bac48e4a87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/0*sb6QNQV74G0i2x-Y"/></div></figure><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mj"><img src="../Images/48f23413f338ca069080264c68decd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:102/0*cc93pWV2ArkFUU-D"/></div></figure><ul class=""><li id="39b1" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">由于第二个条件，增加2个交叉熵CE 1 =</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mi"><img src="../Images/3e0ec3ac4397e979d11567473ad782a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/0*CkRS_FwzBNWno-ma"/></div></figure><ul class=""><li id="a980" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">而CE 2 =</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mk"><img src="../Images/a4e76dbf12d4f98cdcd9dc5ba407f4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/0*vjDT4uprD9qzNyfO"/></div></figure><ul class=""><li id="64a6" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">我们得到二元交叉熵(BCE) =</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es ml"><img src="../Images/22127c4a5c3d197222abc9b455bc2ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/0*BHLb7UWxvi_L2Cjf"/></div></figure><ul class=""><li id="13e3" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">所以现在我们的公式变成了，</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mm"><img src="../Images/4b51b5cf142d6f1c4a1d8ecffafa345a.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/0*VLal7Hh3CkyA5Kdw"/></div></figure><ul class=""><li id="b1be" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">利用简单的链式法则我们得到，</li></ul><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mn"><img src="../Images/f3c79f726052b34d27b94bcd747fb0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/0*WEnXHQrx79Pq6P7i"/></div></figure><ul class=""><li id="5158" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">现在用这个公式应用梯度下降</li></ul><p id="9bc7" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">这就是关于逻辑回归算法的证明，现在我们在代码中实现了上面证明的算法。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="a958" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">密码</h1><p id="055a" class="pw-post-body-paragraph km kn hi jm b jn jo kp kq jp jq ks kt jr mo kv kw jt mp ky kz jv mq lb lc jx hb bi translated">我们将使用<a class="ae lu" href="https://archive.ics.uci.edu/ml/datasets/breast+cancer+wisconsin+(original)" rel="noopener ugc nofollow" target="_blank">乳腺癌数据集</a>来实现我们的逻辑回归算法，该算法可在UCI机器学习库中获得。</p><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mr"><img src="../Images/4e876779d95cf60801197e4bc70347cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*_4yx6z9y6R8X7k2knYY1QQ.png"/></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">数据集描述</figcaption></figure><ul class=""><li id="64f8" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">导入库</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="88ef" class="lm in hi li b fi ln lo l lp lq">import numpy as np<br/>import pandas as pd<br/>import random<br/>import seaborn as sns</span></pre><ul class=""><li id="e3ff" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">数据预处理<br/>加载数据，删除空值。因为我们使用逻辑回归，所以用0和1代替2和4。使用pandas读取数据并删除缺少值的行。</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="1ee8" class="lm in hi li b fi ln lo l lp lq">df=pd.read_csv("breast-cancer.data.txt",na_values=['?'])<br/>df.drop(["id"],axis=1,inplace=True)<br/>df["label"].replace(2,0,inplace=True)<br/>df["label"].replace(4,1,inplace=True)<br/>df.dropna(inplace=True)<br/><br/>full_data=df.astype(float).values.tolist()<br/>df.head()</span></pre><ul class=""><li id="bd78" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">可视化数据——我们将通过seaborn使用成对网格..</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="f160" class="lm in hi li b fi ln lo l lp lq">sns.pairplot(df)</span></pre><ul class=""><li id="319f" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">做主成分分析进行简化学习。</li></ul><p id="3acf" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">没有做PCA的特别需要，因为我们只有9个特性，但我们得到了一个更简单的模型，去掉了其中的3个特性，代码请访问<a class="ae lu" href="https://github.com/Rishit-dagli/Breast-cancer-prediction-ML-Python" rel="noopener ugc nofollow" target="_blank"> github链接</a>。</p><ul class=""><li id="db7e" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">将数据转换为矩阵，用完整的数据矩阵连接一个单位矩阵。也做一个零矩阵，对于初始θ。</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="8716" class="lm in hi li b fi ln lo l lp lq">full_data=np.matrix(full_data)<br/>epoch=150000<br/>alpha=0.001<br/>x0=np.ones((full_data.shape[0],1))<br/><br/>data=np.concatenate((x0,full_data),axis=1)<br/>print(data.shape)<br/><br/>theta=np.zeros((1,data.shape[1]-1))<br/>print(theta.shape)<br/>print(theta)</span></pre><ul class=""><li id="69d4" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">创建训练测试分割</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="dcdb" class="lm in hi li b fi ln lo l lp lq">test_size=0.2<br/>X_train=data[:-int(test_size*len(full_data)),:-1]<br/>Y_train=data[:-int(test_size*len(full_data)),-1]<br/>X_test=data[-int(test_size*len(full_data)):,:-1]<br/>Y_test=data[-int(test_size*len(full_data)):,-1]</span></pre><ul class=""><li id="906c" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">如上所述定义sigmoid函数的代码和BCE。</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e33b" class="lm in hi li b fi ln lo l lp lq">def sigmoid(Z):<br/>    return 1/(1+np.exp(-Z))<br/><br/>def BCE(X,y,theta):<br/>    pred=sigmoid(np.dot(X,theta.T))<br/>    mcost=-np.array(y)*np.array(np.log(pred))-np.array((1 y))*np.array(np.log(1-pred))<br/>    <br/>    return mcost.mean()</span></pre><ul class=""><li id="d6e4" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">定义梯度下降算法，并定义历元数。同样通过1次迭代测试梯度下降。</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="b0e6" class="lm in hi li b fi ln lo l lp lq">def grad_descent(X,y,theta,alpha):<br/>    h=sigmoid(X.dot(theta.T))<br/>    loss=h-y<br/>    dj=(loss.T).dot(X)<br/>    theta -= (alpha/(len(X))*dj)<br/>    return theta<br/>            <br/>cost=BCE(X_train,Y_train,theta)<br/>print("cost before: ",cost)<br/>            <br/>theta=grad_descent(X_train,Y_train,theta,alpha)<br/>            <br/>cost=BCE(X_train,Y_train,theta)<br/>print("cost after: ",cost)</span></pre><ul class=""><li id="c34c" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">用梯度下降代码定义逻辑回归。</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="9da8" class="lm in hi li b fi ln lo l lp lq">def logistic_reg(epoch,X,y,theta,alpha):<br/>    for ep in range(epoch):<br/>#         update theta <br/>        theta=grad_descent(X,y,theta,alpha)<br/>        <br/>#         calculate new loss<br/>        if ((ep+1)%1000 == 0):<br/>            loss=BCE(X,y,theta)<br/>            print("Cost function ",loss)<br/>    return theta<br/><br/>theta=logistic_reg(epoch,X_train,Y_train,theta,alpha)</span></pre><ul class=""><li id="0adc" class="jk jl hi jm b jn ko jp kr jr ma jt mb jv mc jx md jz ka kb bi translated">最后测试代码，</li></ul><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="fe24" class="lm in hi li b fi ln lo l lp lq">print(BCE(X_train,Y_train,theta))<br/>print(BCE(X_test,Y_test,theta))</span></pre><p id="4ecc" class="pw-post-body-paragraph km kn hi jm b jn ko kp kq jp kr ks kt jr ku kv kw jt kx ky kz jv la lb lc jx hb bi translated">现在我们完成了代码</p><figure class="ld le lf lg fd lx er es paragraph-image"><div class="er es mw"><img src="../Images/7c5058805cefad4b5543c4bff6afe883.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/0*y-6X6JmHDvqaq9C7.png"/></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="2976" class="lm in hi bd io mx my mz is na nb nc iw jr nd ne ja jt nf ng je jv nh ni ji nj bi translated">同一项目的一些其他算法</h2><ol class=""><li id="6784" class="jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">多类神经网络</li><li id="4c82" class="jk jl hi jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">随机森林分类器<br/> <a class="ae lu" href="https://gallery.azure.ai/Experiment/Breast-cancer-dataset" rel="noopener ugc nofollow" target="_blank">项目链接</a></li></ol><h2 id="b399" class="lm in hi bd io mx my mz is na nb nc iw jr nd ne ja jt nf ng je jv nh ni ji nj bi translated">GitHub回购:<a class="ae lu" href="https://github.com/Rishit-dagli/Breast-cancer-prediction-ML-Python" rel="noopener ugc nofollow" target="_blank">此处</a></h2><h1 id="17a1" class="im in hi bd io ip kh ir is it ki iv iw ix kj iz ja jb kk jd je jf kl jh ji jj bi translated">关于我</h1><p id="f3e4" class="pw-post-body-paragraph km kn hi jm b jn jo kp kq jp jq ks kt jr mo kv kw jt mp ky kz jv mq lb lc jx hb bi translated"><strong class="jm hj"> Rishit Dagli </strong> <br/> <a class="ae lu" href="http://rishitdagli.ml" rel="noopener ugc nofollow" target="_blank">网站</a> <br/> <a class="ae lu" href="https://www.linkedin.com/in/rishit-dagli-440113165/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></p></div></div>    
</body>
</html>