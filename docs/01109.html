<html>
<head>
<title>Python Iterators and Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python迭代器和可迭代对象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-iterators-and-iterables-b74161c372c6?source=collection_archive---------14-----------------------#2019-10-01">https://medium.com/analytics-vidhya/python-iterators-and-iterables-b74161c372c6?source=collection_archive---------14-----------------------#2019-10-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e28d03abc52bee354b002f95c5316834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRNSOrSZMnIl2J3FM0oE6w.jpeg"/></div></div></figure><p id="0417" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">For循环和Comprehensions用于遍历一个源(列表、字典或集合)，一个接一个地挑选项目并对其执行一些操作。但是有时需要更细粒度的控制。有两个重要的概念，大量的Python语言行为都是基于这两个概念构建的。这些是可迭代对象和迭代器对象。基本上，可迭代对象是那些可以循环的对象。示例包括列表、字符串和元组。</p><p id="4a50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用内置的<strong class="is hj"> iter() </strong>函数将可迭代对象转换为迭代器对象。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5bec" class="jx jy hi jt b fi jz ka l kb kc">iterator = iter(iterable)</span></pre><p id="1be5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迭代器对象可以传递给内置的<strong class="is hj"> next() </strong>函数来获取下一项。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6c14" class="jx jy hi jt b fi jz ka l kb kc">item = next(iterator)</span></pre><p id="0ae7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过Python REPL的一个简单例子来理解这一点。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/daf29c89e5fa675cc6d56b5693f4f03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPNE9IqzITtag2RWv35v-w.png"/></div></div></figure><p id="86f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们首先创建了一个列表，它是一个iterable对象。接下来，我们将这个列表传递给内置的<strong class="is hj"> iter() </strong>函数，这个函数给了我们一个迭代器对象。现在我们可以使用<strong class="is hj"> next() </strong>函数来遍历这个迭代器对象。每次调用next()函数时，它都会从第一项开始给出列表中的下一项。注意，当我们在迭代完所有项目后调用next()函数时，我们会得到一个<strong class="is hj"> StopIteration </strong>异常。</p><p id="f7af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第二个例子中，我们将看到我们可以将一个iterable对象作为参数传递给一个方法。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3b8b" class="jx jy hi jt b fi jz ka l kb kc">def first(iterable):<br/>    iterator = iter(iterable)<br/>    try:<br/>        return next(iterator)<br/>    except StopIteration:<br/>        raise ValueError("iterable is empty")</span><span id="b11e" class="jx jy hi jt b fi ke ka l kb kc">print(first(["1st", "2nd", "3rd"]))<br/>print(first({"1st", "2nd", "3rd"}))<br/>print(first(set()))</span></pre><p id="bfe5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，一个列表或集合的iterable被传递给<strong class="is hj"> first() </strong>方法。因为每次用新的iterable对象调用first()方法时，都会创建一个新的iterator对象。在try块中，对这个iterator对象调用next()方法，它总是返回iterable(列表、集合等)中的第一项。)对象。上面代码的输出是，</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c227" class="jx jy hi jt b fi jz ka l kb kc">1st<br/>2nd<br/>Traceback (most recent call last):<br/>File "iterator.py", line 4, in first<br/>return next(iterator)<br/>StopIteration</span><span id="ea1b" class="jx jy hi jt b fi ke ka l kb kc">During handling of the above exception, another exception occurred:</span><span id="846c" class="jx jy hi jt b fi ke ka l kb kc">Traceback (most recent call last):<br/>File "iterator.py", line 10, in &lt;module&gt;<br/>print(first(set()))<br/>File "iterator.py", line 6, in first<br/>raise ValueError("iterable is empty")<br/>ValueError: iterable is empty</span></pre><p id="1b2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为在最后一次调用中，我们将一个空集传递给了first()函数，它引发了一个<strong class="is hj"> StopIteration </strong>异常，该异常在except块中处理。它会引发ValueError并打印错误消息。</p><p id="10e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，诸如for循环和comprehensions之类的高级结构是直接建立在这个低级迭代协议之上的。</p><p id="69f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读😊</p></div></div>    
</body>
</html>