<html>
<head>
<title>Data Mining → Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据挖掘→聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-mining-clustering-8038e6701c38?source=collection_archive---------11-----------------------#2019-11-03">https://medium.com/analytics-vidhya/data-mining-clustering-8038e6701c38?source=collection_archive---------11-----------------------#2019-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚类是根据对象或实体的特征对它们进行分组，并根据它们的相似性对它们进行聚集。</p><p id="e0d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚类类似于分类，数据被分组。但是，与分类不同的是，组不是预先定义的。相反，通过根据在实际数据中发现的特征找到数据之间的相似性来完成分组。这些组被称为<strong class="ih hj">簇</strong>。</p><p id="a69d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个数据库D = {t1，t2，…..，tn}，定义在任意两个对象ti和tj之间的距离测度dis(ti，tj)和整数值k，聚类问题就是定义一个映射f: D → {1，…..，k}其中每个ti被分配给一个集群Kj，1 &lt; = j &lt; = k .<br/>这里‘k’是集群的数量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/92bda2790769616eda4352bd126d2cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/0*vkRZxGNoEO9aRGJz"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">数据分组</figcaption></figure><p id="89f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">簇是数据对象的集合，其中对象在同一个簇中彼此相似，而在另一个簇中不相似。</p><p id="4089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">聚类分析</strong>是根据数据中发现的特征，寻找数据之间的相似性，并将相似的数据对象分组为簇的过程。</p><p id="90b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聚类是<strong class="ih hj">无监督分类</strong>。没有预定义的类。</p><p id="41b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据是如何聚类的？<br/> </strong>有各种算法用来进行数据聚类。其中有:<br/> 1。k-均值聚类<br/> 2。均值漂移聚类<br/> 3。基于密度的空间聚类</p><ol class=""><li id="9cba" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj"> K-Means聚类:</strong> <br/>每个聚类用聚类的中心来表示。<br/> <strong class="ih hj">算法:</strong> <br/> 1。选择k，集群数量待定<br/> 2。随机选择k个物体作为初始聚类中心<br/> 3。重复<br/> <strong class="ih hj"> 3.1 </strong>使用欧氏距离<br/> <strong class="ih hj"> 3.2 </strong>计算新的聚类中心<br/> 3.2.1计算平均点<br/> <strong class="ih hj"> 4 </strong>将每个对象分配到它们最近的聚类中心<br/> 3.1.1。直到<br/> 4.1没有改变聚类中心<strong class="ih hj">或</strong>，<br/> 4.2没有对象改变其聚类</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/fdcf55fdb9c964b4a966b0a702475db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*8Y2MNFUo4k0ntOykzNgudQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">使用K-均值聚类</figcaption></figure><p id="561f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用K-Means聚类有什么缺点吗？<br/>  1。仅当定义了<em class="jz">含义</em>时适用。<br/> 2。需要预先指定K，即聚类数<br/> 2.1用不同的K值运行算法<br/> 3。无法处理噪音数据和异常值<br/> 4。当集群大小大致相等时效果最佳</p><p id="5287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分层与分区聚类</strong></p><p id="e181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jz">层次聚类:</em> </strong> <br/>一个<em class="jz"> </em>嵌套的聚类集被创建，层次中的每一级都有单独的聚类集。在最低层，每个项目都在自己唯一的群集中。在最高级别，所有项目都属于同一个群。利用这种聚类，不需要输入期望的聚类数。</p><p id="d6b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">层次聚类有两种类型。凝聚式离合器<br/> 2。分裂聚类</p><p id="c641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1 </strong>。聚集聚类<br/>它从与记录一样多的聚类开始，每个聚类只有一个记录。然后，成对的聚类被连续地合并，直到聚类的数量减少到k。在每个阶段，彼此最接近的聚类对被合并。如果继续合并，它将终止于聚类的层次结构，该层次结构仅由包含所有记录的单个聚类构成。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ka"><img src="../Images/3ac98c9b08e7d1dad0ec394430619966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/0*z3fPiQPqdA9w5za0.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">聚集与分裂聚类</figcaption></figure><p id="d521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。</strong>分裂聚类<br/>该算法采用与凝聚方法相反的方法。这些从一个簇中的所有记录开始，然后尝试将簇分成更小的块。</p><p id="24cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jz">划分聚类:</em> </strong> <em class="jz"> <br/> </em>它是一种用于将一个数据集内的观察值根据其相似性划分成多个组的方法。</p><p id="9653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将数据库<strong class="ih hj"> D </strong>的<strong class="ih hj"> n </strong>个对象划分成一组<strong class="ih hj"> k </strong>个簇，这样我们就有了最小的距离平方和。</p><p id="502e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面显示的K-Means聚类的例子是一种使用划分聚类的方法。</p><p id="e5e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">异常值<br/> </strong>异常值是指那些数值与剩余的一组数据相差很大的点。它可能代表数据中的错误，也可能是与其余数据完全不同的正确数据值。</p><p id="33c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们被视为孤立的星团。然而，如果一个聚类算法试图发现更大的聚类，这些离群点将被强制放置在某个聚类中。这一过程可能通过组合两个现有的聚类并将离群值留在其自己的聚类中而导致不良聚类的创建。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/df6ac7db0b59a826f23285da568ed5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*p5Ok0BrNZbGNsbUW.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">局外人</figcaption></figure></div></div>    
</body>
</html>