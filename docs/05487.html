<html>
<head>
<title>Hashing:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希:</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hashing-9d6e439171ef?source=collection_archive---------32-----------------------#2020-04-22">https://medium.com/analytics-vidhya/hashing-9d6e439171ef?source=collection_archive---------32-----------------------#2020-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/3925a017cb2c7a2ff85640817d5ceff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*2F-_sRNRPzUO576wEcEZog.png"/></div></figure><p id="445a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">惠！！</strong> <br/>我相信你一定见过各种各样的搜索技巧。顺序搜索，二分搜索法，其中搜索时间取决于元素的数量，并涉及许多关键比较。<br/>您是否想要一种可以在恒定时间内、在不太关键的比较中为您做到这一点的东西？<br/> <strong class="io hj">听起来不错！！让我们开始吧，</strong></p><blockquote class="jk jl jm"><p id="d078" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">假设我们必须存储某个班级的<strong class="io hj">【n】</strong>名学生的数据，将他们的学号作为<strong class="io hj">键，</strong>和他们的<strong class="io hj">名</strong>作为值<strong class="io hj">。</strong>我们可以获取大小为“n”的数组，并存储与学生编号相对应的学生姓名。由于我们已经将每个姓名唯一地映射到一个编号，因此我们可以直接访问该数据，因此我们可以在恒定时间内获得任何数据，无需进行关键字比较。这种寻址方法被称为<strong class="io hj">直接寻址。</strong>这种类型的寻址仅适用于小数据，并且当可能的键值数量等于要存储的键数量时。</p></blockquote><p id="1c1f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了存储大量数据，同时节省时间和空间，我们使用<strong class="io hj">散列法修改了我们的寻址方法。</strong></p><blockquote class="jk jl jm"><p id="6709" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">从键值生成地址的过程称为<strong class="io hj">散列</strong>，通过散列进行搜索和插入的数组称为<strong class="io hj">哈希表</strong>。</p></blockquote><p id="9fe2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">从键值生成地址:<br/> </strong>哈希函数一般是一种数学函数，用于映射键值及其地址。hash函数将key作为输入，并返回该键的哈希值，该哈希值用作数组中存储该键的地址。密钥可以是任何类型，如整数、字符串等。但是散列值总是一个整数。</p><h2 id="7f4b" class="jr js hi bd jt ju jv jw jx jy jz ka kb ix kc kd ke jb kf kg kh jf ki kj kk kl bi translated"><strong class="ak">密钥— →哈希函数—→地址</strong></h2><p id="5517" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">我们可以这样写-<br/><strong class="io hj"><em class="jn">h(k)= a</em><br/>h</strong>-哈希函数<br/><strong class="io hj">k</strong>-key<br/><strong class="io hj">a</strong>-地址</p><h1 id="e291" class="kr js hi bd jt ks kt ku jx kv kw kx kb ky kz la ke lb lc ld kh le lf lg kk lh bi translated"><strong class="ak">碰撞:</strong></h1><p id="3bf0" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">当哈希函数为不同的键生成相同的地址时，就会发生冲突。映射到相同地址的关键字称为<strong class="io hj">同义词。<br/> </strong>理想情况下，哈希函数应该给所有键一个<strong class="io hj">唯一的地址</strong>，但这<strong class="io hj">实际上是不可能的。</strong>所以，我们应该尽量<strong class="io hj">选择一个最小化冲突的哈希函数。<br/> </strong>在制作使用哈希的算法时，我们必须主要关注两件事:- <br/> <strong class="io hj"> 1。选择将密钥转换为地址的哈希函数。<br/> 2。解决冲突。</strong></p><h1 id="c33d" class="kr js hi bd jt ks kt ku jx kv kw kx kb ky kz la ke lb lc ld kh le lf lg kk lh bi translated">哈希函数:</h1><p id="0b1b" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">正如我们所知，哈希函数作为<strong class="io hj">键</strong>和<strong class="io hj">哈希表之间的映射接口。</strong>如果我们有一个大小为<strong class="io hj"> n，</strong>的哈希表，那么我们需要一个哈希函数来生成范围为<strong class="io hj"> 0到n-1的地址。</strong>基本上我们可以选择哈希函数是- <strong class="io hj"> <br/> 1。容易计算。<br/> 2。生成冲突最小的地址。</strong></p><h1 id="9c64" class="kr js hi bd jt ks kt ku jx kv kw kx kb ky kz la ke lb lc ld kh le lf lg kk lh bi translated"><strong class="ak"> (a)截断(或提取):</strong></h1><p id="6c04" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">这是从密钥计算地址的最简单的方法，这里我们<strong class="io hj">只选择密钥的一部分作为地址</strong>，要么是最右边的数字，要么是最左边的数字。这种方法最简单，但是碰撞的机会更多。<br/>例如- 设我们有5个数字键，54678，87976，98765，32662，表的大小是100，我们决定取哈希表最右边的2个数字作为地址，所以地址分别是78，76，65，62。</p><h1 id="5b19" class="kr js hi bd jt ks kt ku jx kv kw kx kb ky kz la ke lb lc ld kh le lf lg kk lh bi translated"><strong class="ak"> (b)中和法:</strong></h1><p id="e9a1" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">在这种方法中，密钥是平方的，并且取某个中间值作为地址。选择多少位数作为地址取决于表格的大小。如果密钥值对于平方来说非常大，那么我们可以取密钥的一部分并执行中间平方方法。<br/> <strong class="io hj">例如- </strong>说我们有密钥= 1337，1273，1391，1026，在平方上我们分别得到，1787569，1620529，1934881，1052676。并且我们有1000的表大小，所以我们可以取最多三位数的地址，所以地址将是17 <strong class="io hj"> 875 </strong> 69，16 <strong class="io hj"> 205 </strong> 29，19 <strong class="io hj"> 348 </strong> 81，10 <strong class="io hj"> 526 </strong> 76，即875、205、348和526是对应的地址。</p><h1 id="1b01" class="kr js hi bd jt ks kt ku jx kv kw kx kb ky kz la ke lb lc ld kh le lf lg kk lh bi translated"><strong class="ak"> (c)折叠方法:</strong></h1><p id="b813" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated"><strong class="io hj">移位折叠:</strong>在该方法中，密钥被分成不同的部分，其中每个部分的长度与所需地址的长度相同，除了可能是最后一部分。在这之后，被分解的部分被移位并以这样的方式排列，即最低有效数字被排成一行，然后将它们全部相加。<br/> <strong class="io hj">例如- </strong> key = 738239456527，哈希表的大小为1000，所以拆分为三个一组，738、239、456、527，现在将它们全部相加-<br/><strong class="io hj">738+239+456+527 = 1960，</strong>现在忽略最后一个进位，哈希地址变为= 960。</p><p id="7b75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">边界折叠:</strong>在这种方法中，假设密钥写在纸上，纸在密钥各部分的边界处折叠，所以所有偶数部分在相加前都是反的。<br/> <strong class="io hj">例如- </strong> key = 738239456527，哈希表的大小是1000，所以折叠并拆分成三个一组，738、<strong class="io hj"> 932 </strong>、456、<strong class="io hj"> 725 </strong>，现在将它们全部相加- <br/> <strong class="io hj"> 738 + 932+ 456 + 725= 2851，</strong>现在忽略最后一个进位，哈希地址变成= 851</p><h1 id="0fba" class="kr js hi bd jt ks kt ku jx kv kw kx kb ky kz la ke lb lc ld kh le lf lg kk lh bi translated">除法(模除法):</h1><p id="6ac7" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj hb bi translated">这里，密钥除以表的大小，取模数值作为地址。</p><p id="7320" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> H(k) = k mod m <br/><br/>例如，假设表的大小为100，关键字为987，765，653，234<br/>987% 100 = 87<br/>765% 100 = 65<br/>653% 100 = 53<br/>234% 100 = 34<br/>87，65，53，34是对应的哈希地址。</strong></p><p id="eb81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">谢谢你！！！！。</strong></p></div></div>    
</body>
</html>