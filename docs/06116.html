<html>
<head>
<title>Creating Gstreamer Multimedia Pipeline With C++ Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++创建Gstreamer多媒体管道(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-gstreamer-multimedia-pipeline-with-c-part-2-d3085c471747?source=collection_archive---------0-----------------------#2020-05-12">https://medium.com/analytics-vidhya/creating-gstreamer-multimedia-pipeline-with-c-part-2-d3085c471747?source=collection_archive---------0-----------------------#2020-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/59c4961eec70db57b6b6e1f67b57ec00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFUispXJexdzaDyjbvA9kQ.jpeg"/></div></div></figure><p id="232d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了掌握这篇文章的完整内容，请阅读我之前的<a class="ae jo" rel="noopener" href="/@karthickai/creating-gstreamer-multimedia-pipeline-with-c-part-1-a7f0f86b5e1f">帖子</a>。</p><p id="0b58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你正在从事边缘人工智能或计算机视觉项目，你一定会遇到Gstreamer框架。对Gstreamer有很好的了解将对您的项目有很大的帮助。</p><p id="5374" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文第2部分展示了使用GStreamer所需的其他基本概念，主要是</p><ul class=""><li id="88df" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">Gstreamer多线程</li><li id="c67c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Gstreamer解复用器</li><li id="af9a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Gstreamer三通</li><li id="dc84" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Gstreamer队列</li><li id="fe75" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">GStreamer可视化</li><li id="36e8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">GStreamer重采样</li><li id="c257" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Gstreamer文件链接。</li></ul><p id="6ee2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成本文后，您将获得“动态”构建Gstreamer管道的必要知识。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/8dce86f6146a6d39ebb8c3dd2668148a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMJIomlPV6Vtnzy0j9WSRQ.png"/></div></div></figure><p id="2d36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始构建一个动态管道项目。源是网络视频，然后转换为音频信号，使用<code class="du ki kj kk kl b">tee</code>元素将其分离(它通过其源焊盘发送通过其接收焊盘接收的所有内容)。然后，一个分支将信号发送到filesink以保存音频文件，另一个分支呈现波形的视频并将其发送到屏幕。</p><h2 id="ee4f" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">完整的管道图:</h2><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/d11c0a2f526e70a7fa3e370c1d141250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uyn_9cKfvh4nqXDbY_Ewcw.png"/></div></div></figure><h2 id="3555" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">文件结构</h2><ul class=""><li id="72ac" class="jp jq hi is b it li ix lj jb lk jf ll jj lm jn ju jv jw jx bi translated"><em class="ln"> CmakeLists.txt </em></li><li id="c434" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><em class="ln"> main.cpp </em></li></ul><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h2 id="2c0c" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">游戏攻略</h2><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="b48d" class="km kn hi kl b fi lu lv l lw lx"><em class="ln">struct </em>CustomData {<br/>    GstElement *pipeline;<br/>    GstElement *source;<br/>    GstElement *convert;<br/>    GstElement *resample;<br/>    GstElement *tee;<br/>    GstElement *audio_queue;<br/>    GstElement *wavenc;<br/>    GstElement *sink;<br/>    GstElement *wave_queue;<br/>    GstElement *visual;<br/>    GstElement *wave_convert;<br/>    GstElement *wave_sink;<br/><br/>};</span></pre><p id="2537" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们已经将所有需要的信息(基本上是指向GstElements的指针)保存为局部变量。由于本教程(和大多数真实的应用程序)涉及回调，我们将所有的数据组织在一个结构中，以便于处理。</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="791f" class="km kn hi kl b fi lu lv l lw lx">/* Handler for the pad-added signal */<br/>static void pad_added_handler (GstElement *src, GstPad *pad, CustomData *data);</span></pre><p id="66e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个前向参考，以后会用到。</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="7a02" class="km kn hi kl b fi lu lv l lw lx">data.source = gst_element_factory_make("uridecodebin", "source");<br/>data.tee = gst_element_factory_make("tee", "tee");<br/>data.audio_queue = gst_element_factory_make("queue", "audio_queue");<br/>data.convert = gst_element_factory_make("audioconvert", "convert");<br/>data.resample = gst_element_factory_make("audioresample", "resample");<br/>data.wavenc = gst_element_factory_make("wavenc", "wavenc");<br/>data.sink = gst_element_factory_make("filesink", "sink");<br/>data.wave_queue = gst_element_factory_make("queue", "wave_queue");<br/>data.visual = gst_element_factory_make ("wavescope", "visual");<br/>data.wave_convert = gst_element_factory_make ("videoconvert", "csp");<br/>data.wave_sink = gst_element_factory_make ("autovideosink", "wave_sink");</span></pre><p id="cb30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将照常创建元素。<code class="du ki kj kk kl b">uridecodebin</code>将在内部实例化所有必要的元素(源、解复用器和解码器),将URI转换为原始音频和/或视频流。它做的工作是<code class="du ki kj kk kl b">playbin</code>的一半。由于它包含解复用器，其源焊盘最初是不可用的，我们将需要在飞行中链接到它们。</p><p id="e281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">audioconvert</code>对于不同音频格式之间的转换很有用，确保这个例子可以在任何平台上工作，因为音频解码器产生的格式可能与音频接收器预期的不同。</p><p id="3f8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">audioresample</code>对于不同的音频采样率之间的转换很有用，同样确保这个例子可以在任何平台上工作，因为音频解码器产生的音频采样率可能不是音频接收器支持的。</p><p id="22e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">wavescope</code>使用autovideosink消耗音频信号并在显示器上渲染波形。</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="7609" class="km kn hi kl b fi lu lv l lw lx"><em class="ln">if </em>(!gst_element_link_many(data.convert, data.resample, data.tee, <strong class="kl hj">NULL</strong>) || !gst_element_link_many(data.audio_queue, data.wavenc, data.sink, <strong class="kl hj">NULL</strong>) || !gst_element_link_many(data.wave_queue, data.visual, data.wave_convert,data.wave_sink, <strong class="kl hj">NULL</strong>)) {<br/>    g_printerr("Elements could not be linked");<br/>    gst_object_unref(data.pipeline);<br/>    <em class="ln">return </em>-1;<br/>}</span></pre><p id="3d9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们将convert元素链接到tee，但我们<strong class="is hj">没有</strong>将它们与源链接，因为此时它不包含源焊盘。我们只是让这个分支(converter - &gt; tee)不链接，直到以后。</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="03af" class="km kn hi kl b fi lu lv l lw lx">tee_audio_pad = gst_element_get_request_pad(data.tee, "src_%u");<br/>g_print("Obtained request pad %s for audio branch.\n", <strong class="kl hj">gst_pad_get_name </strong>(tee_audio_pad));<br/>tee_wave_pad = gst_element_get_request_pad(data.tee, "src_%u");<br/>g_print("Obtained request pad %s for audio branch.\n", <strong class="kl hj">gst_pad_get_name </strong>(tee_wave_pad));<br/>queue_audio_pad = gst_element_get_static_pad(data.audio_queue, "sink");<br/>queue_wave_pad = gst_element_get_static_pad(data.wave_queue, "sink");<br/><br/><em class="ln">if </em>(gst_pad_link(tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||<br/>    gst_pad_link(tee_wave_pad, queue_wave_pad) != GST_PAD_LINK_OK) {<br/>    g_printerr("Tee could not be linked.\n");<br/>    gst_object_unref(data.pipeline);<br/>    <em class="ln">return </em>-1;<br/>}<br/>gst_object_unref(queue_audio_pad);<br/>gst_object_unref(queue_wave_pad);</span></pre><p id="3672" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要链接请求板，需要通过将它们“请求”到元素来获得它们。一个元素可能能够产生不同种类的请求板，因此，当请求它们时，必须提供所需的板模板名称。在<code class="du ki kj kk kl b">tee</code>元素的文档中，我们看到它有两个pad模板，名为“sink”(用于其sink Pads)和“src_%u”(用于请求pad)。我们从带有<code class="du ki kj kk kl b">gst_element_get_request_pad()</code>的球座处要求两个衬垫(用于音频和波形分支)。</p><p id="fdfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们从这些请求pad需要链接到的下游元素获取pad。这些都是正常的总是垫，所以我们用<code class="du ki kj kk kl b">gst_element_get_static_pad()</code>获得它们。</p><p id="e894" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们用<code class="du ki kj kk kl b">gst_pad_link()</code>链接pads。这是<code class="du ki kj kk kl b">gst_element_link()</code>和<code class="du ki kj kk kl b">gst_element_link_many()</code>内部使用的功能。</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="aed2" class="km kn hi kl b fi lu lv l lw lx">g_signal_connect (data.source, "pad-added", G_CALLBACK (pad_added_handler), &amp;data);</span></pre><p id="8fdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">GSignals</code>是GStreamer中至关重要的一点。当有趣的事情发生时，它们允许您得到通知(通过回调的方式)。信号通过名称识别，每个<code class="du ki kj kk kl b">GObject</code>都有自己的信号。</p><p id="b259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们的源元素最终有足够的信息开始产生数据时，它将创建源焊盘，并触发“焊盘添加”信号。此时，我们的回调将被调用:</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="8a52" class="km kn hi kl b fi lu lv l lw lx">static void pad_added_handler (GstElement *src, GstPad *new_pad, CustomData *data) {</span></pre><p id="78e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">src</code>是触发信号的<code class="du ki kj kk kl b">GstElement</code>。在这个例子中，它只能是<code class="du ki kj kk kl b">uridecodebin</code>。</p><p id="51c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">new_pad</code>是刚刚添加到<code class="du ki kj kk kl b">src</code>元素中的<code class="du ki kj kk kl b">GstPad</code>。这通常是我们要链接的凸台。</p><p id="e77d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">data</code>是我们在附加信号时提供的指针。在这个例子中，我们用它来传递<code class="du ki kj kk kl b">CustomData</code>指针。</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="a40d" class="km kn hi kl b fi lu lv l lw lx">GstPad *sink_pad = gst_element_get_static_pad(data-&gt;convert, "sink");</span></pre><p id="aa67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从<code class="du ki kj kk kl b">CustomData</code>中，我们提取转换器元素，然后使用<code class="du ki kj kk kl b">gst_element_get_static_pad ()</code>检索其汇点。这是我们想要链接的焊盘<code class="du ki kj kk kl b">new_pad</code></p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="03b0" class="km kn hi kl b fi lu lv l lw lx"><em class="ln">/* Check the new pad's type */<br/></em>new_pad_caps = gst_pad_get_current_caps(new_pad);<br/>new_pad_struct = gst_caps_get_structure(new_pad_caps, 0);<br/>new_pad_type = gst_structure_get_name(new_pad_struct);<br/><em class="ln">if </em>(!g_str_has_prefix(new_pad_type, "audio/x-raw")) {<br/>    g_print("It has type '%s' which is not raw audio. Ignoring.\n", new_pad_type);<br/>    <em class="ln">goto </em>exit;<br/>}</span></pre><p id="4024" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将检查这个新pad将要输出的数据类型，因为我们只对产生音频的pad感兴趣。我们之前已经创建了一个处理音频的管道(一个<code class="du ki kj kk kl b">audioconvert</code>与一个<code class="du ki kj kk kl b">audioresample</code>和<code class="du ki kj kk kl b">tee</code>链接)</p><p id="de43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果名字不是<code class="du ki kj kk kl b">audio/x-raw</code>，这就不是解码音频板，我们对它不感兴趣。</p><p id="f161" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">否则，尝试链接:</p><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="13f4" class="km kn hi kl b fi lu lv l lw lx">ret = gst_pad_link(new_pad, sink_pad);<br/><em class="ln">if </em>(<strong class="kl hj">GST_PAD_LINK_FAILED </strong>(ret)) {<br/>    g_print("Type is '%s' but link failed.\n", new_pad_type);<br/>} <em class="ln">else </em>{<br/>    g_print("Link succeeded (type '%s').\n", new_pad_type);<br/>}</span></pre><p id="1eb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ki kj kk kl b">gst_pad_link()</code>尝试连接两个焊盘。最后我们完成了，<strong class="is hj"> <em class="ln">源</em> </strong>与<strong class="is hj"> <em class="ln">三通</em> </strong>通过<strong class="is hj"> <em class="ln">转换</em> </strong>和<strong class="is hj"> <em class="ln">重采样。三通</em> </strong> <em class="ln"> </em>与<strong class="is hj"> <em class="ln">音频_队列</em> </strong>和<strong class="is hj"> <em class="ln">波_队列</em> </strong>然后<strong class="is hj"> <em class="ln">音频_队列</em> </strong>与<strong class="is hj"> <em class="ln">文件链接</em> </strong>保存一个wav文件使用<strong class="is hj"> <em class="ln"> wavenc </em> </strong>编码器和<strong class="is hj"> <em class="ln">波_队列</em> </strong></p><h2 id="760c" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">构建和执行:</h2><pre class="ke kf kg kh fd lq kl lr ls aw lt bi"><span id="b27c" class="km kn hi kl b fi lu lv l lw lx">git clone <a class="ae jo" href="https://github.com/karthickai/gstreamer.git" rel="noopener ugc nofollow" target="_blank">https://github.com/karthickai/gstreamer.git</a><br/>cd gstreamer/gstreamer-02<br/>mkdir build; cd build<br/>cmake ../<br/>make<br/>./gstreamer-02</span></pre><h2 id="9b61" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">输出:</h2><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/2721d81ef6a609244856ee5581fa466a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Pf09avB97a4bslnIFENu6Q.gif"/></div></figure><h2 id="aa20" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">链接:</h2><div class="lz ma ez fb mb mc"><a href="https://github.com/karthickai/gstreamer.git" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hj fi z dy mh ea eb mi ed ef hh bi translated">karthickai/gstreamer</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">使用C++开始使用Gstreamer。为karthickai/gstreamer开发做贡献，创建一个帐户…</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq io mc"/></div></div></a></div><p id="385f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读。</p><p id="480c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有任何建议/问题，请在评论区告诉我们！</p></div></div>    
</body>
</html>