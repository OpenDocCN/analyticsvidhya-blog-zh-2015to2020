<html>
<head>
<title>Independent Component Analysis for Signal decomposition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于信号分解的独立分量分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/independent-component-analysis-for-signal-decomposition-3db954ffe8aa?source=collection_archive---------5-----------------------#2020-04-18">https://medium.com/analytics-vidhya/independent-component-analysis-for-signal-decomposition-3db954ffe8aa?source=collection_archive---------5-----------------------#2020-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/deab13e4f01f8ddf8fd4b56d15c77f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6ahiOqtwW6mxgk-WCDvlg.jpeg"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="768b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">独立分量分析是一种计算技术，用于将多元信号分解成可加的子分量。该方法的主要假设是所有信号源在统计上是独立的，并且不遵循高斯曲线。ICA是盲源分离方法的一个特例。著名的“鸡尾酒会问题”之一——在嘈杂的房间里听到特定的一个人的声音，是一个常见的例子，被称为ICA算法的应用。</p><h1 id="389a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">数学定义</strong></h1><p id="416b" class="pw-post-body-paragraph ix iy hi iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju hb bi translated">如果我们取统计上独立的信号源<strong class="iz hj"> Sₖ </strong>其中<strong class="iz hj"> k = { 1，2，3，…，n} </strong>和混合基向量Aᵢₖ其中i = {1，2，3，…，m}那么观察到的混合信号可以表示为<strong class="iz hj"> Xᵢₖ = ∑ SₖAᵢₖ </strong></p></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="6f09" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在我将展示如何使用Python来生成信号，混合信号，然后分解它们。</p><p id="2e50" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">首先，我们将主要引入<strong class="iz hj">Numpy</strong>(Python的数学库)<strong class="iz hj"> Matplotlib </strong>(用于显示图形)<strong class="iz hj"> Scikit-learn </strong>(充实了机器学习工具和算法)<strong class="iz hj"> Scipy </strong>(统计库)。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="f1f1" class="lh jw hi ld b fi li lj l lk ll"><strong class="ld hj">import</strong> <strong class="ld hj">numpy</strong> <strong class="ld hj">as</strong> <strong class="ld hj">np</strong><br/><strong class="ld hj">import</strong> <strong class="ld hj">matplotlib.pyplot</strong> <strong class="ld hj">as</strong> <strong class="ld hj">plt</strong> <br/><strong class="ld hj">from</strong> <strong class="ld hj">sklearn.decomposition</strong> <strong class="ld hj">import</strong> FastICA, PCA<br/><strong class="ld hj">from</strong> <strong class="ld hj">scipy</strong> <strong class="ld hj">import</strong> signal</span><span id="93a7" class="lh jw hi ld b fi lm lj l lk ll">np.random.seed(123)<br/>n_samples = 3000                  <em class="ln">## for x axis </em><br/>time = np.linspace(0,8,n_samples)  <em class="ln">## for y axis</em></span></pre><p id="9559" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">random.seed有助于每次生成相同的随机样本。现在我们取3000个样本，用numpy的linespace函数在Y轴上绘制时间图。</p><p id="716d" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在我将使用内置函数生成三种不同类型的波。在这里，我选择了正弦波，方波和锯齿波进行实验。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/104841018ba90252dafb556cf9963511.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*lMPnmbBCpVoOHKif29epxQ.jpeg"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">正弦波</figcaption></figure><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/1322f9c20e95cdfc779d6164fb7889d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/1*DrBBhRP-eBtYWffO31Kd_A.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">锯齿波</figcaption></figure><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/3d80a1f68596f53d4f8555c633e2fa8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-kpJ9cWiVzgcg2_v7PxzA.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">方波</figcaption></figure><p id="1d4c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我生成了三种信号s1，s2，s3。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="0063" class="lh jw hi ld b fi li lj l lk ll"><em class="ln">## Generating Different Types of Signals </em><br/><br/><br/>s1 = np.sin(2*time)                              <em class="ln">## Sinusoidal Wave </em><br/>s2 = np.sign(np.sin(3*time))                        #<em class="ln"># Square Wave</em><br/>s3 = signal.sawtooth(2 * np.pi * time)             <em class="ln">## Saw tooth Wave</em></span></pre><p id="9c21" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，我将混合这些信号，并添加随机噪声，这在本质上是可加性的，遵循高斯分布。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="df6f" class="lh jw hi ld b fi li lj l lk ll">S = np.c_[s1, s2, s3]  ## Mixing of Signals ( Ground Truth )<br/>S += 0.2 * np.random.normal(size=S.shape) <em class="ln"># Adding Noise </em></span></pre><p id="19b3" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在将标准化数据并取一个基向量，该基向量将决定信号彼此混合的比例。将使用基向量A和信号混合物S的点积来产生观察混合物</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="bb00" class="lh jw hi ld b fi li lj l lk ll"><em class="ln">## Standardize the data </em></span><span id="e5c6" class="lh jw hi ld b fi lm lj l lk ll">S /= S.std(axis=0)<br/><em class="ln">## Mixing the Data </em><br/><br/>A = np.array([[1,1,1],[0.5,2,1.0],[1.5,1.0,2.0]])   <em class="ln">## Mixing Matrix </em></span><span id="e511" class="lh jw hi ld b fi lm lj l lk ll"><em class="ln"># Create the Observation Data for ICA </em><br/><br/>X = np.dot(S,A.T)</span></pre><p id="d6f1" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这里我使用<a class="ae lv" href="https://en.wikipedia.org/wiki/FastICA" rel="noopener ugc nofollow" target="_blank"> FastICA </a>算法作为ICA模型。在拟合变换之后使用该模型将能够分别分解混合矩阵和信号混合物A_和S_</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="a3a6" class="lh jw hi ld b fi li lj l lk ll">ica = FastICA(n_components=3)<br/>S_ = ica.fit_transform(X)   <em class="ln">## Get Estimated Signals</em><br/><br/>A_ = ica.mixing_</span></pre><p id="72a7" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了交叉验证，我现在将断言我们得到的结果与地面真相。我将让我的观众通过运行整个代码来分析结果。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="a756" class="lh jw hi ld b fi li lj l lk ll"><em class="ln">## Assertion for Proving that ICA Signals unmixing and Reverting</em><br/><br/><strong class="ld hj">assert</strong> np.allclose(X, np.dot(S_,A_.T)+ica.mean_)</span></pre><p id="0266" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们还使用主成分分析计算了结果，以直观地显示ICA如何在混合信号的分解中表现得更好。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="7df0" class="lh jw hi ld b fi li lj l lk ll"><em class="ln">## Computing PCA for Comparison</em><br/>pca = PCA(n_components=3)<br/>H = pca.fit_transform(X)</span></pre><p id="2173" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了直观地观察算法的工作结果，我用观察数据、地面实况、ICA、PCA结果绘制了图表。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="0564" class="lh jw hi ld b fi li lj l lk ll"><em class="ln">## Plotting the results </em><br/><br/>plt.figure()<br/>models = [X, S,S_,H]<br/><br/>names= ['Observations(Mixed All Signals)', <br/>        'Groud Truth','ICA Recovered', 'PCA Recovered']<br/>colors = ['red', 'blue', 'orange']<br/><strong class="ld hj">for</strong> i, (model,name) <strong class="ld hj">in</strong> enumerate(zip(models,names), 1):<br/>    plt.subplot(4,1,i)<br/>    plt.title(name)<br/>    <strong class="ld hj">for</strong> sig ,color <strong class="ld hj">in</strong> zip(model.T,colors):<br/>        plt.plot(sig,color=color)<br/><br/>plt.subplots_adjust(0.39,0.54,1.5,1.5,1,0.76)<br/>plt.show()</span></pre><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/d4e78e764cecc5353699ee6e73b06af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*j4Je2aYJmwwUcgrZ-aSgRA.png"/></div></figure><p id="5a90" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">从直观的结果我们可以得出结论，独立分量分析是信号分解的最佳选择。因此，我们可以在音频信号降噪、图像降噪中使用这种技术，并从图像的叠加中分解不同的分量。</p><p id="6b57" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">今天到此为止。！！！！！！！！！</p><p id="ec58" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我保证我会拿出这种小信息算法和技术作为我的读者的快速指南。要获取更新，请关注我。</p><p id="4839" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">非常感谢你的时间。</p></div></div>    
</body>
</html>