<html>
<head>
<title>Basic Data Pre-Processing in Python using pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用pandas在Python中进行基础数据预处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basic-data-pre-processing-in-python-using-pandas-7ec775251781?source=collection_archive---------0-----------------------#2019-05-06">https://medium.com/analytics-vidhya/basic-data-pre-processing-in-python-using-pandas-7ec775251781?source=collection_archive---------0-----------------------#2019-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d2bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据科学家需要执行几个数据预处理步骤。今天，我在博客中列出了一些常见的步骤。这个博客的Jupyter笔记本可以从<a class="ae jd" href="https://github.com/vikeshsingh37/PythonTutorials/blob/master/DataProcessingInPython.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>获得</p><p id="c912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始吧。我从<a class="ae jd" href="https://data.cityofchicago.org/Public-Safety/Crimes-2001-to-present/ijzp-q8t2" rel="noopener ugc nofollow" target="_blank">犯罪2018 </a>中获取了这个故事的数据。数据存储在csv文件中。</p><h1 id="cbec" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">负载数据</strong></h1><p id="2958" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">第一步是读取csv文件。如果文件不是很大，我们可以一次性读取文件。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2632" class="kq jf hi km b fi kr ks l kt ku">import pandas as pd<br/>dat = pd.read_csv("Crimes2018.csv")</span></pre><p id="4064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果文件很大，我们可以使用pd.read_csv()中的chunksize以小数据块的形式读取文件。chunksize是每次迭代中读取的行数。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8cf6" class="kq jf hi km b fi kr ks l kt ku">for chunk in pd.read_csv("Crimes2018.csv", chunksize = 10000):<br/>     dat = chunk<br/>     ## Do what ever operation you want <br/>     print(chunk.shape)</span></pre><h1 id="eee6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">检查加载的数据</strong></h1><p id="ffb3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们假设文件不是很大，数据是一次性读取的。现在，让我们看看前5行数据。为此，</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="dd8b" class="kq jf hi km b fi kr ks l kt ku">dat.head()</span></pre><p id="1443" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果想打印更多的行，将行数作为参数传递给head。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3138" class="kq jf hi km b fi kr ks l kt ku">dat.head(10)</span></pre><p id="1189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看数据框中有多少行和列</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c880" class="kq jf hi km b fi kr ks l kt ku">dat.shape</span></pre><p id="f439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很好，我们已经看到了如何读取csv文件，检查数据的前几行以及数据中的行数和列数。</p><p id="b004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是如何获得数据帧的摘要。这里有数字列和分类列。因此，在描述函数中使用了“include = all”。否则，将只显示数字列摘要</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3dd6" class="kq jf hi km b fi kr ks l kt ku">dat.describe(include = 'all')</span></pre><h1 id="6b20" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">查找分类和数字列</strong></h1><p id="d5c3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">很多时候需要识别分类列，例如对于一个热编码。下面的代码行将告诉我们哪些列是分类的，哪些是其他的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fb18" class="kq jf hi km b fi kr ks l kt ku">cat_cols = dat.columns[(dat.dtypes == "object").tolist()].tolist()<br/>num_cols = dat.columns[(dat.dtypes != 'object').tolist()].tolist()</span></pre><h1 id="79a8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">查找缺少值的列和行</strong></h1><p id="9730" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在是缺失值列。下面将显示dat的列中缺少的行数。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0115" class="kq jf hi km b fi kr ks l kt ku">missing_vals = dat.isnull().sum()<br/>missing_vals</span></pre><p id="2502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获取缺少值的列的列表:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8b03" class="kq jf hi km b fi kr ks l kt ku">missing_vals_cols = missing_vals[missing_vals &gt; 0].axes[0].tolist()<br/>missing_vals_cols</span></pre><p id="730c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以看到缺少值的数据行。比方说，我们想检查哪些行缺少“位置描述”</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="05be" class="kq jf hi km b fi kr ks l kt ku">dat.loc[dat['Location Description'].isnull()]</span></pre><h1 id="3279" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">估算缺失值</strong></h1><p id="96b0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">处理缺失值需要大量的研究和专业知识。我在这里只是告诉如何填充NA值，而不是插补策略。假设我们想用一个常数值(比如10)估算“病房”列中的NA值。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="25ad" class="kq jf hi km b fi kr ks l kt ku">dat['Ward'].fillna(10)</span></pre><p id="00cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这不会替换dat数据框中的值。为此，需要使用inplace = True</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7ec0" class="kq jf hi km b fi kr ks l kt ku">dat['Ward'].fillna(10, inplace = True)</span></pre><p id="f9da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而不是10，如果有人想用“Ward”的中值代替NA值</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="497b" class="kq jf hi km b fi kr ks l kt ku">dat['Ward'].fillna(dat['Ward'].median(skipna = True), inplace = True)</span></pre><p id="99f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法适用于数字列。对于分类列，可以使用模式或字符“NotAvailable”。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a859" class="kq jf hi km b fi kr ks l kt ku"># Replace NA by NotAvailable<br/>dat['Location Description'].fillna("NotAvailable", inplace= True)</span><span id="23f6" class="kq jf hi km b fi kv ks l kt ku"># Replace NA by Mode<br/>dat['Location Description'].fillna(dat['Location Description'].mode().tolist()[0], inplace= True)</span></pre><h1 id="e3d3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">删除缺少值的行</strong></h1><p id="c967" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有几行数据不能用任何方法估算。需要移除这些行，而机器学习算法无法处理这些行。缺失值的行数可由下式得出:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="cfb8" class="kq jf hi km b fi kr ks l kt ku">num_missing_rows = dat.isnull().any(axis =1).sum()</span></pre><p id="c328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺少值的行可以通过以下方式删除:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b975" class="kq jf hi km b fi kr ks l kt ku">dat.dropna(axis =0, inplace = True)<br/>dat.reset_index(inplace = True)</span></pre><h1 id="ef8e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">删除列</strong></h1><p id="bf7d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">可能需要删除一些列。假设我们想要删除“纬度”和“经度”列。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="dccc" class="kq jf hi km b fi kr ks l kt ku">dat.drop(['Latitude','Longitude'],axis = 1, inplace = True)</span></pre><h1 id="cae8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">对列中的值进行排序</strong></h1><p id="1f69" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">比方说，我们希望按照日期升序和IUCR降序对数据框进行排序。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2935" class="kq jf hi km b fi kr ks l kt ku">dat.sort_values(["Date","IUCR"],ascending=[True, False], inplace = True)<br/>dat.reset_index(inplace = True)</span></pre><h1 id="da27" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">将一列拆分成多列</strong></h1><p id="e98b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">可能需要用分隔符拆分列中的值，并创建两个新列。假设我们想要将“位置”列拆分为纬度和经度。数据中位置列的一个例子是(41.881892729，-87.38515564)</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="020a" class="kq jf hi km b fi kr ks l kt ku">pattern = '|'.join(['\\(','\\)'])<br/>dat = pd.concat([dat,dat["Location"].str.replace(pat = pattern,repl = "").str.split(",",expand = True)], axis = 1)</span><span id="b8d8" class="kq jf hi km b fi kv ks l kt ku"># Rename columns<br/>dat.rename(index =str, columns = {0:'Latitude',1:'Longitude'}, inplace=True)</span><span id="7eb9" class="kq jf hi km b fi kv ks l kt ku"># Convert all columns to lowercase<br/>dat.rename(str.lower, axis = 1, inplace= True)</span></pre><h1 id="40f2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">从分类列创建虚拟列</strong></h1><p id="9acc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">分类列中的值有时需要作为列存在。一种方法是添加虚拟变量。下面创建了“主要类型”列的虚拟变量，并将其添加到数据框中。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="de40" class="kq jf hi km b fi kr ks l kt ku">dat = pd.concat([dat,pd.get_dummies(dat["primary type"])], axis = 1)<br/>dat.drop("primary type", axis = 1, inplace = True)<br/>dat.rename(str.lower, axis = "columns", inplace = True)<br/>dat.reset_index(drop=True,inplace=True)</span></pre><h1 id="5b9d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">按操作分组</h1><p id="1ef6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">很多时候需要通过操作来做一组。下面的例子给出了按“日期”和“位置描述”分组的“盗窃”的总和</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b26f" class="kq jf hi km b fi kr ks l kt ku">pd.DataFrame(dat.groupby(["date","location description"])["theft"].sum()).reset_index()</span></pre><h1 id="8e7d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">筛选列中的行值</h1><p id="5cd5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">可以过滤列中的行值。位置描述为公寓或街道且盗窃为0的示例过滤数据。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5ef8" class="kq jf hi km b fi kr ks l kt ku">dat[dat["location description"].isin(["APARTMENT","STREET"]) &amp; (dat["theft"] == 0)]</span></pre><h1 id="0d72" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">应用功能</h1><p id="0444" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有时需要对某些列的所有行应用一个函数。假设我们想要通过将每个值除以它们的标准z分数来规范化“警察巡逻”和“盗窃”列。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1a18" class="kq jf hi km b fi kr ks l kt ku">app_dat = dat[["police beats","theft"]].apply(lambda x: (x-np.mean(x))/np.std(x), axis = 0)</span></pre><p id="fbb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于“轴= 1”的每一列，可以沿着行执行类似的操作</p><h1 id="a126" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">获取相关矩阵</strong></h1><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1c0c" class="kq jf hi km b fi kr ks l kt ku">num_cols = [i.lower() for i in num_cols]<br/>dat[num_cols].corr()</span></pre><h1 id="11c6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">更改列类型</h1><p id="dc9c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">你也可以改变熊猫的列类型。在本例中，列“逮捕”是布尔型的。比如说，我们想把它改成object。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e21c" class="kq jf hi km b fi kr ks l kt ku">dat['arrest'] = dat['arrest'].astype('object')</span></pre><h1 id="129d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">按列透视</h1><p id="133e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在几个操作中需要通过索引列上的列进行透视。下面的例子将枢纽列“逮捕”超过“索引”列，这必须是唯一的。新列中的值取自“抢劫”列。这些可以引入由-1填充的NaN。然后将透视数据帧添加回原始数据帧。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9f09" class="kq jf hi km b fi kr ks l kt ku">pivoted_dat = dat.pivot(index= "index", columns= "arrest", values="robbery").reset_index(drop = True)<br/>pivoted_dat.fillna(-1, inplace=True)<br/>dat = pd.concat([dat,pivoted_dat], axis=1)</span></pre><h1 id="e886" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">逆透视数据(融化)</h1><p id="81bd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">可能需要对列进行逆透视，以制作长格式的数据帧。这可以通过熔化来完成。在下面的示例中，列“索引”、“案例号”和“日期”将保持在原始数据框中。“描述”和“块”列中的值将作为行添加。这将导致数据框的行数比原始数据框多。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8fcf" class="kq jf hi km b fi kr ks l kt ku">melted_dat = dat.melt(id_vars=["index","case number","date"], value_vars= ["description","block"])</span></pre><h1 id="a268" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">连接</h1><p id="e26e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在许多情况下，可能需要连接两个数据帧。这里，我采用了两个不同于博客其他部分的数据框架。这些数据框创建为:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2da5" class="kq jf hi km b fi kr ks l kt ku">df1 = pd.DataFrame({'col1':[1,2,3,4,5], 'col2' : [12,43,10,20,2],'col3':['A','B','C','X','Y']})<br/>df2 = pd.DataFrame({'col1':[1,2,3,3,4], 'col4' : [12,43,10,20,2],'col5':['AA','BB','CC','XX','YY']})</span></pre><p id="3b58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子展示了如何在pandas中进行所有类型的连接。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b6cf" class="kq jf hi km b fi kr ks l kt ku"># Inner Join<br/>df1.join(df2.set_index(['col1','col4']), on = ['col1','col2'], how = "inner")</span><span id="74e6" class="kq jf hi km b fi kv ks l kt ku"># Left Join<br/>df1.join(df2.set_index(['col1','col4']), on = ['col1','col2'], how = "left")</span><span id="113e" class="kq jf hi km b fi kv ks l kt ku"># Right Join<br/>df1.join(df2.set_index(['col1','col4']), on = ['col1','col2'], how = "right")</span></pre><p id="638a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有在这个博客中讨论过策划。稍后我可能会谈到这一点。希望你喜欢这个博客。如果有，请鼓掌。</p></div></div>    
</body>
</html>