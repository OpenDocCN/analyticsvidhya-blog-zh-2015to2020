<html>
<head>
<title>Python — Function and Function Parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python函数和函数参数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-function-and-function-parameters-3d4d7f13b7fe?source=collection_archive---------19-----------------------#2020-04-27">https://medium.com/analytics-vidhya/python-function-and-function-parameters-3d4d7f13b7fe?source=collection_archive---------19-----------------------#2020-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/453b404c790dc27d2b7500397692f9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*So6SxfQaldS5J62fykwAcA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">知识是没有海岸的海洋</figcaption></figure><p id="b50a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">简而言之，当我们定义一个函数时，我们可能会也可能不会传递参数。但是大多数时间参数是在定义函数时传递的。语义上，我们将函数定义如下:</p><blockquote class="js jt ju"><p id="771e" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">def myfunction(a，b):<br/>#一些代码</p></blockquote><p id="8487" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以当我们调用这个函数时，</p><blockquote class="js jt ju"><p id="275a" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">x = 10 <br/> y = 20 <br/>我的函数(x，y)</p></blockquote><p id="636d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个上下文中，<strong class="iw hj"> <em class="jv"> x </em> </strong>和<strong class="iw hj"> <em class="jv"> y </em> </strong>是<strong class="iw hj"> <em class="jv"> myfunction </em> </strong>的参数，最重要的是要注意，<strong class="iw hj"> <em class="jv"> x </em> </strong>和<strong class="iw hj"> <em class="jv"> y </em> </strong>是通过引用传递的。即<strong class="iw hj"> <em class="jv"> x </em> </strong>和<strong class="iw hj"> <em class="jv"> y </em> </strong>的内存地址通过。<br/>我们可以将<em class="jv">位置</em>和<em class="jv">关键字</em>参数传递给函数。</p><h2 id="2536" class="jz ka hi bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated"><strong class="ak">位置和关键字参数</strong></h2><p id="d916" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">我们通常按照参数传递的顺序给函数的参数赋值，也就是参数的位置。</p><p id="7619" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们定义一个函数，它接受两个参数并返回两个字符串的连接。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e3e4" class="jz ka hi le b fi li lj l lk ll">def concatenate(a: str, b: str) -&gt; str:<br/>    return a + b</span></pre><p id="7434" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以当我们通过传递参数调用上述函数时，</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f119" class="jz ka hi le b fi li lj l lk ll">concatenate(<strong class="le hj">"hello"</strong>, <strong class="le hj">"world!!"</strong>)</span></pre><p id="006c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其中第一个参数" hello "赋给第一个参数即a和第二个参数"<strong class="iw hj"> world！！</strong>"分配给第二个参数，即b</p><p id="3346" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以通过为相应的参数指定一个“缺省”值来使位置变量成为可选的。让我们通过添加额外参数来修改我们的<em class="jv">连接</em>函数，</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c78e" class="jz ka hi le b fi li lj l lk ll">def concatenate(a: str, b: str, c: str = <strong class="le hj">"Welcome"</strong>) -&gt; str:<br/>    return a + b + c</span></pre><p id="d5cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们添加了第三个变量<em class="jv">“c”</em>，默认值为“<em class="jv">欢迎使用</em>”。因此，如果我们调用上述函数而不传递第三个参数，那么将引用第三个位置参数默认值。</p><p id="05a2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以如果我们调用上面的函数，</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="13da" class="jz ka hi le b fi li lj l lk ll">print(concatenate(<strong class="le hj">"hello"</strong>, <strong class="le hj">" world!! "</strong>))</span></pre><p id="677e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="f574" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><em class="hi">你好世界！！欢迎光临</em></p></blockquote><p id="f6bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，如果我们传递第三个参数，那么函数将不会考虑第三个参数的默认值(这是显而易见的😊).为了举例说明，让我们修改我们的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="44f9" class="jz ka hi le b fi li lj l lk ll">print(concatenate(<strong class="le hj">"Hello, "</strong>,<strong class="le hj">" this is my first story in "</strong>, <strong class="le hj">" Medium"</strong>))</span></pre><p id="26ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们运行上面的代码时，输出将是:</p><blockquote class="js jt ju"><p id="d15d" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><em class="hi">你好，这是我在Medium的第一个故事</em></p></blockquote><p id="bcc8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，一切都很好，也很容易理解。然而，可能会有这样的情况，函数中的任何一个参数都是可选的。更准确地说，假设我们有三个参数的加法函数，其中一个或者简化为第二个位置参数是可选的。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="afa5" class="jz ka hi le b fi li lj l lk ll">def addition(a: int, b: int = 150, c: int) -&gt; int:<br/>    return a + b + c</span></pre><p id="abf2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们只传递两个参数来调用这个函数，例如:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5d5a" class="jz ka hi le b fi li lj l lk ll">print(addition(150,150))</span></pre><p id="cf39" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么python将无法识别第二个参数即<em class="jv"> 150 </em>是指第二个参数即<em class="jv"> b </em>还是第三个参数即<em class="jv"> c </em>。所以它会在执行时抛出错误。</p><p id="2f03" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">错误可能是这样的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="51f0" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def addition(a: int, b: int = 150, c: int) -&gt; int:<br/>             ^</strong><br/>   <strong class="le hj"> SyntaxError: non - default argument follows default argument</strong></span></pre><p id="753f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，为了避免这种错误，我们需要在用默认值传递位置参数时遵循以下规则。</p><blockquote class="js jt ju"><p id="c5f1" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">如果我们用默认值定义了一个位置参数，那么对于其后的每个位置参数，我们也必须被赋予默认值。</strong></p></blockquote><p id="c235" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以我们需要修改我们的<em class="jv">加法</em>函数，将默认值赋给第三个参数，即<strong class="iw hj">T5】cT7】</strong></p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b945" class="jz ka hi le b fi li lj l lk ll">def addition(a: int, b: int = 150, c: int = 0) -&gt; int:<br/>    return a + b + c</span></pre><p id="0802" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在当我们运行下面的代码时:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="28b8" class="jz ka hi le b fi li lj l lk ll">print(addition(200, 300)) # a = 200, b = 300, c = 0</span></pre><p id="1b02" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="be51" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi">500</p></blockquote><p id="0088" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于加法函数，我们现在也可以传递一个参数。例如:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e6d9" class="jz ka hi le b fi li lj l lk ll">print(addition(1)) # a = 1, b = 150 (Default), c = 0(Default)</span></pre><p id="e6b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="7ff8" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi">151</p></blockquote><p id="187d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，如果你想跳过第二个参数，将第一个和第三个参数传递给加法函数。我们可以通过使用“<strong class="iw hj"> <em class="jv">关键字参数</em> </strong>”来实现，这也称为“<strong class="iw hj"> <em class="jv">命名参数</em> </strong>”。</p><p id="68f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用关键字或命名参数，我们可以通过传递第一个和第三个参数来调用函数，第二个参数保留默认值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f1af" class="jz ka hi le b fi li lj l lk ll">print(addition(a=1000, c=1500)) # So b = 150 (default value)</span></pre><p id="4e7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="6dd9" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi">2650</p></blockquote><p id="171d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">备注:</strong></p><blockquote class="js jt ju"><p id="b032" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">1.我们可以通过使用参数名来指定位置变量，不管它们是否赋值。</p></blockquote><p id="be82" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:让我们定义一个带有4个参数的函数，并返回传递给该函数的所有4个值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9fd8" class="jz ka hi le b fi li lj l lk ll">def returning_value(val1, val2, val3, val4):<br/>    return <strong class="le hj">"val1 = {0}, val2 ={1}, val3 ={2}, val4 ={3}"</strong>.format(val1, val2, val3, val4)</span></pre><p id="5360" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以调用函数，或者不使用关键字参数传递所有四个参数，或者使用关键字参数。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e51b" class="jz ka hi le b fi li lj l lk ll"><em class="jv"># Passing arguments without keywords argument<br/></em>print(returning_value(1, 2, 3, 4))</span></pre><p id="38bd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="19ae" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">值1 = 1，值2 =2，值3 =3，值4 =4</p></blockquote><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4054" class="jz ka hi le b fi li lj l lk ll"><em class="jv"># Passing arguments with keywords argument<br/></em>print(returning_value(val4=400, val1=120, val3=300, val2=140))</span></pre><p id="2e57" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="b9dd" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">val1 = 120，val2 =140，val3 =300，val4 =400</p></blockquote><p id="bba4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们使用关键字参数，那么传递参数的顺序并不重要，这就是使用关键字参数的优点。</p><p id="39b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，使用关键字参数时有一个警告。</p><blockquote class="js jt ju"><p id="02ea" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">2.如果您开始使用关键字参数，那么其后的所有参数都必须是关键字参数。</p></blockquote><p id="83e2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="55e7" class="jz ka hi le b fi li lj l lk ll"><em class="jv"># Passing few argument with keyword<br/></em>print(returning_value(val1=100, 200, val3=300, 400))</span></pre><p id="8000" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们运行上面的代码时，会显示下面的错误信息:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="cbfd" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">print(returning_value(val1=100, 200, val3=300, 400))<br/>                                   ^<br/>SyntaxError: positional argument follows keyword argument</strong></span></pre><h2 id="4a26" class="jz ka hi bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated"><strong class="ak">任意参数(*args) </strong></h2><p id="4f5e" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">当我们定义一个带参数的函数并访问带参数的函数时，最终我们是通过参数的相对位置来访问参数的。</p><p id="6a69" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，<em class="jv"> my_returnargs </em>函数接受3个位置参数并返回这些值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2bb7" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>my_returnargs(val1, val2, val3):<br/>    print(<strong class="le hj">"First Positional Value = "</strong>, val1)<br/>    print(<strong class="le hj">"Second Positional Value = "</strong>, val2)<br/>    print(<strong class="le hj">"Third Positional Value = "</strong>, val3)</span></pre><p id="b87f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们定义一个列表变量，它有三个值:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="d691" class="jz ka hi le b fi li lj l lk ll">list = [<strong class="le hj">'Hello'</strong>, <strong class="le hj">'World'</strong>, <strong class="le hj">'Learn Python'</strong>]</span></pre><p id="9684" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们将list作为一个参数传递给<em class="jv"> my_returnargs </em>函数，我们将解包list，这样所有的值都将作为一个参数传递:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7d7e" class="jz ka hi le b fi li lj l lk ll">my_returnargs(*list)</span></pre><p id="fbc4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是</p><blockquote class="js jt ju"><p id="8413" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">第一位置值= Hello <br/>第二位置值= World <br/>第三位置值= Learn Python</p></blockquote><p id="bbc3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的例子中，我们在函数中传递了3个参数，因为list有3个元素，所以在解包时，所有三个参数都被赋值。</p><p id="2d5b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，如果我们有一个超过3个元素的相同列表，并试图在函数参数中解包，会发生什么？</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b2fe" class="jz ka hi le b fi li lj l lk ll">list = [<strong class="le hj">'Hello'</strong>, <strong class="le hj">'World'</strong>, <strong class="le hj">'Learn Python'</strong>, <strong class="le hj">'Some Extra Arguments'</strong>]<br/><br/>my_returnargs(*list)</span></pre><p id="8130" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以当我们执行上面的代码时，python会抛出错误:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3ecf" class="jz ka hi le b fi li lj l lk ll">my_returnargs(*list)<br/><strong class="le hj">TypeError: my_returnargs() takes 3 positional arguments but 4 were given</strong></span></pre><p id="7d3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以通过在函数中传递任意参数(*args)来避免这种错误。我们可以修改这个函数，接受两个位置参数，并传递任意参数。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5f2b" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>my_returnargs(val1, val2, *args):<br/>    print(<strong class="le hj">"First Positional Value = "</strong>, val1)<br/>    print(<strong class="le hj">"Second Positional Value = "</strong>, val2)<br/>    print(<strong class="le hj">"Arbitrary Argument Values = "</strong>, args)</span></pre><p id="95ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们运行同样的代码，在这里我们已经用4个值解包了这个列表</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c5ff" class="jz ka hi le b fi li lj l lk ll">list = [<strong class="le hj">'Hello'</strong>, <strong class="le hj">'World'</strong>, <strong class="le hj">'Learn Python'</strong>, <strong class="le hj">'Some Extra Arguments'</strong>]<br/><br/>my_returnargs(*list)</span></pre><p id="da2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="65e8" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">第一个位置值= Hello <br/>第二个位置值= World <br/>任意参数值=('学习Python '，'一些额外的参数')</p></blockquote><p id="b06d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">注意</strong>:args参数返回值为<strong class="iw hj">元组</strong></p><blockquote class="js jt ju"><p id="efd8" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">也不能在*args后面添加任何位置参数。这意味着*args最终会用尽所有的位置参数。</p></blockquote><p id="c74e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以通过在*args后传递位置参数来定义函数。Python在定义这样的函数时绝不会抱怨:)</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="56c3" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>my_returnargs(val1, val2, *args, val3):<br/>    print(<strong class="le hj">"First Positional Value = "</strong>, val1)<br/>    print(<strong class="le hj">"Second Positional Value = "</strong>, val2)<br/>    print(<strong class="le hj">"Arbitrary Argument Values = "</strong>, args)<br/>    print(<strong class="le hj">"Another positional argument Value = "</strong>, val3)</span></pre><p id="b6fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们通过传递参数调用函数时会出现问题，python会抛出TypeError</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="980d" class="jz ka hi le b fi li lj l lk ll">list = [<strong class="le hj">'Hello'</strong>, <strong class="le hj">'World'</strong>, <strong class="le hj">'Learn Python'</strong>, <strong class="le hj">'Some Extra Arguments'</strong>]<br/><br/>my_returnargs(*list)</span></pre><p id="b519" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8162" class="jz ka hi le b fi li lj l lk ll">my_returnargs(*list)<br/>TypeError: my_returnargs() missing 1 required keyword-only argument: <strong class="le hj">'val3'</strong></span></pre><p id="b543" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，我们可以通过强制用户传递强制关键字参数来解决此类问题。</p><h2 id="bde9" class="jz ka hi bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">关键字参数*</h2><p id="2572" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">什么时候我们可以使用强制的关键字参数？所以答案是，一旦我们用尽了所有的位置论点。</p><p id="5d51" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了说明，让我们看下面的例子:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7fd1" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>my_returnargs(val1, val2, *args, val3):<br/>    print(<strong class="le hj">"First Positional Value = "</strong>, val1)<br/>    print(<strong class="le hj">"Second Positional Value = "</strong>, val2)<br/>    print(<strong class="le hj">"Arbitrary Argument Values = "</strong>, args)<br/>    print(<strong class="le hj">"Another positional argument Value = "</strong>, val3)<br/><br/><br/>list = [<strong class="le hj">'Hello'</strong>, <strong class="le hj">'World'</strong>, <strong class="le hj">'Learn Python'</strong>, <strong class="le hj">'Some Extra Arguments'</strong>]<br/><br/>my_returnargs(*list, val3 = <strong class="le hj">"This is a keyword argument"</strong>) <em class="jv"># Explicitly pass the keyword argument</em></span></pre><p id="8516" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们运行上面的代码时，输出将是:</p><blockquote class="js jt ju"><p id="d5a9" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">第一个位置值= Hello <br/>第二个位置值= World <br/>任意参数值=('学习Python '，'一些额外的参数')<br/>另一个位置参数值=这是一个关键字参数</p></blockquote><p id="8240" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以通过传递*作为参数来显式地限制函数不传递任何位置参数。例如:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a0b2" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>no_positionalarg(*, val: str) -&gt; str:<br/>    print(<strong class="le hj">"Only Keyword Argument :"</strong>, val)</span></pre><p id="fa79" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们试图将位置参数和关键字参数一起传递，那么python将通过TypeError</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e05c" class="jz ka hi le b fi li lj l lk ll">no_positionalarg(10,20,val = <strong class="le hj">"Hello World!!"</strong>)</span></pre><p id="c711" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2fb8" class="jz ka hi le b fi li lj l lk ll">no_positionalarg(10,20,val = <strong class="le hj">"Hello World!!"</strong>)<br/><strong class="le hj">TypeError: no_positionalarg() takes 0 positional arguments but 2 positional arguments (and 1 keyword-only argument) were given</strong></span></pre><p id="2253" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是如果我们只传递关键字参数，那么Python不会显示任何错误</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="16d8" class="jz ka hi le b fi li lj l lk ll">no_positionalarg(val = <strong class="le hj">"Hello World!!"</strong>)</span></pre><p id="0579" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="2cce" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">唯一关键字参数:Hello World！！</p></blockquote><p id="d155" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们结合位置参数，可选的位置参数，*args，无位置参数和强制关键字参数。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1ae6" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>combine_func(val1, val2=50, *args, val3, val4=<strong class="le hj">"Hello World!!!"</strong>):<br/>    print(<strong class="le hj">"val1 = "</strong>, val1)<br/>    print(<strong class="le hj">"val2 = "</strong>, val2)<br/>    print(<strong class="le hj">"args = "</strong>, args)<br/>    print(<strong class="le hj">"val3 = "</strong>, val3)<br/>    print(<strong class="le hj">"val4 = "</strong>, val4)</span></pre><p id="23ae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的函数中，我们有:</p><blockquote class="js jt ju"><p id="71bf" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">强制位置参数，即<em class="hi"> val1 </em></p><p id="ad87" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">可选位置参数，即<em class="hi"> val2 </em></p><p id="ef16" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">可选任意数量的位置参数，即*args</p><p id="6bd9" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">强制关键字参数，即<em class="hi"> val3 </em></p><p id="3574" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">最后可选位置参数，即<em class="hi"> val4 </em></p></blockquote><p id="d619" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以当我们调用这个函数时:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7522" class="jz ka hi le b fi li lj l lk ll">list = [101, <strong class="le hj">'Python'</strong>, <strong class="le hj">'Hello'</strong>, <strong class="le hj">'Welcome'</strong>, 20, 30]<br/>combine_func(*list, val3=<strong class="le hj">"This is a mandatory keyword arguments after args"</strong>)</span></pre><p id="6778" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="4ffc" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">val 1 = 101<br/>val 2 = Python<br/>args =(' Hello '，' Welcome '，20，30) <br/> val3 =这是args <br/> val4 = Hello World之后的强制关键字参数！！！</p></blockquote><p id="7736" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们在函数中不限制位置参数，然后是强制关键字参数和可选位置参数，会怎么样？</p><p id="8583" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们修改如下相同的函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="98fc" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>combine_func(val1, val2=50, *, val3, val4=<strong class="le hj">"Hello World!!!"</strong>):<br/>    print(<strong class="le hj">"val1 = "</strong>, val1)<br/>    print(<strong class="le hj">"val2 = "</strong>, val2)<br/>    print(<strong class="le hj">"val3 = "</strong>, val3)<br/>    print(<strong class="le hj">"val4 = "</strong>, val4)</span></pre><p id="b6a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的函数中，我们有:</p><blockquote class="js jt ju"><p id="5696" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">强制位置参数，即<em class="hi"> val1 </em></p><p id="824a" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">可选位置参数，即<em class="hi"> val2 </em></p><p id="a656" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">没有位置参数，即<em class="hi"> * </em></p><p id="d7aa" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">强制关键字参数，即<em class="hi"> val3 </em></p><p id="d113" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">最后可选位置参数，即<em class="hi"> val4 </em></p></blockquote><p id="d21e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以当我们通过传递三个位置参数后跟关键字参数来调用函数时</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="53ba" class="jz ka hi le b fi li lj l lk ll">combine_func(<strong class="le hj">'test'</strong>,25,1000,c=100.1005)</span></pre><p id="4d6e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后我们会遇到下面的错误:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="00a9" class="jz ka hi le b fi li lj l lk ll">combine_func(<strong class="le hj">'test'</strong>,25,1000,val3=100.1005)<br/><strong class="le hj">TypeError: combine_func() takes from 1 to 2 positional arguments but 3 positional arguments (and 1 keyword-only argument) were given</strong></span></pre><p id="1d3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">原因是前两个参数指的是位置参数，即<strong class="iw hj"> <em class="jv"> val1 </em> </strong>和<strong class="iw hj"> <em class="jv"> val2 </em> </strong>(虽然<strong class="iw hj"> <em class="jv"> val2 </em> </strong>是可选的位置参数，其默认值为<em class="jv"> 50 </em>，但这里我们传递的是<em class="jv"> 25 </em>)。) .然而，当我们在关键字参数之前传递第三个参数，即<em class="jv"> 1000 </em>，即<strong class="iw hj"> <em class="jv"> val3 </em> </strong>时，Python无法处理，因为函数被定义为在两个位置参数之后，不应传递任何位置参数，而是传递强制关键字参数，即<strong class="iw hj"> <em class="jv"> val3 </em> </strong>，后跟另一个可选位置参数。</p><p id="d13a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们在调用函数时修改参数，如下所示:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5884" class="jz ka hi le b fi li lj l lk ll">combine_func(<strong class="le hj">'test'</strong>,25,val3=100.1005, val4 = <strong class="le hj">"Welcome to pythonic way of writing python"</strong>)</span></pre><p id="af78" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出将是:</p><blockquote class="js jt ju"><p id="dd93" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">val 1 = test<br/>val 2 = 25<br/>val 3 = 100.1005<br/>val 4 =欢迎来到python的编写方式python</p></blockquote><p id="ebb0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">非常有趣但非常重要(更确切地说，这是一个警告)，如果你调用一个带有命名参数或关键字参数的函数，尽管你声明它们是位置参数后跟*args，那么Python将抛出语法错误，声明位置参数跟在关键字参数后面。</strong></p><p id="1b9f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了说明这一点，让我们运行下面的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="df25" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>namedargument_with_args(val1, val2, val3=10, *args):<br/>    print(val1, val2, val3, *args)<br/><br/><br/>namedargument_with_args(val1=1, val2=2, 30, 50, 60, 80)</span></pre><p id="fd16" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以当我们运行上面的代码时，会显示下面的错误:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="941b" class="jz ka hi le b fi li lj l lk ll">namedargument_with_args(val1=1, val2=2, 30, 50, 60, 80)<br/>                                           ^<br/><strong class="le hj">SyntaxError: positional argument follows keyword argument</strong></span></pre><p id="d46d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们调用函数并试图在*args的末尾传递option参数会怎样？当然Python会抛出错误，因为它发现了位置参数<em class="jv"> val3 </em>的多个值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5134" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>namedargument_with_args(val1, val2, val3=10, *args):<br/>    print(val1, val2, val3, *args)<br/><br/><br/>namedargument_with_args(1,2, 30, 50,60,80, val3= 20)</span><span id="3ae4" class="jz ka hi le b fi lm lj l lk ll"><strong class="le hj">&gt;&gt;&gt; Output:</strong><br/>namedargument_with_args(1,2, 30, 50,60,80, val3= 20)<br/><strong class="le hj">TypeError: namedargument_with_args() got multiple values for argument 'val3'</strong></span></pre><h2 id="045d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">任意数量的关键字参数(**kwargs)</h2><p id="c187" class="pw-post-body-paragraph iu iv hi iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr hb bi translated">在python中，我们可以使用**kwargs向函数添加任意数量的关键字参数。</p><p id="768d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">即使位置参数没有用尽，用户也可以指定**kwargs(这对于*args是不成立的)。但是，**kwargs后面不应该有任何位置参数。</p><p id="5e85" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是有一个警告。如果我们声明一个第一个参数是*的函数，也就是说，后面没有位置参数，那么Python不会处理，而是抛出一个语法错误:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="d9f2" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>kwargs_function(*,**kwargs):<br/>    print (kwargs)</span><span id="083b" class="jz ka hi le b fi lm lj l lk ll"><strong class="le hj">&gt;&gt;&gt; Output:</strong><br/>    def my_func(*,**kwargs):<br/>                 ^<br/><strong class="le hj">SyntaxError: named arguments must follow bare *</strong></span></pre><p id="901f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，如果我们在**kwargs后传递强制关键字或可选位置参数，上面的函数将会工作。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9f3b" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>kwargs_function(*,val,**kwargs):<br/>    print (<strong class="le hj">"The keyword argument value = "</strong>, val)<br/>    print (<strong class="le hj">"Arbitrary Keyword Arguments are: "</strong>, kwargs)<br/><br/>kwargs_function(val= <strong class="le hj">"Hello World!"</strong>, val1 = 1, val2 = 2, val3 = 3, val4 = 4, val5 = 5, val6 = <strong class="le hj">"Welcome to Medium!!!!"</strong>)</span><span id="3974" class="jz ka hi le b fi lm lj l lk ll"><strong class="le hj">&gt;&gt;&gt;</strong> <strong class="le hj">Output</strong>:<br/>The keyword argument value =  <strong class="le hj">Hello World!</strong><br/>Arbitrary Keyword Arguments are:  <strong class="le hj">{'val1': 1, 'val2': 2, 'val3': 3, 'val4': 4, 'val5': 5, 'val6': 'Welcome to Medium!!!!'}</strong></span></pre><p id="23f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">注意</strong>:kwargs参数返回值为<strong class="iw hj">字典</strong></p><p id="306e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以在一个函数中同时使用*args和**kwargs。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2c09" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>args_kwargs_func(*args,**kwargs):<br/>    print(<strong class="le hj">"Arbitrary arguments values :"</strong>, args)<br/>    print (<strong class="le hj">"Arbitrary Keyword Arguments are: "</strong>, kwargs)<br/><br/>args_kwargs_func(10, 20, 30 , 40 ,50 ,a = 1, b = 2, c = 3, d = 4, e = 5, f = <strong class="le hj">"Hello World!!" </strong>)</span><span id="99c5" class="jz ka hi le b fi lm lj l lk ll"><strong class="le hj">&gt;&gt;&gt; Output<br/></strong>Arbitrary arguments values : (10, 20, 30, 40, 50)<br/>Arbitrary Keyword Arguments are:  {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 'Hello World!!'}</span></pre><p id="3485" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以用位置参数、任意数量的位置参数(即*args)、强制的仅关键字参数和任意关键字参数来声明函数。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0d3f" class="jz ka hi le b fi li lj l lk ll"><strong class="le hj">def </strong>my_func(arg_1, arg_2, *args, kwarg_1, **kwargs):<br/>    print(arg_1)<br/>    print(arg_2)<br/>    print(args)<br/>    print(kwarg_1)<br/>    print(kwargs)<br/><br/><br/>s1 = <strong class="le hj">"Welcome"<br/></strong>s2 = <strong class="le hj">"Python"<br/></strong>tuple_1 = (1, 2, 3, 4, 5, 6, <strong class="le hj">"Hello World!!!"</strong>)<br/>my_func(s1, s2, *tuple_1, kwarg_1=<strong class="le hj">"Mandatory Keyword Argument"</strong>, a=10, b=20, c=<strong class="le hj">"Hello"</strong>, d=<strong class="le hj">"World!"</strong>)</span><span id="45f6" class="jz ka hi le b fi lm lj l lk ll"><strong class="le hj">&gt;&gt;&gt; Output<br/></strong>Welcome<br/>Python<br/>(1, 2, 3, 4, 5, 6, 'Hello World!!!')<br/>Mandatory Keyword Argument<br/>{'a': 10, 'b': 20, 'c': 'Hello', 'd': 'World!'}</span></pre><p id="d15a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在定义函数时，我们可以传递位置参数、关键字参数以及任意参数&amp;任意关键字参数。然而，我们需要注意传递这些参数的方式，即在定义任何函数时要记住某些规则。</p><p id="2849" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也请发表您的疑问/想法和建议:)</p><p id="74e5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">快乐学习！！！</p></div></div>    
</body>
</html>