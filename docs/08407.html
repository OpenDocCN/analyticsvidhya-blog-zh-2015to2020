<html>
<head>
<title>Deep dive into JavaScript Map Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究 JavaScript 地图对象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-dive-into-javascript-map-object-24c012e0b3fe?source=collection_archive---------15-----------------------#2020-07-28">https://medium.com/analytics-vidhya/deep-dive-into-javascript-map-object-24c012e0b3fe?source=collection_archive---------15-----------------------#2020-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/598fb60d709194d5df99f20079664765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAWyLo7TJR7-_RdDxEF-rg.jpeg"/></div></div></figure><p id="82ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript 从诞生到现在已经走过了漫长的道路。多年来，JavaScript 逐渐向语言中引入了新的特性，使其更加健壮。</p><p id="8316" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ES6 的引入为 JavaScript 带来了大量新特性，这极大地简化了开发人员的工作。其中一个特性是<strong class="is hj">映射</strong>数据结构。</p><p id="74ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您需要一组严格的键/值对，但是需要比常规 JavaScript 对象提供的更多的功能时，JavaScript map 数据结构是一个强大的工具。</p><h1 id="bcdd" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是地图？</h1><p id="c09d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如前一段所述，在计算机科学术语中，映射是保存键/值对的数据结构。映射允许在数据结构中快速查找关键字，在 0(1)个访问时间内轻松访问一个值。地图在 Java 和 C#等其他语言中已经存在了很长时间。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="96cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从地图的一些基本操作开始:</p><h2 id="3c76" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">创建地图</h2><p id="545b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">通过调用它的构造函数并用<strong class="is hj"> new </strong>关键字实例化它来创建一个地图。有两种方法可以做到这一点。</p><ol class=""><li id="90f8" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">您可以用无参数构造函数实例化一个映射。</li></ol><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="88c4" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map()</span></pre><p id="c40b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建一个没有默认值且大小为 0 的新地图。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="c8c2" class="ky jp hi ma b fi me mf l mg mh">console.log(myMap.size);<br/>//0</span></pre><p id="2b3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.实例化 map 的另一个选项是将值传递给构造函数</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="327b" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map([[1, 'one'],[2, 'two'],[3, 'three'],]);</span></pre><p id="e1c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建一个默认大小为 3 的映射，并将传递的参数作为键/值对。</p><h2 id="8489" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">向地图添加新元素</h2><p id="35db" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">您可以通过调用<strong class="is hj"> set </strong>方法向地图添加新元素，该方法需要两个<br/>参数——一个键和值。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="ee81" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map()<br/>myMap.set('Ford', 'American');<br/>myMap.set('Kantanka', 'Ghana');<br/>myMap.set('Toyota', 'Japan');<br/>myMap.set('Volkswagen', 'German');</span></pre><h2 id="31ce" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">从地图中检索元素</h2><p id="10d2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">从 map 中检索元素非常简单，只需调用 map 的<strong class="is hj"> get </strong>方法，并使用<strong class="is hj">键</strong>作为参数。继续上面的“设置”示例:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="fe08" class="ky jp hi ma b fi me mf l mg mh">console.log(myMap.get('Kantanka')); //Ghana<br/>console.log(myMap.get('Toyota')); //Japan<br/>console.log(myMap.get('Ford')); //American<br/>console.log(myMap.get('Volkswagen')); //American</span></pre><p id="d560" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您试图访问一个不存在于映射中的键，将返回一个未定义的<strong class="is hj"/></p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3b2e" class="ky jp hi ma b fi me mf l mg mh">console.log(myMap.get('unknown')); //undefined</span></pre><p id="9629" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">小心</strong>:如果你将一个<strong class="is hj">对象</strong>类型的值赋给一个键，它将是一个引用类型，这意味着对该对象的任何更改都将反映在映射中。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="68ff" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map();</span><span id="cd0b" class="ky jp hi ma b fi mi mf l mg mh">const car = {<br/> name: 'Impala'<br/> Year: '2020'<br/>}</span><span id="d7b6" class="ky jp hi ma b fi mi mf l mg mh">myMap.set('myNewCar', car);<br/>console.log(myMap.get('myNewCar')); // {name: "Impala", year:"2020"}</span><span id="c07e" class="ky jp hi ma b fi mi mf l mg mh">car.name = 'Malibu';<br/>car.year = '2015';</span><span id="6670" class="ky jp hi ma b fi mi mf l mg mh">console.log(myMap.get('myNewCar')); // {name: "Malibu", year:"2015"}</span></pre></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="1751" class="jo jp hi bd jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh mn kj kk kl bi translated">地图与常规对象</h1><p id="18a6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">前面我提到过，Map 是一种键/值对数据结构。JavaScript 中的常规对象也是如此，但应该指出两者之间的一些差异:</p><ul class=""><li id="47b4" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mo ls lt lu bi translated">JavaScript(JS)对象是属性的集合，<strong class="is hj"> JS 对象只接受两种类型的属性类型 string 和 Symbols </strong>，如果你试图将任何其他类型作为键传递给 JS 对象，它会将它们转换成 String。</li></ul><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="eb25" class="ky jp hi ma b fi me mf l mg mh">//Regular JS Object<br/>const car = {<br/>  name: 'Impala',<br/>  year: '2020',<br/>  true: 1<br/>}</span><span id="6b49" class="ky jp hi ma b fi mi mf l mg mh">console.log(Object.keys(car)); //["name", "year", "true"]</span></pre><p id="8d7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而 Map 将接受任何类型的键，不会将其转换为字符串。地图甚至可以接受一个函数作为它的键。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="f18b" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map()<br/>myMap.set('Ford', 'American');<br/>myMap.set('Kantanka', 'Ghana');</span><span id="6568" class="ky jp hi ma b fi mi mf l mg mh">function randomKey() {<br/>  return 'key1'<br/>}</span><span id="8fd8" class="ky jp hi ma b fi mi mf l mg mh">myMap.set(randomKey(), 'generated random key');<br/>console.log(myMap.get('key1')); //generated random key</span></pre><ul class=""><li id="4434" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mo ls lt lu bi translated">映射是可迭代的，这意味着您可以使用循环，如<em class="mp"> forEach </em>或<em class="mp"> for…of </em>来迭代它的值。</li></ul><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6922" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map()<br/>myMap.set('Ford', 'American');<br/>myMap.set('Kantanka', 'Ghana);<br/>myMap.set('Toyota', 'Japan');<br/>myMap.set('Volkswagen', 'German');</span><span id="2d31" class="ky jp hi ma b fi mi mf l mg mh">//Using forEach loop<br/>myMap.forEach((value, key) =&gt; {<br/>  console.log(key, value);<br/>})<br/>//Ford American<br/>//Kantanka Ghana<br/>//Toyota Japan<br/>//Volkswagen German</span><span id="8146" class="ky jp hi ma b fi mi mf l mg mh"><br/>-----------------------------------------------------------------</span><span id="fccd" class="ky jp hi ma b fi mi mf l mg mh">//Using for...of to iterate over values</span><span id="251b" class="ky jp hi ma b fi mi mf l mg mh">for (let value of myMap.values()) {<br/>  console.log(value);<br/>}<br/>//American<br/>//Ghana<br/>//Japan<br/>//German</span></pre><p id="99fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于 JavaScript 对象，默认情况下它们是不可迭代的。试图使用上述循环(forEach，for…of)迭代 JS 对象将会抛出一个<strong class="is hj"> TypeError </strong>异常</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="d272" class="ky jp hi ma b fi me mf l mg mh">const car = {<br/>  name: 'Impala',<br/>  year: 2020<br/>}</span><span id="80b1" class="ky jp hi ma b fi mi mf l mg mh">for (let value of car) {<br/>  console.log(value);<br/>}<br/>//Uncaught TypeError: car is not iterable</span></pre><p id="2724" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迭代对象的唯一方法是在循环中使用<em class="mp">for…或<em class="mp"> Object.keys </em>通过它的键</em></p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="8c48" class="ky jp hi ma b fi me mf l mg mh">const car = {<br/>  name: 'Impala',<br/>  year: 2020<br/>}</span><span id="0e0a" class="ky jp hi ma b fi mi mf l mg mh">//Using for...in loop<br/>for (let key in car) {<br/>  console.log(key);<br/>}</span><span id="59a2" class="ky jp hi ma b fi mi mf l mg mh">//name<br/>//year<br/>----------------------------------------------------------------</span><span id="7cfc" class="ky jp hi ma b fi mi mf l mg mh">//Using Object.keys()<br/>console.log(Object.keys(car));<br/>//["name", "year"]</span></pre><ul class=""><li id="f042" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mo ls lt lu bi translated">map 跟踪它的集合大小，您可以使用<strong class="is hj"> size </strong>方法来检索 map 的当前大小，其访问时间为<strong class="is hj"> O(1) </strong>。</li></ul><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="ea51" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map()<br/>myMap.set('Ford', 'American');<br/>myMap.set('Kantanka', 'Ghana');</span><span id="d555" class="ky jp hi ma b fi mi mf l mg mh">console.log(myMap.size); //2</span></pre><p id="cb6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JS 对象不跟踪它的大小，获得对象大小的唯一方法是迭代它的键，这是访问时间的一部分。</p><ul class=""><li id="3606" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mo ls lt lu bi translated">插入到地图中的键保持它们的顺序。当你迭代一个地图时，它将按照插入的顺序返回键。</li></ul><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3852" class="ky jp hi ma b fi me mf l mg mh">let myMap = new Map()<br/>myMap.set('Ford', 'American');<br/>myMap.set('Kantanka', 'Ghana);<br/>myMap.set('Toyota', 'Japan');<br/>myMap.set('Volkswagen', 'German');</span><span id="f559" class="ky jp hi ma b fi mi mf l mg mh">myMap.forEach((value, key) =&gt; {<br/>  console.log(key);<br/>})<br/>//Ford<br/>//Kantanka<br/>//Toyota<br/>//Volkswagen</span></pre><p id="594a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">直到引入 ES6，常规 JS 对象才保持键的顺序。但是即使在 ES6 中，JS 对象也只能以正确的顺序保存字符串和符号的键，任何其他被转换成字符串的类型都不能以正确的顺序保存</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="dfd0" class="ky jp hi ma b fi me mf l mg mh">const car = {<br/>  name: 'Impala',<br/>  year: '2020',<br/>  true: 'boolean',<br/>  7: 'just random number'<br/>}<br/>console.log(Object.keys(car)); //["7", "name", "year", "true"]</span></pre><p id="c5d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上几点显示了地图与常规对象的不同，以及它相对于普通的旧 JavaScript 对象的优势。</p><h1 id="4827" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">其他有用的映射方法</h1><ul class=""><li id="224b" class="lm ln hi is b it km ix kn jb mq jf mr jj ms jn mo ls lt lu bi translated"><strong class="is hj"> clear() </strong>:从 map 实例中删除所有键/值对。</li><li id="12ef" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated"><strong class="is hj"> delete(key): </strong>如果传递的参数存在于 map 实例中并已被移除，将返回布尔值 true，否则返回 false。</li><li id="c027" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated"><strong class="is hj"> entries(): </strong>返回一个新的迭代器对象，该对象包含 map 实例中每个元素的，并且按其插入顺序排列。</li><li id="49a9" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated"><strong class="is hj"> iterator(): </strong>返回一个新的 iterator 对象，它包含 Map 对象中每个元素的键/值对的数组，按照元素的插入顺序排列。</li></ul><h1 id="3ffc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">何时使用地图</h1><ul class=""><li id="bb90" class="lm ln hi is b it km ix kn jb mq jf mr jj ms jn mo ls lt lu bi translated">当需要除字符串和符号之外的不同数据类型的键值时，应该考虑映射。</li><li id="1329" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated">当您要求键/值对是可迭代的时，应该考虑映射。</li><li id="39fa" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated">映射有更多有用的插入和删除功能，这使得在必须插入和删除的情况下更容易使用对象。</li></ul></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="0d46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是否一直在使用地图对象，或者对它不熟悉？请在下面留下您对地图对象的想法和使用案例的评论。</p><p id="0ee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，一定要点击鼓掌按钮，看看我下面的其他文章！</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><ul class=""><li id="ba79" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn mo ls lt lu bi translated"><a class="ae my" rel="noopener" href="/@ericsarpong/what-is-a-typescript-tuple-814a016f61fd"> <strong class="is hj">什么是打字稿元组</strong> </a></li><li id="ca5e" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated"><a class="ae my" href="https://ericsarpong.medium.com/asynchronous-programming-in-a-nutshell-theory-d5fd07cf3b22" rel="noopener"> <strong class="is hj">概括地说异步编程(理论)</strong> </a></li><li id="05b5" class="lm ln hi is b it mt ix mu jb mv jf mw jj mx jn mo ls lt lu bi translated"><a class="ae my" href="https://medium.com/p/7d254b495c54/edit" rel="noopener"> <strong class="is hj">角度路由:命令式 vs PopState </strong> </a></li></ul></div></div>    
</body>
</html>