<html>
<head>
<title>Trie Data structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/trie-data-structure-a1c96cee016f?source=collection_archive---------7-----------------------#2019-12-08">https://medium.com/analytics-vidhya/trie-data-structure-a1c96cee016f?source=collection_archive---------7-----------------------#2019-12-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="86b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Trie是一种信息检索数据结构，使用它我们可以优化搜索的复杂性。</p><p id="988d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Trie，我们可以在O(1)时间内搜索密钥。但是惩罚是存储要求</p><p id="362d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Trie，我们可以进行基于前缀的搜索，我们可以按字典顺序排序。</p><p id="3353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用哈希表，我们也可以按字典顺序排序，但我们没有基于前缀的搜索，而且常规哈希表比trie占用更多的空间。</p><p id="5df1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用例</strong></p><ol class=""><li id="19dc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">当你有成千上万的数据，然后使用trie你可以存储它，然后很容易搜索任何记录。</li><li id="b1a1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">自动完成:-正如我所说，使用trie，我们可以进行基于前缀的搜索，因此许多文本编辑器和移动应用程序使用trie数据结构来实现自动完成。</li><li id="6599" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">拼写检查:-拼写检查是一个三步的过程，首先加载字典，然后生成一个潜在的建议，排序的建议与预期的单词在顶部。Trie可以用来存储字典。</li><li id="9315" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">浏览器历史:-在trie上存储浏览器历史，然后用户只需给出前缀，然后我们可以加载所有的建议。</li><li id="d2ca" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">搜索引擎:-与浏览器历史相同，我们可以只通过前缀搜索配置文件。</li><li id="aae7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创建通过多个位置连接的路径。</li></ol><p id="13bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Java中的Trie结构</strong></p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="b444" class="ka kb hi jw b fi kc kd l ke kf">private class TrieNode{</span><span id="f0ef" class="ka kb hi jw b fi kg kd l ke kf">         Map&lt;Character, TrieNode&gt; children;</span><span id="bbd2" class="ka kb hi jw b fi kg kd l ke kf">         boolean isEndOfWord;</span><span id="ae2d" class="ka kb hi jw b fi kg kd l ke kf">         public TrieNode() {</span><span id="7fd5" class="ka kb hi jw b fi kg kd l ke kf">            children= new HashMap&lt;&gt;();</span><span id="d291" class="ka kb hi jw b fi kg kd l ke kf">            size =0;</span><span id="853b" class="ka kb hi jw b fi kg kd l ke kf">            isEndOfWord= false;</span><span id="9b84" class="ka kb hi jw b fi kg kd l ke kf">         }</span><span id="9b86" class="ka kb hi jw b fi kg kd l ke kf">}</span></pre><p id="09bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个节点都有两个主要组成部分，一个是Map，它有key和trie节点来建立父子关系。第二，一个名为isEndOfWord的布尔值，用于检查字符是否是单词的结尾。</p><p id="bb2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对Trie进行插入操作</strong></p><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kh"><img src="../Images/39120a1ef511d0a40da1e75e45e7a8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-i6vckKvFy0OvIqT3y1dQ.png"/></div></div></figure><p id="e95f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，我们的trie是root。根有一个空映射，布尔isEndofword为false。然后我们取第一个单词，一个接一个地插入字符。</p><p id="e99e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个词是“<strong class="ih hj"> Shivam </strong>”</p><p id="5357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们检查“S”在trie中是否存在。不，不是。然后我们创建一个新的节点，并在根节点中放入" S "作为新节点的键和值。</p><p id="1076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们检查“h”是否出现在“S”的节点中。不，不是。然后我们再创建一个新节点，把“h”作为键放在“S”节点中，把值作为新节点。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="a362" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们这样做，直到单词“m”的末尾，创建一个新的节点，并把它放在“a”节点作为键，新节点作为值，我们使isEndOfword布尔值为真，因为它是单词的最后一个字符。</p><p id="94b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个词是“<strong class="ih hj"> Shoni </strong>”</p><p id="9891" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们检查“S”是否存在。是的，它存在，然后我们继续前进</p><p id="8062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“h”存在与否。是的，它存在，然后我们忽略并继续前进。</p><p id="88bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“o”存在与否。不，不是。然后我们创建一个新节点，把“o”作为“h”节点的键，把“o”的值作为新节点。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="a8c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我们对其他人做的一样，直到我们到达单词的末尾，我们得到了“我”。因此，我们为“I”创建一个新节点，并将其作为“n”节点的键，并使isEndOfword为True。</p><p id="f62c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用于插入的代码片段</strong></p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="554d" class="ka kb hi jw b fi kc kd l ke kf">public void insert(String word) {</span><span id="bce8" class="ka kb hi jw b fi kg kd l ke kf">           TrieNode current = root;</span><span id="a31d" class="ka kb hi jw b fi kg kd l ke kf">           for(int i=0;i&lt;word.length();i++) {</span><span id="49ae" class="ka kb hi jw b fi kg kd l ke kf">                   char ch = word.charAt(i);</span><span id="b4fe" class="ka kb hi jw b fi kg kd l ke kf">                   TrieNode node = current.children.get(ch);</span><span id="f804" class="ka kb hi jw b fi kg kd l ke kf">                   if(node == null) {</span><span id="b27f" class="ka kb hi jw b fi kg kd l ke kf">                       node = new TrieNode();</span><span id="31be" class="ka kb hi jw b fi kg kd l ke kf">                      current.children.put(ch, node);</span><span id="b6e6" class="ka kb hi jw b fi kg kd l ke kf">                    }</span><span id="2b15" class="ka kb hi jw b fi kg kd l ke kf">                    current= node;</span><span id="2fd9" class="ka kb hi jw b fi kg kd l ke kf">             }</span><span id="6b88" class="ka kb hi jw b fi kg kd l ke kf">             current.endOfWord= true;</span><span id="6e4a" class="ka kb hi jw b fi kg kd l ke kf">}</span></pre><p id="1208" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Trie中的搜索操作</strong></p><p id="93aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以执行两种类型的搜索</p><ol class=""><li id="4e98" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">基于前缀的</strong>(任何字符串都以前缀开头)</li><li id="9902" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">全词搜索</strong>(全词存在与否)</li></ol><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kw"><img src="../Images/1aef00b2b4d6018c25ff8e46e9e37d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGC2Z5Ji7snhDgYbxOXxEA.png"/></div></div></figure><p id="ef8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考前缀搜索中的图表，第一个单词是“Sh”。</p><p id="6c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们从root开始检查root是否包含“S”。它确实包含，然后在根的映射中，我们检查“h”是否存在，或者它是否有“h”。所以我们至少有一个单词和“Sh”匹配。</p><p id="2e4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们返回true。</p><p id="028d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们有“所以。同样，我们从根“S”开始，但是在“S”图中没有“O”。我们返回false。</p><p id="a9a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搜索单词“Shivam”。我们再次从根开始，检查“S”的存在，而不是以同样的方式遍历到“m”。然后我们检查m isEndOfWord是否为真。这对于检查isEndOfWord的真假很重要。这里我们得到了真实。所以“Shivam”这个词确实存在。</p><p id="65c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用于搜索的代码片段</strong></p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="8b82" class="ka kb hi jw b fi kc kd l ke kf">/**</span><span id="9277" class="ka kb hi jw b fi kg kd l ke kf">* Iterative implemention for both kind of search</span><span id="89c4" class="ka kb hi jw b fi kg kd l ke kf">*/</span><span id="f754" class="ka kb hi jw b fi kg kd l ke kf">public boolean search(String word) {</span><span id="55cd" class="ka kb hi jw b fi kg kd l ke kf">           TrieNode current = root;</span><span id="8c58" class="ka kb hi jw b fi kg kd l ke kf">           for (int i = 0; i &lt; word.length(); i++) {</span><span id="166b" class="ka kb hi jw b fi kg kd l ke kf">                   char ch = word.charAt(i);</span><span id="5972" class="ka kb hi jw b fi kg kd l ke kf">                   TrieNode node = current.children.get(ch);</span><span id="668a" class="ka kb hi jw b fi kg kd l ke kf">                   if (node == null) {</span><span id="2c6e" class="ka kb hi jw b fi kg kd l ke kf">                         return false;</span><span id="6064" class="ka kb hi jw b fi kg kd l ke kf">                   }</span><span id="3b03" class="ka kb hi jw b fi kg kd l ke kf">                   current = node;</span><span id="6878" class="ka kb hi jw b fi kg kd l ke kf">            }</span><span id="dd09" class="ka kb hi jw b fi kg kd l ke kf">            return current.endOfWord;</span><span id="cd20" class="ka kb hi jw b fi kg kd l ke kf">}</span></pre><p id="e01a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">破解黑客排名问题的尝试</strong></p><p id="4574" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参考该问题的链接</p><div class="kx ky ez fb kz la"><a href="https://www.hackerrank.com/challenges/ctci-contacts/problem" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">尝试:联系人|黑客排名</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">用两个基本操作创建一个联系人应用程序:添加和查找。</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">www.hackerrank.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo kn la"/></div></div></a></div><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="9a8e" class="ka kb hi jw b fi kc kd l ke kf">public class Contacts {</span><span id="477e" class="ka kb hi jw b fi kg kd l ke kf">private class TrieNode{</span><span id="0197" class="ka kb hi jw b fi kg kd l ke kf">          Map&lt;Character, TrieNode&gt; children;</span><span id="bff8" class="ka kb hi jw b fi kg kd l ke kf">          int size;</span><span id="a0c1" class="ka kb hi jw b fi kg kd l ke kf">          public TrieNode() {</span><span id="8c5b" class="ka kb hi jw b fi kg kd l ke kf">               children= new HashMap&lt;&gt;();</span><span id="90ce" class="ka kb hi jw b fi kg kd l ke kf">               size =0;</span><span id="a093" class="ka kb hi jw b fi kg kd l ke kf">          }</span><span id="6bac" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="8c0d" class="ka kb hi jw b fi kg kd l ke kf">private TrieNode root; <br/></span><span id="39f2" class="ka kb hi jw b fi kg kd l ke kf">public Contacts() {</span><span id="350e" class="ka kb hi jw b fi kg kd l ke kf">         root = new TrieNode();</span><span id="b354" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="a0d4" class="ka kb hi jw b fi kg kd l ke kf">public void insert(String word) {<br/></span><span id="5952" class="ka kb hi jw b fi kg kd l ke kf">            TrieNode current = root;</span><span id="c61e" class="ka kb hi jw b fi kg kd l ke kf">            for(int i=0;i&lt;word.length();i++) {</span><span id="7d67" class="ka kb hi jw b fi kg kd l ke kf">                char ch = word.charAt(i);</span><span id="670c" class="ka kb hi jw b fi kg kd l ke kf">                TrieNode node = current.children.get(ch);</span><span id="c40b" class="ka kb hi jw b fi kg kd l ke kf">                if(node == null) {</span><span id="278a" class="ka kb hi jw b fi kg kd l ke kf">                     node = new TrieNode();</span><span id="879a" class="ka kb hi jw b fi kg kd l ke kf">                     current.children.put(ch, node);</span><span id="d740" class="ka kb hi jw b fi kg kd l ke kf">              }</span><span id="78f7" class="ka kb hi jw b fi kg kd l ke kf">              current= node;</span><span id="1e71" class="ka kb hi jw b fi kg kd l ke kf">              current.size++;</span><span id="814d" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="8e25" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="3e76" class="ka kb hi jw b fi kg kd l ke kf">public int prefixCount(String word) {</span><span id="fdd2" class="ka kb hi jw b fi kg kd l ke kf">             TrieNode current = root;</span><span id="135f" class="ka kb hi jw b fi kg kd l ke kf">             for(int i=0;i&lt;word.length();i++) {</span><span id="60dd" class="ka kb hi jw b fi kg kd l ke kf">                  char ch = word.charAt(i);</span><span id="af87" class="ka kb hi jw b fi kg kd l ke kf">                  TrieNode node =current.children.get(ch);</span><span id="cf2c" class="ka kb hi jw b fi kg kd l ke kf">                 if(node == null) {</span><span id="012b" class="ka kb hi jw b fi kg kd l ke kf">                    return 0;</span><span id="0c0f" class="ka kb hi jw b fi kg kd l ke kf">                  }</span><span id="5d7a" class="ka kb hi jw b fi kg kd l ke kf">                 current = node;</span><span id="4b6f" class="ka kb hi jw b fi kg kd l ke kf">             }</span><span id="6279" class="ka kb hi jw b fi kg kd l ke kf">           return current.size;</span><span id="8dd3" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="5a92" class="ka kb hi jw b fi kg kd l ke kf">public static void main(String args[]) {</span><span id="6ba1" class="ka kb hi jw b fi kg kd l ke kf">          Scanner scan = new Scanner(System.in);</span><span id="81f4" class="ka kb hi jw b fi kg kd l ke kf">          Contacts contact = new Contacts();</span><span id="039a" class="ka kb hi jw b fi kg kd l ke kf">          int n = scan.nextInt();</span><span id="266d" class="ka kb hi jw b fi kg kd l ke kf">         for(int i=0;i&lt;n;i++) {</span><span id="6c60" class="ka kb hi jw b fi kg kd l ke kf">              String operation= scan.next();<br/>              String data = scan.next();</span><span id="9424" class="ka kb hi jw b fi kg kd l ke kf">             if(operation.equals("add")) {</span><span id="3f6b" class="ka kb hi jw b fi kg kd l ke kf">                 contact.insert(data);</span><span id="6dfe" class="ka kb hi jw b fi kg kd l ke kf">             }else if(operation.equals("find")) {</span><span id="98ae" class="ka kb hi jw b fi kg kd l ke kf">                 System.out.println(contact.prefixCount(data));</span><span id="eac5" class="ka kb hi jw b fi kg kd l ke kf">              }</span><span id="e3c1" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="d49c" class="ka kb hi jw b fi kg kd l ke kf">scan.close();</span><span id="7bf4" class="ka kb hi jw b fi kg kd l ke kf">}</span><span id="e7ee" class="ka kb hi jw b fi kg kd l ke kf">}</span></pre><p id="c9ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诀窍是在每次插入过程中跟踪尺寸计数。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="801d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是全部<strong class="ih hj">如果你喜欢这个，请点击几下这些拍手。</strong></p></div></div>    
</body>
</html>