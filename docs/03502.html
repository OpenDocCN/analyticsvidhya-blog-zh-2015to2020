<html>
<head>
<title>Time Complexity: The (Not So) Hidden Secret to Writing Faster Python Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间复杂性:编写更快Python程序的(不那么)隐藏的秘密</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-complexity-the-not-so-hidden-secret-to-writing-faster-python-programs-6200a2872d6a?source=collection_archive---------18-----------------------#2020-02-04">https://medium.com/analytics-vidhya/time-complexity-the-not-so-hidden-secret-to-writing-faster-python-programs-6200a2872d6a?source=collection_archive---------18-----------------------#2020-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/393de8815a05c8d7e07fb8fd52ca14d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HefRYzIkDcwHJcZlMAqkA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由来自<a class="ae iu" href="https://www.pexels.com/photo/blue-tree-painting-2397989/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae iu" href="https://www.pexels.com/@andree-brennan-974943?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安德烈·布伦南</a>拍摄</figcaption></figure><p id="fec6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名初学web开发的人，启动并运行一个程序是一件令人兴奋的事情。有很多次，当我遇到一个特别令人沮丧的工作问题时，我会对着空气(不针对任何人)挥舞拳头。</p><p id="995f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，随着您在旅程中的进一步发展，您可能需要开始考虑扩展程序的复杂性和挑战。</p><blockquote class="jt"><p id="3958" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">随着你成为一名程序员，你开始较少考虑你将如何解决一个特定的问题，而是更多地考虑你为什么以这样或那样的方式解决它。</p></blockquote><p id="776f" class="pw-post-body-paragraph iv iw hi ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">好吧…我撒谎了。你仍然考虑如何做，但是你也必须考虑为什么做。</p><p id="6582" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，你的矩阵程序可以处理一个3 x 3的正方形，但是如果你把它扩大到9 x 9，甚至90 x 90呢？你写的表达式是否足够精简以承受更大规模的执行，或者它们是否会降低你的运行时间，或者更糟，导致你的整个程序崩溃？你不会想等到生产时才发现这一点。最好在第一次编写精益和吝啬的代码，并谨慎行事。</p><p id="3d42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，我在为<a class="ae iu" href="http://Exercism.io" rel="noopener ugc nofollow" target="_blank">exercisem . io</a>做的一个问题中遇到了这类问题。这个问题包括给特定的字母分配不同的分值，并报告任何给定单词的分数，就像你在拼字游戏中所做的那样:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6b67" class="kr ks hi kn b fi kt ku l kv kw">Letter                                Value<br/>A, E, I, O, U, L, N, R, S, T            1</span><span id="c58a" class="kr ks hi kn b fi kx ku l kv kw">D, G                                    2</span><span id="70dc" class="kr ks hi kn b fi kx ku l kv kw">B, C, M, P                              3</span><span id="30dd" class="kr ks hi kn b fi kx ku l kv kw">F, H, V, W, Y                           4</span><span id="c14c" class="kr ks hi kn b fi kx ku l kv kw">K                                       5 </span><span id="4a45" class="kr ks hi kn b fi kx ku l kv kw">J, X                                    8</span><span id="9ce7" class="kr ks hi kn b fi kx ku l kv kw">Q, Z                                    10</span></pre><p id="9dd4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在程序结束时，您需要返回给定单词的完整分数。例如，单词“PYTHON”的得分为14 (3+4+1+4+1+1)。</p><p id="8e81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这个问题，我最初的解决方案是将上述所有值放入一个字典中。上表中“字母”列的每一行都是它自己的键，如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9add" class="kr ks hi kn b fi kt ku l kv kw">def score(word):<br/>    <br/>     letter_values = {</span><span id="66da" class="kr ks hi kn b fi kx ku l kv kw">        "AEIOULNRST": 1,<br/>        "DG": 2,<br/>        "BCMP": 3,<br/>        "FHVWY": 4,<br/>        "K": 5,<br/>        "JX": 8,<br/>        "QZ": 10<br/>    <br/>         }<br/>    <br/>     score = [letter_values[key] for letter in list(word.upper())      <br/>     for key in letter_values if letter in key]<br/>    <br/>     return sum(score)</span></pre><p id="98b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个解决方案中，<em class="ky">分数</em>是一个列表。更准确地说，这是一种嵌套列表理解，它遍历<em class="ky"> letter_values </em>中的每个键以及<em class="ky"> word </em>中的每个字母，并在<em class="ky"> word </em>中追加与给定字母匹配的键的值。</p><p id="3e52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，该函数返回该分数列表中所有值的总和，以得到一个完全可用的解决方案。</p><p id="63ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们从未计划扩大规模。</p><p id="7570" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你看，上面的解决方案中部署的漂亮的列表理解相当复杂。也就是说，它要求计算机做大量的迭代来得到正确的解。在这里，它被解开了:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="aa06" class="kr ks hi kn b fi kt ku l kv kw">for letter in word:<br/>    letter_score = letter_values[letter]</span><span id="473e" class="kr ks hi kn b fi kx ku l kv kw">    score.append(letter_score)</span></pre><p id="d624" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好，但是如果这个单词有100万个字母呢？(我不认为任何语言有那么长的单词，甚至德语也没有，只是跟着它走)。这将需要大量的迭代，因为计算机会在我们的百万字母单词中逐个字母地进行迭代，然后遍历上面的每个键来定位正确的字母，然后插入该字母的相应值。光是想想就让我精疲力尽。</p><p id="a429" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的概念是时间复杂性。<a class="ae iu" href="https://www.techopedia.com/definition/22573/time-complexity" rel="noopener ugc nofollow" target="_blank">你可以在这里阅读更多关于时间复杂度的内容</a>。</p><blockquote class="jt"><p id="253f" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">时间复杂度是算法处理或运行所需时间的量化，是输入量的函数。基本上，它是对你的程序在运行时效率的度量。</p></blockquote><p id="90a3" class="pw-post-body-paragraph iv iw hi ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">老实说，我不完全确定这个程序运行一百万个字母的单词会不会慢一些，我从来没有试过。但这是一个可以重构的低效程序。这是一个很好的机会来探索这个概念，并确保我们编写的代码能够预见到即将出现的这类问题。毕竟，一盎司的预防抵得上一磅的治疗，正如一位<a class="ae iu" href="https://en.wikipedia.org/wiki/Benjamin_Franklin" rel="noopener ugc nofollow" target="_blank">的印刷工人</a>曾经说过的。(顺便说一句，显然他说这话时指的是防火？<a class="ae iu" href="https://www.ag.ndsu.edu/news/columns/beeftalk/beeftalk-an-ounce-of-prevention-is-worth-a-pound-of-cure/" rel="noopener ugc nofollow" target="_blank">感谢互联网。</a>)</p><p id="a6bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，百万美元(或百万字母)的问题是:如何重构它，使程序更有效？</p><p id="00f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们可以使用更多的代码行。虽然这看起来可能违反直觉，但通过将键分解成每个字母并拥有26个不同的键，我们实际上帮助程序运行得更快。这是我们在计算机执行的任务列表中要担心的迭代的一个小步骤。</p><p id="545c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以简单地在给定的键上附加字母的值，就像这样:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0623" class="kr ks hi kn b fi kt ku l kv kw">def score(word):<br/><br/>    letter_values = {<br/>        'A': 1,<br/>        'E': 1,<br/>        'I': 1,<br/>        'O': 1,<br/>        'U': 1,<br/>        'L': 1,<br/>        'N': 1,<br/>        'R': 1,<br/>        'S': 1,<br/>        'T': 1,<br/>        'D': 2,<br/>        'G': 2,<br/>        'B': 3,<br/>        'C': 3,<br/>        'M': 3,<br/>        'P': 3,<br/>        'F': 4,<br/>        'H': 4,<br/>        'V': 4,<br/>        'W': 4,<br/>        'Y': 4,<br/>        'K': 5,<br/>        'J': 8,<br/>        'X': 8,<br/>        'Q': 10,<br/>        'Z': 10<br/>    }<br/>    score = [letter_values[letter] for letter in word.upper()]<br/>    return sum(score)</span></pre><p id="9baa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该程序通过将<em class="ky">letter _ value【letter】</em>插入分数列表，返回每个字母的正确值。</p><p id="4339" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们没有遍历<em class="ky">单词</em>和<em class="ky"> letter_values </em>字典的键，而是遍历<em class="ky">单词</em>中的字母，并将它们直接插入字典中以获取值。</p><p id="8cbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个更简单、更优雅的解决方案。我猜，如果我们的计算机会说话，它们会感谢我们减少了它们生活中的时间复杂性。</p></div></div>    
</body>
</html>