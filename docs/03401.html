<html>
<head>
<title>Beginner’s guide to start with CNN using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CNN使用Keras入门指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/beginners-guide-to-start-with-cnn-using-keras-1430044a8400?source=collection_archive---------15-----------------------#2020-01-29">https://medium.com/analytics-vidhya/beginners-guide-to-start-with-cnn-using-keras-1430044a8400?source=collection_archive---------15-----------------------#2020-01-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee8b417ed09471eb0068a35d3de4751e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SsattFt4vpNyzRJ_"/></div></div></figure><p id="9e28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我开始学习神经网络已经有一段时间了，最近互联网上有很多关于CNN的热点。我发现这是完全合理的，因为这种神经网络在现代技术时代有大量的应用，即物体检测、行人检测、文本检测。在接下来的10分钟里，您将学习使用keras制作自己的卷积神经网络，在它的帮助下，我们将使用一个人的胸部x光图像来预测他/她是否患有肺炎。本文主要面向对神经网络和python知之甚少的读者。</p><p id="1f96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文使用的数据集在<a class="ae jo" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank"> kaggle </a>上提供。</p><h1 id="c85e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">导入所需的库</h1><p id="534e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">最初，我们将从导入必要的库开始。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="70fb" class="lb jq hi kx b fi lc ld l le lf">import numpy as np # linear algebra<br/>import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)<br/>import matplotlib.pyplot as plt # visualizing plots<br/>import os # reading files from system directory<br/>from keras.models import Sequential # keras model<br/>from keras.layers import MaxPooling2D, Activation, Conv2D, Dense, Dropout, Flatten # keras layers<br/>from keras import optimizers <br/>from keras.optimizers import RMSprop # keras optimizer<br/>from keras.preprocessing.image import ImageDataGenerator # keras image preprocessor</span></pre><h1 id="543a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">将图像从文件系统加载到数据帧中</h1><p id="3353" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将从定义两个ImageDataGenerators开始，它们将用于在dataframes中加载数据。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1033" class="lb jq hi kx b fi lc ld l le lf">train_datagen = ImageDataGenerator(rescale = 1./255,<br/>                                   shear_range = 0.2,<br/>                                   zoom_range = 0.2,<br/>                                   horizontal_flip = True)</span><span id="33cf" class="lb jq hi kx b fi lg ld l le lf">test_datagen = ImageDataGenerator(rescale = 1./255)</span></pre><ul class=""><li id="6935" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">train_datagen将帮助我们标准化训练数据集，并使用经过一些修改的单个图像作为另一个输入图像，因为数据集是有限的，稍微不同的图片将有助于提高我们模型的准确性。</li><li id="f8c6" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">test_datagen将用于测试我们的模型，因此除了将其重新调整到与训练数据集相同的级别之外，不需要太多的规范化参数。</li></ul><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b0ae" class="lb jq hi kx b fi lc ld l le lf">train = train_datagen.flow_from_directory('../input/chest-xray-pneumonia/chest_xray/chest_xray/train',target_size = (64, 64),batch_size = 32,color_mode='grayscale',class_mode = 'binary')</span><span id="c883" class="lb jq hi kx b fi lg ld l le lf">val = test_datagen.flow_from_directory('../input/chest-xray-pneumonia/chest_xray/chest_xray/val',target_size=(64, 64), batch_size=32,color_mode='grayscale',class_mode='binary')</span><span id="3ab6" class="lb jq hi kx b fi lg ld l le lf">test = test_datagen.flow_from_directory('../input/chest-xray-pneumonia/chest_xray/chest_xray/test',target_size = (64, 64),batch_size = 32,color_mode='grayscale',class_mode = 'binary')</span></pre><p id="faac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码将数据集加载到三个框架中。除了<strong class="is hj"> <em class="lv"> class_mode </em> </strong>之外，其他参数的名称都是不言自明的，这些参数基本上表示数据中有多少个不同的类；在这种情况下，2表示患者是否患有肺炎。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/4e35655a663dd253a8be611e317eb476.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*NowkcXqVb84KAkTilDTKoA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">上述代码将得出每个数据帧中加载的图像数量</figcaption></figure><h1 id="c3df" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建我们的卷积神经网络</h1><p id="495f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的神经网络将由几层组成，我将在一分钟内逐一解释。Keras使得在我们的模型中添加层变得非常容易，并创建一个由我们添加的不同层组成的通用神经网络对象。该对象随后可用于拟合数据。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="79e4" class="lb jq hi kx b fi lc ld l le lf">model = Sequential()<br/>model.add(Conv2D(32, (3, 3), padding='same',<br/>                 input_shape=(64,64,1),activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Dropout(0.25))</span><span id="9ec9" class="lb jq hi kx b fi lg ld l le lf">model.add(Conv2D(64, (3, 3), padding='same',activation='relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Dropout(0.25))</span><span id="cf8a" class="lb jq hi kx b fi lg ld l le lf">model.add(Flatten())<br/>model.add(Dense(100,activation='relu'))<br/>model.add(Dense(1, activation='sigmoid'))</span><span id="1ca7" class="lb jq hi kx b fi lg ld l le lf">model.compile(optimizer='adam',loss="binary_crossentropy", metrics=["accuracy"])</span></pre><ul class=""><li id="0964" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">顺序模型是层的线性堆叠。我们可以稍后在对象中传递一个层列表来创建堆栈。</li><li id="a759" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">2D卷积层用于图像的空间卷积。当使用conv2d层作为我们模型的第一层时，我们还提供了input_shape参数，即<em class="lv">(高度、宽度、通道)。</em>Conv2D中最初的两个参数分别是<em class="lv"> batch_size </em>和<em class="lv"> kernel_size </em>。<em class="lv"> Relu </em>激活函数用于忽略负值，因为它定义为y = max(0，x)。你可以在官方的<a class="ae jo" href="https://keras.io/layers/convolutional/" rel="noopener ugc nofollow" target="_blank"> keras文档中读到更多关于参数的细节。</a></li><li id="78eb" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">接下来是具有pool _ size，2)的MaxPooling2D图层，这表示输入将在两个空间维度上减半。这样做是为了通过总结特征图中特征的存在来对特征图进行下采样。</li><li id="2683" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">Dropout层将在训练期间使网络变薄，由于所需的节点数量减少，我们的网络将运行得更快。参数是节点的丢失率。</li><li id="a032" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">展平层只是展平我们的张量，然后将它加密成更少的节点。最后的密集层在单个节点(变量)中提供输出，并且这里使用的激活函数是sigmoid，因为它将预测概率作为输出。因为我们需要介于0和1之间的输出。</li><li id="db8b" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">最后一步是用我们在开始时导入的优化器和损失类型编译模型。我们认为“准确性”是将在培训期间评估的指标。</li></ul><h1 id="c80a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们训练吧！</h1><p id="6859" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们已经准备好了模型和数据，我们可以开始根据这些数据训练我们的模型了。这就像下面这行代码一样简单。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="107f" class="lb jq hi kx b fi lc ld l le lf">cnn_model = model.fit_generator(train, steps_per_epoch=163, epochs=10, verbose=1, callbacks=None, validation_data=val, validation_steps=624,class_weight=None, max_queue_size=10, workers=1, use_multiprocessing=False, shuffle=True, initial_epoch=0)</span></pre><ul class=""><li id="f4db" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">每个时期的步骤通常计算为(我们的训练数据帧中的图像数量/批量大小)。</li><li id="171d" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">epochs是我们将根据数据训练模型的迭代次数。</li><li id="f189" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">shuffle参数设置为true，以便在下一个时期对数据进行加扰，从而防止过拟合。</li><li id="1727" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">其余参数可在<a class="ae jo" href="https://keras.io/models/sequential/#fit_generator" rel="noopener ugc nofollow" target="_blank">官方文档</a>中阅读。</li></ul><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/f7f343e771d11bc5c47385fa807307e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Peqp8Mxb1wHANlQ5oa0nJQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">准确度随着历元数的增加而增加</figcaption></figure><h1 id="56b6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">在测试数据集上评估我们的模型</h1><p id="bd80" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一旦我们的模型训练完成，我们就可以在测试数据集上对它进行评估，这将为我们提供更精确的准确性和模型的能力。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0958" class="lb jq hi kx b fi lc ld l le lf">test_accu = model.evaluate_generator(test,steps=624)<br/>print(test_accu[1]*100)</span></pre><p id="ceeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将导致我们的模型在x射线图像的帮助下正确预测肺炎的准确性。在我们的例子中，我们得到了<strong class="is hj"> 89.91 </strong>，对于一个如此简单的模型来说，这已经很不错了。</p><h1 id="1cb0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">取得的成果</h1><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f871" class="lb jq hi kx b fi lc ld l le lf">plt.plot(cnn_model.history['acc'])<br/>plt.plot(cnn_model.history['val_acc'])<br/>plt.title('Model Accuracy')<br/>plt.ylabel('Accuracy')<br/>plt.xlabel('Epoch')<br/>plt.legend(['Training set', 'Validation set'])<br/>plt.show()</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/8397a312dd76c269a985795787e88ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*UCpwDgN19GjFKZ9nE0Mjgg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">历元计数的精确度</figcaption></figure><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cf2e" class="lb jq hi kx b fi lc ld l le lf">plt.plot(cnn_model.history['val_loss'])<br/>plt.plot(cnn_model.history['loss'])<br/>plt.title('Model Loss')<br/>plt.ylabel('Loss')<br/>plt.xlabel('Epoch')<br/>plt.legend(['Training set', 'Test set'])<br/>plt.show()</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es md"><img src="../Images/6c83ab229c7ee44e669c80a2761e5965.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*If7_A5jb8BNDOJn5UB5ObA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">历元计数损失</figcaption></figure><h1 id="9027" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="8016" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在本文中，我们看到了在keras中创建一个CNN模型是多么容易，它可以基于图像输入进行预测，并获得非常好的结果。现在，您可以为不同的应用程序创建自己的模型，并自己练习学习。</p></div></div>    
</body>
</html>