<html>
<head>
<title>Array Indexing: 0-based or 1-based?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组索引:从0开始还是从1开始？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/array-indexing-0-based-or-1-based-dd89d631d11c?source=collection_archive---------4-----------------------#2020-01-26">https://medium.com/analytics-vidhya/array-indexing-0-based-or-1-based-dd89d631d11c?source=collection_archive---------4-----------------------#2020-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d80dd237d059863b2b147db8321da73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVKsZjucxOyWWbEWh1I2hw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">萨法尔·萨法罗夫在<a class="ae iu" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a3d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从零开始的数组索引是对数组中的项进行编号的一种方式，这样数组的第一项的索引为0，而从一开始的数组索引数组的第一项的索引为1。在当今的现代数学符号中，从零开始的索引是一种非常常见的顺序编号方式。特别是，在组合数学中，组合数系使用数字0来表示集合的空子集。在下面这篇博文中，我将仔细研究这两者，比较它们的优缺点。</p><p id="cff5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在现代计算机科学中，大多数编程语言如Python、Ruby、PHP、Java都有从零开始的数组索引。一个很大的原因是，它提供了一个清晰的区别，即序数形式(如第一，第二，第三)有一个既定的意义，即函数的零阶导数，实际上是函数本身(因为你微分0次！)，在一阶导数之前，一阶导数在二阶导数之前，依此类推。这是因为当我们描述属于前面序列的元素时，我们使用序数。众所周知，整数是编程中最基本的类型之一，因为零是存在的最小无符号整数值，所以我们经常会发现零被用作数学序列中多种数值递归的基本情况。此外，一些语言，如C和C++使用指针来存储数据，因此索引从零开始也是有意义的，因为默认情况下，程序计数器首先将内存地址保存为0，从而使编译更容易。在这些情况下，使用从零开始的数组索引会更合适，因为它基于我们经常使用数组的数值方法。</p><p id="7dc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相比之下，对于计算机科学和编程的新用户来说，人们从小就被教导自然数序列是1、2、3等。因此，对于一个完全的初学者来说，从1开始进行数组索引是有意义的。在数学课上，大多数高中生可能是从1开始的序列和数列索引，其中序列的第一个数字的位置是n，其中n是大于零的正整数。从物理上来说，索引为0更有意义，因为你不能有第0项，因为一个项目通常必须有一个正整数的索引。大多数人都被教导计算一个以1为基数的指数等差数列的第n项为<code class="du jt ju jv jw b">a+(n-1)*d</code>，所以他们已经非常熟悉这个数学现象了。然而，基于零的索引允许在运行时更有效的<code class="du jt ju jv jw b">a+n*d</code>。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="200d" class="kf kg hi jw b fi kh ki l kj kk">a = first term<br/>n = the index<br/>d = common difference</span></pre><p id="df09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在以下情况下，基于0的索引可能更有用。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="a54c" class="kf kg hi jw b fi kh ki l kj kk">sequence = [2,5,8,11,14,17,20,23,26,29,32,35]</span></pre><p id="4d97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，如果序列的第一项的索引为0，这意味着我们可以使用<code class="du jt ju jv jw b">a+n*d</code>计算序列的第n项。因此可以使用<code class="du jt ju jv jw b">a+n*d = 2+5*3=17</code>找到索引为5的项目。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/a3e9dd196a1bb628d9c0c5374d9b24fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htz-Sli3FXUP4IxUdOCzng.jpeg"/></div></div></figure><p id="c584" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我们可以使用Python等基于0的索引语言来确认这是否正确，但还是让我们使用Julia中一个名为<a class="ae iu" href="https://github.com/JuliaArrays/OffsetArrays.jl" rel="noopener ugc nofollow" target="_blank"> OffsetArrays.jl </a>的包。它允许Julia用户使用他们自己选择的任意索引的数组，类似于其他语言中可用的数组，例如Fortran。这基本上意味着我们可以创建一个数组，并定义数组中任意项的索引。我们可能使用它的一个原因是，如果我们从Python(基于0的索引)转移，那么对于像我们这样的用户来说，进行基于0的索引会更有意义，也更直观。</p><p id="3463" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的例子中，我从0开始索引数组中的项，以创建一个从零开始的数组。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="ab17" class="kf kg hi jw b fi kh ki l kj kk">using OffsetArrays<br/>sequence = OffsetVector([2,5,8,11,14,17,20,23,26,29,32,35], 0:11)</span></pre><p id="be9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们将第五项输入REPL，我们会得到:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0e7b" class="kf kg hi jw b fi kh ki l kj kk">julia&gt; println(sequence[5])<br/>17</span></pre><p id="054d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，基于0的数组索引要容易得多，因为您可以更容易地计算第n项，而不必在乘以公差带之前从n中减去1。这正是基于0的索引可能派上用场的一个场景。</p><p id="6463" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，假设我们有50件物品，这些物品被分成10块，每块5个。使用方程式<code class="du jt ju jv jw b">a + n*d</code>；其中d = 5(固定块大小)，第n项是a <code class="du jt ju jv jw b">5n + a</code>。这里，<code class="du jt ju jv jw b">n</code>是大数组中方块的索引，范围从0到9，一旦找到了方块<code class="du jt ju jv jw b">n</code>，就需要找到物品。这就是<code class="du jt ju jv jw b">a</code>的用武之地，范围从0到4: <code class="du jt ju jv jw b">a</code>成为你在块(编号从0到9)中寻找的项目(0到4)的索引。</p><p id="b233" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python中的以下数组显示了这方面的一个示例:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="9550" class="kf kg hi jw b fi kh ki l kj kk">myarray = [<br/>[0,1,2,3,4],<br/>[5,6,7,8,9],<br/>[10,11,12,13,14],<br/>[15,16,17,18,19],<br/>[20,21,22,23,24],<br/>[25,26,27,28,29],<br/>[30,31,32,33,34],<br/>[35,36,37,38,39],<br/>[40,41,42,43,44],<br/>[45,46,47,48,49]<br/>]</span></pre><p id="c5b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我想找到第6行第3项的值，我可以简单地使用公式<code class="du jt ju jv jw b">5n+a</code>来计算。由于Python是从0开始索引的，<code class="du jt ju jv jw b">n=5</code>和<code class="du jt ju jv jw b">a=2</code>，所以值只是简单的<code class="du jt ju jv jw b">5*5+2 = 27</code>。我们可以在REPL证实这一点，看看我们是否正确:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="bd32" class="kf kg hi jw b fi kh ki l kj kk">In[2]: myarray[5][2]<br/>Out[2]: 27</span></pre><p id="6136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，如果我们在Julia中这样做，我们不能直接使用公式<code class="du jt ju jv jw b">5n+a</code>。因为是基于1的索引编程语言，所以我们会有<code class="du jt ju jv jw b">n=6</code>和<code class="du jt ju jv jw b">a=3</code>。如果我们这样做了，我们的值将变成<code class="du jt ju jv jw b">5*6+3 = 33</code>。让我们与REPL核对一下:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="5f6a" class="kf kg hi jw b fi kh ki l kj kk">julia&gt; myarray[6][3]<br/>27</span></pre><p id="a502" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像您可能预测的那样，它也给出了<code class="du jt ju jv jw b">27</code>，因为实际上值根本没有改变。因为它仍然没有满足我们得到值27的目标。我们必须从<code class="du jt ju jv jw b">n</code>和<code class="du jt ju jv jw b">a</code>值中减去<code class="du jt ju jv jw b">1</code>，因为Julia是基于1的索引，所以公式改为<code class="du jt ju jv jw b">5(n-1)+(a-1)</code>。因此，我们可以得出结论，在这种情况下，我们使用基于0的数组索引会更有用，因为如果我们使用基于1的数组索引，公式<code class="du jt ju jv jw b">5(n-1)+(a-1)</code>会使人们更难遵循，需要更长的运行时间，并使程序效率更低(如果我们要大规模执行)。</p><p id="8aa1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，由于Julia天生是一种基于1的数组索引编程语言，如果我们要在下面的示例中找到该数组的第五个元素，基于1的数组索引会更有帮助，因为它会返回该数组中的第五个项目，在本例中为“grape”。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="3610" class="kf kg hi jw b fi kh ki l kj kk">fruit = ["apple", "banana", "lemon", "peach", "grape", "orange", "lychee"]</span></pre><p id="544a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">REPL的输出:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="6175" class="kf kg hi jw b fi kh ki l kj kk">julia&gt; println(fruit[5])<br/>grape</span></pre><p id="d5f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，你可能会问“哪个更好？基于0的索引还是基于1的？”。从我们之前看到的情况来看，在计算机科学和组合学中使用基于0的索引非常有用，对c等语言的编译也很有帮助。但是，如果我们谈论的是Julia，那么它使用基于1的索引更有意义，因为它在科学和数学研究领域更受欢迎。此外，它为初学者提供了一个更容易的入口，因为它对那些从一开始计数的人来说非常直观！我相信很高兴看到Julia为那些想在Julia中使用基于0的索引的人提供了一个选择，但是，它确实需要更多的步骤和一些设置来适应。</p><h2 id="278a" class="kf kg hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated"><strong class="ak">感谢您的阅读！</strong></h2><h1 id="ff98" class="lf kg hi bd km lg lh li kq lj lk ll ku lm ln lo kx lp lq lr la ls lt lu ld lv bi translated">参考</h1><p id="2f44" class="pw-post-body-paragraph iv iw hi ix b iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo ma jq jr js hb bi translated">【https://github.com/JuliaArrays/OffsetArrays.jl<br/><a class="ae iu" href="https://developerinsider.co/why-does-the-indexing-of-array-start-with-zero-in-c/" rel="noopener ugc nofollow" target="_blank">https://developer sider . co/why-the-indexing-of-array-start-with-zero-in-c/</a><br/><a class="ae iu" href="https://en.wikipedia.org/wiki/Zero-based_numbering" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Zero-based_numbering</a></p></div></div>    
</body>
</html>