<html>
<head>
<title>Easy Tree Traversal in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中简单的树遍历</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/easy-tree-traversal-in-python-ff75e320978c?source=collection_archive---------7-----------------------#2020-10-31">https://medium.com/analytics-vidhya/easy-tree-traversal-in-python-ff75e320978c?source=collection_archive---------7-----------------------#2020-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ff87fc32dec842bef5f45c0d9b9d5421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a99ke6FZn9ktGdUUNojpsA.png"/></div></div></figure><blockquote class="iq ir is"><p id="9218" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">第1部分:使用递归的DFS&lt;=你在这里</strong></p><p id="e6c9" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第2部分:使用迭代的DFS</p><p id="97da" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第3部分:使用DFS解决Leetcode和binary搜索问题</p><p id="b78c" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第4部分:BFS树遍历</p><p id="8c08" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第5部分:使用BFS解决Leetcode和binary搜索问题</p></blockquote><p id="61f2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">而备考编码面试和竞聘编程树都很重要，一定要知道数据结构。人们应该熟悉树操作，例如在树中插入节点，从树和树遍历中删除节点。说到遍历，有两种方法来遍历一棵树DFS(深度优先搜索)和BFS(广度优先搜索)。在这篇文章中，我们将看看DFS遍历。</p><h1 id="4396" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak"><em class="kt">DFS-遍历</em> </strong></h1><p id="a04b" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">有三种使用dfs遍历树的方法:前序和后序，以及两种实现遍历的方法，即迭代和递归。我们将讨论这两种方法及其差异，并用python实现一个dfs模板来执行上述遍历</p><h1 id="934b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">算法</h1><p id="6976" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">执行DFS Inorder traversal (LVR)的步骤这里我们使用Inorder traversal，我们可以通过改变顺序来实现其他两个，这在实现中是很清楚的。</p><p id="72df" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">执行有序遍历的步骤</p><ol class=""><li id="c4cb" class="kz la hi iw b ix iy jb jc js lb jt lc ju ld jr le lf lg lh bi translated">转到左侧子树</li><li id="0235" class="kz la hi iw b ix li jb lj js lk jt ll ju lm jr le lf lg lh bi translated">将节点标记为已访问</li><li id="040b" class="kz la hi iw b ix li jb lj js lk jt ll ju lm jr le lf lg lh bi translated">转到右边的子树</li><li id="b601" class="kz la hi iw b ix li jb lj js lk jt ll ju lm jr le lf lg lh bi translated">重复上述步骤，直到访问完所有节点</li></ol><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/6ab3abb8247637d0ab719ea8d7d76673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wipdU6oxV147YJ8VK-IxIw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated"><strong class="bd jx">顺序遍历中DFS的可视化</strong></figcaption></figure><h1 id="1af0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">实施:</h1><h2 id="85db" class="lw jw hi bd jx lx ly lz kb ma mb mc kf js md me kj jt mf mg kn ju mh mi kr mj bi translated">实现遍历有两种方法:迭代和递归。</h2><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/8b6658f9d91e8606af7f8ffdb4015e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOAcshg8v2Dz5HJbw8UB-Q.png"/></div></div></figure><p id="8f37" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">上述比较是我对这些方法的感觉，你可以在互联网上找到很多比较，随意选择你觉得舒服的任何方法，因为递归问题可以用迭代方法实现，反之亦然</p><h1 id="463f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">何时使用迭代或递归？</strong></h1><p id="c6bb" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">当需要速度时，使用迭代方法是很好的选择，因为循环比函数调用更快，这就是为什么大多数有竞争力的程序员使用迭代方法。递归解决方案有利于概念构建，因为它们是解决问题的更自然的方法。首先递归解决，然后使用迭代方法优化是很好的实践。</p><blockquote class="iq ir is"><p id="c9c2" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们对什么是遍历、它们如何工作以及实现它们的方法有了一个概念。</p></blockquote><h2 id="31e2" class="lw jw hi bd jx lx ly lz kb ma mb mc kf js md me kj jt mf mg kn ju mh mi kr mj bi translated">让我们开始用python实现递归方法</h2><h2 id="1306" class="lw jw hi bd jx lx ly lz kb ma mb mc kf js md me kj jt mf mg kn ju mh mi kr mj bi translated">有序遍历(LVR)</h2><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="ca04" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">前序遍历(VLR)</h1><p id="6ce3" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">执行前序遍历的步骤</p><p id="f717" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">1.将节点标记为已访问</p><p id="673f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">2.转到左侧子树</p><p id="8e15" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">3.转到右边的子树</p><p id="99ab" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">4.重复上述步骤，直到访问完所有节点</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><blockquote class="iq ir is"><p id="e46d" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们仔细观察这两个代码，我们会注意到它们之间唯一的变化是我们调用函数的方式，在我们遵循的顺序(LVR)和在我们遵循的前序(VLR)的情况下，顺序是唯一的变化，对于后序，你猜对了，顺序将是(LRV)这意味着我们可以使用上面的代码作为简单易懂的dfs模板来实现所有的遍历，只需改变顺序万岁！！！！！！！！！！！！！</p></blockquote><p id="4765" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="iv">下面是发文顺序实现</em> </strong></p><h2 id="9c99" class="lw jw hi bd jx lx ly lz kb ma mb mc kf js md me kj jt mf mg kn ju mh mi kr mj bi translated">前序遍历(VLR)</h2><p id="5cd8" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">执行前序遍历的步骤</p><ol class=""><li id="d0d4" class="kz la hi iw b ix iy jb jc js lb jt lc ju ld jr le lf lg lh bi translated">转到左侧子树</li><li id="8239" class="kz la hi iw b ix li jb lj js lk jt ll ju lm jr le lf lg lh bi translated">转到右边的子树</li><li id="b1dd" class="kz la hi iw b ix li jb lj js lk jt ll ju lm jr le lf lg lh bi translated">将节点标记为已访问</li><li id="6fd6" class="kz la hi iw b ix li jb lj js lk jt ll ju lm jr le lf lg lh bi translated">重复上述步骤，直到访问完所有节点</li></ol><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="fc42" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">输出</h1><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/142e9dc345ef8cd236792d9b0790b8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs3PocxvtXa_cjiWROoHzA.png"/></div></div></figure></div></div>    
</body>
</html>