<html>
<head>
<title>An Intro to Gradient Descent for Kotlin Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林程序员梯度下降介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-intro-to-gradient-descent-for-kotlin-programmers-a98bb5dbd351?source=collection_archive---------7-----------------------#2019-09-05">https://medium.com/analytics-vidhya/an-intro-to-gradient-descent-for-kotlin-programmers-a98bb5dbd351?source=collection_archive---------7-----------------------#2019-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0eca" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">开放式学习练习</h2></div><h1 id="55d8" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="c52f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">梯度下降是一种用于解决监督学习和深度学习问题的算法。在这里，我将试图给你一个想法，为什么算法的工作，以及你如何在Kotlin实现它。我还将展示使用<a class="ae kl" href="https://www.kaggle.com/rush4ratio/video-game-sales-with-ratings" rel="noopener ugc nofollow" target="_blank">的算法，这是一个简单的kaggle数据集，涉及视频游戏销售和评级</a>。</p><p id="f2a5" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">除了梯度下降的Kotlin实现之外，我在这里介绍的所有内容都包含在<a class="ae kl" href="https://www.coursera.org/learn/machine-learning" rel="noopener ugc nofollow" target="_blank">吴恩达的优秀Coursera机器学习课程</a>中。如果你真的想要对梯度下降有一个清晰明确的介绍，我推荐这个课程。在这里，我最感兴趣的是通过分享来巩固我所学到的东西。</p><h1 id="09b9" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">我们的玩具问题</h1><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/86909914a275876cfcfad324135c2e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZ-HKmnrct3FShqlL73QsQ.png"/></div></div></figure><p id="25c6" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">下面是2010年到2016年一堆电子游戏的剧情。在X轴上，我们有一个元评论家分数。在y轴上，我们看到的是北美的百万销量。从数据来看，meta-critic评分和游戏销量之间似乎存在某种关系。我们的玩具问题是这样的:我们想写一个程序，可以根据metric critic评分预测视频游戏的销售。</p><p id="e3b6" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果我们在excel或google sheets中查看这个，我们只需在图表选项中勾选“绘制趋势线”复选框，就几乎可以解决我们的机器学习问题了。Excel对于一些监督学习任务很好，但对于更难的问题就不行了，这就是梯度下降变得必不可少的地方。尽管梯度下降对于这个玩具问题来说可能有点过了，但我们还是要使用它，因为无论什么样的枯燥的学习算法，在excel中已经存在了几十年，大概都不能扩展到更有趣的当代ML问题。</p><p id="b074" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">无论如何，如果我们为上述数据画一条最佳拟合线，它看起来会是这样的:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/54f48e4be002246c000e4783585f1efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rz6Yon15Dff0ArgIg51Xdw.png"/></div></div></figure><p id="faa0" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果你记得你的高中代数，像这样的线的方程看起来像这样:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es le"><img src="../Images/810103dbeeefeca4cbd615ef9cdd557f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*MF2BFwPidDcwWFdbiuTuOg.png"/></div></figure><p id="c527" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">因此，我们在这里的问题实际上是这样的:我们如何计算出给定上述视频游戏数据的<code class="du lf lg lh li b">m</code>和<code class="du lf lg lh li b">b</code>？或者，我们如何实现下面的Kotlin函数:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="04f8" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这确实是问题的症结所在，因为一旦我们实现了这个功能，编写一个可以根据meta-critic分数预测视频游戏销量的程序就变得很简单了:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0346" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们想要的是学习参数使得预测值(由最佳拟合线给出)和所有实际值之间的差异最小化。这个差异<em class="kr">取决于</em>我们为<code class="du lf lg lh li b">x</code>和<code class="du lf lg lh li b">b</code>选择的值；这是这些变量的函数。这个函数被称为“成本函数”，所以我们问题的另一种表述方式是，我们试图找到最小化成本函数的<code class="du lf lg lh li b">x</code>和<code class="du lf lg lh li b">b</code>的值。</p><h1 id="2ddd" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">解决办法</h1><p id="c208" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了开始理解我们如何解决这个问题，我们需要仔细看看成本函数。到底是什么？让我们从一个思维实验开始:假设我们选择0作为<code class="du lf lg lh li b">x</code>和<code class="du lf lg lh li b">b</code>的值。数据集的<em class="kr">实际值</em>和预测值之间会有什么差异？下表列出了前五个数据点，试图抓住这一点:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ll"><img src="../Images/5a21759bf8cb3be832fa6745f747b346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsPcl3A5K0u0FI35JieB6Q.png"/></div></div></figure><p id="8df7" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">总结该表的一种方法是取预测值和实际值之间的平方差的平均值，然后除以2。这就是我们的成本函数，我们称之为<code class="du lf lg lh li b">J</code>。形式上，那是:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lm"><img src="../Images/acc68e5b0d9dcc3a1edb2b0b894c9887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACjCXff0bhCan3KaZOEAcQ.png"/></div></div></figure><p id="e81e" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">其中n是我们数据集中视频游戏的数量。(如果我们在上表中使用这个等式，我们将得到54.31。)让我们暂时忽略<code class="du lf lg lh li b">b</code>，改写我们的等式:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lm"><img src="../Images/5015013c84bedff79d195ab5386bf05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIH7h9yNUZH6kNGrqsJRUA.png"/></div></div></figure><p id="6e15" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">请记住:<code class="du lf lg lh li b">x</code>和<code class="du lf lg lh li b">actual</code>在这里不是变量，我们将能够从我们的数据中插入值，所以我们实际上只是在看一个二次函数，你可能还记得高中时的二次函数是这样的:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/6c685af0c330722aea6fb78a1baa8db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jo4MDD41PPDInMp2ctzb-A.png"/></div></div></figure><p id="2d9c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在这种情况下，x轴是<code class="du lf lg lh li b">m</code>，y轴告诉我们<code class="du lf lg lh li b">m</code>离它需要的位置有多远。该图告诉我们，<code class="du lf lg lh li b">0</code>是我们对<code class="du lf lg lh li b">m</code>的最佳选择，因为选择<code class="du lf lg lh li b">0</code>实际上会最小化成本函数。对于我们的实际数据集来说，这是不正确的，但是梯度下降的基本思想仍然适用，并且这个图(可能)看起来更清晰。</p><p id="e911" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在最高水平上，梯度下降的工作方式是我们猜测<code class="du lf lg lh li b">m</code>的最佳值，然后我们通过称为“学习率”的少量修改我们的猜测，并重复直到我们不再变得更好。这就是这种算法的名字来源:我们减慢梯度下降的速度，直到达到最小值。</p><p id="e137" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这样，我们可以开始填充更多的<code class="du lf lg lh li b">findLearningParameters</code>函数:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="39ec" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">第5行和第7行指出了一些需要解释的函数。你应该能猜到<code class="du lf lg lh li b">cost</code>做了什么:它用前面提到的公式计算出我们对<code class="du lf lg lh li b">m</code>和<code class="du lf lg lh li b">b</code>的猜测有多差:</p><p id="8328" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">所以，实现是这样的:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="8cbb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们使用成本函数的原因是为了监控梯度下降的进度。随着for循环的执行，<code class="du lf lg lh li b">cost</code>应该会下降。</p><p id="3ce9" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">理解<code class="du lf lg lh li b">updateGuess</code>的实现需要稍微了解一下基本的微积分。</p><p id="72e5" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果我们看我们的图<code class="du lf lg lh li b">m</code>和<code class="du lf lg lh li b">J(m)</code>并且记住函数的导数给我们切线的斜率，我们就有了我们所需要的中心洞察力，使得梯度下降成为可能。那么，我们来问:如果我们计算这个函数的导数，并在这个图中为<code class="du lf lg lh li b">m = 1</code>和<code class="du lf lg lh li b">m=-1</code>画切线，会发生什么？</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/cf5e721798c8405ebe7027f79a7144b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yox6Nl9ltZvGR8mkSBNA9A.png"/></div></div></figure><p id="bdac" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">m=1的切线有一个<em class="kr">正</em>斜率，这意味着<code class="du lf lg lh li b">J(m)</code>在该点的导数将为正。m=-1的切线有一个<em class="kr">负的</em>斜率，这意味着<code class="du lf lg lh li b">J(m)</code>在该点的导数将是负的。如果m=1，我们希望我们在<code class="du lf lg lh li b">m</code>的下一个猜测更少，如果m=-1，我们希望我们的下一个猜测更多。我们可以通过减去导数来轻松实现这一点，如果我们这样做，我们最终会得到梯度下降算法的核心:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ln"><img src="../Images/ea0a305f321cdfd069488ee12c4db050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0n5-ZxNmPie_6TpF1KgqA.png"/></div></div></figure><p id="704a" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们这里有一些偏导数，因为我们正在处理多个变量，一般来说，如果我们在学习问题中有更多的功能/变量，可能会有比<code class="du lf lg lh li b">m</code>和<code class="du lf lg lh li b">b</code>更多的学习参数(例如，我们可能认为game studio是一个预测器/变量，可以告诉我们一些关于游戏销售的信息)。这个细节对于获得梯度下降的要点并不重要。科特林是这样的:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="755b" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">运行这段代码会得到<code class="du lf lg lh li b">m</code>的<code class="du lf lg lh li b">.0281</code>和<code class="du lf lg lh li b">b</code>的<code class="du lf lg lh li b">-.804</code>，这非常接近我们之前看到的最佳拟合线。</p><h1 id="8245" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">笔记</h1><ol class=""><li id="a817" class="lo lp hi jr b js jt jv jw jy lq kc lr kg ls kk lt lu lv lw bi translated">这种关系没有我想象的那么牢固。他们说做游戏开发者很辛苦。也许这就是证据。也许数据不是很好。</li><li id="e626" class="lo lp hi jr b js lx jv ly jy lz kc ma kg mb kk lt lu lv lw bi translated">我打赌excel和google sheets使用线性回归的“正常方程”方法，而不是梯度下降，如果你正在处理一个小于10k特征的线性回归问题，这<a class="ae kl" href="https://www.coursera.org/learn/machine-learning/supplement/bjjZW/normal-equation" rel="noopener ugc nofollow" target="_blank">显然是可以的。我也怀疑在没有任何扩展的情况下，它能处理多个变量。</a></li></ol></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="f7d7" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><em class="kr">最初发表于</em><a class="ae kl" href="https://www.philosophicalhacker.com/post/gradient-descent-for-kotlin-programmers/" rel="noopener ugc nofollow" target="_blank">T5【https://www.philosophicalhacker.com】</a><em class="kr">。</em></p></div></div>    
</body>
</html>