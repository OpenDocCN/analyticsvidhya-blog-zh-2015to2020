<html>
<head>
<title>Time Series Modelling — ARIMA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列建模— ARIMA</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-modelling-arima-82453bac7de?source=collection_archive---------15-----------------------#2020-05-03">https://medium.com/analytics-vidhya/time-series-modelling-arima-82453bac7de?source=collection_archive---------15-----------------------#2020-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="10a9" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">本文描述了一个完整的使用ARIMA模型对时间序列数据进行预测的端到端过程。</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/ee75b3cafd7576f9f378a3736f764c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhX6n3egKZaqP6Cg0xJg_w.png"/></div></div></figure><p id="370d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated"><strong class="il hj"> ARIMA </strong> ( <em class="ik">自回归综合移动平均</em>)是一类模型，它根据给定时间序列自身的过去值来解释该时间序列。换句话说，它自己的滞后和滞后预测误差，使方程可以用来预测未来值。</p><p id="0484" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated"><strong class="il hj"> AR — <em class="ik">自动回归</em> </strong>。<br/>利用自身与某些滞后观测值之间的依赖关系的模型。这基本上是时间序列对自身的线性回归。参数<strong class="il hj"> k </strong>代表最大滞后。它也被称为滞后阶。</p><p id="722a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">输出仅取决于其自身的滞后，因此，Yt是Yt 的<em class="ik">滞后的函数。</em></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es jw"><img src="../Images/c67ffafc0fb63e0da4eaf64d152d92bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*QWCNrYasb36_qicc.png"/></div></figure><p id="1068" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated"><strong class="il hj">一— <em class="ik">综合</em> </strong>。<br/>差分观测值的使用。换句话说，从上一时间步的观测值中减去一个观测值。参数<strong class="il hj"> d </strong>表示使时间序列稳定所需的差值数量。</p><p id="8894" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated"><strong class="il hj">马—<em class="ik"/>移动平均线</strong>。<br/>该模型表示未来观察值是所有过去观察值的平均值。我们也可以考虑移动平均模型根据最近预测的误差来修正未来的预测。</p><p id="2b84" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">订单<strong class="il hj"> q </strong>的移动授权流程定义为:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es jx"><img src="../Images/e1bea6060990e80e83d683550c32d4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*X_k8J0Fp4MB3nsFw.jpeg"/></div></figure><p id="b1fe" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">在哪里，</p><ul class=""><li id="8ada" class="jy jz hi il b im in iq ir jt ka ju kb jv kc jg kd ke kf kg bi translated"><em class="ik"> c </em> =数值的平均值</li><li id="423c" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg kd ke kf kg bi translated"><em class="ik"> ϵt </em> =一个周期内数值的变化。换句话说，就是那个时间段的误差。</li><li id="030d" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg kd ke kf kg bi translated"><em class="ik"> t-1，t-2，…..t-q </em>表示订单1，2，…分别问。</li><li id="5689" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg kd ke kf kg bi translated">θ₁, θ2,…..θq表示积分的阶数。对于这个例子，让我们只考虑订单1。</li></ul><p id="b4dd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">所以，MA方程变成了，</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es km"><img src="../Images/9a1b29e3fdb3c04260a65820bcea21df.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/0*OvLb5uMleB94NUYA.jpeg"/></div></figure><p id="3cbd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">参数<strong class="il hj"> q </strong>代表最大滞后，在该最大滞后之后，其他滞后不显著。它也被称为移动平均的顺序或窗口大小。<br/>我们应用自相关函数图(ACF)来找出<strong class="il hj"> q. </strong>的值</p><h1 id="ccca" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我们开始编程吧</h1><p id="07d4" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">对于本文，我决定选择外汇汇率数据集。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es lq"><img src="../Images/66c76f929fbf05bb4eb2f5608b2cf8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*tWViLotq1Fs1GZqv381_-g.png"/></div></figure><p id="e4c2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我们在python代码中导入数据集，并绘制值来检查序列是否真的是非平稳的。</p><p id="d0e1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">但首先，我们需要确保数据被转换成时序数据。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lr"><img src="../Images/b8ece8b52550963d623c6060b7b98e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uQdCCGcyXdjx7sGJLD2Cw.png"/></div></div></figure><p id="4160" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">现在，我们绘制数据，以手动显示平稳性。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ls"><img src="../Images/c5d3371d4ea1583fedc41377d73b0e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*PHr3FLgLQtl8-B4GHS1RWw.png"/></div></figure><p id="c79a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">上述情况清楚地表明，时间序列数据不是静止不变的，特别是由于上半年出现了上升趋势。</p><h2 id="1d63" class="lt ko hi bd kp lu lv lw kt lx ly lz kx jt ma mb lb ju mc md lf jv me mf lj mg bi translated">对数据进行重采样</h2><p id="f2ef" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">有两种类型的重采样:</p><ul class=""><li id="6973" class="jy jz hi il b im in iq ir jt ka ju kb jv kc jg kd ke kf kg bi translated">上采样— <em class="ik">增加采样频率，比如从几分钟到几秒钟。</em></li><li id="e246" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg kd ke kf kg bi translated">下采样— <em class="ik">减少采样频率，比如从几天减少到几个月。</em></li></ul><p id="adb6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">在我们的场景中，原始数据是日常数据。因此，我们将数据降采样为月度数据。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mh"><img src="../Images/3d06af312af772ef527f9a7d99f44568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhXIw9j5VaYa6_ztX-kJRQ.png"/></div></div></figure><p id="9fc1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">现在，在我们进行建模之前，我们需要将数据转换为静态数据。为了实现这一点，我们必须执行差分程序，或者换句话说，滞后数据，正如我在<a class="ae mi" rel="noopener" href="/analytics-vidhya/time-series-analysis-stationarity-check-using-statistical-test-f106e9045370">以前的文章</a>中所描述的。</p><p id="9f78" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我们同时继续执行滞后并检查平稳性，直到<strong class="il hj"> p值</strong>降低到低于<strong class="il hj"> 0.05 </strong>。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mj"><img src="../Images/4c62cf5539b1957848967fde8f7807a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UuhYcLeYd6KUFIaFThN3w.png"/></div></div></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mk"><img src="../Images/68c837a2de7e3f10895e2510791b6159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RlJxRKtJrZ2tolV1GzFAEQ.png"/></div></div></figure><p id="3bee" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">上述绘图结果表明<em class="ik"> p值</em>已经低于0.05，因此我们可以观察到时间序列数据现在已经变得有些稳定。</p><p id="1427" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">所以，<em class="ik"> ts_monthly_log_diff </em>成为我们建模的系列。</p><h2 id="8f4a" class="lt ko hi bd kp lu lv lw kt lx ly lz kx jt ma mb lb ju mc md lf jv me mf lj mg bi translated">找出k值</h2><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ml"><img src="../Images/750ce8b6d95811f5a6f29d03fadb1649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*NfbR8smSicPn2mMu6R2gSw.png"/></div></figure><p id="63d5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我们应用部分自相关函数图(PACF)来找出<strong class="il hj"> k </strong>的值。</p><p id="1406" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated"><strong class="il hj">为什么不是自相关函数(ACF)？</strong></p><p id="0af2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我们不能在AR模型中使用ACF图，因为它显示了很强的相关性，即使对于过去很久的滞后也是如此，因此最终可能导致多重共线性问题。PACF图通过去除已经由过去的滞后解释的成分来避免这种情况，因此我们只得到与残差相关的滞后，即不能由过去的滞后解释的成分。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mm"><img src="../Images/cc5970cd24bf47ac040cd6ce65a3fd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XubTevz7pm0pluOguRO9Ng.png"/></div></div></figure><p id="c971" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">从上面的图中可以明显看出，PACF图在k值= 2时切割x轴。因此，<strong class="il hj"> k值</strong>变为2。</p><h2 id="ed63" class="lt ko hi bd kp lu lv lw kt lx ly lz kx jt ma mb lb ju mc md lf jv me mf lj mg bi translated">找出q值</h2><p id="1ba7" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">订单<strong class="il hj"> q </strong>从ACF图中获得。这是ACF第一次跨越置信区间上限的滞后时间。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mn"><img src="../Images/6f789e032473a66b60272c2152019a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPZol4kIqnPnzM4FFlO5cg.png"/></div></div></figure><p id="53d2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">从上图中可以明显看出，ACF图在q值= 1时切割了置信区间上限(蓝色区域)。</p><p id="6257" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">因此，<strong class="il hj"> q值</strong>变为1。</p><h1 id="a36c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">培训ARIMA模型</h1><p id="0913" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">现在，我们准备建立我们的第一个模型。我们有以下内容:</p><ul class=""><li id="0ccb" class="jy jz hi il b im in iq ir jt ka ju kb jv kc jg kd ke kf kg bi translated">k = 2</li><li id="ea86" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg kd ke kf kg bi translated">d = 1</li><li id="e083" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg kd ke kf kg bi translated">q = 1</li></ul><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mn"><img src="../Images/d85f62c00eaef6c18002351ef4a1d0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ci14gSWz9lk19BhPLNkJ9w.png"/></div></div></figure><h2 id="6b52" class="lt ko hi bd kp lu lv lw kt lx ly lz kx jt ma mb lb ju mc md lf jv me mf lj mg bi translated">残留的；剩余的</h2><p id="9314" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">我们执行残差的核密度估计(KDE)图，它几乎是正态分布，因此表明我们的预测是可信的。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mo"><img src="../Images/8ccfe779b29d83fd8b65f503d33d76db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18Datm9OPBzpNot05rbR1Q.png"/></div></div></figure><h1 id="ce41" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">让我们做一些预测</h1><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mp"><img src="../Images/49e4c8bcef9912d59af9e95d30e8831a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cv45bG1ZLczof0rFv71txg.png"/></div></div></figure><p id="494c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">上图显示预测在数据上有差距。如果我们仔细观察数据，预测是从1980年1月开始的，而在原始时间序列中，我们有从1979年12月开始的数据。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mq"><img src="../Images/6d99c552597a7ef0a0e496ac61f7c6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*1tgtXD78viGk4QBojXtEkA.png"/></div></figure><p id="de5e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">发生这种情况是因为我们之前进行的移位，它为第一个值创建了一个空白或null数据，如下所示。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mr"><img src="../Images/d36dd5a924b6e1b29b5ba3e433aa36aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*ZungF8l4hnhxjgIUWAi9Eg.png"/></div></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ms"><img src="../Images/735d96704c70389ed1fcff0ec378bc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*OxLNskQpisJsiJvDcgymKg.png"/></div></figure><p id="0f95" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">因此，我们对移位的时间序列进行累积求和。我们将原始时间序列的第一个值添加到累积和中。</p><p id="2627" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">这将最终把我们带到数据的原始结构。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mt"><img src="../Images/4450c815b6af6c712dccbc646963ac04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1ZBHK5ffkH4amchkAr3YA.png"/></div></div></figure><p id="bd31" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我们现在尝试绘制包含原始时间序列和预测时间序列的图表。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mu"><img src="../Images/767ed3b033698e4ac5db43a674846d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFIF_Yc48HFtwPK4tLavTQ.png"/></div></div></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mv"><img src="../Images/aafe487c21231b949cb2a19ecf8bca2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*6mhgNKZEIYo1dTIcbM8JSg.png"/></div></figure><p id="5e91" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">我们还将原始时间序列分成训练集和测试集，并对测试数据执行相同的预测过程，以将预测输出与实际或预期输出进行比较。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mj"><img src="../Images/c1549e9995f0e44ee7d7a5d773e98713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxtAljeZuskCpRfj1ZS7SQ.png"/></div></div></figure><h1 id="a040" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">评估绩效</h1><p id="cca6" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">由于时间序列分析属于回归的范畴，由于自动回归的存在，我选择MSE或均方误差作为评估指标。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mw"><img src="../Images/6ec4a7f426a71c838c4a5cf86399a6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9v00GBzHwUQDcWWiN72QIw.png"/></div></div></figure><p id="9ce8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">均方误差为0.0001，这是相当小的，该模型目前是好的。</p><h1 id="1b0f" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">摘要</h1><p id="390d" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it jt ln iw ix ju lo ja jb jv lp je jf jg hb bi translated">让我们总结一下我们在这个实验中执行的所有步骤。</p><ol class=""><li id="f57d" class="jy jz hi il b im in iq ir jt ka ju kb jv kc jg mx ke kf kg bi translated">将导入的数据集转换为时序数据集。</li><li id="0489" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg mx ke kf kg bi translated">基于当前数据的频率，执行下采样或上采样。</li><li id="644e" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg mx ke kf kg bi translated">执行平稳性检查并保持滞后/差分，直到p值降低到小于0.05的值。</li><li id="19a3" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg mx ke kf kg bi translated">绘制PACF和ACF图，以便分别找出<em class="ik"> k </em>值和<em class="ik"> q </em>值。</li><li id="1d91" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg mx ke kf kg bi translated">使用ARIMA模型训练最终的滞后时间序列数据，并提供<em class="ik"> k </em>、<em class="ik"> d </em>和<em class="ik"> q </em>值作为参数。</li><li id="9f24" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg mx ke kf kg bi translated">对预测的时间序列执行累积求和，以便将其转换为原始时间序列格式。</li><li id="ad41" class="jy jz hi il b im kh iq ki jt kj ju kk jv kl jg mx ke kf kg bi translated">对合计的预测时间序列执行预测，并使用MSE评估性能。</li></ol><p id="c1ef" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jt iv iw ix ju iz ja jb jv jd je jf jg hb bi translated">仅此而已。希望你真的喜欢这篇文章。</p></div></div>    
</body>
</html>