<html>
<head>
<title>Deploy your production ready TensorFlow v2.x models with classify signature.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用分类签名部署您的生产就绪TensorFlow v2.x模型。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-your-production-ready-tensorflow-v2-x-models-with-classify-signature-71d58316570c?source=collection_archive---------13-----------------------#2020-04-13">https://medium.com/analytics-vidhya/deploy-your-production-ready-tensorflow-v2-x-models-with-classify-signature-71d58316570c?source=collection_archive---------13-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="881c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个中型博客在开始时没有一张无关的图片，仅仅是为了给事情增加一点活力，那它还有什么意义呢？(:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d562c161b1d9895bcb3988712e59c9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xcBOuHBssRqkAOZw"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jt" href="https://unsplash.com/@krisroller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托佛罗拉</a>拍摄的照片</figcaption></figure><p id="68a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经解决了这个问题，让我们继续讨论重要的问题。</p><h1 id="9686" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="3725" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">对于具有TensorFlow基础知识以及如何使用TensorFlow 2.x构建模型的基础知识的中级人员来说，这是更好的读物。创建分类模型的最佳参考是<a class="ae jt" href="https://www.tensorflow.org/tutorials/keras/classification" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="d228" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，你们都知道，TensorFlow v1.x非常糟糕，我从心底里讨厌它，但有了TensorFlow v2.x，它并没有完全改变，但他们通过让初学者和像我们这样经验有限的人更容易编码和创建模型，改进了很多。对于那些不知道Tensorflow v1.x的人来说，抽象数据结构需要用一种叫做图形的东西来定义。实际上，要执行代码，必须使用会话。这个系统有一个陡峭的学习曲线，因为它与Python编程的正常方式如此不同。调试这样的程序也非常困难，因为当打印一个图形节点时，我们不会得到一个具体的值，而只会看到一个引用。</p><p id="491b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在版本2.0中，Tensorflow从图形/会话架构中移出，并包含了急切执行。急切执行是一种必不可少的编程方法，它们会立即评估操作，而无需构建图形。随着Keras集成到TF本身中，而不是作为一个单独的包，我们有幸减少了TF错误和兼容性问题，这是任何人都无法理解的。(不像TF团队会帮助解决问题)</p><p id="2466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，即使有可怕的支持和不太好的文档，TF仍然是最受欢迎的选择，因为它在2015年推出，主要是因为它支持的平台，如分别使用tflite和tf.js的手机和网页，以及使用其<a class="ae jt" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank"> SavedModel </a>格式的生产就绪TFServing。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/5e59f793ba1493297a825752d6997161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LRLTWVQbCc9rhIx1qMikg.png"/></div></div></figure><p id="ef5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里要解释的是如何为分类模型创建一个“分类”签名，并将其保存为<a class="ae jt" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank"> SavedModel </a>格式，以便在<a class="ae jt" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> TFServing </a>中使用。</p><h1 id="cb9c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">TFServing是什么？</h1><p id="bf28" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">TensorFlow Serving实现了一个运行机器学习模型的服务器，并提供对它们的远程访问。常见任务是对提供的数据进行预测和分类。如果你是一个使用TF进行开发和部署的人，我会建议你去看看，因为这是一种非常优化的部署模型的方式，而且非常棒。</p><h2 id="99d1" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">为什么我们需要分类签名</h2><p id="a605" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">因此，TF提供了三种现成的签名类型，在部署TFServing时可以利用这三种签名。点击此<a class="ae jt" href="https://www.tensorflow.org/tfx/serving/signature_defs" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多信息。</p><p id="4c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但长话短说，基本上如果你处于分类问题中，你有两个选择:</p><ol class=""><li id="d797" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">使用“预测”签名，该签名返回模型的softmax输出，然后您必须编写一个包装器代码来转换该输出，并在客户端获取标签。</li><li id="5763" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">使用“分类”签名，该签名返回标签及其来自模型本身的分数，可以由客户端应用程序直接解释，而无需编写包装器代码。</li></ol><p id="bf30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以你通常会想为什么我们不用“分类”呢，对吗？是的，也许TF不希望你这么做，因为没有任何文档说明如何创建这个签名。间接的，有一些例子展示了如何使用“分类”来创建一个，就像这个mnist <a class="ae jt" href="https://github.com/tensorflow/serving/blob/master/tensorflow_serving/example/mnist_saved_model.py" rel="noopener ugc nofollow" target="_blank">例子</a>。但仅此而已，没有更多关于如何创建一个细节。甚至这个例子也被埋在很多其他链接下，几乎不可能找到。</p><h1 id="0e16" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">让我们进入代码。</h1><h2 id="b1fc" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">要求</h2><p id="b952" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">所以基本上你需要用TensorFlow 2.x版本来设置你的系统，这个版本可以在<a class="ae jt" href="https://www.tensorflow.org/install" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="f940" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">密码</h2><p id="a400" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">所以首先我们需要找到一个数据集和一个模型来解释整个过程。由于这不是一篇关于设计模型的文章，我不打算详细介绍如何创建模型。</p><p id="afbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将使用fashion-mnist数据集，它在<code class="du ma mb mc md b">tf.keras.datasets</code>中提供，以方便使用，但我可以向你保证，所有类型的分类数据都可以直接通过。我们将使用一个非常简单的两层CNN。</p><h2 id="1598" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">进口</h2><p id="56bf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">除了tf库本身，我们不需要任何东西</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="eedc" class="ky jv hi md b fi mi mj l mk ml">import tensorflow as tf<br/>from tensorflow.python.ops import lookup_ops<br/>from tensorflow.python.ops import array_ops<br/>from tensorflow.python.framework import dtypes<br/>from tensorflow.python.saved_model.signature_def_utils_impl import build_signature_def<br/>from tensorflow.python.saved_model.signature_def_utils_impl import is_valid_signature<br/>from tensorflow.compat.v1.saved_model.utils import build_tensor_info<br/>from tensorflow.python.saved_model import tag_constants, signature_constants<br/>from tensorflow.python.saved_model import builder as saved_builder<br/>from tensorflow.compat.v1.keras.backend import get_session</span></pre><p id="3cee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们将需要关闭TF2中的急切执行，以使用TF1中的一些方法。所以，</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="3d3c" class="ky jv hi md b fi mi mj l mk ml">tf.compat.v1.disable_eager_execution()</span></pre><h2 id="c93b" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">获取数据集</h2><p id="8b1d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是准备fashion-mnist数据集的标准代码。这里没什么有趣的。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="8b18" class="ky jv hi md b fi mi mj l mk ml">fashion_mnist = tf.keras.datasets.fashion_mnist<br/>(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()</span><span id="cd46" class="ky jv hi md b fi mm mj l mk ml"># scale the values to 0.0 to 1.0<br/>train_images = train_images / 255.0<br/>test_images = test_images / 255.0</span><span id="2f93" class="ky jv hi md b fi mm mj l mk ml"># reshape for feeding into the model<br/>train_images = train_images.reshape(train_images.shape[0], 28, 28, 1)<br/>test_images = test_images.reshape(test_images.shape[0], 28, 28, 1)</span><span id="3ae3" class="ky jv hi md b fi mm mj l mk ml">class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',<br/>               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']</span><span id="7743" class="ky jv hi md b fi mm mj l mk ml">print('\ntrain_images.shape: {}, of {}'.format(train_images.shape, train_images.dtype))<br/>print('test_images.shape: {}, of {}'.format(test_images.shape, test_images.dtype))</span></pre><h2 id="f1be" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">定义您的模型</h2><p id="f755" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">具有密集输出的标准2层CNN。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="68bd" class="ky jv hi md b fi mi mj l mk ml">model = tf.keras.Sequential([<br/>  tf.keras.layers.Conv2D(input_shape=(28,28,1), filters=8, kernel_size=3, <br/>                      strides=2, activation='relu', name='Conv1'),<br/>  tf.keras.layers.Flatten(),<br/>  tf.keras.layers.Dense(10, activation=tf.nn.softmax, name='Softmax')<br/>])<br/>model.summary()</span></pre><h2 id="3aeb" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">签名部分</h2><p id="836f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是没有文档的部分。这对于保存模型以供TF使用<strong class="ih hj">分类API动作</strong>是必要的。我们将使用这些来正确地生成签名定义。TF服给点文档<a class="ae jt" href="https://www.tensorflow.org/serving/signature_defs" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="52df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以有多种方法可以做到。我将在这里解释我认为最有效的添加签名的方法。我将在GitHub repo中添加其他方法。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="40d6" class="ky jv hi md b fi mi mj l mk ml">def preprocess_image(image_buffer):<br/>    image = tf.image.decode_jpeg(image_buffer, channels=1)<br/>    image = tf.image.resize(image, (28, 28))<br/>    image = tf.image.convert_image_dtype(image, dtype=tf.float32)</span><span id="cc86" class="ky jv hi md b fi mm mj l mk ml">return image / 255</span></pre><p id="640d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，按照TensorFlow的定义，将提供给classify API的输入是字符串缓冲区。因此，上面的这个函数将帮助我们把图像缓冲区转换成一个浮点张量。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="5262" class="ky jv hi md b fi mi mj l mk ml">NUM_CLASSES = len(class_names)</span><span id="d620" class="ky jv hi md b fi mm mj l mk ml">serialized_tf_example = array_ops.placeholder(tf.string,<br/>                                              name='tf_example')<br/>feature_configs = {'x': tf.io.FixedLenFeature([], tf.string), }<br/>tf_example = tf.io.parse_example(serialized_tf_example,<br/>                                 feature_configs)</span><span id="3c9c" class="ky jv hi md b fi mm mj l mk ml">jpegs = tf_example['x']<br/>x = tf.map_fn(preprocess_image, jpegs, dtype=tf.float32)<br/>y = model(x)</span><span id="748e" class="ky jv hi md b fi mm mj l mk ml"># Create Signature<br/>values, indices = tf.nn.top_k(y, NUM_CLASSES)<br/>table = lookup_ops.index_to_string_table_from_tensor(<br/>    vocabulary_list=tf.constant(class_names),<br/>    default_value="UNK",<br/>    name=None<br/>    )<br/>prediction_classes = table.lookup(tf.cast(indices, dtype=dtypes.int64))</span><span id="51b9" class="ky jv hi md b fi mm mj l mk ml">classification_inputs = build_tensor_info(serialized_tf_example)<br/>classification_outputs_classes = build_tensor_info(prediction_classes)<br/>classification_outputs_scores = build_tensor_info(values)</span><span id="d9f2" class="ky jv hi md b fi mm mj l mk ml">classification_signature = build_signature_def(<br/>  inputs={<br/>      tf.compat.v1.saved_model.signature_constants.CLASSIFY_INPUTS:<br/>          classification_inputs<br/>  },<br/>  outputs={<br/>      tf.compat.v1.saved_model.signature_constants<br/>      .CLASSIFY_OUTPUT_CLASSES:<br/>          classification_outputs_classes,<br/>      tf.compat.v1.saved_model.signature_constants<br/>      .CLASSIFY_OUTPUT_SCORES:<br/>          classification_outputs_scores<br/>  },<br/>  method_name=tf.compat.v1.saved_model.signature_constants<br/>  .CLASSIFY_METHOD_NAME)</span><span id="98fa" class="ky jv hi md b fi mm mj l mk ml"># Checking validation<br/>valid_signature = is_valid_signature(classification_signature)<br/>if not valid_signature:<br/>    raise ValueError("Error: Classification signature not valid!")</span></pre><p id="e2d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这里所发生的一切:</p><ul class=""><li id="bb02" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mn ls lt lu bi translated">首先，我们定义一些在TFServer中运行它所需的输入。</li><li id="7598" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mn ls lt lu bi translated">输入将是一串图像缓冲区，如这里定义的<a class="ae jt" href="https://www.tensorflow.org/tfx/serving/signature_defs#classification_signaturedef" rel="noopener ugc nofollow" target="_blank"/>。因此，我们需要将其转换为float32，从而使用<code class="du ma mb mc md b">tf.map_fn.</code>向图形添加预处理功能</li><li id="0e2c" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mn ls lt lu bi translated">然后传递占位张量并得到输出。因为我们已经禁用了急切执行，所以它不会被执行，但是我们会得到一个占位符张量。</li><li id="fc1f" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mn ls lt lu bi translated">然后，我们为包含所有类名的类创建一个表或散列表，然后根据它们的分数进行排序。</li><li id="2e76" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mn ls lt lu bi translated">最后，我们构建要添加到图中的张量，并传递给它一个由tf提供的<code class="du ma mb mc md b">build_signature_def</code>,以根据我们的需要创建签名定义。</li><li id="4ec8" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mn ls lt lu bi translated">然后，我们可以用另一个内置函数<code class="du ma mb mc md b">is_valid_signature.</code>来验证我们刚刚创建的签名</li></ul><p id="3ef5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们还没有将此图添加到我们的模型图中，该部分将在稍后保存模型时出现。</p><h2 id="304b" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">训练模型。</h2><p id="aeae" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在我们已经完成了所有这些，我们可以编译和训练模型了。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="7102" class="ky jv hi md b fi mi mj l mk ml">epochs = 1<br/>model.compile(optimizer=tf.optimizers.Adam(), <br/>              loss='sparse_categorical_crossentropy',<br/>              metrics=['accuracy'])</span><span id="8209" class="ky jv hi md b fi mm mj l mk ml">model.fit(train_images, train_labels, epochs=epochs)</span></pre><h2 id="1e58" class="ky jv hi bd jw kz la lb ka lc ld le ke iq lf lg ki iu lh li km iy lj lk kq ll bi translated">保存模型</h2><p id="0bc4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在，为了保存模型，我们必须将它保存为上面指定的SavedModel格式，以便用于TFServing。我们还将创建的签名添加到模型中。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="8ef5" class="ky jv hi md b fi mi mj l mk ml">export_path = 'models/123'<br/>session = get_session()<br/>builder = saved_builder.SavedModelBuilder(export_path)</span><span id="6984" class="ky jv hi md b fi mm mj l mk ml"># Add the meta_graph and the variables to the builder<br/>serv_key = signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY<br/>builder.add_meta_graph_and_variables(<br/>      session, [tag_constants.SERVING],<br/>      signature_def_map={<br/>           serv_key: classification_signature,<br/>      },<br/>      main_op=tf.compat.v1.tables_initializer(),<br/>      strip_default_attrs=True)<br/># save the graph<br/>builder.save()</span></pre><p id="ec75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">get_session</code>函数将为我们提供现有的图表，我们必须添加我们的签名。这是用一种叫做<code class="du ma mb mc md b">saved_builder</code>的东西完成的，更多信息<a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/saved_model" rel="noopener ugc nofollow" target="_blank">在这里</a>。我们将我们的签名添加到现有的图中，在这种情况下是我们的模型并保存它。</p><p id="75d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，模型将保存在指定的文件夹中，其中包含文件夹资产和变量以及saved_model.pb文件。如果是这样，我们已经准备好部署模型了。</p><h1 id="b619" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在TFServing中部署模型</h1><p id="44e2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">因此，有多种方式部署这个可用的可服务模型<a class="ae jt" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank">这里是</a>。这里我们将使用最简单的方法，即使用TFServing docker。更多文档请点击<a class="ae jt" href="https://www.tensorflow.org/tfx/serving/docker" rel="noopener ugc nofollow" target="_blank">这里</a>。要遵循的步骤是:</p><ul class=""><li id="1bce" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mn ls lt lu bi translated">你需要安装Docker。查看<a class="ae jt" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</li><li id="a1ec" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mn ls lt lu bi translated">通过以下方式提取TensorFlow docker服务器映像</li></ul><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="ddfd" class="ky jv hi md b fi mi mj l mk ml">sudo docker pull tensorflow/serving</span></pre><ul class=""><li id="57f2" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mn ls lt lu bi translated">然后在保存模型的目录中打开终端，用下面给出的命令运行docker映像</li></ul><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="6733" class="ky jv hi md b fi mi mj l mk ml">docker run -t --rm -p 8501:8501 -v "$(pwd)/models/:/models/fashion" -e MODEL_NAME=fashion tensorflow/serving &amp;</span></pre><p id="7d06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建一个docker容器，其中运行TensorFlow服务器，并将我们的模型作为输入。确保位于包含saved_model.pb的文件夹所在的文件夹中。我将很快写另一篇博客来解释部署部分。</p><ul class=""><li id="7b0e" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mn ls lt lu bi translated">现在模型正在运行，您应该会看到类似这样的内容</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/b61cf2afadedbc3a1764d75ca282b5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWGwOGmD7_F8JyAX_XVyBg.png"/></div></div></figure><p id="ef9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您看到一条消息“正在进入事件循环”，这意味着您的模型当前正在运行并准备接受请求。</p><ul class=""><li id="2a2a" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mn ls lt lu bi translated">发送请求并获得输出。</li></ul><p id="a8ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此你需要一些图书馆。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="1ac2" class="ky jv hi md b fi mi mj l mk ml">import requests<br/>import base64<br/>import json</span></pre><p id="7111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要将我们的图像以指定的格式发送到TensorFlow服务器创建的URL。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="82a1" class="ky jv hi md b fi mi mj l mk ml">headers = {"content-type": "application/json"}<br/>SERVER_URL = '<a class="ae jt" href="http://localhost:8501/v1/models/fashion:classify'" rel="noopener ugc nofollow" target="_blank">http://localhost:8501/v1/models/fashion:classify'</a></span><span id="1ad7" class="ky jv hi md b fi mm mj l mk ml">loaded_image = open('test_image.jpg', 'rb').read()<br/>jpeg_bytes = base64.b64encode(loaded_image).decode('utf-8')</span><span id="fd86" class="ky jv hi md b fi mm mj l mk ml">body = {<br/>    "signature_name": "serving_default",<br/>    "examples" : [{<br/>        "x": { "b64": jpeg_bytes},  <br/>     }]<br/>}<br/>r = requests.post(SERVER_URL, data=json.dumps(body), headers = headers)</span></pre><p id="f4c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们以字节的形式读取图像，将其编码为base64，包装成JSON格式，然后向该格式的URL发送post请求。如果成功，你将获得一个<code class="du ma mb mc md b">&lt;Response [200]&gt;</code>。现在要获得输出，我们需要做的只是读取输出的内容。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="8412" class="ky jv hi md b fi mi mj l mk ml">json.loads(r.text)</span></pre><h1 id="51cf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">完成的</h1><p id="b9d9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">啊，瞧，Donee…！！！你将得到你的输出，包括班级和他们各自的分数。您的输出可能如下所示。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="dfca" class="ky jv hi md b fi mi mj l mk ml">{'results': [[['Bag', 0.999858618],<br/>   ['Shirt', 6.90536544e-05],<br/>   ['T-shirt/top', 4.54395085e-05],<br/>   ['Trouser', 2.42908627e-05],<br/>   ['Dress', 2.16052649e-06],<br/>   ['Ankle boot', 3.70926585e-07],<br/>   ['Pullover', 3.7451251e-08],<br/>   ['Coat', 1.59411251e-09],<br/>   ['Sneaker', 9.65969305e-10],<br/>   ['Sandal', 1.49970661e-11]]]}</span></pre><p id="475e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您已经有了一个可供生产的模型。当我说生产就绪模型时，这不是部署模型的最佳方式。虽然，这就是如何用分类签名API正确保存分类模型。</p><p id="f522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我发布的笔记本的<a class="ae jt" href="https://github.com/cypherix/Deploy-TensorFlow-v2.x-models/blob/master/tfmodel_with_classify.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a>。如果您有任何疑问，请在GitHub repo中创建一个问题或发表评论。</p></div></div>    
</body>
</html>