<html>
<head>
<title>Detecting Pneumonia in X-ray Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 X 射线图像中检测肺炎</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/detecting-pneumonia-in-x-ray-images-with-a-convolutional-neural-network-735f68f40564?source=collection_archive---------17-----------------------#2020-11-23">https://medium.com/analytics-vidhya/detecting-pneumonia-in-x-ray-images-with-a-convolutional-neural-network-735f68f40564?source=collection_archive---------17-----------------------#2020-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ba2d9f821d00430c358a682372a56fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzHjJxK3igS6D1JpyFKnpg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@nci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">国家癌症研究所</a>在<a class="ae iu" href="https://unsplash.com/s/photos/x-ray?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8595" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我写这篇文章的主要目的是强调一个实际应用，作为构建一个卷积神经网络(CNN)模型的结果。总的来说，CNN 模型的应用范围很广；在这种情况下，它正在建立一个可以在 x 射线图像中准确检测肺炎的模型。听起来很酷，对吧？但是，当我们有可以执行相同任务的医学专家时，我们为什么需要卷积神经网络呢？</p><p id="dd6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">为什么我们需要 CNN 来检测肺炎？</strong></p><p id="a948" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在世界范围内，普遍缺乏放射科医生，并且这一数字持续减少，这导致花费大量资源来确定医学成像的结果。在许多情况下，缺乏放射科医生会延误检查结果。这也可能意味着依赖不具备放射学专业知识的医疗专业人员，从而导致错误的结果。在短时间内获得准确的结果对某些患者来说是至关重要的，甚至可能是救命稻草。</p><p id="18c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个特殊项目中使用的图像是针对 5 岁以下的儿科患者的。据世界卫生组织统计，肺炎占全球 5 岁以下儿童死亡的 15%。由细菌引起的肺炎可以用抗生素治疗，但是只有三分之一的儿童使用抗生素。简化准确检测儿童肺炎的过程是必要的，这确实可以拯救生命。</p><p id="8db4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经理解了 CNN 的必要性，让我们来看看这个项目和最终模型结果的一些细节。在继续之前，如果您对用于构建项目的一些代码不感兴趣，只想看到最终结果(如果您不了解 Python，这是可以理解的)，那么请随意滚动到文章的末尾。</p><p id="a641" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据:</strong> <br/>本项目数据直接从<a class="ae iu" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/paultimothymiooney/chest-x ray-pneumonia</a>下载。该数据包含 5，856 张混合了 RGB 和灰度图像的 x 射线图像。</p><p id="ee49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">调整图像大小:</strong> <br/>在本地机器上运行时，为了提高效率，图像被调整为 75x75。此外，迁移学习与预训练网络 InceptionResNetV2 一起使用，该网络要求最小图像尺寸为 75x75。</p><p id="afdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">训练、验证和测试集:</strong> <br/>原始训练、测试和验证集是 5，216，624 和 16 幅图像。所有的图像和标签被组合，然后重新分割，以增加测试集的大小，从而更准确地评估模型结果，因为 16 个图像本身不会给出足够清晰的图片。最终的训练集略微减少到 5，153 幅图像，在建模过程中使用总共 632 幅图像的验证集来衡量模型的准确性并进一步调整模型，测试集用于衡量模型如何处理总共 71 幅图像的看不见的数据。</p><p id="7e0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据扩充:</strong> <br/>实施数据扩充是为了增加训练集的大小，并为模型提供额外的图像多样性以提高准确性(您可能已经注意到上面的重新分割训练图比原始图大)。初始训练集被加倍，像素值小于 25 的图像被替换为 0。本质上，这将较暗的灰色区域转换为黑色，并允许模型专注于更重要、更亮的区域。下面是原始图像与修改后的图像的比较，以及用于进行这种修改的代码(差异非常细微，但很有效):</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="293b" class="kc kd hi jy b fi ke kf l kg kh">#Change pixel values for data augmentation<br/>i = (X_train &gt;= 0) &amp; (X_train &lt; 25)<br/>altered = np.where(i, 0, X_train)</span></pre><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/a05f2cf82f1ce496134a8e112c9cd06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUnj47l9UeaYcIhBH04JjQ.png"/></div></div></figure><p id="480d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，下面是原始训练集与增强训练集的对比图:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/2369229672b88f3242679437ef4062c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhvmBzSg7fgd7h85DmogJw.png"/></div></div></figure><p id="48b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">建立初始模型:</strong></p><p id="cb1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的第一个函数被创建来可视化一个混淆矩阵，以便理解真阳性、真阴性、假阳性和假阴性的分类。下面的第二个函数是为建模过程创建的。如文档所述，该函数用于构建神经网络模型，返回分类报告和混淆矩阵，并使用基于验证准确性的模型检查点回调来保存最佳模型。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ed91" class="kc kd hi jy b fi ke kf l kg kh">#Build Plot Confusion Matrix Function<br/>def plot_confusion_matrix(cm, classes=[0, 1], normalize=False, title=None, cmap=plt.cm.Blues, ax=None):<br/>    """<br/>    Print and plot a confusion matrix.<br/>    Normalization can be applied by setting `normalize=True`.<br/>    """<br/>    plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes)<br/>    plt.yticks(np.arange(0, 1), [0, 1])</span><span id="89e5" class="kc kd hi jy b fi kk kf l kg kh">if normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>    else:<br/>        pass</span><span id="c88f" class="kc kd hi jy b fi kk kf l kg kh">thresh = cm.max() / 2.<br/>    j_list = []<br/>    for i in cm:<br/>        for j in i:<br/>            j_list.append(j)<br/>    zero = j_list[:2]<br/>    one = j_list[2:]<br/>    for i, j in enumerate(zero):<br/>        plt.text(x=i, y=0, s=j, horizontalalignment="center", fontsize=16, <br/>                 color="white" if j &gt; thresh else "black")<br/>        plt.text(x=0, y=0.2, s='True Negatives', horizontalalignment="center",<br/>                 fontsize=16, <br/>                 color="white" if j &gt; thresh else "black")<br/>        plt.text(x=1, y=0.2, s='False Positives', horizontalalignment="center",<br/>                 fontsize=16, <br/>                 color="white" if j &gt; thresh else "black")<br/>    for i, j in enumerate(one):<br/>        plt.text(x=i, y=1, s=j, horizontalalignment="center", verticalalignment="center", fontsize=16, <br/>                 color="white" if j &gt; thresh else "black")<br/>        plt.text(x=0, y=1.2, s='False Negatives', horizontalalignment="center", <br/>                 fontsize=16, <br/>                 color="white" if j &gt; thresh else "black")<br/>        plt.text(x=1, y=1.2, s='True Positives', horizontalalignment="center", <br/>                 fontsize=16, <br/>                 color="white" if j &gt; thresh else "black")</span><span id="c8e5" class="kc kd hi jy b fi kk kf l kg kh">plt.tight_layout()<br/>    plt.ylabel('True label')</span></pre><p id="3558" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构建模型的函数:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5236" class="kc kd hi jy b fi ke kf l kg kh">layers_list = []</span><span id="7e7d" class="kc kd hi jy b fi kk kf l kg kh"># Create Model Checkpoint <br/>mc = ModelCheckpoint('best_model_test.h5', monitor='val_accuracy', mode='max', verbose=1, save_best_only=True)</span><span id="2ac8" class="kc kd hi jy b fi kk kf l kg kh">def build_model(optimizer, epochs, batch_size, callbacks=mc, weights={0:1,1:1}):<br/>    """<br/>    Build a neural network model, returning classification reports, confusion matrix, <br/>    and save best model using model checkpoint based on val_accuracy.<br/>    <br/>    Input Parameters: optimizer, epochs, batch_size, callbacks, weights<br/>    """<br/>    <br/>    # Initialize a sequential model<br/>    model = Sequential()</span><span id="d19f" class="kc kd hi jy b fi kk kf l kg kh"># Add layers<br/>    for i in layers_list:<br/>        model.add(i)<br/>    <br/>    # Compile the model<br/>    model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])<br/>    <br/>    results = model.fit(X_train, y_train, callbacks=callbacks, class_weight=weights, epochs=epochs, batch_size=batch_size, <br/>                        validation_data=(X_test, y_test))<br/>    build_model.results = results<br/>    <br/>    # Output (probability) predictions for the train and test set<br/>    y_hat_train = model.predict(X_train)<br/>    y_hat_test = model.predict(X_test)<br/>    build_model.y_hat_train = y_hat_train<br/>    build_model.y_hat_test = y_hat_test<br/>    <br/>    #Visualize Results<br/>    history = results.history<br/>    plt.figure()<br/>    plt.plot(history['val_loss'])<br/>    plt.plot(history['loss'])<br/>    plt.legend(['val_loss', 'loss'])<br/>    plt.title('Loss')<br/>    plt.xlabel('Epochs')<br/>    plt.ylabel('Loss')<br/>    plt.show()<br/>    <br/>    plt.figure()<br/>    plt.plot(history['val_accuracy'])<br/>    plt.plot(history['accuracy'])<br/>    plt.legend(['val_accuracy', 'accuracy'])<br/>    plt.title('Accuracy')<br/>    plt.xlabel('Epochs')<br/>    plt.ylabel('Accuracy')<br/>    plt.show()<br/>    <br/>    print('-----------------------------------\n')<br/>    <br/>    # Print the loss and accuracy for the training set <br/>    results_train = model.evaluate(X_train, y_train)<br/>    print('Train Results', results_train)<br/>    print('-----------------------------------\n')<br/>    <br/>    # Print the loss and accuracy for the training set <br/>    results_test = model.evaluate(X_test, y_test)<br/>    print('Test Results', results_test)<br/>    print('-----------------------------------\n')<br/>    <br/>    # Print Classification Reports<br/>    print('Train Classification Report')<br/>    print(classification_report(y_train, np.round(y_hat_train, 0), <br/>                                target_names = ['Normal (Class 0)','Pneumonia (Class 1)']))<br/>    print('-----------------------------------\n')<br/>    <br/>    print('Test Classification Report')<br/>    print(classification_report(y_test, np.round(y_hat_test, 0), <br/>                                target_names = ['Normal (Class 0)','Pneumonia (Class 1)']))<br/>    print('-----------------------------------\n')<br/>    <br/>    # load the saved model<br/>    saved_model = load_model('best_model_test.h5')</span><span id="d72b" class="kc kd hi jy b fi kk kf l kg kh"># evaluate the model<br/>    _, train_acc = saved_model.evaluate(X_train, y_train, verbose=0)<br/>    _, test_acc = saved_model.evaluate(X_test, y_test, verbose=0)<br/>    build_model.saved_model = saved_model<br/>    print('Best Model Results\n')<br/>    print('Train: %.3f, Test: %.3f' % (train_acc, test_acc))<br/>    print('-----------------------------------\n')<br/>    <br/>    #Create Confusion Matrices<br/>    train_cm = confusion_matrix(y_true=y_train, y_pred=np.round(y_hat_train, 0))<br/>    test_cm = confusion_matrix(y_true=y_test, y_pred=np.round(y_hat_test, 0))<br/>    build_model.train_cm = train_cm<br/>    build_model.test_cm = test_cm<br/>    <br/>    #Plot Train Confusion Matrices<br/>    plt.figure(figsize=(12, 6))<br/>    plt.subplot(121)<br/>    plot_confusion_matrix(cm=train_cm, <br/>                          cmap=plt.cm.Blues)<br/>    <br/>    plt.subplot(122)<br/>    plot_confusion_matrix(cm=test_cm, <br/>                          cmap=plt.cm.Blues)<br/>    plt.subplots_adjust(wspace=0.4)</span></pre><p id="8824" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然已经设置了函数，下面是第一个模型的结构:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c07f" class="kc kd hi jy b fi ke kf l kg kh">#Add layers<br/>layers_list = []</span><span id="ab72" class="kc kd hi jy b fi kk kf l kg kh">layer1 = layers.Conv2D(75, (2, 2), padding='same', activation='relu', input_shape=(75, 75,  3))<br/>layer2 = layers.MaxPooling2D((2, 2), padding='same')<br/>layer3 = layers.Conv2D(75, (2, 2), padding='same', activation='relu')<br/>layer4 = layers.MaxPooling2D((2, 2), padding='same')<br/>layer5 = layers.Conv2D(75, (2, 2), padding='same', activation='relu')<br/>layer6 = layers.MaxPooling2D((2, 2), padding='same')<br/>layer7 = layers.Flatten()<br/>layer8 = layers.Dense(75, activation='relu')<br/>layer9 = layers.Dense(1, activation='sigmoid')</span><span id="4735" class="kc kd hi jy b fi kk kf l kg kh">layers_list = [layer1, layer2, layer3, layer4, layer5, layer6, layer7, layer8, layer9]</span><span id="a36a" class="kc kd hi jy b fi kk kf l kg kh">#Utilize Stochastic Gradient Descent Optimizer<br/>opt = keras.optimizers.SGD(learning_rate=0.01, momentum=.9)</span><span id="548e" class="kc kd hi jy b fi kk kf l kg kh">#Build model with pre-built function<br/>build_model(optimizer=opt, epochs=50, batch_size=100, callbacks=mc)</span></pre><p id="0660" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该模型表现良好，验证集的准确率为 96.7%。我尝试了没有迁移学习的第二种模式，试图改善这些结果，但无济于事。事实上，我尝试了数百万个不同的参数和超参数，在某些情况下确实取得了更好的结果，但总体上最好的模型结果是由预构建的 InceptionResNetV2 模型确定的。我不会在这里打印整个模型结构，因为它相当大，但是如果您感兴趣，您可以用 Python 查看这个代码的结构(以及在我的 GitHub repo 中，包含在本文的末尾):</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c2fd" class="kc kd hi jy b fi ke kf l kg kh">#Import InceptionResNetV2<br/>from keras.applications import InceptionResNetV2</span><span id="f78e" class="kc kd hi jy b fi kk kf l kg kh">#Build the model base with required input shape 75x75x3<br/>cnn_base = InceptionResNetV2(weights='imagenet', <br/>                 include_top=False, <br/>                 input_shape=(75, 75, 3))</span><span id="7425" class="kc kd hi jy b fi kk kf l kg kh">#View base structure<br/>cnn_base.summary()</span></pre><p id="0643" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，大多数会冻结预训练网络或至少部分网络，以使用预构建的模型权重并减少训练时间。我决定与众不同，重新训练整个模型以提高准确性。这可以在我的 Mac 上运行，数据集的大小和使用一个较小的图像大小为 75x75x3。我将基本模型作为我的第一层，如下所示:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9e95" class="kc kd hi jy b fi ke kf l kg kh">#Set random seed<br/>np.random.seed(123)</span><span id="9ff1" class="kc kd hi jy b fi kk kf l kg kh">#Add layers including InceptionResNetV2 base<br/>layers_list = []</span><span id="970e" class="kc kd hi jy b fi kk kf l kg kh">layer1 = cnn_base<br/>layer2 = layers.Flatten()<br/>layer3 = layers.Dense(75, activation='relu')<br/>layer4 = layers.Dense(1, activation='sigmoid')</span><span id="11ad" class="kc kd hi jy b fi kk kf l kg kh">layers_list = [layer1, layer2, layer3, layer4]</span><span id="cc8e" class="kc kd hi jy b fi kk kf l kg kh">#Utilize Stochastic Gradient Descent Optimizer<br/>opt = keras.optimizers.SGD(learning_rate=0.01, momentum=.9)</span><span id="44ff" class="kc kd hi jy b fi kk kf l kg kh">#Build model with pre-built function<br/>build_model(optimizer=opt, epochs=50, batch_size=100, callbacks=mc)</span></pre><p id="b9f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">最终模型结果:</strong></p><p id="758a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是对未知测试集进行预测的函数。测试集一直持续到最终预测，以便消除在训练模型时可能出现的任何偏差。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d102" class="kc kd hi jy b fi ke kf l kg kh">#Build a function to make predictions on unseen data<br/>def predict_new_images(test_img, test_lbls):<br/>    '''Predict saved model results on unseen test set, print classification report and plot confusion matrix.'''<br/>    <br/>    #Transpose val labels<br/>    test_lbls = test_lbls.T[[1]]<br/>    test_lbls = test_lbls.T<br/>    <br/>    #Standardize the data<br/>    test_final = test_img/255<br/>    <br/>    predictions = build_model.saved_model.predict(test_final)<br/>    predict_new_images.predictions = predictions<br/>    test_cm = confusion_matrix(y_true=test_lbls, y_pred=np.round(predictions, 0))<br/>    <br/>    print('Classification Report')<br/>    print(classification_report(test_lbls, np.round(predictions, 0), <br/>                                target_names = ['Normal (Class 0)','Pneumonia (Class 1)']))<br/>    print('-----------------------------------\n')<br/>    <br/>    plt.figure(figsize=(10, 6))<br/>    plot_confusion_matrix(cm=test_cm, <br/>                      cmap=plt.cm.Blues)<br/>    plt.savefig('images/final_model_result.png')</span></pre><p id="68ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该函数绘制了显示最终结果的混淆矩阵:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/b9217ccab198fbe77c28b2d189b3e90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRBBLO_hNsY50iC3g7Q4Ng.png"/></div></div></figure><p id="6c72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在某些方面，我是一个完美主义者，所以在未知的测试集上有 100%的准确率让我很高兴。就我个人而言，我觉得很神奇的是，在看不见的测试集中的 71 张 x 光图像中，这个卷积神经网络模型能够以 100%的准确率检测出儿科患者是否患有肺炎。就像我说的，这很酷。</p><p id="7a73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多细节和这个项目的完整笔记本，请访问我的 GitHub repo 这里:<a class="ae iu" href="https://github.com/dbarth411/dsc-mod-4-project-v2-1-online-ds-sp-000" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/dbarth 411/DSC-mod-4-project-v2-1-online-ds-sp-000</a>。</p></div></div>    
</body>
</html>