<html>
<head>
<title>Bulk loading R-trees and how to store higher dimension data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">批量加载R树以及如何存储高维数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bulk-loading-r-trees-and-how-to-store-higher-dimension-data-c7da26e4f853?source=collection_archive---------5-----------------------#2020-04-24">https://medium.com/analytics-vidhya/bulk-loading-r-trees-and-how-to-store-higher-dimension-data-c7da26e4f853?source=collection_archive---------5-----------------------#2020-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1afcb491c3500eb3522ee0dec6fe9fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxQP-nJMK4vja2lHkfkKTQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">劳拉·斯坦利拍摄</figcaption></figure><h1 id="9339" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">r树？更像是服用了类固醇的B树</h1><p id="ad10" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">r树是用于空间访问方法的树数据结构，即用于索引多维信息，例如地理坐标、矩形或多边形。</p><h2 id="ed14" class="kq iv hi bd iw kr ks kt ja ku kv kw je kd kx ky ji kh kz la jm kl lb lc jq ld bi translated">空间坐标数据</h2><p id="ae6f" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果一个对象具有至少一个捕捉其在2D或3D空间中的位置的属性，则该对象被表征为空间的。此外，空间对象可能在空间中具有几何范围。例如，我们可以说建筑物是一个空间对象，因为它在2D或3D地图中具有位置和几何范围。</p><p id="3ae6" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">多维空间中没有保持空间邻近性的总排序。因此，空间中的对象不能以一种理论上为空间查询提供最佳性能界限的方式物理地聚集到磁盘页面。</p><p id="1d9b" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">假设我们尝试使用某个一维排序键对一组二维点进行排序。无论我们使用哪一个键，按列排序皮亚诺曲线或希尔伯特排序，我们都不能保证任何一对在空间上接近的物体在总顺序上也是接近的。</p><p id="d37c" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">r树正在绘制我们的世界，这是一个真实世界的应用。它们存储空间数据对象，如商店位置和创建地图的所有其他形状。例如，从城市街区或您最喜欢的餐馆创建多边形的地理坐标。</p><h2 id="da29" class="kq iv hi bd iw kr ks kt ja ku kv kw je kd kx ky ji kh kz la jm kl lb lc jq ld bi translated">为什么这是有用的？</h2><blockquote class="lj lk ll"><p id="9817" class="js jt lm ju b jv le jx jy jz lf kb kc ln lg kf kg lo lh kj kk lp li kn ko kp hb bi translated">嘿Siri！找到离我最近的麦当劳</p></blockquote><p id="93d3" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">没错。根据对象的实际位置进行查询。</p><h1 id="adfd" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">R树中的“R”代表矩形</h1><p id="afdc" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">数据结构的关键思想是将附近的对象分组，并用矩形表示它们。<strong class="ju hj"> <em class="lm">最小外接矩形</em> </strong>或<strong class="ju hj"> <em class="lm"> MBR </em> </strong>简称。这是递归发生的。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/cbaffc81ec9c84f5b789f1b8bd09dab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rg8GGRXhkS6TcSYMko6emg.png"/></div></div></figure><p id="b194" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">因为所有对象都位于该边框内，所以不与边框相交的查询也不能与任何包含的对象相交。在叶级别，每个矩形描述一个空间对象。所有其他级别都是简单的节点指针。</p><p id="9aef" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">该树的一个约束是每个节点(除了根节点)应该至少有40%是满的，以便正确地利用磁盘空间。下面我们可以看到一个R树的例子。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/badec8f1e8b432e1a1c45009ad4ee775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wa85gISlshaiRxgfQ47Lw.png"/></div></div></figure><p id="f84a" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">为了保持R树的利用率，我们必须做四件事。</p><ol class=""><li id="2849" class="lw lx hi ju b jv le jz lf kd ly kh lz kl ma kp mb mc md me bi translated">目录节点条目的MBR所覆盖的区域应该最小化。</li><li id="5737" class="lw lx hi ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">同一级别的目录条目的MBR之间的重叠应该最小化。</li><li id="c8be" class="lw lx hi ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">应该最小化目录节点条目的MBR的边界。</li><li id="b8c0" class="lw lx hi ju b jv mf jz mg kd mh kh mi kl mj kp mb mc md me bi translated">R树节点中的平均条目数应该最大化。</li></ol><h1 id="bcb1" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">毛载</h1><p id="eae9" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">批量加载是一种以“大块”方式加载数据的方式，通常加载到数据库中。我们将使用一种叫做<strong class="ju hj"> <em class="lm">的方法排序平铺递归</em></strong><strong class="ju hj"><em class="lm">(STR)</em></strong>。</p><p id="0b6f" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">每个MBR包含由制表符(' \t ')分隔的以下内容:对象id、x-低、x-高、y-低、y-高。下面我们可以用阿瑟函数来计算一列矩形的MBR。每个矩形都存储在一个字符串中。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="2da3" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated"><strong class="ju hj"> <em class="lm"> STR </em> </strong>技术最初根据矩形的x-low对n个矩形进行排序。排序后，我们知道树中会有<strong class="ju hj"> L = ⌈n/C⌉ </strong>叶节点。属性<strong class="ju hj"> C </strong>是指每个节点的容量。特别是它可以存储多少个矩形。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="98ea" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">(排序后的)矩形然后被分成<strong class="ju hj"> ⌈SquareRoot( L)⌉ </strong>组(垂直条纹),每个组使用矩形的y-low作为关键字进行排序。这种排序的输出被打包到叶节点中，并且树是通过递归调用以自底向上的方式构建的。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="9153" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">当切片数为1时，递归结束。这意味着我们到达了根级别。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="41b6" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">让我们查询树</h1><p id="00c1" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">以深度优先的方式遍历该树，跟随与查询范围相交的条目的指针。查询算法有三个参数；查询范围q、被检索对象应该满足的谓词θ和R-树节点n。</p><p id="619a" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">如果我们在一个叶节点上，我们搜索这个节点的每个MBR来检查它们是否满足我们的查询。如果有，我们将矩形添加到答案集中。</p><p id="0d5a" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">如果我们不在叶节点上，我们搜索该节点的每个MBR以检查它们是否满足我们的查询。如果有，我们递归调用这个函数。我们使用相同的参数。唯一改变的参数是节点。我们现在正在传递当前节点所指向的节点。</p><p id="2ccf" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">简单地说，我们想要检查我们是否与查询的MBR有交集。</p><p id="75c9" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">我们希望能够做3种查询类型。<strong class="ju hj"> <em class="lm">交集，</em> </strong>用于至少有一个公共点的MBR，<strong class="ju hj"> <em class="lm">内部，</em> </strong>用于查询内部的MBR，<strong class="ju hj"> <em class="lm">包含，</em> </strong>用于包含查询的MBR的MBR。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e40a" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">每个非叶节点必须只检查交集。通过下面的例子我们可以看到，如果我们严格过滤非叶节点上的所有MBR，我们将会错过很多结果。</p><p id="d780" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">考虑一个内部查询和一个非叶节点上的步骤。黑色矩形是查询的MBR。红色是被过滤的中间节点，绿色是实际对象。如果在递归中，我们有一个严格的规则，MBR必须完全在要检查的内部，红色的不会通过过滤器，所以我们会丢失绿色的，这是一个符合标准的实际对象。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/370d5a4657259236ff41940e62882256.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*16FjiaN74puJfzBoND9UNw.png"/></div></figure><p id="6a67" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated">接受对象的标准取决于其几何形状，如下所示。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="d1ee" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="3462" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在空间数据库系统中处理空间选择的方式取决于被查询的关系R是否被索引。如果R没有被索引，我们线性扫描它并将每个对象与查询范围进行比较。如前所述，DBMS应用两步处理技术，在对象的精确几何结构之前，根据查询测试对象的MBR。如果关系被索引(例如，通过R树),那么我们可以使用它来快速找到符合过滤步骤的对象。</p><p id="2261" class="pw-post-body-paragraph js jt hi ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp hb bi translated"><strong class="ju hj">参考资料:</strong> <em class="lm">高级数据库技术</em> <em class="lm">香港大学Nikos Mamoulis讲座笔记</em></p></div></div>    
</body>
</html>