<html>
<head>
<title>DC Comics Logo Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DC漫画标志分类器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dc-comics-logo-classifier-f8a42c144c25?source=collection_archive---------11-----------------------#2019-10-15">https://medium.com/analytics-vidhya/dc-comics-logo-classifier-f8a42c144c25?source=collection_archive---------11-----------------------#2019-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="64cf" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用TensorFlow 2.0从头开始训练图像分类器</h2></div><p id="726f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将训练CNN对某个特定角色的标志进行分类。在这个例子中，我选择了五个不同的角色，分别是蝙蝠侠、超人、绿灯侠、神奇女侠和闪电侠。这将是一篇首尾相连的文章。它包括从收集数据到保存训练模型的所有步骤。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/d0ca84a73369ea2d5b5577050514c49d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWoewnA8F82eVqNPOfWvww.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">因此，在给出这个图像作为输入后，我们预测的类将是“蝙蝠侠”</figcaption></figure><p id="1523" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先决条件</p><ol class=""><li id="94aa" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">Python知识</li><li id="b506" class="kj kk hi iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">谷歌帐户:因为我们将使用谷歌Colab</li></ol><p id="fc56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以是时候把手弄脏了！</p><p id="1cc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们将使用<a class="ae kx" href="https://github.com/hardikvasa/google-images-download" rel="noopener ugc nofollow" target="_blank"> GoogleImagesDownload </a>收集数据，这是一个非常方便的python包，可以从google search下载图像。现在我们将为每个职业下载图片(这里我们有五个职业，分别是蝙蝠侠、超人、绿灯侠、神奇女侠和闪电侠)。请参考关于使用上面给定链接中提到的工具的文档。</p><p id="0eba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你找不到的话，这里有一个<a class="ae kx" href="https://chromedriver.chromium.org/downloads" rel="noopener ugc nofollow" target="_blank"> ChromeDriver </a>的链接。</p><blockquote class="ky kz la"><p id="5f02" class="ix iy lb iz b ja jb ij jc jd je im jf lc jh ji jj ld jl jm jn le jp jq jr js hb bi translated">googleimagesdownload —关键词“蝙蝠侠标志”— chromedriver chromedrvier —限制300</p></blockquote><p id="7547" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在命令提示符下运行上述语句，通过更改搜索关键字来获取每个类的图像。现在我用。jpg扩展名，因为它也下载其他扩展名的文件。我不得不手动删除一些无关的图片。然后我给这些图片重新命名。我每节课都这样做。仅用于重命名和选择。jpg文件我已经在Github库中提供了脚本。您只需要在执行路径之前处理好它们。</p><p id="4da8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我创建了一个名为data的文件夹，其中包含每个类的图像。目录的层次结构如下图所示。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lf"><img src="../Images/1e38f217eb5ad739872c14592b688ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*O8LdtiYu2eHLvGuuMOEp-w.jpeg"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">目录的层次结构</figcaption></figure><p id="91d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在把这个文件夹上传到你的google drive。将这个文件夹上传到Google Drive后，我们将从这个<a class="ae kx" href="https://colab.research.google.com" rel="noopener ugc nofollow" target="_blank">链接</a>创建一个新的colab笔记本。谷歌实验室给了我们jupyter环境。可以参考Github库中的jupyter笔记本。现在我们将从预处理开始，然后定义模型来训练它。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="668d" class="ll lm hi lh b fi ln lo l lp lq">!pip install tensorflow==2.0</span></pre><p id="e88a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在第一个单元，我们安装了TensorFlow 2.0。现在我们将导入我们需要的所有包。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="93e6" class="ll lm hi lh b fi ln lo l lp lq"><strong class="lh hj">import</strong> <strong class="lh hj">cv2</strong><br/><strong class="lh hj">import</strong> <strong class="lh hj">os</strong><br/><strong class="lh hj">import</strong> <strong class="lh hj">numpy</strong> <strong class="lh hj">as</strong> <strong class="lh hj">np</strong><br/><strong class="lh hj">import</strong> <strong class="lh hj">tensorflow</strong> <strong class="lh hj">as</strong> <strong class="lh hj">tf</strong><br/><strong class="lh hj">import</strong> <strong class="lh hj">matplotlib.pyplot</strong> <strong class="lh hj">as</strong> <strong class="lh hj">plt</strong><br/><strong class="lh hj">from</strong> <strong class="lh hj">sklearn.utils</strong> <strong class="lh hj">import</strong> shuffle<br/><strong class="lh hj">from</strong> <strong class="lh hj">tensorflow.keras</strong> <strong class="lh hj">import</strong> layers, models<br/><strong class="lh hj">from</strong> <strong class="lh hj">google.colab</strong> <strong class="lh hj">import</strong> drive<br/>drive.mount('/content/drive')</span></pre><p id="a077" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用<em class="lb"> cv2 </em>处理图像，使用<em class="lb"> os </em>处理路径。<em class="lb"> numpy </em>用于numpy数组。<em class="lb"> TensorFlow </em>将用于定义和训练模型。在这里，我使用了来自<em class="lb"> sklearn.utils </em>的shuffle来在执行训练测试分割时对图像数据进行混洗。最后，来自google.colab的drive将用于在colab笔记本上安装google drive。</p><p id="7978" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面单元格的最后一行执行后，会提供一个提供验证令牌的链接。一旦给定令牌，google drive将被安装在colab笔记本上。我定义了两个函数<em class="lb"> loadTrain() </em>和<em class="lb"> readData()，loadTrain() </em>将帮助预处理图像。图像的预处理包括调整大小、归一化和给相应的图像分配标签。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="041c" class="ll lm hi lh b fi ln lo l lp lq">validationSize = 0.2<br/>imageSize = 128<br/>numChannels = 3<br/>dataPath = "/content/drive/My Drive/comic/data"<br/>classes = os.listdir(dataPath)<br/>numClasses = len(classes)<br/>print("Number of classes are : ", classes)<br/>print("Training data Path : ",dataPath)</span></pre><p id="95cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:注意数据文件夹的路径。我把它放在漫画下面。</p><p id="419a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里<em class="lb"> validationSize </em>的给定值为0.2，所以80%是我们的训练数据，20%是测试数据。<em class="lb"> imageSize </em>将指定将输入模型的图像的尺寸。<em class="lb"> numChannels </em>被赋予值3，因为我们的图像将被读入RGB通道。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="a447" class="ll lm hi lh b fi ln lo l lp lq">data = readData(dataPath,classes,imageSize,validationSize)<br/><br/>X_train,y_train,names_train,cls_train = data.train.getData()<br/>X_test,y_test,names_test,cls_test = data.valid.getData()<br/><br/>print("Training data X : " , X_train.shape)<br/>print("Training data y : " , y_train.shape)<br/>print("Testing data X : ",X_test.shape)<br/>print("Testing data y : ",y_test.shape)</span></pre><p id="0ab3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经准备好了训练和测试数据。是时候定义我们的模型并训练它了。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="e903" class="ll lm hi lh b fi ln lo l lp lq">model = models.Sequential()<br/>model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)))<br/>model.add(layers.MaxPooling2D((2, 2)))<br/>model.add(layers.Conv2D(64, (3, 3), activation='relu'))<br/>model.add(layers.MaxPooling2D((2, 2)))<br/>model.add(layers.Conv2D(64, (3, 3), activation='relu'))<br/>model.add(layers.Flatten())<br/>model.add(layers.Dense(64, activation='relu'))<br/>model.add(layers.Dense(5, activation='softmax'))</span></pre><p id="12a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个Conv层，然后是最大池层。当我们将图像调整到128*128分辨率时，这里的输入形状是128*128*3，3是通道数。然后，我们再次有一个Conv层，其次是最大池。然后又是Conv层，现在张量在下一层变平。我们现在有一个密集层连接到我们的输出层。这里，输出层由5个单元组成，因为我们有5个分类类别。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="b133" class="ll lm hi lh b fi ln lo l lp lq">model.summary()</span></pre><p id="82a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到了我们定义的模型的概要。现在该训练了。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="84e4" class="ll lm hi lh b fi ln lo l lp lq">history = model.fit(X_train,y_train, epochs=4, <br/>                    validation_data=(X_test,y_test))</span></pre><p id="50f7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还提到了图表和准确性指标。你可以在我的笔记本上查一下。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="0aef" class="ll lm hi lh b fi ln lo l lp lq">model.save("comic.h5")</span></pre><p id="a8aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将模型保存在. h5文件中，但这是colab的本地文件，所以我们将它保存在google drive中。</p><pre class="ju jv jw jx fd lg lh li lj aw lk bi"><span id="141e" class="ll lm hi lh b fi ln lo l lp lq">!pip install -U -q PyDrive<br/><strong class="lh hj">from</strong> <strong class="lh hj">pydrive.auth</strong> <strong class="lh hj">import</strong> GoogleAuth<br/><strong class="lh hj">from</strong> <strong class="lh hj">pydrive.drive</strong> <strong class="lh hj">import</strong> GoogleDrive <br/><strong class="lh hj">from</strong> <strong class="lh hj">google.colab</strong> <strong class="lh hj">import</strong> auth <br/><strong class="lh hj">from</strong> <strong class="lh hj">oauth2client.client</strong> <strong class="lh hj">import</strong> GoogleCredentials<br/><br/>auth.authenticate_user()<br/>gauth = GoogleAuth()<br/>gauth.credentials = GoogleCredentials.get_application_default()          <br/>drive = GoogleDrive(gauth)<br/>model_file = drive.CreateFile({'title' : 'comic.h5'})                       <br/>model_file.SetContentFile('comic.h5')                       <br/>model_file.Upload()<br/>drive.CreateFile({'id': model_file.get('id')})</span></pre><p id="2bfd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以现在我们训练好的模型会保存到google drive。它可以很容易地从google drive下载。</p><p id="d656" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了进行分类，我编写了一个名为classify.py的脚本。在这里，我们将把图像的路径作为CLI参数传递。我们的输出将是预测类。我们实际上得到每一类的概率，我们将选择一个最大的。有时模型会做出错误的分类。正在努力提高准确率，现在准确率是80%。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lr"><img src="../Images/3f79a46dc9c834dbb5107002836efe59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDUQ_WdLAl88FNNz2acwWw.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">这里预测了上面标志的阶级是<strong class="bd ls">蝙蝠侠</strong>。</figcaption></figure><p id="60d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个<a class="ae kx" href="https://github.com/aniruddha414/DC-comics-logo-classifier" rel="noopener ugc nofollow" target="_blank">链接</a>到我的Github repo。</p><p id="7e11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我将尝试写下我在云平台上将它部署为API的经历。您还可以通过将model转换为lite版本并将其保存到来将其部署在移动设备中。tflite文件，有关详细信息，请参考TensorFlow Lite文档。请随时在LinkedIn、Github和Instagram上与我联系。让我知道任何即兴创作。</p><p id="5a1a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">谢谢！</strong></p></div></div>    
</body>
</html>