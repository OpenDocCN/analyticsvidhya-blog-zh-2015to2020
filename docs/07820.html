<html>
<head>
<title>Object-Oriented Programming in Python part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的面向对象编程第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-oriented-programming-in-python-part1-309f64ebbd40?source=collection_archive---------28-----------------------#2020-07-08">https://medium.com/analytics-vidhya/object-oriented-programming-in-python-part1-309f64ebbd40?source=collection_archive---------28-----------------------#2020-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="54e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2020年7月3日</p><p id="6198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"># <strong class="ih hj"> Blog16 </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e5a420464f2940aa6953b44c4a701ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZVf_qBFSgE2YGDEf.png"/></div></div></figure><p id="6ebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都有意或无意地使用过面向对象编程。如果你正在收集成为数据科学家的技能，那么OOP也是一个需要学习的重要课题。</p><p id="87d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你想知道我们使用的著名软件包scikit-learn是如何工作的吗(它是如何构建的)？？？</p><p id="736e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="3348" class="ju jv hi jq b fi jw jx l jy jz">import pandas as pd <br/>pd.read_csv()</span></pre><p id="4dba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是pandas，这个read_csv()是从哪里来的，不需要我们自己创建这样的函数就可以使用吗？？？</p><p id="a3d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么这个博客是给你的。</p><p id="8d24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始吧。欢迎:)</p><p id="711e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们实际上使用哎呀的概念</p><p id="1f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么OOP是什么呢？？</p><h1 id="1ed5" class="ka jv hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">面向对象编程</h1><p id="f857" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">面向对象编程是一种使用类和对象编写程序的风格。</p><p id="984f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">面向对象编程允许您创建大型的模块化程序，这些程序可以很容易地随着时间的推移而扩展。</p><p id="176c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">面向对象的程序对最终用户隐藏了实现。当你用Scikit-learn训练一个机器学习算法时，你不需要知道任何关于算法如何工作或者它们是如何编码的。您可以直接关注建模。如果实现发生了变化，作为软件包的用户，您可能永远也不会发现。</p><p id="7651" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python包不需要使用面向对象的编程。您可以简单地拥有一个包含一组函数的Python模块。然而，大多数(如果不是全部)流行的Python包都利用了面向对象编程，因为:</p><ol class=""><li id="2a44" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated">面向对象的程序相对容易扩展，尤其是因为继承</li><li id="6055" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated">面向对象的程序对用户隐藏了功能。</li></ol><p id="4542" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象是由属性和方法定义的。</p><p id="3ebb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">把物体想象成现实世界中存在的东西。\例如，如果我们以餐馆为例</p><ul class=""><li id="787c" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lq li lj lk bi translated">餐馆本身就是客体</li><li id="beb1" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lq li lj lk bi translated">食物菜肴是客体</li><li id="525b" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lq li lj lk bi translated">服务员也是对象</li></ul><p id="ccdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，如果服务员是一个对象，它的属性(特征)和方法(动作)是什么？？？</p><p id="e7a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务员的属性是姓名、地址、电话号码、薪水</p><p id="aeee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务员的工作方式有点菜、加薪和上菜。</p><p id="a1f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了对象，但是两个对象可能具有不同的值，这意味着有两个对象，但是属性和方法是相同的，这意味着两个对象具有相同的属性类型，但是具有不同的值，这意味着两个对象具有相同的蓝图。</p><p id="8cd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以一个对象的蓝图叫做类。使用这个蓝图，我们可以创建许多对象。</p><p id="86d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们来看看类的代码。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="d00e" class="ju jv hi jq b fi jw jx l jy jz">class Waiter:<br/>    """The waiter class represents an type of person who takes order and serve dishes in a restaurant<br/>    """<br/><br/>    def __init__(self, name, address, height, salary):<br/>        """Method for initializing a Pants object<br/><br/>        Args: <br/>            name (str)<br/>            address (str)<br/>            height (int)<br/>            salary (float)<br/><br/>        Attributes:<br/>            name (str): name of waiter object<br/>            address (str): address of a waiter object<br/>            height (int): height of a waiter object<br/>            salary (float): salary of a waiter object<br/>        """<br/><br/>        self.name = name<br/>        self.address = address<br/>        self.height = height<br/>        self.salary = salary<br/><br/>    def hike_salary(self, hike_percent):<br/>        """The hike_salary method changes the salary attribute of a waiter object<br/><br/>        Args: <br/>            hike_percent (float): the new salary of the waiter object<br/><br/>        Returns: None<br/><br/>        """<br/>        sal = self.salary + (hike_percent*self_salary)<br/>        self.salary = sal</span></pre><p id="ac34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是自我？？我在代码中多次使用self。</p><p id="5bf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它用于将值传递给属性，并区分这两个对象。</p><p id="795c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Self告诉Python在计算机内存的什么地方寻找a对象。然后Python改变了那个对象的值。当您调用特定的方法时，self被隐式传入。</p><p id="64f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你注意到看起来和函数相似的方法了吗？？函数和方法看起来非常相似。它们都使用def关键字。它们也有输入和返回输出。区别在于方法在类的内部，而函数在类的外部。</p><p id="b6f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码讲述了OOPs以及文档字符串的使用。</p><h1 id="3500" class="ka jv hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">邓德方法</h1><p id="14d7" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">Python中的Dunder或magic方法是在方法名中有两个前缀和后缀下划线的方法。邓德在这里的意思是“双下(下划线)”。这些通常用于运算符重载。等等！！你看到上面代码中的那些了吗？？没错，__init__是dunder方法，它覆盖了默认行为。</p><p id="a7a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看高斯分布类，并了解如何使用邓德。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="1951" class="ju jv hi jq b fi jw jx l jy jz">class Gaussian():<br/>    """ Gaussian distribution class for calculating and <br/>    visualizing a Gaussian distribution.<br/>    """<br/>    def __init__(self, mu = 0, sigma = 1):<br/>        <br/>        self.mean = mu<br/>        self.stdev = sigma<br/>        self.data = []<br/>    <br/>    def calculate_mean(self):<br/>        self.mean = 1.0 * sum(self.data) /len(self.data)<br/>        return self.mean<br/><br/>    def calculate_stdev(self, sample=True):<br/>        if sample:<br/>            n = len(self.data) - 1<br/>        else:<br/>            n = len(self.data)<br/>        mean = self.mean<br/>        sigma = 0<br/>        for d in self.data:<br/>            sigma += (d - mean) ** 2<br/>        sigma = math.sqrt(sigma / n)<br/>        self.stdev = sigma        <br/>        return self.stdev</span></pre><p id="febb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如何添加两个高斯分布，如果你看到数学解释，这似乎很容易，但如何在代码中做到这一点，如果你尝试以下你会得到错误。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="1bd6" class="ju jv hi jq b fi jw jx l jy jz">gaus_a + gaus_b = Yes we get error!!!</span></pre><p id="150c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是邓德方法。</p><p id="855d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python类中有一个名为__add__ method的dunder，它将帮助添加自定义对象的两个实例。这意味着我们可以通过修改或拒绝__add__方法来控制两个对象相加的结果。</p><p id="f283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您将这段代码添加到上面的Gaussian类中，就会出现一些奇迹。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="8d1a" class="ju jv hi jq b fi jw jx l jy jz">def __add__(self, other): <br/>    result = Gaussian() <br/>    result.mean = self.mean + other.mean <br/>    result.stdev = math.sqrt(self.stdev**2 + other.stdev**2) <br/>    return result</span></pre><p id="a1d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在之前给你错误的代码可以正常工作了:)</p><p id="9736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样我们就可以重写代码并改变所有的默认行为，这不是很有用吗？？？</p><h1 id="37ab" class="ka jv hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">遗产</h1><p id="af4b" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在餐馆的例子中，我们看到food dish是一个对象，这意味着所有其他的食物都有单独的类，但是为什么要麻烦地为所有的东西建立单独的类呢，有没有更好的方法呢？？？</p><p id="7a5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以继承的概念在这里很有帮助。</p><p id="1f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以有一个名为food dish的通用类，拥有所有食物项目共有的所有属性，并为不同的食物继承该类。现在，如果你想把这个属性添加到所有叫做季节性的食物中，而不是添加到所有的食物中，我们可以把它添加到主根类中，所有其他的类都会继承它。这样省时省力很多。</p><p id="45f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要继承一个类，我们需要编写一个通用的主类，并在子类的括号中使用这个类名。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="7a6d" class="ju jv hi jq b fi jw jx l jy jz">class Gaussian(Distribution):</span></pre><p id="d3db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分布是主类，高斯(子)使用分布类。</p><p id="a115" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们已经看到了OOP的所有基础知识。记得在博客的开始我说过著名的包将使用OOP概念来构建包，所以除非你应用你的知识去使用OOP，否则对OOP的学习是不完整的。</p><p id="ee4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此在下一篇博客中，我们将看到如何使用OOP概念用python创建一个包，并将其上传到PyPI，之后您就可以使用使用pip install创建的包了。</p><p id="2f52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">学分:</strong> Udacity课程。</p><p id="b2b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本博客第二部分将于2020年7月11日在<a class="ae lr" href="https://kirankamath.netlify.app/blog/oop-in-python-part2-make-a-python-package" rel="noopener ugc nofollow" target="_blank">这里</a>发表。</p><p id="2867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读本博客:)</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="38fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lz">最初发布于</em><a class="ae lr" href="https://kirankamath.netlify.app/blog/object-oriented-programming-in-python-part1/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://kirankamath . netlify . app</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>