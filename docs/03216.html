<html>
<head>
<title>Learn about loops in R by simulating Delirious Ducks.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过模拟发狂的鸭子来学习R中的循环。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/learn-about-loops-in-r-by-simulating-delirious-ducks-1bc7fafd16ce?source=collection_archive---------21-----------------------#2020-01-20">https://medium.com/analytics-vidhya/learn-about-loops-in-r-by-simulating-delirious-ducks-1bc7fafd16ce?source=collection_archive---------21-----------------------#2020-01-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bd93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天下午我在参观538时，遇到了这个奇妙的问题，题目是“你能追踪疯狂的鸭子吗？”。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/05851380aa90474aebe1f6907b68f4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g9HLX4-zFUd8Pghq.jpg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">岩石上的鸭子选择下一步行动。</figcaption></figure><p id="921d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，在一个池塘里有一个正方形的3×3排列的石头。两只鸭子从中间的岩石出发，每分钟独立地游向相邻的岩石，或者向上，或者向下，或者向左，或者向右，但从不斜着游。平均来说，他们要走多长时间才能在同一块岩石上再次相遇？</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="3fc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我开始想象这些岩石，左上角的岩石是#1，右边的是#2，依此类推，直到我到达右下角的岩石#9。鸭子从中间的岩石开始，所以那是岩石#5。从那里他们有四个去哪里的选择。当在边缘时，他们可能只有两个(如果鸭子在角落里)或三个选择(如岩石#8，鸭子可以游到岩石#7、#5或#9)。</p><p id="e496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为这是一个很好的方法，可以通过编写几个循环在R中处理。我仔细考虑了几个选项，最后选择了一个我认为非常清晰简单，甚至可能是r中循环(一个长期流行的话题)的一个很好的演示。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="5c5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">采样</strong></p><p id="bc03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上每次鸭子起飞的时候，就好像是在抛硬币或扔骰子。一枚硬币可能只有两种结果，但对于我们的鸭子，有时有四种，有时三种，有时两种。我们需要根据鸭子的位置生成一个随机数。在R中生成随机数有很多种方法。我使用函数sample()，因为我可以告诉R我想要一组数中的一个数。当我在岩石#5上时，我希望它从岩石#2、#4、#6或#8中随机选择下一块岩石。当我在岩石#1上时，我希望它从岩石#2和#4中随机选择一块岩石。因此，对于每个状态，我写:</p><pre class="jf jg jh ji fd kb kc kd ke aw kf bi"><span id="8f56" class="kg kh hi kc b fi ki kj l kk kl">sample(c(2,4), 1)</span></pre><p id="982c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当鸭子在1号岩石上时。我将不得不重复这样做，所以我们需要一个循环。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="da57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">概述</strong></p><p id="bfeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从概述我的想法开始，然后由内向外构建。我将为鸭子可能在的九块石头中的每一块建立一个if语句。首先，我决定建立一个向量来绘制鸭子游泳的位置。为了确保循环结束，我创建了一个名为minute的变量，我简单地将它初始化为1，然后每当鸭子改变位置时就加1。我会让这个循环在50分钟以下运行，让鸭子游一会儿。我还初始化了一个名为duck的向量，它是鸭子所在位置的向量。因此，我会在每次循环时将鸭子的位置连接到鸭子向量上。我想象分钟=0，位置= 5；接着是分钟=1，位置=2，等等…点击直到我收集了一些数据:</p><pre class="jf jg jh ji fd kb kc kd ke aw kf bi"><span id="e3c3" class="kg kh hi kc b fi ki kj l kk kl">minute&lt;-1<br/>Duck&lt;-5</span><span id="8993" class="kg kh hi kc b fi km kj l kk kl">while (minute&lt;50){<br/>  if (Duck[minute] == 1) {<br/>    Duck&lt;-c(Duck,sample(c(2,4), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 2) {<br/>    Duck&lt;-c(Duck,sample(c(1,3,5), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 3) {<br/>    Duck&lt;-c(Duck,sample(c(2,6), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 4) {<br/>    Duck&lt;-c(Duck,sample(c(1,5,7), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 5) {<br/>    Duck&lt;-c(Duck,sample(c(2,4,6,8), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 6) {<br/>    Duck&lt;-c(Duck,sample(c(3,5,9), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 7) {<br/>    Duck&lt;-c(Duck,sample(c(4,8), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 8) {<br/>    Duck&lt;-c(Duck,sample(c(5,7,9), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 9) {<br/>    Duck&lt;-c(Duck,sample(c(6,8), 1))<br/>    minute&lt;-minute+1}<br/>}</span></pre><p id="b359" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这最终产生了一个名为50个数字的鸭子的向量，从我初始化它的数字5开始，看起来像5，8，5，2，1，4，5，6…从这里你可以保留这个向量，对你的第二只鸭子重复这个过程，然后检查它们的数字匹配的第一个实例。因此，如果我运行鸭子#2的模拟，它是5，1，4，2，我会砍掉最初的5，并看到在第1分钟，鸭子1在岩石8上，鸭子2在岩石1上，接着是岩石5和4，然后是岩石2和2。三分钟后的比赛。</p><p id="4626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我所做的只是将第一次鸭子的游程放入一个名为A的变量中，然后再执行一次该过程，并将该游程称为B:</p><pre class="jf jg jh ji fd kb kc kd ke aw kf bi"><span id="cd20" class="kg kh hi kc b fi ki kj l kk kl">A&lt;-Duck</span><span id="0c0c" class="kg kh hi kc b fi km kj l kk kl">minute&lt;-1<br/>Duck&lt;-5</span><span id="f09a" class="kg kh hi kc b fi km kj l kk kl">while (minute&lt;50)....etc..etc...etc...<br/>B&lt;-Duck</span></pre><p id="1316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将两列绑定在一起，去掉第一行，然后检查哪一行是第一个匹配的行:</p><pre class="jf jg jh ji fd kb kc kd ke aw kf bi"><span id="a5a0" class="kg kh hi kc b fi ki kj l kk kl">bound&lt;-cbind(A,B)<br/>bound&lt;-bound[-1,]<br/>Durations&lt;-c(Durations, min(which(bound[,1]==bound[,2])))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kn"><img src="../Images/67005125ebb18ba44d89a2a3c98a5ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*DeuU7YMphL5NqGT0XHoF9Q.png"/></div></figure><p id="6433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在上面的跑步中看到，我在第10分钟进行了第一场比赛。</p><p id="2ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了得到一个好的平均值，我决定将这个过程运行5000次。每次循环的时候，我会把鸭子在同一块石头上相遇的持续时间发送给一个向量，就像上面一样，我会在每次循环的时候连接这个向量。以下是完整的代码:</p><pre class="jf jg jh ji fd kb kc kd ke aw kf bi"><span id="1b96" class="kg kh hi kc b fi ki kj l kk kl">i&lt;-1<br/>Durations&lt;-vector()</span><span id="6651" class="kg kh hi kc b fi km kj l kk kl">for (i in 1:5000){<br/>minute&lt;-1<br/>Duck&lt;-5</span><span id="be3b" class="kg kh hi kc b fi km kj l kk kl">while (minute&lt;50){<br/>  if (Duck[minute] == 1) {<br/>    Duck&lt;-c(Duck,sample(c(2,4), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 2) {<br/>    Duck&lt;-c(Duck,sample(c(1,3,5), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 3) {<br/>    Duck&lt;-c(Duck,sample(c(2,6), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 4) {<br/>    Duck&lt;-c(Duck,sample(c(1,5,7), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 5) {<br/>    Duck&lt;-c(Duck,sample(c(2,4,6,8), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 6) {<br/>    Duck&lt;-c(Duck,sample(c(3,5,9), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 7) {<br/>    Duck&lt;-c(Duck,sample(c(4,8), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 8) {<br/>    Duck&lt;-c(Duck,sample(c(5,7,9), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 9) {<br/>    Duck&lt;-c(Duck,sample(c(6,8), 1))<br/>    minute&lt;-minute+1}<br/>}</span><span id="5cd0" class="kg kh hi kc b fi km kj l kk kl">A&lt;-Duck</span><span id="149e" class="kg kh hi kc b fi km kj l kk kl">minute&lt;-1<br/>Duck&lt;-5</span><span id="b3c1" class="kg kh hi kc b fi km kj l kk kl">while (minute&lt;50){<br/>  if (Duck[minute] == 1) {<br/>    Duck&lt;-c(Duck,sample(c(2,4), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 2) {<br/>    Duck&lt;-c(Duck,sample(c(1,3,5), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 3) {<br/>    Duck&lt;-c(Duck,sample(c(2,6), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 4) {<br/>    Duck&lt;-c(Duck,sample(c(1,5,7), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 5) {<br/>    Duck&lt;-c(Duck,sample(c(2,4,6,8), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 6) {<br/>    Duck&lt;-c(Duck,sample(c(3,5,9), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 7) {<br/>    Duck&lt;-c(Duck,sample(c(4,8), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 8) {<br/>    Duck&lt;-c(Duck,sample(c(5,7,9), 1))<br/>    minute&lt;-minute+1}<br/>  else if (Duck[minute] == 9) {<br/>    Duck&lt;-c(Duck,sample(c(6,8), 1))<br/>    minute&lt;-minute+1}<br/>}</span><span id="d148" class="kg kh hi kc b fi km kj l kk kl">B&lt;-Duck</span><span id="875c" class="kg kh hi kc b fi km kj l kk kl">bound&lt;-cbind(A,B)<br/>bound&lt;-bound[-1,]<br/>Durations&lt;-c(Durations, min(which(bound[,1]==bound[,2])))<br/>i&lt;-i+1<br/>}</span><span id="d9fc" class="kg kh hi kc b fi km kj l kk kl">#DONE!!!!</span></pre><p id="0521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我希望可视化该过程，并获得5000次运行的平均值。对于这一轮，我得到的平均值为4.8，直方图如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ko"><img src="../Images/abcd596a7e5285f870783efba682ad76.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*zSxYQmDra8jdrJjGLirgQw.png"/></div></figure><p id="ff6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题描述告诉你额外的学分是为三只或更多的鸭子建模。我希望通过了解我是如何从内向外构建循环过程的，你将能够轻松地进行自己的修改，并弄清楚三只或四只鸭子的行为。计算五只或更多的鸭子是没有用的，因为从中间的岩石只有四个选项，因此每次长度都是1。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="0e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">循环可能很难写。从一个最需要的小流程开始。想想地球在绕着太阳转的同时是如何自转的。如果你愿意的话，可以在年循环中嵌套一个日循环。在进行过程中测试您的循环，以确保组成循环的各个部分正常工作。</p></div></div>    
</body>
</html>