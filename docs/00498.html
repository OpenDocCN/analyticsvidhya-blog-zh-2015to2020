<html>
<head>
<title>Understanding Bloom Filter Part-I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解布隆过滤器第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-bloom-filter-part-i-85459df3ae37?source=collection_archive---------2-----------------------#2019-07-10">https://medium.com/analytics-vidhya/understanding-bloom-filter-part-i-85459df3ae37?source=collection_archive---------2-----------------------#2019-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/58014b5f6ea728bab3dce16d4b97f18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Atw61qgB47mAhpPRu7LDKA.png"/></div></div></figure><div class=""/><p id="85ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一篇由两部分组成的文章。在第一部分中，我们将尝试开发布鲁姆过滤器背后的直觉。在第二部分中，我们将使用第一部分中的知识来构建Bloom Filter的数据结构。</p><h2 id="a558" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">动机</h2><p id="8a50" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在一个相当复杂的分布式系统中，我们遇到的问题可以归结为在一个集合中寻找一个元素的存在。Bloom Filter是一种有助于解决这个问题的数据结构。这是一个来自维基百科的布隆过滤器的应用。<br/> <em class="ko"> Akamai注意到大约75%的网络下载只下载了一次。他们认为在第二次下载时缓存web下载比第一次更有利。他们使用了布鲁姆过滤器来解决这个问题。有了Bloom Filter，您可以进行缓存检查，而不必存储内容，甚至内容的散列。</em></p><h2 id="0928" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">本文的使用案例</h2><p id="82d1" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">为了本文的目的，让我们定义一个样例用例。</p><blockquote class="kp"><p id="d862" class="kq kr ht bd ks kt ku kv kw kx ky jn dx translated">用户将输入一个建议的密码，我们的系统应该会快速响应，无论建议的密码是可接受的还是不可接受的。</p></blockquote><p id="678d" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">第一个想法可能是使用正则表达式来符合某些规则。这可以帮助我们给密码一些结构。仍然有一些不可接受的密码太容易被猜到。<br/>例如，这些可能是在一种语言的字典里的单词。因此，为了这篇文章，我们可以假设有一个不可接受的密码定义列表。</p><p id="88f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ko">因此，该要求转化为维护不可接受密码的数据库，并快速检查建议的密码是否在不可接受密码的数据库中。</em></p><p id="b355" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么不接受密码？为什么不维护可接受的密码？可能密码的范围太大，难以维护。例如，如果我们简单地将密码视为长度为n的字符串，那么这个集合的大小是52^N(taking(只有大写字母和小写字母)，</p><h2 id="6754" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">正式化要求</h2><p id="0a60" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">让我们将需求正式化。<br/> <strong class="is hu"> U </strong>代表所有可能的密码。<br/> <strong class="is hu"> S ⊂ U </strong>代表一组不可接受的密码。<br/>假设<strong class="is hu"> X </strong>是该设置中的建议密码。</p><p id="3313" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，要回答<strong class="is hu"> X </strong>是否是不可接受的密码，我们必须回答对<strong class="is hu"> X ∈ U </strong>的查询，是否<strong class="is hu"> X ∈ S </strong>？</p><p id="71d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们想建立一个数据结构或散列方案，它能快速回答这些查询。</p><h1 id="b105" class="le jp ht bd jq lf lg lh ju li lj lk jy ll lm ln kb lo lp lq ke lr ls lt kh lu bi translated">布鲁姆过滤器背后的直觉</h1><h2 id="5f1f" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">传统方法</h2><p id="0987" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">让我们首先来看看传统的哈希方案(称为链式哈希)在这种情况下是如何工作的。<br/>为了维护集合<strong class="is hu"> S </strong>，我们将使用大小为<strong class="is hu"> n </strong>的散列表<strong class="is hu"> H </strong>。在链式哈希中，这个表<strong class="is hu"> H </strong>是一个大小为<strong class="is hu"> n </strong>的链表数组，<strong class="is hu">H【I】</strong>是那些哈希值恰好为<strong class="is hu"> i </strong>的元素(不可接受的密码)的链表。<br/>我们将使用一个散列函数<strong class="is hu"> h(X) </strong>，它将<strong class="is hu"> U </strong>中的元素映射到<strong class="is hu"> H </strong>中的元素。我们将假设<strong class="is hu"> h(X) </strong>映射到一个随机索引。此外，我们将假设这个随机映射独立于所有其他散列。因此,<strong class="is hu"> h(X) </strong>映射到哪里与宇宙中任何其他元素映射到哪里无关。</p><p id="e32c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，要将一个元素插入到这个子集<strong class="is hu"> S </strong>中，我们只需找到它的散列值索引，然后将该元素添加到链表中的特定索引处。</p><p id="f9e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要进行查询，我们只需转到哈希值索引，并查看链表来检查它是否在那里。</p><blockquote class="lv lw lx"><p id="8d5d" class="iq ir ko is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">现在，如果你把这个散列表的索引想象成容器，把<strong class="is hu"> S </strong>中的元素想象成球，那么这个散列函数所做的就是，把这些球分配到随机的容器中。我们稍后将使用这个类比来计算单个箱子中最大球数的概率，也就是最大负荷。</p></blockquote><p id="544a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在我们继续之前，有一点符号是有用的。<br/>这个集合<strong class="is hu"> U </strong>很大，我们用大写<strong class="is hu"> N </strong>来表示它的大小。<br/>哈希表的大小为<strong class="is hu"> n </strong>。<br/>我们将使用<strong class="is hu"> m </strong>来表示我们正在维护的这个数据库<strong class="is hu"> S </strong>的大小。通常我们的哈希表大小至少是我们维护的数据库的大小。总结一下</p><blockquote class="kp"><p id="7d2a" class="kq kr ht bd ks kt ku kv kw kx ky jn dx translated"><strong class="ak">| U | = N&gt;T65】| H | = N≥| S | = m</strong></p></blockquote><p id="88bd" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">所以<strong class="is hu"> n </strong>的大小至少是<strong class="is hu"> m </strong>，我们的目标当然是尽量保持这个数据库不会比m大太多。</p><h2 id="9b89" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">时间分析</h2><p id="b3c1" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们来看一下查询时间。我们需要多长时间来回答一个表格的问题？<br/>是子集<strong class="is hu"> S </strong>中的<strong class="is hu"> X </strong>？。<br/>现在，为了回答这个查询，我们要做的是查看索引<strong class="is hu"> i </strong>处的哈希表，也就是H<strong class="is hu">【I】</strong>，然后我们必须遍历整个链表，检查那个链表中是否有<strong class="is hu"> X </strong>。<br/>所以，时间和这个链表的大小成正比。</p><blockquote class="lv lw lx"><p id="2975" class="iq ir ko is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">这个链表有多大？ <br/>记得鲍尔斯在以宾比喻。这类似于寻找最大负载。大致最大负载为<strong class="is hu"> O(log(n)) </strong>，概率较大。我们可以有更紧的界限，但为了简单起见，我们选择了一个宽松的界限。你可以在这里阅读更多信息<a class="ae mb" href="https://en.wikipedia.org/wiki/Balls_into_bins_problem" rel="noopener ugc nofollow" target="_blank">。当然，在最坏的情况下，它可能是<strong class="is hu"> O(n) </strong>，但这是一个不太可能的事件。</a></p></blockquote><p id="a661" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们回答一个查询所花费的时间与哈希值处的负载大小成正比。在高概率下，最大负载将是<strong class="is hu"> O(log(n)) </strong>，这意味着最坏情况下的查询时间，在高概率下将是<strong class="is hu"> O(log(n)) </strong>。现在，当<strong class="is hu"> n </strong>很大时，那么<strong class="is hu"> O(log(n)) </strong>对我们来说可能太慢了。</p><h2 id="3a96" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">缩短查询时间</h2><p id="e57b" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">那么如何才能实现更快的查询时间呢？嗯，一种方法是增加哈希表的大小。为了将这个最大负载从<strong class="is hu"> O(log(n)) </strong>减少到顺序<strong class="is hu"> O(1) </strong>，我们可以将哈希表的大小从<strong class="is hu"> O(m) </strong>增加到<strong class="is hu"> O(m ) </strong>。现在，这是一个很大的代价。</p><p id="7d7c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们看看是否有更简单的方法来减少查询时间。</p><h2 id="b4e3" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">两种选择的力量</h2><p id="4976" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们现在要做的不是使用单个哈希函数，而是选择一对哈希函数<strong class="is hu"> h1 </strong>和<strong class="is hu"> h2，</strong>每个哈希函数都将可能密码的<strong class="is hu"> U </strong>元素映射到大小为<strong class="is hu"> n </strong>的哈希表中。现在我们将假设这些散列函数是随机的，因此可能密码的总体中的每个元素X映射到散列表的一个随机元素。<strong class="is hu"> h1(X) </strong>是随机的，<strong class="is hu"> h2(X) </strong>是随机的，并且这些是彼此独立的，并且独立于其他散列值。</p><p id="041f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个问题是，我们如何将一个元素，一个可能的密码，插入到我们的不可接受密码字典中？ <br/>让我们假设在我们的哈希表中，我们也在每个索引处维护链表的大小。我们首先要做的是计算这两个哈希值<strong class="is hu"> h1(X) </strong>和<strong class="is hu"> h2(X) </strong>。然后通过比较它们的大小来确定哪一个负载最小。然后，我们可以将<strong class="is hu"> X </strong>添加到适当的链表中，并增加该链表的大小。因此，这一切都可以在插入的时间内完成。</p><p id="bdf7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ko">下一个问题是，我们如何查询一个元素</em> <strong class="is hu"> <em class="ko"> Y </em> </strong> <em class="ko">(建议密码)是否在我们的不可接受密码字典中？</em> <br/>我们一开始同样是做加法。我们计算两个散列值<strong class="is hu"> h1(Y) </strong>和<strong class="is hu"> h2(Y) </strong>。这是<strong class="is hu"> Y </strong>的两个可能位置。我们无法确定它可能在这两个地点中的哪一个。<br/>我们在<strong class="is hu"> h1(Y) </strong>和<strong class="is hu"> h2(Y) </strong>检查链表。我们在这两个链表中寻找<strong class="is hu"> Y </strong>。如果它在这些链表中的任何一个中，那么我们知道<strong class="is hu"> Y </strong>在字典中，否则<strong class="is hu"> Y </strong>从未被插入到不可接受密码的字典中。</p><p id="ec48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么做一次查询需要多长时间呢？</p><p id="815d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询时间现在取决于<strong class="is hu"> h1(Y) </strong>和<strong class="is hu"> h2(Y) </strong>的负载。<br/>因此，如果我们有最大负载的上限，那么查询时间就是最大负载的两倍。现在，如果<strong class="is hu"> m </strong>等于<strong class="is hu"> n </strong>，那么我们的不可接受密码字典的大小和我们的哈希表的大小是相同的<br/>，那么查询时间将是<strong class="is hu"> O(log(log(n)) </strong>。在这种情况下，只需从一个哈希函数更改为一对哈希函数，我们的查询时间就会从<strong class="is hu"> O(log(n)) </strong>大幅减少到<strong class="is hu"> O(log(log(n))) </strong>，并且在空间方面没有额外的开销。这是一个很大的增益，因为log log n非常小，即使对于非常大的n也是如此。所以这几乎就像<strong class="is hu"> O(1) </strong>一样，非常接近，是一个非常小的量。</p><p id="a593" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看到这个结果，你可能会说，“<em class="ko">好吧，为什么要选择两个随机哈希函数。让我们选择三个随机散列函数，也许我们会得到</em><strong class="is hu"><em class="ko">log log n</em></strong><em class="ko">。</em>”</p><p id="08d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，原来大的收获是从一个到两个，之后就没多大收获了。特别是，如果你选择了<strong class="is hu"> d个随机散列函数</strong>并将第<strong class="is hu">个元素分配给所有这些链表中负载最小的，那么最大负载将是<strong class="is hu"> O(log log(n)/log(d)) </strong>，其中<strong class="is hu"> d </strong>至少为-2。所以用<strong class="is hu"> d </strong>提升很小。</strong></p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="fab3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们终于可以描述出现在<a class="ae mb" rel="noopener" href="/p/79b0e23ed174">第二部分</a>中的布隆过滤器了。</p></div></div>    
</body>
</html>