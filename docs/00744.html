<html>
<head>
<title>Predicting Left Ventricular End Diastolic Volume using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用机器学习预测左心室舒张末期容积</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-left-ventricular-end-diastolic-volume-d7d3059d6be0?source=collection_archive---------15-----------------------#2019-09-02">https://medium.com/analytics-vidhya/predicting-left-ventricular-end-diastolic-volume-d7d3059d6be0?source=collection_archive---------15-----------------------#2019-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ecc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我沉浸于大会的数据科学期间，我参与了许多不同的项目，从预测爱荷华州埃姆斯的房价到用神经网络对手写数字进行分类。</p><p id="06dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据是我的激情所在，但我的目标是让数据为每个人服务。我在这个项目中考虑到了人的因素:我想要一个能以积极的方式影响人们的想法，但也想要一个我能找到数据的想法。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="8d72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，我得到了一组数据，包括心脏病患者的心脏核磁共振数据。别担心，数据在我收到之前就被取消识别了。</p><p id="0c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数据中的所有48个特征中，最突出的是左心室舒张末期容积(从这里开始是EDV)，这是左心室完成充血时的容积。左心室(LV)是心脏的腔室，负责将氧合血推入体循环。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/f296a5072ec6c16ec80f926ccc98eb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*uGrqPr4iptRVxOOisg-88w.gif"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">心脏跳动的GIF插图。心脏是镜像的，所以左心室在右侧。</figcaption></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="ad17" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated"><strong class="ak">问题</strong></h2><p id="011b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">左心室不能像气球一样膨胀:为了增加体积，肌肉壁必须变薄。一旦肌肉壁变薄，左心室就不能有效地泵血，这将导致一系列的问题。左心室的功能也是整体心脏功能的指标。如果一个模型可以准确预测EDV，它可以帮助心脏病学家确定谁最需要帮助，并提高医疗保健系统的效率。</p><h2 id="25cc" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated"><strong class="ak">预处理</strong></h2><p id="2872" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在我能够直接进入建模之前，我必须处理数据。对我来说幸运的是，数据是<em class="kw">非常</em>干净的:只有四列有重要的缺失值。我花了很多时间阅读关于数据插补的内容，因为这是一个非常敏感的话题:如果你做得不正确，你可能会极大地扭曲你的数据(这是未来博客文章的主题)。我最终使用了fancyimpute的KNN估算器，因为缺失的数据是离散的和有序的。</p><p id="76a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了输入数据之外，我只需要确保序数文本在数字范围内。</p><p id="f214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的数据有48个特征，包括目标变量EDV。这些特征中的34个表示心脏的17个部分中的每一个中的划痕或局部缺血(血流减少)。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es kx"><img src="../Images/8b33468bfe5abd6ea1e41ae822ae091c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*DvAHN5KNZy-Cyd1_3S9hVg.jpeg"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">克雷格·哈金博士提供的案例，Radiopaedia.org，rID: 68467</figcaption></figure><p id="700b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为有太多的功能，我想看看能否通过功能工程减少它们的数量。使用如上图，我基于环形层和编号部分规划了交互列。然而，我创建交互列的能力受到了限制，因为我的绝大多数值都是0，表示没有损坏。也就是说，我能够创建三个“summary”列，包括基底、中间和间隔区域的总和(分别是心室的顶部、中间和底部)。一旦我做到了这一点，我就可以开始建模了。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="18d0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated"><strong class="ak">建模</strong></h2><pre class="jl jm jn jo fd ky kz la lb aw lc bi"><span id="8780" class="jw jx hi kz b fi ld le l lf lg"><strong class="kz hj">import</strong> <strong class="kz hj">pandas</strong>                <strong class="kz hj">as</strong> <strong class="kz hj">pd</strong><br/><strong class="kz hj">import</strong> <strong class="kz hj">numpy</strong>                 <strong class="kz hj">as</strong> <strong class="kz hj">np</strong><br/><strong class="kz hj">import</strong> <strong class="kz hj">matplotlib.pyplot</strong>     <strong class="kz hj">as</strong> <strong class="kz hj">plt</strong><br/><strong class="kz hj">import</strong> <strong class="kz hj">seaborn</strong>               <strong class="kz hj">as</strong> <strong class="kz hj">sns</strong><br/><strong class="kz hj">import</strong> <strong class="kz hj">xgboost</strong>               <strong class="kz hj">as</strong> <strong class="kz hj">xgb</strong><br/><strong class="kz hj">from</strong> <strong class="kz hj">math</strong>                    <strong class="kz hj">import</strong> sqrt<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.linear_model</strong>    <strong class="kz hj">import</strong> LinearRegression, LassoCV<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.linear_model</strong>    <strong class="kz hj">import</strong> RidgeCV, ElasticNetCV<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.metrics</strong>         <strong class="kz hj">import</strong> r2_score, mean_squared_error<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.metrics</strong>         <strong class="kz hj">import</strong> mean_absolute_error<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.model_selection</strong> <strong class="kz hj">import</strong> train_test_split, GridSearchCV<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.model_selection</strong> <strong class="kz hj">import</strong> cross_val_score<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.preprocessing</strong>   <strong class="kz hj">import</strong> StandardScaler<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.ensemble</strong>        <strong class="kz hj">import</strong> RandomForestRegressor<br/><strong class="kz hj">from</strong> <strong class="kz hj">sklearn.pipeline</strong>        <strong class="kz hj">import</strong> Pipeline</span></pre><p id="7e79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的导入相当标准&amp;我包含了三种模型类型:线性、树和boosting模型。</p><p id="92d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我设计特征的方式，我必须创建两组数据:一组是原始特征，另一组是设计特征。当我建模时，每个模型都在两组数据上运行。在模型评估方面，我比较了每组特性的模型性能。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="78fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从线性回归开始，因为这是最简单的回归模型。我知道，如果这个模型表现不佳，我将不得不转换到不同的模型类型。然而，线性回归做得出奇的好。</p><p id="ee90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从线性模型，我决定我的下一步是尝试正则化模型。正则化模型的好处在于，它们通过将算法确定为不重要的特征向0缩小或实际上缩小到0来减少这些特征。我运行了三个正则化模型:山脊，套索和弹性网。令人惊讶的是，所有模型的表现都比线性回归差。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/94f3ce586897b54e5e4ea1265e221ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7aphDqUhBOj0oKob1d1gxA.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/cef7eb6a1e81e8a5aa1039ca4075c731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJWg0U8OwDOLOYKjk9u1zw.png"/></div></div></figure><p id="9691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">黄点是最容易看到的，因为实际上所有的预测都是相互叠加的。</p><p id="4930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很容易看出线性模型失败的地方:具有原始特征的模型过度预测低值，并且其方差随着实际值的增加而增加，而具有工程特征的模型对低值和高值预测不足。</p><p id="53f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我决定转向其他两种型号。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="c442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随机森林是一个树模型:它使用决策树来确定预测值。然而，它是对标准决策树的一个改进，因为它包含了两个层次的随机性:它引导(随机选择替换)行&amp;然后选择一组随机的特性。我选择这个模型而不是其他树类型，因为特征的选择是随机的:数据集中有48个特征是原始特征。随机森林建立方式的一个缺点是，我运行了一个网格搜索来搜索超参数(我设置的参数)的许多组合，但是这样做不允许提取特征重要性&amp;因此删除了解释。</p><p id="99d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">XGBoost回归模型或极端梯度增强模型是一种增强模型，它拟合初始弱线性模型，然后迭代地将弱模型拟合到残差上。然而，XGBoost将正则化与L1 <em class="kw">和</em> L2算法相结合，以帮助最小化过拟合。考虑到这两个模型的性能，我选择不对XGBoost模型运行GridSearch。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lm"><img src="../Images/e0f9cdb2caf20309e9221b59a5c8ef77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9FJj4fIGPaq3FuIIC2xPw.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lm"><img src="../Images/828dee9bef4698d3978a49e6b40601ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ui2mojz9iWsAeBm2M98-EQ.png"/></div></div></figure><p id="826c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显而易见，这两个模型比任何线性模型都<em class="kw">好得多。此外，他们使用工程特征表现得更好。</em></p><p id="9f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最好的模型是随机森林回归，因为它有最好的度量分数，尽管XGBoost模型紧随其后。此外，我们能够从模型中提取特征重要性，这允许我们了解数据中最重要的特征是什么。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ln"><img src="../Images/0feaf81f10dd8b14f5a500f0b95740b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njdN5Q1MsmhNZ94DJODiBw.png"/></div></div></figure><ul class=""><li id="f9c8" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj"> lvesv_log </strong>为收缩末期容积(收缩末期容积)的记录值；</li><li id="4bc6" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj"> lvef </strong>是射血分数或泵出多少血；</li><li id="27a1" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">性别</strong>是主体的性别；</li><li id="5923" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">主动脉调节</strong>是通过主动脉瓣的血液回流的量度</li><li id="010a" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">心尖缺血</strong>是对心尖区域血流量的测量</li></ul><p id="6994" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">收缩期容积与舒张期容积的关系接近1:1，因此该系数的大小并不令人惊讶。此外，射血分数是心脏舒张和收缩容积的比值，所以射血分数第二强并不奇怪。令人惊讶的是，接下来的三个最重要的特征是多么的微不足道:它们甚至在图上都看不到。这让我特别惊讶，因为具有工程特性的XGBoost模型具有更多、更强的系数。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="9e92" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated"><strong class="ak">结论&amp;展望</strong></h2><p id="d1c2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">非线性模型是迄今为止最好的，但仍有更多的工作要做。这是与健康相关的数据，所以我仍然对模型的预测不完全满意，但这将随着模型的进一步调整而出现。同样，特征工程需要被进一步清除，因为它提高了模型的性能。</p><p id="7193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想改进的另一个方面是数据本身。从核磁共振数据中预测EDV固然很好，但要真正提高系统的效率，我需要从患者病历中预测数据。也就是说，HIPAA将使获取这类数据变得困难。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="2f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望我没有对这个项目漫谈太久！我喜欢从事这项工作，因为它对我来说很有意义&amp;有现实世界的应用。</p><p id="b4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目的存储库可以在这里找到<a class="ae mc" href="https://github.com/a-bergman/DSI-Capstone" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="aec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以通过LinkedIn 联系到我。</p></div></div>    
</body>
</html>