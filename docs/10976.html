<html>
<head>
<title>Machine Learning for Programmers and Non-Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向程序员和非程序员的机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-for-programmers-and-non-programmers-f8568d357750?source=collection_archive---------9-----------------------#2020-11-11">https://medium.com/analytics-vidhya/machine-learning-for-programmers-and-non-programmers-f8568d357750?source=collection_archive---------9-----------------------#2020-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4ebc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用 Python 编程语言或 RapidMiner 应用程序创建机器学习模型</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/46263259ed185e114ac5a2b5046c41a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2Z5eAksWw6krG1zYONShQ.jpeg"/></div></figure><p id="aed2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">机器学习的目的是让计算机在没有人类干预的情况下自动学习。可以使用 Python 或 R 编程语言中的特定库来构建机器学习模型。它也可以使用带有图形界面的应用程序和拖放技术来构建，例如<a class="ae kb" href="https://orange.biolab.si/#Orange-Features" rel="noopener ugc nofollow" target="_blank"> Orange </a>和<a class="ae kb" href="https://rapidminer.com/" rel="noopener ugc nofollow" target="_blank"> RapidMiner </a>。最近，数据分析和机器学习库使得程序员分析和建立机器学习模型变得容易。此外，具有图形界面的数据科学应用程序使用户能够分析数据并构建机器学习模型，而无需编写代码。这些应用程序对非程序员和研究人员很有帮助。</p><p id="00cd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们将使用两种不同的方法来创建一个机器学习模型:<strong class="jh hj"> Python </strong>编程语言和<strong class="jh hj"> RapidMiner </strong>应用程序。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="af7c" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将使用“<a class="ae kb" href="https://archive.ics.uci.edu/ml/datasets/Early+stage+diabetes+risk+prediction+dataset." rel="noopener ugc nofollow" target="_blank"> <em class="kj">”早期糖尿病风险预测数据集</em> </a>”。该数据集包含 520 人的数据。有 16 列人口统计和健康数据。第 17 列是类(正或负)。</p><p id="1665" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将建立一个<strong class="jh hj">随机森林</strong>机器学习模型，在早期预测糖尿病。以下是我们将要遵循的步骤:</p><ol class=""><li id="a046" class="kk kl hi jh b ji jj jl jm jo km js kn jw ko ka kp kq kr ks bi translated">加载数据集</li><li id="73b2" class="kk kl hi jh b ji kt jl ku jo kv js kw jw kx ka kp kq kr ks bi translated">确立目标</li><li id="9342" class="kk kl hi jh b ji kt jl ku jo kv js kw jw kx ka kp kq kr ks bi translated">将数据分为训练和测试</li><li id="1c7b" class="kk kl hi jh b ji kt jl ku jo kv js kw jw kx ka kp kq kr ks bi translated">训练模型</li><li id="5ace" class="kk kl hi jh b ji kt jl ku jo kv js kw jw kx ka kp kq kr ks bi translated">评估模型</li></ol><p id="2076" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">模型的 Python 文件和 RapidMiner 文件可以在我的<a class="ae kb" href="https://github.com/nadaalay/Early_Stage_Diabetes_Prediction" rel="noopener ugc nofollow" target="_blank"> GitHub 资源库</a>中找到。</p><p id="0f8b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，让我们开始使用 Python 构建模型。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="4917" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated"><strong class="ak">使用 Python 的预测模型</strong></h1><h2 id="9dc2" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 1。</strong>T21【加载数据集】</h2><p id="40f9" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">首先，让我们导入我们将要使用的所有库。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="f6d8" class="lq kz hi mk b fi mo mp l mq mr"># import libraries<br/>import numpy as np<br/>import pandas as pd<br/>from sklearn.preprocessing import LabelEncoder<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.metrics import confusion_matrix, classification_report</span></pre><p id="e6da" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，我们将读取数据:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="4eb7" class="lq kz hi mk b fi mo mp l mq mr"># Read dataset file<br/>df = pd.read_csv('diabetes_data_upload.csv')<br/>df.head()</span></pre><p id="6f78" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是数据标题的快照。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es ms"><img src="../Images/7a7e338137c8fc1b13fbbd6d14936c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHbLKsIPDYwL6mW2PY7suA.png"/></div></div></figure><p id="96a0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于值不是数字，我们应该在创建模型之前对数据进行编码。我们将把非数字标签转换成数字标签。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="3b80" class="lq kz hi mk b fi mo mp l mq mr"># Apply label encoding<br/>for c in df.columns:<br/>	if df[c].dtype == 'object':<br/>		le = LabelEncoder()<br/>		df[c] = le.fit_transform(list(df[c].values))</span></pre><h2 id="b515" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 2。</strong>设定目标<strong class="ak">设定目标</strong></h2><p id="e836" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">我们将使用<code class="du mx my mz mk b">class</code>列作为模型的<em class="kj">目标</em>，所有其他列作为<em class="kj">特征</em>。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="7f5d" class="lq kz hi mk b fi mo mp l mq mr"># Initialize target and features<br/>label = df['class']<br/>features = df.drop( ['class'], axis = 1)</span></pre><h2 id="cbd8" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 3。</strong> <strong class="ak">将数据拆分成训练和测试</strong></h2><p id="8163" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">我们将数据集分成两组，80%用于模型训练，20%用于模型测试。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="be14" class="lq kz hi mk b fi mo mp l mq mr"># Split data into training and testing<br/>X_train, X_test, y_train, y_test = train_test_split(features, label, test_size = 0.2)</span></pre><h2 id="8184" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 4。</strong> <strong class="ak">训练模型</strong></h2><p id="48e3" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">让我们创建随机森林模型，训练并测试它:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="86ba" class="lq kz hi mk b fi mo mp l mq mr"># Create Random Forest classification model<br/>clf = RandomForestClassifier(criterion = 'gini', max_depth = 10)</span><span id="c5e4" class="lq kz hi mk b fi na mp l mq mr"># Train the model<br/>clf.fit(X_train, y_train)</span><span id="2d1e" class="lq kz hi mk b fi na mp l mq mr"># Test the model<br/>prediction = clf.predict(X_test)</span></pre><h2 id="747a" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 5。</strong> <strong class="ak">评估模型</strong></h2><p id="60f8" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">我们已经完成了模特训练。现在让我们评估模型并打印分类报告和混淆矩阵。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="818a" class="lq kz hi mk b fi mo mp l mq mr"># Print classification report<br/>class_report = classification_report(y_test, prediction)<br/>print('Classification Report')<br/>print(class_report)<br/>print()</span><span id="0670" class="lq kz hi mk b fi na mp l mq mr"># Print confusion matrix report<br/>conf_matrix = confusion_matrix(y_test, prediction)<br/>print('Confusion Matrix')<br/>print(conf_matrix)</span></pre><p id="a464" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下图显示了分类报告和混淆矩阵。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nb"><img src="../Images/3f10097e00a10b54870110a5ab698a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*VB28kV4ENGk112-UephQIw.png"/></div></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="b4bd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们已经完成了使用 Python 构建预测模型，让我们开始使用 RapidMiner 构建模型。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="6e3d" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated"><strong class="ak">使用 RapidMiner 的预测模型</strong></h1><p id="3917" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">在 RapidMiner 中，为了构建工作流流程，我们将操作符从<strong class="jh hj">操作符</strong>选项卡拖放到<strong class="jh hj">设计</strong>视图中的<strong class="jh hj">流程</strong>画布，并将操作符连接在一起。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nc"><img src="../Images/e090b7b87c31048a3d0ae4a7bc243170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x5JAGp5YSwP_QsIlt2mDQ.png"/></div></div></figure><p id="8aab" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">工作流流程代表预测模型。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nd"><img src="../Images/c74d179597e59cadda398f784c2ab079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH0y6-v2iab5Pt0i6RwwHw.png"/></div></div></figure><h2 id="71fe" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 1。</strong> <strong class="ak">加载数据集</strong></h2><p id="8c7b" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">要加载数据，首先点击<strong class="jh hj">存储库</strong>选项卡中的<strong class="jh hj">导入数据</strong>按钮，然后选择数据集文件，将数据集存储在存储库中。之后，将<strong class="jh hj"> Retrieve </strong> process 拖到画布上，然后从<strong class="jh hj"> Parameters </strong>选项卡中选择数据集的存储库位置。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ne"><img src="../Images/a446bd16d786d250943c097a49f3aa90.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*0zi53AA0TA_arbN_yCpg7A.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nc"><img src="../Images/1bdbc67f3bbd71b395924ed97e72e8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q94vT3-EpM8qUGFZ-gwG1A.png"/></div></div></figure><h2 id="e83f" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated">2.<strong class="ak">设定目标</strong></h2><p id="e030" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">将<strong class="jh hj">设置角色</strong>流程拖到画布上，并将<strong class="jh hj">检索</strong>流程的输出连接到<strong class="jh hj">设置角色</strong>流程的输入。然后，从<strong class="jh hj">参数</strong>页签中更改目标列的角色，将<strong class="jh hj">属性 _ 名称</strong>设置为'<em class="kj">类</em>'，将<strong class="jh hj">目标 _ 角色</strong>设置为'<em class="kj">标签</em>'。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nf"><img src="../Images/7db134e6eabfc9edfc7722d55a06f892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obaPcKr6FyuKYzsvnHbBtA.png"/></div></div></figure><h2 id="c9b1" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 3。</strong> <strong class="ak">将数据拆分成训练和测试</strong></h2><p id="c154" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">将<strong class="jh hj">拆分数据</strong>流程拖到画布上，并将<strong class="jh hj">设置角色</strong>流程的输出连接到<strong class="jh hj">拆分数据</strong>流程的输入。然后配置<strong class="jh hj">分区参数</strong>产生两个分区，分别为<strong class="jh hj"/><em class="kj">0.8</em>和<em class="kj"> 0.2 </em>。这将数据集分成两组，80%用于训练，20%用于测试。</p><div class="iy iz ja jb fd ab cb"><figure class="ng jc nh ni nj nk nl paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><img src="../Images/206b47f769508b8096bf77579e156d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1452/format:webp/1*7fcCzKu5d_mV4xunwtw-RA.png"/></div></figure><figure class="ng jc nm ni nj nk nl paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><img src="../Images/fade763bd5f6e8d98a138a12d573bedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*I5wYscfyA_hFFNvwcmvBdg.png"/></div></figure></div><h2 id="0fc3" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak"> 4。</strong>火车<strong class="ak">模型</strong></h2><p id="b619" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">首先，将<strong class="jh hj">随机森林</strong>进程拖到画布上。然后，为了训练模型，将<strong class="jh hj">分割数据</strong>过程的第一个输出(<em class="kj"> par </em> ) (80%)连接到<strong class="jh hj">随机森林</strong>过程的输入，并根据需要更改模型<strong class="jh hj"> </strong>的<strong class="jh hj">参数</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nn"><img src="../Images/46ba5dff61600da449901cbad8d55af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53e7VlfyFqIjmDG1jslNdw.png"/></div></div></figure><p id="af2a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了测试模型，拖放<strong class="jh hj">应用模型</strong>进程，并将<strong class="jh hj">随机森林</strong>进程(模型(<em class="kj"> mod </em>))的第一个输出连接到<strong class="jh hj">应用模型</strong>进程(模型(<em class="kj"> mod </em>))的第一个输入。之后，将<strong class="jh hj">分割数据</strong>进程的第二个输出(<em class="kj"> par </em> ) (20%)连接到<strong class="jh hj">应用模型</strong>进程的第二个输入(未标记数据(<em class="kj"> unl </em>))。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es no"><img src="../Images/25ede90a6a1debefe6e3a631b0a357b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_y3xEfyb4S3HWIKqLI7Hg.png"/></div></div></figure><h2 id="d480" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated">5.<strong class="ak">评估模型</strong></h2><p id="788c" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">将<strong class="jh hj">性能</strong>流程拖到画布上，并将<strong class="jh hj">应用模型</strong>流程的第一个输出(标记为数据(<em class="kj">实验室</em>))连接到<strong class="jh hj">性能</strong>流程的输入。然后，将<strong class="jh hj">性能</strong>过程的第一个输出(性能(<em class="kj">根据</em>))连接到结果(<em class="kj"> res </em>)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es np"><img src="../Images/a36558e7f336e9bace341fb428301ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNsEgtxcB1KPS7gMF_LiFw.png"/></div></div></figure><p id="e69f" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，运行流程，您可以在<strong class="jh hj">结果</strong>视图中看到性能结果。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="er es nq"><img src="../Images/253db716db70b4bc4ea1ea492c07d468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdreSL66xp9GD-o4ud-WJg.png"/></div></div></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="f83a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如你所见，我们可以使用<strong class="jh hj">和</strong>两种不同的方法创建一个<strong class="jh hj">机器学习模型</strong>。第一种方法是<strong class="jh hj">文本接口</strong>，这些是使用书面命令的编程语言，它们易于共享并且可以灵活地重复使用。另一种方法是<strong class="jh hj">图形界面</strong>，这些是使用菜单和小工具的专门应用程序。很容易看到流程，尽管共享或重用它可能会比较困难。总的来说，这些应用程序使<strong class="jh hj">非程序员</strong>和<strong class="jh hj">研究人员</strong>能够轻松完成数据科学任务。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="6756" class="lq kz hi bd la lr ls lt le lu lv lw li jo lx ly lk js lz ma lm jw mb mc lo md bi translated"><strong class="ak">结论</strong></h2><p id="a492" class="pw-post-body-paragraph jf jg hi jh b ji me ij jk jl mf im jn jo mg jq jr js mh ju jv jw mi jy jz ka hb bi translated">本文解释了如何用 Python 和 RapidMiner 创建机器学习模型。Python 提供了一些功能和库，使得 python 成为数据科学家和开发人员的首选之一。RapidMiner 是一个易于使用的可视化应用程序，用于不需要编程的数据科学任务。</p><p id="a4ad" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">感谢阅读:)</p></div></div>    
</body>
</html>