<html>
<head>
<title>Artificial Neural Network cookbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工神经网络食谱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/artificial-neural-network-cookbook-28240b57594a?source=collection_archive---------16-----------------------#2020-02-02">https://medium.com/analytics-vidhya/artificial-neural-network-cookbook-28240b57594a?source=collection_archive---------16-----------------------#2020-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cea4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何使用Keras实现人工神经网络的逐步说明</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/101489e0d2e7a5f9743b78cd20db6f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*446ZaKfxDbt6f---7YxLQA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">放电神经元</figcaption></figure><h1 id="715a" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">什么是神经网络？</h1><p id="a49c" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">神经网络是机器学习中的分类算法之一，它实际上是受人脑神经元细胞的启发，来预测某个事件或因变量的概率。它更像一个逻辑回归，但具有多层激活函数，以确保预测的准确性更高。</p><p id="5f0e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果你熟悉基本的回归技术，你可能想知道为什么不用逻辑回归来解决分类问题？问题是，简单的逻辑回归不能有效地计算非线性假设，因此我们使用人工神经网络进行实时复杂的分类</p><blockquote class="lg lh li"><p id="3203" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated">神经网络是更多层的逻辑函数或其他一些激活函数，可以产生更复杂的非线性决策边界。</p></blockquote><p id="86fd" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我知道如果你对神经网络完全陌生，这种解释不足以理解它的全部背景，如果你有兴趣知道它的数学背景，我强烈建议你去看吴恩达教授的视频讲座，关于进一步的数学参考，你可以读一本名为<em class="lj">“制作你自己的神经网络”的书。</em></p><p id="fd92" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在让我们开始，看看我们如何使用流行的python库“<em class="lj"> Keras”实现ANN。</em></p><h2 id="60e5" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">用例</h2><p id="2578" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">对于我们下面的ANN实现的例子，我们的目标是预测，当客户服务代表打电话给客户时，他们是否会订阅银行定期存款？</p><p id="1c9f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我已经从https://archive.ics.uci.edu/ml/datasets/Bank+Marketing<a class="ae mb" href="https://archive.ics.uci.edu/ml/datasets/Bank+Marketing" rel="noopener ugc nofollow" target="_blank">得到了数据集</a></p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="cfc2" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">不要再浪费时间了，让我们开始如何从头开始建立一个人工神经网络模型。</p><h1 id="5ebe" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">建立人工神经网络模型</h1><h2 id="a5d9" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">步骤1-导入数据集</h2><p id="b049" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">与任何其他机器学习模型一样，第一步将是导入我们将要使用的数据集，并在需要时进行必要的预处理。</p><p id="223d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们导入数据集</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="b6b3" class="ln jo hi mk b fi mo mp l mq mr">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plot<br/>import seaborn as sos</span><span id="55d4" class="ln jo hi mk b fi ms mp l mq mr">df = pd.read_csv('/Users/arunramji/Downloads/Sourcefiles/bank-additional/bank-additional-full.csv',sep=';')</span><span id="1239" class="ln jo hi mk b fi ms mp l mq mr">df.describe()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/6cdbf8e0e6eeb4967fc23aabe3973c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ky-ua7bXPw1LwKSE4zJB6w.png"/></div></div></figure><p id="dbbd" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">您可以从中获得一些关于数据集的基本统计信息。</p><h2 id="84c8" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">步骤2-检查空值</h2><p id="c591" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">另一个非常重要的预处理步骤是，在我们的数据集中识别缺失值，并用一些合理的值移除或替换它(如果没有这些缺失值，可能会导致模型预测有偏差)。</p><p id="8d7e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们检查数据集中任何缺失的值。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="fdab" class="ln jo hi mk b fi mo mp l mq mr">sns.heatmap(df.isnull(),yticklabels=False,cbar=False,cmap='viridis')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/6e3093179b1d9cecf84f3982b1deb84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*wC8N3S559NV6Rz1gtwhl_Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">缺少值</figcaption></figure><p id="2e3f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果有任何缺失值，我们可能会在图表中为每个变量绘制条形，但在我们的数据中，没有这样的缺失值，因此我们可能不需要进行任何插补。</p><h2 id="b2a3" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">步骤3-编码分类变量</h2><p id="1e2d" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">由于大多数参数ML算法只能得到数字形式的输入向量，所以在建立模型之前，我们必须将分类变量转换成数字形式。</p><h2 id="1ba3" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">a.标签编码</h2><p id="00f9" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">例如，如果我们有分类变量:Sex {Male，Female}，我们应该在将该变量用作模型变量之前将其转换为{0，1}，这种技术称为“标签编码”。</p><blockquote class="lg lh li"><p id="3749" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated">将分类变量值转换为具有整数值的数值变量被称为“标签编码”或“整数编码”</p></blockquote><h2 id="4540" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">b.序数变量的编码</h2><p id="2ebc" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">对于只有两个可能值(例如:性别)的分类变量来说，标签编码本身就足够了，但是对于有两个以上可能值且具有某种顺序的变量来说，应该以相同的顺序进行编码。</p><p id="7223" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">例如，序数变量有值→好，平均，坏</p><p id="433c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果我们要使用标签编码，它会随机给出如下数字:</p><p id="461c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">好:0，一般:2，差:1</p><p id="2144" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这对顺序变量没有意义，因为好的&gt;平均的&gt;坏的，我们应该按照下面的顺序编码(哪个是正确的)</p><p id="47dd" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">好:2，一般:1，差:0</p><blockquote class="lg lh li"><p id="86cf" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated">值具有某种顺序的分类变量应该以相同的顺序编码，这样当我们将它用于算法时，它将正确地解释它的意义。</p></blockquote><p id="e6b9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">虽然我们可以使用sklearn实现分类变量的标签编码的方法很少，但我经常使用<strong class="kh hj"> Find/Replace </strong>来编码顺序变量，因为我们对这种方法有更多的控制来编码每个值。</p><p id="7417" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们看看所有的分类变量是什么，</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="20a7" class="ln jo hi mk b fi mo mp l mq mr">df.select_dtypes('object').info()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/229a34d33d7deb5b78d41ee3b5d77fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*uHOQTqo2iNx4W-Lw9m5XMg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">分类变量</figcaption></figure><p id="fff5" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">当你浏览数据集时，你会发现在所有这些因素中——工作、教育和收入有一定的顺序，尽管一开始可能不明显，但它间接说明了一些事情。例如，一个高薪工作的人可能比一个低薪工作的人更倾向于开定期存款。</p><p id="6bb9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这同样适用于其他两个变量，所以让我们根据从中推断出的顺序，开始使用find/replace对它们进行编码。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="2e47" class="ln jo hi mk b fi mo mp l mq mr">#Encoding categorical variable</span><span id="d9ca" class="ln jo hi mk b fi ms mp l mq mr">'''Lets first split what are ordinal categorical variable and normal categorical variable</span><span id="65ad" class="ln jo hi mk b fi ms mp l mq mr">1. Ordinal - job , education ,poutcome</span><span id="20d0" class="ln jo hi mk b fi ms mp l mq mr">2. Normal - rest of them</span><span id="2968" class="ln jo hi mk b fi ms mp l mq mr">'''</span><span id="c756" class="ln jo hi mk b fi ms mp l mq mr">dict_job = {"job":{"housemaid":1,"unemployed":0,"entrepreneur":4,"blue-collar":1,"services":3,<br/>                  "admin.":2,"technician":2,"retired":1,"management":4,"self-employed":3,<br/>                  "unknown":1,"student":0.5}}<br/>dict_education = {"education":{"basic.4y":1,"basic.6y":1,"basic.9y":1<br/>                              ,"high.school":1,"professional.course":2,<br/>                              "university.degree":2,"illiterate":0.9,"unknown":0.9}}<br/>dict_poutcome = {"poutcome":{"nonexistent":0,"failure":0,"success":1}}</span><span id="20c8" class="ln jo hi mk b fi ms mp l mq mr">dict_y = {"y":{"no":0,"yes":1}}</span></pre><p id="9f68" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在我们已经创建了带有相关编码值的字典，注意我也为依赖变量y做了同样的事情。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="f49b" class="ln jo hi mk b fi mo mp l mq mr">#Find and Replace<br/>for i in [dict_job,dict_education,dict_poutcome,dict_y]:<br/>    df.replace(i,inplace=True)</span></pre><p id="4e80" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">好了，现在让我们用sklearn对剩下的名义变量(没有顺序的变量)进行编码。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="3c99" class="ln jo hi mk b fi mo mp l mq mr">#Encoding rest of the un ordinal categorical variable <br/>from sklearn.preprocessing import LabelEncoder</span><span id="9c0b" class="ln jo hi mk b fi ms mp l mq mr">lc_X1 = LabelEncoder()<br/>lst = ['marital','default','housing','loan','contact','month','day_of_week']<br/>for i in lst:<br/>    df[i] = lc_X1.fit_transform(df[i])</span></pre><p id="3cd5" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这将把所有剩余的分类变量转换成整数。</p><p id="aa84" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们看一看我们都做了些什么，</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/8859cb9c6a541563e173682c4a32af3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6yuh4rKsLLcU31uNinAhw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">标签编码后的样本数据集</figcaption></figure><p id="dd9a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">好吧，好吧！所以我们已经编码了所有的分类变量(包括名词性和序数，这样够了吗？</p><p id="9351" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">当你注意到‘婚姻’变量时，你可以看到我们的sklearn标签编码器将它转换成整数(1，2，3..)，正如我们之前所讨论的，即使变量中没有顺序，它也以某种方式转换了一个有顺序的整数，如果我们将此直接用于我们的算法，则martial status 2的值可能大于1，为了避免这种情况，我们必须遵循另一种称为“一个热编码”的方法。</p><blockquote class="lg lh li"><p id="3d37" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated">独热编码器为每个值创建一列，以便与所有其他值进行比较。对于每个新列，如果一行包含该列的值，则该行得到1，如果不包含该列的值，则得到0。</p></blockquote><p id="810b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们使用熊猫来应用一个热编码器，</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="755b" class="ln jo hi mk b fi mo mp l mq mr">#one hot encoding<br/>df_1 = pd.get_dummies(df,columns=['marital','default','housing','loan','contact','month','day_of_week']<br/>               ,drop_first=True)</span></pre><p id="f16f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们在上面的代码中使用drop_first = True来避免“虚拟变量陷阱”,这是“多重共线性”的基本概念。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/fd6714f155661d728dd8916e4ee51bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rf7nI2fS0winD0JZgOns5Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在一次热编码之后</figcaption></figure><p id="4161" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">您可以注意到，对于“婚姻”变量，它创建了三个唯一的列，对于每个值，如果该值存在，那么它将为1，否则为0。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="192b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">酷！可能我们已经完成了所需的数据预处理，现在是有趣的部分了，大家，让我们建立人工神经网络。</p><h2 id="99aa" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">步骤4 —分割数据集</h2><p id="d4ed" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">与所有其他学习算法一样，我们必须分配因变量和自变量，并将数据集分为训练和测试。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="ee3e" class="ln jo hi mk b fi mo mp l mq mr">#Assign Variable<br/>X = df_1.drop(columns='y',axis=1).values #matrix of feature X<br/>y = df_1['y'].values #dependent variable vector y</span><span id="57f3" class="ln jo hi mk b fi ms mp l mq mr">#split training - test set<br/>from sklearn.model_selection import train_test_split<br/>X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=101)</span></pre><h2 id="6a9e" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">步骤5-特征缩放</h2><p id="9a98" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">这是重要的一步，我们正在减少所有变量的大小，使它们彼此相似，这样我们的算法运行得更快，并提供合理的参数。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="4cf0" class="ln jo hi mk b fi mo mp l mq mr">#Feature Scaling<br/>from sklearn.preprocessing import StandardScaler<br/>sc = StandardScaler()<br/>X_train = sc.fit_transform(X_train)<br/>X_test = sc.fit_transform(X_test)</span></pre><h2 id="4cdc" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">步骤6 —建立人工神经网络模型</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/8877d9a0ec989904c6a990a19ca8e595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fA77_mLNiJTSgZFhYnU0Q.png"/></div></div></figure><p id="7c9d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们导入keras包</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="8b43" class="ln jo hi mk b fi mo mp l mq mr">#ANN Model</span><span id="fa2b" class="ln jo hi mk b fi ms mp l mq mr">#import keras libraries and modules <br/>import keras     #backend tensorflow by default</span><span id="473a" class="ln jo hi mk b fi ms mp l mq mr">#sequential module required to initialise neural network<br/>from keras.models import Sequential</span><span id="393f" class="ln jo hi mk b fi ms mp l mq mr">#dense model required to build layers of ANN<br/>from keras.layers import Dense</span><span id="44c0" class="ln jo hi mk b fi ms mp l mq mr">#import dropout class if needed<br/>from keras.layers import Dropout</span></pre><p id="4cef" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们初始化人工神经网络模型</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="4769" class="ln jo hi mk b fi mo mp l mq mr">classifier = Sequential() #object instantiating</span></pre><p id="195b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们添加我们的第一层</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="9b40" class="ln jo hi mk b fi mo mp l mq mr">classifier.add(Dense(units=13,activation='relu',kernel_initializer='uniform',input_dim=35))</span><span id="f044" class="ln jo hi mk b fi ms mp l mq mr">classifier.add(Dropout(rate=0.1))</span></pre><p id="b1f2" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">下面参数说明，</p><ol class=""><li id="adac" class="mx my hi kh b ki lb kl lc ko mz ks na kw nb la nc nd ne nf bi translated">单位-第一层的节点数</li><li id="2aae" class="mx my hi kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">激活——激活函数我们使用隐藏层</li><li id="607c" class="mx my hi kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">kernel_initializer —初始化接近0的权重</li><li id="ff92" class="mx my hi kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">input_dim —数据集中独立变量的数量</li></ol><p id="7198" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们需要添加多少层和节点完全取决于我们自己，我们可以使用不同的体系结构并提出一个有效的体系结构，但一般的方法是使用节点作为</p><p id="a308" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">因变量数量+自变量数量/ 2</p><p id="428a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">但这不是强制性的，您也可以选择不同的节点数。</p><blockquote class="lg lh li"><p id="20f1" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated">退出是一种技术，在随机选择的训练阶段随机忽略单位</p></blockquote><p id="1c48" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们添加第二层</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="46bd" class="ln jo hi mk b fi mo mp l mq mr">classifier.add(Dense(units=13,activation='relu',kernel_initializer='uniform'))</span><span id="54e5" class="ln jo hi mk b fi ms mp l mq mr">classifier.add(Dropout(rate=0.1))</span></pre><p id="3b58" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们添加第三层和最后一层，因为它是一个二进制分类，一个最终节点就足够了。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="ab27" class="ln jo hi mk b fi mo mp l mq mr">classifier.add(Dense(units=1,activation='sigmoid',kernel_initializer='uniform'))</span></pre><p id="9e82" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">下一步，让我们添加用于模型的参数类型、成本函数和指标。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="921d" class="ln jo hi mk b fi mo mp l mq mr">#compile ANN<br/>classifier.compile(optimizer='adam',loss='binary_crossentropy',<br/>                  metrics=['accuracy'])</span></pre><p id="b4c1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">完美！！现在我们已经建立了神经网络的框架，现在是时候传递来自训练集的输入并训练模型了😃</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="7a2a" class="ln jo hi mk b fi mo mp l mq mr">#fitting ANN<br/>classifier.fit(x=X_train, y = y_train,batch_size=10,epochs=100)</span></pre><p id="ab61" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">batch_size —每次迭代所需的样本数量</p><p id="3b4d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">时期—优化模型的迭代次数</p><p id="7dd0" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">一旦你运行了上面的步骤，我们将会看到如下的每次迭代，直到它完成，很漂亮，不是吗？！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/19ad138c2fdc4a4bc4f17f947ae82c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxRyNgD5rg_h2KzHswXKgg.png"/></div></div></figure><p id="00e9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">好吧。！现在，我们的模型在训练集中的准确率为90.21 %，这意味着如果您给模型提供相同的训练集数据，它将对90.21%的数据进行正确预测。</p><h2 id="e169" class="ln jo hi bd jp lo lp lq jt lr ls lt jx ko lu lv jz ks lw lx kb kw ly lz kd ma bi translated">第七步——预测</h2><p id="19b0" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们输入测试集数据，看看它如何预测。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="724d" class="ln jo hi mk b fi mo mp l mq mr">#predict test set</span><span id="4558" class="ln jo hi mk b fi ms mp l mq mr">y_pred = classifier.predict(X_test)</span><span id="92a8" class="ln jo hi mk b fi ms mp l mq mr">y_pred = y_pred &gt; 0.5  # predicted values with more than 50% probability <br/>y_pred</span></pre><p id="342e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">y_pred数组包含因变量是否有超过50%的机会为“是”的布尔值。</p><p id="5e45" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果是，则为真，如果不是，则为假。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nl"><img src="../Images/74123e261c5bd0afec2b0316f65d45e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*U188pqn2XJQuMQXxy7f6rQ.png"/></div></figure><p id="df2c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">测试集的精确度是多少？</p><blockquote class="lg lh li"><p id="2cb1" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated">测试集上模型的准确性:在数据集的所有实际样本中，我们正确预测了多少</p></blockquote><blockquote class="nm"><p id="21e6" class="nn no hi bd np nq nr ns nt nu nv la dx translated">真阳性+真阴性/总样本</p></blockquote><p id="5d35" class="pw-post-body-paragraph kf kg hi kh b ki nw ij kk kl nx im kn ko ny kq kr ks nz ku kv kw oa ky kz la hb bi translated">我们可以使用混淆矩阵来列出错误分类的数量。</p><p id="23d8" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">通常，对于我们的目标变量“y ”,混淆矩阵会是这样的</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ob"><img src="../Images/cf38c0ecc74c054a271ec0b3d6fe148a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOH13tSCstMITgvoue66Ww.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">混淆矩阵结构</figcaption></figure><p id="a985" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们将实际测试集类和预测测试集类的混淆矩阵列表。</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="fa8c" class="ln jo hi mk b fi mo mp l mq mr">from sklearn.metrics import confusion_matrix<br/>cm = confusion_matrix(y_test,y_pred)<br/>df = pd.DataFrame(cm)<br/>df</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oc"><img src="../Images/d7dd1756e50240f450d52a57dec2229b.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*LqtogqD2_CwgVs3mlcZs8Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">混淆矩阵</figcaption></figure><ul class=""><li id="6685" class="mx my hi kh b ki lb kl lc ko mz ks na kw nb la od nd ne nf bi translated"><strong class="kh hj">真阳性(TP): </strong>没有选择定期存款的<em class="lj"/>人，也被预测有<em class="lj">没有选择定期存款的</em>。</li><li id="421f" class="mx my hi kh b ki ng kl nh ko ni ks nj kw nk la od nd ne nf bi translated"><strong class="kh hj">真否定(TN): </strong>选择了定期存款并且也被预测到<em class="lj">的人选择了定期存款</em>。</li><li id="1470" class="mx my hi kh b ki ng kl nh ko ni ks nj kw nk la od nd ne nf bi translated"><strong class="kh hj">假阴性(FN): </strong>没有选择的人，但是预测说他们选择了。</li><li id="35da" class="mx my hi kh b ki ng kl nh ko ni ks nj kw nk la od nd ne nf bi translated"><strong class="kh hj">误报(FP): </strong>选择定期存款<em class="lj">的人</em>预测说他们不会。</li></ul><p id="61fa" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们计算一下精确度，</p><blockquote class="nm"><p id="d442" class="nn no hi bd np nq oe of og oh oi la dx translated">真正+真负/ TP+TN+FP+FN</p></blockquote><p id="3608" class="pw-post-body-paragraph kf kg hi kh b ki nw ij kk kl nx im kn ko ny kq kr ks nz ku kv kw oa ky kz la hb bi">7174 + 237 / 7174+105+722+237 = 0.89</p><p id="3694" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">测试集上的准确率为89% </strong></p><p id="92f9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">准确性通常会给出模型性能一般概念。如果我们的训练集有或多或少相等数量的正类和负类，那么我们可以相信准确性是模型性能的标准。</p><p id="19e7" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">然而，我们的模型具有因变量的正类和负类的不等分布，因此我们可能必须使用“敏感性”和“特异性”来进一步评估。</p><p id="c13b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">训练集中正类和负类的计数:</p><p id="8f6d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">正类' 0 '[未选择存款的客户] : 36548</p><p id="1051" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">负类' 1 '[选择存款的客户] : 4640</p><blockquote class="lg lh li"><p id="2c9a" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated"><strong class="kh hj">敏感度用于评估模型预测正类的置信度</strong></p></blockquote><blockquote class="nm"><p id="0fc2" class="nn no hi bd np nq nr ns nt nu nv la dx translated">灵敏度=真阳性/真阳性+假阴性</p></blockquote><p id="a312" class="pw-post-body-paragraph kf kg hi kh b ki nw ij kk kl nx im kn ko ny kq kr ks nz ku kv kw oa ky kz la hb bi">7174 / 7174 + 722 = 0.9085</p><p id="c347" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">模型对测试集的敏感度为90.85 % </strong></p><p id="4e92" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这意味着，如果你在模型中给出一个新的未知测试集，它将很有可能正确预测90%的肯定类。</p><blockquote class="lg lh li"><p id="1aa5" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated"><strong class="kh hj">特异性用于评估模型预测阴性类别的置信度</strong></p></blockquote><blockquote class="nm"><p id="cae2" class="nn no hi bd np nq nr ns nt nu nv la dx translated">特异性=真阴性/真阴性+假阳性</p></blockquote><p id="14cd" class="pw-post-body-paragraph kf kg hi kh b ki nw ij kk kl nx im kn ko ny kq kr ks nz ku kv kw oa ky kz la hb bi">237 / 237 + 105 = 0.692</p><p id="52f9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">模型对测试集的特异性为69.2 % </strong></p><p id="9259" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这意味着，如果我们对未知集合使用我们的模型，只有69%的时间它会正确预测负类。</p><p id="942e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">因此，在我们的示例中，我们的目标是预测可能接听电话并同意认购定期存款的客户为负类“是”，模型预测的准确率仅为69.2%。</p><blockquote class="lg lh li"><p id="5905" class="kf kg lj kh b ki lb ij kk kl lc im kn lk ld kq kr ll le ku kv lm lf ky kz la hb bi translated"><strong class="kh hj"> <em class="hi">如果正确识别阳性对我们来说很重要，那么我们应该选择灵敏度更高的模型。然而，如果正确识别阴性更重要，那么我们应该选择特异性作为度量标准。</em> </strong></p></blockquote><p id="53f4" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">由于我们的模型在预测负类方面表现不太好，但仍有模型改进的空间，您可以通过多种方式实现这一点，如<em class="lj">添加更多层、调整辍学率、使用不同的神经网络架构</em>等等。</p><h1 id="3d23" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">结束注释</h1><p id="62fe" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我希望这可能给你一些关于用keras工具和评估指标烹饪神经网络的基本想法，我强烈鼓励你使用这些数据并尝试提高准确性。</p><p id="a1f2" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如果你觉得这有用或者有什么建议，请在下面留下评论。</p><blockquote class="nm"><p id="f040" class="nn no hi bd np nq oe of og oh oi la dx translated">为了更好的未来继续努力！！</p></blockquote></div></div>    
</body>
</html>