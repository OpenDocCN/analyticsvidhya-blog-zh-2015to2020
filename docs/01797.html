<html>
<head>
<title>Malware Engineering Part 0x2— Finding shelter for parasite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">恶意软件工程部分0x2—为寄生虫寻找庇护所</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/malware-engineering-part-0x2-finding-shelter-for-parasite-751145dd18d0?source=collection_archive---------8-----------------------#2019-11-14">https://medium.com/analytics-vidhya/malware-engineering-part-0x2-finding-shelter-for-parasite-751145dd18d0?source=collection_archive---------8-----------------------#2019-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/15b17024d766a0503d4105dca23ff6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4B5FBxW1NNzedAo7FIQXg.png"/></div></div></figure><blockquote class="iq"><p id="3062" class="ir is hi bd it iu iv iw ix iy iz ja dx translated">病毒是一种小的传染因子，它只能在生物体的活细胞内复制</p></blockquote><p id="2b34" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ja hb bi translated">这就是维基百科对生物病毒的简单定义。根据类比，计算机病毒属于恶意软件的范畴，它通过一些寄生代码注入技术来感染主机二进制文件(甚至是内存)。这里的寄生虫是被注入的代码，驻留在宿主二进制文件中，以接管宿主程序被劫持的代码流。感染后，宿主二进制被<a class="ae jy" href="https://en.wikipedia.org/wiki/Trojan_horse_(computing)" rel="noopener ugc nofollow" target="_blank">植入</a>以达到更进一步的目的。特洛伊木马是一种具有恶意但伪装成合法程序的软件。病毒的基本思想是劫持程序的代码流，并将其交给寄生代码，寄生代码(在其恶意代码执行后)悄悄地将控制转移到主机二进制程序，恢复预期的代码执行。在这篇文章中，我们将讨论一种病毒设计的方法和用于感染过程的算法。</p><p id="9a0e" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated"><strong class="jd hj">注</strong>:本文是《神奇精灵  <em class="ke"> </em>恶意软件工程系列》的续篇，在该系列中，我们首次涉足精灵二进制文件的世界。</p><h1 id="4a9f" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">先决条件</h1><ul class=""><li id="ceeb" class="ld le hi jd b je lf ji lg jm lh jq li ju lj ja lk ll lm ln bi translated">必须了解<a class="ae jy" rel="noopener" href="/@compilepeace/malware-engineering-part-0x1-that-magical-elf-5be3556ecb2b"> ELF文件格式</a>。</li><li id="3a20" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">Linux下大量的C编程技能以及<a class="ae jy" href="https://github.com/angrave/SystemProgramming/wiki" rel="noopener ugc nofollow" target="_blank">系统编程</a>概念(链接用于快速学习)将极大地有助于全面理解本文。</li><li id="96ad" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">此外，我们将使用在<a class="ae jy" href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h" rel="noopener ugc nofollow" target="_blank"> elf.h </a>(位于本地Linux文件系统的<code class="du lt lu lv lw b">/usr/include/</code>目录中)中定义的数据结构，以编程方式访问和操作主机二进制文件的部分内容。因此，我鼓励读者浏览这些结构。或者，这些数据结构可以从Linux手册<code class="du lt lu lv lw b">$ man 5 elf</code>的<em class="ke">第5页</em>中引用。</li></ul><h1 id="369e" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">在狙击手和手榴弹的世界里，我们打算制造什么？</h1><p id="1a3f" class="pw-post-body-paragraph jb jc hi jd b je lf jg jh ji lg jk jl jm lx jo jp jq ly js jt ju lz jw jx ja hb bi translated">可能是一把匕首。我们要设计的是一种带有某种毒素(寄生虫)的无声武器(传染程序),它可以在网络杀伤链的利用阶段之后，通过一些常用的特洛伊木马，在受害者机器上秘密地保持持久性。</p><p id="3a1a" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">在内存中，程序以段的形式排列(每个段由一个或多个部分组成)。让我们来看看<em class="ke"> </em> <code class="du lt lu lv lw b"><em class="ke">/bin/ls</em></code>实用程序的程序头表(PHT)(它列出了当前目录的内容)</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/b7de88c37cf48722e378fa364038aa8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0lKDT-DY1l2EUYQvYQRfg.png"/></div></div></figure><p id="9fba" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">上面，我们看到有2个可加载段(标记为类型LOAD ),段权限为R-E(读-执行)和RW-(读-写)。查看段到段的映射，可以推断它们分别是<strong class="jd hj">代码/文本</strong>和<strong class="jd hj">数据</strong>段。</p><figure class="mb mc md me fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/57708757993ae4be37b8a8e8ddb7293d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*FKR8uJu9EwX-UOafX02ovg.png"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">程序的抽象内存视图</figcaption></figure><p id="def9" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">在无害程序被加载到存储器中之后，段是页面对齐的，但是段(包括段)很少与页面边界对齐，从而在当前段和相邻段之间留下空间。当二进制文件加载到内存中时，这个空间由零字节填充。在上面的图片中，填充由一系列的<code class="du lt lu lv lw b">P</code>表示，这将导致分段对齐。我们将使用这种填料为寄生虫提供住所，因为它似乎是一个舒适的庇护所。但是，也有填充区域小于寄生虫大小的情况，在这种情况下，这种感染方法(在UNIX世界中称为<strong class="jd hj"> <em class="ke">段填充感染</em> </strong>，在windows世界中称为<a class="ae jy" href="https://en.wikipedia.org/wiki/Code_cave" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hj"> <em class="ke">代码崩溃</em></strong></a><strong class="jd hj"><em class="ke"/></strong>)将无法感染该二进制文件。下面是传染机制的算法。</p><pre class="mb mc md me fd mk lw ml mm aw mn bi"><span id="c4a4" class="mo kg hi lw b fi mp mq l mr ms"><strong class="lw hj">-x-x- Load parasite from file on-disk into memory</strong>                       <br/>1. Get <em class="ke">parasite_size</em> and <em class="ke">parasite_code</em> address (location in allocated memory) <br/>                                                                    <br/><strong class="lw hj">-x-x- Find the padding_size </strong>(unused space)<strong class="lw hj"> between CODE segment and the NEXT segment after CODE segment</strong>(usually data segment)                      <br/>2. In the CODE segment PHT entry, increase the following-                         <br/>-&gt; <em class="ke">p_filesz</em>   (by parasite size)                         <br/>-&gt; <em class="ke">p_memsz</em>    (by parasite size)</span><span id="b926" class="mo kg hi lw b fi mt mq l mr ms">Get and Set respectively,                         <br/>-&gt;<em class="ke"> </em><strong class="lw hj"><em class="ke">padding_size</em></strong>  = (offset of next segment (after CODE segment)) - (end of CODE segment)                        <br/>-&gt;<em class="ke"> </em><strong class="lw hj"><em class="ke">parasite_offset</em></strong> = (end of CODE segment) or (end of last section of CODE segment)<br/>-&gt; <strong class="lw hj">parasite_load_address</strong> = virtual address (vaddr) + sizeof CODE segment (filesz) </span><span id="4479" class="mo kg hi lw b fi mt mq l mr ms"><strong class="lw hj">-x-x- PATCH Host entry point</strong>                       <br/>3. Save the <em class="ke">original_entry_point </em>of host binary.<br/>4. Alter the host entry to point to the location <em class="ke">parasite_offset</em>/<em class="ke">parasite_load_address </em>(i.e. the location where parasite is to be injected into the host binary) <br/>                                                                     <br/><strong class="lw hj">-x-x- PATCH SHT</strong>                       <br/>5. Find the last section in CODE Segment and increase -                                <br/>-&gt; <em class="ke">sh_size</em>    (by parasite size)<br/>                                                                     <br/><strong class="lw hj">-x-x- PATCH Parasite offset </strong>                      <br/>6. Find and replace Parasite jmp-on-exit address/offset placeholder with <em class="ke">original_entry_point</em> 0x????????????????   <br/>                                                                  <br/><strong class="lw hj">-x-x- Inject Parasite to Host </strong>(mapped @ host_mapping)                       <br/>7. Inject parasite code @ (<em class="ke">host_mapping + parasite_offset</em>), i.e. to the end of the last section (among all other sections in CODE segment)<br/>8. Write the infection to disk ×_×</span></pre><p id="91e7" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">注意:这个感染点有一个缺点。由于代码段是<strong class="jd hj">而不是</strong>具有写权限，所以自我修改的寄生代码不会起作用。</p><h1 id="20c6" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">让代码自己说话×_×</h1><p id="cf14" class="pw-post-body-paragraph jb jc hi jd b je lf jg jh ji lg jk jl jm lx jo jp jq ly js jt ju lz jw jx ja hb bi translated">有了关于ELF和我们的黑色连帽衫的所有知识，是时候深入C编程语言中感染算法的实际实现了。我将浏览一下<a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV" rel="noopener ugc nofollow" target="_blank"> Kaal Bhairav </a>的感染<a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">模块</a>的源代码。</p><h2 id="5fca" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">序言</h2><p id="f330" class="pw-post-body-paragraph jb jc hi jd b je lf jg jh ji lg jk jl jm lx jo jp jq ly js jt ju lz jw jx ja hb bi translated">首先，我们来声明一些变量。我希望上面的评论足以清楚地理解变量存储了什么。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/6afc02cec8efa3c197394e569134fe3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nijv85rmuJz4H5uHjE1MUA.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">拼用配料</a></figcaption></figure><p id="1e4d" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated"><code class="du lt lu lv lw b"><em class="ke">ElfParser()</em></code> <em class="ke"> </em>接受一个名为<em class="ke"> filepath </em>(主机二进制文件的路径)的参数，并通过与其他实用函数协调来遵循感染算法的每个步骤。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/25631abd69685f48b44f2ee7cc873d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae_HtYVUm8as_jrC61N3vw.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">邪恶精灵就这样诞生了</a></figcaption></figure><ul class=""><li id="d19f" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(Line <strong class="jd hj"> 84 </strong>)抽象使用<code class="du lt lu lv lw b">mmap()</code>将主机二进制文件映射到内存中，以便进一步修改。主机的第一个字节被映射到由<em class="ke"> host_mapping指定的位置。</em></li><li id="939f" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">86</strong>–<strong class="jd hj">90</strong>)将主机二进制文件的Elf头读入<em class="ke">host _ header</em>(<a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank">Elf . h</a>中指定的<code class="du lt lu lv lw b"><em class="ke">struct Elf64_Ehdr</em></code>类型)。它解析<strong class="jd hj"> ET_EXEC </strong>和<strong class="jd hj"> ET_DYN </strong>(可执行和共享对象)类型的64位类二进制文件，跳过<strong class="jd hj"> ET_REL </strong>(可重定位)、<strong class="jd hj"> ET_CORE </strong>(核心)或类<strong class="jd hj"> ELFCLASS32 </strong> (32位二进制文件)的二进制文件。这里的<strong class="jd hj"> ET_EXEC </strong>、<strong class="jd hj"> ET_DYN </strong>、<strong class="jd hj"> ET_REL </strong>、<strong class="jd hj"> ET_CORE </strong>都是在<a class="ae jy" href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h" rel="noopener ugc nofollow" target="_blank"> elf.h </a>中定义的宏。</li><li id="e9b8" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">93</strong>–<strong class="jd hj">94</strong>)调用<code class="du lt lu lv lw b">LoadParasite()</code> <em class="ke"> </em>将寄生虫放入内存，为其注入宿主做准备。制作寄生代码(对于LSB可执行文件和共享对象类型是不同的)将在下一篇文章中解释。</li><li id="9ba2" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">96</strong>–<strong class="jd hj">101</strong>)调用<code class="du lt lu lv lw b">GetPaddingSize()</code>获取垫料尺寸(庇护所尺寸)并检查宿主是否能容纳寄生虫进入垫料。</li><li id="d424" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">103</strong>–<strong class="jd hj">107</strong>)保存主机二进制文件的<em class="ke"> original_entry_point </em>，并根据寄生虫被注入的位置修改主机入口点(由<code class="du lt lu lv lw b">GetPaddingSize()</code>设置的<em class="ke">寄生虫_offset </em>和<em class="ke">寄生虫_load_address </em>)。可执行文件和共享对象二进制文件的寄生位置是不同的。在ET_EXEC主机中，入口点由地址指定，而在共享对象(ET_DYN)中，入口点由偏移量指定，因为它包含PIC(<strong class="jd hj">P</strong>position<strong class="jd hj">I</strong>n dependent<strong class="jd hj">C</strong>ode)。</li></ul><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/1a066b01a494b7b90e1a11ead19269e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6HTJwgHwSnPFT08I9o2eg.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">LSB可执行文件和LSB共享对象</figcaption></figure><ul class=""><li id="b5ca" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(Line<strong class="jd hj">109</strong>–<strong class="jd hj">115</strong>)<code class="du lt lu lv lw b">PatchSHT()</code>是我们的效用函数，对<strong class="jd hj"> S </strong>截面<strong class="jd hj"> H </strong>头部<strong class="jd hj"> T </strong>进行修改，使其能够容纳寄生虫。然后我们使用<code class="du lt lu lv lw b">FindAndReplace()</code>用主机二进制的<em class="ke"> original_entry_point </em>修补寄生虫代码的jmp-on-exit地址/偏移量，之后我们通过<code class="du lt lu lv lw b">memcpy()</code>将寄生虫注入主机，并使用<code class="du lt lu lv lw b">munmap()</code>取消二进制映射，将受感染的主机映射写到磁盘上。</li></ul><h2 id="5fa2" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">mmapFile() —与主机保持一臂的距离</h2><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/06027237431cf24187f62289b9319e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9XrsUXDKPrnFTociJdD0g.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">映射主机</a></figcaption></figure><p id="efd0" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">函数<code class="du lt lu lv lw b">mmapFile()</code>接受主机路径作为参数，将主机映射到当前进程地址空间，并返回指向映射的主机二进制文件的第一个字节的指针。</p><ul class=""><li id="91fe" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(线<strong class="jd hj">317</strong>–<strong class="jd hj">321</strong>)以读写模式打开主机二进制文件</li><li id="bc80" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">323</strong>–<strong class="jd hj">328</strong>)<code class="du lt lu lv lw b">lstat()</code>获取关于主机的信息，特别是mmap()要使用的主机二进制文件的大小(磁盘上的大小)。念<code class="du lt lu lv lw b">$ man stat</code>。</li><li id="ef6d" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">330</strong>–<strong class="jd hj">334</strong>)<code class="du lt lu lv lw b">mmap()</code>将主机二进制映射到调用进程的虚拟地址空间(本例中为Kaal Bhairav)。主机被映射到内核选择的地址(由NULL作为mmap的第一个参数指定)。<strong class="jd hj">PROT _写入</strong>这里描述了映射的内存保护，即映射中的页面可以被写入。<strong class="jd hj"> MAP_SHARED </strong>标志指定一旦对映射进行任何修改，映射的更新将反映到磁盘上的文件中(此外，最好使用msync())。阅读<code class="du lt lu lv lw b">$ man mmap</code>。</li><li id="a09a" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(行<strong class="jd hj">336</strong>–<strong class="jd hj">337</strong>)最后<code class="du lt lu lv lw b">close()</code>主机二进制并将地址返回到映射的主机二进制的第一个字节。</li></ul><h2 id="5863" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">LoadParasite() —内存中的毒药</h2><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/09f94f0db2753555efbd9623ee0248c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4ESXhnuPov8kcAMSJV1dA.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">装载毒丸</a></figcaption></figure><p id="8ca6" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">这个想法是将寄生虫注入到主机映射中(它设置了MAP_SHARED标志)。为此，寄生代码需要放在进程地址空间中的某个地方，以便在适当的时候可以直接访问。<code class="du lt lu lv lw b">LoadParasite()</code>将包含寄生虫代码的文件的路径()作为参数，并将寄生虫放入定义<em class="ke">寄生虫_大小</em>和<em class="ke">寄生虫_代码</em>全局变量的内存中(在内存中存储寄生虫代码的大小和位置)。它是通过-</p><ul class=""><li id="6cb9" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(Line<strong class="jd hj">270</strong>–<strong class="jd hj">282</strong>)以只读模式打开包含寄生虫代码的文件，并使用<code class="du lt lu lv lw b">lstat()</code>(之前用于<code class="du lt lu lv lw b">mmapFile()</code>)获取寄生虫文件的属性。</li><li id="6d18" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(行<strong class="jd hj">284</strong>–<strong class="jd hj">290</strong>)代码将寄生虫的大小放入<em class="ke">寄生虫_大小</em>中，并通过<code class="du lt lu lv lw b">malloc()</code>在堆段上分配<em class="ke">寄生虫_大小</em>字节，后者将分配空间的位置返回给<em class="ke">寄生虫_代码</em>。<code class="du lt lu lv lw b">malloc()</code>返回的地址存储在<code class="du lt lu lv lw b">int8_t *</code>类型的寄生虫代码中(指向一个字节值的指针)。</li><li id="d39d" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(行<strong class="jd hj">292</strong>–<strong class="jd hj">296</strong>)最后我们执行<code class="du lt lu lv lw b">read()</code> syscall从<code class="du lt lu lv lw b">parasite_fd</code>(由<code class="du lt lu lv lw b">open()</code>返回的寄生虫文件描述符)中读取<em class="ke">寄生虫大小</em>字节。</li></ul><p id="094c" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated"><strong class="jd hj">注意</strong>:我们依靠堆段来加载寄生代码，因为它在程序执行结束之前一直是可访问的。如果我们将寄生代码加载到一个数组中(在堆栈段上为其分配空间)，一旦函数返回(在函数尾声期间)，它将与<code class="du lt lu lv lw b">LoadParasite()</code>的堆栈帧一起被销毁。</p><h2 id="0a05" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">GetPaddingSize() —舒适的庇护所！</h2><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/e3340bcf46c50566304a3bd9df5bd104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30oIrnaeo2goeekAgLEicQ.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">解析PHT </a></figcaption></figure><p id="d2a0" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">到目前为止，我们已经将主机二进制映射到进程地址空间，并且我们的寄生代码已经在堆段中冷却。接下来，我们需要找到一个宿主二进制文件的映射，在那里我们的寄生代码可以安静地运行。函数<code class="du lt lu lv lw b">GetPaddingSize()</code>解析<strong class="jd hj">P</strong>program<strong class="jd hj">H</strong>eader<strong class="jd hj">T</strong>able(PHT )( host mapped @<em class="ke">host _ mapping</em>)以找到代码段和代码段之后的下一个段(通常是数据段)之间的填充大小，并返回填充大小(这让我们知道主机是否能够容纳寄生虫)。</p><ul class=""><li id="5326" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(Line<strong class="jd hj">211</strong>–<strong class="jd hj">213</strong>)从host_mapping(总是从二进制的第0个偏移量开始)获取elf_header。从elf header中获取并存储pht的偏移量到名为<em class="ke"> pht_offset </em>的变量中，并将程序头的数量(在PHT中)存储到名为<em class="ke"> pht_entry_count的变量中。</em></li><li id="eecc" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line <strong class="jd hj"> 216 </strong>设置一个名为<em class="ke"> phdr_entry </em>的变量，指向PHT中的第一个条目@ (host_mapping + pht_offset)</li><li id="7784" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">217</strong>–<strong class="jd hj">219</strong>)将<strong class="jd hj"> CODE_SEGMENT_FOUND </strong>置0，表示是否找到代码段。然后，我们从第0个程序头开始遍历PHT的条目。</li><li id="20d6" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(行<strong class="jd hj">221</strong>–<strong class="jd hj">225</strong>)检查<strong class="jd hj"> CODE_SEGMENT_FOUND </strong>是否为0(即代码段尚未找到)以及<a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank"> elf.h </a>中定义的<code class="du lt lu lv lw b">struct Elf64_Phdr</code>的段类型(由<a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank">T8】p _ type</a>属性指定)是否为<a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hj"> PT_LOAD </strong> </a>(即二进制的加载段之一)和如果这三个条件都为真，通过将<strong class="jd hj"> CODE_SEGMENT_FOUND </strong>设置为1，该段被标记为CODE seg Patch parasite code，以将控制静默转移到原始代码段。</li><li id="a02b" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">227</strong>–<strong class="jd hj">229</strong>)这里的<em class="ke"> phdr_entry </em>指向当前程序头，段的结束是通过将<strong class="jd hj"> p_filesz </strong>(磁盘上段的大小)加到<strong class="jd hj"> p_offset </strong>(当前段的偏移量)给出的。由于我们希望将寄生虫代码放在代码段本身的末尾，我们将<em class="ke">寄生虫_偏移量</em>设置为<em class="ke">代码_段_结束_偏移量</em>。对于LSB可执行文件，我们将代码段的<em class="ke">寄生虫_加载_地址</em>(即在主机二进制执行期间将发现寄生虫的位置)设置为(p_vaddr + p_filesz)。</li><li id="973a" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">231</strong>–<strong class="jd hj">232</strong>)根据感染算法的第二步，我们通过<em class="ke"> parasite_size </em>增加当前程序头的<em class="ke"> filesz </em>(磁盘上段的大小)和<em class="ke"> memsz </em>(内存中段的大小)属性。这样做是为了适应磁盘和内存中寄生虫。</li><li id="2f64" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">235</strong>–<strong class="jd hj">240</strong>)如果<strong class="jd hj"> CODE_SEGMENT_FOUND </strong>设置为1(即代码段已经被上述代码解析和修改)并且段类型(<a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank"> elf.h </a>中定义的<code class="du lt lu lv lw b">struct Elf64_Phdr</code>的<code class="du lt lu lv lw b">p_type</code>属性)设置为PT_LOAD(即可加载段)并且段权限设置为读写(RW-)，则执行数据段的块。返回数据段偏移量减去<br/>代码段结束偏移量后得到的padding_size(即<em class="ke"> p_offset </em>(数据段)<em class="ke"/>—<em class="ke">CODE _ segment _ end _ offset</em>)。</li><li id="4006" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(行<strong class="jd hj">242</strong>–<strong class="jd hj">245</strong>)然后递增<em class="ke"> phdr_entry </em>以指向下一个程序头条目。如果循环遍历所有条目，并且代码流不知何故到达行号<strong class="jd hj"> 245 </strong>，这意味着我们没有进入数据段的If块，因此返回0，这表示没有空间用于寄生代码。</li></ul><p id="4777" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated"><strong class="jd hj">注</strong>:这里PF_R、PF_W、PF_X是描述段访问权限的宏，在<code class="du lt lu lv lw b">/usr/include/elf.h</code>中定义。<strong class="jd hj"> PF_X </strong>为(1&lt;&lt;0)<strong class="jd hj">PF _ W</strong>为(1&lt;&lt;1)<strong class="jd hj">PF _ R</strong>为(1 &lt; &lt; 2)。如<code class="du lt lu lv lw b"><a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank">$ man 5 elf</a></code>所述，我们可以通过对这些宏执行按位“或”运算来使用这些标志。</p><h2 id="d819" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">PatchSHT() —我们的寄生虫万岁！</h2><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/aea1f5e4fe797d93c5b280cee25a3752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPfxhj7disiL3ANSEkkWSA.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank">解析PHT </a></figcaption></figure><p id="feda" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">我们在宿主体内发现了一个寄生虫的房间，但是我们如何消除它对不被扔出我们发现的庇护所的不安全感。存在二进制文件专用的工具(如<code class="du lt lu lv lw b">strip</code>)，它们不喜欢补充内容(即除了程序执行所必需的内容之外的任何内容)留在二进制文件中。<code class="du lt lu lv lw b">Strip</code>丢弃符号、调试信息和二进制文件中无助于程序执行的部分。像<code class="du lt lu lv lw b">strip</code>这样的工具经常被软件开发人员用来减少二进制文件的大小(在发布用于生产之前),也让逆向工程师的日子更难过。与此同时，它删除了任何不属于任何部分的代码/数据，这对我们的寄生虫来说似乎很可怕。为了使我们未来的木马主机条带安全，我们必须解析二进制文件的段标题表(SHT ),并将代码段的最后一段的大小增加<em class="ke">寄生虫_大小</em>,以欺骗<code class="du lt lu lv lw b">strip</code>相信寄生虫是段的一部分。</p><ul class=""><li id="43e2" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(Line<strong class="jd hj">145</strong>–<strong class="jd hj">150</strong>)它从主机二进制文件的elf头设置<em class="ke"> sht_offset </em>(到段头表的偏移量)和<em class="ke">SHT _ entry _ count</em>(SHT中的条目数)。将<em class="ke"> section_entry </em>(属于<a class="ae jy" href="https://linux.die.net/man/5/elf" rel="noopener ugc nofollow" target="_blank"> elf.h </a>中定义的<code class="du lt lu lv lw b">Elf64_Shdr *</code>类型)定义为SHT的第一个条目。</li><li id="117a" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">153</strong>–<strong class="jd hj">162</strong>)遍历SHT，检查当前段结束偏移量(<em class="ke">current _ section _ end _ offset</em>)是否等于代码段结束偏移量(<em class="ke">code _ segment _ end _ offset</em>)。如果是代码段的最后一段，则增加其<em class="ke"> sh_size </em>以容纳寄生代码。稍后，递增section_entry指针以指向SHT中的下一个条目。</li></ul><h2 id="3435" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">FindAndReplace() —修补寄生虫</h2><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/0148b6e3a26b5c0f73508c336345b56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sl41g03snIHkfyK8_6yKMg.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank"> evil_elf.c </a></figcaption></figure><p id="f0b0" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">当攻击者感染一个二进制程序时，他打算劫持该二进制程序的代码流，让它做一些它不打算做的事情(由寄生虫执行的特技)。该过程的劫持部分可以通过不同的感染方法来完成，这取决于恶意软件作者使用的感染点。它可以在main()执行之前完成(通过<strong class="jd hj">入口点修改技术</strong>或<strong class="jd hj">劫持构造函数</strong>)，在main()执行之间完成(通过劫持库函数<strong class="jd hj"> —中毒</strong>或<strong class="jd hj"> PLT/GOT重定向</strong>，通过<strong class="jd hj">函数蹦床</strong>感染)，也可以在main()执行之后完成(<strong class="jd hj">劫持析构函数</strong>)。这里，我们重点关注第一种技术，即修改入口点来劫持主机二进制代码流。</p><p id="8c08" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">在我们劫持了代码流并将代码流传输给寄生虫之后，寄生虫的责任是将代码流静默地传输回主机二进制代码的预期代码执行，使得代码被静默地执行而不产生任何噪声。要做到这一点，我们需要以某种方式让寄生虫知道它需要在执行后将代码流转移到哪里。我们的效用函数— <code class="du lt lu lv lw b">FindAndReplace()</code>为我们执行这个任务。它用主机二进制文件的<em class="ke"> original_entry_point </em>替换一个占位符值(在寄生代码内部)。称之为- <code class="du lt lu lv lw b">FindAndReplace(parasite_code, 0xAAAAAAAAAAAAAAAA, original_entry_point);</code>。</p><ul class=""><li id="fff2" class="ld le hi jd b je jz ji ka jm nj jq nk ju nl ja lk ll lm ln bi translated">(Line<strong class="jd hj">125</strong>–<strong class="jd hj">128</strong>)初始化一个指向寄生虫的指针<code class="du lt lu lv lw b">uint8_t *ptr</code>，并遍历寄生虫代码的每个字节。</li><li id="6811" class="ld le hi jd b je lo ji lp jm lq jq lr ju ls ja lk ll lm ln bi translated">(Line<strong class="jd hj">130</strong>–<strong class="jd hj">135</strong>)在x86–64位架构上，一个内存地址占用内存中8个字节的空间。请记住，<em class="ke"> current_QWORD </em>是一个长类型变量，存储一个8字节的值。<code class="du lt lu lv lw b"><em class="ke">if statement</em></code> <em class="ke"> </em>通过对<em class="ke"> find_value </em>和<em class="ke"> current_QWORD </em> (1 XOR 1为0) <em class="ke"> </em>进行异或运算来比较这些值，从而用<em class="ke"> replace_value </em>覆盖8个字节的占位符并返回<em class="ke"> </em>(即<em class="ke"> original_entry_point </em>)</li></ul><h2 id="4abe" class="mo kg hi bd kh mu mv mw kl mx my mz kp jm na nb kt jq nc nd kx ju ne nf lb ng bi translated">ElfParser:注入寄生代码并取消二进制映射</h2><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/063826d115f1bc0c09a9221e7913dcb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCLtbQhh1qq39dLSGgUbwg.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV/blob/master/evil_elf.c" rel="noopener ugc nofollow" target="_blank"> evil_elf.c </a></figcaption></figure><p id="773e" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">在<code class="du lt lu lv lw b">ElfParser()</code>、<code class="du lt lu lv lw b">memcpy()</code>中，将<em class="ke">寄生虫_大小</em>字节从位置<em class="ke">寄生虫_代码</em>(堆段中)复制到(<em class="ke">主机_映射+寄生虫_偏移量</em>)中，这是寄生虫的住处。<code class="du lt lu lv lw b">munmap()</code>从Kaal Bhairav的进程地址空间取消主机二进制映射，感染被写入磁盘。</p></div><div class="ab cl nt nu gp nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hb hc hd he hf"><h1 id="f861" class="kf kg hi bd kh ki oa kk kl km ob ko kp kq oc ks kt ku od kw kx ky oe la lb lc bi translated">我心爱的双星生病了</h1><p id="5bec" class="pw-post-body-paragraph jb jc hi jd b je lf jg jh ji lg jk jl jm lx jo jp jq ly js jt ju lz jw jx ja hb bi translated">恶心到(至少)表现出一种唐突的行为。直到我们学会制造寄生虫，感染过程才算完成。寄生虫是在我们劫持了主机的代码流后，通过定义什么是善或恶来完成感染的。在下一篇文章中，我们将讨论对于<strong class="jd hj"> ET_EXEC </strong>和<strong class="jd hj"> ET_DYN </strong>类型的二进制文件来说是不同的寄生设计(即对于LSB可执行文件和共享对象)。<br/>elf infector的完整源代码可以在<a class="ae jy" href="https://github.com/compilepeace/KAAL_BHAIRAV" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="8ee4" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated">干杯，<br/><strong class="jd hj"><br/><em class="ke"/></strong></p><p id="c99f" class="pw-post-body-paragraph jb jc hi jd b je jz jg jh ji ka jk jl jm kb jo jp jq kc js jt ju kd jw jx ja hb bi translated"><strong class="jd hj">Github</strong>:<a class="ae jy" href="https://github.com/compilepeace" rel="noopener ugc nofollow" target="_blank">https://github.com/compilepeace</a><br/><strong class="jd hj">领英</strong>:<a class="ae jy" href="https://www.linkedin.com/in/abhinav-thakur-795a96157/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/abhinav-thakur-795a96157/</a></p></div></div>    
</body>
</html>