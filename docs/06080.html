<html>
<head>
<title>DEEP LEARNING TUTORIAL-(patch_camelyon data-set)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习教程-(补丁_卡梅里昂数据集)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-learning-tutorial-patch-camelyon-data-set-d0da9034550e?source=collection_archive---------6-----------------------#2020-05-11">https://medium.com/analytics-vidhya/deep-learning-tutorial-patch-camelyon-data-set-d0da9034550e?source=collection_archive---------6-----------------------#2020-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将在patch _ camelyon数据集(医学图像)上使用卷积神经网络(CNN ),该数据集来自tensor flow官方网站。我们将建立一个能够对图像进行分类的convnet模型。</p><p id="f912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您尚未安装此模块，请使用pip安装tensorflow-datasets</p><h2 id="e5c4" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">了解数据集</h2><p id="cd82" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在我们开始创建我们的模型之前，让我们试着理解我们将要处理的数据。</p><p id="8de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它由从淋巴结切片的组织病理学扫描中提取的327，680幅彩色图像(96 x 96px)组成。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/1c5e170cc9192b33556b539abf6bb069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5wnsoA5B2N5eTaje.png"/></div></div></figure><p id="1463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每幅图像都标注了一个二元标记，表明存在转移组织。</p><p id="dfe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个图像的大小为[96，96，3](彩色图像)，二进制标签为0或1。数据集正在进行训练、验证和测试拆分。最后一件事是…</p><p id="accf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，你猜对了，这是医学图像。现在我们已经了解了我们将要处理的内容，让我们加载数据</p><p id="b5ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:</p><ul class=""><li id="d874" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">在google colab上尝试这将是最好的选择，数据集相当大！</li><li id="96b0" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">加载数据需要一段时间，原因同上</li><li id="d317" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">不要害怕下载的大小，它实际上只需要不到50MB，而在谷歌colab加载它，所以给它一个尝试！</li></ul><p id="8a61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始吧</p><h2 id="3ed9" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">加载数据集</h2><p id="1149" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">为了加载数据集，我们需要做的第一件事是导入必要的库。然后，我们将使用tfds.load()加载(下载，然后第一次加载)我们的数据集，同时将with _info和as_supervised设置为True。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="7d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着检查一些可能不清楚的代码部分</p><ul class=""><li id="2cfa" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">在第9行使用tfds.load()时，设置with_info = True将返回关于我们的数据集的信息，然后将这些信息存储在我们声明的变量中(即info)。</li><li id="fdc5" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">as_supervised = True将我们的数据集加载为(图像，标签)元组结构。</li></ul><p id="f6ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们的数据集由训练、验证和测试分割组成。第12、13、14行在它们各自的变量中分配每个单独的分割</p><h2 id="b3b6" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">预处理数据</h2><p id="2dc3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在把我们的数据输入CNN之前，它必须经过某种形式的预处理。</p><p id="175a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的数据集中图像的每个像素范围从0到255，我们将缩放到0到1之间。</p><p id="ac24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们批处理和预取训练、验证和测试数据。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><ul class=""><li id="48f8" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">创建了一个函数来缩放图像的像素</li><li id="3541" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">tf.cast确保我们的图像是float32类型</li><li id="811e" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">潜水255。以浮点格式将我们的像素缩放到0到1之间</li><li id="9f99" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">对每个数据使用map()方法会将我们的预处理函数应用于每个数据</li><li id="c7f2" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">使用大小为1000的缓冲区来混洗训练数据。确保缓冲区大小足够大，以使洗牌有效，但尽量不要超过RAM的容量。</li><li id="84ec" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">每个数据以batch_size为128进行批处理，通过使用prefetch(1 ),我们的数据集将始终领先一个批次</li></ul><h2 id="425d" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">格式化</h2><p id="ee44" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在我们准备好之前，只剩下一点格式化了。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><ul class=""><li id="7c4e" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">iter()遍历数据来分离图像和标签，记住我们设置为_supervise = True</li><li id="e3d7" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">next()移动到下一批</li><li id="503c" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">然后我们检查给出(128，1)的标签的形状，注意第一项是我们的batch_size，而不是我们数据集中标签的总数</li><li id="3fe1" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">train_images.shape返回TensorShape([128，96，96，3])。第一项也是我们的batch_size，而我们数据集中图像的形状是[96，96，3]，即我们的input_shape</li></ul><h2 id="e917" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">模型</h2><p id="b05d" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在预处理和格式化之后，我们现在终于准备好构建我们的模型了。在构建我们的CNN之前，我们肯定会从导入一些必要的库开始</p><p id="1c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住我们的input_shape = [96，96，3]</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><ul class=""><li id="eb9b" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">我们的第一层由256个大小为3(即3 x 3)的过滤器组成，我们的input_shape变量也位于第一层</li><li id="7189" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">下一层由最大池组成，池大小为2</li><li id="436f" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">随着过滤器256、512、1024的数量增加，重复相同的过程</li><li id="8ac0" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">对于具有(填充=相同)的层，每个图像将被填充</li><li id="29dc" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">Kernel_initializer用于训练开始时的随机性加权</li><li id="eb54" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">使用的激活函数是“relu”</li><li id="9a37" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">展平层在传递到致密层之前展平我们图像的形状</li><li id="ccfd" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">我们有三个密集隐藏层，隐藏单元为1024、512、128</li><li id="67f2" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">我们希望我们的模型返回一个单一的输出，即0或1，所以我们的输出层只包含1个隐藏单元，具有“sigmoid”激活函数</li></ul><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="b7d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将返回我们的模型的总结，我们可以看到可训练和不可训练的层和总参数</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lf"><img src="../Images/2214e149118e97792046b4151e10c423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0orbY33ssgDc1hE-pLHnA.png"/></div></div></figure><p id="e939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要编译我们的模型并使之适合。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><ul class=""><li id="163f" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">Adam optimizer的学习率为0.0001</li><li id="8e4a" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">由于我们的标签已经被编码为0和1，我们将使用“二进制交叉熵”作为损失函数</li><li id="c230" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">还实现了早期停止回调来监控我们的val_loss，并且如果val_loss在10个时期内没有增加，则停止模型</li><li id="e87b" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">model.fit()将开始我们模型的训练</li></ul><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lg"><img src="../Images/b96861170f74412f674d2b9136d07a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZQeykBj5SKQBL-aT8ab_w.png"/></div></div></figure><p id="b790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在训练之后，验证准确度应该是大约73%</p><p id="5e5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用下面的代码绘制精度和损耗曲线</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="9731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当训练精度曲线继续增加时，在它停止之前，得到的曲线应该是验证精度的稳定增加</p><p id="7298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以继续在test_data上测试它</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="7775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结论</p><p id="e7e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能够获得75%的模型准确性，这仍然可以通过数据扩充和迁移学习来提高(这将需要大量的计算能力和资源)，但总的来说，这仍然是一个好模型</p></div></div>    
</body>
</html>