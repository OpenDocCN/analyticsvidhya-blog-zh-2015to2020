<html>
<head>
<title>Setting up python conscientiously</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认真设置python</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/setting-up-python-conscientiously-b27dc0a690ff?source=collection_archive---------8-----------------------#2020-11-04">https://medium.com/analytics-vidhya/setting-up-python-conscientiously-b27dc0a690ff?source=collection_archive---------8-----------------------#2020-11-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f8418c5a88966e71c73383bca4f93dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2gkcrQZwU5HmgZ2HJlv2w.jpeg"/></div></div></figure><p id="7d53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能是一个精力充沛的开发人员，准备编码下一个大东西，甚至是一个科学家，需要验证一个有前途的和新颖的想法！你喜欢人工智能，网络，密码或任何其他热门和趋势的概念。您可能认为python是一个很好的入门工具。而且你知道，它实际上是！Python可能是最伟大、最成熟的社区之一。您有太多的实现示例，多个库提供了开箱即用的功能。各种各样的博客帖子已经被制作出来，以帮助你在这个漫长的旅程中，探索你自己的pythonic世界。</p><p id="f5cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我们走吧，让我们开始写一些代码。第0步是获取某个<code class="du jo jp jq jr b">stack overflow</code> ed例程，然后<br/>执行它来断言它的输出。接下来你应该准备好发射了。</p><p id="2aba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">my_python_scirpt.py:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="52f5" class="ka kb hi jr b fi kc kd l ke kf">import pandas as pd<br/> import numpy as np</span><span id="6494" class="ka kb hi jr b fi kg kd l ke kf"> if __name__=="__main__":<br/>  # <br/>  # TODO: write some extra magnificent piece of code here<br/>  # <br/>  print("something is happening here")</span><span id="c701" class="ka kb hi jr b fi kg kd l ke kf">&gt; python my_python_script.py</span></pre><p id="62d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，您会得到以下错误:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="5294" class="ka kb hi jr b fi kc kd l ke kf">ModuleNotFoundError            Traceback (most recent call last)<br/> &lt;ipython-input-1-7dd3504c366f&gt; in &lt;module&gt;<br/> ----&gt; 1 import pandas as pd</span><span id="2c42" class="ka kb hi jr b fi kg kd l ke kf"> ModuleNotFoundError: No module named 'pandas'</span></pre><p id="1741" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上，你开始谷歌错误，以找到大量的解决方案，最终可能正确地工作在你的情况下。然而，具体的文章不应该被视为另一个修复手稿的问题。这是关于解释python的设置过程。我们不提供纯粹的步骤，而是要调查幕后发生了什么，以便能够减轻将来与python设置相关的任何问题。</p><p id="add1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">声明:我基本上是一个苹果电脑迷。我确实在macOS上开发，在Linux上部署，而且通常是以文档化的方式。这就是为什么这篇文章主要是面向macOS的。然而，同样的原理也可以应用于windows系统。</p><h1 id="1e90" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">预装python</h1><p id="1ace" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">首先，任何macOS或Linux系统都是python就绪的。这意味着python已经安装，并且在大多数情况下已经包含在相应的<code class="du jo jp jq jr b">$PATH</code>环境变量中。Python对于增强最终用户体验的多个脚本或软件组件来说是必不可少的。这就是Python成为任何macOS (/Linux)发行版的一部分的原因。也就是说，在shell中键入<code class="du jo jp jq jr b">python</code>应该会触发交互式python解释器，提示您输入有效的Python表达式。但是python的安装并不是专门用于开发的(至少在macOS上是这样)。这是由于(a)安全问题以及(b)版本不兼容。关于最后一个，考虑macOS具有<code class="du jo jp jq jr b">python 2.7.x</code>(在特定帖子被编辑时)，它与苹果提供的任何基于python的功能兼容，但不与最新的<code class="du jo jp jq jr b">Keras</code>、<code class="du jo jp jq jr b">Pandas</code>或<code class="du jo jp jq jr b">Numpy</code>实现兼容，例如。或者想想还没有移植到最新python版本的研究工具，很可能它们还没有。因此，我们大部分时间都需要安装至少一个python版本才能安全轻松地工作。</p><h1 id="c50d" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">点</h1><p id="683a" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">另一个让我们生活变得更简单的东西是<code class="du jo jp jq jr b">pip</code>，python包安装程序。<code class="du jo jp jq jr b">Pip</code>可以很容易地用来安装我们需要在其上构建的任何<code class="du jo jp jq jr b">site-packages</code>(即第三方组件)。例如，要安装广为人知的包<code class="du jo jp jq jr b">pandas</code>，我们可以在shell中键入以下命令:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="bf68" class="ka kb hi jr b fi kc kd l ke kf">&gt; pip install pandas</span></pre><p id="e8aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在成功安装pandas之后，我们可以继续我们的python代码片段，导入并使用<code class="du jo jp jq jr b">pandas</code>。顺便说一下，对于那些没有意识到的人来说，<code class="du jo jp jq jr b">pandas</code>是一个很棒的数据预处理和轻量级分析工具。</p><p id="937b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然<code class="du jo jp jq jr b">pip</code>不会像python一样从盒子里出来。我们需要手动安装它。安装pip更简单的方法是使用相应的软件包安装程序(即<code class="du jo jp jq jr b">brew</code> if <code class="du jo jp jq jr b">Mac</code> else <code class="du jo jp jq jr b">apt</code>)。通过键入以下命令:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="dfa7" class="ka kb hi jr b fi kc kd l ke kf">&gt; brew install python&lt;PVersion&gt;-pip #macOS , &lt;PVersion&gt; --&gt; python version 2 or 3</span><span id="4090" class="ka kb hi jr b fi kg kd l ke kf">&gt; apt install python&lt;PVersion&gt;-pip #Ubuntu, &lt;PVersion&gt; --&gt; python version 2 or 3</span></pre><p id="801d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们应该安装<code class="du jo jp jq jr b">pip</code>，然后我们应该能够安装我们需要的python包。对吗？有一点...</p><p id="9735" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">Pip</code>在<code class="du jo jp jq jr b">&lt;some_path&gt;/python&lt;Version&gt;/site_packages</code>目录下安装包，这是python解释器在遇到<code class="du jo jp jq jr b">import</code>代码行时查找的地方之一。这样，已安装的<code class="du jo jp jq jr b">pandas</code>包就可用于上面的代码片段。</p><p id="1a9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">python-pip安装的两个路径变量(即<code class="du jo jp jq jr b">&lt;some_path&gt;</code>和<code class="du jo jp jq jr b">&lt;Version&gt;</code>)<code class="du jo jp jq jr b">&lt;PVersion&gt;</code>以及<code class="du jo jp jq jr b">$PATH</code>环境变量是本文讨论的大多数python安装难点的原因。</p><h1 id="88e7" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">路径，环境变量</h1><p id="b01a" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">环境变量注册了所有可执行文件所在的目录。尽管像大多数环境变量一样是一个字符串，它的行为却像一个有序列表。每当请求一个可执行文件时，操作系统都会扫描<code class="du jo jp jq jr b">$PATH</code>来定位第一个匹配的文件。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="ab15" class="ka kb hi jr b fi kc kd l ke kf">&gt; echo $PATH<br/>  /Users/someone/.pyenv/shims:/usr/local/sbin:/usr/local/Manual_installs:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:</span></pre><p id="e919" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是典型的<code class="du jo jp jq jr b">$PATH</code>布局。假设您已经安装了以下两个可执行文件:</p><ul class=""><li id="5671" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated"><code class="du jo jp jq jr b">/usr/local/sbin/test</code></li><li id="bee1" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated"><code class="du jo jp jq jr b">/sbin/test</code> <br/>击键测试将导致执行第一个，实际上是基于<code class="du jo jp jq jr b">$PATH</code>指示的顺序的第一个匹配。</li></ul><h1 id="1feb" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Python多版本化</h1><p id="56c6" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">假设您的笔记本电脑提供了预装的<code class="du jo jp jq jr b">pythonX</code>，并且您已经安装了相应的<code class="du jo jp jq jr b">pythonX-pip</code>。然而，您最终需要导入一个与特定python版本<code class="du jo jp jq jr b">X</code>不兼容但与<code class="du jo jp jq jr b">Y</code>版本兼容的模块。显而易见的解决方案是安装所需的<code class="du jo jp jq jr b">pythonY</code>以及相关的，并祈祷其他模块都与<code class="du jo jp jq jr b">Y</code>版本兼容。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="a532" class="ka kb hi jr b fi kc kd l ke kf">&gt; brew install python3<br/>&gt; brew install python3-pip</span></pre><p id="cffa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对你很有帮助。因此，每当您需要显式定义一个特定的python版本时，只需键入:</p><p id="c261" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="ad7b" class="ka kb hi jr b fi kc kd l ke kf">&gt; pip3 install &lt;python_3_package&gt;<br/>&gt; python3 my_python_3_code.py</span></pre><p id="045f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这是额外的工作，不那么优雅。是吗？</p><h1 id="754c" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Pyenv</h1><p id="d2cb" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">您可以使用<code class="du jo jp jq jr b">pyenv</code>包，而不是手动指示python版本。<code class="du jo jp jq jr b">Pyenv</code>负责无缝安装和管理多个python版本。用户可以通过以下命令来指定<code class="du jo jp jq jr b">global</code>或<code class="du jo jp jq jr b">local</code> python版本:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="f324" class="ka kb hi jr b fi kc kd l ke kf">&gt; pyenv shell 3.8.1  # sets python 3.8.1 to be the default python for # the current tty session</span></pre><p id="7bd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且在下一时刻，键入<code class="du jo jp jq jr b">python</code>或<code class="du jo jp jq jr b">pip</code>应该被绑定到设置的版本。</p><p id="4aac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是通过一个名为垫片的概念实现的。Shims是轻量级的可执行文件，它只是将您的命令传递给pyenv。我认为shims更像是一个可执行的适配器模式。Pyenv在<code class="du jo jp jq jr b">$PATH</code>前面注入一个垫片目录。这意味着通过键入<code class="du jo jp jq jr b">python</code>shims的目录是第一个被访问的，猜猜看，python可执行文件似乎就在那里！根据PyEnv原始文档，当您击键<code class="du jo jp jq jr b">pip</code>操作系统时:</p><ul class=""><li id="d175" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">在路径中搜索一个名为pip的可执行文件</li><li id="7ef6" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">在路径的开头找到名为pip的pyenv shim</li><li id="2376" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">运行名为pip的shim，它依次将命令传递给pyenv</li></ul><p id="a01e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过设置您喜欢的版本，命令<code class="du jo jp jq jr b">python</code>和<code class="du jo jp jq jr b">pip</code>被绑定到该版本。而这让python版本管理真的是小菜一碟！</p><p id="715f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，pyenv不是由Python引导的。它不依赖于任何python安装。因此，它的设置在概念上是非常清楚的。然而，缺点是它需要对已安装的版本以及它们所依赖的“东西”有一个很好的概述。考虑运行在特定python版本上的python linter的情况。全局python版本管理的灵活性可能会影响linters的行为。</p><h1 id="fa8d" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">虚拟</h1><p id="e25f" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">好的，然后你设置好<code class="du jo jp jq jr b">pyenv</code>，你就可以开始了。但是迟早你会遇到混合需求的问题。想象一下，在你的两个不同的项目中工作，项目A和项目B，每个项目都需要不同的第三方包列表。在每个项目都是在不同的python版本下开发的情况下，混合需求问题乍一看可能并不明显。但这种情况并不常见。通常，你会在同一个python版本中处理多个项目。在全球范围内使用<code class="du jo jp jq jr b">pip</code>不应该被认为是明智的选择！除了一个高度损坏的<code class="du jo jp jq jr b">pythonX/site_packages/</code>目录之外，你将无法区分所有那些你为项目A安装的包和那些与项目b相关的包，这就是<code class="du jo jp jq jr b">virtualenv</code>被创建的原因；提供需求隔离级别。这对你很有帮助。</p><p id="2e78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要安装，您可以:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="4ab8" class="ka kb hi jr b fi kc kd l ke kf">&gt; pip install virtualenv</span></pre><p id="b959" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，您可以创建一个新的项目目录并创建相关的虚拟环境:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="f78a" class="ka kb hi jr b fi kc kd l ke kf">&gt; mkdir my_project_dir &amp;&amp; cd project_dir  # create the project dir and move there<br/>&gt; virtualenv the_venv  # in case of Python 2<br/>&gt; python3 -m venv the_venv  # in case of Python 3</span></pre><p id="7f69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">激活虚拟环境，你就准备好了！</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="b173" class="ka kb hi jr b fi kc kd l ke kf">&gt; source the_venv/bin/activate</span></pre><p id="f534" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您下载的任何包都将被存储到那个<code class="du jo jp jq jr b">the_venv/.../site-packages</code>目录中。</p><h1 id="74b2" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Virtualenvwrapper</h1><p id="16b9" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">有几个高级工具可以以简洁的方式管理python虚拟环境。据我所知，<code class="du jo jp jq jr b">Pipenv</code>和<code class="du jo jp jq jr b">virtualenvwrapper</code>是最突出的两个。在这篇文章中，我们将使用<code class="du jo jp jq jr b">virtualenvwrapper</code>这个，因为这是我熟悉的一个。它是一个python包，将所有目录设置细节从python源代码目录中抽象出来，成为一个专用于存储虚拟环境的目录。在这种情况下，我们需要创建专用目录:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="5569" class="ka kb hi jr b fi kc kd l ke kf">&gt; mkdir ~/.virtualenvs  # virtual environments are going to be <br/># installed into the home folder into a hiffen file</span></pre><p id="fe26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个python包，它可以通过以下方式轻松安装:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="2156" class="ka kb hi jr b fi kc kd l ke kf">&gt; pip install virtualenvwrapper</span></pre><p id="d1a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="f74d" class="ka kb hi jr b fi kc kd l ke kf">&gt; sudo pip install virtualenvwrapper #avoid such sudo ops if possible!</span></pre><p id="e75a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们需要让终端可以访问这个包的功能。换句话说，每当我们在终端中键入任何包virtualenvwrapper子命令时，我们都期望相应的功能发生。这些可以通过在我们的<code class="du jo jp jq jr b">~/bashrc</code>或<code class="du jo jp jq jr b">~zshrc</code>文件中添加以下行来实现。</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="3369" class="ka kb hi jr b fi kc kd l ke kf">&gt; export WORKON_HOME=$HOME/.virtualenvs  # define the virtual envs # direcotry<br/>&gt; source /usr/local/bin/virtualenvwrapper.sh  # load virtualenvwrapper # functionality to terminal</span></pre><p id="b578" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经准备好创建您的第一个环境:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="4c06" class="ka kb hi jr b fi kc kd l ke kf">&gt; makevirtualenv my_env  # that's going to crate a virtual env named <br/># my_end --&gt; located at $WORKON<br/>&gt; workon my_env  # to start working into a my_env<br/>&gt; deactivate  # is going to deactivate the particular enabled <br/># virtualenv</span></pre><p id="a5ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过运行以下命令</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="20da" class="ka kb hi jr b fi kc kd l ke kf">&gt; lsvirtualenvs</span></pre><p id="91a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以列出可用的虚拟环境。通过检查<code class="du jo jp jq jr b">~/.virtualenvs/</code>目录，您可以确保所有列出的virtualenvs都在那里。</p><p id="7de9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">额外提示:请记住，virtualenvwrapper能够定义您需要使用的python版本。通过键入<code class="du jo jp jq jr b">mkvirtualenv test -p python2</code>，只要您的<code class="du jo jp jq jr b">$PATH</code>上有python2，test将成为python2 virtualenv。</p><h1 id="d66f" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">混淆了，常见的陷阱</h1><p id="a7f3" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">尽管您可以将所有这三种工具结合到一个高度自动化和高效的环境中，但有些情况下事情可能会真的出错。另外，您将要构建的许多自动化可能在不久的将来会变得过时。整个设置过程中最棘手的一个概念是，有一些工具可以管理用python创建的python环境！例如，你可以在python2中安装并运行virtualenv和virtualenvwrapper，但是要处理python3虚拟环境。这很难理解，在我看来，这也是在“完美设置”过程中可能面临的所有这些棘手问题的原因。环境变量内容的任何重新排序或令人讨厌的软件都可能破坏这种美丽的自动化。</p><h1 id="2795" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">用集装箱装</h1><p id="a982" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">这是一个面向生产的解决方案，没有上面提到的所有复杂性。通过为一个特定的项目创建一个专门的docker容器，您可以将您需要的任何东西全局地安装到该容器中。不要忘记，尽管这种特定解决方案有三个主要缺点，但总体性能会略有下降，可视化在交互工作方面具有挑战性，docker开发模式与生产模式不同。</p><h1 id="2b0c" class="kh kb hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">最后的想法</h1><p id="56c5" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">四种解决方案我都用过。我认为Virtualenvweapper是最适合我的。我确实使用多个python版本。为了减轻这种情况，我使用Virtualevnwrapper的<code class="du jo jp jq jr b">-p</code>选项将每个虚拟环境与特定的python版本绑定在一起。我的安装作战计划如下:</p><ul class=""><li id="6cb1" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">安装我想保留为主的python(对我来说这是python3.5)</li><li id="ad2f" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">为特定的python版本安装<code class="du jo jp jq jr b">pip</code>(在我的例子中，python3-pip)</li><li id="c1dd" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">在python安装程序上安装<code class="du jo jp jq jr b">virtualenv</code></li><li id="539f" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">在python安装程序上安装<code class="du jo jp jq jr b">virtualenvwrapper</code></li><li id="be5e" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">额外提示:在该设置上安装任何林挺工具，而不是将它们安装在不同的虚拟环境中</li><li id="6e51" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">安装我需要的任何python版本，并使用virtualenvwrapper的<code class="du jo jp jq jr b">-p</code>选项将该特定版本绑定到相关环境。对我来说，这是最简单明了的管道。我不喜欢使用外来的工具来管理python版本和虚拟环境，除非我对正在发生的事情非常有信心。</li></ul></div></div>    
</body>
</html>