<html>
<head>
<title>React Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回应面试问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/react-interview-questions-77fb2f62f30?source=collection_archive---------28-----------------------#2020-05-06">https://medium.com/analytics-vidhya/react-interview-questions-77fb2f62f30?source=collection_archive---------28-----------------------#2020-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0fcd32738c3c1b6dab8271abf138ffb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etZQvxokw-9sVitrw0IIsQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自谷歌</figcaption></figure><p id="ce7f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">今天的话题</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="c814" class="kb kc hi jx b fi kd ke l kf kg">1. Closures</span><span id="9ee8" class="kb kc hi jx b fi kh ke l kf kg">2. How do React hooks work?</span><span id="335e" class="kb kc hi jx b fi kh ke l kf kg">3. useMemo Hook</span><span id="7ccf" class="kb kc hi jx b fi kh ke l kf kg">4. Dependency on useEffect hook</span><span id="141e" class="kb kc hi jx b fi kh ke l kf kg">5. useCallback</span><span id="9ce9" class="kb kc hi jx b fi kh ke l kf kg">6. state</span><span id="eb28" class="kb kc hi jx b fi kh ke l kf kg">7. Custom Hooks</span><span id="8aee" class="kb kc hi jx b fi kh ke l kf kg">8. Regular functions vs arrow functions</span><span id="ee2e" class="kb kc hi jx b fi kh ke l kf kg">9. useState</span><span id="a705" class="kb kc hi jx b fi kh ke l kf kg">10. useEffect</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="9d8c" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">主题1: </strong>闭包</p></blockquote><p id="37ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当一个函数能够记住并访问它的词法范围时，即使这个函数是在它的词法范围之外执行的，这就叫做闭包。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="56c7" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">话题2:</strong>React挂钩是如何工作的？</p></blockquote><p id="3ddb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">钩子是在用户界面中封装有状态行为和副作用的一种非常简单的方法。它们最初被引入React，并被Vue、Svelte等其他框架广泛采用，甚至被用于一般的函数式JS。然而，它们的功能设计需要对JavaScript中的闭包有很好的理解。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="83d3" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">话题三:</strong>使用备忘录挂钩</p></blockquote><p id="cfab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">useMemo返回一个记忆值。<br/>传递一个“创建”函数和一个依赖数组。useMemo只会在其中一个依赖关系发生变化时重新计算memoized值。这种优化有助于避免每次渲染时进行昂贵的计算。<br/>如果没有提供数组，将在每次渲染时计算一个新值。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="4753" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">主题4: </strong>对useEffect挂钩的依赖</p></blockquote><p id="ccf8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我说的是useEffect hook的第二个参数。如果我们改变第二个参数的值，useEffect钩子将刷新。</p><p id="7fe8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4a3d" class="kb kc hi jx b fi kd ke l kf kg">useEffect(() =&gt; {<br/>    console.log(`You clicked ${count} times`)<br/>}, count)</span></pre><p id="241c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，如果我们改变count的值，useEffect钩子将刷新。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="21c6" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">主题5: </strong>使用回调</p></blockquote><p id="59a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些钩子防止了不必要的重新渲染，使得我们的代码更加高效。它返回一个记忆的回调</p><p id="95ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="dff4" class="kb kc hi jx b fi kd ke l kf kg">const memoizedCallback = useCallback(() =&gt; {<br/>    doSomething(a, b);<br/>}, [a, b],)</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="46ee" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">话题6: </strong>状态</p></blockquote><p id="a40f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们在类组件中使用<strong class="iw hj">‘state’</strong>。但是在功能组件中，我们使用了useState钩子而不是State，并且<strong class="iw hj">‘useState’</strong>的工作与<strong class="iw hj">‘state’</strong>相同。</p><p id="e48b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4f16" class="kb kc hi jx b fi kd ke l kf kg">const [value, setValue] = useState(initialValue);</span></pre><p id="bf6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里的值是类组件中的状态。要改变状态的值，我们可以使用setValue函数</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="6a5d" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">话题七:</strong>定制挂钩</p></blockquote><p id="bde4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">定制钩子允许我们创建可以跨不同组件重用的功能。当然，你可以只使用函数来重用功能，但是钩子带来的好处是能够“挂钩”到组件生命周期和状态之类的东西。这使得它们在React世界中比常规函数更有价值。要创建自定义挂钩，挂钩名称将以“use”开头。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="a5b4" class="kb kc hi jx b fi kd ke l kf kg">import React, { useState } from "react";</span><span id="430a" class="kb kc hi jx b fi kh ke l kf kg">const useInputValue = initialValue =&gt; {<br/>    const [value, setValue] = useState(initialValue);<br/>    <br/>    return {<br/>        value,<br/>        onChange: event =&gt; {<br/>            setValue(event.target.value || event.target.innerText);<br/>        };<br/>    };<br/>};</span><span id="86dc" class="kb kc hi jx b fi kh ke l kf kg">export default useInputValue;</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="1171" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">话题8: </strong>常规函数vs箭头函数</p></blockquote><p id="c13d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">箭头功能是ES6中引入新功能。尽管常规函数和箭头函数的工作方式相似，但它们之间也存在一些差异。看这个例子:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="ab73" class="kb kc hi jx b fi kd ke l kf kg">const person = {<br/>      name: "Khan",<br/>      func1:() =&gt; {<br/>          console.log("From arrow function: " + this.name); <br/>          // no 'this' binding here<br/>      },<br/>      func2(){<br/>          console.log("From regular function: " + this.name); <br/>          // 'this' binding works here<br/>      }<br/>}</span><span id="f509" class="kb kc hi jx b fi kh ke l kf kg">person.func1()  // From arrow function: undefined<br/>person.func2()  // From regular function: Khan</span></pre><p id="3eac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看另一个例子:</p><p id="0e29" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="ks">常规功能:</em> </strong></p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="750c" class="kb kc hi jx b fi kd ke l kf kg">const person = {<br/>    show(){<br/>        console.log(arguments);<br/>        // { '0': 1, '1': 2, '2': 3 }<br/>    }<br/>};</span><span id="6f2f" class="kb kc hi jx b fi kh ke l kf kg">person.show(1, 2, 3);</span></pre><p id="289c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="ks">箭头功能:</em> </strong></p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="72de" class="kb kc hi jx b fi kd ke l kf kg">const person = {<br/>    show : () =&gt; {<br/>        console.log(...arguments);<br/>        // arguments is not defined<br/>    }<br/>};</span><span id="e080" class="kb kc hi jx b fi kh ke l kf kg">person.show(1, 2, 3);</span></pre><p id="bc73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Arguments对象在箭头函数中不可用，但在常规函数中可用。</p><blockquote class="kp kq kr"><p id="81f8" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">主题9: </strong>使用状态</p></blockquote><p id="a006" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">useState是一个内置的钩子，我们需要从react包中导入它。我们可以在功能组件中使用这个钩子。有一个变量和一个函数可以改变useState钩子中变量的值。让我们看一个例子:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0dc9" class="kb kc hi jx b fi kd ke l kf kg">import React, { useState } from 'react';</span><span id="a17b" class="kb kc hi jx b fi kh ke l kf kg">function App() {<br/>    const [count, setCount] = useState(0);</span><span id="582b" class="kb kc hi jx b fi kh ke l kf kg">    return (<br/>        &lt;div&gt;<br/>            &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>                Click here to increase count<br/>            &lt;/button&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="9b6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们声明了一个新的状态变量，叫做“count”。为了改变变量，我们声明了“setCount”函数。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="d395" class="iu iv ks iw b ix iy iz ja jb jc jd je kt jg jh ji ku jk jl jm kv jo jp jq jr hb bi translated"><strong class="iw hj">话题10: </strong>使用效果</p></blockquote><p id="e348" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">useEffect是一个内置的钩子，我们需要像useState一样从react包中导入它。useEffect是一个钩子，用于封装有“副作用”的代码。它接受一个函数作为参数。该函数在组件首次渲染时运行，并在随后的每次重新渲染/更新时运行。React首先更新DOM，然后调用传递给useEffect()的任何函数。让我们看一个例子:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4157" class="kb kc hi jx b fi kd ke l kf kg">import React, { useState, useEffect } from 'react';</span><span id="8306" class="kb kc hi jx b fi kh ke l kf kg">function App() {<br/>    const [count, setCount] = useState(0);</span><span id="52f8" class="kb kc hi jx b fi kh ke l kf kg">    useEffect(() =&gt; {<br/>        console.log(`You clicked ${count} times`)<br/>    }, count)</span><span id="3010" class="kb kc hi jx b fi kh ke l kf kg">    return (<br/>        &lt;div&gt;<br/>            &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>                Click here to increase count<br/>            &lt;/button&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="c73b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每当count的值改变时，useEffect就会刷新。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="8c4c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="ks">更多信息，请访问:</em></p><div class="kw kx ez fb ky kz"><a href="https://reactjs.org" rel="noopener  ugc nofollow" target="_blank"><div class="la ab dw"><div class="lb ab lc cl cj ld"><h2 class="bd hj fi z dy le ea eb lf ed ef hh bi translated">react——用于构建用户界面的JavaScript库</h2><div class="lg l"><h3 class="bd b fi z dy le ea eb lf ed ef dx translated">React使得创建交互式ui变得不那么痛苦。为应用程序中的每个状态设计简单的视图，并反应…</h3></div><div class="lh l"><p class="bd b fp z dy le ea eb lf ed ef dx translated">reactjs.org</p></div></div><div class="li l"><div class="lj l lk ll lm li ln io kz"/></div></div></a></div><p id="9b13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">今天到此为止。</p></div></div>    
</body>
</html>