<html>
<head>
<title>Demystify Transposed Convolutional Layers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开转置卷积层的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/demystify-transposed-convolutional-layers-6f7b61485454?source=collection_archive---------15-----------------------#2020-04-25">https://medium.com/analytics-vidhya/demystify-transposed-convolutional-layers-6f7b61485454?source=collection_archive---------15-----------------------#2020-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转置卷积层广泛应用于自动编码器和生成对抗网络(GAN)中，作为一种数据上采样的方法。</p><p id="5131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的概念，但在我的学习过程中，我被大量不一致的材料搞糊涂了。因此，我想创建这个教程，使用动画和PyTorch代码来清楚地解释转置卷积层的参数和数学。所有源文件都在我的<a class="ae jd" href="https://github.com/RyC37/Demystify-Transposed-Convolutional-Layers" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Github Repo </strong> </a>上。</p><p id="47c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">鸣谢:</strong>动画设计的风格灵感来源于<a class="ae jd" href="https://github.com/vdumoulin/conv_arithmetic" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">conv _算术</strong> </a>。(虽然，它在我的学习过程中让我很困惑。)</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="0d9b" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak"> 1。默认情况</strong></h2><p id="ed05" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">先说最简单的情况。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/d4d3fc43e30182c0c1ba2cb1cbec4607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FZ6mACe7DJLjvD3LLCn9TQ.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图一。默认情况。</figcaption></figure><p id="9d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图1显示了转置卷积层的计算过程，其中<em class="lb"> kernel_size </em>为3，其他参数设置为默认值。输入(2x2)和输出(4x4)的尺寸很容易识别。</p><p id="0c75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一步一步的计算过程。如动画所示，生成最终输出有4个步骤。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/c0a0f0a87d387d857e73ba0d2c23b8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Blv7vr9sMAmfYTTgKCKGVw.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图二。基本情况的计算步骤</figcaption></figure><p id="ffa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用PyTorch来验证相同的计算:</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="ld le l"/></div></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="a4a4" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">2.进展</h2><p id="dca9" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">接下来，我们将更改参数<strong class="ih hj">步距</strong>，其他一切与第一种情况相同。</p><p id="ab0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://pytorch.org/docs/stable/nn.html#convtranspose2d" rel="noopener ugc nofollow" target="_blank"> PyTorch文件</a>指出:</p><blockquote class="lf lg lh"><p id="f676" class="if ig lb ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated"><code class="du ll lm ln lo b">stride</code>控制互相关的步距。</p></blockquote><p id="c8c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该文件仅供参考。就我个人而言，一开始我并不理解。但是下面的可视化应该是清楚的。stride的默认值是1，这里我们将stride设置为2。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/896e4fb7b9f823b29e0fef9d3bf2d61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*na8U3QpHwuAB3R9QohQC1w.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图三。将参数步幅设置为2</figcaption></figure><p id="cbb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到，在每个乘法步骤之后，核矩阵水平移动2步，直到到达终点，然后垂直移动2步，从头开始。</p><p id="a637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看计算过程:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/fe8282eb41a569aa581576f8f3ed07ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsqJh7WU7ARUGZ-jgvF1dw.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图4。步幅= 2时的计算步骤</figcaption></figure><p id="fcba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用pytorch来验证一下:</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="ld le l"/></div></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="9cea" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">3.填料</h2><p id="c222" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">我们将继续基于步幅情况进行构建，这次我们将参数<strong class="ih hj">填充</strong>更改为1。在以前的情况下，填充具有默认值0。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/686b1c3892e7b292d8644b1a0919a56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4KKbju-YNsbvDSfYlIHFVg.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图五。将参数填充设置为1。</figcaption></figure><p id="e0bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，最终输出是中心3×3矩阵。你可以把它解释为，在计算之后，丢弃矩阵的边界单元。你应该可以想象，如果我们设置填充等于2，结果将是中心单元格(1x1)。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/b63051f23a3524326451d882d4243d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HokEeAWSt_rwzREUdyFWCQ.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图六。步幅= 2、填充= 1时的计算步骤</figcaption></figure><p id="ebcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图6显示了计算过程，正如您所看到的，它几乎与图4相同。唯一的区别是我们“移除”了外层细胞。</p><p id="e317" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看PyTorch是否同意我们的观点:</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="ld le l"/></div></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="62b4" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">4.输出填充</h2><p id="7050" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">是的，我们有另一种衬垫。他们的区别很简单:</p><blockquote class="lf lg lh"><p id="3785" class="if ig lb ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">输出填充向输出的一侧添加单元格，而填充从输出的两侧移除单元格。</p></blockquote><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/d22230daf04e9bb980a491ae1fb281b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8KQDwfmCJpBZAS4BWQAHFg.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图7。将output_padding设置为1。</figcaption></figure><p id="fb6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们将参数<strong class="ih hj"> output_padding </strong>设置为1(默认为0)，将<strong class="ih hj"> stride </strong>设置为2。如图7所示，输出矩阵的一侧添加了单元格，其值为0。</p><p id="a89e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您对此有任何理解上的困难，请随意比较图7和图3。</p><p id="1802" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是计算步骤:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/8be487b1a97f70cdf298f619e903ee1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-TG8mr4E2QdPBRy0pKmZA.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图8。output_padding = 1，stride = 2时的计算步骤</figcaption></figure><p id="17dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再和PyTorch确认一下。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="ld le l"/></div></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="08d3" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">5.扩张</h2><p id="cef4" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated"><strong class="ih hj">膨胀</strong>影响内核矩阵的结构。</p><p id="46f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyTorch文档指出，</p><blockquote class="lf lg lh"><p id="952d" class="if ig lb ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated"><code class="du ll lm ln lo b">dilation</code>控制内核点之间的间距；</p></blockquote><p id="844c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不知道我第一次看到这个是什么时候，因为它非常抽象。然而，看看图9，您也许能够理解它。为了使事情变得简单，我们在这个例子中使用2x2内核。(在前面的例子中，我们使用的是3x3内核。)</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/57bc50515ee2d73d1615f14ef6e1abf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCr3pn2WQ_yv_Lt6Litnvw.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图九。具有不同膨胀值的核矩阵。</figcaption></figure><p id="9da5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面是不同膨胀值的核矩阵的样子。基本上，如果膨胀值是<strong class="ih hj"> <em class="lb"> n </em> </strong>，那么内核矩阵就会被插入<strong class="ih hj"> <em class="lb"> n-1 </em> </strong>单元格填充0。在这一点上，不难想象对更大的核矩阵进行同样的变换。其余的计算与之前相同，如图10所示。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/cd34b048e2b9928577405ecbe8ed47bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XJpA0zdmc80seyqZODSF7Q.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图10。设置内核为2，步幅为2，膨胀为2。</figcaption></figure><p id="3797" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了澄清，在图10中，我通过使0值的内核单元透明而忽略了它。</p><p id="ce39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是计算步骤:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/27a0d23ac59a5e1fb9b75b4e2d9f01fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FL5feyXLuewR3duDj6vww.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">图11。内核= 2、步距= 2、膨胀= 2时的计算步骤。</figcaption></figure><p id="4a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是PyTorch的实现。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="ld le l"/></div></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h2 id="a340" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated"><strong class="ak"> 6。输出形状背后的数学运算</strong></h2><p id="6716" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">最后，让我们通过推导输出大小的公式来结束本教程。如果您想更深入地了解转置卷积层，只需阅读这一部分，否则请随意跳过。</p><p id="281d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出大小公式的为:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lp"><img src="../Images/65ccf8e87333c37c1c904071cb0e5c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRJw1colfm5tqfJfFB_1KA.png"/></div></div></figure><p id="7d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> n </strong>为输出大小(<strong class="ih hj"> n </strong> x <strong class="ih hj"> n </strong>矩阵)，<strong class="ih hj"> m </strong>为输入大小(<strong class="ih hj"> m </strong> x <strong class="ih hj"> m </strong>矩阵)。此外，公式中有5个参数:<strong class="ih hj"> K </strong>为内核大小，<strong class="ih hj"> S </strong>为步长值，<strong class="ih hj"> P </strong>为填充值，<strong class="ih hj"> D </strong>为膨胀值，<strong class="ih hj"> P_out </strong>为输出_填充值。</p><p id="151d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这看起来很复杂，但实际上很简单。让我们一步一步来看。</p><p id="cc23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (1)只考虑S(步幅)和K(内核大小)</strong></p><p id="5b66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为输入的大小是m，所以我们有m*m步的计算。但是我们实际上只需要考虑前m步，因为前m步会固定输出矩阵的宽度。</p><p id="313b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以想象随着计算的进行，输出会逐渐增加，如图2，4，6，8，11所示。</p><ul class=""><li id="9393" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated"><em class="lb">在</em> <strong class="ih hj"> <em class="lb">第1个</em> </strong> <em class="lb">步骤中，输出尺寸为</em> <strong class="ih hj"> <em class="lb"> K </em> </strong> <em class="lb">。</em></li><li id="aa72" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><em class="lb">在</em> <strong class="ih hj"> <em class="lb">第二个</em> </strong> <em class="lb">步骤中，中间矩阵移位由</em> <strong class="ih hj"> <em class="lb"> S </em> </strong> <em class="lb">，所以输出大小为</em><strong class="ih hj"><em class="lb">K+S</em></strong><em class="lb">。</em></li><li id="82e5" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><em class="lb">在</em> <strong class="ih hj"> <em class="lb">第三个</em> </strong> <em class="lb">步骤中，中间矩阵由</em> <strong class="ih hj"> <em class="lb"> S </em> </strong> <em class="lb">，所以输出大小为</em><strong class="ih hj"><em class="lb">K+2S</em></strong><em class="lb">。</em></li><li id="f7f4" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><em class="lb">在第</em> <strong class="ih hj"> <em class="lb"> m- </em> </strong> <em class="lb">步中，中间矩阵由</em><strong class="ih hj"><em class="lb"/></strong><em class="lb">S移位，所以输出大小为</em><strong class="ih hj"><em class="lb">(m-1)S</em></strong><em class="lb">。</em></li></ul><p id="be89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们只考虑<strong class="ih hj"> S </strong>和<strong class="ih hj"> K </strong>，则公式为:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es me"><img src="../Images/18c4ccac72e86aced2ee165c7e15b1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZUe9JH7M7INAklIYSdbwQ.png"/></div></div></figure><p id="0109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (2)考虑D(膨胀)</strong></p><p id="586f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经讨论过的，膨胀改变了内核的大小。这里，让我们用<strong class="ih hj">K’</strong>来表示变换后的内核大小。如图9所示，膨胀转换在内核中插入<strong class="ih hj"> (K-1)(D-1) </strong>细胞。因此，<strong class="ih hj"> K' </strong>、<strong class="ih hj"> K </strong>、<strong class="ih hj"> D </strong>之间的关系应为:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es mf"><img src="../Images/8a0a8e125b9e935ff48360ab3495928e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzhI9FQtZJ6paaLkVVRoHw.png"/></div></div></figure><p id="6978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们有:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es mg"><img src="../Images/f5573415a927cf3cc0c83781ba527395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xMac5hpXSHCQ0hdP8j8bQ.png"/></div></div></figure><p id="978d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将(2)中的<strong class="ih hj"> K </strong>替换为<strong class="ih hj">K’</strong>，我们有:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es mg"><img src="../Images/6126ab9ce3212562903e90bfd95185ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtWnci2_XGUA8ppiiZBVRw.png"/></div></div></figure><p id="959d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们差不多完成了，剩下的参数很容易理解。</p><p id="08de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (3)考虑P(填充)和P_out(输出_填充)</strong></p><p id="ab4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于填充删除了两边的单元格，所以它对输出大小的影响是- <strong class="ih hj"> 2P </strong>。同样，output_padding在1侧添加单元格，所以它对输出大小的影响是<strong class="ih hj"> +P_out </strong>。将这些片段加入到(4)中，我们就得出了(1)。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="04e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程到此结束。感谢阅读！我希望本教程有助于您更深入地了解转置卷积层。</p><p id="63b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请随时留下评论。欢迎所有建议、问题！</p></div></div>    
</body>
</html>