<html>
<head>
<title>Auto-ML using Genetic Algorithm for Regression tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于遗传算法的回归任务自动建模</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/auto-ml-using-genetic-algorithm-for-regression-tasks-8b6048fb6344?source=collection_archive---------24-----------------------#2020-07-03">https://medium.com/analytics-vidhya/auto-ml-using-genetic-algorithm-for-regression-tasks-8b6048fb6344?source=collection_archive---------24-----------------------#2020-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cfb5df739620ec635f5f005a25f49ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rY_7GLzl0gvDbeiUcojVtg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.bioedge.org/bioethics/will-ivf-affect-human-evolution/13071" rel="noopener ugc nofollow" target="_blank">https://www . bio edge . org/bio ethics/will-IVF-affect-human-evolution/13071</a></figcaption></figure><p id="b8e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些带有分类和回归任务的数据科学项目让我意识到，尽管每个问题都有它自己的解决方案，但在我正在做的事情中肯定有一些冗余。就像许多雄心勃勃的数据科学家一样，我想我会一劳永逸地自动化这个过程。</p><blockquote class="jt ju jv"><p id="cf62" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">为什么要浪费一个小时手动操作，而你可以花10个小时自动操作，对吗？:D</p></blockquote><p id="c329" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在创建预测模型时，我们会一次又一次地遇到相同的方法——清理数据、对分类变量进行编码、估算缺失值、选择算法并最终训练模型。为了使过程更加复杂，我们对过程的每一步都有同样多的参数。那么，如何在众多配置中进行选择呢？</p><p id="e7dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，你可以研究变量的分布，当你有数百个特征时，这是一种痛苦，然后研究离群值，但当我们进行在线学习时，即使离群值的行为也会随着时间而变化。类似地，有无数种方法来准备你的模型，但是大多数工作流程都需要很长时间。但是，由于这种准备是一次性的任务，如果我们有一台计算机通过有组织的方式为我们进行参数搜索，以寻找一个可接受的配置，会怎么样？即使这样的解决方案需要几天的时间，但是只要我们需要创建新的模型，这个解决方案就可以工作。这种方法就是我们所说的Auto-ML。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/ae0f2eb5eff9e81017252f1e8fc36cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcIzL9X3X4j_shzXyM-Y7A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://robohub.org/from-disembodied-bytes-to-robots-that-think-and-act-like-humans/" rel="noopener ugc nofollow" target="_blank">https://robo hub . org/from-disembedded-bytes-to-robots-the-think-and-act-like-humans/</a></figcaption></figure><p id="46fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这篇文章，我们将保持简单。我们仅尝试解决一个经典回归问题(鲍鱼年龄预测)的特征变换。你可以在这里找到数据的链接——<a class="ae iu" href="https://archive.ics.uci.edu/ml/datasets/abalone" rel="noopener ugc nofollow" target="_blank">鲍鱼年龄预测数据</a>。鲍鱼是海螺，发现它们年龄的过程是一个漫长的过程。但是有些东西更容易测量，比如体重，它可以用来预测年龄。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/99b981ebb00d72d8ca9e9d0da2b81e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfudmlCr9wjpocLjgfgb4g.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.theguardian.com/environment/2018/aug/19/poachers-abalone-south-africa-seafood-divers" rel="noopener ugc nofollow" target="_blank">https://www . the guardian . com/environment/2018/aug/19/偷猎者-鲍鱼-南非-海鲜-潜水员</a></figcaption></figure><p id="bf34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">鲍鱼数据包含以下信息-</p><ul class=""><li id="3429" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">性</li><li id="eec2" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">长度</li><li id="3c72" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">直径</li><li id="5c5b" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">高度</li><li id="095f" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">整体重量</li><li id="4bbb" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">去皮重量</li><li id="6462" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">内脏重量</li><li id="1ec3" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">外壳重量</li><li id="9448" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">戒指</li></ul><p id="28fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于这些栏目的详细说明可以在这里找到—<a class="ae iu" href="https://www.kaggle.com/rodolfomendes/abalone-dataset" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/rodolfomendes/abalone-dataset</a></p><p id="2a2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目标是预测环的数量。我们把这项任务当作一个回归问题来处理。并且作为子问题，我们试图为每个特征列找到最佳变换，以使环数的预测值和真实值之间的均方误差最小。</p><h1 id="8697" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">搜索空间设计</h1><p id="6932" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">我们在一些标准转换中寻找特性列。在这个问题中，我们将使用以下变换-</p><ul class=""><li id="2cc2" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">对数</li><li id="8902" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">指数的</li><li id="33a2" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">平方</li><li id="9f2b" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">平方根</li></ul><p id="bee2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们可以选择保持功能不变。</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="1e79" class="mc kv hi ly b fi md me l mf mg">trans_choices = ['exp','log','square','sqrt','None']</span></pre><p id="39d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们为每一列选择上述转换之一，并将所有转换组合在一起，我们就得到一个配置。这部分是遗传算法的用武之地。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/c22c69e08a9da21be118b7b5a422ac17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKqoZP4YSf2L_F7iINzUGA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://towardsdatascience.com/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3#:~:text=A%20genetic%20algorithm%20is%20a,offspring%20of%20the%20next%20generation" rel="noopener" target="_blank">遗传算法简介—包括示例代码</a></figcaption></figure><p id="9dd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">遗传算法是一种人工智能技术，经常用于运筹学任务。顾名思义，它的灵感来自于自然选择和进化的过程。它包括以下几个方面</p><ul class=""><li id="ca28" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">使用不同的工艺参数定义染色体结构</li><li id="f43e" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">在这种情况下，每个参数就像是构成染色体的基因</li><li id="737b" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">每个基因/参数占用不同的值</li><li id="bbaa" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">基因的值组成了染色体，可以对染色体的适合度进行评估</li><li id="6550" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">使用目标函数(在我们的例子中是模型的准确性)来计算适合度</li></ul><p id="a54e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，遗传算法的关键要素是，我们使用两种不同的配置，称为父母，并使用他们来创建后代。父母是从一个群体中挑选出来的，随着过程的开始，这个群体不断偏向于更强壮的染色体或配置。因此，简单地说，在每次迭代中，我们从群体中挑选两个亲本配置，并通过组合来自两个亲本的基因/参数值来创建后代。我们根据目标函数计算后代的适应度或强度。如果孩子表现良好，我们会分配给它在群体中更高的生存机会。如果后代表现不佳，我们会减少它存活的机会。</p><p id="a697" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个过程导致种群包含更多更强的染色体或配置，并且当我们看不到子代配置的任何变化时，该过程收敛。</p><h1 id="02a6" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">时间到了</h1><p id="58f0" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">让我们看看如何用python实现这个过程</p><h2 id="735e" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤1:导入库</h2><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="51bf" class="mc kv hi ly b fi md me l mf mg">import numpy as np <br/>import pandas as pd  <br/>import lightgbm  <br/>import scipy<br/>from sklearn import metrics <br/>from sklearn.preprocessing <br/>import StandardScaler <br/>from sklearn.model_selection import train_test_split <br/>from sklearn.metrics <br/>import mean_squared_error as acc  <br/>import random <br/>import warnings warnings.filterwarnings('ignore') np.random.seed(100)</span></pre><h2 id="a837" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤2:创建随机配置</h2><p id="59ac" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">该函数使用转换空间中的一个选项为每个列创建一个配置设置</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="40f9" class="mc kv hi ly b fi md me l mf mg">def create_random_config(trans_choices, config_cols):     <br/>    config = []     <br/>    for col in config_cols:<br/>        config.append(random.choice(trans_choices))     <br/>    return config</span></pre><h2 id="07fa" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">第三步:变压器</h2><p id="56ed" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">该函数接收训练数据，并根据“create_random_config”函数选择的配置对其进行转换</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="07bb" class="mc kv hi ly b fi md me l mf mg">def transformer(dft, dfv, config, config_cols):<br/>    dft2 = dft.copy()<br/>    dfv2 = dfv.copy()<br/>    for index in range(0,len(config_cols)):<br/>        if config[index] == 'exp':<br/>            dft2[config_cols[index]] = np.exp(dft[config_cols[index]])<br/>            dfv2[config_cols[index]] = np.exp(dfv[config_cols[index]])<br/>        elif config[index] == 'log':<br/>            dft2[config_cols[index]] = np.log(dft[config_cols[index]])<br/>            dfv2[config_cols[index]] = np.log(dfv[config_cols[index]])<br/>        elif config[index] == 'sqrt':<br/>            dft2[config_cols[index]] = np.sqrt(dft[config_cols[index]])<br/>            dfv2[config_cols[index]] = np.sqrt(dfv[config_cols[index]])<br/>        elif config[index] == 'square':<br/>            dft2[config_cols[index]] = np.square(dft[config_cols[index]])<br/>            dfv2[config_cols[index]] = np.square(dfv[config_cols[index]])<br/>        else:<br/>            dft2[config_cols[index]] = dft[config_cols[index]]<br/>            dfv2[config_cols[index]] = dfv[config_cols[index]]<br/>    return dft2, dfv2</span></pre><h2 id="1cdf" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">第四步:获得分数</h2><p id="1f08" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">根据模型准确性评估配置。这里出于示例目的选择的模型是<a class="ae iu" href="https://github.com/microsoft/LightGBM" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>。</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="dc3f" class="mc kv hi ly b fi md me l mf mg">def get_score(dft2, dfv2, verbose = False):<br/>        X_train, X_test, y_train, y_test = train_test_split(dft2.drop(columns = ['y']), dft2['y'], test_size=0.20, random_state=1)<br/>        X_train = X_train.fillna(0)<br/>        X_test = X_test.fillna(0)<br/>        y_train = y_train.fillna(0)<br/>        y_test = y_test.fillna(0)</span><span id="3943" class="mc kv hi ly b fi mv me l mf mg">trained_model = lightgbm.LGBMRegressor(<br/>                  boosting_type = 'gbdt',<br/>                  max_depth = 6,<br/>                  n_estimators = 100000,  <br/>                  learning_rate = 0.05,<br/>                  objective = 'regression',<br/>                  n_jobs = -1,<br/>                  random_state  = 100,<br/>#                   device = 'gpu',<br/>#                   gpu_platform_id = 0,<br/>#                   gpu_device_id = 0,<br/>                  num_leaves = 7<br/>             trained_model.fit(<br/>                            X_train, y_train,<br/>                            eval_set=[(X_test, y_test)],<br/>                            eval_metric = 'rmse',<br/>                            early_stopping_rounds = 100,<br/>                            verbose = verbose<br/>                        )<br/>            <br/>        result = trained_model.predict(dfv2.drop(columns = 'y')).round(0)<br/>        score = acc(dfv2['y'],result)<br/>        return score</span></pre><h2 id="401d" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤5:创建配置搜索空间</h2><p id="1629" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">此功能使用所有评分配置创建一个搜索空间，其中包含更多高评分配置实例。这实现了基因进化的过程，通过选择那些得分较高的基因来创建更好的子代配置。该方法中的随机性会导致噪声，但结果显示准确度得分呈上升趋势。偏差因子决定了如何设计配置。对于下面的实现，我们使用范围[(n_iter X 0.1/5，0)，(n_iter/5，0)]之间的随机偏差因子，其中n_iter是我们运行算法的总迭代次数。一旦我们有了一定数量的分数配置来创建配置空间，该函数用于创建配置的搜索空间。</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="4083" class="mc kv hi ly b fi md me l mf mg">def create_config_space(all_scored_configs, n_iter):<br/>    sorted_configs = sorted(all_scored_configs, key=lambda row: row[-1], reverse = True)[-1*random.randint(round(n_iter*0.1/5,0),round(n_iter/5,0)):]<br/>    config_space = []<br/>    for index in range(0,len(sorted_configs)):<br/>        repeated_configs = [sorted_configs[index] for i in range((index+1)*random.randint(1,6))]<br/>        config_space.extend(repeated_configs)<br/>    return config_space</span></pre><h2 id="73ba" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤6:创建子配置</h2><p id="d649" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">该函数使用从配置空间中随机选择的2个父配置，并在每个子基因的父个体基因值之间随机选择</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="1358" class="mc kv hi ly b fi md me l mf mg">def create_child(parent1, parent2):<br/>    child = []<br/>    for index in range(0,len(parent1)-1):<br/>        child.append(random.choice([parent1[index],parent2[index]]))<br/>    return child</span></pre><h2 id="7f2b" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤7:找到最佳配置</h2><p id="25e3" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">该函数将查找最佳配置的过程封装在以下步骤中-</p><ul class=""><li id="ab87" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">对于一半的迭代次数，我们为列转换创建随机配置</li><li id="7025" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">对于剩余的一半迭代，我们使用配置的分数来创建配置空间，以给予具有较高分数的配置更多的重要性</li><li id="0b81" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">从配置空间中，以相等的概率随机选择2个父配置。配置空间本身偏向于具有更多数量的更强的染色体/配置</li><li id="c46e" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">整个过程完成后，选择最佳配置。最终配置是在上述过程中评分的所有配置中得分最高的一个</li></ul><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="6da0" class="mc kv hi ly b fi md me l mf mg">def find_best_config(dft, dfv, config_cols, trans_choices, src, n_iter = 100):<br/>    iter_data = []<br/>    for itr in range(len(iter_data),n_iter):<br/>        if itr &lt; round(n_iter/2,0):<br/>            config = create_random_config(trans_choices = trans_choices, config_cols = config_cols)<br/>            dft2, dfv2 = transformer(dft,dfv,config, config_cols = config_cols)<br/>            score = get_score(dft2, dfv2)<br/>            print('Score = ',score)<br/>            iter_row = config<br/>            iter_row.append(score)<br/>            iter_data.append(iter_row)<br/>        if itr &gt;= round(n_iter/2,0):<br/>            config_space = create_config_space(all_scored_configs = iter_data, n_iter = n_iter)<br/>            parent1, parent2 = random.sample(config_space, 2)<br/>            child = create_child(parent1 = parent1, parent2 = parent2)<br/>            config = child.copy()<br/>            dft2, dfv2 = transformer(dft,dfv,config, config_cols = config_cols)<br/>            score = get_score(dft2, dfv2)<br/>            print('Score = ',score)<br/>            iter_row = config<br/>            iter_row.append(score)<br/>            iter_data.append(iter_row)<br/>    cols = list(dft.columns[:-1])<br/>    cols.append('y')<br/>    results = pd.DataFrame(iter_data, columns = cols) <br/>    results.to_csv(src+'results.csv') ## Save GA results<br/>    best_config = sorted(iter_data, key=lambda row: row[-1], reverse = True)[-1]<br/>    return best_config</span></pre><h2 id="03a6" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤8:准备数据</h2><p id="ae4d" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">该函数读取数据，并将其分为训练数据和验证数据。验证集将以类似于训练数据的方式进行处理，但是来自验证数据的任何信息都不会用于影响模型训练工作流。</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="525d" class="mc kv hi ly b fi md me l mf mg">def prep_data(pata_path, target_col, mode = 'find_final_accuracy'): ########## Must be user defined to have features with whatever column names and label as 'y'<br/>    <br/>    df = pd.read_csv(pata_path)<br/>    <br/>    if mode == 'find_config':<br/>        df = df.sample(min(10000,df.shape[0])).reset_index(drop=True)<br/>    <br/>    df['Sex'] = df['Sex'].map({'M':1,'F':2, 'I':3})<br/>    <br/>    df = df.rename(columns = {target_col:'y'})<br/>    <br/>    s = np.random.uniform(high = df.shape[0]-1, low = 0, size = round(0.1*df.shape[0]))<br/>    s = np.unique(s.round())<br/>    dfv = df.iloc[s,:]<br/>    dft = df.drop(index = s)<br/>    <br/>    print('shape of the overall, training and validation data are as follows - ',df.shape,dft.shape,dfv.shape)<br/>    <br/>    return dft, dfv</span></pre><h2 id="c9bc" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">第九步:忙碌</h2><p id="6307" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">这个函数使用输入来计算整个过程并输出结果</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="ac02" class="mc kv hi ly b fi md me l mf mg">def main(src, filename, n_iter, target_col):<br/>    ## User Inputs<br/>    trans_choices = ["exp","log","square","sqrt","None"]</span><span id="f085" class="mc kv hi ly b fi mv me l mf mg">## Find best config<br/>    dft, dfv = prep_data(pata_path = src+filename, target_col = target_col, mode = 'find_config')<br/>    config_cols = dft.drop(columns = 'y').columns<br/>    best_config = find_best_config(dft, dfv, config_cols, trans_choices, src = src, n_iter = n_iter)</span><span id="e48e" class="mc kv hi ly b fi mv me l mf mg">## Get final accuracy for the data<br/>    df2t, df2v = prep_data(pata_path = src+filename, target_col = target_col)<br/>    df2t2, df2v2 = transformer(dft = df2t, dfv = df2v, config = best_config, config_cols = config_cols)<br/>    score = get_score(df2t2, df2v2, verbose = True)<br/>    print("Final error is - ", score)</span></pre><h2 id="2bb8" class="mc kv hi bd kw mi mj mk la ml mm mn le jg mo mp li jk mq mr lm jo ms mt lq mu bi translated">步骤10:运行流程</h2><p id="0b38" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">这一步必须使用正确的参数值来运行，我们将根据不同配置的得分来获得输出。</p><pre class="kb kc kd ke fd lx ly lz ma aw mb bi"><span id="b3d2" class="mc kv hi ly b fi md me l mf mg">main(<br/>        src = ""<br/>        , filename = "Abalone Data.csv"<br/>        , n_iter = 100<br/>        , target_col = 'Rings'<br/>      )</span></pre><p id="0bc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于该代码的简易笔记本，请遵循— <a class="ae iu" href="https://gitlab.scss.tcd.ie/amittal/automated-data-interpreter/-/blob/master/Automated%20Data%20Interpreter%20(ADI).ipynb" rel="noopener ugc nofollow" target="_blank">自动数据解释器(ADI) </a></p><p id="488f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看到后续配置的均方误差下降，如下所示</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/05fad2394d04a237c81dc4e9992fb382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPeYgIKq7jSq3EcWiWjm1A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">结果</figcaption></figure><p id="9069" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们看到，对于每一列，配置围绕一个变换收敛。根据当前配置搜索状态空间，这些配置为我们提供了最佳结果。为了获得更好的结果，我们只需要用更多的选项和可学习的参数来扩大搜索空间。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/cfed42421f7ec82277d27631900b4723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivzVDzriu1rioDHABanbJg.jpeg"/></div></div></figure><p id="ae28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个过程是优化回归或分类任务的参数搜索的非常简单的方法。参数状态空间可以包括更多的参数，例如</p><ul class=""><li id="7d2d" class="kg kh hi ix b iy iz jc jd jg ki jk kj jo kk js kl km kn ko bi translated">分类变量编码器的类型:<a class="ae iu" href="http://contrib.scikit-learn.org/category_encoders/" rel="noopener ugc nofollow" target="_blank">http://contrib.scikit-learn.org/category_encoders/</a></li><li id="7e30" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">缺失值估算者的类型:【https://scikit-learn.org/stable/modules/impute.html T2】</li><li id="5aac" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">异常值检测器类型:【https://pyod.readthedocs.io/en/latest/ T4】</li><li id="cbe4" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">回归算法:<a class="ae iu" href="https://towardsdatascience.com/catboost-vs-light-gbm-vs-xgboost-5f93620723db" rel="noopener" target="_blank">https://towardsdatascience . com/catboost-vs-light-GBM-vs-xgboost-5f 93620723 db</a></li><li id="e82b" class="kg kh hi ix b iy kp jc kq jg kr jk ks jo kt js kl km kn ko bi translated">所有的步骤也可以进一步分解成参数</li></ul><p id="16ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多细节请参考我之前的文章:<a class="ae iu" href="https://www.linkedin.com/pulse/bigger-blacker-box-lazy-data-scientist-adhishwar-mittal/" rel="noopener ugc nofollow" target="_blank">一个懒惰的数据科学家的更大更黑的盒子</a></p><p id="df56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读。我希望这个过程有一天能帮助你完成数据科学任务。:)</p></div></div>    
</body>
</html>