<html>
<head>
<title>Python Metaclass — Practical use cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python元类——实际用例</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/metaclass-practical-use-cases-a8f24957322?source=collection_archive---------17-----------------------#2019-12-24">https://medium.com/analytics-vidhya/metaclass-practical-use-cases-a8f24957322?source=collection_archive---------17-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c918323c7be4009685e35adcb1a197df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArokwZUTs1rG6P_vGU7zxw.png"/></div></div></figure><p id="a669" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们上一个故事(<a class="ae jo" rel="noopener" href="/analytics-vidhya/metaprogramming-in-python-for-beginners-546adbc76f98">https://medium . com/analytics-vid hya/meta programming-in-python-for-初学者-546adbc76f98 </a>)中，我们看到了元类的基础知识。</p><p id="2f58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将看到一些<code class="du jp jq jr js b">metaclass</code>非常有用的用例。</p><p id="f014" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用例1: </strong>使用<code class="du jp jq jr js b">metaclass</code>创建单例类(重复上一篇文章中的相同场景)</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="7953" class="kb kc hi js b fi kd ke l kf kg"><strong class="js hj">class </strong>SingletonMeta(type):<br/>    _instances = {}<br/><br/>    <strong class="js hj">def </strong>__call__(cls, *args, **kwargs):<br/>        <strong class="js hj">if </strong>cls <strong class="js hj">not in </strong>SingletonMeta._instances:<br/>            obj = super(SingletonMeta, cls).__call__(*args, **kwargs)<br/>            SingletonMeta._instances[cls] = obj<br/>        <strong class="js hj">return </strong>SingletonMeta._instances[cls]<br/><br/><br/><strong class="js hj">class </strong>Singleton(metaclass=SingletonMeta):<br/>    <strong class="js hj">pass<br/><br/><br/></strong>a = Singleton()<br/>b = Singleton()<br/>print(a <strong class="js hj">is </strong>b)</span></pre><p id="9d18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:</strong></p><ol class=""><li id="b8f0" class="kh ki hi is b it iu ix iy jb kj jf kk jj kl jn km kn ko kp bi translated">每当该类被用作可调用的对象时(即在对象创建期间)，在我们的元类上定义的<code class="du jp jq jr js b">__call__</code>方法就会被调用。</li><li id="1392" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">我们在我们的<code class="du jp jq jr js b">metaclass</code>上维护了一个字典<code class="du jp jq jr js b">_instances</code>来映射每个类及其新创建的对象。</li><li id="b134" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">如果这个类在<code class="du jp jq jr js b">_instances</code>字典中已经有了一个对象，我们返回相同的对象，而不是再次创建它。</li></ol><p id="9429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用例2: </strong>我们如何使用<code class="du jp jq jr js b">metaclass</code>来创建类的注册表？</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="0acc" class="kb kc hi js b fi kd ke l kf kg"><strong class="js hj">class </strong>Animal(type):<br/>    _register = {}<br/><br/>    <strong class="js hj">def </strong>__new__(cls, name, bases, dct):<br/>        class_ = super(Animal, cls).__new__(cls, name, bases, dct)<br/>        <strong class="js hj">if </strong>name <strong class="js hj">not in </strong>Animal._register:<br/>            Animal._register[name] = class_<br/>        <strong class="js hj">return </strong>class_<br/><br/>    <strong class="js hj">@classmethod</strong><br/>    <strong class="js hj">def </strong>list_animals(cls):<br/>        <strong class="js hj">print</strong>(cls._register)<br/><br/><br/><strong class="js hj">class </strong>Dog(metaclass=Animal):<br/>    <strong class="js hj">pass<br/><br/><br/>class </strong>Cat(metaclass=Animal):<br/>    <strong class="js hj">pass<br/><br/><br/>class </strong>Shark(metaclass=Animal):<br/>    <strong class="js hj">pass<br/><br/><br/></strong>Animal.list_animals()</span></pre><p id="2031" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:</strong></p><ol class=""><li id="f317" class="kh ki hi is b it iu ix iy jb kj jf kk jj kl jn km kn ko kp bi translated">元类<code class="du jp jq jr js b">Animal</code>维护一个字典<code class="du jp jq jr js b">_register</code>，其中保存了类名和类之间的引用。</li><li id="b2d0" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">元类<code class="du jp jq jr js b">Animal</code>上的方法<code class="du jp jq jr js b">list_animals</code>使用字典<code class="du jp jq jr js b">_register</code>中的数据显示动物列表</li></ol><p id="5a65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用例3: </strong>元类定制类的创建</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="fb3a" class="kb kc hi js b fi kd ke l kf kg"><strong class="js hj">class </strong>Animal:<br/>    <strong class="js hj">def </strong>__init__(self, type, count):<br/>        self.type = type<br/>        self.count = count<br/><br/>    <strong class="js hj">def </strong>__repr__(self):<br/>        <strong class="js hj">return f"{</strong>self.name<strong class="js hj">}:{</strong>self.type<strong class="js hj">}:{</strong>self.count<strong class="js hj">}"<br/><br/><br/>class Zoo</strong>Meta(type):<br/>    <strong class="js hj">def </strong>__new__(cls, name, bases, dct):<br/>        animals = []<br/>        <strong class="js hj">for </strong>key, val <strong class="js hj">in </strong>dct.items():<br/>            <strong class="js hj">if </strong>isinstance(val, Animal):<br/>                val.name = key<br/>                animals.append(val)<br/>        dct[<strong class="js hj">"herbivores"</strong>] = [animal <strong class="js hj">for </strong>animal <strong class="js hj">in </strong>animals <strong class="js hj">if </strong>animal.type == <strong class="js hj">"herbivore"</strong>]<br/>        dct[<strong class="js hj">"carnivores"</strong>] = [animal <strong class="js hj">for </strong>animal <strong class="js hj">in </strong>animals <strong class="js hj">if </strong>animal.type == <strong class="js hj">"carnivore"</strong>]<br/>        dct[<strong class="js hj">"total_herbivores"</strong>] = sum([animal.count <strong class="js hj">for </strong>animal <strong class="js hj">in </strong>dct[<strong class="js hj">"herbivores"</strong>]])<br/>        dct[<strong class="js hj">"total_carnivores"</strong>] = sum([animal.count <strong class="js hj">for </strong>animal <strong class="js hj">in </strong>dct[<strong class="js hj">"carnivores"</strong>]])<br/>        dct[<strong class="js hj">"total_animals"</strong>] = dct[<strong class="js hj">"total_carnivores"</strong>] + dct[<strong class="js hj">"total_herbivores"</strong>]<br/>        class_ = super(ZooMeta, cls).__new__(cls, name, bases, dct)<br/>        <strong class="js hj">return </strong>class_<br/><br/><br/><strong class="js hj">class </strong>ChennaiZoo(metaclass=ZooMeta):<br/>    tiger = Animal(<strong class="js hj">"carnivore"</strong>, 10)<br/>    lion = Animal(<strong class="js hj">"carnivore"</strong>, 4)<br/>    elephant = Animal(<strong class="js hj">"herbivore"</strong>, 25)<br/>    camel = Animal(<strong class="js hj">"herbivore"</strong>, 12)<br/>    snake = Animal(<strong class="js hj">"carnivore"</strong>, 5)<br/><br/><br/><strong class="js hj">class </strong>MumbaiZoo(metaclass=ZooMeta):<br/>    tiger = Animal(<strong class="js hj">"carnivore"</strong>, 6)<br/>    lion = Animal(<strong class="js hj">"carnivore"</strong>, 7)<br/>    elephant = Animal(<strong class="js hj">"herbivore"</strong>, 14)<br/>    camel = Animal(<strong class="js hj">"herbivore"</strong>, 7)<br/>    snake = Animal(<strong class="js hj">"carnivore"</strong>, 20)<br/><br/><br/><strong class="js hj">print</strong>(ChennaiZoo.total_animals)<br/><strong class="js hj">print</strong>(ChennaiZoo.herbivores)<br/><strong class="js hj">print</strong>(ChennaiZoo.carnivores)<br/><br/><strong class="js hj">print</strong>(MumbaiZoo.total_animals)<br/><strong class="js hj">print</strong>(MumbaiZoo.herbivores)<br/><strong class="js hj">print</strong>(MumbaiZoo.carnivores)</span></pre><p id="49bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:</strong></p><ol class=""><li id="e865" class="kh ki hi is b it iu ix iy jb kj jf kk jj kl jn km kn ko kp bi translated">元类<code class="du jp jq jr js b">ZooMeta</code>的行为就像一个工厂，让开发人员不必定义创建其他附加属性的逻辑。</li><li id="4d88" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">开发人员只需定义<code class="du jp jq jr js b">Zoo</code>类，元类负责在创建类时向类添加其他相关属性。</li><li id="51f9" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">元类<code class="du jp jq jr js b">ZooMeta </code>在运行时将自定义属性<code class="du jp jq jr js b">herbivores, carnivores, total_herbivores, total_carnivores, total_animals</code>动态添加到zoo类中，这非常有用。</li></ol><p id="c2fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您通读。如果你喜欢这篇文章，请订阅我的频道。</p></div></div>    
</body>
</html>