<html>
<head>
<title>Image classification using fastai — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用fastai进行影像分类—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-classification-using-fastai-5ff5b374d414?source=collection_archive---------2-----------------------#2019-09-19">https://medium.com/analytics-vidhya/image-classification-using-fastai-5ff5b374d414?source=collection_archive---------2-----------------------#2019-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">我将使用fastai库实现图像分类。没有什么比fastai库更容易使用和理解了。让我们开始吧。</em></p><p id="414e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用pet数据集，默认情况下由fastai提供。在其他博客文章中，我将解释如何通过网络下载和分类来自其他人的任何可能的东西。</p><p id="99e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">💡有两种不同类型的数据集:</p><ul class=""><li id="23b1" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">学术数据集——这是学术人员花费大量时间来管理和收集数据的东西，这通常需要大量的头脑风暴技术来传递最先进的学术成果。</li><li id="fa18" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Kaggle竞赛数据集-ka ggle竞赛期间提供的数据集。</li></ul><p id="05fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">💁精细分类——这是一种我们必须在非常相似的类别之间进行分类的分类，如鸟类、花卉或动物的种类、汽车的型号等。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/cd2a6ac5bf66f36ca7e7ba17239d7030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hBScDfSJ_DHdQIbr.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">精细分类</figcaption></figure><p id="0fdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们导入分类所需的包:</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="38f8" class="kn ko hi kj b fi kp kq l kr ks"><strong class="kj hj">from fastai.vision import *</strong></span><span id="58e9" class="kn ko hi kj b fi kt kq l kr ks">(Vision module in fastai package provides us the classification methods.)</span></pre><p id="5868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fastai图书馆提供了大量的学术数据集。其中之一是在URLs.PETS下定义的宠物。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="eb68" class="kn ko hi kj b fi kp kq l kr ks">URLs.PETS = <a class="ae ku" href="https://s3.amazonaws.com/fast-ai-imageclas/oxford-iiit-pet" rel="noopener ugc nofollow" target="_blank">https://s3.amazonaws.com/fast-ai-imageclas/oxford-iiit-pet</a></span></pre><p id="ba95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要做的第一件事是下载并提取我们想要的数据。我们将使用这个名为的函数，它会自动下载并解压缩它。会将数据集下载到某个方便的路径，并为我们解包，然后它会返回路径的值。路径是</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="9b24" class="kn ko hi kj b fi kp kq l kr ks">path = untar_data(URLs.PETS); path</span><span id="815b" class="kn ko hi kj b fi kt kq l kr ks">= PosixPath('/root/.fastai/data/oxford-iiit-pet')</span></pre><p id="16d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是<a class="ae ku" href="https://docs.fast.ai/datasets.html#untar_data" rel="noopener ugc nofollow" target="_blank"> untar_data </a></p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="721d" class="kn ko hi kj b fi kp kq l kr ks">untar_data<!-- -->(<strong class="kj hj">url</strong>:<!-- -->str<!-- -->, <strong class="kj hj">fname</strong>:<!-- -->PathOrStr<!-- -->=<strong class="kj hj"><em class="jd">None</em></strong>, <strong class="kj hj">dest</strong>:<!-- -->PathOrStr<!-- -->=<strong class="kj hj"><em class="jd">None</em></strong>, <strong class="kj hj">data</strong>=<strong class="kj hj"><em class="jd">True</em></strong>, <strong class="kj hj">force_download</strong>=<strong class="kj hj"><em class="jd">False</em></strong>) → <!-- -->Path</span></pre><p id="f1b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">untar_data使用URL下载fname下的tgz文件，然后将tgz fname解压缩到dest下的文件夹中。</p><p id="0608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看我们下载的数据里面。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="8e55" class="kn ko hi kj b fi kp kq l kr ks">path.ls</span><span id="dfac" class="kn ko hi kj b fi kt kq l kr ks">= PosixPath('/root/.fastai/data/oxford-iiit-pet/annotations'),     PosixPath('/root/.fastai/data/oxford-iiit-pet/images')</span></pre><p id="a7c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它已经返回到两个PosixPaths。我们可以创建如下两个路径字符串:</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="59d8" class="kn ko hi kj b fi kp kq l kr ks">path_anno = path/'annotations'<br/>path_img = path/'images'</span></pre><p id="4d14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们处理一个问题时，我们做的第一件事就是看一看数据。我们<em class="jd">总是</em>需要很好地理解问题是什么，数据看起来像什么，然后才能想出如何解决它。查看数据意味着理解数据目录是如何构造的，标签是什么，以及一些示例图像是什么样子。影像分类数据集处理的主要区别在于标注的存储方式。在机器学习中，标签指的是我们试图预测的东西。</p><p id="c356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看看path_img里面是什么。fastai提供了一个便捷的方法，即<em class="jd"> get_image_files。</em></p><p id="c975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是<a class="ae ku" href="https://docs.fast.ai/vision.data.html#get_image_files" rel="noopener ugc nofollow" target="_blank"> get_image_files </a></p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="9529" class="kn ko hi kj b fi kp kq l kr ks">get_image_files<!-- -->(<strong class="kj hj">c</strong>:<!-- -->PathOrStr<!-- -->, <strong class="kj hj">check_ext</strong>:<!-- -->bool<!-- -->=<strong class="kj hj"><em class="jd">True</em></strong>, <strong class="kj hj">recurse</strong>=<strong class="kj hj"><em class="jd">False</em></strong>) → <!-- -->FilePathList</span></pre><p id="50e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">返回图像中的文件列表。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="a27d" class="kn ko hi kj b fi kp kq l kr ks">fnames = get_image_files(path_img)<br/>fnames[:4]</span><span id="8cde" class="kn ko hi kj b fi kt kq l kr ks">= PosixPath('/root/.fastai/data/oxford-iiit-pet/images/saint_bernard_40.jpg'),</span><span id="7e9c" class="kn ko hi kj b fi kt kq l kr ks">PosixPath('/root/.fastai/data/oxford-iiit-pet/images/Abyssinian_89.jpg'),</span><span id="95c6" class="kn ko hi kj b fi kt kq l kr ks">PosixPath('/root/.fastai/data/oxford-iiit-pet/images/boxer_89.jpg'),</span><span id="4a12" class="kn ko hi kj b fi kt kq l kr ks">PosixPath('/root/.fastai/data/oxford-iiit-pet/images/pug_188.jpg')</span></pre><p id="7d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个特定的数据集中，标签存储在文件名本身中，如x _<em class="jd">path/label _ name . extension</em>。我们将需要提取它们，以便能够将图像分类到正确的类别中。这是任何分类问题最著名的地方。</p><p id="9f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了从路径中提取文件名，fastai为我们提供了一个对象，即ImageDataBunch。</p><p id="2093" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是ImageDataBunch</p><p id="6c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ImageDataBunch提供了许多类方法，帮助我们创建训练、验证和测试数据加载器，这些加载器可进一步用于提取数据集的束。它返回给我们数据束对象。我们将要使用的一个类方法是<em class="jd"> from_name_re。</em> <code class="du kv kw kx kj b">from_name_re</code>取正则表达式并分隔数据。</p><p id="7783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是来自_name_re</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="6891" class="kn ko hi kj b fi kp kq l kr ks">from_name_re<!-- -->(<strong class="kj hj">path</strong>:<!-- -->PathOrStr<!-- -->, <strong class="kj hj">fnames</strong>:<!-- -->FilePathList<!-- -->, <strong class="kj hj">pat</strong>:<!-- -->str<!-- -->, <strong class="kj hj">valid_pct</strong>:<!-- -->float<!-- -->=<strong class="kj hj"><em class="jd">0.2</em></strong>, <strong class="kj hj">**</strong><strong class="kj hj">kwargs</strong>)</span></pre><ul class=""><li id="8289" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">路径:包含图像的路径</li><li id="8bcd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">文件名列表</li><li id="f0ef" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">pat:用于从文件名中提取标签的正则表达式(即模式)</li><li id="04ed" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">尺寸:你想处理多大尺寸的图像。</li></ul><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="5b8c" class="kn ko hi kj b fi kp kq l kr ks">np.random.seed(2)<br/>pat = r'/([^/]+)_\d+.jpg$'</span><span id="f362" class="kn ko hi kj b fi kt kq l kr ks">data = ImageDataBunch.from_name_re(path_img, fnames, pat, ds_tfms=get_transforms(), size=224)</span><span id="f5e7" class="kn ko hi kj b fi kt kq l kr ks">data.normalize(imagenet_stats)</span></pre><p id="c919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，深度学习处理器有一个限制，即所有图像必须具有相同的大小；否则就达不到预期的效果。224*224是标准的图像尺寸，也能给出好的结果。您可以尝试这个值。我们将整个数据标准化，使平均值为0，标准差为1。在几乎所有的机器学习任务中，你必须让所有的数据都具有相同的“大小”——它们特别是关于相等的均值和标准差。</p><p id="1fd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是图像正常化</p><p id="a7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像规格化将图像的像素规格化，该像素可以是从0到255的任何数字。如果这些红色、绿色和蓝色通道中的每一个都具有零的均值和一的标准差，那么它有助于训练深度学习模型。<br/>如果您的数据没有标准化，您的模型很难训练好。因此，如果你在训练一个模型时遇到困难，要检查的一件事就是你已经将它规范化了。</p><p id="0834" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是内幕数据</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="371a" class="kn ko hi kj b fi kp kq l kr ks"><strong class="kj hj">data</strong></span><span id="5395" class="kn ko hi kj b fi kt kq l kr ks"><strong class="kj hj">= ImageDataBunch;</strong> <br/> <br/><strong class="kj hj">Train</strong>: LabelList (5912 items) <br/><strong class="kj hj">x: ImageList</strong> <br/>Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224)  <br/><strong class="kj hj">y: CategoryList </strong>saint_bernard,Abyssinian,boxer,pug,staffordshire_bull_terrier <br/>Path: /root/.fastai/data/oxford-iiit-pet/images;</span><span id="f76f" class="kn ko hi kj b fi kt kq l kr ks"><strong class="kj hj">Valid</strong>: LabelList (1478 items) <br/><strong class="kj hj">x: ImageList</strong> Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224) <br/><strong class="kj hj">y: CategoryList</strong> <br/>beagle,samoyed,newfoundland,boxer,chihuahua <br/>Path: /root/.fastai/data/oxford-iiit-pet/images;</span><span id="880f" class="kn ko hi kj b fi kt kq l kr ks"><strong class="kj hj">Test</strong>: None</span></pre><h1 id="295e" class="ky ko hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">让我们看看数据内部</h1><p id="aa01" class="pw-post-body-paragraph if ig hi ih b ii lv ik il im lw io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">要成为一名优秀的从业者，对数据的感知是必不可少的。所以，你应该总是详细地查看你的数据。</p><ul class=""><li id="cd09" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">C/classes:图像标签的数量称为类别。您可以使用下面的命令来计算标签的数量。<strong class="ih hj">它接受这些字符串(标签的数量)，它会找到所有可能的唯一值，它会创建一个列表，然后它会把字符串变成数字(内部)。</strong></li></ul><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="7452" class="kn ko hi kj b fi kp kq l kr ks">data.c<br/> <br/> = 37</span><span id="2dd6" class="kn ko hi kj b fi kt kq l kr ks">data.classes<br/> <br/> = ['Abyssinian',  'Bengal',  'Birman',  'Bombay',   'British_Shorthair',  'Egyptian_Mau',  'Maine_Coon',  'Persian',  'Ragdoll',  'Russian_Blue',  'Siamese',  'Sphynx',  'american_bulldog',  'american_pit_bull_terrier',  'basset_hound',  'beagle',  'boxer',  'chihuahua',  'english_cocker_spaniel',  'english_setter',  'german_shorthaired',  'great_pyrenees',  'havanese',  'japanese_chin',  'keeshond',  'leonberger',  'miniature_pinscher',  'newfoundland',  'pomeranian',  'pug',  'saint_bernard',  'samoyed',  'scottish_terrier',  'shiba_inu',  'staffordshire_bull_terrier',  'wheaten_terrier',  'yorkshire_terrier']</span></pre><ul class=""><li id="b7af" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">显示批处理:</li></ul><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="611e" class="kn ko hi kj b fi kp kq l kr ks">show_batch<!-- -->(<strong class="kj hj">rows</strong>:<!-- -->int<!-- -->=<strong class="kj hj"><em class="jd">5</em></strong>, <strong class="kj hj">ds_type</strong>:<a class="ae ku" href="https://docs.fast.ai/basic_data.html#DatasetType" rel="noopener ugc nofollow" target="_blank">DatasetType</a>=<strong class="kj hj"><em class="jd">&lt;DatasetType.Train: 1&gt;</em></strong>, <strong class="kj hj">reverse</strong>:<!-- -->bool<!-- -->=<strong class="kj hj"><em class="jd">False</em></strong>, <strong class="kj hj">**</strong><strong class="kj hj">kwargs</strong>)</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ma"><img src="../Images/2cda24f2b5e75f077dc1d5db02fa546b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*khz-tujp7o9GdltR0gn5lQ.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">data.show_batch(rows=3，figsize=(7，6))</figcaption></figure><h1 id="b508" class="ky ko hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">学习者</h1><p id="9fd5" class="pw-post-body-paragraph if ig hi ih b ii lv ik il im lw io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">现在，我们准备训练我们的模型。一个模型在fastai中用一种叫做“学习者”的东西来训练。</p><p id="bd68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将建立convnet风格的学习者。我们将使用<em class="jd"> create_cnn </em>。</p><p id="8eed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是create_cnn <br/> Vision.learner是定义cnn_learner方法的模块，用来快速获得适合迁移学习的模型。我们将很快学习迁移学习。简而言之，这是一个概念，其中我们使用预定义/训练的模型来训练我们的模型。目前，你需要知道我们正在建立一个模型，该模型将图像作为输入，并将输出每个类别的预测概率。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="4013" class="kn ko hi kj b fi kp kq l kr ks">from fastai.metrics import error_rate</span><span id="b7d7" class="kn ko hi kj b fi kt kq l kr ks">learn = create_cnn(data, models.resnet34, metrics=error_rate)</span></pre><p id="7e31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，我还会给它一个东西，这是一个指标列表。指标只是在培训过程中打印出来的东西。所以我想让你打印出错误率。我们使用ResNet34模型作为迁移学习的一部分。</p><p id="e56f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓使用ResNet34 <br/>的原因是什么ResNet34是一个预先训练好的模型架构，已经定义了一组权重。使用预训练模型背后的思想是避免使用对模型一无所知的模型，该模型通过使用图像数据集ImageNet将数百万张图像分类成数千种类别而训练有素。ImageNet的最后一层由1000列组成，对应于1000个不同的类别。因此，它将减少学习者的大量工作。我们不确定这些预定义的一千个类别是否包含我们所有的宠物类别，但我们有信心的一件事是，模型了解动物，模型知道dos看起来像什么，猫看起来像什么，以及它们与其他东西有什么不同。这就足够了。我第一次在新安装的机器上运行时，它下载了ResNet34预训练的砝码。</p><p id="8f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多架构可供选择，公平地说，没有一个最好的，但如果你看看像图像分类基准这样的东西，ResNet就足够好了。</p><p id="4a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓:什么是迁移学习<br/>这个概念背后的基本思想是，我们将一个模型的学习转移到我们的模型中。因此，我们对它进行了调整，这样它就可以用你的宠物数据预测37种宠物，而不是用ImageNet数据预测1000种ImageNet。这样做，你可以用常规模型训练的1/100或更少的数据，用常规模型训练的1/100或更少的时间训练模型。令人印象深刻。</p><h1 id="b56f" class="ky ko hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">符合您的模型</h1><p id="4649" class="pw-post-body-paragraph if ig hi ih b ii lv ik il im lw io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">现在，我们有一个学习者。我们需要将数据放入学习者体内，这样它才能学习数据。现在，在学习或拟合数据时，我们必须注意过度拟合。我们希望我们的模型能够区分不同品种的宠物，而不是仅仅学习输入数据集，即填鸭式输入数据集。如果我们的模型过拟合，那么它将在验证数据集上表现不佳。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="0040" class="kn ko hi kj b fi kp kq l kr ks">learn.fit_one_cycle(4)</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mb"><img src="../Images/40375daa902637b6d8ee753caccc9898.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*2GWMRYRf_3Dsq-FtS7dIOg.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">错误率是我们的衡量标准。我们有93%的准确结果。</figcaption></figure><p id="a456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4，基本上决定了我们遍历整个数据集多少次，我们向模型显示数据集多少次，以便它可以从中学习。每当它看到一张照片，它就会变得更好一点。我们没有过度拟合，因为我们的验证损失总是小于训练损失。😉</p><p id="28b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的模型正在学习一组特殊的权重，这些权重在对宠物品种进行分类时非常有效。我们可以保存这些权重，以便我们可以重复使用已经设置的权重，而不是一次又一次地进行拟合。这将是试衣/训练时间。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="2c50" class="kn ko hi kj b fi kp kq l kr ks">learn.save('pets-classifier-1')</span></pre><p id="e9a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">？create_cnn <br/> </strong>背后发生了什么现在，既然我们知道了fit_one_cycle()，那就让我们来了解一下卷积神经网络背后发生了什么。create_cnn基本上破坏了ImageNet的最后一层，它有1000个列，用于各种1000个类别。这取决于我们用于分类的类的数量。因此，我们丢弃了完整的权重矩阵，并且在它们之间增加了两个具有非激活函数的权重矩阵。最后一个矩阵的列数等于我们在分类的情况下定义的类别数。然后我们训练这些权重矩阵。</p><p id="d898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们调用<code class="du kv kw kx kj b">fit</code>或<code class="du kv kw kx kj b">fit_one_cycle</code>时，它会冻结除新层之外的所有层。这意味着我们要求fastai和PyTorch，当我们训练时，即当我们调用fit时，不要将渐变反向传播到那些层中。换句话说，当你这样做的时候，<code class="du kv kw kx kj b">weights = weights - learning rate * weight_grad</code>只对新的层做，而不对其他层做，这就是冻结的意思——只是意味着不要更新那些参数。</p><p id="e44c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以它也会快一点，因为要做的计算更少。它会占用更少的内存，因为我们需要存储的梯度更少了。但最重要的是，它不会改变已经比没有好的权重——它们至少比随机要好。这就是你调用freeze的结果。它不会冻结整个事情。它冻结了所有东西，除了我们为你添加的随机生成的图层。</p><h1 id="c5a7" class="ky ko hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结果</h1><p id="adfb" class="pw-post-body-paragraph if ig hi ih b ii lv ik il im lw io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">为了解释结果，我们将使用ClassificationInterpretation，这是来自学习者的工厂方法，因此我们将传递learn对象。</p><p id="b58d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓什么是<a class="ae ku" href="https://docs.fast.ai/train.html#ClassificationInterpretation" rel="noopener ugc nofollow" target="_blank">分类释义</a></p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="45aa" class="kn ko hi kj b fi kp kq l kr ks">ClassificationInterpretation(learn:Learner, preds:Tensor, y_true:Tensor, losses:Tensor, ds_type:DatasetType=&lt;DatasetType.Valid: 2&gt;) :: Interpretation</span></pre><p id="169a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类模型的解释方法。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="4b86" class="kn ko hi kj b fi kp kq l kr ks">interp = ClassificationInterpretation.from_learner(learn)</span></pre><p id="d2cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">interp有一堆技术可以帮助找到高损失。当我们对错误的预测最有信心时，高损失就会发生。</p><ul class=""><li id="d6eb" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae ku" href="https://docs.fast.ai/vision.learner.html#_cl_int_plot_top_losses" rel="noopener ugc nofollow" target="_blank"> plot_top_losses </a> —显示top_losses中的图像及其预测、实际、损失和实际类别的概率。</li></ul><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="566f" class="kn ko hi kj b fi kp kq l kr ks">interp.plot_top_losses(9, figsize=(15,11))</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mc"><img src="../Images/218e070248cdc2332f26bf6053c752aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJpffiEnHuSfz5CMQIw-nQ.png"/></div></div></figure><ul class=""><li id="fef3" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae ku" href="https://docs.fast.ai/train.html#ClassificationInterpretation.plot_confusion_matrix" rel="noopener ugc nofollow" target="_blank">plot _ confusion _ matrix</a>—为您显示每种实际类型的狗或猫，有多少次被预测为那只狗或猫。</li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es md"><img src="../Images/8eef8d8938f0a21071c25c07de7fa435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*WnEY9-P2SGQr_L9C8szGbQ.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">混淆矩阵——不太用户友好</figcaption></figure><ul class=""><li id="2c70" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae ku" href="https://docs.fast.ai/train.html#ClassificationInterpretation.most_confused" rel="noopener ugc nofollow" target="_blank"> most_confused </a> —混淆矩阵的最大规模非对角线条目的降序列表，以实际、预测、出现次数表示。</li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es me"><img src="../Images/e1aec06a0817c8861f4070366c2adf59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*xVQoqJuipSOIubQMo3hR7Q.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">实际、预测的错误发生次数</figcaption></figure><h1 id="5605" class="ky ko hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解冻和学习率</h1><p id="c1c7" class="pw-post-body-paragraph if ig hi ih b ii lv ik il im lw io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">现在，我们所做的是保持整个模型不变，我们只训练模型的最后几层。这是因为早期的层有利于识别我们不想改变或重新训练的不同模式。因此，当我们对学习者调用freeze()时，它会冻结模型的早期层，以防止重新训练它们。最后一层是我们添加的用来区分宠物模型的层。所以，这样的话，我们会让整个模型保持同样的状态；我们将权重只凝胶或合并我们的最后一层与已经定义的层。</p><h2 id="dc3b" class="kn ko hi bd kz mf mg mh ld mi mj mk lh iq ml mm ll iu mn mo lp iy mp mq lt mr bi translated">如果我们要从头开始训练整个模型呢？</h2><p id="b096" class="pw-post-body-paragraph if ig hi ih b ii lv ik il im lw io ip iq lx is it iu ly iw ix iy lz ja jb jc hb bi translated">我们可以这样做，使用unfreeze属性。它永远不会过量，但要使它合适，你必须调用<code class="du kv kw kx kj b">unfreeze</code>。<code class="du kv kw kx kj b">unfreeze</code>就是那个说，请训练整个模型考虑到所有层的东西。然后我可以再调用fit_one_cycle。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="bd89" class="kn ko hi kj b fi kp kq l kr ks">learn.unfreeze()<br/>learn.fit_one_cycle(1)</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ms"><img src="../Images/1485e0baa70ffaad8751dd24c07f6eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*ukX8Log_S5Sj5K-BsgYWUw.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">差错率</figcaption></figure><p id="271b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你这样做的时候，我们的错误损失会比以前更多，或者比以前没有改善。这主要是因为我们用默认的学习率来拟合我们的模型。我们想要改变模型的初始层是不太可能的，这些层已经被预先训练以找到一些模式。当我们解冻整个模型时，它也试图适应初始层，这导致简化的模型。因此，我们想要的是初始层的学习率低，因为我们不想将初始权重改变相当大的量，而我们想要设置的最新层的学习率高。</p><p id="debe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❓How发现学习率</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="00f2" class="kn ko hi kj b fi kp kq l kr ks">learn.load('pets-classifier-1')<br/>learn.lr_find()<br/>learn.recorder.plot()</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mt"><img src="../Images/1d96354973789d4579101b240a3b3dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*bh_664jls7Cfp9V-Pplxtg.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">学习率图</figcaption></figure><p id="2e13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习率表示我更新模型中参数的速度。这里的x轴显示了当我提高学习率时会发生什么。y轴表示损失是多少。所以你可以看到，一旦学习率超过10^-4，我的损失会更严重。因为我们现在在尝试微调东西，所以不能用这么高的学习率。</p><pre class="jt ju jv jw fd ki kj kk kl aw km bi"><span id="0ee6" class="kn ko hi kj b fi kp kq l kr ks">learn.unfreeze()<br/>learn.fit_one_cycle(3, max_lr=slice(1e-6,1e-4))</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mu"><img src="../Images/f56fba02f9519d5580f0996d51b4eef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*ybDZsn8GLerTjZJZBALVyw.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">更少的错误率</figcaption></figure><p id="2452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python中的这个关键字叫做<code class="du kv kw kx kj b">slice</code>，它可以接受一个起始值和一个终止值，基本上它的意思是以1e-6的学习速率训练最开始的层，以1e-4的速率训练最后的层，并将所有其他层分布在其上(即在这两个值之间相等)。</p><p id="5626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将学习如何更深入地选择学习率；现在，您可以浏览定义的值。请随意试验这些值。</p><p id="462a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi mv translated"><span class="l mw mx my bm mz na nb nc nd di">如果</span>你已经理解了分类背后的动力，那么你很好地阅读了分类的<a class="ae ku" rel="noopener" href="/@PJrohan/face-recognition-using-fastai-part-2-44360f6471fb">第二部分</a>。</p><h1 id="fe2a" class="ky ko hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考资料:</h1><ul class=""><li id="ee40" class="je jf hi ih b ii lv im lw iq ne iu nf iy ng jc jj jk jl jm bi translated">Fast.ai</li></ul></div></div>    
</body>
</html>