<html>
<head>
<title>Programming Paradigms: Imperative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程范例:命令式</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/programming-paradigms-imperative-1472c4f08723?source=collection_archive---------8-----------------------#2020-02-12">https://medium.com/analytics-vidhya/programming-paradigms-imperative-1472c4f08723?source=collection_archive---------8-----------------------#2020-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aa9240dddda960e004ad98b3a94838e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KqVIbnlAZIXp2zxO"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9880" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好，</p><p id="627d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" rel="noopener" href="/@shivam.gosavi340_58315/programming-paradigms-cb560f5125a1">之前的博客文章</a>中，我们详细讨论了命令式和声明式范例。在这篇博文中，我们将讨论受命令式范式影响的范式。如果你还没有读过我之前关于范式的博客，那么我建议你在继续深入之前读一读。<br/>以下是受命令式范例影响的几种范例:</p><ol class=""><li id="ffea" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">结构化范例</li><li id="612e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">程序范式</li><li id="d8a3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">面向对象的范例</li></ol><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/bfc17b71f50ab3dfe0f80bc02468f4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*GkxF82uH_5-n7w4duyMY-g.gif"/></div></figure><h1 id="cca0" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结构化编程:</h1><p id="775f" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">结构化编程是一种使用结构化控制流(无goto)来提高代码清晰度和质量的编程范式。</p><p id="d3f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结构化编程有三种组合程序的方式——<strong class="ix hj">排序、选择和迭代</strong>。</p><p id="1a02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种范式大量使用了<strong class="ix hj">块结构</strong>(排序)<strong class="ix hj"> if/else </strong>(选择)，以及<strong class="ix hj"> while or for循环</strong>(重复)。Edsger W. Dijkstra在他关于<a class="ae iu" href="https://en.wikipedia.org/wiki/Go_To_Statement_Considered_Harmful" rel="noopener ugc nofollow" target="_blank">Go To Statement behaviour</a>的公开信中创造了结构化编程这个术语。</p><p id="a904" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，在下面的代码片段中，我们使用For循环来迭代代码:</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="725d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结构化编程也是命令式编程的一种形式，因为我们明确地<em class="lr">循环</em> (for，while，repeat)并且<em class="lr">在每个循环中用明确的赋值操作改变变量</em>。结构化语言的例子有C、C++、Java、PHP等。因为这些语言支持<strong class="ix hj">测序、选择和迭代</strong>的特性。</p><h2 id="abd5" class="ls kn hi bd ko lt lu lv ks lw lx ly kw jg lz ma la jk mb mc le jo md me li mf bi translated">结构化编程的优势:</h2><p id="9e4d" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">以下是结构化编程的一些好处:</p><ul class=""><li id="1acb" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mg jz ka kb bi translated">代码组织得很好。</li><li id="afea" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">我们可以重复执行一段代码，直到给定的条件匹配。</li><li id="014d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">提高决策能力。基于某些条件，我们可以决定是否执行任何代码块。</li><li id="6f99" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">使用if/else和for/while的结构化执行流。这与<a class="ae iu" href="https://en.wikipedia.org/wiki/Non-structured_programming" rel="noopener ugc nofollow" target="_blank">非结构化编程</a>形成对比，后者使用<a class="ae iu" href="https://en.wikipedia.org/wiki/Goto" rel="noopener ugc nofollow" target="_blank"> goto </a>语句或等效语句，使用非结构化跳转到标签或指令地址。</li></ul><h1 id="77e3" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">程序编程:</h1><p id="5365" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">过程化编程范例<strong class="ix hj">是从结构化</strong>编程中派生出来的。它基于过程调用的概念。过程也称为例程、子例程、方法或函数。</p><p id="02e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个过程包含一系列耦合在一起的指令。我们可以在程序执行的任何时候调用任何过程。</p><p id="7dc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">计算机处理器通过<a class="ae iu" href="https://en.wikipedia.org/wiki/Stack_register" rel="noopener ugc nofollow" target="_blank">堆栈寄存器</a>和指令<a class="ae iu" href="https://en.wikipedia.org/wiki/Subroutine#Jump_to_subroutine" rel="noopener ugc nofollow" target="_blank">调用程序</a>并从中返回，为程序编程提供硬件支持。</p><p id="d2ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数过程编程语言本质上都是命令式的，因为它们明确引用了执行状态。下图说明了命令式结构化程序范例之间的关系。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/a35eff8ddf991b2d9b71268f7ea5651b.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*CfM5842LBDd5ON6Z1JD3ZQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">过程编程与结构化和命令式编程的关系。</figcaption></figure><p id="527f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们以一个计算前n个数总和的程序为例。我们可以用过程式编程风格编写代码，如下所示:</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用过程式编程风格</figcaption></figure><p id="3fb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们把程序分成了两个功能。main()充当执行的入口点或起始点，sumOfFirst()计算前n个数的相加。</p><p id="8cd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分离计算总和的逻辑的主要优点是，我们现在可以重用具有不同输入值的相同代码块。注意这里的命令式；当我们遍历给定的数字范围时，我们使用赋值操作符来更新变量total的值。</p><p id="172a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过程语言的例子有C、C++、Java、Kotlin、PHP等。因为这些语言支持函数、方法、过程。使用函数，我们可以将复杂的问题分解成更小的子问题。</p><h2 id="f63c" class="ls kn hi bd ko lt lu lv ks lw lx ly kw jg lz ma la jk mb mc le jo md me li mf bi translated">过程化编程的优势:</h2><p id="83a8" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">以下是过程化编程的一些好处:</p><ul class=""><li id="dbf7" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mg jz ka kb bi translated">代码变得可重用。</li><li id="70b2" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">编写模块化代码是可能的；这催生了另一个范例，即<a class="ae iu" href="https://en.wikipedia.org/wiki/Modular_programming" rel="noopener ugc nofollow" target="_blank">模块化编程</a>。</li><li id="75ba" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">跟踪控制流更容易。</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/1e732b9717b78ebab4990e18b8715b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/1*wf-RzqH5_3ke6SSWrT_U5g.gif"/></div></figure><h1 id="fb23" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">面向对象编程:</h1><p id="629b" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">面向对象的编程范例基于<strong class="ix hj">对象的概念。</strong>对象可以是任何现实世界的实体。一个对象有数据(属性、变量)和行为(方法)。面向对象的范例通过支持抽象、封装、继承、多态等特性，将编程带到了一个新的高度。</p><p id="4837" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种类型的面向对象编程——一种是基于类的，另一种是基于原型的。</p><h2 id="60d9" class="ls kn hi bd ko lt lu lv ks lw lx ly kw jg lz ma la jk mb mc le jo md me li mf bi translated">基于类别:</h2><p id="b924" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">在<a class="ae iu" href="https://en.wikipedia.org/wiki/Class-based_programming" rel="noopener ugc nofollow" target="_blank">基于类的语言</a>中，预先定义了<em class="lr">类</em>，基于类实例化了<em class="lr">对象</em>。例如，如果我们想要创建两个新对象，一个表示苹果<em class="lr">另一个表示桔子<em class="lr">，</em>，那么首先我们需要创建水果类<em class="lr">。然后</em>我们可以创建水果类的两个实例(对象)，一个用于苹果，另一个用于橘子<em class="lr">。</em></em></p><p id="a63d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在基于类的语言中，对象是类的实例。Java支持基于类的编程。</p><h2 id="7ad3" class="ls kn hi bd ko lt lu lv ks lw lx ly kw jg lz ma la jk mb mc le jo md me li mf bi translated">基于原型:</h2><p id="0ded" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">在<a class="ae iu" href="https://en.wikipedia.org/wiki/Prototype-based_programming" rel="noopener ugc nofollow" target="_blank">基于原型的语言</a>中，<em class="lr">对象</em>是主实体，其中不存在<em class="lr">类</em>。我们基于已经存在的对象创建新对象。这些已经存在的对象充当新对象的原型。</p><p id="f345" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们想要创建两个新对象，一个表示苹果的<em class="lr">，另一个表示桔子<em class="lr">的</em>，那么首先我们需要创建一个水果对象<em class="lr">。然后</em>我们可以从水果对象<em class="lr">创建两个对象。</em>在这里，水果对象充当苹果和桔子对象的原型。</em></p><p id="b610" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">委托是一种支持基于原型编程的语言特性。JavaScript支持基于原型的编程。</p><h2 id="0db4" class="ls kn hi bd ko lt lu lv ks lw lx ly kw jg lz ma la jk mb mc le jo md me li mf bi translated">面向对象编程的优势:</h2><p id="0040" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">以下是面向对象编程的一些好处:</p><ul class=""><li id="0c66" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mg jz ka kb bi translated">抽象:隐藏实现细节。一般来说，抽象是通过抽象类和接口实现的。</li><li id="cbc8" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">封装:就是将实现(代码)和它处理的数据(变量)封装在同一个类中。这是通过使用访问修饰符如public、private和protected来实现的。</li><li id="ec16" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">继承:这是一种从现有类(基类或父类)创建新类(子类)的方法。这种机制使得代码可以重用。因为派生类获得了基类的所有功能，并且它还允许在不修改现有源代码的情况下扩展基类的功能。</li><li id="7f45" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mg jz ka kb bi translated">多态性:我们可以有一个方法，根据使用它的上下文，它有不同的行为。我们可以使用方法重载和方法覆盖来实现这一点。</li></ul><h1 id="6bee" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">延伸阅读:</h1><p id="7fac" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">声明性范例:</p><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/programming-paradigms-declarative-a6ee23ca8dc9"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">编程范例:声明式</h2><div class="mt l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz io mm"/></div></div></a></div></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="4887" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢你阅读这篇博客。我希望你喜欢这篇关于命令式范例的文章，并且学到了一些新东西。如果你有任何建议或问题，请在下面的评论中添加，快乐学习👏。</p><h1 id="77ac" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我的更多信息:</h1><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/programming-paradigms-cb560f5125a1"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">编程范例</h2><div class="nh l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">什么是编程范式？</h3></div><div class="mt l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz io mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/demystifying-kotlin-data-classes-a806f90368b3"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">揭开Kotlin数据类的神秘面纱</h2><div class="mt l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="ni l mw mx my mu mz io mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/demystifying-the-concept-of-uri-6dcc82fdeef5"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">揭开URI概念的神秘面纱</h2><div class="nh l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">理解统一资源标识符(URI)概念的新系列文章。</h3></div><div class="mt l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="nj l mw mx my mu mz io mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/@shivam.gosavi340_58315/productivity-hacks-200f235a0acc"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">生产力黑客</h2><div class="nh l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">提高软件工程师生产力的一些技巧和工具。</h3></div><div class="mt l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="nk l mw mx my mu mz io mm"/></div></div></a></div></div></div>    
</body>
</html>