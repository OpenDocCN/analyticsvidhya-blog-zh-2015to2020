<html>
<head>
<title>Django rest framework: nested serializer.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django rest框架:嵌套序列化程序。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/django-rest-framework-nested-serializer-6bebb5f9289e?source=collection_archive---------9-----------------------#2020-05-23">https://medium.com/analytics-vidhya/django-rest-framework-nested-serializer-6bebb5f9289e?source=collection_archive---------9-----------------------#2020-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5a0d3a47e9a1add72165698512b1b427.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*53FHbwGylRliYEYv7JjC_A.png"/></div></figure><p id="084a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Django REST framework是一个很棒的包，它让您在创建REST APIs方面有了一个良好的开端，它让将想法开发成代码比以往任何时候都更快更容易。然而，当你开始定制你的应用程序来满足你的需求时，事情就变得更棘手了。</p><p id="4995" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果您需要一个端点来产生和消费不同模型的嵌套实例，Django-rest-framework要求您编写一个关于如何处理数据的逻辑。</p><p id="cd35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将了解如何定义嵌套的序列化程序。</p><p id="6971" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了定制一个序列化器，我们必须重写两个不同的方法:创建和更新。这两种方法都用于反序列化提交给API的JSON数据。两者之间的区别在于，create方法获取用户通过POST请求发送的信息，并创建所需模型的实例，而update方法用于客户端使用PATCH或PUT来编辑数据库中已存储的某个对象的数据。</p><h1 id="a1d6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><em class="ki">设置</em></h1><p id="820c" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">为了便于解释，我们将使用两个模型；第一个是Django自带的内置用户模型。第二个是客户端模型，它通过一对一关系扩展了用户模型，客户端模型将用于存储关于用户的额外信息。</p><p id="b57e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">客户端模型将被定义如下:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="d626" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了通过API使用客户机模型，我们在urls.py文件中有两个不同的端点路径；一个用于创建客户端，一个用于更新现有的客户端。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="2d11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">处理这些端点路径的视图将位于“views.py”中。这两个视图是rest-framework的通用视图；它将负责创建和更新客户端的所有细节。我们所要做的就是为他们提供一个数据库中存储的所有客户机的查询集，并将他们指向将处理JSON数据的序列化器。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="2bed" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">现在到了重要的部分:序列化器。</h1><p id="d85e" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">如果我们再深入一点，我们会发现问题并不在于序列化程序本身，而在于反序列化过程。这意味着，如果我们仅对安全的Http方法或delete方法使用嵌套的serialize(因为它不发送任何要处理的数据),将不会发生错误。并且模型之间的嵌套关系会被翻译成嵌套的JSON对象。但是如果我们使用Http请求方法，将数据发送到API进行处理(POST、PATCH和PUT ),就会面临问题。</p><p id="3f5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了克服这个问题，我们必须在外部模型的创建和更新方法中处理嵌套模型的创建和更新。这就是为什么我们必须重写处理反序列化的方法:创建和更新。就像下面这样:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es if"><img src="../Images/5a0d3a47e9a1add72165698512b1b427.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*53FHbwGylRliYEYv7JjC_A.png"/></div></figure><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es if"><img src="../Images/5a0d3a47e9a1add72165698512b1b427.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*53FHbwGylRliYEYv7JjC_A.png"/></div></figure><p id="0b85" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们所见。两种方法的区别；create方法创建一个新的客户机实例并返回它。当update方法在更新所提供的客户端实例的字段时，update generic视图会重试此实例，并将其与提交的数据一起传递给序列化程序。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="78c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lb">感谢阅读。</em></p></div></div>    
</body>
</html>