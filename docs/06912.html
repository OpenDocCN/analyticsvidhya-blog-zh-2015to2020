<html>
<head>
<title>Identification of Indian dance form using TenforFlow 2.0 and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于TenforFlow 2.0和Keras的印度舞蹈形态识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/identification-of-indian-dance-form-using-tenforflow2-0-and-keras-4341b4c69526?source=collection_archive---------6-----------------------#2020-06-07">https://medium.com/analytics-vidhya/identification-of-indian-dance-form-using-tenforflow2-0-and-keras-4341b4c69526?source=collection_archive---------6-----------------------#2020-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="af54" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">图像分类，TensorFlow，OpenCV，Keras，印度舞蹈</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f2bc00eba5d27b1e903dbd3223c12de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fI6IN4eiRZIxnVcYSL7E2g.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">拉杰什·拉杰普特在<a class="ae jn" href="https://unsplash.com/s/photos/indian-dance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c2a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我将带你通过使用印度舞蹈形式数据的基本图像分类问题。我准备用<strong class="jq hj"> CNN </strong>(卷积神经网络)在<strong class="jq hj"><em class="kk">tensor flow 2.0</em></strong><em class="kk"/>和<strong class="jq hj"> <em class="kk"> Keras </em> </strong>配合<strong class="jq hj"> <em class="kk">转移学习</em> </strong>将图像分类成多类。在这篇文章中，我用迁移学习的概念对印度舞蹈形式进行分类。图像分类需要大量的训练数据来训练一个模型并取得好的结果。在我们的例子中，我们的训练数据量非常少，所以我们使用<strong class="jq hj"><em class="kk">tensor flow vgg 16</em></strong>预训练<strong class="jq hj"> <em class="kk">迁移学习</em> </strong>模型来获取其权重。本文的目的是给出如何使用迁移学习进行图像分类的基本思想。你可以从<a class="ae jn" href="https://github.com/ubsingh9/Identify-the-dance-form" rel="noopener ugc nofollow" target="_blank">这里</a>下载数据和完整代码。</p><p id="af89" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据集由364幅图像组成，分属8个类别，即<em class="kk">曼尼普尔、bharatanatyam、odissi、kathakali、kathak、sattriya、kuchipudi和mohiniyatam</em>。我们的任务是建立一个分类模型，自动标记图像并将它们分类到印度古典舞形式的不同类别中。</p><p id="c51a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数据文件夹由两个文件夹和两个。csv文件。这里我们的重点是训练数据并验证它们的结果。</p><p id="660c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">具体如下:train:包含8个类的364个图像</p><ul class=""><li id="d881" class="kl km hi jq b jr js ju jv jx kn kb ko kf kp kj kq kr ks kt bi translated">曼尼普尔，</li><li id="ef3b" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">婆罗多舞</li><li id="e5e4" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">奥迪西</li><li id="9ad2" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">卡塔尔卡里</li><li id="9b0d" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">北印度舞</li><li id="0a48" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">萨特里亚</li><li id="1572" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">库奇普迪</li><li id="58b8" class="kl km hi jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">莫希尼亚塔姆</li></ul><p id="2e31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，在继续下一步之前，我们需要加载所有的库</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/3b8e06e0e1ccaaac6f83e8c9bb4af5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-bsWlMo1q-NZxDLtrB4eg.png"/></div></div></figure><p id="72a9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们加载数据集，该数据集包含训练数据集的图像名称和标签以及测试数据集的图像名称。我正在使用<em class="kk"> kaggle </em>平台来执行我的代码，你可以使用你自己的位置。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es la"><img src="../Images/6f1b440ad3a8ebb1f084d333f241ff33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1dOn8SBOkSpnxlTqACgig.png"/></div></div></figure><p id="8f1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们使用直方图来绘制舞蹈形式，以检查图像分布</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/67d1ab38727f8d0fd4dc69069e68f7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvXB8DJ5Kz4Zm_hAIdvhcA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">舞蹈类型的直方图</figcaption></figure><p id="9f14" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以看到图像类别几乎是平均分布的，曼尼普尔<em class="kk">的最小图像是36，<em class="kk">的最大图像是50</em></em></p><p id="4e19" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是时候创建一个<em class="kk">工作目录</em>来将实际的图像从磁盘加载到内存中了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lc"><img src="../Images/92b90cafca0afe51245b12f272d4455a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6KPcmiSjALpg1K7a2q8zqw.png"/></div></div></figure><p id="4f7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在指定了实际数据所在的路径后，我们需要两个辅助函数来读取图像数据并转换成数字格式。这里我使用<strong class="jq hj"> <em class="kk"> OpenCV </em> </strong>读取图像并转换成数字格式。我正在将所有图像加载到224*224像素。好的做法是将所有的图像加载到相同的大小。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ld"><img src="../Images/9e5ffbf6a7aad4be5660c2b8e1f87b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHcDmiLDtG5RA2l-5J3Fcw.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/295cf7e8e3186f9ac641be5c79b794fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BeLPCYO_1w-vbVw77qlEw.png"/></div></div></figure><p id="6ae2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将图像加载到内存中，并转换成数字格式，让我们来看前25张图像。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/a06410c48320702ed073047f98d2abb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQ3ggSkscicKIXvf3IESUg.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/69b9b54391d5a44b996898cabe056114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*z8ZvWKwCRiza5LohKifCVA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">前25幅训练图像</figcaption></figure><p id="412b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从上面的图片中我们可以看到我们的目标变量是字符串格式的，为了建立模型，我们需要将字符串转换成对象变量。我们使用<em class="kk"> sklearn LebelEncode </em> r将字符串转换成对象格式</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/7dfe49f5e958497a3a60e8b43fa7d558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7uHt_N2b4joF71s3B_AYw.png"/></div></div></figure><p id="c295" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在建立深度学习模型之前，我们需要将数据分为训练集和验证集，以验证我们的模型性能。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/c397442697c1803409efacb8def96d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bs8xJ9Up5wWYLcU_cDpcbg.png"/></div></div></figure><p id="6374" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在模型建立之前的最后一步是应用"<em class="kk">图像</em> <em class="kk">增强"</em>来生成多个特征并避免模型的过度拟合。我们通过将所有值除以255来应用数值数据的重新缩放，以使所有值都在0到1之间。对于验证和测试数据集，我们仅使用重新缩放来防止我们的模型在看不见的数据上表现过度。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/f26a629188bac68c30ffacd16d3a7913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EosZHzggacKQAW7z3A_FkA.png"/></div></div></figure><p id="d27f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们的数据已经可以进行训练了。是时候将预先训练好的迁移学习模型<strong class="jq hj"> <em class="kk"> VGG16 </em> </strong>的权重使用到我们要求的格式中，并检查模型的摘要。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/71d3addc8ba6649025afa8be49ec141f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPI_noxeIG5W5FIgkQ7Ogg.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/c42eaa51a5b4edb4f5edb5c0339cc050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DgncuIRog1zEPBMP4_BMg.png"/></div></div></figure><p id="70c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用已经训练好的模型输出，构建两个连续的密集层，其中<em class="kk"> dropout =0.15 </em>以防止过度拟合。让我们编译模型并运行30个时期。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/2abba5bbe81895e7cd83d5f60c52b027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-QBBsNX8wxK7qCrcbZt_A.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/a91138545179a1e79cbc090d17b45b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6-KdA511CPrJAw_fQk1JQ.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ln"><img src="../Images/fcf309b2f0ab94a7c9c85fc94eaef223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Z9mdQnXV9YtWLXTaTwexw.png"/></div></div></figure><p id="62b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在30个历元之后，我们达到了0.8642的训练精度和0.6694的验证精度。让我们为每个时期的训练和验证数据集绘制准确性和损失图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/86316036b7089c24bcade9e277753254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5xOzW8GrEF1C_YBXXWAig.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lo"><img src="../Images/99f981aab7f3371c6b2c1d175cc7092e.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*ZBQR5p6FC3IXiVXtz_D3Cg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">训练和验证集的准确度和损失图</figcaption></figure><p id="e7d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从上图我们可以看到，前几个时期的训练和验证精度有所提高，但之后并没有太大的改善。</p><h2 id="b075" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jx ma mb mc kb md me mf kf mg mh mi mj bi translated">结论</h2><p id="7e83" class="pw-post-body-paragraph jo jp hi jq b jr mk ij jt ju ml im jw jx mm jz ka kb mn kd ke kf mo kh ki kj hb bi translated">在这篇文章中，我们得到了如何使用<em class="kk"> openCV </em>读取图像文件并应用迁移学习来训练图像数据的基本想法。</p><p id="90a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望这篇文章能让你在迁移学习的帮助下，用<strong class="jq hj"><em class="kk"/></strong>和<strong class="jq hj"> <em class="kk"> keras </em> </strong>对印度舞蹈形式进行分类。</p><p id="08aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注:</strong>本文使用的数据集取自此处的<a class="ae jn" href="https://www.hackerearth.com/challenges/competitive/hackerearth-deep-learning-challenge-identify-dance-form/" rel="noopener ugc nofollow" target="_blank">和</a>，用于学习目的。</p><p id="5273" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">谢谢</p></div></div>    
</body>
</html>