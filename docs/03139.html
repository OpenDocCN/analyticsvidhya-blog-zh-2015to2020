<html>
<head>
<title>Simplifying Closures in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化Swift中的闭包</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simplifying-closures-in-swift-a7a58be642d0?source=collection_archive---------18-----------------------#2020-01-17">https://medium.com/analytics-vidhya/simplifying-closures-in-swift-a7a58be642d0?source=collection_archive---------18-----------------------#2020-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="509a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">别担心，你并不孤单。闭包可能会令人困惑，如果您和我一样，您可能已经阅读了各种定义和帖子，试图找出它们。但是读完之后，你会更加困惑。希望这能帮助你筛选技术术语，让你有更好的理解。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="2a1b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是终结？</h1><p id="b570" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">只是一个有一些特殊规则的函数，写的有点不一样。</p><h2 id="6bb8" class="kn jl hi bd jm ko kp kq jq kr ks kt ju ix ku kv jy jb kw kx kc jf ky kz kg la bi translated"><em class="lb">语法和规则</em></h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="03fa" class="kn jl hi lh b fi ll lm l ln lo">{(parameters) -&gt; return type in<br/>    code<br/>}</span></pre><p id="69be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则1: </strong>如果没有参数，可以省略箭头操作符和返回类型。也可以用下划线代替参数名。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b8cc" class="kn jl hi lh b fi ll lm l ln lo">let closure = { () in<br/>    return "This is still a valid closure"<br/>}()</span></pre><p id="76e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则二:</strong>如果参数类型是编译器已知的，可以省略类型。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="656a" class="kn jl hi lh b fi ll lm l ln lo">let closure = {(str) in<br/>    return "This is a \(str) in a closure"<br/>}</span><span id="d3b5" class="kn jl hi lh b fi lp lm l ln lo">closure("string")</span></pre><p id="56a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则3: </strong>如果匿名函数不带参数，并且返回类型可以省略，就不必使用‘in’表达式。但是，如果有参数，您仍然可以通过使用$0语法省略名称。</p><p id="18d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则四:</strong>如果闭包是一行，可以省略关键字return。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6642" class="kn jl hi lh b fi ll lm l ln lo">let closure = {<br/>    "No return keyword necessary"<br/>}</span></pre><p id="d9c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则5: </strong>如果省略了参数类型，则可以省略参数列表两边的括号。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7848" class="kn jl hi lh b fi ll lm l ln lo">let closure = { str in<br/>    return "This is how you omit the parentheses around \(str)"<br/>}</span></pre><p id="346f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则6: </strong>如果函数的最后一个参数是闭包，可以使用尾随闭包语法，这样可以省略函数标签和/或函数括号。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0b62" class="kn jl hi lh b fi ll lm l ln lo">func doSomething(_ closure: () -&gt; ()) {<br/>    closure()<br/>}</span><span id="b8e1" class="kn jl hi lh b fi lp lm l ln lo">doSomething { //Omitting ()<br/>    "This is a trailing closure, notice there is no function call"<br/>}</span></pre><blockquote class="lq"><p id="5c37" class="lr ls hi bd lt lu lv lw lx ly lz jj dx translated">专业提示:如果一个匿名函数接受参数，你必须确认所有的参数。要么使用它们，要么用下划线忽略它们。</p></blockquote></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="dfc2" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">使用闭包</strong></h1><p id="d0f2" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated"><strong class="io hj">规则1 </strong>:就像函数一样，你可以给变量分配闭包，稍后或者立即调用它们。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b48e" class="kn jl hi lh b fi ll lm l ln lo">let closure = {<br/>    return "This is a closure"<br/>}</span><span id="4f1b" class="kn jl hi lh b fi lp lm l ln lo">print(closure()) //prints "This is a closure"</span><span id="748e" class="kn jl hi lh b fi lp lm l ln lo">func f() -&gt; String {<br/>    return "Functions look pretty similar to closures, right?"<br/>}</span><span id="6e34" class="kn jl hi lh b fi lp lm l ln lo">let varFunc = f<br/>print(varFunc())</span></pre><p id="4208" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ma">注意:你也可以定义然后调用闭包。请习惯这一点，因为这是初始化实例属性时非常常见的模式。</em></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="db59" class="kn jl hi lh b fi ll lm l ln lo">let closure = {<br/>    return "This is a closure"<br/>}()</span></pre><p id="6293" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">规则2 :闭包不使用参数标签。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d854" class="kn jl hi lh b fi ll lm l ln lo">let printThis = { (str: String) in<br/>    print("This is a \(str)")<br/>}<br/>printThis("string") //vs func equivalent printThis(str: "string")</span></pre><p id="5616" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">规则3:在任何使用变量的地方，你都可以用闭包来代替。通常，函数有参数，比如整型、字符串或数组。在下面的例子中，我们使用闭包printThis作为新函数closureAsParam中的变量。有几件事情正在发生，所以让我们把它分解成它的组件。我们有一个新的函数closureAsParam，它接受一个闭包。这个闭包参数也接受一个字符串并返回void，表示为(String) - &gt; Void。我们从函数中调用闭包，并向它提供字符串“插入值”。</p><p id="2570" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以当我们调用这个函数closureAsParam时，我们可以提供任何接受一个字符串并返回void的闭包。在我们的例子中，我们使用闭包printThis，有效地调用printThis(“插入的值”)。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="24e5" class="kn jl hi lh b fi ll lm l ln lo">func closureAsParam(closureParam: (String) -&gt; Void){<br/>    closureParam("inserted value")<br/>}</span><span id="0cbb" class="kn jl hi lh b fi lp lm l ln lo">closureAsParam(closureParam: printThis)</span></pre><p id="df68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ma">注意:你可以用两个括号()代替Void </em></p><p id="51f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则4 </strong>:如果一个函数的最后一个参数是闭包，你可以在花括号中的函数调用之后传递你的闭包。这就是所谓的尾随闭包。假设您想要更改closureAsParam函数，但不想直接修改该函数。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="bc3d" class="kn jl hi lh b fi ll lm l ln lo">closureAsParam() { _ in<br/>    printThis("different value") //'This is a different value'<br/>}</span></pre><p id="6668" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">规则5 </strong>:闭包捕获对外部变量的引用，并可以在其中存储值。当你把一个函数/闭包赋给一个变量时，你设置了这个变量被这个函数/闭包引用。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b8a4" class="kn jl hi lh b fi ll lm l ln lo">class someClass {<br/>    var someVar = "This is the original value"<br/>    func printVar() {<br/>        print(self.someVar)<br/>    }<br/>}</span><span id="51fe" class="kn jl hi lh b fi lp lm l ln lo">func runFunc(_ f:() -&gt; ()) {<br/>    f()<br/>}</span><span id="2c40" class="kn jl hi lh b fi lp lm l ln lo">let ex = someClass()<br/>ex.printVar() //"This is the original value"<br/>ex.someVar = "This is a new value"</span><span id="91be" class="kn jl hi lh b fi lp lm l ln lo">let ex2 = ex.printVar<br/>runFunc(ex2) //"This is a new value"</span></pre><p id="04c6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个例子中，我们创建了一个someClass的实例，并将someVar设置为一个新值。然后我们将ex2设置为函数printVar。我们不显式调用ex.printVar()，而是将函数作为值传递。所以当我们运行函数runFunc时，我们可以访问一个someVar的引用。因此，如果我们更改ex.someVar，当我们运行runFunc时，它也会反映所有新的更改！！</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="944e" class="kn jl hi lh b fi ll lm l ln lo">let ex = someClass()<br/>let ex2 = ex.printVar</span><span id="dfb9" class="kn jl hi lh b fi lp lm l ln lo">runFunc(ex2) //"This is the original value"<br/>ex.someVar = "New Value"</span><span id="52e0" class="kn jl hi lh b fi lp lm l ln lo">runFunc(ex2) //"New Value"</span></pre><p id="88d2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们没有改变ex2，刚刚发生了什么？ex1和ex2都引用了someClass的同一个实例！</p><p id="2748" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看另一个捕获闭包内的值的例子:今天你和同事打了几次招呼？</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1463" class="kn jl hi lh b fi ll lm l ln lo">func greeting () -&gt; (String) -&gt; (){<br/>    var greetings = 0</span><span id="327d" class="kn jl hi lh b fi lp lm l ln lo">    return { name in<br/>        print("Hey \(name), how about that weather though?")<br/>        greetings +=1<br/>    }</span><span id="515d" class="kn jl hi lh b fi lp lm l ln lo">}</span><span id="614c" class="kn jl hi lh b fi lp lm l ln lo">let hi = greeting()<br/>hi("Vincent") //Greetings = 1<br/>hi("Tiffany") //Greetings = 2<br/>hi("Brian") //Greetings = 3</span></pre><p id="ac6e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">即使greetings在该函数的范围内，我们的闭包仍然有对它的引用。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="3588" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">闭包的用例</h1><ol class=""><li id="5492" class="mb mc hi io b ip ki it kj ix md jb me jf mf jj mg mh mi mj bi translated"><strong class="io hj">代码更短<br/> </strong>如果一个函数接受另一个函数，尽量用闭包代替。</li></ol><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ab9f" class="kn jl hi lh b fi ll lm l ln lo">var nums = [1,2,3,4,5]<br/>evenNumsFirst = nums.sorted(by: {num1 % 2 &lt; num2 % 2 })</span><span id="08bf" class="kn jl hi lh b fi lp lm l ln lo">evenNumsFirst //[2, 4, 1, 3, 5]</span></pre><p id="3c8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">你有一个返回函数的函数(高阶函数)<br/> </strong>在考虑什么时候使用闭包的时候，永远记住DRY原则。任何时候你有硬编码的值，或者重复的代码，这可能是一个重构代码的好机会！</p><h1 id="3499" class="jk jl hi bd jm jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh bi translated"><strong class="ak">接下来是什么？</strong></h1><p id="6597" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如果您刚刚开始学习swift，那么使用闭包还有很多内容！首先，掌握使用闭包的基本知识。然后，在继续学习转义和自动关闭之前，尝试在代码中使用它们。</p><p id="dfbb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">和往常一样，如果你想深入了解，我建议你通读文档:<a class="ae mp" href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/closures . html</a></p></div></div>    
</body>
</html>