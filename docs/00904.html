<html>
<head>
<title>Netflix Million Dollar Challenge: Understanding the algorithm that won a million dollars</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网飞百万美元挑战:理解赢得百万美元的算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/netflix-million-dollar-challenge-understanding-the-algorithm-that-won-a-million-dollar-f6556060e7a0?source=collection_archive---------9-----------------------#2019-09-17">https://medium.com/analytics-vidhya/netflix-million-dollar-challenge-understanding-the-algorithm-that-won-a-million-dollar-f6556060e7a0?source=collection_archive---------9-----------------------#2019-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="80c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为各种产品和服务提供推荐是普遍存在的。一个主要的例子是网飞。2006年，网飞向全世界的数据科学家发出公开挑战:将他们现有的推荐系统提高10%，赢得100万美元。他们开放了一个庞大的训练和测试数据集，供数据科学家使用。<a class="ae jd" href="https://datajobs.com/data-science-repo/Recommender-Systems-%5BNetflix%5D.pdf" rel="noopener ugc nofollow" target="_blank"> Koren等人</a>最终凭借他们的矩阵分解算法获奖。</p><h1 id="defc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">背景</h1><p id="92bb" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">存在多个推荐系统，即，为特定用户提供推荐。其中一种方法被称为<em class="kh">基于内容的过滤</em>方法，您可以为项目和用户创建配置文件，并根据这些配置文件(配置文件的内容)给出推荐，即喜欢动作片的人会喜欢被标记为“动作”的电影，或者你可以说一个年轻的男性青少年(人口统计数据)平均来说可能喜欢快节奏的动作片。这样做的明显缺点是，您需要收集关于项目和用户的数据。另一种方法叫做c <em class="kh">人工过滤</em>，依靠用户过去的行为来预测未来的行为。</p><p id="c4b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">协同过滤</em>的两个主要领域是<em class="kh">邻域方法</em>和<em class="kh">潜在因素模型</em>。</p><h1 id="fd09" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">邻域方法</h1><p id="a27e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">邻域法的核心是计算项目之间的关系，或者用户之间的关系。面向项目的方法基于同一用户或通过某些因素(即朋友等)彼此相关的一组用户对“相邻”项目的评级来评估用户对项目的偏好。一个产品的邻居是当由相同的用户或用户组评级时倾向于获得相似评级的其他产品。论文中的图1给出了邻域法的直观解释:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/87398e4287f0b94724fc49074dae42e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*vV8sNFTWhkJBZBFYjeRYzQ.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">图取自<a class="ae jd" href="https://datajobs.com/data-science-repo/Recommender-Systems-[Netflix].pdf" rel="noopener ugc nofollow" target="_blank"> Koren等人。艾尔。</a></figcaption></figure><h1 id="f16e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">潜在因素模型(LFM)</h1><p id="4752" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">LFM完全依赖于用户对项目的评级，并推断出影响用户评级背后的决定的因素，即用户评级拯救大兵瑞恩高是因为他们普遍喜欢战争电影吗？</p><h1 id="5bac" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">矩阵分解</h1><p id="3fdf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们的输入是评级矩阵R (n x m)，其中每行是一个用户，每列是一部电影。R(I，j)是用户I给电影j的评分，我们把R分解成两个矩阵P(n×k)和Q(k×m)。p(n×k)表示用户对某些潜在因素的偏好，矩阵Q(k×m)表示项目(网飞的电影和表演)中前述潜在因素的存在/不存在。换句话说，对于给定的用户u，P(u)的元素测量用户对在相应因子上较高的项目感兴趣的程度。对于给定的项目I，Q(i)的元素度量该项目拥有那些因素的程度。不幸的是，我们不知道这些因素是什么。但是，一旦我们生成了P和Q，我们就可以对它们进行有根据的猜测。比如生成P和Q后，我们看到拯救大兵瑞恩，珍珠港和现代启示录与因子1的关联度很高。我们还看到，对兄弟乐队评价很高的用户A与因子1的相关性很高。在这一点上，我们有根据的猜测是，因素1指向“战争节目”这一类型。</p><h1 id="a8af" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">将R分解成潜在因子矩阵</h1><p id="acc6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">已知P和Q，我们可以通过以下公式计算R(u，I):</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ku"><img src="../Images/7c5e7b8d91eba50742ed2701b98ae976.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/0*MffrPfO_NjiFknkT"/></div></figure><p id="1cb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们可以为所有用户填充P(u ),为所有项目填充Q(i ),那么我们就可以预测用户的评分，这反过来又可以用于给出推荐。那么我们如何填充P(u)和Q(i)呢？</p><p id="578b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，矩阵P和Q中的所有条目都是未知的。我们通过优化过程建立P和Q。</p><p id="ba2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有多少未知数？P和Q中的所有项，即我们有(nk + km)个未知实数。在优化过程中，我们将随机初始化P和Q，并开始调整它们的所有条目，使得每当R中存在非缺失的评级r(i，j)时，对应的k维向量P(i)和Q(j)的内积将逼近评级r(i，j)。我用P(i)来表示P的第I行，用Q(j)来表示Q的第j列，因为我们知道这个值，所以我们通过用户给定评分和算法近似评分之间的差值来计算估计值的好坏。然后，我们相应地调整P(i)和Q(j ),使这一差值(也称为误差)最小。这是学习步骤，Koren等人使用的过程称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" rel="noopener ugc nofollow" target="_blank">随机梯度下降</a>。</p><p id="9767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当R中缺失了某个评分r(u，v)时(用户u没有对物品v进行评分)，我们只是不知道如何约束P(u)和Q(v)的内积，所以我们只会“随它们去”而不会去管它们。</p><p id="b7c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，用户u评价了其他项目，P(u)的条目肯定会在其他地方被调整；并且类似地，因为项目v被其他用户评级，所以Q(v)的条目将在别处被调整。因此，在优化过程中，P(u)和Q(v)不会保持不变。</p><p id="29da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Koren等人还考虑了用户偏见，例如，用户是严肃的还是随意的电影评论者，以及他们如何随时间而变化。他们将这些偏差投影为时间的函数，并使用它们来了解用户偏差，以便他们可以基于用户的当前偏差给出最佳推荐。例如，一个用户可能以一个不经意的评论者开始了他们的评论之旅，但是随着生活迫使他们变得更加愤世嫉俗，他们变得更加挑剔(所有这些都是假设的！).所以他们最初的电影收视率很高，但他们最近的收视率出现了令人难过的下滑。对于一个普通用户来说，6分似乎很低，但是对于这个新的愤世嫉俗的用户来说，这已经很不错了。我们需要能够识别和利用这些偏见。</p><p id="9e49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且，你是怎么把炒作考虑进去的？我们有时会给一部电影更高的评级，不是因为我们绝对喜欢它，而是因为其他人都喜欢它。或者，这可能是因为奢侈的营销。Koren等人考虑到这一点，在他们的方程中加入了一个置信变量。</p><p id="308a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终等式看起来像这样:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es kv"><img src="../Images/6df86dbb2ac20cb2e1da84fc2fc6ad41.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*lWUS3WYzqOIaCYuHskN3uA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">图片来自Koren等人。艾尔。</figcaption></figure><p id="cce2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，c(u，I)是置信度，r(u，I)是用户给出的评级，mu是所有电影的平均评级，b(u)是用户偏差，b(i)是电影偏差，p(u)T.q(i)是算法近似评级。</p><p id="7bf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇文章能对这篇了不起的论文有所启发！看到他们仅仅从用户评分中推断出的数据令人震惊。</p></div></div>    
</body>
</html>