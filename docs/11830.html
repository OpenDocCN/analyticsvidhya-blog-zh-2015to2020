<html>
<head>
<title>Asynchronous Javascript (2) — More about promise and async await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步 Javascript (2) —关于 promise 和异步 await 的更多信息</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asynchronous-javascript-2-418e0d27c006?source=collection_archive---------14-----------------------#2020-12-20">https://medium.com/analytics-vidhya/asynchronous-javascript-2-418e0d27c006?source=collection_archive---------14-----------------------#2020-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0fd79dd77545eca7d62862f4f863c7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmKmRRuxjsQZPgahMG3o6Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">三一学院的图书馆</figcaption></figure><ol class=""><li id="2629" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">更多关于承诺</li></ol><ul class=""><li id="934f" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">Promise.resolve()</li></ul><p id="3f5b" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">大多数情况下，我们返回一个具有给定值的已解析的承诺对象，该值可以是任何东西，它可以是另一个承诺或可有陈述，如果该值是可有陈述，那么履行状态将取决于它。更多信息，请参考<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" rel="noopener ugc nofollow" target="_blank"> MDN 文档</a></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="a8e8" class="km kn hi ki b fi ko kp l kq kr">Promise.resolve("finished").then(data=&gt; {console.log(data)})</span><span id="a1b5" class="km kn hi ki b fi ks kp l kq kr">//output<br/>//finished</span></pre><ul class=""><li id="4007" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">承诺.拒绝()</li></ul><p id="3ec3" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">与 Promise.resolve()相同，但返回一个被拒绝的承诺，其他相同</p><p id="a05b" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi">_______________________________________________________________</p><p id="bbec" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">下面是处理多重承诺的内置承诺函数</p><p id="df4d" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">我们将重复使用上一篇文章中的例子</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="6476" class="km kn hi ki b fi ko kp l kq kr">//Promisfied setTimeout<br/>const delay = (msg, ms) =&gt; new Promise(resolve =&gt; setTimeout(<br/>() =&gt; resolve(msg), ms));</span><span id="47a5" class="km kn hi ki b fi ks kp l kq kr">//Promisfied navigator.geolocation.getCurrentPosition<br/>const geoLocation = (opts) =&gt; new Promise((resolve, reject) =&gt; navigator.geolocation.getCurrentPosition(<br/>posData=&gt;{resolve(posData)}, error=&gt;{reject(error)}, opts));</span></pre><ul class=""><li id="4174" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">Promise.race() <br/>同时启动多个承诺并只返回最快承诺的结果</li></ul><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="c92f" class="km kn hi ki b fi ko kp l kq kr">Promise.race([delay("abc", 0), geoLocation()]).then(data =&gt; {console.log(data)});</span><span id="515e" class="km kn hi ki b fi ks kp l kq kr">//print abc, as we wait 0 second(immediately) to do that<br/>//abc</span><span id="f79e" class="km kn hi ki b fi ks kp l kq kr">Promise.race([delay("abc", 3000), geoLocation()]).then(data =&gt; {console.log(data)});</span><span id="8fcb" class="km kn hi ki b fi ks kp l kq kr">//print location data, as it faster than print abc this time<br/>//GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1608386922668}</span></pre><ul class=""><li id="bcae" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">同时启动多个承诺，如果其中一个失败，它将停止并返回错误——全有或全无。</li></ul><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="056e" class="km kn hi ki b fi ko kp l kq kr">Promise.all([delay("abc", 3000), geoLocation()]).then(data =&gt; {console.log(data)});</span><span id="85c2" class="km kn hi ki b fi ks kp l kq kr">//allow the location access this time<br/>//print result of both promise<br/>//["abc", GeolocationPosition]</span><span id="a838" class="km kn hi ki b fi ks kp l kq kr">Promise.all([delay("abc", 3000), geoLocation()]).then(data =&gt; {console.log(data)}).catch(error =&gt; {console.log(error)});</span><span id="e6f6" class="km kn hi ki b fi ks kp l kq kr">//prints the error as we block the retrieve of location<br/>//GeolocationPositionError {code: 1, message: "User denied Geolocation"}</span></pre><ul class=""><li id="f7e9" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">Promise.allSettled()</li></ul><p id="22fb" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">同时启动多个承诺，并返回每个承诺的详细状态</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="ebb3" class="km kn hi ki b fi ko kp l kq kr">Promise.allSettled([delay("abc", 3000), geoLocation()]).then(data =&gt; {console.log(data)}).catch(error =&gt; {console.log(error)});</span><span id="4824" class="km kn hi ki b fi ks kp l kq kr">//allow the location access this time<br/>//print detail status for both promise<br/>//[{status: "fulfilled", value: "abc"}, {status: "fulfilled", value: GeolocationPosition}]</span><span id="39e0" class="km kn hi ki b fi ks kp l kq kr">Promise.allSettled([delay("abc", 3000), geoLocation()]).then(data =&gt; {console.log(data)}).catch(error =&gt; {console.log(error)});</span><span id="58e0" class="km kn hi ki b fi ks kp l kq kr">//block the location access this time<br/>//print detail status for both promise<br/>//[{status: "fulfilled", value: "abc"}, {status: "rejected", reason: GeolocationPositionError}]</span></pre><p id="bd20" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">2.异步等待</p><p id="8a20" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">除了回调和承诺，Javascript 中还有另一种编写异步代码的语法——async await，它们是两个保留关键字，但我们经常一起使用它们。它类似于承诺，有时我们甚至说这是承诺的句法糖。</p><p id="78ce" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">像 promise 一样，我们不能仅仅用 async await 来包装异步代码，如果它们没有返回 promise，我们必须首先向它们许诺。详情请参考<a class="ae kc" rel="noopener" href="/analytics-vidhya/asynchronous-javascript-1-callbacks-and-promise-5f9ffc61b2e5">最后一段</a></p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="74cb" class="km kn hi ki b fi ko kp l kq kr">//Promisfied setTimeout<br/>const delay = (msg, ms) =&gt; new Promise(resolve =&gt; setTimeout(<br/>() =&gt; resolve(msg), ms));</span><span id="388a" class="km kn hi ki b fi ks kp l kq kr">//Promisfied navigator.geolocation.getCurrentPosition<br/>const geoLocation = (opts) =&gt; new Promise((resolve, reject) =&gt; navigator.geolocation.getCurrentPosition(<br/>posData=&gt;{resolve(posData)}, error=&gt;{reject(error)}, opts));</span></pre><p id="9f93" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">请考虑 promise 中的以下代码片段</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9ef8" class="km kn hi ki b fi ko kp l kq kr">delay('Some task required before retrieving location', 0)<br/>.then(data =&gt; console.log(data))<br/>.then(() =&gt; geoLocation())<br/>.then(data =&gt; {console.log(data); return delay('Some task after getting the location', 0)})<br/>.catch(err =&gt; {console.log(err); return delay('Some task after fail getting the location', 0)})<br/>.then(data =&gt; console.log(data));</span></pre><p id="829c" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">我们可以像这样在异步等待中实现它</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="bb09" class="km kn hi ki b fi ko kp l kq kr">async function doSomeTask() {</span><span id="c34e" class="km kn hi ki b fi ks kp l kq kr">   const msgBeforeLoc = await delay('Some task required before retrieving location', 0);<br/>   console.log(msgBeforeLoc);</span><span id="0912" class="km kn hi ki b fi ks kp l kq kr">   try {<br/>      const loc = await geoLocation();<br/>      console.log(loc);<br/>      const msgAfterLoc = await delay('Some task after getting the location', 0);<br/>      console.log(msgAfterLoc);<br/>   }  catch(error) {<br/>      console.log(error);<br/>      const msgAfterLoc = await delay('Some task after fail getting the location', 0);<br/>      console.log(msgAfterLoc);      <br/>   }<br/>}</span><span id="90ab" class="km kn hi ki b fi ks kp l kq kr">doSomeTask();</span></pre><p id="713c" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">让我们看看细节</p><ul class=""><li id="411c" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">函数前面的“async”关键字</li></ul><p id="f25f" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">我们必须用“async”来包装函数中的所有内容。这个函数将<strong class="iw hj">返回一个解析的承诺</strong>不管我们现在返回什么，甚至我们没有返回语句<br/>，这意味着我们可以在后面附加一个“then”语句，它将成为一个承诺链。</p><ul class=""><li id="400a" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">语句前面的“await”关键字</li></ul><p id="ceed" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">如上所述，它只支持 promise，如果异步代码没有返回 promise，你必须首先承诺它。在上面的例子中，我承诺 setTimeout 和 navigator . geolocation . getcurrentposition，它们分别在“delay”和“geoLocation”中。</p><p id="cf80" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">所以，我们只是像使用一个普通函数一样使用它们，在它的前面加上“await”。在 Javascript 引擎中，它会将每个语句转换成“then”语句并依次执行，就像 promise 中的“then”语句一样。结果将存储在我们为其分配 await 语句的变量中，而不是存储在 promise 链中的下一个“then”语句中</p><ul class=""><li id="8553" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">错误处理</li></ul><p id="648d" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">Async await 不像 promise 那样提供任何错误处理，但是如上所示，我们可以使用 try catch 语句</p><ul class=""><li id="04c7" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">没有等待的异步怎么样？</li></ul><p id="d4be" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">让我们试着移除函数中的“await”。</p><p id="56cf" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">我们仍然可以运行代码，但很快我们会发现那些异步代码不起作用，似乎 Javascript 引擎没有意识到它们是异步调用，它不再“等待”它们返回结果，因此我们会在日志中看到“Promise <pending/></p><p id="132f" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">来自<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#Description" rel="noopener ugc nofollow" target="_blank"> Mozilla docs </a></p><p id="84b2" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated"><em class="kt">“Await 表达式通过一个异步函数挂起进程，产生控制，然后仅当一个等待的基于承诺的异步操作被完成或拒绝时才恢复进程。”</em></p><p id="f373" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">这意味着我们必须在每个调用异步代码的语句前添加“await”</p><ul class=""><li id="db00" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">没有异步的 await 怎么样？</li></ul><p id="8201" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">让我们试着去掉函数前面的“async”关键字。</p><p id="c422" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">这将导致编译错误，没有异步，我们不能使用 await</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/b282beb04d607deae2bf7a5c70c60892.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*uY-UhKKtNL0y5xV7FfuOJQ.jpeg"/></div></figure><ul class=""><li id="9070" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">调用多个异步 await 函数</li></ul><p id="4c2d" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">考虑下面的例子</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d884" class="km kn hi ki b fi ko kp l kq kr">const delay = (msg, ms) =&gt; new Promise(resolve =&gt; setTimeout(<br/>() =&gt; resolve(msg), ms));</span><span id="369d" class="km kn hi ki b fi ks kp l kq kr">async function funcA() {<br/>   console.log('before a')<br/>   await delay('a', 2000).then(data=&gt; {console.log(data)});<br/>   console.log('after a')<br/>}<br/>async function funcB() {<br/>   console.log('before b')<br/>   await delay('b', 2000).then(data=&gt; {console.log(data)});<br/>   console.log('after b')<br/>}<br/>function run() {<br/>      funcA();<br/>      funcB();<br/>}<br/>run();</span></pre><p id="88bf" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">它可以打印</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="1f59" class="km kn hi ki b fi ko kp l kq kr">before a<br/>before b<br/>a<br/>after a<br/>b<br/>after b</span></pre><p id="12e1" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">代替</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="498d" class="km kn hi ki b fi ko kp l kq kr">before a<br/>a<br/>after a<br/>before b<br/>b<br/>after b</span></pre><p id="4498" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">事实上，调用者也必须用异步 await 来实现</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="6a5d" class="km kn hi ki b fi ko kp l kq kr">async function run() {<br/>      await funcA();<br/>      await funcB();<br/>}<br/>run();</span></pre><p id="28c3" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">或者我们也可以用承诺来实现</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="d217" class="km kn hi ki b fi ko kp l kq kr">funcA().then(data =&gt; {funcB()})</span></pre><p id="eb17" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">3.承诺 vs 异步等待</p><ul class=""><li id="5a59" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">更简单、更少的代码</li></ul><p id="2128" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">Async await 得到的代码量少得多，只包装在一个“Async”函数中，并在调用异步代码的每个语句中添加了一个“await”关键字，结果将只存储在我们将 await 语句分配给它的变量中。相比之下，承诺链总是需要另一个。然后()语句进行下一步操作，或者只处理响应</p><ul class=""><li id="b350" class="iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh jm jj jk jl bi translated">隐形然后屏蔽</li></ul><p id="d398" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">考虑 promise <br/>中的代码(只是重复使用上一节的例子，但是添加了一个控制台日志来打印其他任务)</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="4016" class="km kn hi ki b fi ko kp l kq kr">function trackUserHandler() {<br/>delay('Some task required before retrieving location', 0)<br/>.then(data =&gt; console.log(data))<br/>.then(() =&gt; geoLocation())<br/>.then(data =&gt; {console.log(data); return delay('Some task after getting the location', 0)})<br/>.catch(err =&gt; {console.log(err); return delay('Some task after fail getting the location', 0)})<br/>.then(data =&gt; console.log(data));</span><span id="3502" class="km kn hi ki b fi ks kp l kq kr">console.log("other task");<br/>}</span></pre><p id="2d74" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">以及 async await <br/>中的代码(只是重复使用上一节中的例子，但是添加了一个控制台日志来打印其他任务)</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="07f5" class="km kn hi ki b fi ko kp l kq kr">async function doSomeTask() {<br/>   const msgBeforeLoc = await delay('Some task required before retrieving location', 0);<br/>   console.log(msgBeforeLoc);<br/>   try {<br/>      const loc = await geoLocation();<br/>      console.log(loc);<br/>      const msgAfterLoc = await delay('Some task after getting the location', 0);<br/>      console.log(msgAfterLoc);<br/>   }  catch(error) {<br/>      console.log(error);<br/>      const msgAfterLoc = await delay('Some task after fail getting the location', 0);<br/>      console.log(msgAfterLoc);      <br/>   }<br/>   console.log("other task");<br/>}</span></pre><p id="76c6" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">在上一节中，我提到它们产生相同的输出，让我们再试一次新版本</p><p id="3297" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">Promise 示例首先打印“other task”<br/>像回调一样，它首先执行同步任务</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="9822" class="km kn hi ki b fi ko kp l kq kr">other task<br/>Some task required before retrieving location<br/>GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1608277437934}<br/>Some task after getting the location</span></pre><p id="ada8" class="pw-post-body-paragraph jn jo hi iw b ix iy jp jq iz ja jr js jb jt ju jv jd jw jx jy jf jz ka kb jh hb bi translated">然而，async await 示例最后打印了“其他任务”<br/>，因为在 async 函数中，即使我们没有在 console . log(‘其他任务’)前面添加 await，但是 Javascript 引擎仍然会用一个不可见的“then”来包装它们，这就是为什么</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b1fc" class="km kn hi ki b fi ko kp l kq kr">Some task required before retrieving location<br/>GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1608277486716}<br/>Some task after getting the location<br/>other task</span></pre></div></div>    
</body>
</html>