<html>
<head>
<title>Clustering Taxi Geolocation Data To Predict Location of Taxi Service Stations (Pt 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类出租车地理位置数据以预测出租车服务站的位置(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-pt-1-2471303e0965?source=collection_archive---------8-----------------------#2020-08-04">https://medium.com/analytics-vidhya/clustering-taxi-geolocation-data-to-predict-location-of-taxi-service-stations-pt-1-2471303e0965?source=collection_archive---------8-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d8ca2a3488d5f45581f1d4da553f078c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*001GKx6-cEcs0j4mq-mg5A.png"/></div></div></figure><p id="981e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是<em class="jo">“聚类出租车地理位置数据以预测出租车服务站位置”的分步指南。</em></p><p id="d254" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个很大的话题，所以我决定分成两部分，本文是第一部分。</p><p id="0d29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个领域的任何人，请不要被这个话题吓跑。一旦你掌握了窍门，这就很容易了。坚持到最后，好吗？这会很长(提前道歉)。</p><p id="47a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有，这是我第一个真正意义上的机器学习项目。天知道我研究这个课题的时间和梅林的胡子变白的时间一样长。</p><p id="a211" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总之，Coursera提供了广泛的指导项目。这是其中之一。你可以在这里查看:</p><p id="81d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">https://www.coursera.org/courses?query=guided%20projects<a class="ae jp" href="https://www.coursera.org/courses?query=guided%20projects" rel="noopener ugc nofollow" target="_blank"/></p><p id="408b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">词。确保你花了大量的时间来理解你的项目。在谷歌上阅读背景资料，写一份个人报告可以创造奇迹。</p><h1 id="14ec" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">关于ML你需要知道什么</h1><p id="7723" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">机器学习</strong>是一个研究领域，它赋予计算机无需明确编程就能学习的能力。ML是人们曾经遇到过的最令人兴奋的技术之一。顾名思义，它赋予了计算机使其更类似于人类的能力:<strong class="is hj"> <em class="jo">学习</em> </strong>的能力。今天，机器学习正在被积极地使用，也许在比你想象的更多的地方。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/3d7c7e0174fdc91049eff50d73b9b547.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*YD3IDdwwEacxK0Vz0afB_w.png"/></div></figure><ol class=""><li id="4ee1" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><strong class="is hj">监督与非监督机器学习:</strong></li></ol><div class="lh li ez fb lj lk"><a rel="noopener follow" target="_blank" href="/@gowthamy/machine-learning-supervised-learning-vs-unsupervised-learning-f1658e12a780"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">机器学习:监督学习与非监督学习</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">这个博客是关于监督和非监督学习技术的简短讨论</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly io lk"/></div></div></a></div><p id="a18b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hj">回归vs分类:</strong></p><div class="lh li ez fb lj lk"><a rel="noopener follow" target="_blank" href="/fintechexplained/supervised-machine-learning-regression-vs-classification-18b2f97708de"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">监督机器学习:回归与分类</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">在这篇文章中，我将解释回归和分类监督机器学习之间的主要区别…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="lz l lv lw lx lt ly io lk"/></div></div></a></div><p id="55dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.<strong class="is hj">聚类:</strong></p><div class="lh li ez fb lj lk"><a rel="noopener follow" target="_blank" href="/datadriveninvestor/an-introduction-to-clustering-61f6930e3e0b"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">聚类的介绍</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">聚类被认为是无监督学习中最重要的技术。在这篇博客中，我们将尝试…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="ma l lv lw lx lt ly io lk"/></div></div></a></div><h1 id="425e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">先决条件:</h1><ol class=""><li id="0b6c" class="ky kz hi is b it ko ix kp jb mb jf mc jj md jn ld le lf lg bi translated"><a class="ae jp" href="https://drive.google.com/drive/u/0/folders/1j31pTDkqjE3IK2fEunaUjUAzmjIy-hBF" rel="noopener ugc nofollow" target="_blank">数据集</a></li><li id="3741" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://github.com/sanjanamops8752/Clustering-Taxi-Geolocation-Data-To-Predict-Location-of-Taxi-Stands/blob/master/Clustering_Geolocation_data_intelligently_in_Python.ipynb" rel="noopener ugc nofollow" target="_blank"> Github代码</a></li><li id="53c1" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated">熊猫</li><li id="25f4" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://jakevdp.github.io/PythonDataScienceHandbook/04.00-introduction-to-matplotlib.html" rel="noopener ugc nofollow" target="_blank">Matplotlib</a>(<a class="ae jp" href="http://matplotlib.sourceforge.net/api/pyplot_api.html#module-matplotlib.pyplot" rel="noopener ugc nofollow" target="_blank">py plot</a></li><li id="9aa8" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://www.edureka.co/blog/python-numpy-tutorial/" rel="noopener ugc nofollow" target="_blank"> Numpy </a></li><li id="371c" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://www.kaggle.com/daveianhickey/how-to-folium-for-maps-heatmaps-time-analysis" rel="noopener ugc nofollow" target="_blank">叶子</a></li><li id="2ee9" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://scikit-learn.org/stable/tutorial/basic/tutorial.html" rel="noopener ugc nofollow" target="_blank"> Scikit学习</a></li><li id="dcd0" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://books.google.co.in/books?id=bOh1DwAAQBAJ&amp;pg=PA356&amp;lpg=PA356&amp;dq=X%5B50:100,+:%5D+in+python+meaning&amp;source=bl&amp;ots=oL0anyRPsk&amp;sig=ACfU3U397lY-XN_eRAnCdhDauBbWW9v6ZA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjsht2L9-zpAhVizDgGHf-BBboQ6AEwCnoECAcQAQ#v=onepage&amp;q=X%5B50%3A100%2C%20%3A%5D%20in%20python%20meaning&amp;f=false" rel="noopener ugc nofollow" target="_blank">K-表示</a></li><li id="903a" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://towardsdatascience.com/understanding-k-means-clustering-in-machine-learning-6a6e67336aa1" rel="noopener" target="_blank"> K均值聚类</a></li><li id="60a6" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn ld le lf lg bi translated"><a class="ae jp" href="https://scikit-learn.org/stable/modules/clustering.html" rel="noopener ugc nofollow" target="_blank">其他聚类形式</a></li></ol><h1 id="776f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">问题陈述和我们的解决方法:</h1><p id="b2e7" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">出租车候客处是出租车待命时的位置。我们需要分析他们的地理位置数据，以了解在哪里使用集群建立服务站。一种简单的方法是在每个集群的中心建立一个服务站，为属于该集群的每辆出租车提供服务。在使用更复杂的基于密度的算法DBSCAN之前，您将学习如何首先使用K-Means方法进行聚类。我们将讨论如何评估这些模型，并通过引入HDBSCAN对DBSCAN进行改进。</p><h1 id="c450" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">开始使用:</h1><p id="6771" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我用Google Colab做编码。</p><ol class=""><li id="e5a5" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">从本地系统导入文件:</li></ol><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/d1bd14ce1eb2c6a4b58f3bdf44abc754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLnloA4E_QvPHokrw5LUuA.png"/></div></div></figure><p id="6574" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.导入将在项目中使用的库和颜色(col)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/3de4b9c67e8ed313bc6adc9c54b1d2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2NBLaKHi1JHX8NzUOvy4Q.png"/></div></div></figure><h1 id="f59b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.探索性数据分析</h1><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/c11a8931153170c7623cb353869911fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WHugBNZuOJayx_OBXKMKQ.png"/></div></div></figure><p id="e6a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从数据帧中读取数据，并检查任何重复值和空值。我们有一些重复值和空值。我们的下一步是移除它们。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/cbab973a0005c19cde18fc8e1b6467b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PaPj8vB-qSHVC5GQX8hv9w.png"/></div></div></figure><p id="cb14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个框架代码，它可以帮助我们查看这些更改前后的数据框。我们使用df.head()来检查我们的数据帧看起来是否相同。是的，它是。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/9a1d1b3de0410bed0586aa5f0fe70062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smAIamUkhl2xyfpY_GSt7Q.png"/></div></div></figure><p id="a149" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将纬度和经度值提取为一个numpy数组。数据类型是一种数据，我们希望可视化我们的lat和lon，因为它们是很大的数字。</p><p id="b3a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">dt = np.dtype('float64') <em class="jo"> # 64位浮点数</em></p><p id="c021" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们<a class="ae jp" href="https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.scatter.html" rel="noopener ugc nofollow" target="_blank">散布图</a> X</p><ul class=""><li id="99ca" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated"><strong class="is hj">alpha</strong>:alpha混合值，介于0(透明)和1(不透明)之间。帮助查看图表中人口密集的区域。</li><li id="af74" class="ky kz hi is b it me ix mf jb mg jf mh jj mi jn mo le lf lg bi translated"><strong class="is hj"> s </strong>:为点的大小。</li></ul><p id="3008" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一个可视化中，我们将在地图上看到相同的散点图。因为很难理解有多少小点属于一个区域。</p><h1 id="8b1f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.可视化地理数据</h1><p id="f177" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了绘制漂亮的交互式地理数据，我们使用了一个用Python编写的叫做Folium的漂亮的包。</p><p id="8052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在编写代码时，我们需要给出位置，以便follow可以处理我们最初想要可视化地图的位置。因为它需要纬度和经度的值，对我们来说最简单的方法就是从我们已经有的数据帧中取纬度和经度的平均值。我们的地图将从那里开始。然后我们给出缩放值和平铺值，这基本上是地图的颜色方案。我们运行<strong class="is hj">‘m’</strong>来准备好地图。(Img1中的输出由Img2中的前两行代码给出)</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/0842a0e66190200c90276714711f139e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*C45aCU5D-5Jl3UGS0ot3sQ.png"/></div><figcaption class="mq mr et er es ms mt bd b be z dx translated">Img1</figcaption></figure><p id="4355" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将出租车等级的数据添加到地图中，我们可以通过迭代添加数据框的所有行和列来完成此操作。这就是leav的工作方式，将来当我们给每个集群案例命名时，这将变得很容易。</p><p id="408d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码中使用了“”,因为它返回了我们正在查看的行号的元组和实际的行信息。我们用一个圆形标记来标出纬度和经度。为了方便起见，我们给它一个半径值。然后是一个弹出值，即当我们单击圆圈时会弹出什么值。我们还通过指定颜色的十六进制值来设置颜色。然后我们设置填充颜色为真，用同样的颜色填充圆圈，因为它看起来很好。我们把圆圈标记加到m上。</p><p id="aee5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们运行代码Img2，并再次运行<strong class="is hj">‘m’</strong>以获取Img2输出作为输出。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/8b2256457b39d0769222dd05e3acab36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAw5CsffcY4-ln8pQpVcHw.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated">Img2</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/c8bf5e35a55a8f77bc629d6d58f39185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blg87cdGN9jQ7EFIQ8OJDA.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated">Img2输出</figcaption></figure><p id="361d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们单击小圆圈，我们将看到每个出租车等级详细信息的小弹出窗口。我们也可以放大并看到高度密集的点的位置。</p><p id="f732" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将了解如何确定群集的强度。</p><h1 id="eb7c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.聚类强度/性能指标</h1><p id="de5e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在这里，我们将测试聚类算法，并看看是否通过改变它在聚类方面有所改进。我们将通过使用scikit-learn的<strong class="is hj">‘make _ blobs’</strong>函数创建测试数据来开始这一部分。<a class="ae jp" href="https://machinelearningmastery.com/generate-test-datasets-python-scikit-learn/#:~:text=The%20make_blobs()%20function%20can,a%20host%20of%20other%20properties." rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> make_blobs </strong>()函数</a>可用于生成具有高斯分布的点的斑点。您可以控制要生成的斑点数量和要生成的样本数量，以及许多其他属性。</p><p id="cb8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用[:，0]表示数组的所有行和第0列，使用[:，1]表示数组的所有行和第1列。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/c17bd63fa7996dff6e6b3306ecbd5d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*satfefc_r3uVziJFRqxfsg.png"/></div></div></figure><p id="4b1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">LHS上有四个定义明确的集群，RHS上有四个，右侧的一个看起来像是两个集群的融合。</p><p id="b776" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们要做的是通过运行类预测来创建单独的聚类。(<strong class="is hj">类预测</strong>是一种监督学习方法，其中算法从具有已知<strong class="is hj">类</strong>成员资格(训练集)的样本中学习，并建立<strong class="is hj">预测</strong>规则来对新样本(测试集)进行分类。例如，该方法可用于<strong class="is hj">使用基因组表达谱预测</strong>癌症类型</p><p id="40f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后通过分配颜色(col)来区分它们。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/e459eed2bbec3aa7197ee2a01a6bc058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbnaHPshQZwZWi_odiIAdw.png"/></div></div></figure><p id="a550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出看起来像这样-</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es my"><img src="../Images/e4ab528f5f33727e391fef7d5ab8ede1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*_v-DSdNO_NRbExLktE-c4g.png"/></div></figure><p id="d3f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将使用一个名为<strong class="is hj">剪影分数</strong>的东西。它用于对聚类算法进行评分。它的工作原理是给聚类算法分配一个介于-1和1之间的分数，分数越接近1越好。它检查单个群集与相对群集的中心相比有多好。</p><p id="eb51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">0:表示聚类无关紧要，或者我们可以说聚类之间的距离不显著。</p><p id="e624" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">-1:表示以错误的方式分配簇。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/9f6be80ed2d129472efe94abc86a7fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T4R5h_ridNePm9vm.jpeg"/></div></div></figure><p id="022b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">剪影得分= (b-a)/max(a，b)</p><p id="e531" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在哪里</p><p id="85d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a=平均类内距离，即类内各点之间的平均距离。</p><p id="31e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b=平均聚类间距离，即所有聚类之间的平均距离。</p><p id="17e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">score函数将接受我们考虑的测试数据X_blobs(一个数组)和class_predictions。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/9c09d0f33670ac84d33fc6697d5fb6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpi-LmKqi2MzyJFtM0jd-A.png"/></div></div></figure><p id="8364" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们得到了大约0.66的分数，这很好。现在我们将复制粘贴并再次运行上面的算法(名为改进的),只是为了看看剪影分数是否真的起作用。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/eec34e46713fc3485edf7950d9e653ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51EqeytN87y0KdQ2ug55dA.png"/></div></div></figure><p id="c501" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们得到了一个类似这样的结果:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/694a995c51bb7496cf2fa359fd0c46de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Z_Z9doPbU4wsRqJfeKOOmw.png"/></div></figure><p id="3565" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看到了吗？！我们现在可以区分重叠的星团了。这不是很棒吗？</p><p id="6026" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将再次检查剪影分数，看看它是否有所改善。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/1c13f1a821ca96215d13b8e49ece4b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*q_VyWAO85BBeESlCuqCq0g.png"/></div></figure><p id="252c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太棒了。它有！继续走。你做得很好。我们差不多完成了。</p><h1 id="8efe" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">4.k均值聚类</h1><p id="628f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">这里我们将看看我们的第一个聚类方法，即K均值聚类。我们使用K-means算法运行一些迭代，以便它学习如何以交互的方式对我们的数据进行聚类。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/77aa7de243dc517850cac2a13bb6cf05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlTwTGUZ1cJ4B75poPFizw.png"/></div></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/2fe5ba28bdcec910b5e51d5601611389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83ydQ59yJzHZruTDDTAUkA.png"/></div></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/479fb189d3d1ce245d429818ee3520dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bf92lRvc_j8BPb61rU6Gg.png"/></div></div></figure><p id="057f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们正在谈论的互动情节。从虚拟数据中我们得到了这个图，很明显我们可以给出K=3的值(聚类数)。上面的图也是第10次迭代。</p><p id="cc25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">K-means的工作原理是迭代地找到每个聚类的质心。(了解k-means背后的数学—<a class="ae jp" href="https://heartbeat.fritz.ai/understanding-the-mathematics-behind-k-means-clustering-40e1d55e2f4c" rel="noopener ugc nofollow" target="_blank">https://heart beat . fritz . ai/了解k-means背后的数学—聚类—40 E1 d 55 e 2 f 4c</a>)</p><p id="c90d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法将3个质心随机分配给测试数据聚类(黑色三角形)。</p><p id="cda8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，它对靠近该质心的最近数据点进行聚类，一旦聚类完成(如上图所示)，它将再次迭代地进行聚类，并分配一个新的质心。目前,<strong class="is hj"> x </strong>代表迭代，每次迭代分配一个新的质心(黑色三角形将轻微移动),直到没有发现变化。这是无监督学习，这就是算法如何从数据中学习。</p><p id="5288" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将它的点重新分配到最近的质心簇，这就是为什么我们看到红色黄色和绿色的点随着迭代次数的增加而相互推挤。</p><p id="4bff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是第一次和第二十次迭代的样子。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/267c702283b230e0c6841805c6558845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjzFnqN-J0IslhiRqwf-GA.png"/></div></div></figure><p id="bd27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将继续编码。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/fa70972b5a2b3648df96263d33c80621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSIocPIj5sVPYoUEXVGbmQ.png"/></div></div></figure><p id="181f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">‘k’</strong>值通常基于直觉，很容易用2D数据来猜测，但不能用其他更高维度的数据来猜测。</p><p id="1680" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们指定k=70。然后我们用一些参数来建模。我们使用fit(x)来改变权重(输入变量的系数),使它们符合训练数据集。并且还在数据帧中分配了一列。常见错误:不要忘记在代码中重新定义X。</p><p id="d594" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们调用<strong class="is hj"> df.head() </strong>来查看我们使用的k均值算法的前五个聚类预测。他们结果很好。</p><p id="f9cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在必须像前面一样在地图上想象它。我们需要调用一个函数来创建一个映射，该映射应该包括所讨论的数据帧以及集群列。我们还应该分配一个集群颜色。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/17465440d7b7c147e890f7ef00bd12c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHy_Y-SPZw4VE9cYrZC95A.png"/></div></div></figure><p id="381d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们运行代码时，我们得到k值和轮廓分数。然后我们可以在下一个内核中运行m来获得地图的可视化。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/09f59016fd0702303439f72e0959966a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Na-kzRC9TvHPkby_"/></div></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/9292e5c0c6952f630ca07d69857984f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iADOMaN0wY4eZx8YWHt7dQ.png"/></div></div></figure><p id="3db2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编写此代码是为了迭代“k”的各种值，以查看我们的数据如何工作，并找到此k值的最佳可能轮廓得分范围。我们可以调整我们想要的集群数量的值，但是它也有自己的限制。我们坚持k=70，我们将在下一阶段看到为什么它对我们的数据是一个好值。</p><p id="9dd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终的剪影分数是0.697，比之前的0.637有所提高(向上滚动查看地图上方)。地图出来也很好，但仍有改进的空间。</p><p id="0d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你不觉得地图上的点在中心看起来太拥挤了吗？嗯，这可能是因为K-Means在处理如此高度填充的数据时效果不太好。</p><p id="34ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">市中心的出租车非常密集，随着我们向郊区移动，出租车的数量逐渐减少。我们需要在这样的人口密集地区建立更多的出租车服务站，显然目前的模式很难运作。我们需要其他方法来改进我们目前的模式。</p><p id="ec64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在我的下一篇文章中讨论更多的替代方法。</p></div><div class="ab cl nl nm gp nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hb hc hd he hf"><p id="64b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我真诚地希望你玩得开心，如果有任何改进的空间或者发现了任何错误，请在评论中告诉我。</p><p id="dfe4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们很快会再见面的。</p><p id="0788" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">敬请期待！还有快乐编码！</p></div></div>    
</body>
</html>