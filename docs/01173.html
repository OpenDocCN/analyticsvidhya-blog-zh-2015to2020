<html>
<head>
<title>How does the DB-SCAN algorithm work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DB-SCAN算法是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-does-the-dbscan-algorithm-work-5a18098148d6?source=collection_archive---------3-----------------------#2019-10-06">https://medium.com/analytics-vidhya/how-does-the-dbscan-algorithm-work-5a18098148d6?source=collection_archive---------3-----------------------#2019-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b866bf66153d4411f67c2447a8052e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jI8GVOB6a_xPtxHRm_9wA.png"/></div></div></figure><p id="fdac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">集群这个词意味着相似类型的对象被组合在一起，以显示它们以相似的方式运行。聚类问题是最重要的问题之一，因为它用于了解那些输出变量未给定的问题的数据类型，因此我们需要了解数据的类型。因此，聚类算法开始发挥作用。</p><p id="13b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">带噪声应用的基于密度的空间聚类</strong> ( <strong class="is hj"> DB-SCAN </strong>)是一组数据库和数据挖掘社区在90年代初提出的数据聚类算法。</p><p id="b7ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在我们开始之前，让我们了解一下DB-SCAN的核心概念。</p><p id="d9cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让一个给定的点数据集(数据集D = {xi})，我们必须将点划分成密集区域，我们称之为<em class="jo">簇</em>和稀疏区域，其中可能包含<em class="jo">噪声</em>。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/9852e05f851ebf2d95d8f9d914290438.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*ce0MlvO2XX9sofnw-xUOTw.jpeg"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">稀疏区域是点密度较小的区域，点密度较大的部分是密集区域。</figcaption></figure><p id="5678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们介绍一些关于db-scan的基本主题:</p><p id="39c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo"> eps: </em> </strong> <em class="jo">指定点彼此之间应该有多近才能被认为是聚类的一部分。这意味着如果两点之间的距离低于或等于该值(eps)，则这些点被认为是邻居。</em></p><p id="127c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jo">min points</em></strong><em class="jo">:形成密集区域的最小点数。例如，如果我们将minPoints参数设置为5，那么我们至少需要5个点来形成密集区域。它基本上被称为min_samples。</em></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/e2a27c8af7bc501186258240bfa2103d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*gqjFuPUUectS0lXiKITh8A.png"/></div></figure><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/5046af0988e270d91aa606a9172f1d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjGsqmxCUQ91-5jy7FT62w.png"/></div></div></figure><p id="c0f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法中有三种类型的点——噪声点、核心点和边界点。让我们简单讨论一下这个问题:</p><h2 id="7039" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">核心观点:</h2><ul class=""><li id="388a" class="kv kw hi is b it kx ix ky jb kz jf la jj lb jn lc ld le lf bi translated">如果一个点在其周围<em class="jo"> eps </em>半径内有超过指定数量的m个<em class="jo">内点</em>，则该点是核心点。</li><li id="d675" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">核心点总是属于密集区域。</li><li id="402b" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">例如，如果'<em class="jo"> p' </em>在其周围的<em class="jo"> eps </em>半径内有≥ <em class="jo"> minPoints </em>，那么让我们认为'<em class="jo"> p' </em>被设置为核心点。</li></ul><h2 id="9f86" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">边界点:</h2><ul class=""><li id="fd28" class="kv kw hi is b it kx ix ky jb kz jf la jj lb jn lc ld le lf bi translated">如果一个点在<em class="jo"> Eps </em>内的最小点少于<em class="jo">个，但是在<em class="jo">核心点</em>的邻域内，则称该点为边界点。</em></li><li id="9299" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">例如，如果'<em class="jo"> p' </em>不是核心点，则p被设置为边界点。即'<em class="jo"> p' </em>在<em class="jo"> eps </em>半径内有&lt;T42分点。但是'<em class="jo"> p' </em>应该属于邻区'<em class="jo"> q' </em>。其中'<em class="jo"> q' </em>为核心点。</li><li id="5ee7" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">p∈<em class="jo">q</em>的邻域和距离(<em class="jo"> p，q </em> ) ≤ <em class="jo"> eps </em>。</li></ul><h2 id="408f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">噪音点:</h2><ul class=""><li id="1ccc" class="kv kw hi is b it kx ix ky jb kz jf la jj lb jn lc ld le lf bi translated">噪声点是不是核心点或边界点的任何点</li></ul><h2 id="4b1b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">密度边缘:</h2><p id="74fa" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">如果a和b都是核心点，并且(a，b) ≤ <em class="jo"> eps </em>之间的距离，那么我们可以连接图中的<em class="jo"> p，q </em>顶点，称之为“<em class="jo">密度边</em>”。</p><h2 id="6a91" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">密度连接点:</h2><p id="899c" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">如果a和<em class="jo"> b </em>都是核心点，并且它们存在一条由密度边形成的连接点(a)到点(b)的路径，则称两点a和b是密度连接点。</p><h1 id="2f44" class="lo kb hi bd kc lp lq lr kg ls lt lu kk lv lw lx kn ly lz ma kq mb mc md kt me bi translated">DBSCAN算法:</h1><p id="6c3b" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">因此，给定所有这些术语和概念，让我们进入DBSCAN算法的核心，看看它是如何工作的。</p><h2 id="4492" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">算法:</h2><p id="1a61" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated"><strong class="is hj">步骤1 </strong> : ∀ xi ∈ D，标注点为核心点、边界点和噪点。</p><p id="9fb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步</strong>:去除或消除所有噪声点(因为它们属于稀疏区域。即它们不属于任何集群)。</p><p id="2238" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤3 </strong>:对于每个还没有被分配到集群的核心点<em class="jo"> p </em></p><p id="3210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a)用点<em class="jo"> p </em>创建一个新的集群，并且</p><p id="c170" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b)添加密度连接到<em class="jo"> p </em>的所有点。</p><p id="e201" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第四步</strong>:将每个边界点分配到最近的核心点的聚类中。</p><h2 id="bd4a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">算法如何工作:</h2><p id="e6cb" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">首先我们选择两个参数，一个正数ε和一个自然数minPoints。然后，我们从在数据集中选取任意一点开始。如果在距离该点ε的距离内有多于minPoints个点，(包括原始点本身)，我们认为它们都是“簇”的一部分。然后，我们通过检查所有新点并查看它们是否在ε的距离内也具有多于minPoints的点来扩展该聚类，如果是，则递归地增长该聚类。</p><p id="6b5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终，我们用完了添加到集群中的点。然后我们选择一个新的任意点，重复这个过程。现在，完全有可能我们选择的点在其epsilon球中的点数少于minPoints，并且也不是任何其他簇的一部分。如果是这种情况，它被认为是不属于任何聚类的“噪声点”。</p><p id="2f62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(有一个小小的复杂情况值得指出:假设minPoints=4，你有一个点，它的epsilon球中有三个点，包括它本身。假设其他两个点属于两个不同的簇，并且每个点在它们的ε球中有4个点。然后，这两个密集点将“争夺”原始点，并且它最终会出现在两个集群中的哪一个是任意的。要理解我的意思，请尝试minPoints=4，epsilon=1.98的“示例A”。由于DBSCAN以任意顺序考虑这些点，因此在不同的运行中，中间点可能会出现在左簇或右簇中。这种点被称为“边界点”)。</p><h2 id="bb66" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">DBSCAN什么时候效果好？</h2><ul class=""><li id="55d1" class="kv kw hi is b it kx ix ky jb kz jf la jj lb jn lc ld le lf bi translated">它可以很好地处理噪音。</li><li id="b829" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">DB-SCAN可以处理不同形状和大小的集群。</li></ul><h2 id="dd24" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">当不是！</h2><ul class=""><li id="8f34" class="kv kw hi is b it kx ix ky jb kz jf la jj lb jn lc ld le lf bi translated">DBSCAN虽然功能强大，对某些应用程序来说也不错。没有永远有效的单一算法。每个职业都有不好的一面。</li><li id="ec3b" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">如果数据集具有多个密度或变化的密度，DBSCAN往往会失败。在这种情况下，它不太管用。</li><li id="0348" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">它对超参数极其敏感。超参数的微小变化会导致结果的剧烈变化。</li><li id="92c4" class="kv kw hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">正如我们所知，像密度这样的概念在高维数据中可能不太适用。我们应该避免将它用于文本数据。</li></ul><h2 id="f215" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">时间和空间复杂性:</h2><p id="0d03" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated"><strong class="is hj">时间复杂度</strong> : O(n logn)</p><p id="a247" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">空间复杂度</strong> : O(n)</p><h1 id="ffd2" class="lo kb hi bd kc lp lq lr kg ls lt lu kk lv lw lx kn ly lz ma kq mb mc md kt me bi translated">实施:</h1><p id="c995" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">我们可以使用互联网上的一个库/包。另外，<a class="ae mf" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" rel="noopener ugc nofollow" target="_blank"> Sklearn </a>有一个DBSCAN实现包。</p><h2 id="185f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">代码示例:</h2><h2 id="1f36" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">带Scikit-Learn的DBSCAN算法示例:</h2><p id="c811" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">为了查看DBSCAN算法的一个实际例子，我使用了加拿大2014年的天气数据来对气象站进行聚类。首先让我们加载数据—</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/c87851645a1a0104e718012aff7a3bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ee2qjAg9Vl-mi8dU.png"/></div></div></figure><p id="3712" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据帧由1341行和25列组成，为了理解列名代表什么，让我们看看下面最重要的特性</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/4c87fd8fe7bc67201d5f5dcc146abe28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OBYeAorlqOjo6e5t.png"/></div></div></figure><p id="c6cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为，我想使用不同的温度作为第一次尝试聚类气象站的几个主要特征，首先，让我们删除“平均温度(Tm)”、“最低温度(Tn)”和“最高温度(Tx)”列中包含NaN值的行。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/0e7a0c9ed7ff42cbfa131f84515317e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*VQPjh4LRXafPsiSS"/></div></figure><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/3f3e102b10cccd298bbb972e00cc6ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MGv_RZY_IS-sMQqG.png"/></div></div></figure><p id="c244" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在删除上述列中包含NaN值的行后，我们剩下1255个样本。尽管这几乎是7%的数据损失，但是考虑到我们仍然有超过1000个样本，让我们继续进行聚类。</p><p id="eac2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们要进行空间聚类，并在地图投影中查看聚类，以及不同的温度(“Tm”、“Tn”、“Tx”)、“Lat”、“long”也应作为特征。在这里，我使用了<a class="ae mf" href="https://matplotlib.org/basemap/users/intro.html" rel="noopener ugc nofollow" target="_blank">底图工具包</a>，一个用于绘制2D数据的库，以便用Python绘制地图。正如底图文档中提到的<em class="jo">“底图本身不进行任何绘图，但提供了将坐标转换为25种不同地图投影之一的工具”。</em>底图的一个重要属性是-使用参数纬度/经度(以度为单位，如我们的数据框中所示)调用底图类实例，以获取x/y地图投影坐标。</p><p id="560a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用底图绘制气象站，以便熟悉它。从导入必要的库开始</p><pre class="jq jr js jt fd mk ml mm mn aw mo bi"><span id="703f" class="ka kb hi ml b fi mp mq l mr ms">from mpl_toolkits.basemap import Basemap<br/>import matplotlib<br/>from PIL import Image<br/>import matplotlib.pyplot as plt<br/>from pylab import rcParams<br/>%matplotlib inline<br/>rcParams['figure.figsize'] = (14,10)</span></pre><p id="73c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在准备调用底图类—</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/27e7d782ba0ddd965edd0c02bd80b633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i4jo6wvnOB8G0oZw.png"/></div></div></figure><p id="a1b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我简单解释一下代码块。我开始使用<a class="ae mf" href="https://en.wikipedia.org/wiki/Mercator_projection" rel="noopener ugc nofollow" target="_blank">墨卡托投影</a> ( <em class="jo">投影=‘merc’</em>)、低分辨率(<em class="jo">分辨率=‘l’</em>)调用一个底图类实例，地图域的边界由4个参数给出<em class="jo"> llcrnrlon、llcrnrlat、urcrnrlon、urcrnrlat、</em>，其中<em class="jo"> llcrnrlon </em>表示所选地图域左下角的经度，依此类推。<em class="jo">绘制海岸线，绘制国家</em>顾名思义，<em class="jo">绘制遮罩</em>绘制高分辨率陆海遮罩图像，将陆地和海洋颜色指定为橙色和天蓝色。使用下面的命令将纬度和经度转换为x/y地图投影坐标—</p><pre class="jq jr js jt fd mk ml mm mn aw mo bi"><span id="facf" class="ka kb hi ml b fi mp mq l mr ms">xs, ys = my_map(np.asarray(weather_df.Long), np.asarray(weather_df.Lat))</span></pre><p id="174c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些地图投影坐标将用作要素，以便在空间上将数据点与温度一起聚类。首先让我们看看下面的气象站—</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/6101d137322203c5af94aa4dcce225d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z7DNvjsDJk-zEOI8.png"/></div></div></figure><p id="02f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用底图绘制的加拿大气象站。</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h2 id="e36b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">3.1 —聚类天气数据(温度和坐标作为特征)</h2><p id="f9e4" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">对于聚类数据，我遵循了<a class="ae mf" href="https://scikit-learn.org/stable/auto_examples/cluster/plot_dbscan.html#sphx-glr-auto-examples-cluster-plot-dbscan-py" rel="noopener ugc nofollow" target="_blank">sci kit-DBS can</a>的学习演示中所示的步骤。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/c84248b530da7e73658fdfd91f18c5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ACICa_J3S0LeDr_X.png"/></div></div></figure><p id="83f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择温度(' Tm '，' Tx '，' Tn ')和坐标的x/y映射投影(' xm '，' ym ')作为特征，并将ϵ和<em class="jo"> MinPts </em>分别设置为0.3和10，给出8个唯一的聚类(噪声标记为-1)。您可以随意更改这些参数来测试集群会受到多大的影响。</p><p id="3115" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用底图来可视化这些集群—</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/e9d92fa8085587c9d1970df8f5b13f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DTJo2isQudWlJnkv.png"/></div></div></figure><p id="7cf6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">加拿大基于天气数据中几个选定特征的8个独特聚类。ϵ和MinPts分别设置为0.3和10。</p><p id="7a0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我将降水(“p”)包含在特征中，并重复相同的聚类步骤，将ϵ和<em class="jo"> MinPts </em>设置为0.5和10。我们看到了与以前的聚类的一些不同，因此它给了我们一个思路，当我们缺乏领域知识时，即使使用DBSCAN也可以对无监督数据进行聚类。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/52e50e7c24aa960b6702a584158d5f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FukY_TXdtY5bkEbW.png"/></div></div></figure><p id="9421" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据天气数据中的选定特征(与以前的情况相比，现在包括降水),加拿大有4个独特的聚类。ϵ和MinPts分别设置为0.5和10。</p><p id="f894" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以尝试重复这个过程，包括一些更多的功能，或者，改变聚类参数，以获得更好的整体知识。</p><h1 id="7ed0" class="lo kb hi bd kc lp lq lr kg ls lt lu kk lv lw lx kn ly lz ma kq mb mc md kt me bi translated"><strong class="ak">结论:</strong></h1><p id="e504" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">最后，我们介绍了DBSCAN算法的一些基本概念，并测试了该算法对加拿大气象站的聚类。详细代码和所有图片将在我的GitHub中提供。可以与K-均值聚类进行直接比较，以便更好地理解这些算法之间的差异。希望这将有助于您开始使用一种最常用的聚类算法来处理无监督问题。</p><p id="6ddf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献:</strong></p><p id="b49d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">维基百科:【https://en.wikipedia.org/wiki/DBSCAN T2】</p><p id="a3d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">sk learn:<a class="ae mf" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . cluster . DBS can . html</a></p><p id="9dcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于密度的聚类方法；高，j。布法罗大学副教授。<a class="ae mf" href="https://cse.buffalo.edu/~jing/cse601/fa12/materials/clustering_density.pdf" rel="noopener ugc nofollow" target="_blank">演示链接。</a></p></div></div>    
</body>
</html>