<html>
<head>
<title>Exploring your FitBit sleep data with Python, Pandas, and Seaborn in Jupyter Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jupyter笔记本中使用Python、Pandas和Seaborn探索您的FitBit睡眠数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploring-your-fitbit-sleep-data-with-python-pandas-and-seaborn-in-jupyter-notebook-a997f17c3a42?source=collection_archive---------4-----------------------#2019-10-13">https://medium.com/analytics-vidhya/exploring-your-fitbit-sleep-data-with-python-pandas-and-seaborn-in-jupyter-notebook-a997f17c3a42?source=collection_archive---------4-----------------------#2019-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2cacd215c75d1c09ab15bae8d9af0613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a6kbenpOCKNpejDZ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@andresurena?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德烈斯·乌雷纳</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7398" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">在本文中，我将介绍…</h1><ul class=""><li id="0316" class="jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">如何以及在哪里从FitBit下载您的数据</li><li id="3c76" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">探索和识别导出的数据</li><li id="2691" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">将您的数据加载到熊猫数据框架中</li><li id="fa13" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">Seaborn的一些基本绘图</li></ul><blockquote class="kq kr ks"><p id="bba1" class="kt ku kv jv b jw kw kx ky jy kz la lb lc ld le lf lg lh li lj lk ll lm ln kg hb bi translated">TL；DR；如果你只是想得到好东西，跳到我在GitHub上发布的Jupyter笔记本。</p></blockquote><h1 id="d7c8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="ffa8" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">自从几年前我有了FitBit Flex，我就成了健身追踪的忠实粉丝。在几周或几个月的时间里，你通过查看关于自己的数据而获得的动力是无价的。当你试图找出什么样的惯例或习惯最适合你时，这很有帮助。另外，如果你像我一样是个数据怪胎，看着就很有趣！</p><p id="80b0" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">但是，当你有合适的工具和一点好奇心时，你在FitBit应用程序或仪表盘中看到的只是这些数据的皮毛。</p><h2 id="9188" class="lr iw hi bd ix ls lt lu jb lv lw lx jf ka ly lz jj kc ma mb jn ke mc md jr me bi translated">先决条件</h2><p id="3fd9" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">你需要在你的机器上安装Anaconda <a class="ae iu" href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/macos.html" rel="noopener ugc nofollow" target="_blank">来启动Jupyter笔记本。关于Anaconda的伟大之处在于，只要您有了那个设置，您就可以开始工作了。</a></p><p id="c950" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">我也喜欢从命令行运行，所以指令就是这么写的。你不需要成为一个黑客级别的命令行向导，但是你需要知道如何到达你的终端，以及如何运行我提供的命令。</p><blockquote class="kq kr ks"><p id="5132" class="kt ku kv jv b jw kw kx ky jy kz la lb lc ld le lf lg lh li lj lk ll lm ln kg hb bi translated">注意:如果你在windows机器上，用<code class="du mf mg mh mi b"><em class="hi">dir</em></code>替换任何<code class="du mf mg mh mi b"><em class="hi">ls</em></code>命令。这只是将“ls — list”命令与“dir — directory”命令交换，这两个命令都列出了当前目录的内容。</p></blockquote><h1 id="f299" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">下载您的FitBit数据</h1><p id="0aa4" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">FitBit在这方面有一个非常直接的帮助文档，所以从点击下面的链接开始，按照步骤请求完整导出您的所有数据。</p><div class="mj mk ez fb ml mm"><a href="https://help.fitbit.com/articles/en_US/Help_article/1133" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">如何导出我的Fitbit帐户数据？</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">文章正文使用fitbit.com仪表板导出您的GPS数据、社区数据或您的帐户数据档案…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">help.fitbit.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na io mm"/></div></div></a></div><p id="a616" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">从我确认我的请求开始，大约25分钟后我的数据就可以下载了。作为参考，我有2015年的数据。我预计导出时间会稍微多一点或少一点，这取决于您的数据回溯到多远。</p><h1 id="6295" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">探索和识别导出的数据</h1><h2 id="b43a" class="lr iw hi bd ix ls lt lu jb lv lw lx jf ka ly lz jj kc ma mb jn ke mc md jr me bi translated">设置您的环境</h2><p id="8e6d" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">首先为您的探索性数据分析创建一个文件夹。从您想要存储此项目的任何文件夹中，运行以下命令:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="d3d6" class="lr iw hi mi b fi nj nk l nl nm">mkdir fitbit-eda<br/>cd fitbit-eda</span></pre><p id="412a" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">接下来，您将需要一个虚拟环境，这样它就不会干扰您的计算机上可能存在的任何其他出色的项目。要运行，请执行以下操作:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="1353" class="lr iw hi mi b fi nj nk l nl nm">conda create -n env python=3.7 anaconda</span></pre><p id="1bd6" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这告诉Anaconda用Python 3.7建立一个名为<code class="du mf mg mh mi b">env</code>的新Python虚拟环境。如果不指定版本，Anaconda将选择您的默认Python安装。由于这很可能是Python 2，我建议显式地设置要使用的Python版本。</p><p id="0aed" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">现在，使用以下命令激活环境:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="043d" class="lr iw hi mi b fi nj nk l nl nm">conda activate env</span></pre><h2 id="9737" class="lr iw hi bd ix ls lt lu jb lv lw lx jf ka ly lz jj kc ma mb jn ke mc md jr me bi translated">下载并解压缩</h2><p id="ed0e" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">继续下载并将下载的<code class="du mf mg mh mi b">MyFitbitdata.zip</code>文件移动到新创建的文件夹中。</p><p id="d94c" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">接下来，解压缩下载的文件。您可以通过您的文件资源管理器，或者在命令行中使用:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="49c3" class="lr iw hi mi b fi nj nk l nl nm">unzip MyFitbitData.zip</span></pre><p id="2ff8" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这将创建一个以你的名字命名的文件夹(例如在我的例子中是LoganHennessy)。</p><p id="492f" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">从这里开始，启动Jupyter Notebook，充分发挥Python、Pandas、Matplotlib/Seaborn等工具的威力。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="f200" class="lr iw hi mi b fi nj nk l nl nm">jupyter notebook</span></pre><p id="8d12" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">默认情况下，Jupyter将在localhost:8888启动host a notebook。单击终端中的链接，您应该会看到类似这样的内容。</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/0b3b31d76f0efe435829b1f93d0054b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GM1zB4kGRWdqxVHMM73QEg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Jupyter笔记本</figcaption></figure><p id="760f" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">酷毙了。现在让我们稍微探索一下。</p><p id="793d" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">看看那个解压缩的文件夹，上面有你的名字。</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/12083e98651375ee0b85475923c901e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfCVeLJvh84JydN4F0sk4Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据档案</figcaption></figure><p id="ec89" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated"><code class="du mf mg mh mi b">user-profile</code>有一些关于我的数据，这不是很有趣(我向你保证)。FitBit刚刚增加了一个睡眠评分，这很有趣，但我对原始数据更感兴趣。<code class="du mf mg mh mi b">user-site-export</code>是我们想要的。这是我有史以来所有的原始数据。</p><p id="f332" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">导航到<code class="du mf mg mh mi b">user-site-export</code>。根据你拥有FitBit的时间长短，你可能会看到一个巨大的文件列表。我的档案有2139个文件。</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/7b47a371dc47db98bc5e2383784eab0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7wZ_WpxUrx6pYeiIAV5Wg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">用户网站导出文件</figcaption></figure><p id="2a33" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">虽然一开始让人不知所措，但看起来FitBit对这些文件有一个很好的、一致的命名约定。似乎有几种不同类型的数据文件有它们自己独特的名字，并且每个文件都有日期戳。格式如下所示:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="bce7" class="lr iw hi mi b fi nj nk l nl nm">{underscored_type}-{hyphenated-date}</span></pre><p id="d203" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这很好，因为有了这样一种可预测的格式，我们可以使用Python来识别所有独特的文件类型。</p><p id="b89b" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">导航回到您启动Jupyter的根目录。</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/d03813463d2dc048005f6d58245fb4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BZ4lRDGcgWU0qGQ7Xdcxg.png"/></div></div></figure><p id="adb6" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">现在，在右上角的New -&gt; Notebook下，点击“Python 3”。</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/f1d17ca0541845b4848af8afc86b0ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvW2aq0ykJTGdQ1YVxnL6Q.png"/></div></div></figure><p id="9061" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这将打开一个Python 3 Jupyter笔记本。在第一个单元格中，复制并粘贴以下代码片段，确保用您的真实姓名替换<code class="du mf mg mh mi b">{Firstname}{Lastname}</code>。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="b57a" class="lr iw hi mi b fi nj nk l nl nm">import os</span><span id="fa79" class="lr iw hi mi b fi ns nk l nl nm">filenames = os.listdir("LoganHennessy/user-site-export")</span><span id="e6ee" class="lr iw hi mi b fi ns nk l nl nm">print(f"Parsing {len(filenames)} files for unique types.")<br/>unique_filenames = set()</span><span id="0d32" class="lr iw hi mi b fi ns nk l nl nm">for f in filenames:<br/>    unique_filenames.add(f.split("-")[0])</span><span id="9d6f" class="lr iw hi mi b fi ns nk l nl nm">print(f"Found {len(unique_filenames)} unique types.")<br/>for name in sorted(unique_filenames):<br/>    print(name)</span></pre><p id="8600" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">花一分钟回顾并理解这段代码。这很简单。它首先收集您的<code class="du mf mg mh mi b">user-site-export</code>目录中的文件列表，然后遍历它们，只分离出文件名的第一部分，并将其添加到Python <code class="du mf mg mh mi b">set</code>中。集合在这里很有用，因为它只允许不存在的新对象。因此，在遍历所有文件名后，我们将拥有一个不同数据类型的唯一列表。</p><p id="43b7" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">从这里你可以按下笔记本顶部的“运行”按钮，或者按下Shift+Enter运行(我的首选方式)。</p><p id="8d3c" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这将打印出以下列表。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="3da8" class="lr iw hi mi b fi nj nk l nl nm">Parsing 2139 files for unique types.<br/>Found 21 unique types.<br/>altitude<br/>badge.json<br/>calories<br/>demographic_vo2_max<br/>distance<br/>exercise<br/>food_logs<br/>heart_rate<br/>height<br/>lightly_active_minutes<br/>moderately_active_minutes<br/>resting_heart_rate<br/>run_vo2_max<br/>sedentary_minutes<br/>sleep<br/>steps<br/>swim_lengths_data<br/>time_in_heart_rate_zones<br/>very_active_minutes<br/>water_logs<br/>weight</span></pre><p id="4540" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">我们的脚本找到了21种不同类型的数据。我们可以看到其中一个叫做<code class="du mf mg mh mi b">sleep</code>。看起来那就是我们想要的。</p><h1 id="9789" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">将您的数据加载到熊猫数据框架中</h1><p id="4344" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">首先，将睡眠数据复制到一个<code class="du mf mg mh mi b">data</code>文件夹中。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="be96" class="lr iw hi mi b fi nj nk l nl nm">!mkdir data<br/>!cp LoganHennessy/user-site-export/sleep* data/</span></pre><p id="4037" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">在朱庇特的笔记本中，一行开头的<code class="du mf mg mh mi b">!</code>告诉朱庇特呼叫外壳。</p><p id="3f9a" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">现在列出<code class="du mf mg mh mi b">data</code>目录的内容。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="78c6" class="lr iw hi mi b fi nj nk l nl nm">!ls data</span></pre><p id="abf0" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">你会看到一个列表，里面只有你的睡眠数据文件。这就是我们想要的。</p><p id="72be" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">Panda有一个内置的方法<code class="du mf mg mh mi b">pd.read_json</code>，它将接受一个文件路径作为一个字符串，并将它在那个位置找到的JSON文件读入一个数据帧。然而，我们有很多很多的睡眠文件，我们需要它们都在同一个数据帧中。</p><p id="3005" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">要将所有睡眠文件加载到同一个数据帧中，通过循环遍历目录中的每个文件，创建一个数据帧列表，然后使用T8将列表中的数据帧连接成一个数据帧。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="3199" class="lr iw hi mi b fi nj nk l nl nm">import pandas as pd</span><span id="a2ff" class="lr iw hi mi b fi ns nk l nl nm">dfs = []<br/>for file in os.listdir("data"):<br/>    dfs.append(pd.read_json(f"data/{file}"))<br/>df = pd.concat(dfs)</span></pre><p id="12e7" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">查看数据框的前5行。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="bfe1" class="lr iw hi mi b fi nj nk l nl nm">df.head()</span></pre><p id="75a7" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">不是<code class="du mf mg mh mi b">levels</code>，看起来那个列没有正确解析，因为那个列本身包含了<em class="kv">嵌套的</em> JSON。这种形式的嵌套JSON很难处理，也不容易绘制或分析。</p><p id="2502" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">那我们该怎么办？</p><p id="b31a" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">我们需要做的是通过将单个字段作为新列显示在数据帧中来“扁平化”。</p><p id="8511" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">首先，看一下这个字段的示例单元格。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="1c50" class="lr iw hi mi b fi nj nk l nl nm">df.iloc[0].levels['summary']</span></pre><p id="308a" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这会打印出类似。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="8df2" class="lr iw hi mi b fi nj nk l nl nm">{'deep': {'count': 2, 'minutes': 50, 'thirtyDayAvgMinutes': 59},<br/> 'wake': {'count': 6, 'minutes': 51, 'thirtyDayAvgMinutes': 57},<br/> 'light': {'count': 11, 'minutes': 210, 'thirtyDayAvgMinutes': 213},<br/> 'rem': {'count': 4, 'minutes': 83, 'thirtyDayAvgMinutes': 101}}</span></pre><p id="87ae" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">好的。所以看起来像是<code class="du mf mg mh mi b">levels</code>数据本身包含了4个嵌套的JSON对象，每个对象都有关于睡眠的特定阶段的数据。幸运的是，这些对象都是一致的，都有一个<code class="du mf mg mh mi b">count</code>、<code class="du mf mg mh mi b">minutes</code>和<code class="du mf mg mh mi b">thirtyDayAvgMinutes</code>字段。</p><p id="a084" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">对于要出图的东西，我最感兴趣的是<code class="du mf mg mh mi b">minutes</code>领域。</p><p id="37e9" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">为了从睡眠的每个阶段提取这个字段，我们需要使用<code class="du mf mg mh mi b">df.{columnName}.apply()</code>方法。这个方法本质上相当于一个<code class="du mf mg mh mi b">map</code>函数，它<em class="kv">将一个函数</em>映射到数据帧中特定列的每一行。</p><p id="0225" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">给定<code class="du mf mg mh mi b">levels</code>列的结构，为了提取必要的<code class="du mf mg mh mi b">minutes</code>字段，我们将需要类似这样的东西。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="2096" class="lr iw hi mi b fi nj nk l nl nm">def get_minutes(levels, sleep_phase):<br/>    if not levels.get('summary'):<br/>        return None<br/>    if not levels.get('summary').get(sleep_phase):<br/>        return None<br/>    if not levels.get('summary').get(sleep_phase).get('minutes'):<br/>        return None<br/>    return levels['summary'][sleep_phase]['minutes']</span></pre><p id="431f" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">由于我有2015年的数据，而且我过去的跟踪器不够健壮，所以不是每一行都一定有有效数据，所以我需要检查以确保每个字段在尝试访问之前都包含数据。多级<code class="du mf mg mh mi b">if not levels.get(...</code>执行此检查。</p><p id="9cf0" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">将此函数应用于四个睡眠阶段中的每一个。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="a5d9" class="lr iw hi mi b fi nj nk l nl nm">df['deepSleep'] = df.levels.apply(get_minutes, args=('deep',))<br/>df['wakeMins'] = df.levels.apply(get_minutes, args=('wake',))<br/>df['lightSleep'] = df.levels.apply(get_minutes, args=('light',))<br/>df['remSleep'] = df.levels.apply(get_minutes, args=('rem',))</span></pre><p id="f91a" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">运行另一个<code class="du mf mg mh mi b">df.head()</code>来查看dataframe是如何形成的，您应该会看到四个新列，每个列包含特定行的特定睡眠阶段的分钟数(您可能需要滚动到最右侧才能看到它们)。</p><h1 id="c24f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Seaborn的一些基本绘图</h1><p id="b787" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">为了结束本教程，我们将使用Seaborn生成一个简单的图表。</p><p id="8b0c" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">到目前为止，我们有一个数据帧，其中一行代表每天，一列代表睡眠的每个阶段所花的分钟数，所有默认列都来自FitBit的每个数据点。</p><p id="92ba" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">为了更容易绘制，我们将对我们的数据帧进行一些处理，使其成为符合Seaborn和Matplotlib的格式。我们的步骤将是:</p><ol class=""><li id="af67" class="jt ju hi jv b jw kw jy kz ka nt kc nu ke nv kg nw ki kj kk bi translated">在我们的数据框架上设置一个基于时间的索引</li><li id="5b06" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg nw ki kj kk bi translated">删除我们不需要/不想要的列</li><li id="6a8a" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg nw ki kj kk bi translated">绘制剩余的列</li></ol><h2 id="f35d" class="lr iw hi bd ix ls lt lu jb lv lw lx jf ka ly lz jj kc ma mb jn ke mc md jr me bi translated">在熊猫数据帧上设置基于时间的索引</h2><p id="178a" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">运行以下命令:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="344d" class="lr iw hi mi b fi nj nk l nl nm">df.dateOfSleep = pd.to_datetime(df.dateOfSleep)<br/>df.set_index("dateOfSleep", drop=True, inplace=True)<br/>df.sort_index(inplace=True)</span></pre><p id="46c9" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">在这3行中，实际上有很多东西需要解开。</p><p id="9177" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">首先，我们使用<code class="du mf mg mh mi b">pd.to_datetime()</code>将<code class="du mf mg mh mi b">dateOfSleep</code>列转换成日期时间。这是必要的，因为在此之前，Pandas只是将<code class="du mf mg mh mi b">dateOfSleep</code>列作为一般的<code class="du mf mg mh mi b">object</code>来处理，而Seaborn不知道将该列作为日期时间来处理。</p><p id="02a9" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">其次，我们将dataframe的索引设置为我们刚刚转换的列，<code class="du mf mg mh mi b">dateOfSleep</code>。两个额外的参数告诉Pandas(a)删除原来的<code class="du mf mg mh mi b">dateOfSleep</code>(或者Pandas会将该列复制到索引中)，以及(b)完成这个操作<code class="du mf mg mh mi b">inplace</code>，这样我们就不必返回并保存一个新的dataframe。</p><p id="2499" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">最后，我们将在新创建的索引上对该数据帧进行排序，以便按时间顺序排序。默认情况下，这是按照升序排序，这就是我们想要的。</p><p id="b519" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">使用<code class="du mf mg mh mi b">df.info()</code>查看我们的数据框的列。这将打印出如下内容:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="2e85" class="lr iw hi mi b fi nj nk l nl nm">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>DatetimeIndex: 921 entries, 2015-07-18 to 2019-09-28<br/>Data columns (total 18 columns):<br/>duration               921 non-null int64<br/>efficiency             921 non-null int64<br/>endTime                921 non-null object<br/>infoCode               921 non-null int64<br/>levels                 921 non-null object<br/>logId                  921 non-null int64<br/>mainSleep              921 non-null bool<br/>minutesAfterWakeup     921 non-null int64<br/>minutesAsleep          921 non-null int64<br/>minutesAwake           921 non-null int64<br/>minutesToFallAsleep    921 non-null int64<br/>startTime              921 non-null object<br/>timeInBed              921 non-null int64<br/>type                   921 non-null object<br/>deepSleep              766 non-null float64<br/>wakeMins               766 non-null float64<br/>lightSleep             766 non-null float64<br/>remSleep               766 non-null float64<br/>dtypes: bool(1), float64(4), int64(9), object(4)<br/>memory usage: 130.4+ KB</span></pre><p id="dd0c" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">注意顶部的<code class="du mf mg mh mi b">DatetimeIndex</code>标注，它甚至包括我们的日期范围。相当酷！</p><p id="62ce" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">现在，这个数据框架中有很多我们不一定要画出来的东西。我最感兴趣的是我们之前创建的4个列，加上<code class="du mf mg mh mi b">minutesAsleep</code>和<code class="du mf mg mh mi b">timeInBed</code>。</p><p id="173e" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">为了使绘图更容易，让我们删除所有不需要的列。运行:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="e6bd" class="lr iw hi mi b fi nj nk l nl nm">df.drop(columns=([<br/>    "logId", <br/>    "startTime", <br/>    "endTime", <br/>    "duration", <br/>    "minutesToFallAsleep", <br/>    "minutesAwake", <br/>    "minutesAfterWakeup", <br/>    "efficiency",<br/>    "type",<br/>    "infoCode",<br/>    "levels",<br/>    "mainSleep"<br/>]), inplace=True)</span></pre><p id="f416" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">删除所有未使用的列。</p><p id="0d5c" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">最后，但并非最不重要的是，我的特定数据集有一些空值(或N/A ),因为我记录的夜晚并没有记录所有的睡眠阶段。我<em class="kv">只</em>想绘制有全套数据的夜晚，所以运行:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="4df8" class="lr iw hi mi b fi nj nk l nl nm">df.dropna(inplace=True)</span></pre><blockquote class="kq kr ks"><p id="65b1" class="kt ku kv jv b jw kw kx ky jy kz la lb lc ld le lf lg lh li lj lk ll lm ln kg hb bi translated">注意:您可能不总是希望删除空数据。处理这些行的另一种方法可能是用0填充空值。参见熊猫的<code class="du mf mg mh mi b">fillna</code>方法来获得更多关于如何做的信息。</p></blockquote><p id="b6b0" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">有了这些，我们就可以开始绘图了。</p><p id="e8c3" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">使用以下内容进行绘图。</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="ba1d" class="lr iw hi mi b fi nj nk l nl nm">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from pandas.plotting import register_matplotlib_converters</span><span id="045f" class="lr iw hi mi b fi ns nk l nl nm">%matplotlib inline</span><span id="ba4c" class="lr iw hi mi b fi ns nk l nl nm">register_matplotlib_converters()<br/>sns.set()</span><span id="1548" class="lr iw hi mi b fi ns nk l nl nm">fig, ax = plt.subplots(figsize=(18,10))<br/>sns.lineplot(ax=ax, data=df)</span></pre><p id="ff74" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">在使用Pandas、Jupyter Notebook和Matplotlib/Seaborn时，大多数都是标准的样板文件。例如，<code class="du mf mg mh mi b">%matplotlib inline</code>告诉Jupyter Notebook在生成Matplotlib图后显示它们。</p><p id="456a" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">有一句台词是我们特有的。因为我们传入了一个dataframe，该data frame将一个列转换为Panda表示的日期时间，所以我们只使用<code class="du mf mg mh mi b">register_matplotlib_converters()</code>显式注册这个数据类型。</p><p id="128d" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">运行上面的所有内容应该会返回如下内容:</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nx"><img src="../Images/dab83c68baf2355e0e60410b2670f59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBkinOypPNQgNRWfWq_KDw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我的睡眠数据——一直如此</figcaption></figure><p id="f9d7" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">作为最后一个练习，请注意上面的图表有点拥挤。试图将两年多的数据塞进一张图表有点过了。为了使其更具可读性，并缩小特定的日期范围，请使用以下代码:</p><pre class="nb nc nd ne fd nf mi ng nh aw ni bi"><span id="eb0e" class="lr iw hi mi b fi nj nk l nl nm">fig, ax = plt.subplots(figsize=(18,10))<br/>sns.lineplot(ax=ax, data=df[df.index &gt;= '2019-07-01'])</span></pre><p id="2845" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">由于我们的索引是我们的日期范围，我们可以很容易地将数据过滤到特定的日期范围。将我的数据限制到大约3个月，我得到了一个可读性更强的图表，如下所示。</p><figure class="nb nc nd ne fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/63d011a75e406ab00f5631bc54c47b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXdETV7TqE_0hIEBtcy5Rw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我从7月1日开始的睡眠数据</figcaption></figure><h1 id="c6ff" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="6830" class="pw-post-body-paragraph kt ku hi jv b jw jx kx ky jy jz la lb ka lo le lf kc lp li lj ke lq lm ln kg hb bi translated">我们已经介绍了如何克服以下方面的一些常见挑战:</p><ul class=""><li id="3b1a" class="jt ju hi jv b jw kw jy kz ka nt kc nu ke nv kg kh ki kj kk bi translated">将多个JSON文件数据导入单个数据帧</li><li id="afd1" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">通过将嵌套的JSON数据解包到专用列中来格式化数据帧</li><li id="96ea" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">使用Seaborn绘制数据框架</li></ul><p id="38eb" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">这仅仅触及了您可以利用FitBit数据归档中的可用数据做些什么的皮毛。请继续关注我的探索和分享。我的数据探索路线图包括:</p><ul class=""><li id="b164" class="jt ju hi jv b jw kw jy kz ka nt kc nu ke nv kg kh ki kj kk bi translated">检测时间序列数据的过去趋势和预测未来趋势</li><li id="6b8c" class="jt ju hi jv b jw kl jy km ka kn kc ko ke kp kg kh ki kj kk bi translated">分析数据集中方差的统计显著性</li></ul><p id="fb11" class="pw-post-body-paragraph kt ku hi jv b jw kw kx ky jy kz la lb ka ld le lf kc lh li lj ke ll lm ln kg hb bi translated">感谢阅读和快乐的黑客！:)</p></div></div>    
</body>
</html>