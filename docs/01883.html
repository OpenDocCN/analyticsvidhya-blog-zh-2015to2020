<html>
<head>
<title>Clustering as Matrix Factorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类作为矩阵分解</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clustering-as-matrix-factorization-65b871cf2ab9?source=collection_archive---------10-----------------------#2019-11-19">https://medium.com/analytics-vidhya/clustering-as-matrix-factorization-65b871cf2ab9?source=collection_archive---------10-----------------------#2019-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a347d22f49c6e3f5bd0f43d64a723af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rN5AIc0CYq1iVra9o4I8g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源— <a class="ae iu" href="https://techcrunch.com/2019/03/18/how-to-build-the-matrix/" rel="noopener ugc nofollow" target="_blank">科技危机</a></figcaption></figure><p id="e100" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇博客文章试图简要介绍如何在K-means聚类中使用矩阵分解来聚类相似的数据点。</p><p id="8322" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">K均值聚类中的主要目标函数由下式给出:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/e2ef18e02c7cb564ba4b699f2171319f.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/1*bureCsHa0V0Yr8yJY1UX6A.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1</figcaption></figure><p id="abf0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中K是聚类的数量，Si是属于聚类I的所有点的集合，x是数据点，Ci是第I个聚类。(x-Ci)指点x到质心Ci的距离。</p><p id="4b1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们必须记住，只有当且仅当x属于簇Si时，才计算(x-Ci)。如果数据点x不属于聚类Si，则(x-Ci)的值为0。</p><p id="0a52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们将上述目标函数转换为矩阵分解问题之前，让我们定义一个新的名为Z的k×n维矩阵，其中k是质心/聚类的数量，n是数据点的总数。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/505ac38ee205131c8867b7948c9d9597.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/1*Sr-ofcYa-SZiwWOt7Lplpg.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/d7768b6dc1c55742a10e4dbfacbd884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/1*r84g332s-99jtTaswqjTxQ.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3</figcaption></figure><p id="a020" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是Z的属性:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/4979d10e18270597dde8cc877491a647.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/1*ftZeSrpUxX4uEKisrEV-5Q.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4</figcaption></figure><p id="3839" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们举个例子来理解z的这个性质。如果Z₂₃ = 1，它暗示数据点x₃属于聚类集S₂，并且它的质心是C₂.如果Z₃₂ = 0，这意味着数据点x₂不属于聚类集S₃，因此C₃不是x₂.的质心</p><p id="f136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，基本上矩阵Z告诉你哪些数据点属于哪个聚类，什么是它的质心，什么不是。</p><p id="fd99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们在由图1中的等式表示的目标函数中使用Z的这个属性，我们得到，</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/43c85e240e3d1b7f1c09320f253ae775.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/1*3ggO4KDWor9nplEfEpTQQg.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图5</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/11a75c3e1b6d7b8d7fcc391a8aec5054.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/1*aHpiceDMcOjlZGurXVigww.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图6</figcaption></figure><p id="de0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等式1和等式2给出了相同的结果。用矩阵形式表示等式2，我们得到:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kd"><img src="../Images/02b543f4573dd29bf03869b36b3bf86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/1*urQbgQy1YUdGIwF2tFl5Hg.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图7</figcaption></figure><div class="ju jv jw jx fd ab cb"><figure class="ke ij kf kg kh ki kj paragraph-image"><img src="../Images/dc5a0410958ac3dfe4e1c0d860c738a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/1*TSJQi3UoRE9JiMciaFxT-Q.gif"/></figure><figure class="ke ij kk kg kh ki kj paragraph-image"><img src="../Images/8076ab4cf25a5f193cd888a259fc8679.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/1*ziMVaimKQWbKA63WGMZeXg.gif"/></figure><figure class="ke ij kl kg kh ki kj paragraph-image"><img src="../Images/505ac38ee205131c8867b7948c9d9597.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/1*Sr-ofcYa-SZiwWOt7Lplpg.gif"/><figcaption class="iq ir et er es is it bd b be z dx km di kn ko translated">图8</figcaption></figure></div><p id="e9e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，Z具有稀疏列，即，在其每一列中只有一个值是1，而其余的值是0，因为每个数据点只能有一个质心。</p><p id="3254" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设Cᵢ是c的iᵗʰ行，Zⱼ是z的jᵗʰ列，那么，</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/ae1575e4656074348636f4af6bc98cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/1*RsJXK67Kj_k7QmEr413oHw.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图9</figcaption></figure><p id="a766" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，当我们做C * Z的时候，</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/42182260a84c4d9cded8676a059a1e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*-H9pcfp5CrpUoxyju_JJKQ.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图10</figcaption></figure><p id="1d61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，等式(3)右侧只有一项非零，因为每个数据点只能有一个质心，而其余项为零。</p><p id="ebc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，C * Z有效地只迎合那些属于一个聚类的数据点。</p><p id="b15d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总之，使用未知矩阵C &amp; Z，我们预测已知矩阵x。因此，这是一个矩阵分解问题。在这个过程中，当我们找到C时，我们已经找到了x中每个数据点的质心。因此，这也是一个聚类问题。</p></div></div>    
</body>
</html>