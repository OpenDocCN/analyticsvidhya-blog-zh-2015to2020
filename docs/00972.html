<html>
<head>
<title>Matching Messy Pandas columns with FuzzyWuzzy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用FuzzyWuzzy搭配凌乱的熊猫专栏</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matching-messy-pandas-columns-with-fuzzywuzzy-4adda6c7994f?source=collection_archive---------0-----------------------#2019-09-23">https://medium.com/analytics-vidhya/matching-messy-pandas-columns-with-fuzzywuzzy-4adda6c7994f?source=collection_archive---------0-----------------------#2019-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3e17b8ee7af738abb9f826980d6eec19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8X2MB-PbC7ukprsBegSjg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">rawpixel.com</figcaption></figure><p id="2844" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我将向您展示如何使用Python包<strong class="iw hj"> FuzzyWuzzy </strong>根据<strong class="iw hj">字符串相似度</strong>来<strong class="iw hj">匹配两个熊猫数据帧列</strong>；预期的结果是将A列的每个值与B列中最接近的对应值进行匹配，然后将其放在同一行中。</p><p id="a8c0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为此，我将使用我个人遇到的一个混乱的真实世界案例(个人和公司信息被虚构和随机生成的数据所替代)。</p><p id="67f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在解决我们的小问题之前，下面是这篇文章的内容:</p><ul class=""><li id="7154" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">通常，当您使用不同的数据源时，相同的实体(企业、国家、地址、电话号码、酒店房间类型、音乐专辑、运动队……)可能会有不同的写法或措辞。在这篇文章中，我们将致力于匹配全名和电子邮件。但是，您可以对遇到的任何字符串匹配问题应用相同的技术(简单地说，字符串就是文本)；</li><li id="fee3" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">你可以通过下载<strong class="iw hj"> Jupyter笔记本</strong>和<strong class="iw hj">我的<a class="ae kg" href="https://github.com/kelmouloudi/MediumArticle-FuzzyWuzzy" rel="noopener ugc nofollow" target="_blank"> Github库</a>中的数据</strong>来跟随我。Jupyter笔记本有更多的解释，我无法在本文中包括；</li><li id="3631" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">这是一篇非常适合初学者的文章。在Jupyter的笔记本中，我确保在末尾包含了一个<strong class="iw hj">附录</strong>，在那里我尽可能详细地解释了每个看起来复杂的代码片段。然而，对Python、Jupyter笔记本和Pandas(这是一个用于数据处理和分析的Python包)的基本理解将会对你有很大的帮助。</li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="a438" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">问题是:</h1><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/ae93c5a5f0c1c6080602845cbdd9acc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKRzfTjPVtqXLoPioHvjEA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">rawpixel.com</figcaption></figure><p id="a394" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在一家名为Giant Baby Bibs的公司工作，专门为巨婴制作围兜。GBB有200名员工。一天，我需要列出所有员工及其电子邮件的清单。大惊喜:人力资源部门有一个包含所有员工id和全名的文件，但没有电子邮件，IT部门有一个包含所有电子邮件的CSV文件，但没有员工id或姓名。</p><p id="e33d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">似乎这还不够混乱，IT部门并没有一个明确的既定规则，规定电子邮件应该如何从员工的全名派生出来。例如，对于一个名叫<strong class="iw hj">约翰·多伊</strong>的员工，电子邮件可以是<a class="ae kg" href="mailto:j.doe@giantbabybibs.org" rel="noopener ugc nofollow" target="_blank">j.doe@giantbabybibs.org</a>，或者<a class="ae kg" href="mailto:jdoe@giantbabybibs.org" rel="noopener ugc nofollow" target="_blank">jdoe@giantbabybibs.org</a>，甚至<a class="ae kg" href="mailto:johndoe@giantbabybibs.org" rel="noopener ugc nofollow" target="_blank">johndoe@giantbabybibs.org</a>(特别是对于那些姓氏非常短的员工)。</p><p id="171b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，真正的难题出现在有中间名的员工身上。例如，对于约翰·塞巴斯蒂安·多伊来说，电子邮件可以是jsdoe@giantbabybibs.org、j.sebastian.doe@giantbabybibs.org、T21或j.sebastian@giantbabybibs.org，或者是站长当时认为合适的任何变体。干得好凯文。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="3b73" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">包装:</h1><p id="0f15" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">首先，让我们导入<code class="du lw lx ly lz b">Pandas</code>:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="5cbc" class="me kp hi lz b fi mf mg l mh mi">import pandas as pd</span></pre><p id="84b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你没有安装<code class="du lw lx ly lz b">FuzzyWuzzy</code>，你可以在你的Jupyter笔记本上运行<code class="du lw lx ly lz b">pip install fuzzywuzzy[speedup]</code>或者从PIP或者Anaconda提示符下安装它。如果这样不行，你就把<code class="du lw lx ly lz b">FuzzyWuzzy</code>这样装:<code class="du lw lx ly lz b">pip install fuzzywuzzy</code>然后把<code class="du lw lx ly lz b">python-levenshtein</code>这样装:<code class="du lw lx ly lz b">pip install python-Levenshtein</code>(为了加快匹配过程)。</p><p id="e8e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从<code class="du lw lx ly lz b">FuzzyWuzzy</code>开始，我们将主要需要两个模块:<code class="du lw lx ly lz b">process</code>和<code class="du lw lx ly lz b">fuzz</code>:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="e5b0" class="me kp hi lz b fi mf mg l mh mi">from fuzzywuzzy import process, fuzz</span></pre><p id="91ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们也导入<code class="du lw lx ly lz b">matplotlib</code>来实现一些数据可视化:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="aa7c" class="me kp hi lz b fi mf mg l mh mi">import matplotlib.pyplot as plt</span></pre><p id="bea5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了更好地测量，让我们添加一些CSS来样式化我们的数据帧，以增加轴和数据本身之间的对比(如果您不喜欢这种样式，只需删除单元格，重新启动内核并重新运行所有单元格) :</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="2c62" class="me kp hi lz b fi mf mg l mh mi">%%HTML<br/>&lt;style&gt;.dataframe th, td:first-child{background:#3f577c;font-family:monospace;color:white;border:3px solid white;<br/>text-align:left !important;}#codex{float:right;}&lt;/style&gt;</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="30c9" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">数据:</h1><p id="3569" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">这里我们有两个需要匹配的数据框或表格:</p><ul class=""><li id="e27a" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><code class="du lw lx ly lz b">hr</code>包含员工id和全名，由人力资源部维护；</li><li id="9a49" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><code class="du lw lx ly lz b">it</code>仅包含IT部门提取的电子邮件。</li></ul><p id="d682" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">确保将“data/hr.csv”和“data/it.csv”路径更改为您的数据在机器中的位置(不要忘记从本文的<a class="ae kg" href="https://github.com/kelmouloudi/MediumArticle-FuzzyWuzzy" rel="noopener ugc nofollow" target="_blank"> Github存储库</a>获取数据:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="83f3" class="me kp hi lz b fi mf mg l mh mi">hr = pd.read_csv('data/hr.csv', encoding='unicode_escape')<br/>it = pd.read_csv('data/it.csv', encoding='unicode_escape')</span><span id="145c" class="me kp hi lz b fi mj mg l mh mi">display( hr.head(3) )<br/>display( it.head(3) )</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/31904b729d908180411e57d3f1a2661a.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*5B_Zcb96QlpjhXjy31OPwA.png"/></div></figure><p id="718a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们在<code class="du lw lx ly lz b">hr</code>数据框架中有200名员工，在<code class="du lw lx ly lz b">it</code>数据框架中有200封电子邮件。每个员工对应一封电子邮件，反之亦然。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="dba1" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">“愚蠢但有点效果”的解决方案:</h1><p id="0711" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">在施展<code class="du lw lx ly lz b">FuzzyWuzzy</code>的魔力之前，我想探索一下我在开始时曾尝试过的这个问题的解决方案。这个想法是:</p><ol class=""><li id="189f" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr ml jy jz ka bi translated">自动生成一封电子邮件(姑且称之为<code class="du lw lx ly lz b">gen_email</code>)，使用名字的第一个字母加上姓氏，并用点分隔。因此，对于无名氏，生成的电子邮件将是<a class="ae kg" href="mailto:j.doe@giantbabybibs.org" rel="noopener ugc nofollow" target="_blank">j.doe@giantbabybibs.org</a>。通过研究实际邮件列表，这似乎是主导趋势；</li><li id="c9e4" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr ml jy jz ka bi translated">将<code class="du lw lx ly lz b">gen_email</code>列与实际的<code class="du lw lx ly lz b">email</code>列进行比较，如果生成的邮件存在于实际的邮件列表中，则输出值<strong class="iw hj"> True </strong>，如果不存在，则输出值<strong class="iw hj"> False </strong>。真值和假值将存储在一个名为<code class="du lw lx ly lz b">exists</code>的列中。</li></ol><p id="100a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们在<code class="du lw lx ly lz b">hr</code>数据框架中制作<code class="du lw lx ly lz b">gen_email</code>列:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="47f9" class="me kp hi lz b fi mf mg l mh mi">hr['gen_email'] = hr['full_name'].str[0] + '.' + hr['full_name'].str.split().str[1] + '<a class="ae kg" href="http://twitter.com/giantbabybibs" rel="noopener ugc nofollow" target="_blank">@giantbabybibs</a>.org'<br/>hr['gen_email'] = hr['gen_email'].str.lower()<br/>hr.head(3)</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/a9a730052d0ea615abd52cd4d025ae7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*EUms3XVeDIKVCrQdC9Yn2A.png"/></div></figure><p id="9599" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们检查一下<code class="du lw lx ly lz b">gen_email</code>值是否存在于实际的<code class="du lw lx ly lz b">email</code>列表中。为此，我们将创建一个名为<code class="du lw lx ly lz b">exists</code>的附加列，如果生成的电子邮件是正确的，则接受<strong class="iw hj">真</strong>，否则接受<strong class="iw hj">假</strong>:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="5969" class="me kp hi lz b fi mf mg l mh mi">hr['exists'] = hr.apply(lambda x: x.gen_email in list(it.email), axis=1)<br/>hr.head(3)</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/0629ba1d005d8b0eec059182f483542b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*lUDZQadHbPiXwRHemEM7_w.png"/></div></figure><p id="d350" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用这种方法，我们得到了多少封邮件？</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="be62" class="me kp hi lz b fi mf mg l mh mi">ax = hr.exists.value_counts().sort_values() \<br/>    .plot(kind='barh', <br/>          color=['tomato', 'c'], <br/>          figsize=(12,1), <br/>          width=0.3 )<br/>plt.xlim(0,201), <br/>plt.xticks(fontsize=8), <br/>ax.set_frame_on(False), <br/>plt.grid(color='white', alpha=.4, axis='x') ;</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/696736e5ef8a1abd90548916e272003d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1yRCjWFQrxHNtJvJhuOaw.png"/></div></div></figure><p id="8495" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，在200封邮件中，我们有148封邮件是正确的，52封邮件是错误的(成功率为74%)。还不错！我们可以用<code class="du lw lx ly lz b">if</code>语句更深入地挖掘邮件生成的其他方式(没有点，使用中间名而不是姓，等等)。)，不过现在还是用FuzzyWuzzy吧。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="e068" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">令人厌烦的模糊不清的讲座；</h1><p id="6a23" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">让我们从<code class="du lw lx ly lz b">FuzzyWuzzy</code>的基本介绍开始。这个漂亮的包比较两个字符串A和B，并输出一个比率来估计它们之间的距离。我们在这里谈论的是<strong class="iw hj"> Levenshtein距离</strong>，这是A和B之间的距离，根据我们必须对字符串A进行多少更改才能将其转换为字符串B。这些更改包括删除、添加或替换字符。我们必须做出的改变越少，A和B就越相似，这导致了更高的比率。</p><p id="1de6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你记得的话，我们从<code class="du lw lx ly lz b">FuzzyWuzzy</code>包中导入了<code class="du lw lx ly lz b">fuzz</code>和<code class="du lw lx ly lz b">process</code>。这是我们将在本文中介绍的两个主要模块:</p><blockquote class="mp mq mr"><p id="ecb0" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated"><strong class="iw hj"><em class="hi">fuzz . ratio</em></strong><em class="hi">:比较两个字符串，输出一个比值。例如:</em></p><p id="355d" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">fuzz.ratio("外面阳光明媚！"，“外面真是阳光明媚”)<br/>输出:38</p><p id="368a" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated"><strong class="iw hj"><em class="hi">process . extract</em></strong><em class="hi">:它获取一个字符串A，然后在字符串列表中为其寻找最佳匹配，然后返回这些字符串及其比率(limit参数告诉模块我们想要返回多少个相似的字符串)。例如:</em></p><p id="5f47" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">list_of_strings = ['a '，' ab '，' c '，' cd'] <br/> process.extract( 'aaa '，list_of_strings，limit=2 ) <br/> Output: [('a '，90)，(' ab '，45)]</p></blockquote><p id="8923" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这两个模块可以使用多种方法来计算比率，从基本的Levenshtein比率到更复杂的加权比率。这些方法被称为<strong class="iw hj">计分器</strong>，下面是它们的使用方法:</p><blockquote class="mp mq mr"><p id="5e4e" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">fuzz.ratio(…)</p><p id="dbc4" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">fuzz.partial_ratio(…)</p><p id="5a63" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">绒毛。WRatio(…)等。</p><p id="7d5e" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">process.extract( …，scorer=fuzz.ratio)</p><p id="90ac" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">process.extract( …，scorer=fuzz.partial_ratio)</p><p id="7f85" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">process.extract( …，scorer=fuzz。WRatio)等。</p></blockquote><p id="d27a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">稍后我们会看到完整的得分者名单和他们每个人的表现。理论到此为止，让我们开始实践吧！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="b45c" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">不那么无聊的模糊应用程序:</h1><p id="abda" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">在我们的例子中，我们希望将<code class="du lw lx ly lz b">hr.full_name</code>列中的每个全名与<code class="du lw lx ly lz b">it.email</code>列中的所有实际电子邮件进行比较，因此我们将使用<strong class="iw hj"> process.extract </strong>。</p><p id="07fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，我们只需要电子邮件的第一部分进行比较，因为域名部分<code class="du lw lx ly lz b">@giantbabybibs.org</code>可能会干扰比率计算。让我们在<code class="du lw lx ly lz b">it</code>数据框架内生成一个名为<code class="du lw lx ly lz b">username</code>的新列:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="cbef" class="me kp hi lz b fi mf mg l mh mi">it['username'] = it['email'].str.replace('<a class="ae kg" href="http://twitter.com/giantbabybibs" rel="noopener ugc nofollow" target="_blank">@giantbabybibs</a>.org', '')<br/>it.head(3)</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/17ed23e88ae8c7d55ebf31d945088fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*IlRTnefLmdmPoxhgjuhJkA.png"/></div></figure><p id="16ea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们使用<strong class="iw hj"> process.extract </strong>来比较<code class="du lw lx ly lz b">hr.full_name</code>和<code class="du lw lx ly lz b">it.username</code>(注意，我们在计算比率后添加了域名<code class="du lw lx ly lz b">@giantbabybibs.org</code>):</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="9899" class="me kp hi lz b fi mf mg l mh mi">actual_email = []<br/>similarity = []</span><span id="6046" class="me kp hi lz b fi mj mg l mh mi">for i in hr.full_name:<br/>        ratio = process.extract( i, it.username, limit=1)<br/>        actual_email.append(ratio[0][0])<br/>        similarity.append(ratio[0][1])</span><span id="a6a6" class="me kp hi lz b fi mj mg l mh mi">hr['actual_email'] = pd.Series(actual_email)<br/>hr['actual_email'] = hr['actual_email'] + '<a class="ae kg" href="http://twitter.com/giantbabybibs" rel="noopener ugc nofollow" target="_blank">@giantbabybibs</a>.org'<br/>hr['similarity'] = pd.Series(similarity)</span><span id="c117" class="me kp hi lz b fi mj mg l mh mi">hr.head(3)</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/ed49521c6caecd6b371911afa8d88713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaHR2xZVfVIvdLv5ylr5Sg.png"/></div></div></figure><p id="e570" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">模糊巫师施展了他的魔法！现在让我们简化这个数据帧，只保留<code class="du lw lx ly lz b">full_name</code>、<code class="du lw lx ly lz b">actual_email</code>和<code class="du lw lx ly lz b">similarity</code>列。姑且称之为<code class="du lw lx ly lz b">final_result</code>:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="4fec" class="me kp hi lz b fi mf mg l mh mi">final_result = hr[['full_name', 'actual_email', 'similarity']]<br/>final_result.head(3)</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es my"><img src="../Images/0ef2b69ef7e8f044078673d94b30edd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*lav03Jp9DUw--pb-HbbZLw.png"/></div></figure><p id="3867" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> NB </strong>:如果<code class="du lw lx ly lz b">hr.full_name</code>有空值(不仅仅是<em class="ms">字符串</em>显示‘Null’或‘Nan’)，上面的代码应该考虑到这一点(感谢Thomas Algenio提出这个问题) :</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="dee1" class="me kp hi lz b fi mf mg l mh mi">import numpy as np</span><span id="8cf1" class="me kp hi lz b fi mj mg l mh mi">actual_email = []<br/>similarity = []</span><span id="700b" class="me kp hi lz b fi mj mg l mh mi">for i in hr.full_name :     <br/>    if pd.isnull( i ) :          <br/>        matching_list.append(np.null)<br/>        similarity.append(np.null)     <br/>    else :          <br/>        ratio = process.extract( i, df2.col, limit=1)<br/>        matching_list.append(ratio[0][0])<br/>        similarity.append(ratio[0][1]) <br/>...<br/>...</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="744a" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">审计:</h1><p id="138f" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">这很好，但我们如何确保每个员工都匹配到正确的电子邮件呢？这样做的一个好方法是格式化数据帧，这样低的比率将更容易使用颜色图发现和检查。在我们的例子中，我们将使用反转的夏季色图<code class="du lw lx ly lz b">summer_r</code>，其中高比率显示绿色，低比率显示黄色:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="628f" class="me kp hi lz b fi mf mg l mh mi">final_result.head(8).style.background_gradient(subset='similarity',<br/>                                               cmap='summer_r')</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es my"><img src="../Images/572c27617db790a9e4fa875cb9c4b26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*fL3t6BmnV1olSlDbYPGXAw.png"/></div></figure><p id="c8c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">除此之外，我们可以通过<code class="du lw lx ly lz b">similarity</code>对<code class="du lw lx ly lz b">final_result</code>数据帧进行排序，然后检查低比率(注意，高比率并不意味着匹配正确。反之亦然)。</p><p id="2a76" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，如果你的数据框架很大(比如一百万条记录或者更多)，你能做什么呢？您可以使用<strong class="iw hj">随机抽样</strong>来控制匹配是否成功。你应该根据需要多次运行下面的代码，因为每次你都会得到一个新的随机样本来检查(这里的<code class="du lw lx ly lz b">random_state=9</code>参数确保你会得到和我一样的样本)。每次运行该单元时，移除它以获得随机样本) :</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="db18" class="me kp hi lz b fi mf mg l mh mi">sample = final_result.sample( n=8, random_state=9 )<br/>sample</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/189445063d0397ba73f373828f73fce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*HntRyhhx9LubIJ1WW2Ko4w.png"/></div></figure><p id="de37" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们在这里看到的，上面的随机样本显示，员工<strong class="iw hj"> N 60犯了一个特殊的错误:Rocio E. Thatch </strong>。会不会是因为中间名缩写？让我们看看是否还有其他像这样的员工:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="8b42" class="me kp hi lz b fi mf mg l mh mi">final_result[final_result['full_name'].str.contains('.',<br/>                                                    regex=False)]</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es na"><img src="../Images/99f85a26b6620522639e87880af629c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*ROPEjYDK0Qk63YyoFYF9rA.png"/></div></figure><p id="a798" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你看看这个！这个过程把4名员工都弄错了。尽管这只是200封邮件中的<strong class="iw hj"> 4封</strong>错误，这意味着98%的<strong class="iw hj">成功率</strong>，但想象一下，如果你的数据框架中有173，000名员工(例如像通用汽车这样的公司)，这将意味着<strong class="iw hj"> 3460封错误邮件</strong>。</p><p id="d017" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了理解为什么会出现这种错误，我们必须检查该流程使用了哪个<code class="du lw lx ly lz b">FuzzyWuzzy</code> <strong class="iw hj">计分器</strong>。计分器是一种通过比较两个字符串来生成比率的方法。是的，正如我们之前看到的，<code class="du lw lx ly lz b">FuzzyWuzzy</code>有许多不同的计分器，你可以根据你正在处理的数据类型进行选择。以下是上述得分者的名单:</p><ul class=""><li id="ea4c" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">模糊比率</li><li id="d9bf" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">模糊.部分_比率</li><li id="bf38" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz.token_set_ratio</li><li id="8aee" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz.token_sort_ratio</li><li id="1623" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz.partial_token_set_ratio</li><li id="b9b7" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzzy . partial _ token _ sort _ ratio</li><li id="64a3" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj">细毛。WRatio </strong></li><li id="f1e8" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。比率</li><li id="3886" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。UWRatio</li><li id="161a" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。比率</li></ul><p id="a194" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">流程默认使用的是<code class="du lw lx ly lz b">fuzz.WRatio</code>。如果您想对这些计分器中的一个使用<code class="du lw lx ly lz b">process</code>,只需像这样传递它作为一个参数:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="1726" class="me kp hi lz b fi mf mg l mh mi">ratio = process.extract( column_A, column_B, limit=1,<br/>                         scorer=fuzz.ratio )</span></pre><p id="eb80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们将测试其中一些计分器，看看哪一个在我们的情况下工作得最好。开始寻找100%的成功率吧！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="3985" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">寻找完美的模糊不清的记分员:</h1><p id="a897" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">让我们看看所有我们能使用的<code class="du lw lx ly lz b">FuzzyWuzzy</code>计分器。我们将为它们中的每一个分配一个缩写，以便以后在字典中作为一个键使用(scorer方法是区分大小写的。例如fuzz.wratio将不起作用) :</p><ul class=""><li id="3c26" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">模糊比率</li><li id="56ed" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">模糊.部分比率(PR)</li><li id="1d59" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz.token_set_ratio</li><li id="bcd8" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz.token_sort_ratio</li><li id="7f58" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz . partial _ token _ set _ ratio(PTSeR)</li><li id="f259" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">fuzz . partial _ token _ sort _ ratio(PTsoR)</li><li id="370a" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。雷蒂奥(WR)</li><li id="7c08" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。比率(QR)</li><li id="71a1" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。UWRatio (UWR)</li><li id="187e" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">绒毛。UQR比率</li></ul><p id="f98b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是我们最喜欢的字典:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="8856" class="me kp hi lz b fi mf mg l mh mi">scorer_dict = { 'R':fuzz.ratio, <br/>                'PR': fuzz.partial_ratio, <br/>                'TSeR': fuzz.token_set_ratio, <br/>                'TSoR': fuzz.token_sort_ratio,<br/>                'PTSeR': fuzz.partial_token_set_ratio, <br/>                'PTSoR': fuzz.partial_token_sort_ratio, <br/>                'WR': fuzz.WRatio, <br/>                'QR': fuzz.QRatio,<br/>                'UWR': fuzz.UWRatio, <br/>                'UQR': fuzz.UQRatio }</span></pre><p id="145e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还记得<code class="du lw lx ly lz b">hr</code>数据帧吗？我们将使用它的列<code class="du lw lx ly lz b">full_name</code>进行测试。我们称之为<code class="du lw lx ly lz b">scorer_test</code>:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="f80f" class="me kp hi lz b fi mf mg l mh mi">scorer_test = hr[['full_name']].copy()<br/>scorer_test.head(3)</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/9bd9d6559f5c436f9a022ee168492b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*O_cRCXRAhXxxhnEZMCY6LA.png"/></div></figure><p id="ab2b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在是大秀！我们将定义一个名为<code class="du lw lx ly lz b">scorer_tester_function</code>的<strong class="iw hj">函数</strong>，它从<code class="du lw lx ly lz b">scorer_dict</code>(它只是计分器的名称)中获取一个<strong class="iw hj">参数x </strong>，并将<code class="du lw lx ly lz b">scorer_test.full_name</code>列与<code class="du lw lx ly lz b">it.email</code>列进行匹配:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="f744" class="me kp hi lz b fi mf mg l mh mi">def scorer_tester_function(x) :<br/>    actual_email = []<br/>    similarity = []<br/>    <br/>    for i in scorer_test['full_name']:<br/>        ratio = process.extract( i, it.username, limit=1,<br/>                                 scorer=scorer_dict[x])<br/>        actual_email.append( ratio[0][0] )<br/>        similarity.append( ratio[0][1] )</span><span id="86de" class="me kp hi lz b fi mj mg l mh mi">        scorer_test['actual_email'] = pd.Series(actual_email)<br/>        scorer_test['actual_email'] = scorer_test['actual_email'] +<br/>                                      '<a class="ae kg" href="http://twitter.com/giantbabybibs" rel="noopener ugc nofollow" target="_blank">@giantbabybibs</a>.org'<br/>        scorer_test['similarity'] = pd.Series(similarity)<br/>        <br/>    return scorer_test</span></pre><p id="3f82" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们将应用来自<code class="du lw lx ly lz b">scorer_dict</code>字典的不同计分器的函数。让我们从4名员工<strong class="iw hj">开始。</strong>WRatio(WR)弄错了:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="0fda" class="me kp hi lz b fi mf mg l mh mi">scorer_tester_function('WR')<br/>scorer_test[scorer_test.full_name.str.contains('.', regex=False)]</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/804c4602c18b117cd4550fc93a9d3cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*dSZntRgAGZlnMrJ3oxJuPg.png"/></div></figure><p id="d44a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们所见，<strong class="iw hj">细毛。WRatio (WR) </strong>全名带有中间名缩写时表现很差。让我们看看其他评分者是否会纠正这一点，<strong class="iw hj"> fuzz.ratio (R) </strong>例如:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="6bb9" class="me kp hi lz b fi mf mg l mh mi">scorer_tester_function('R')<br/>display(scorer_test[scorer_test.full_name.str.contains('.',<br/>                                                    regex=False)])<br/>display(scorer_test[81:82])</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/c203bc7b63e21ae66b782693d2851767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Ay1341b_fxqFrGixP8f-HA.png"/></div></figure><p id="7e96" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">确实如此。<strong class="iw hj"> fuzz.ratio (R) </strong>得到了<strong class="iw hj">200个正确</strong>中的199个(99.5%的成功率)。它犯的唯一错误是针对第81号员工:斯特林·马洛里·阿彻。(我们在危险区！).但是，所有中间名缩写的员工都通过该评分员得到了妥善处理。</p><p id="0168" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们能做得更好吗？让我们尝试另一个计分器，<strong class="iw hj"> fuzz.partial_ratio (PR) </strong>这次，看看它是否对所有有问题的员工姓名都有效:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="cfd5" class="me kp hi lz b fi mf mg l mh mi">scorer_tester_function('PR')<br/>display(scorer_test[scorer_test.full_name.str.contains('.',<br/>                                                    regex=False)])<br/>display(scorer_test[81:82])</span></pre><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/227eb5470e170c7f698125f36298771d.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*JFSslYwJSjfRCd5d8AUrDA.png"/></div></figure><p id="99c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">终于！在人工检查完所有其他记录后，我在此宣布<strong class="iw hj"> fuzz.partial_ratio (PR) </strong>以<strong class="iw hj"> 100%成功率</strong>获得冠军。任务结束了！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="d2b5" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">射手之战(加成) :</h1><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/154dbd0f5dd4fcaea9e1113a2658cfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdmA_hEH_AlvG52Me4TtHg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">rawpixel.com</figcaption></figure><p id="d2d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在现实世界的应用程序中，您可能会处理大量的数据，在这种情况下，手动检查结果是不可取的。这就是为什么你需要了解每个<code class="du lw lx ly lz b">FuzzyWuzzy</code>计分器做什么，以便选择一个最适合你正在处理的数据的计分器。</p><p id="d40a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了探究评分器<code class="du lw lx ly lz b">FuzzyWuzzy</code>之间的差异，我们将使用一个测试字符串。我们想把一个朋友的<strong class="iw hj">地址</strong>和一个电话簿的<strong class="iw hj">多个地址</strong>(是的，电话簿还是一个东西！):</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="8cea" class="me kp hi lz b fi mf mg l mh mi">friend_address = '56 West Princess Rd. Cedar Rapids, IA 52402'</span><span id="9b06" class="me kp hi lz b fi mj mg l mh mi">phonebook = [ '9102 South St. Lake Worth, FL 33460',<br/>              '20425 Prince Edward Road, West philadelphia, PA<br/>               56560',<br/>              'Wst Princess Road, Appt. 56 N°8 3rd floor, C.Rapids,<br/>               52402 Iowa ',<br/>              '400 Van Dyke St.Hartford, IA 26106',<br/>              '56 Golden Star Rd, Stone Rapids, GA 52483' ]</span></pre><p id="f423" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们来测试一下所有的得分者。在这种情况下，我们将使用<code class="du lw lx ly lz b">fuzz</code>模块，而不是<code class="du lw lx ly lz b">process</code>。</p><h2 id="488c" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">1 —模糊比率(R)</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="433b" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="4249" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.ratio(friend_address, address)<br/>    print(address, '\nRATIO: ', ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="3953" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。爱荷华州锡达拉皮兹52402 <br/> - <br/>佛罗里达州南圣莱克沃斯9102号33460 <br/>比例:31 <br/> <br/>宾夕法尼亚州西费城爱德华王子路20425号56560 <br/>比例:50 <br/> <br/> Wst公主路，Appt。衣阿华州52402 .拉皮兹56N 8 3楼<br/>比例:62 <br/>比例:400衣阿华州范·代克圣哈特福德26106 <br/>比例:39 <br/>比例:56佐治亚州石拉皮兹金星路56号<br/>比例:60</p></blockquote><p id="46ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> fuzz.ratio (R) </strong>简单计算<strong class="iw hj"> Levenshtein距离</strong>。如果两个字符串完全相似(包括大写和小写),它只会返回100%,这在我们寻找精确匹配时非常有用。</p><h2 id="0bdd" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">2 — fuzz.partial_ratio (PR):</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="3033" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="d37d" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.partial_ratio(friend_address, address)<br/>    print(address, '\nRATIO: ', ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="b92c" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。爱荷华州锡达拉皮兹52402 <br/> - <br/> 9102佛罗里达州南圣莱克沃斯33460 <br/>比例:29<br/>T26】20425宾夕法尼亚州西费城太子路56560 <br/>比例:49<br/>Wst公主路Appt。衣阿华州C .拉皮兹52402号8楼56号<br/>比例:51 <br/>比例:400衣阿华州范·代克圣哈特福德26106 <br/>比例:41 <br/>比例:56佐治亚州斯通拉皮兹金星路56号<br/>比例:61</p></blockquote><p id="27d4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> fuzz.partial_ratio (PR) </strong>考虑它所比较的字符串的子集，然后根据它们的相似性返回一个比率。例如，如果将<strong class="iw hj">道恩·约翰逊</strong>与<strong class="iw hj">道恩</strong>进行比较，它将返回100%的比率:</p><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="97ba" class="me kp hi lz b fi mf mg l mh mi">fuzz.partial_ratio('Dwayne The Rock Johnson', 'Dwayne')<br/>Output: 100</span></pre><p id="65d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，在我们的例子中，它被愚弄了，因为第五个地址与朋友的地址有共同的词，如<code class="du lw lx ly lz b">56</code>、<code class="du lw lx ly lz b">Rd.</code>和<code class="du lw lx ly lz b">Rapids</code>。所以，也许这不是这个特殊任务的最佳记分员。</p><h2 id="7bb1" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">3 — fuzz.token_sort_ratio (TSoR):</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="f831" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="d44e" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.token_sort_ratio(friend_address, address)<br/>    print(address, '\nRATIO: ', ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="206b" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。锡达拉皮兹，IA 52402 <br/> - <br/> 9102南圣莱克沃斯，FL 33460 <br/>比例:35 <br/> <br/> 20425西费城太子道，PA 56560 <br/>比例:65 <br/> <br/> Wst公主道，Appt。衣阿华州C .拉皮兹市56号8楼3楼52402】比例:75 <br/>比例:400衣阿华州范·代克圣哈特福德26106 <br/>比例:38 <br/>比例:56佐治亚州石拉皮兹市金星路56号<br/>比例:57</p></blockquote><p id="c495" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个令牌方法。令牌方法的优点是可以忽略大小写和标点符号(所有字符都被转换成小写字符)。在使用<strong class="iw hj">fuzz . token _ sort _ ratio(TSoR)</strong>的情况下，在对字符串应用基本的<strong class="iw hj"> fuzz.ratio (R) </strong>之前,“标记化”的字符串(每个单词都被转换成一个标记)按字母数字顺序排序，因此两个字符串中单词的顺序并不重要(与之前的非标记方法不同)。在这种情况下，这个得分手表现得非常好。</p><h2 id="1af6" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">4 — fuzz.token_set_ratio(TSeR):</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="ccb0" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="84e5" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.token_set_ratio(friend_address, address)<br/>    print(address, '\nRATIO: ', ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="e053" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。爱荷华州锡达拉皮兹52402 <br/> - <br/> 9102佛罗里达州南圣莱克沃斯33460 <br/>比例:35<br/>T5】宾夕法尼亚州西费城太子路20425号56560 <br/>比例:65<br/>Wst公主路Appt。衣阿华州52402 .拉皮兹56N 8 3楼<br/>比例:77 <br/>比例:400范·代克圣哈特福德，衣阿华州26106 <br/>比例:43 <br/>比例:56佐治亚州石拉皮兹金星路<br/>比例:60</p></blockquote><p id="d42c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是目前给定任务的最佳比例。<strong class="iw hj">fuzz . token _ set _ ratio(TSeR)</strong>与<strong class="iw hj">fuzz . token _ sort _ ratio(TSoR)</strong>相似，只是它忽略了重复的单词(因此得名，因为在Math和Python中的<code class="du lw lx ly lz b">set</code>是不包含重复值的集合/数据结构)。它还对比较的两个字符串共有的标记进行配对比较。</p><h2 id="8c57" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">5—fuzz . partial _ token _ sort _ ratio(PTSoR):</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="e9a2" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="d006" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.partial_token_sort_ratio(friend_address, address)<br/>    print(address, '\nRATIO: ' ,ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="fd18" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。爱荷华州锡达拉皮兹52402 <br/> - <br/> 9102佛罗里达州南圣莱克沃斯33460 <br/>比例:33<br/>T24】20425宾夕法尼亚州西费城太子路56560 <br/>比例:61<br/>Wst公主路Appt。衣阿华州C .拉皮兹56 N 8号3楼<br/>比例:71<br/>T30】爱荷华州范·代克圣哈特福德400号26106 <br/>比例:42<br/>T33】佐治亚州斯通拉皮兹金星路56号52483 <br/>比例:56</p></blockquote><p id="40dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">fuzz . partial _ token _ sort _ ratio(PTSoR)</strong>与<strong class="iw hj">fuzz . token _ sort _ ratio(TSR)</strong>的工作原理相同，但它在标记化和排序后使用了<strong class="iw hj"> fuzz.partial_ratio (PR) </strong>方法，而不是普通的<strong class="iw hj"> fuzz.ratio (R) </strong>方法。</p><h2 id="e61c" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">6—fuzz . partial _ token _ set _ ratio(PTSeR):</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="a92f" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="2160" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.partial_token_set_ratio(friend_address, address)<br/>    print(address, '\nRATIO: ', ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="943e" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。锡达拉皮兹，IA 52402 <br/> - <br/> 9102南圣莱克沃斯，FL 33460 <br/>比例:33 <br/> <br/> 20425西费城太子道，PA 56560 <br/>比例:100 <br/> <br/> Wst公主道，Appt。衣阿华州C .拉皮兹市56 N 8号3楼52402】比例:100 <br/> <br/> 400衣阿华州范·代克圣哈特福德26106 <br/>比例:100 <br/> <br/>佐治亚州石拉皮兹市金星路56号52483 <br/>比例:100</p></blockquote><p id="35dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与<strong class="iw hj">fuzz . token _ set _ ratio(TSR)</strong>相同，但在标记化和设置(消除重复)后，不使用<strong class="iw hj"> fuzz.ratio (R) </strong>，而是使用<strong class="iw hj"> fuzz.partial_ratio (PR) </strong>。这里我们看到它太宽容了，在这种情况下没有用。</p><h2 id="7970" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">7 —模糊。雷蒂奥(WR):</h2><pre class="ln lo lp lq fd ma lz mb mc aw md bi"><span id="cfda" class="me kp hi lz b fi mf mg l mh mi">print("Friend's address : ", friend_address, '\n', 62*'-', '\n')</span><span id="b748" class="me kp hi lz b fi mj mg l mh mi">for address in phonebook:<br/>    ratio = fuzz.WRatio(friend_address, address)<br/>    print(address, '\nRATIO: ', ratio, '\n')</span></pre><blockquote class="mp mq mr"><p id="9f68" class="iu iv ms iw b ix iy iz ja jb jc jd je mt jg jh ji mu jk jl jm mv jo jp jq jr hb bi translated">朋友的地址:公主西路56号。爱荷华州锡达拉皮兹52402 <br/> - <br/> 9102佛罗里达州南圣莱克沃斯33460 <br/>比例:38<br/>T4 20425宾夕法尼亚州西费城太子路56560 <br/>比例:62<br/>Wst公主路Appt。衣阿华州52402 .拉皮兹56N 8 3楼<br/>比例:73<br/>T10】爱荷华州范·代克圣哈特福德400号26106 <br/>比例:44<br/>T13】佐治亚州石拉皮兹金星路56号52483 <br/>比例:64</p></blockquote><p id="aec4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是与<strong class="iw hj"> process.extract() </strong>一起使用的默认计分器。这个记分员，<strong class="iw hj"> fuzz。WRatio (WR) </strong>(代表加权比率)，试图得到一个比标准的<strong class="iw hj"> fuzz.ratio (R) </strong>更好的比率。根据源代码，它是这样工作的:</p><ol class=""><li id="d54b" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr ml jy jz ka bi translated">取两个处理过的字符串的比率(fuzz.ratio)</li><li id="217e" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr ml jy jz ka bi translated">运行检查以比较字符串的长度</li></ol><ul class=""><li id="5f3e" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">如果其中一个字符串的长度是另一个字符串的1.5倍以上，则使用partial_ratio比较-将部分结果缩放0.9(这确保只有完整结果才能返回100)</li><li id="8197" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">如果其中一根弦的长度超过另一根弦的8倍，则按0.6的比例缩放</li></ul><p id="0499" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.运行其他比率功能</p><ul class=""><li id="bc44" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">如果使用部分比率函数，则调用partial_ratio、partial_token_sort_ratio和partial_token_set_ratio根据长度按比率缩放所有这些函数</li><li id="440a" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">否则调用token_sort_ratio和token_set_ratio</li><li id="e51a" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">所有基于标记的比较都被缩放0.95(在任何部分标量之上)</li></ul><p id="b128" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.从这些结果中取最大值，对其进行舍入，并将其作为整数返回。</p><p id="2056" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我告诉你这是魔法！</p><h2 id="6730" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">8 —模糊。UWRatio(UWR):</h2><p id="32ff" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">与<strong class="iw hj"> WR </strong>相同，但是它考虑了Unicode。在这种情况下，它输出比<strong class="iw hj"> WR </strong>略低的比率，因为<strong class="iw hj">字符</strong>强制使用Unicode编码(它不在朋友的地址中，使得分数略低)。</p><h2 id="60f4" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">9 —模糊。QRatio(QR):</h2><p id="01f5" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">根据源代码，<strong class="iw hj"> QR </strong>代表速动比率，因为如果处理后任一字符串为空，它会缩短比较过程。</p><h2 id="4b24" class="me kp hi bd kq nf ng nh ku ni nj nk ky jf nl nm lc jj nn no lg jn np nq lk nr bi translated">10 —模糊。UQRatio(UQR):</h2><p id="6b31" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">与<strong class="iw hj"> QR </strong>相同，但代表Unicode速动比率(就像<strong class="iw hj"> WR </strong>也有Unicode版本一样)。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="0b13" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">判决结果是:</h1><p id="9b9b" class="pw-post-body-paragraph iu iv hi iw b ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn lv jp jq jr hb bi translated">正如我们所看到的，最佳性能评分器随着应用程序的变化而变化。在将全名比作电子邮件的情况下，<strong class="iw hj"> fuzz.partial_ratio (PR) </strong>是正确的选择。对于地址，<strong class="iw hj">fuzz . token _ set _ ratio(TSeR)</strong>是表现最好的计分器，不仅因为它给出了正确地址的最高比率，还因为正确地址和最接近的错误地址的比率之间的差异是最高的(12分)。</p><p id="c041" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无论如何，在确定匹配字符串的最佳方法之前，使用<code class="du lw lx ly lz b">FuzzyWuzzy</code>需要一些试验。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="06fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望这篇文章不要太长，我只是想尽可能多地介绍一些有用的内容。如果你需要一个代码片段的解释，一定要下载Jupyter笔记本并查看附录。</p></div></div>    
</body>
</html>