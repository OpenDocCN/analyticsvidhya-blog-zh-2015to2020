<html>
<head>
<title>The SOLID Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/s-o-l-i-d-principles-7caf040fab96?source=collection_archive---------13-----------------------#2020-02-18">https://medium.com/analytics-vidhya/s-o-l-i-d-principles-7caf040fab96?source=collection_archive---------13-----------------------#2020-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d5c87ac328f9b54b6ece0729997b7e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFWBCirj1Qk4EdIyQSFhhA.jpeg"/></div></div></figure><p id="3f14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将尝试解释复习所谓的<strong class="is hj">扎实</strong> <strong class="is hj">原理</strong>，以及如何以一种Pythonic式的方式实现它们。我们将学习如何开发可维护的。将设计模式应用于<strong class="is hj">坚实</strong> <strong class="is hj">原则</strong>的软件系统。</p><p id="3f01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SOLID是OOP(面向对象编程)的基本原则，在本世纪初由<strong class="is hj"> Michael Feathers </strong>提出定义，并以前五项原则<strong class="is hj"> Robert C. Martin </strong>命名。当谈到坚实的原理时，参考<strong class="is hj">类</strong>和<strong class="is hj">模块</strong>。这并不意味着它们只适用于OOP，尽管它们确实能很好地与OOP一起工作。</p><p id="beb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OOP是关于通过反转关键依赖来管理依赖，以防止<strong class="is hj">刚性代码</strong>、<strong class="is hj">脆弱代码</strong>和<strong class="is hj">不可重用代码</strong>。描述不可重用代码有三个术语:</p><ul class=""><li id="a306" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">刚性</strong>:当一个程序的一部分的改变会破坏另一部分时</li><li id="048a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">脆弱:当东西在不相关的地方破碎</li><li id="b3a7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">不可移动性</strong>:当代码不能在其原始上下文之外重用时</li></ul><p id="49d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用<strong class="is hj">坚实的原理</strong>解决这些问题。它被认为是面向对象编程(OOP)的基本原则，定义了<strong class="is hj">五个</strong>设计原则。</p><p id="953c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些原则使得软件设计更容易理解，更灵活，更易维护。</p><ul class=""><li id="ded1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">单一责任原则</li><li id="1171" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj"> O </strong>笔闭合原理(<strong class="is hj"> OCP </strong>)</li><li id="64e0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj"> L </strong>伊斯科夫替代原理(<strong class="is hj"> LSP </strong></li><li id="bfa4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj"> I </strong>界面偏析原理(<strong class="is hj"> ISP </strong></li><li id="9bef" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj"> D </strong>依赖反转原理(DIP)</li></ul><p id="c286" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们一个一个来看看这些原理。</p><h1 id="6d5c" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1.单一责任原则</h1><p id="e44a" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">这个原理经常被表述为:</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9d84" class="lo kd hi lk b fi lp lq l lr ls">A software component(Module or Class) must have only one responsibility.</span></pre><p id="5c52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个项目中的每个班级都应该专注于一项任务。因此，不要将因不同原因而改变的方法放在同一个类中。我们可以得出结论，它必须只有一个改变的理由。</p><p id="5ba6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，有一个<strong class="is hj">圆</strong>类。它提供了一个叫做<strong class="is hj"> draw() </strong>的方法。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="ad34" class="lo kd hi lk b fi lp lq l lr ls">class Circle():<br/>    def draw(self):<br/>        """Draw a circle"""<br/>        pass</span></pre><h1 id="ee9b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">2.开闭原则(OCP)</h1><p id="4f2c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">这个原理经常被表述为:</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="5100" class="lo kd hi lk b fi lp lq l lr ls">A software entities (source file, module, class, <br/>or function) should be open for extension but closed for modification.</span></pre><p id="0a85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们应该能够添加功能，而不必从头重写一切。</p><p id="9e2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们得到了一个绘制<strong class="is hj">圆</strong>和<strong class="is hj">正方形</strong>的应用程序。画图时，如果类型是<strong class="is hj">圆</strong>或<strong class="is hj">方</strong>就这样画。但是我们如果以后要按照三角形来画就违背了这个原则。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="ab6e" class="lo kd hi lk b fi lp lq l lr ls">class Shape:<br/>    def draw_circle(self):<br/>        """Draw a circle"""<br/>        pass<br/>    def draw_square(self):<br/>        """ Draw a square"""<br/>        pass<br/>    def draw_triangle(self):<br/>        """ Draw a triangle"""<br/>        pass</span></pre><p id="b668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这种情况，下面的代码片段就是按照这个原则编写的。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="63a7" class="lo kd hi lk b fi lp lq l lr ls">class Shape<br/>    def draw(self):<br/>        """Draw a shape"""<br/>        pass</span><span id="536b" class="lo kd hi lk b fi lt lq l lr ls">class Circle(Shape):<br/>    def draw(self):<br/>        """Draw a circle"""<br/>        pass</span><span id="109d" class="lo kd hi lk b fi lt lq l lr ls">class Square(Shape):<br/>    def draw(self):<br/>        """Draw a square"""<br/>        pass</span></pre><h1 id="6dc8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">3.利斯科夫替代原理</h1><p id="a016" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">这个原理经常被表述为:</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="dec4" class="lo kd hi lk b fi lp lq l lr ls">If for each object o1 of type S there is an object o2 of type T <br/>such that for all programs P defined in terms of T, the <br/>behavior of P is unchanged when o1 is substituted for o2 <br/>then S is a subtype of T.</span><span id="01fd" class="lo kd hi lk b fi lt lq l lr ls">Barbara Liskov, “Data Abstractions and Hierarchy”, 1988.</span></pre><p id="7c98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Liskov替换原则指出，设计必须提供用一个子类的实例替换父类的任何实例的能力。如果一个父类能做一些事情，那么一个子类也必须能做。</p><p id="7069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，Vehicle类有一个engine方法。但是自行车没有发动机。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a499" class="lo kd hi lk b fi lp lq l lr ls">class Vehicle:<br/>    def __init__(self, name):<br/>        self.name = name</span><span id="66eb" class="lo kd hi lk b fi lt lq l lr ls">    def engine(self):<br/>        """A Vehicle engine"""<br/>        pass</span><span id="20d8" class="lo kd hi lk b fi lt lq l lr ls">    def get_name(self):<br/>        """Get vehicle name"""<br/>        return f'The vehicle name {self.name}'</span><span id="0cef" class="lo kd hi lk b fi lt lq l lr ls">class Bicycle(Vehicle):<br/>    def engine(self):<br/>        pass</span><span id="fa56" class="lo kd hi lk b fi lt lq l lr ls">class Car(Vehicle):<br/>    def engine(self):<br/>        pass</span></pre><p id="45ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们根据这个规则修改代码。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a072" class="lo kd hi lk b fi lp lq l lr ls">class Vehicle:<br/>    def __init__(self, name):<br/>        self.name = name</span><span id="16e9" class="lo kd hi lk b fi lt lq l lr ls">    def get_name(self):<br/>        """Get vehicle name"""<br/>        return f'The vehicle name {self.name}'</span><span id="a0d9" class="lo kd hi lk b fi lt lq l lr ls">class VehicleWithoutEngine(Vehicle):<br/>    pass</span><span id="6483" class="lo kd hi lk b fi lt lq l lr ls">class VehicleWithEngine(Vehicle):<br/>    def engine(self):<br/>        """A Vehicle engine"""<br/>        pass</span><span id="0d13" class="lo kd hi lk b fi lt lq l lr ls">class Bicycle(VehicleWithoutEngine):<br/>    pass</span><span id="ecd2" class="lo kd hi lk b fi lt lq l lr ls">class Car(VehicleWithEngine):<br/>    def engine(self):<br/>        """A vehicle engine"""<br/>        pass</span></pre><h1 id="fbd9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">4.界面分离原理(IPS)</h1><p id="99d1" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">这个原理经常被表述为:</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="8a47" class="lo kd hi lk b fi lp lq l lr ls">A client should not be forced to implement an interface that it does not use.</span></pre><p id="9b04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接口隔离原则(ISP)指出，拥有许多小接口比拥有几个大接口更好，并且提供了一些我们已经反复讨论过的观点的指导原则:接口应该是小的。</p><p id="b97d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在面向对象的术语中，接口由对象公开的一组方法来表示。也就是说，一个对象能够接收或解释的所有消息构成了它的接口，这也是其他客户端可以请求的。接口将类的公开行为的定义与其实现分开。</p><p id="dce7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们从Circle和Square类中调用一些方法。但是它们是不必要的方法。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="bb2d" class="lo kd hi lk b fi lp lq l lr ls">class Shape:<br/>    def draw_circle(self):<br/>        """Draw a circle"""<br/>        pass</span><span id="1533" class="lo kd hi lk b fi lt lq l lr ls">    def draw_square(self):<br/>        """Draw a square"""<br/>        pass<br/>    <br/>class Circle(Shape):<br/>    def draw_circle(self):<br/>        """Draw a circle"""<br/>        pass</span><span id="55e8" class="lo kd hi lk b fi lt lq l lr ls">    def draw_square(self):<br/>        """Draw a square"""<br/>        pass</span><span id="b29a" class="lo kd hi lk b fi lt lq l lr ls">class Square(Shape):<br/>    def draw_circle(self):<br/>        """Draw a circle"""<br/>        pass</span><span id="daf7" class="lo kd hi lk b fi lt lq l lr ls">    def draw_square(self):<br/>        """Draw a square"""<br/>        pass</span></pre><p id="06a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这种情况，下面的代码片段就是按照这个原则编写的。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6ecf" class="lo kd hi lk b fi lp lq l lr ls">class Shape:<br/>    def draw(self):<br/>        """Draw a shape"""<br/>        pass</span><span id="f597" class="lo kd hi lk b fi lt lq l lr ls">class Circle(Shape):<br/>    def draw(self):<br/>        """Draw a circle"""<br/>        pass</span><span id="5415" class="lo kd hi lk b fi lt lq l lr ls">class Square(Shape):<br/>    def draw(self):<br/>        """Draw a square"""<br/>        pass</span></pre><h1 id="2f66" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">5.从属倒置原则</h1><p id="90a7" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">这一原则通常被表述为:</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="ec8a" class="lo kd hi lk b fi lp lq l lr ls">High-level modules should not depend on low-level <br/>modules. Both should depend on abstractions. Abstractions <br/>should not depend on details. Details should depend on <br/>abstractions.</span><span id="5353" class="lo kd hi lk b fi lt lq l lr ls">Or, source code dependencies should refer only to <br/>abstractions, not to concretions.</span></pre><p id="a583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽象必须以不依赖于细节的方式来组织，反之亦然——细节(具体实现)应该依赖于抽象。</p><p id="fe7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们设计中的两个对象需要协作，A和B。A使用B的一个实例，但事实证明，我们的模块并不直接控制B(它可能是一个外部库，或者由另一个团队维护的模块，等等)。如果我们的代码严重依赖于B，当这种变化发生时，代码将会崩溃。为了防止这种情况，我们必须反转依赖关系:使B必须适应a。这是通过提供一个接口并强制我们的代码不依赖于B的具体实现，而是依赖于我们定义的接口来实现的。然后，B有责任遵守该接口。</p><p id="a3b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，<strong class="is hj"> Sports </strong>类是一个高级模块。<strong class="is hj">足球</strong>和<strong class="is hj">篮球</strong>为低级模块。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="86b1" class="lo kd hi lk b fi lp lq l lr ls">class Football:<br/>    """Low-level module"""<br/>    @staticmethod<br/>    def play_football():<br/>        print('play football')</span><span id="9339" class="lo kd hi lk b fi lt lq l lr ls">class Basketball:<br/>    """Low-level module"""<br/>    @staticmethod<br/>    def play_basketball():<br/>        print('play basketball')</span><span id="a46f" class="lo kd hi lk b fi lt lq l lr ls">class Sports:<br/>    """High-level module"""<br/>    def __init__(self):<br/>        self.football = Football()<br/>        self.basketball = Basketball()</span><span id="adbf" class="lo kd hi lk b fi lt lq l lr ls">    def playing(self):<br/>        self.football.play_football()<br/>        self.basketball.play_basketball()<br/>        return 'Playing...'</span></pre><p id="8956" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结果</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="5dc8" class="lo kd hi lk b fi lp lq l lr ls">In [1]: s = Sports()<br/>In [2]: s.playing()<br/>play football<br/>play basketball<br/>Out[2]: 'Playing...'</span></pre><p id="b4d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们根据<strong class="is hj">依存倒置原则</strong>来解决问题。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a661" class="lo kd hi lk b fi lp lq l lr ls">class Football:<br/>    """Low-level module"""<br/>    def playing(self):<br/>        self.__play_football()</span><span id="8517" class="lo kd hi lk b fi lt lq l lr ls">    @staticmethod<br/>    def __play_football():<br/>        print('play football')</span><span id="33dd" class="lo kd hi lk b fi lt lq l lr ls">class Basketball:<br/>    """Low-level module"""<br/>    def playing(self):<br/>        self.__play_basketball()</span><span id="9c0b" class="lo kd hi lk b fi lt lq l lr ls">    @staticmethod<br/>    def __play_basketball():<br/>        print('play basketball')</span><span id="d35a" class="lo kd hi lk b fi lt lq l lr ls">class Playing:<br/>    """Abstract module"""<br/>    def __init__(self):<br/>        self.football = Football()<br/>        self.basketball = Basketball()</span><span id="42d6" class="lo kd hi lk b fi lt lq l lr ls">    def playing(self):<br/>        self.football.playing()<br/>        self.basketball.playing()</span><span id="5d3b" class="lo kd hi lk b fi lt lq l lr ls">class Sports:<br/>    """High-level module"""<br/>    def __init__(self):<br/>        self.__playing = Playing()<br/>    def plays(self):<br/>        return self.__playing.playing()</span></pre><p id="bdbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结果</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a933" class="lo kd hi lk b fi lp lq l lr ls">In [1]: sport = Sports()<br/>In [2]: sport.plays()<br/>play football<br/>play basketball</span></pre><h1 id="223b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">摘要</h1><p id="13b5" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在本文中，我们探索了<strong class="is hj">坚实的原则</strong>，目的是理解干净的设计。这些原则不是一条神奇的规则，但是它们提供了很好的指导方针，在过去的项目中已经被证明是有效的，并且将使我们的软件更有可能成功，并且是当今使用的最有影响力的面向对象指导方针之一。</p><h1 id="1952" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">参考</h1><ul class=""><li id="77d1" class="jo jp hi is b it la ix lb jb lu jf lv jj lw jn jt ju jv jw bi translated"><a class="ae lx" href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="noopener ugc nofollow" target="_blank">单一责任原则</a></li><li id="81ac" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lx" href="https://www.python.org/dev/peps/pep-3119/" rel="noopener ugc nofollow" target="_blank"> pep-3119 </a></li></ul></div></div>    
</body>
</html>