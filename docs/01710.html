<html>
<head>
<title>[Part I] : Breadth First Search Using Grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[第一部分]:使用网格进行广度优先搜索</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/part-i-breadth-first-search-using-grid-dc41a5f41663?source=collection_archive---------11-----------------------#2019-11-10">https://medium.com/analytics-vidhya/part-i-breadth-first-search-using-grid-dc41a5f41663?source=collection_archive---------11-----------------------#2019-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/974d3a9746a26d7acd848435386329e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpiUgQle_iuGRyYxlW1mGg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">网格中的路径查找</figcaption></figure><figure class="iu iv iw ix fd ij"><div class="bz dy l di"><div class="iy iz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">展示本页内容的视频</figcaption></figure><h2 id="7701" class="ja jb hi bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">简介:</h2><p id="d968" class="pw-post-body-paragraph jy jz hi ka b kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks hb bi translated">当谈到算法时，我们需要首先理解这些算法的应用是找到一个问题的解决方案，在这个问题中，给定一组数据，用户不需要手动递归来获取信息。这种数据的组织可以是不同的维度，并且可以导致分层结构的创建。如果这个数据是一维的，它可能是一个数组。该阵列可以在水平(X)或垂直(Y)轴上直观地表示。当它有两个维度时，我们可以把它画在图上，X轴和Y轴之间有一个关系。</p><p id="30f1" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">在第一部分中，我们将使用BFS在网格中寻找一条从一点到另一点的路径。为了尽可能简单，我们将不制作任何图形或节点结构。此外，我们将假设网格位于坐标系的正象限。我们将使用网格单元的位置(X，Y)使用K-最近邻算法来寻找邻居。然后，我们将使用广度优先搜索遍历，在所有方向平等地探索图形。</p><h2 id="a9af" class="ja jb hi bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">设置:</h2><p id="72aa" class="pw-post-body-paragraph jy jz hi ka b kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks hb bi translated">下图有一个由50x50个正方形组成的网格。每个都有一个单位尺寸，因此，我们有大约2500个网格单元。</p><p id="e89e" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">我们将使用BFS的概念来寻找从起点(红色)到终点(黄色)的路径。一旦我们应用了该算法，我们将回溯路径以突出显示它必须穿过的网格单元。</p><figure class="iu iv iw ix fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/dcd90e303022376efdeb9bf19946615b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXVJ8pHY-o1R0xPRk1Md3Q.png"/></div></div></figure><h2 id="1a38" class="ja jb hi bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">收集数据:</h2><p id="74a0" class="pw-post-body-paragraph jy jz hi ka b kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks hb bi translated">理解我们应该处理的数据是最重要的一步。我们知道网格单元的大小是:1x1单位。此外，我们知道有2500个这样的元素。这些从坐标系上的(0，0)开始，然后上升到(49，49)。假设我们在网格上有一个起点，它将由x和y坐标定义。现在，我们需要应用一个算法来开始遍历邻居，直到我们到达目的地。</p><h2 id="00f2" class="ja jb hi bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">遍历:</h2><p id="2d76" class="pw-post-body-paragraph jy jz hi ka b kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks hb bi translated">我们将使用BFS，这意味着我们需要在所有方向上同等地找到当前网格单元的邻居。为了简单起见，我们假设方向是:</p><p id="918f" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated"><strong class="ka hj">上、下、左、右</strong></p><p id="499e" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated"><strong class="ka hj">举例:</strong>要获取起始位置在坐标X = 15，Y = 47的邻居，可以使用下面的函数得到最近的四个邻居:</p><pre class="iu iv iw ix fd kz la lb lc aw ld bi"><span id="f409" class="ja jb hi la b fi le lf l lg lh">GameObject[] GetNeighbors(int X, int Y)<br/>{<br/>    return new GameObject[]<br/>    {<br/>        GameObject.Find($"{X}_{Y+1}"),<br/>        GameObject.Find($"{X}_{Y-1}"),<br/>        GameObject.Find($"{X - 1}_{Y}"),<br/>        GameObject.Find($"{X + 1}_{Y}")<br/>    };<br/>}</span></pre><p id="885d" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">这一点，我们遵循，直到我们没有到达目的地。我们所需要的是一个列表或“队列”,恰如其名。当我们获取邻居的数据时，该队列将包含这些数据。为了避免重复的元素，我们可以维护另一个队列，这有助于我们知道邻居是否被访问过。</p><p id="6a33" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">下图将有助于视觉表现，其中红点位于(15，47)。第一组绿点是第一组邻居。</p><figure class="iu iv iw ix fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/a4f2d6880a8403e442faa788b0ddb130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yh4PIZz7pX2Xhp32MgYIXA.png"/></div></div></figure><p id="16cf" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">然后，我们对每个邻居进行迭代，并为它们获得4个最近的邻居，依此类推。下图显示了我们在上面计算的最近的4个邻居:</p><figure class="iu iv iw ix fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/ffdead37ec4750551185707b89a2182b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8yGcIB1pDkWbMUuN4rfXg.png"/></div></div></figure><p id="0aa5" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">下面的函数演示了如何实现这一点:</p><pre class="iu iv iw ix fd kz la lb lc aw ld bi"><span id="62f5" class="ja jb hi la b fi le lf l lg lh">IEnumerator FindPath()<br/>{<br/>    while (neighbors.Count &gt; 0)<br/>    {<br/>        //there are neighbors and hence search for them:<br/>        current = neighbors[0];<br/>        neighbors.RemoveAt(0);<br/>        GameObject[] knn = GetNeighbors(current.transform.position.x, current.transform.position.z);<br/>        foreach (var t in knn)<br/>        {<br/>            if(!t)<br/>            {<br/>                continue;<br/>            }<br/>            if (!visitedList.Contains(t.name))<br/>            {<br/>                neighbors.Add(t);<br/>                visitedList.Add(t.name);<br/>            }<br/>            <br/>            t.GetComponent&lt;Renderer&gt;().material.color = Color.green;<br/>            <br/>            if (t.name == destination.name)<br/>            {<br/>                Debug.Log("Found the destinatination.");<br/>                neighbors.Clear();<br/>                break;<br/>            }<br/>        }<br/>        yield return null;<br/>    }<br/>}</span></pre><h2 id="9ac0" class="ja jb hi bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">追溯到:</h2><p id="e74b" class="pw-post-body-paragraph jy jz hi ka b kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks hb bi translated">现在我们知道，我们可以使用这个方法从(X1，Y1)到(Xn，Yn)，并可以在到达目的点时从循环中断开。我们需要在当前点和它之间保持一个映射。这样，对于我们访问的每个邻居，我们都有我们来自的网格单元的映射。这有助于遍历所有的映射和绘制路径。这可以在下图中看到:</p><figure class="iu iv iw ix fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/974d3a9746a26d7acd848435386329e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpiUgQle_iuGRyYxlW1mGg.png"/></div></div></figure><p id="a643" class="pw-post-body-paragraph jy jz hi ka b kb kt kd ke kf ku kh ki jl kv kk kl jp kw kn ko jt kx kq kr ks hb bi translated">需要添加以下截取的代码来存储映射数据:</p><pre class="iu iv iw ix fd kz la lb lc aw ld bi"><span id="5868" class="ja jb hi la b fi le lf l lg lh">if(!traceBackMap.ContainsKey(t))<br/>{<br/>  traceBackMap.Add(t, current);<br/>}</span></pre><h2 id="70b8" class="ja jb hi bd jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">结论:</h2><p id="c382" class="pw-post-body-paragraph jy jz hi ka b kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks hb bi translated">BFS系列的第一部分到此结束。我希望大家清楚一些非常基本的代码片段如何转化为算法，并有助于轻松找到解决方案。在接下来的部分中，我们将看看如何增强对邻居的搜索，我们如何才能有一个带权重的图，即帮助定义路径的成本是容易还是困难或更短/更长。优化算法。我们还将实现一些其他的路径查找或图形遍历算法。</p></div></div>    
</body>
</html>