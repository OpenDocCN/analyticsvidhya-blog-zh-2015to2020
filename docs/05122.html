<html>
<head>
<title>This algorithm could solve NP Complete problem in P time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">该算法可以在P时间内解决NP完全问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/this-algorithm-could-solve-np-complete-problem-in-p-time-6857b40d6586?source=collection_archive---------29-----------------------#2020-04-11">https://medium.com/analytics-vidhya/this-algorithm-could-solve-np-complete-problem-in-p-time-6857b40d6586?source=collection_archive---------29-----------------------#2020-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/26191d1abfe3f55c59360c86bfcaef5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*83bJI54q3kclADyMfBnLng.jpeg"/></div></figure><div class=""/><p id="5dfd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇文章是我对算法以及它们如何与纯数学的经典部分相关联的工作的结果，也是我对计算的数学理论的研究。以下想法代表一个假设的思维实验，而不是一个真正的计算机程序。</p><h2 id="3336" class="jl jm hp bd jn jo jp jq jr js jt ju jv ix jw jx jy jb jz ka kb jf kc kd ke kf bi translated">计算机病毒的计算效率是多少？</h2><p id="6fee" class="pw-post-body-paragraph im in hp io b ip kg ir is it kh iv iw ix ki iz ja jb kj jd je jf kk jh ji jj hb bi translated">为了这个思想实验的目的，想象下面这个假的计算机病毒:每一台被这个“病毒”感染的计算机，这台计算机每T秒就会通过互联网感染另一台计算机一次。</p><p id="ae77" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据定义，让我们取T=1的单位。然后我们将构建一个假的“命令与控制服务器”(C&amp;C服务器)(对于这个思想实验)，由C&amp;C服务器+所有被感染的计算机组成的系统构成一个“单机”。</p><p id="03aa" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，假设我们用这种病毒感染了一台计算机，比如我们感染了C&amp;C服务器。那么每单位时间t，被感染的计算机的数量将加倍。在总时间段<em class="jk"> t </em>过去之后，将会有2^t感染的计算机。这意味着“病毒”以所谓的“指数效率”传播</p><p id="3367" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">出于所有实际目的，可以假设从时间<em class="jk"> t=0 </em>开始，整个系统的计算能力随时间呈指数增长。这是整个算法的基础，也是为什么这是一个思想实验而不是真正的程序。</p><h2 id="7782" class="jl jm hp bd jn jo jp jq jr js jt ju jv ix jw jx jy jb jz ka kb jf kc kd ke kf bi translated">该算法</h2><p id="3e27" class="pw-post-body-paragraph im in hp io b ip kg ir is it kh iv iw ix ki iz ja jb kj jd je jf kk jh ji jj hb bi translated">n P完全理论中的一个众所周知的结果是，如果存在一个算法可以在P时间内解决任何单个NP完全问题，那么这个算法也可以用来解决P时间内NP完全问题族中的任何其他问题。</p><p id="c14f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基本思想是利用随时间呈指数增长的实际上无限量的计算机能力。让我们以NP完全问题为例，即所谓的SAT问题，这意味着<a class="ae kl" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" rel="noopener ugc nofollow" target="_blank">布尔可满足性问题</a>，可以表述如下:</p><p id="07cb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> <em class="jk"> SAT问题</em> </strong> <em class="jk">:决定给定布尔公式的变量是否可以一致地被值TRUE或FALSE替换，使得公式</em> <a class="ae kl" href="https://en.wikipedia.org/wiki/Validity_(logic)" rel="noopener ugc nofollow" target="_blank"> <em class="jk">的计算结果为TRUE </em> </a></p><p id="1a67" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">设<strong class="io hq"> B </strong>为任意布尔公式，设<strong class="io hq"> N </strong>为<strong class="io hq"> B </strong>中变量的个数</p><p id="d661" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1 —使用来自c服务器的预定义指令，以指数速度及时感染2^的计算机</p><p id="7c55" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2—经过预定时间后，预定义的指令执行其“有效载荷”，包括检查SAT问题</p><p id="0c3d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3-如果在任何时候，当检查<strong class="io hq"> B </strong>时，被感染的计算机之一得到答案“真”,那么它将把这个消息发送回C &amp; C服务器</p><p id="26e6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后给定任何涉及<strong class="io hq"> N </strong>变量的布尔表达式<strong class="io hq"> B </strong>，我可以用这个算法来解决布尔可满足性问题，平均来说，比在有限的计算机网络上运行的普通程序要快得多。</p><h2 id="63de" class="jl jm hp bd jn jo jp jq jr js jt ju jv ix jw jx jy jb jz ka kb jf kc kd ke kf bi translated">理论计算效率</h2><p id="d9f7" class="pw-post-body-paragraph im in hp io b ip kg ir is it kh iv iw ix ki iz ja jb kj jd je jf kk jh ji jj hb bi translated">在问题无解的情况下，C&amp;C服务器将花费最长时间得出该问题无法解决的结论；然而，如果<strong class="io hq"> B </strong>是可解的(出于论证的目的，通过假设)，那么每台被感染的计算机将向C &amp; C发送真实消息的顺序是完全随机的。有时你会非常幸运，算法会很快完成，而其他时候，你会很不幸，这基本上会花费最坏情况下的时间，这与如果<strong class="io hq"> B </strong>不可解所花费的时间相同。</p><p id="0f63" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">试探性地，这些类型的论证表明，对应于计算能力的指数增长，理论计算效率可能存在对数节省，并且该算法的效率将为O( <strong class="io hq"> N </strong> log <strong class="io hq"> N </strong>)。我现在还没有严格证明这个结果。</p></div></div>    
</body>
</html>