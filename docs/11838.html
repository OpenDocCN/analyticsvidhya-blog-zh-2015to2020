<html>
<head>
<title>Programming 01-Three Sums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程 01-三个和</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/programming-01-three-sums-46e13d4c3b9b?source=collection_archive---------22-----------------------#2020-12-20">https://medium.com/analytics-vidhya/programming-01-three-sums-46e13d4c3b9b?source=collection_archive---------22-----------------------#2020-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们深入一个惊人的编程问题，以提高您解决问题的技能。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="e5cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我猜你是:)</p><p id="4ae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是-</p><p id="1a2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个由<em class="jo"> n </em>个整数组成的数组<code class="du jk jl jm jn b">nums</code>，在<code class="du jk jl jm jn b">nums</code>中是否有元素<em class="jo"> a </em>、<em class="jo"> b </em>、<em class="jo"> c </em>使得<em class="jo">a</em>+<em class="jo">b</em>+<em class="jo">c</em>= 0？找出数组中所有唯一的三元组，其和为零。</p><p id="f4f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，解决方案集不得包含重复的三元组。</p><p id="6e43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 1: </strong></p><pre class="jd je jf jg fd jp jn jq jr aw js bi"><span id="910b" class="jt ju hi jn b fi jv jw l jx jy"><strong class="jn hj">Input:</strong> nums = [-1,0,1,2,-1,-4]<br/><strong class="jn hj">Output:</strong> [[-1,-1,2],[-1,0,1]]</span></pre><p id="6d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例二:</strong></p><pre class="jd je jf jg fd jp jn jq jr aw js bi"><span id="f76e" class="jt ju hi jn b fi jv jw l jx jy"><strong class="jn hj">Input:</strong> nums = []<br/><strong class="jn hj">Output:</strong> []</span></pre><p id="de44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 3: </strong></p><pre class="jd je jf jg fd jp jn jq jr aw js bi"><span id="d5c1" class="jt ju hi jn b fi jv jw l jx jy"><strong class="jn hj">Input:</strong> nums = [0]<br/><strong class="jn hj">Output:</strong> []</span></pre><p id="ef99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束:</strong></p><ul class=""><li id="3a66" class="jz ka hi ih b ii ij im in iq kb iu kc iy kd jc ke kf kg kh bi translated"><code class="du jk jl jm jn b">0 &lt;= nums.length &lt;= 3000</code></li><li id="1d54" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc ke kf kg kh bi translated"><code class="du jk jl jm jn b">-100000 &lt;= nums[i] &lt;= 100000</code></li></ul><p id="eb7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你直接进入解决方案之前，仔细观察这个问题。</p><p id="255b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您错过了这个问题，您可能会错过正确答案-“数组中唯一的三个一组”。</p><p id="2f00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在直接编码之前，我更喜欢通过写下可能的解决方法来解决问题，当然也可以试运行。</p><ol class=""><li id="e9c0" class="jz ka hi ih b ii ij im in iq kb iu kc iy kd jc kn kf kg kh bi translated">让我们先对数组进行排序。</li><li id="6d95" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc kn kf kg kh bi translated">排序后，我们可以保持向前和向后两个指针，向前从索引 i+1 开始，I 从 0 开始，向后从数组的末尾开始。</li><li id="6906" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc kn kf kg kh bi translated">然后，只有当所有三个元素都是唯一的，我们才能找到第 I 个索引、前向元素和后向元素的总和，并检查总和是否等于零。</li><li id="0eb1" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc kn kf kg kh bi translated">如果总数等于零，则在答案后面加上三元组，然后向前递增，向后递减。</li><li id="31ce" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc kn kf kg kh bi translated">如果总数为负，则向前递增，如果总数为正，则向后递减。</li><li id="4dc8" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc kn kf kg kh bi translated">在通过条件前进<backward increment="" i="" and="" repeat="" the="" process=""/></li></ol><pre class="jd je jf jg fd jp jn jq jr aw js bi"><span id="0387" class="jt ju hi jn b fi jv jw l jx jy">class Solution:<br/>    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:<br/>        <br/>        ans=[]<br/>        nums.sort()<br/>        <br/>        length=len(nums)<br/>        <br/>        for i in range(length-2):<br/>            if (i&gt;0 and nums[i]==nums[i-1]):<br/>                continue<br/>            l=i+1;<br/>            r=length-1<br/>            <br/>            while(l&lt;r):<br/>                total=nums[i]+nums[l]+nums[r];<br/>                if(total&lt;0):<br/>                    l=l+1<br/>                elif total&gt;0:<br/>                    r=r-1<br/>                else:<br/>                    ans.append([nums[i],nums[l],nums[r]])<br/>                    while l&lt;r and nums[l]==nums[l+1]:<br/>                        l=l+1<br/>                    while l&lt;r and nums[r]==nums[r-1]:<br/>                        r=r-1<br/>                    l=l+1<br/>                    r=r-1<br/>        return ans</span></pre><p id="091b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">The Time Complexity is O(n log n)+O(n²)=O(n²). Note here O(n log n) is used for the<strong class="ih hj">遍历整个长度后，排序功能</strong>和 O(n)用于<strong class="ih hj">两个循环</strong>。由于 O(n)比 O(n log n)更占优势，所以时间复杂度变成了<strong class="ih hj"> O(n ) </strong>。</p><p id="708b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们创建了一个名为<strong class="ih hj"> ans </strong>的链表，所以辅助空间复杂度为<strong class="ih hj"> O(n) </strong>。</p><p id="108d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！！！</p></div></div>    
</body>
</html>