<html>
<head>
<title>Ensemble methods: Using XGBoost model and API to enable the Colaboratory GPU</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成方法:使用XGBoost模型和API实现协同工作的GPU</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ensemble-methods-using-xgboost-model-and-api-to-enable-the-colaboratory-gpu-2da67fcc8281?source=collection_archive---------17-----------------------#2019-10-29">https://medium.com/analytics-vidhya/ensemble-methods-using-xgboost-model-and-api-to-enable-the-colaboratory-gpu-2da67fcc8281?source=collection_archive---------17-----------------------#2019-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/67bc1135329949289d0aad4bf44e2fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*YA635Xtf6KmlbT9o"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图1</figcaption></figure><h1 id="c41d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">提升和问题激励</h1><p id="042f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> Boosting </strong>(原称假设提升)是指任何可以将几个弱学习者组合成一个强学习者的集成方法。大多数boosting方法的一般思想是顺序训练预测器，每个预测器都试图纠正其前任。XGBoost是梯度提升决策树的实现，旨在提高速度和性能。</p><p id="4bb0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">问题动机是美国的个人收入。数据(<a class="ae kr" href="http://archive.ics.uci.edu/ml/datasets/Adult" rel="noopener ugc nofollow" target="_blank">加州大学欧文分校网站</a> ) <strong class="jq hj"> </strong>来自1994年的人口普查，包含个人的婚姻状况、年龄、工作类型等信息。目标栏(我们要预测的)是个人年收入是小于等于50k，还是大于50k。我的目标是使用XGBoost API进行机器学习工作流，因此使用GPU我可以以更快/更有效的方式实现良好的性能。</p><h1 id="5432" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">管道描述</strong></h1><p id="acef" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，我们用熊猫获取数据，对她进行处理。因为我的目标是关注XGBoost API的使用，所以我做了一个简单的管道。我在dataframe中观察到的一个问题是未知数据被标上了问号(`？`).所以我删除了包含这些未知数据的行。除此之外，输入data.info()我们可以看到一些分类列，所以我使用pd来处理它们。pandas的categorial()，它在分类列中应用序号编码。</p><p id="9f08" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">之后，我使用<em class="ks"> train_test_split </em>分离出训练/验证和测试数据集，并创建了一个DMatrix，因为我们使用的是XGboost API。DMatrix最初对数据进行排序，以便在构建树时针对XGBoost进行优化，这使得算法更加高效。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/c1a1e9cf90f2ca024101c5b5acede008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*esfCPNtknHbBGKrk"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图2</figcaption></figure><p id="2711" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后，我用超参数创建了一个字典，并进行超参数组合，在XGBoost API的交叉验证中将字典作为参数传递。超参数包括XGBoost模型超参数和其他两个支持GPU使用的参数:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/b2c0c02a5d7e8894a8f8afcc3e6c4998.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/0*H0v60H7OpIRPXqVn"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图3</figcaption></figure><p id="dead" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">之后，我训练了模型，进行了预测，并计算了准确度，在将从预测中获得的概率转换为模型的类别标签后，准确度约为0.86。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/580d1c32e9ddd73a39045b0ffa0fe560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/0*_onAIbRUGPr9uuSL"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图4</figcaption></figure><h1 id="d67d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="53ac" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">用pandas <strong class="jq hj"> time </strong>库测量训练和交叉验证部分花费的时间，我可以意识到使用XGBoost API确实提高了速度，因为使用GPU花费的时间是26.8秒，而使用scikit learn(CPU)花费的时间是1分40秒。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es la"><img src="../Images/cd871cc65d82754540c684cd701d0c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2_M1wimRIa4-LWaz"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图5</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lf"><img src="../Images/55b63c81059da5d9e0d0c8b45ef8e663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*89H8QGBMldo8w33U"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图6</figcaption></figure><p id="29c9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，您可以使用XGBoost模型API加快启用GPU的训练时间。请注意，还有许多方法可以提高模型性能(比如我们之前计算的精确度)，但这不是我们这里的重点。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="4de5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">结束。</strong></p></div></div>    
</body>
</html>