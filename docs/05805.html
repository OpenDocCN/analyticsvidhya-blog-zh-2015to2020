<html>
<head>
<title>Object-Oriented &amp; Functional JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象和函数式JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-oriented-functional-javascript-168069783fcc?source=collection_archive---------36-----------------------#2020-05-02">https://medium.com/analytics-vidhya/object-oriented-functional-javascript-168069783fcc?source=collection_archive---------36-----------------------#2020-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="3730" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">JavaScript学习的第6天——里程碑1(第1周)</h1><p id="b253" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这里我们已经描述了一个流行的和必须学习的编程概念，面向对象编程。除此之外，我们还关注了另一种简单方便的编程方法，称为函数式编程。这两种方法都将与JavaScript一起讨论。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/b3e3615063cb158cd807abc97a9dda2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDWA9wg7SftGxPIpOJCBYQ.png"/></div></div></figure></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h2 id="1d39" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated"><strong class="ak"> <em class="li"> 1。OOP是什么？顺利解说</em> </strong></h2><p id="6b64" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated"><span class="l lk ll lm bm ln lo lp lq lr di"> O </span>面向对象编程(OOP)是一种流行的编程模式，它使用现实世界中的实体作为对象以及这些对象的蓝图，通常称为类。记住，OOP不是一种编程语言。它是编程语言遵循的一种技术或模式。还有其他编程模式，例如-</p><p id="7f19" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">I)结构化程序设计</p><p id="8bc9" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">ii)面向过程的编程(POP)</p><p id="7193" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">iii)功能编程等。</p><p id="7862" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">为什么要OOP？</em>T9】</strong></p><p id="323f" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">OOP使得代码维护更加容易，我们不需要一次又一次地重写相同的代码。根据需要多次重用代码块是OOP的强大特性之一。OOP提供了一个关于代码模块的透明概念，并且通过隐藏内部实现来保护代码库。数据和代码可以封装到一个模块中，就像药品中的胶囊一样，这将节省大量的复杂性，而没有OOP是不可能的。</p><h2 id="9038" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated"><strong class="ak"> <em class="li"> 2。OOP的三颗“宝石”…核心概念</em> </strong></h2><p id="e457" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">OP提供了许多丰富编程和软件开发的特性，但是有一些(如前所述)必须引起注意。我们称它们为面向对象编程的<strong class="jf hj">‘宝石’</strong>。</p><p id="5fe0" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx"> OOP核心‘宝石’:</em></strong></p><p id="299e" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">OOP支持以下特性来简化软件开发-</p><ul class=""><li id="f198" class="ly lz hi jf b jg ls jk lt jo ma js mb jw mc ka md me mf mg bi translated">对象(真实世界的实体)</li><li id="aa96" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">类别(对象的蓝图-相同的设计，多个建筑)</li><li id="97ba" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">继承(父子/父子关系)</li><li id="2c77" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">多态性(相同的方法，多种能力)</li><li id="dacb" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">抽象(隐藏内部实现)</li><li id="14c8" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">封装(将数据和代码包装在一起)</li></ul><p id="7ef7" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">这里简要讨论了其中的三种</p><p id="0687" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx"> i)继承</em> </strong></p><p id="873b" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">当一个对象获得一个父对象的所有属性和行为时，这就是所谓的继承。它提供了代码的可重用性。它用于实现运行时多态性。</p><p id="85f5" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx"> ii)抽象</em> </strong></p><p id="597e" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">隐藏内部细节和显示功能被称为抽象。比如电话，我们不知道内部处理。</p><p id="d19a" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx"> iii)封装</em> </strong></p><p id="0569" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">将代码和数据绑定(或包装)到一个单元中称为封装。比如一个胶囊，它包裹着不同的药物。</p><h2 id="9033" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated"><strong class="ak"> <em class="li"> 3。通过原型链接继承属性</em>T3】</strong></h2><p id="cbc1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">除了每个对象，<strong class="jf hj"> [[Prototype]] </strong>属性都是从构造函数中创建的。prototype属性指向另一个对象或者为空。</p><p id="f8a4" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">在下面的例子中，我们将看到<strong class="jf hj">矩形</strong>的原型属性被设置为<strong class="jf hj">形状</strong>，它能够访问<strong class="jf hj">形状</strong>中的所有属性。如果在对象中找不到属性，比如在<strong class="jf hj">矩形</strong>中找不到<strong class="jf hj">名称</strong>属性，JavaScript将自动从该对象的原型<strong class="jf hj">形状</strong>中获取该属性。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mm"><img src="../Images/755a7d12b7f4389ff970dcfc65edd842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeIx28Gdzb_B4wEM2ehW4Q.png"/></div></div></figure><h2 id="d198" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated"><strong class="ak"> <em class="li"> 4。定义类中的方法</em> </strong></h2><p id="8dab" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">一个类的对象的实例总是需要通过首先访问原型来访问类内部的方法。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mn"><img src="../Images/b8545ffa95dca8bc00f9341ae2d50330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_16vCfgG58iRusXG8UOPw.png"/></div></div></figure><p id="1c68" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">在上面的代码中-</p><ul class=""><li id="2c2c" class="ly lz hi jf b jg ls jk lt jo ma js mb jw mc ka md me mf mg bi translated">在构造函数之外定义了<strong class="jf hj"> getMarks() </strong>函数</li><li id="0f02" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">所有这样的方法都存储在<strong class="jf hj">学生</strong>类的原型对象中。</li><li id="9f79" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">因此，一个新对象，比如<strong class="jf hj"> studentObj </strong>，可以访问该类中定义的所有方法。</li><li id="ac1e" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">当被<strong class="jf hj"> studentObj </strong>调用时，方法<strong class="jf hj"> getMarks() </strong>取自student.prototype。</li></ul><h2 id="740f" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">5.包装</h2><p id="5400" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">当每个对象在一个类中保持其状态<strong class="jf hj">私有</strong>时，就实现了封装。其他对象不能直接访问该状态。相反，它们只能调用一系列公共函数，即所谓的方法。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mo"><img src="../Images/c80b3e4862bd8c74d36b2507ed09c344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8bnazkAO8lavt9cYz8Elw.png"/></div></div></figure><p id="42e3" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">这里猫的“状态”是私人变量<strong class="jf hj">情绪</strong>、<strong class="jf hj">饥饿</strong>和<strong class="jf hj">能量</strong>。它还有一个<strong class="jf hj">私有</strong>方法<strong class="jf hj">喵()</strong>。它可以随时调用它，其他类不能告诉猫什么时候喵喵叫。</p><p id="5c9a" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">它们能做什么是在公共方法<strong class="jf hj"> sleep() </strong>、<strong class="jf hj"> play() </strong>和<strong class="jf hj"> feed() </strong>中定义的。它们中的每一个都以某种方式修改内部状态，并可能调用<strong class="jf hj"> meow() </strong>。这样，<strong class="jf hj">私有</strong>状态和<strong class="jf hj">公共</strong>方法之间的绑定就完成了。</p><p id="8306" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">这就是封装。</p><p id="b610" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> 6。抽象</strong></p><p id="e236" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi lj translated">这个机制隐藏了代码的内部实现细节。它只表达与其他对象相关的操作。</p><p id="f5c9" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">这里值得举一个现实生活中的例子——</em></strong></p><p id="61da" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">我们只用几个按钮就能和手机互动。引擎盖下到底发生了什么？我们甚至不需要知道——实现细节是隐藏的。我们只需要知道一组简短的动作。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mp"><img src="../Images/1d25ce78add40df4aff1da1172ee23a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FZickK7a5gVQuPqsbkkng.png"/></div></div></figure><h2 id="b56f" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">7.遗产</h2><p id="4a66" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">对象往往非常相似。他们有共同的逻辑。但它们并不完全相同。那么我们如何重用通用的逻辑，将独特的逻辑提取到单独的类中呢？实现这一点的方法之一是<strong class="jf hj">继承</strong>。</p><p id="5756" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">这意味着我们通过从父类或基类派生来创建子类。这样，我们就形成了一个<strong class="jf hj">层级</strong>。也可以称为<strong class="jf hj">是——一种关系</strong>。使用<strong class="jf hj"> super </strong>关键字访问父类。</p><p id="ba56" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">子类重用父类的所有字段和方法，并且可以实现自己的属性。</p><p id="5836" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"><em class="lx">——</em>——</strong></p><p id="b2f0" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">这里的<strong class="jf hj">私教</strong>和<strong class="jf hj">公办教师</strong>都是俗称的<strong class="jf hj">老师、</strong>，无论是<strong class="jf hj">老师</strong>还是<strong class="jf hj">学生</strong>，他们都是<strong class="jf hj">人。</strong></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mo"><img src="../Images/d5ec0f27caf7621e96ca323a1379e77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeljjejZN1YP50IaPxYoVQ.png"/></div></div></figure><h2 id="1ce3" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">8。调用堆栈</h2><p id="14e3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">一个后进先出(LIFO)过程，通过它浏览器引擎执行已经构建的代码。就像我们在堆栈中所做的一样，JavaScript中的方法或函数调用在我们调用它们时被推到堆栈的顶部，对于函数返回情况则相反，当执行完成时，它首先弹出。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mq"><img src="../Images/74a805dabadf7fa181ab80472fab22a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWYfoUc_qQhFOMIIvOT9RA.jpeg"/></div></div></figure><p id="c20e" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">在上面的例子中，<strong class="jf hj"> printSquare() </strong>方法将在主程序开始执行后立即被调用。这就是为什么浏览器引擎检测到main()在堆栈的第一个位置。在调用了<strong class="jf hj"> printSquare() </strong>之后，引擎会进入函数内部，并执行<strong class="jf hj"> square() </strong>。查看<strong class="jf hj"> square() </strong>函数内部，得到<strong class="jf hj"> multiply() </strong>函数。一步一步…酷吧？</p><p id="b925" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj">main()</strong>→<strong class="jf hj">print square()→square()→multiply()</strong></p><p id="ed0a" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">现在弹出开始。当<strong class="jf hj"> multiply() </strong>的执行完成时，它首先从堆栈中弹出，而不管其他调用的函数。然后<strong class="jf hj"> square() </strong>，然后<strong class="jf hj"> printSquare()，</strong>最后主程序执行完毕。</p><p id="b9e3" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj">乘()→方()→印方()→主()</strong></p><h2 id="8926" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">9.事件循环</h2><p id="813b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated">事件循环是指等待队列同步接收消息的过程。</p><p id="a1eb" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">事件循环移入的增量称为“滴答”，每次“滴答”时，它检查调用堆栈是否为空，如果是，它将事件队列中的top函数添加到调用堆栈中并执行它。一旦它处理完这个函数，它就再次开始计时。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mr"><img src="../Images/51944c4e735a7ca08777665027e592b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4R9bgxOlHdpf3wj-g_QqUg.jpeg"/></div></div></figure><p id="d534" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">事件循环到底做什么:</em> </strong></p><ul class=""><li id="73fa" class="ly lz hi jf b jg ls jk lt jo ma js mb jw mc ka md me mf mg bi translated">等待和调度事件的代码</li><li id="87f1" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">处理其环境的事件</li><li id="1b5b" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">监控调用堆栈和回调队列</li><li id="8d4c" class="ly lz hi jf b jg mh jk mi jo mj js mk jw ml ka md me mf mg bi translated">将异步代码分解成节拍</li></ul><h2 id="2fcf" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">10.函数式编程</h2><p id="f63b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi lj translated"><span class="l lk ll lm bm ln lo lp lq lr di"> F </span>函数式编程是一种以函数为王的编程范式或编码风格。它以一种简单的方式组织你的代码，并保持代码结构的整洁和简单。函数式编程更安全，更易于调试或维护。</p><p id="c6cb" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">为什么要用函数式JavaScript？<br/> </em> </strong>有时候面向对象的JS会变得棘手(原型？这个？！？).总是没有必要使用面向对象的方法来完成事情。另一方面，函数可以根据需要多次重用。我们不需要像想的那样修改整个类来改变一点代码库。函数式编程使用纯函数来解决问题，这种方法使调试变得更容易。它也有一个固定的社区。</p><p id="8857" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">非功能方法:</em> </strong></p><blockquote class="ms mt mu"><p id="90af" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">var name = " Rahul<br/> var greeting = "嗨，我是"；</p><p id="7d5f" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">console.log(问候语+姓名)；//“嗨，我是Rahul”</p></blockquote><p id="6c97" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">功能方法:</em> </strong></p><blockquote class="ms mt mu"><p id="ebf6" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">函数greet(name) { <br/>返回“你好，我是”+name；<br/> } <br/>问候(“拉胡尔”)；//“嗨，我是Rahul”</p></blockquote><p id="52e0" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">使用高阶函数:</em> </strong></p><p id="752f" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">功能可以只是输入/输出。但是在函数式编程中，我们能做的比我们想象的要多得多。</p><blockquote class="ms mt mu"><p id="a3bb" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">函数makeAdjectifier(形容词){ <br/>返回函数(字符串){ <br/>返回形容词+ " " +字符串；<br/>}；<br/>}<br/>var cooli fier = make adjectifier(" cool ")；<br/>冷却器(“天气”)；//“凉爽的天气”</p></blockquote><p id="5df6" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">功能方法不迭代</em> </strong></p><p id="0295" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">函数式编程忽略了迭代，如(loops - for，while，do-while，for…in，for…of等。)、void函数、对象突变、数组mutator方法、map mutator方法、set mutator方法。相反，它使用<strong class="jf hj">贴图</strong>，<strong class="jf hj">减少</strong>，<strong class="jf hj">滤镜</strong>。这里有一个有趣的图片来解释这一点。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es my"><img src="../Images/f55f95fe615b02978b226d217b0b9d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*h9Knqn-lOQoyh6AAP34iYQ.png"/></div></figure><p id="a726" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj"> <em class="lx">避免可变性</em> </strong></p><p id="038a" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">函数式编程使用不可变的数据。突变和免疫的例子如下。</p><p id="e5c3" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj">突变(不好！):</strong></p><blockquote class="ms mt mu"><p id="e976" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">var rooms = ["H1 "，" H2 "，" H3]]；</p><p id="941d" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">房间[2]=“H4”；<br/>客房；//[《H1》、《H2》、《H4》]</p></blockquote><p id="a85a" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated"><strong class="jf hj">没有突变(好！):</strong></p><blockquote class="ms mt mu"><p id="3318" class="jd je lx jf b jg ls ji jj jk lt jm jn mv lu jq jr mw lv ju jv mx lw jy jz ka hb bi translated">var rooms = ["H1 "，" H2 "，" H3]]；<br/>var newRooms = rooms . map(function(RM){<br/>if(RM = = = " H3 "){<br/>返回" H4 "；<br/> } else { <br/>返回RM；<br/>}<br/>})；新房间；=&gt;【《H1》、《H2》、《H4》】客房；//[《H1》、《H2》、《H3》]</p></blockquote><p id="cce7" class="pw-post-body-paragraph jd je hi jf b jg ls ji jj jk lt jm jn jo lu jq jr js lv ju jv jw lw jy jz ka hb bi translated">今天到此为止。谢谢:)</p></div></div>    
</body>
</html>