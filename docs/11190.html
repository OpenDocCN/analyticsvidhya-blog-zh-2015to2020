<html>
<head>
<title>Simplifying Object Creation With The Builder Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用构建器模式简化对象创建</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simplifying-object-creation-with-the-builder-pattern-23ff93eb968a?source=collection_archive---------6-----------------------#2020-11-22">https://medium.com/analytics-vidhya/simplifying-object-creation-with-the-builder-pattern-23ff93eb968a?source=collection_archive---------6-----------------------#2020-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f2ec2caf698c3f7826c49df674bd8e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNVXwxPae3XUCdV3hE_tzA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">如果你构建它…他们会更容易阅读你的代码。</figcaption></figure><p id="b812" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">设计模式是解决软件架构中常见问题的可重用且广为接受的策略。在这篇文章中，我将谈论<strong class="iw hj">构建器模式</strong>。作为<a class="ae js" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">四人组</a>设计模式之一，构建器模式可以用于封装和控制复杂对象的创建，通过实现一个单独的、具体的构建器类来委托对象创建，而不是试图通过复杂的构造器直接构建。遵循这种模式不仅可以更容易地实例化复杂的类，还可以生成更易于阅读和理解的代码——潜在地防止了错误。</p><p id="4f1b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将展示一个我最近遇到的问题的例子，由于一些要求需要额外的、可选的构造函数参数，我不得不创建一个相当复杂的对象的实例。</p><h2 id="8ed9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">例子</h2><p id="274b" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">这里有一个事件类，它有三个必填字段和一些可选字段，用于控制事件的可重试性:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="e39d" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">public class </strong>Event {<br/>  <strong class="ky hj">private final </strong>String <strong class="ky hj">type</strong>;<br/>  <strong class="ky hj">private final </strong>String <strong class="ky hj">sender</strong>;<br/>  <strong class="ky hj">private final </strong>Map&lt;String, Object&gt; <strong class="ky hj">payload</strong>;<br/><br/>  <strong class="ky hj">private </strong>Date <strong class="ky hj">created</strong>;<br/>  <strong class="ky hj">private boolean retryable</strong>;<br/>  <strong class="ky hj">private int maxRetries</strong>;<br/>  <strong class="ky hj">private int attemptCount</strong>;<br/>  <strong class="ky hj">private </strong>Date <strong class="ky hj">lastUpdated</strong>;<br/><br/>  <strong class="ky hj">public </strong>Event(String type, String sender, Map&lt;String, Object&gt; payload) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">type </strong>= type;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">sender </strong>= sender;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">payload </strong>= payload;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">created </strong>= <strong class="ky hj">new </strong>Date();<br/>  }<br/>  <br/>  // additional methods omitted for example<br/>  <br/>}</span></pre><p id="b3de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个事件类中，我们需要在构造函数中设置三个<strong class="iw hj"> final </strong>字段。我们的可选字段在这里帮助我们控制事件的可重试性。</p><p id="ce54" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以将它们添加到新的构造函数中，就像这样:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="a2b3" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">public </strong>Event(String type, String sender, Map&lt;String, Object&gt; payload, <strong class="ky hj">boolean </strong>retryable,<br/>    <strong class="ky hj">int </strong>maxRetries, <strong class="ky hj">int </strong>attemptCount, Date lastUpdated) {<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">type </strong>= type;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">sender </strong>= sender;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">payload </strong>= payload;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">created </strong>= <strong class="ky hj">new </strong>Date();<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">retryable </strong>= retryable;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">maxRetries </strong>= maxRetries;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">attemptCount </strong>= attemptCount;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">lastUpdated </strong>= lastUpdated;<br/>}</span></pre><p id="5bac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这开始增加复杂性，使我们的代码可读性更差，如果我们需要更多的控制机制来传递给事件，可能会变得混乱。另一个选择是添加一些 setter 方法来设置我们的 Event 类上的可选 retry 字段。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="385b" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">public void </strong>setRetryable(<strong class="ky hj">boolean </strong>retryable) {<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">retryable </strong>= retryable;<br/>}<br/><br/><strong class="ky hj">public void </strong>setMaxRetries(<strong class="ky hj">int </strong>maxRetries) {<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">maxRetries </strong>= maxRetries;<br/>}<br/><br/><strong class="ky hj">public void </strong>setAttemptCount(<strong class="ky hj">int </strong>attemptCount) {<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">attemptCount </strong>= attemptCount;<br/>}<br/><br/><strong class="ky hj">public void </strong>setLastUpdated(Date lastUpdated) {<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">lastUpdated </strong>= lastUpdated;<br/>}</span></pre><p id="1e0e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用 setter 方法，如果我们将来添加更多的字段，我们需要记住为可选字段调用每个 setter 方法。忘记一个可能会在我们的实现中创建一个没有某种空检查的运行时异常。此外，这可能会使事件处于构造函数和 setter 方法类之间的部分状态，这在多线程情况下可能会有进一步的影响。那么，做什么呢？</p><p id="0c06" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输入构建器类。这里，我们在事件类中创建了一个嵌套的公共构建器类。我们在我们的事件类中创建它，所以我们不必偏离我们的代码太远，将来，当改变事件对象的接口时，这将允许您或其他开发人员更容易地记住更新构建器。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="5288" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">public class </strong>Event {<br/><br/>  <strong class="ky hj">private final </strong>String <strong class="ky hj">type</strong>;<br/>  <strong class="ky hj">private final </strong>String <strong class="ky hj">sender</strong>;<br/>  <strong class="ky hj">private final </strong>Map&lt;String, Object&gt; <strong class="ky hj">payload</strong>;<br/><br/>  <strong class="ky hj">private </strong>Date <strong class="ky hj">created</strong>;<br/>  <strong class="ky hj">private boolean retryable</strong>;<br/>  <strong class="ky hj">private int maxRetries</strong>;<br/>  <strong class="ky hj">private int attemptCount</strong>;<br/>  <strong class="ky hj">private </strong>Date <strong class="ky hj">lastUpdated</strong>;<br/><br/>  <strong class="ky hj">private </strong>Event(String type, String sender, Map&lt;String, Object&gt; payload) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">type </strong>= type;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">sender </strong>= sender;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">payload </strong>= payload;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">created </strong>= <strong class="ky hj">new </strong>Date();<br/>  }<br/><br/>  <strong class="ky hj">public </strong>Event(String type, String sender, Map&lt;String, Object&gt; payload, <strong class="ky hj">boolean </strong>retryable,<br/>      <strong class="ky hj">int </strong>maxRetries, <strong class="ky hj">int </strong>attemptCount, Date lastUpdated) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">type </strong>= type;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">sender </strong>= sender;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">payload </strong>= payload;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">created </strong>= <strong class="ky hj">new </strong>Date();<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">retryable </strong>= retryable;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">maxRetries </strong>= maxRetries;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">attemptCount </strong>= attemptCount;<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">lastUpdated </strong>= lastUpdated;<br/>  }<br/><br/>  <strong class="ky hj">public void </strong>setRetryable(<strong class="ky hj">boolean </strong>retryable) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">retryable </strong>= retryable;<br/>  }<br/><br/>  <strong class="ky hj">public void </strong>setMaxRetries(<strong class="ky hj">int </strong>maxRetries) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">maxRetries </strong>= maxRetries;<br/>  }<br/><br/>  <strong class="ky hj">public void </strong>setAttemptCount(<strong class="ky hj">int </strong>attemptCount) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">attemptCount </strong>= attemptCount;<br/>  }<br/><br/>  <strong class="ky hj">public void </strong>setLastUpdated(Date lastUpdated) {<br/>    <strong class="ky hj">this</strong>.<strong class="ky hj">lastUpdated </strong>= lastUpdated;<br/>  }<br/><br/>  <strong class="ky hj">public static class </strong>Builder {<br/><br/>    <strong class="ky hj">private final </strong>String <strong class="ky hj">type</strong>;<br/>    <strong class="ky hj">private final </strong>String <strong class="ky hj">sender</strong>;<br/>    <strong class="ky hj">private final </strong>Map&lt;String, Object&gt; <strong class="ky hj">payload</strong>;<br/><br/>    <strong class="ky hj">private boolean retryable </strong>= <strong class="ky hj">false</strong>;<br/>    <strong class="ky hj">private int maxRetries </strong>= 0;<br/>    <strong class="ky hj">private int attemptCount </strong>= 0;<br/>    <strong class="ky hj">private </strong>Date <strong class="ky hj">lastUpdated </strong>= <strong class="ky hj">new </strong>Date();<br/><br/>    <strong class="ky hj">public </strong>Builder(String type, String sender, Map&lt;String, Object&gt; payload) {<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">type </strong>= type;<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">sender </strong>= sender;<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">payload </strong>= payload;<br/>    }<br/><br/>    <strong class="ky hj">public </strong>Builder isRetryable(<strong class="ky hj">boolean </strong>retryable) {<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">retryable </strong>= retryable;<br/>      <strong class="ky hj">return this</strong>;<br/>    }<br/><br/>    <strong class="ky hj">public </strong>Builder withMaxRetries(<strong class="ky hj">int </strong>maxRetries) {<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">maxRetries </strong>= maxRetries;<br/>      <strong class="ky hj">return this</strong>;<br/>    }<br/><br/>    <strong class="ky hj">public </strong>Builder withAttemptCount(<strong class="ky hj">int </strong>attemptCount) {<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">attemptCount </strong>= attemptCount;<br/>      <strong class="ky hj">return this</strong>;<br/>    }<br/><br/>    <strong class="ky hj">public </strong>Builder withLastUpdated(Date lastUpdated) {<br/>      <strong class="ky hj">this</strong>.<strong class="ky hj">lastUpdated </strong>= lastUpdated;<br/>      <strong class="ky hj">return this</strong>;<br/>    }<br/><br/>    <strong class="ky hj">public </strong>Event build() {<br/>      Event event = <strong class="ky hj">new </strong>Event(<strong class="ky hj">type</strong>, <strong class="ky hj">sender</strong>, <strong class="ky hj">payload</strong>);<br/>      event.setRetryable(<strong class="ky hj">retryable</strong>);<br/>      event.setAttemptCount(<strong class="ky hj">attemptCount</strong>);<br/>      event.setMaxRetries(<strong class="ky hj">maxRetries</strong>);<br/>      event.setAttemptCount(<strong class="ky hj">attemptCount</strong>);<br/>      event.setLastUpdated(<strong class="ky hj">lastUpdated</strong>);<br/>      <strong class="ky hj">return </strong>event;<br/>    }<br/>  }<br/><br/>}</span></pre><p id="1435" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们创建的构建器类封装、组装并创建了我们的事件对象，其名称如下:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8d95" class="jt ju hi ky b fi lc ld l le lf">Map&lt;String, Object&gt; payload = <strong class="ky hj">new </strong>HashMap&lt;&gt;();<br/>payload.put(<strong class="ky hj">"message"</strong>, <strong class="ky hj">"Hi!"</strong>);</span><span id="a4fb" class="jt ju hi ky b fi lg ld l le lf">Event event = <strong class="ky hj">new </strong>Event.Builder(<strong class="ky hj">"myType"</strong>, <strong class="ky hj">"Reed"</strong>, payload)<br/>  .isRetryable(<strong class="ky hj">true</strong>)<br/>  .withMaxRetries(2)<br/>  .build();</span></pre><p id="eac3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一种更干净的方法，而不是创建一个很长的构造函数。</p><h2 id="ed01" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">委派控制</h2><p id="d836" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">您可以更进一步，将事件创建的控制权委托给 Builder 类，方法是将事件构造函数设为私有，让 Builder 公共构造函数成为创建新事件对象的唯一接口。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="892a" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">private </strong>Event(String type, String sender, Map&lt;String, Object&gt; payload) {<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">type </strong>= type;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">sender </strong>= sender;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">payload </strong>= payload;<br/>  <strong class="ky hj">this</strong>.<strong class="ky hj">created </strong>= <strong class="ky hj">new </strong>Date();<br/>}</span><span id="6ad7" class="jt ju hi ky b fi lg ld l le lf">// disables the ability to call new Event() outside this class</span></pre><h2 id="045e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">结论</h2><p id="fc79" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">Builder 模式是四种设计模式中的一种，可用于简化复杂对象的创建，通过消除调用长构造函数或调用多个 setter 方法来创建对象的需要，使您的代码更具可读性，并减少开发人员出错的可能性。</p><p id="79e0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">链接:</p><ul class=""><li id="c3a6" class="lh li hi iw b ix iy jb jc jf lj jj lk jn ll jr lm ln lo lp bi translated"><a class="ae js" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">四人帮设计的图案书</a></li></ul></div></div>    
</body>
</html>