<html>
<head>
<title>How to upload 50 OpenCV frames into cloud storage within 1 second</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在1秒内将50个OpenCV帧上传到云存储</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-upload-50-opencv-frames-into-cloud-storage-within-1-second-653ee73d7711?source=collection_archive---------4-----------------------#2020-11-12">https://medium.com/analytics-vidhya/how-to-upload-50-opencv-frames-into-cloud-storage-within-1-second-653ee73d7711?source=collection_archive---------4-----------------------#2020-11-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="33db" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何读取RTSP/视频帧并以异步方式上传到云存储</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/98b661e9acf461b549b5984dbe9ceff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLUVpekKIUAenQrRXcCIPw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">paweczerwi ski在<a class="ae jn" href="https://unsplash.com/s/photos/surveillance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="2615" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">用例</h1><p id="3f78" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这个现代世界，我想我们大多数人都熟悉使用计算机视觉应用的新行业。特别是闭路电视监视摄像机和视频分析，这些都有助于在计算机视觉技术中发挥重要作用。</p><p id="ecd5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">例如，当我们分析闭路电视摄像机时，作为第一步，我们应该使用OpenCV读取RTSP URL，然后我们应该将它存储在云中的某个位置，以便进一步分析。</p><p id="6e37" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">但问题是，当我们把帧一个接一个上传到云端的时候，上传是需要一些时间的，不是吗？</p><p id="4f70" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了获得对此的清晰理解，我用Google bucket做了一个实验，它计算出一帧需要1.05秒来上传Google bucket。因此，我们将不得不等待1秒钟以获得响应，然后，我们需要上传该行中的下一帧。</p><p id="04d7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在你的期待下，我正在寻找解决这个问题的方法，给你！！！</p><blockquote class="lh"><p id="42b7" class="li lj hi bd lk ll lm ln lo lp lq lb dx translated">解决方案是，我们可以使用<a class="ae jn" href="https://docs.celeryproject.org/en/master/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">芹菜</strong> </a>以异步方式上传帧。</p></blockquote><p id="66de" class="pw-post-body-paragraph kg kh hi ki b kj lr ij kl km ls im ko kp lt kr ks kt lu kv kw kx lv kz la lb hb bi translated">当我们以异步方式上传帧时，我们无法获得序列帧，作为一种手段，我们应该使用芹菜中的组和链概念。</p><p id="afb0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">许多人(非专业人士)会有兴趣知道；<strong class="ki hj">芹菜是什么？</strong></p><p id="4dd2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><a class="ae jn" href="http://www.celeryproject.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj">芹菜</strong> </a>是Python世界中最受作业管理者欢迎的背景之一。</p><p id="7aeb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">“芹菜”与RabbitMQ或Redis等几个消息代理兼容。这些既可以作为生产者，也可以作为消费者。此外，“Celery”是基于分布式消息传递的异步任务队列/作业队列。除此之外，它还专注于实时操作，并支持调度。</p><p id="ea29" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">澄清了定义之后，下面让我们看看如何用python代码配置celery。</p><p id="d934" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">第一步:- </strong>导入所有必需的芹菜包</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="4fb3" class="mb jp hi lx b fi mc md l me mf">from celery import Celery<br/>from celery.result import AsyncResult<br/>from celery.result import allow_join_result<br/>from celery.decorators import periodic_task</span></pre><p id="5e77" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">步骤2:- </strong>我们应该在芹菜中配置代理和后端。我已经使用Redis作为后端，所以<a class="ae jn" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank">在你的系统中安装Redis </a>，请确保它运行成功；</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="ff40" class="mb jp hi lx b fi mc md l me mf">app = Celery(‘tasks’, backend=’redis://guest@127.0.0.1:6379', broker=’redis://guest@127.0.0.1:6379')</span></pre><p id="8279" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">第三步:- </strong>为了异步调用一个函数，我们要在函数上放<strong class="ki hj"> "@app.taks annotation" </strong>。</p><p id="3fe3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">下面是将帧上传到Google bucket的样本celery代码。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="2d11" class="mb jp hi lx b fi mc md l me mf"><a class="ae jn" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.task(bind=True, max_retries=30)<br/>def upload_frames_gcs(self, file_name):<br/>    try:<br/>        url = upload_file_to_gcs(file_name)<br/>        return url<br/>    except Exception as e:<br/>        raise self.retry(exc=e)</span></pre><p id="5922" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">第四步:- 以下是最重要的步骤:</p><p id="bb26" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们将无法直接调用函数并以异步方式上传帧，因为上传后无法获得序列帧，所以要使用芹菜中的<a class="ae jn" href="https://docs.celeryproject.org/en/stable/userguide/canvas.html#chains" rel="noopener ugc nofollow" target="_blank">链</a>和<a class="ae jn" href="https://docs.celeryproject.org/en/stable/userguide/canvas.html#groups" rel="noopener ugc nofollow" target="_blank">组</a>概念将帧上传到一个桶中。使用这种技术，我们可以并行上传多达5或10帧，也可以得到帧的序列顺序。然而，在进入编码之前，让我们先看看<strong class="ki hj">“芹菜中的链和组是什么”</strong></p><h2 id="6e03" class="mb jp hi bd jq mg mh mi ju mj mk ml jy kp mm mn ka kt mo mp kc kx mq mr ke ms bi translated">芹菜链</h2><blockquote class="mt mu mv"><p id="61a5" class="kg kh mw ki b kj lc ij kl km ld im ko mx le kr ks my lf kv kw mz lg kz la lb hb bi translated">链是一种原语，它让我们将更多的任务链接到一个单一的签名中，因此它被称为<strong class="ki hj">“一个接一个，本质上形成了回调的<em class="hi">链</em></strong>。</p></blockquote><p id="0356" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">也许，如果你仍然不确定，然而，下面的图表会给你一个清晰的想法，如何在芹菜链工程。这些是芹菜里的任务id。</p><h2 id="39ee" class="mb jp hi bd jq mg mh mi ju mj mk ml jy kp mm mn ka kt mo mp kc kx mq mr ke ms bi translated">芹菜中的群体</h2><blockquote class="mt mu mv"><p id="1c23" class="kg kh mw ki b kj lc ij kl km ld im ko mx le kr ks my lf kv kw mz lg kz la lb hb bi translated">组原语是一个签名，它接受应该并行应用的任务列表。</p></blockquote><p id="c5d7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这是示例代码来解释，<strong class="ki hj">我如何上传帧到谷歌桶使用组和链技术在芹菜</strong>。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="7e94" class="mb jp hi lx b fi mc md l me mf">jobs = group(upload_frames_gcs.s(file_name, ts) for ts, file_name in file_name_dic.items())</span><span id="b98d" class="mb jp hi lx b fi na md l me mf">result = jobs.apply_async()</span></pre><p id="1f7c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">可以理解的是，我在一个组方法中调用<strong class="ki hj"> upload_frames_gcs </strong>函数<strong class="ki hj"> </strong>，然后你可以看到“s”传递一个名为<strong class="ki hj">“Chains concept”</strong>的参数，这允许你链接签名，在结果<strong class="ki hj">中一个接一个地被调用，实质上形成了一个回调</strong>的<em class="mw">链</em>。最后，我们可以在一个任务中得到一组结果。</p><p id="289d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">第五步:- </strong>难怪，如果你可能认为如何在芹菜上传后获得框架网址。很简单，在结果变量中你可以得到这个组函数的任务id，我们可以使用这个任务id来得到结果。</p><p id="d1a6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">但是，要小心检查任务的状态，一旦任务完成，我们就可以获得框架的URL。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="c707" class="mb jp hi lx b fi mc md l me mf">def taskid_status(task_id_array):<br/>        for task in task_id_array:<br/>            if task.successful():<br/>                task_id_array.remove(task)<br/>                with allow_join_result():</span><span id="7a73" class="mb jp hi lx b fi na md l me mf">                    frames_array = []<br/>                    for results in task.join(): <br/>                        frame_dic = {}<br/>                        frame_dic['frame_url'] = results[0]<br/>                        frames_array.append(frame_dic)</span><span id="8592" class="mb jp hi lx b fi na md l me mf">       return task_id_array, frames_array</span></pre><p id="8edd" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在frames_array变量中，您可以获得带有时间戳的所有帧。</p><h1 id="dbee" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">我已经用多个不同的测试用例测试了性能。</h1><ol class=""><li id="d05a" class="nb nc hi ki b kj kk km kn kp nd kt ne kx nf lb ng nh ni nj bi translated"><strong class="ki hj"> 5帧上传谷歌存储需要0.85秒。</strong></li><li id="9fe7" class="nb nc hi ki b kj nk km nl kp nm kt nn kx no lb ng nh ni nj bi translated"><strong class="ki hj"> 10帧上传谷歌存储需要0.77到0.82秒。</strong></li><li id="b190" class="nb nc hi ki b kj nk km nl kp nm kt nn kx no lb ng nh ni nj bi translated"><strong class="ki hj"> 15帧上传谷歌存储需要0.9到1.0秒。</strong></li><li id="03cb" class="nb nc hi ki b kj nk km nl kp nm kt nn kx no lb ng nh ni nj bi translated"><strong class="ki hj"> 30帧上传谷歌存储需要0.7到0.8秒。</strong></li></ol><p id="00a0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">很明显，增加上传到bucket的帧数并没有太大的区别，因为在celery中使用了多处理来执行任务的并发执行。</p><blockquote class="lh"><p id="e520" class="li lj hi bd lk ll lm ln lo lp lq lb dx translated">如果你需要进一步的帮助。请随时联系我<a class="ae jn" href="http://balavenkatesh.com/" rel="noopener ugc nofollow" target="_blank">balavenkatesh.com</a>📬我很乐意帮助你。🖥️</p></blockquote></div></div>    
</body>
</html>