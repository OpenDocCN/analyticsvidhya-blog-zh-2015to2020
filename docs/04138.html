<html>
<head>
<title>Time Series Forecasting — LSTM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测— LSTM</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-forecasting-lstm-f45fbc7796e1?source=collection_archive---------10-----------------------#2020-03-06">https://medium.com/analytics-vidhya/time-series-forecasting-lstm-f45fbc7796e1?source=collection_archive---------10-----------------------#2020-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e1e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们将了解RNN网络的概念，不同类型的网络及其实际应用。我们也看到了RNN和人工神经网络之间的性能比较。</p><p id="ebca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> RNN网络:【RNNs背后的思想是利用序列信息。在传统的神经网络中，我们假设所有的输入(和输出)都是相互独立的。但是对于许多任务来说，这是一个非常糟糕的主意。如果你想预测一个句子中的下一个单词，你最好知道它前面有哪些单词。rnn被称为<em class="jd">递归</em>，因为它们对序列的每个元素执行相同的任务，输出取决于之前的计算，你已经知道它们有一个“记忆”，可以捕捉到目前为止已经计算过的信息。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a4c82ddd45b46f6b85ec64a7518197a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyKC1vB5OJ9A9NtVNMqgkg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">RNN建筑</figcaption></figure><p id="5c3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">应用</strong></p><ul class=""><li id="6344" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae kd" href="https://en.wikipedia.org/wiki/Machine_Translation" rel="noopener ugc nofollow" target="_blank">机器翻译</a></li><li id="6d15" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated"><a class="ae kd" href="https://en.wikipedia.org/wiki/Time_series_prediction" rel="noopener ugc nofollow" target="_blank">时间序列预测</a></li><li id="8606" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated"><a class="ae kd" href="https://en.wikipedia.org/wiki/Speech_recognition" rel="noopener ugc nofollow" target="_blank">语音识别</a></li><li id="1e6c" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated"><a class="ae kd" href="https://en.wikipedia.org/wiki/Handwriting_recognition" rel="noopener ugc nofollow" target="_blank">手写识别</a></li><li id="8e70" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">预测蛋白质的亚细胞定位</li></ul><p id="6933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不同类型的无线网络</strong></p><ol class=""><li id="5b46" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kj ka kb kc bi translated">一对一:这个网络通常有一个输入和一个输出节点。它可以有“n”个隐藏节点。该网络用于预测公司/股票的股价。</li><li id="1f98" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kj ka kb kc bi translated">一对多:这个网络通常有一个输入和多个输出节点。它可以有“n”个隐藏节点。该网络用于图像字幕。</li><li id="2002" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kj ka kb kc bi translated">多对一:这个网络通常有多个输入和一个输出节点。它可以有“n”个隐藏节点。这个网络用于情感分析。</li><li id="a1d1" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kj ka kb kc bi translated">多对多:这个网络通常有多个输入和多个输出节点。它可以有“n”个隐藏节点。这个网络用于语言翻译。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kk"><img src="../Images/cd3970313715b34ce6b66fea022299cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHttNkzcown4RJd02b7wcw.jpeg"/></div></div></figure><p id="bb8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归神经网络的缺点</strong></p><ol class=""><li id="acaf" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kj ka kb kc bi translated">消失渐变和爆炸渐变。</li><li id="2ea0" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kj ka kb kc bi translated">迁移学习是不可能的。</li><li id="0d1d" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kj ka kb kc bi translated">训练RNN是一项非常艰巨的任务。</li></ol><p id="1018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来快速看一下什么是消失和爆炸渐变，以及如何解决这个问题。当我们从最后一层回到第一层时，权重更新得太慢。这就是所谓的消失梯度。我们可以通过使用LSTM、GRU网络和引入分层辍学来避免这种情况。爆炸梯度是一个权重更新过快的问题，它会导致发散问题。</p><p id="82e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">LSTM——长短期记忆:</strong> LSTM人有一种长时间记忆信息的天性，这是他们的默认行为。这个网络有三个用于记忆长序列的门。</p><p id="6f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遗忘门、输入门和输出门</p><p id="25e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遗忘门用于决定哪些信息必须记住或忘记。在处理长句时，重要的是要记住旧的状态，直到新的状态出现。例如，在处理句子时，当讨论新的个人信息时，必须忘记老人的性别。输入门用于决定什么信息必须被添加到网络中。输出门用于组合两个门的结果，并将响应转发到下一层。</p><p id="e15b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GRU有两个门，更新门和复位门。它不太复杂，需要较少的操作，因此比LSTM快得多。一般来说，两层已被证明足以检测更复杂的特征。层数越多越好，但也越难训练。作为一般的经验法则，一个隐藏层处理简单的问题，两个隐藏层足以找到相当复杂的特性。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kl"><img src="../Images/1da277de84fb6c3bed1987aa6096060f.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*8Q0zqOgVu-o9Kt7reFQfNw.jpeg"/></div></figure><p id="b286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们讨论了RNN建筑和LSTM。现在让我们进入我最喜欢的，也是最令人兴奋的使用LSTM解决实际问题的过程。</p><p id="9fa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题:</strong>使用LSTM预测股票的开盘价、收盘价、最高价和最低价。这是一个多对多的问题，这里我将解释实现的每一步。这是用Pytorch实现的，我们用了50年的数据进行预测。</p><p id="1eb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">导入必要的包</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es km"><img src="../Images/7d19e45cc017e7bcec822f17ef29b0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*47SGaqgWeOMxbLgUBqhJtg.png"/></div></figure><p id="17e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">警告.过滤警告('忽略')</em></p><p id="1962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">利用CUDA加快处理速度</strong></p><p id="5dce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">device = torch . device(' cuda:0 ')if torch . cuda . is _ available()else torch . device(' CPU ')</em></p><p id="8218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一行将有助于在GPU中以更高的速度运行进程。如果我们没有指定CUDA，那么它将默认运行在CPU中。</p><p id="4fde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建自定义数据集</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kn"><img src="../Images/947d62add5455ae565326f57ce83c300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7GajNFJ8r3eo1z1Hx5SwA.png"/></div></div></figure><p id="c691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们选择必要的列，然后，我们对数据应用特征缩放。PyTorch中的内置包不支持功能扩展，因此必须编写自定义函数来实现这一点。最重要的一步是创建批量数据。这里我们考虑最后三十个样本来预测下一个输出，因为我们已经创建了数据。</p><p id="ca13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建模型</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kn"><img src="../Images/4433d88c109dbe0816ed6460c1c50c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWNoR-VAzpUG9PmCx1VsOg.png"/></div></div></figure><p id="133b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建LSTM层，然后是线性层。在这种情况下，输入和输出大小为4，因为我们预测开盘价、收盘价、最低价和最高价。LSTM使用隐藏状态和单元状态来存储先前的输出，因此，我们定义了ho和co。转发函数是默认的a函数，用于在一层到另一层之间传递数据。</p><p id="b73f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">培训模式</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ko"><img src="../Images/54a56c91a486cc6298db897fdf4ce3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWF6zMwesxPOiUdakex5Kw.png"/></div></div></figure><p id="367c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数用于训练，这些步骤包括预测输出、计算损耗、反向传播和参数优化。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kp"><img src="../Images/dff7bd603cba2c59c84fb896e8a8faf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J78L1Oxvip407553LmQ2rQ.png"/></div></div></figure><p id="bb2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">培训过程将从这里开始。这里，我们将反向传播应用于每一步，以使训练更加有效。这个过程叫做随机梯度下降。我们计算了每批和每个时期的损失。</p><p id="c8dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">验证模型</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kq"><img src="../Images/fbcb99fd641dae7474f1fc5ec2ee8b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AzVuCRIsuqT68uNcqwfx3A.png"/></div></div></figure><p id="260e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在训练/验证阶段，我们不应该进行反向传播。模型和输入应该转移到GPU进行更快的处理。GPU只能访问GPU内存，因此模型所需的所有输入都必须发送到GPU。</p><p id="7c77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">性能对比</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kr"><img src="../Images/aa55d50ac81e0c3d8efa0acc4c7272e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*RHBnkyC5namo3MoLuFQSRA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">LSTM预言</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kr"><img src="../Images/cbb70a6f91db01f1a6516962ce94c956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*Dr9Doq8aulRGzug_sz8Y6g.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">人工神经网络预测</figcaption></figure><p id="be48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的预测中，我们可以清楚地看到RNN如何比人工神经网络更好地处理时间序列数据。</p><p id="eccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong>时间序列预测是深度学习领域中一个有趣且活跃的领域。它应用于零售、医疗保健、农业、银行、安全和许多行业。我希望给出的概念已经清楚，可以开始进入时间序列领域。在接下来的博客中，我将解释更多的技术及其实现。</p></div></div>    
</body>
</html>