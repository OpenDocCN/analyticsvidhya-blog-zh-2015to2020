<html>
<head>
<title>Test time Augmentation using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch增加测试时间</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/test-time-augmentation-using-pytorch-3da02d0a3188?source=collection_archive---------7-----------------------#2020-12-28">https://medium.com/analytics-vidhya/test-time-augmentation-using-pytorch-3da02d0a3188?source=collection_archive---------7-----------------------#2020-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b2fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图像分类中，当我们要在训练我们的模型后为我们的测试集图像预测类别时，<strong class="ih hj"> <em class="jd">我们将为每个测试图像生成n次</em> </strong>的置信概率，最后<strong class="ih hj"> <em class="jd">我们将把所有预测类别</em> </strong>中的最大平均值分配给<strong class="ih hj"> <em class="jd">图像</em> </strong>。这叫做<strong class="ih hj"> <em class="jd">测试时间增加</em> </strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/7422f3681d1f244e1b39c8500769bb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*WAdX6kpoH2sG1RFZaMn-uA.png"/></div></figure><p id="785c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在PyTorch中实现这一点，首先我们要像这样定义测试数据集类</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="bbfe" class="jr js hi jn b fi jt ju l jv jw">class <strong class="jn hj">test_Dataset</strong>(torch.utils.data.Dataset):<br/>    def __init__(self, ids, image_ids):<br/>        self.ids = ids<br/>        self.image_ids = image_ids <strong class="jn hj"># list of testset image ids</strong></span><span id="1448" class="jr js hi jn b fi jx ju l jv jw">        <strong class="jn hj">#test data augmentations</strong><br/>        self.aug = albumentations.Compose([<br/>                    albumentations.RandomResizedCrop(256, 256),<br/>                    albumentations.Transpose(p=0.5),<br/>                    albumentations.HorizontalFlip(p=0.5),<br/>                    albumentations.VerticalFlip(p=0.5),<br/>                    albumentations.HueSaturationValue(<br/>                        hue_shift_limit=0.2, <br/>                        sat_shift_limit=0.2,<br/>                        val_shift_limit=0.2, <br/>                        p=0.5<br/>                    ),<br/>                    albumentations.RandomBrightnessContrast(<br/>                        brightness_limit=(-0.1,0.1), <br/>                        contrast_limit=(-0.1, 0.1), <br/>                        p=0.5<br/>                    ),<br/>                    albumentations.Normalize(<br/>                        mean=[0.485, 0.456, 0.406], <br/>                        std=[0.229, 0.224, 0.225], <br/>                        max_pixel_value=255.0, <br/>                        p=1.0<br/>                    )<br/>                ], p=1.)<br/>    def __len__(self):<br/>        return len(self.ids)<br/>    <br/>    def __getitem__(self, index):<br/>        <strong class="jn hj"><em class="jd"># converting jpg format of images to numpy array</em></strong><br/>        img = np.array(Image.open('<strong class="jn hj">_PATH_</strong>' + self.image_ids[index]))</span><span id="5468" class="jr js hi jn b fi jx ju l jv jw">        <strong class="jn hj"><em class="jd">#Applying augmentations to numpy array</em></strong><br/>        img = self.aug(image = img)['image']</span><span id="cc32" class="jr js hi jn b fi jx ju l jv jw"><em class="jd">        </em><strong class="jn hj"># converting to pytorch image format &amp; 2,0,1 because pytorch excepts image channel first then dimension of image<em class="jd"><br/>        </em></strong>img = np.transpose(img , (2,0,1)).astype(np.float32) <br/>        <br/>        <strong class="jn hj"><em class="jd"># finally returning image tensor and its image id</em></strong><br/>        return torch.tensor(img, dtype = torch.float) , self.image_ids[index]</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/026f9e22fdcb4e38d5808f23039e7c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8kkd5XA6R8vhZDPv-F4bw.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">来源-<a class="ae kh" href="https://miro.medium.com/max/850/1*ae1tW5ngf1zhPRyh7aaM1Q.png" rel="noopener">https://miro . medium . com/max/850/1 * AE 1 tw 5 NGF 1 zhpryh 7 AAM 1 q . png</a></figcaption></figure><p id="231c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，我们称之为:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="de4d" class="jr js hi jn b fi jt ju l jv jw">test_data = <strong class="jn hj">test_Dataset</strong>(ids = [i for i <strong class="jn hj">in</strong> range(len(<strong class="jn hj">YOUR_LIST</strong>))], image_ids = <strong class="jn hj">YOUR_LIST</strong>)</span></pre><p id="f3f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们尝试对任何单个图像id运行这个<strong class="ih hj"> n </strong>次，那么我们每次都会得到不同的图像，因为对它应用了放大。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="9f4a" class="jr js hi jn b fi jt ju l jv jw">idx = <strong class="jn hj">ANY_IMAGE_ID(from 0 to length of YOUR_LIST)</strong></span><span id="4739" class="jr js hi jn b fi jx ju l jv jw">print(test_data[idx][1])</span><span id="7df3" class="jr js hi jn b fi jx ju l jv jw">img = test_data[idx][0]<br/>npimg = img.numpy()<br/>plt.imshow(np.transpose(npimg, (1,2,0)))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ki"><img src="../Images/34cb5161bdfdc42f7ba59716bb41d307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnNu1lVgbpDfd9Ne0y8NkA.jpeg"/></div></div></figure><p id="5ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，将test_data包装在数据加载器中，然后我们就可以在这段代码的帮助下进行预测了</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="58d0" class="jr js hi jn b fi jt ju l jv jw"><strong class="jn hj">no_of_times_we_wanna_do_prediction_for_one_image = </strong><em class="jd">any integer value</em><br/>final_predictions = None</span><span id="a4dd" class="jr js hi jn b fi jx ju l jv jw">for j <strong class="jn hj">in</strong> range(<strong class="jn hj">no_of_times_we_wanna_do_prediction_for_one_image</strong>):<br/>    for image,image_id <strong class="jn hj">in</strong> test_dataloader:<br/>        image = image.to(device, dtype=torch.float)<br/><br/>        with torch.no_grad():<br/>            preds = model(image)<br/>    temporary_predictions = None<br/>    for p <strong class="jn hj">in</strong> preds:<br/>        if temporary_predictions <strong class="jn hj">is</strong> None:<br/>            temporary_predictions = p<br/>        else:<br/>            temp_preds = np.vstack((temporary_predictions, p))<br/>    if final_preds <strong class="jn hj">is</strong> None:<br/>        final_predictions = temporary_predictions<br/>    else:<br/>        final_predictions += temporary_predictions</span><span id="a5d4" class="jr js hi jn b fi jx ju l jv jw">final_predictions /= <strong class="jn hj">no_of_times_we_wanna_do_prediction_for_one_image</strong></span><span id="62a7" class="jr js hi jn b fi jx ju l jv jw">final_predictions = final_predictions.detach().cpu().numpy()</span><span id="0186" class="jr js hi jn b fi jx ju l jv jw"><strong class="jn hj"><em class="jd">final_list_of_all_predictions</em></strong> = np.argmax(final_predictions)</span></pre><p id="57fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将有<strong class="ih hj"> <em class="jd">最终所有预测列表，其将</em> </strong>对应于所有测试图像的预测列表作为我们的答案。我希望你明白这一点。如果你有任何问题、意见或担忧，请在本文的评论区发表出来，在此之前享受学习的乐趣。</p></div></div>    
</body>
</html>