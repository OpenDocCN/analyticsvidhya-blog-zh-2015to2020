<html>
<head>
<title>Cost Function and Gradient Descent in pure Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯Kotlin中的代价函数和梯度下降</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cost-function-and-gradient-descent-in-pure-kotlin-169c14c0ec7?source=collection_archive---------21-----------------------#2019-12-11">https://medium.com/analytics-vidhya/cost-function-and-gradient-descent-in-pure-kotlin-169c14c0ec7?source=collection_archive---------21-----------------------#2019-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a715" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今年早些时候，我一直在Coursera(来自斯坦福大学)学习一门著名的机器学习课程，有时我发现同时学习octave有点困难。因为这不是我喜欢的编程语言类型，所以我想用我在Java或Kotlin中学到的东西进行实验。最后，我决定使用Kotlin，因为它更容易实现matrix及其函数，这主要是因为它支持operator霸王和中缀函数。</p><p id="ddd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我将从与Couseara课程相同的leaner回归开始，然后希望我会转到逻辑回归、神经网络、SVM等，并对Kotlin做同样的事情。</p><p id="3cb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从成本函数开始..</p><h2 id="6932" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">什么是成本函数(损失函数或平方误差函数)</h2><p id="22c3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">这里我不打算解释定义，但它做的是对预测值和期望值之间的误差进行量化。因此，一旦我们计算误差(图中的距离)并求和，我们将得到预测的损失。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/a32bebe968b25d2c134da067b1a6b909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aB7003vFGthyWE1sOSNjag.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">实际和预测之间的距离</figcaption></figure><p id="6635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始编码。</p><h2 id="d906" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">首先定义矩阵</h2><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="102e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有什么复杂的只是保持行数和列数，并将所有数据保存在一个列表中。</p><p id="c822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ex- if矩阵是2 x 3 [0，0] =第1个元素，[0，3] =第3个元素，[1，0] =第4个元素，[1，3] =第6个元素</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="475e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我计划以列表形式检索所有特性和结果。所以需要一个方法把列表转换成这个矩阵。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="255c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，它可以很容易地通过给定的列数将其转换为矩阵。确保列表的大小必须与列数兼容。</p><p id="f9af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要做的就是实现成本函数。因为我在处理矩阵，所以我们不必担心特征的数量。一旦正确实现，它将工作任何数量的给定功能。无论如何，为了使这个形象化，我取一个有一个变量的数据集。但是我将运行一些具有两个或更多特性的数据集，并与Python库进行比较，以确保我们的实现工作正常。</p><p id="8e41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成本函数是一个简单的等式。它的作用是，得到所有误差的总和，然后取平均值。</p><p id="a9cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lc">注:对于未来的直觉，我建议跟随一个深入的教程。</em></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es ld"><img src="../Images/30c8173797fe1b445a644bf6e647f9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*q9ykCHCYuNS4NKIB5SxnHg.png"/></div></figure><p id="5023" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对多特征数据集的假设。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es le"><img src="../Images/45d4ba1e644aaf00c71d14989ea93fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5CA3F7wpMUu4mb_asMylg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">来源:Coursera机器学习课程——斯坦福大学</figcaption></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="03d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“X Xθ”(X乘以θ)到底是什么？。是的，这就是度量乘法，这就是科特林中缀函数的美妙之处。让我们实现这一点。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lf"><img src="../Images/47061a19676eca9c603cd2aa49114531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FZpBBAAtUi8kwKqG.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">[4 x 2] x [ 2 x 3] = [4 x 3]矩阵(来源——维基)</figcaption></figure><p id="8ca4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，首先，我们需要实现矩阵乘法，这是乘法是如何实现的图示。</p><p id="637e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个矩阵的列和第二个矩阵的行必须相等。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="d725" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以基本上就是这样。现在你能够计算给定的成本。</p><p id="dbf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，这里我们实现了没有矢量化的成本函数。我们所做的是迭代每个元素，并将累积误差存储在临时变量中。但是我们可以使用矢量化以更好的方式来实现。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">矢量化和非矢量化实施</figcaption></figure><blockquote class="lg lh li"><p id="4353" class="if ig lc ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated">上面我已经添加了这两个实现，所以你可以检查不同之处。</p></blockquote><p id="7536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，对于矢量化的实现，我们需要更多的运算符重载&amp;矩阵函数，如下所示。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">矩阵减运算符过载函数</figcaption></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">矩阵幂扩展函数</figcaption></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">矩阵求和</figcaption></figure><p id="392f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们完成了成本函数的实现。让我们加载一些数据集，并找出一些猜测的成本。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="84d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我使用JMathPlot来绘制数据集。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lm"><img src="../Images/15047eb6b237835d0f9660074978cc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOM8ACGrStgf6AEfBOYwPg.png"/></div></div></figure><p id="a65c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们猜猜看。😂 😂</p><p id="f231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过一番猜测，我的最佳猜测是θ[-4.0，1.2]。(因为这是单变量数据集)让我们画出来。</p><blockquote class="lg lh li"><p id="acbe" class="if ig lc ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated">注意:-为了考虑截距项(θ0)，我们添加一个附加列作为X的第一个索引，并将其设置为全1(1 *θ0)。所以我们可以很容易地做乘法，找到假设</p></blockquote><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">使用给定默认值为给定索引插入新列的函数</figcaption></figure><p id="1d76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并在图中画线。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ln"><img src="../Images/318b097b1320260291f2e5194b82a00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRM6fnuOJ_HgaG2O7p52wQ.png"/></div></div></figure><p id="3b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们运行我们的实现，并找出猜测的成本。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="a6e4" class="jd je hi lp b fi lt lu l lv lw">4.478453220857733 (from non vectorized function)<br/>4.478453220857733 (from vectorized function)</span></pre><p id="3bf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我得到了4.4785作为成本。从根本上来说，我们需要确保成本最小，以表明绘制的线最适合给定的数据集。</p><p id="6d68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我们要做的是，从一些θ值开始，不断改变它，以降低成本函数，直到我们找到最小值。这叫梯度下降。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lx"><img src="../Images/0755181e392762f97a23e02d367d7237.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/0*pEHWJ68ouwH1IC6A.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">来源—<a class="ae ly" href="https://ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html" rel="noopener ugc nofollow" target="_blank">https://ml-cheat sheet . readthedocs . io/en/latest/gradient _ descent . html</a></figcaption></figure><p id="0ee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说..</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lz"><img src="../Images/c333575b7ddf8347a491f26bb7349a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*B6NR3363cLcGYj8hUok1RA.png"/></div></div></figure><p id="9ddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实施梯度下降算法之前，我真的需要知道我的猜测是否正确😉。所以让我们做一个快速的python脚本来看看。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ma"><img src="../Images/6445af9aa4f44720fc8aae6a2914bab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGNwW-xBRBfEfZlmmCTOlA.png"/></div></div></figure><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="9448" class="jd je hi lp b fi lt lu l lv lw">Intercept : -3.8957808783118537<br/>Feature's coefficients are: [1.19303364]<br/>So calculated cost is: 4.476971375975176</span></pre><p id="8e7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哈哈，太接近了😇 😎。</p><p id="0564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们现在做梯度下降代码。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="db70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要实现更多的矩阵函数和运算符重载。(转置和矩阵*双精度)</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">转置函数</figcaption></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">矩阵*双运算符重载</figcaption></figure><p id="f8a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们完成了✌️.让我们运行同样的例子，看看我们得到的结果是否和Python脚本一样。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="28d1" class="jd je hi lp b fi lt lu l lv lw">With learning rate = 0.01 and iteration = 1000 i've got</span><span id="31f2" class="jd je hi lp b fi mb lu l lv lw">Intercept: -3.241402144274422<br/>Coefficients: [1.1272942024281842]<br/>Cost: 4.515955503078912</span></pre><p id="d57f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇…那太糟糕了😱。连我的猜测都比那好。那么有什么问题吗？。让我们画出收敛图，看看发生了什么。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mc"><img src="../Images/147a3ab8a7e904e3fbb04677adecb04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*V3GJxU0182OAa5O_J7h7ow.png"/></div></figure><p id="1db1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的清晰，训练率是公平的，但它需要更多的迭代收敛更多。所以我们把迭代增加到5000看看。</p><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="d8f7" class="jd je hi lp b fi lt lu l lv lw">With learning rate = 0.01 and iteration = 5000 i've got</span><span id="f878" class="jd je hi lp b fi mb lu l lv lw">Intercept: -3.895300510657168<br/>Coefficients: [1.1929853860482198]<br/>Cost: 4.47697139698281</span></pre><p id="4f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">收敛图也很好。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es md"><img src="../Images/967b3f1b6e56f055e2793be36bcfcc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*63kcO5nL_foFvrpN0lzekA.png"/></div></figure><p id="50de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁…..😇 😇。成功了。现在，让我们画出结果。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es me"><img src="../Images/e3f433af3e1673ae370b800fe3fde138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4J-LWYZYwY8Vk6coiZi6uQ.png"/></div></div></figure><p id="7fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">够公平吧？。现在我想形象化地展示θ值在每次迭代中是如何变化的。所以我要把所有的θ值保存在列表中并返回。然后用thread.sleep()打印每一个</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mf"><img src="../Images/5fae0ad8a80a68ef5299bce57c045d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fcHGBHJBkE1spPa92JPQZA.gif"/></div></div></figure></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="b2b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们从Kaggle获得另一个数据集，并评估我们的实现。</p><p id="c98d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集—<a class="ae ly" href="https://www.kaggle.com/andonians/random-linear-regression" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/andonians/random-linear-regression</a></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mg"><img src="../Images/8776b9938028ccf05f222fca1bb161fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6ZqLL-3e9eeZIYXcCJQSA.png"/></div></div></figure><p id="f1e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着我们的实施，</p><blockquote class="lg lh li"><p id="4a33" class="if ig lc ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated"><strong class="ih hj">学习率= 0.0005，迭代次数= 10000 </strong></p></blockquote><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="4201" class="jd je hi lp b fi lt lu l lv lw">intercept: -0.08157245168346036<br/>coefficients: [1.0001999306062792]<br/>Cost: 3.944586551695178<br/></span></pre><blockquote class="lg lh li"><p id="38dc" class="if ig lc ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated"><strong class="ih hj">学习率= 0.0005，迭代次数= 100000 </strong></p></blockquote><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="26ac" class="jd je hi lp b fi lt lu l lv lw">intercept: -0.12015504504010248<br/>coefficients: [1.0007782407846593]<br/>Cost: 3.944399934788149</span></pre><div class="ke kf kg kh fd ab cb"><figure class="mh ki mi mj mk ml mm paragraph-image"><img src="../Images/a24a46e0836bf3b612e29efa2e9f2e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*8J_gSjliaT_E1AikgSAYsA.png"/></figure><figure class="mh ki mn mj mk ml mm paragraph-image"><img src="../Images/958dd379ace94a8a075bd90064ff9769.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*B6Mq4wqpSun3mQHZGSIqQw.png"/><figcaption class="kp kq et er es kr ks bd b be z dx mo di mp mq translated">左:<strong class="bd jf">学习率= 0.0005，迭代次数= 10000:收敛还需要更多的迭代次数</strong>右:<strong class="bd jf">学习率= 0.0005，迭代次数= 200000:似乎收敛正常</strong></figcaption></figure></div><p id="395a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于好奇，让我们绘制前100次迭代(放大)并观察它的行为。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mr"><img src="../Images/8c95c1d2ccff13c69f44ef6375dec50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*oBcuFkFvtWIKBcASS6ICUw.png"/></div></figure><p id="ae92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">似乎最初，它很挣扎。不过，很快就恢复了。最初的挣扎表明学习率比我们想象的要高一点，所以只要把学习率降低到0.0002，看看会发生什么。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es ms"><img src="../Images/feaebb40db5d47dc5bd80c15a89b928c.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*nYP3GWPBxzVf2va5qGo1wQ.png"/></div></figure><p id="422c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在看起来很公平，但是这是以迭代次数为代价的。这意味着训练所需的时间。所以既然恢复的好，我觉得还是保持在0.0005比较好。</p><p id="5c79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者我应该再增加一点看看？好，让我们增加到0.0006，看看它如何表现。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mt"><img src="../Images/7a64f3801094d4b9134f642d36415f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*SJmD8v2fqin-Uyh0hXOl5Q.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">搞砸</figcaption></figure><p id="1a13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阿哈哈哈太高了😬 😬，我们不要去那里😉。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="7ead" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">多变量梯度下降</h2><p id="4ac9" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">现在，让我们获取一个多特征数据集并运行我们的实现。数据集与“Coursera”作业中使用的数据集相同。</p><blockquote class="lg lh li"><p id="cb79" class="if ig lc ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated">注意:两个特征，房子的大小(平方英尺)和卧室的数量。我们正在预测房子的价格。</p></blockquote><p id="4bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，这里是计算截距和特征系数的python代码。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mu"><img src="../Images/d39b339981d725e9ded28fb62fcd3509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xo6dV1fKfinTKFgEBXvQ_g.png"/></div></div></figure><blockquote class="lg lh li"><p id="e578" class="if ig lc ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated">做了2000平方英尺和3间卧室的预测，答案是341805.200</p></blockquote><p id="a6f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将运行我们的实现，看看我们是否得到相同的结果。</p><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="db5c" class="jd je hi lp b fi lt lu l lv lw"><strong class="lp hj"><em class="lc">1st attempt</em></strong><br/>Learning Rate = 0.0000002<br/>Iterations = 5000000</span><span id="fec2" class="jd je hi lp b fi mb lu l lv lw"><strong class="lp hj"><em class="lc">2nd attempt</em></strong><br/>Learning Rate = 0.0000002<br/>Iterations = 10000000</span><span id="d99a" class="jd je hi lp b fi mb lu l lv lw"><strong class="lp hj"><em class="lc">3rd attempt</em></strong><br/>Learning Rate = 0.0000002<br/>Iterations = 100000000</span></pre><p id="be22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有3次尝试都表明迭代远远不足以使θ最小化。你可以在下面的图表中看到。</p><div class="ke kf kg kh fd ab cb"><figure class="mh ki mv mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/6906f74d144ffab5e96c229fbf5b7df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*0Q6-64g9o7IEjGTflzHM2Q.png"/></div></figure><figure class="mh ki mw mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/00701603aeee893dd83613e861ea3148.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*I-PcalQmuT1Lb3UNLsL9fg.png"/></div></figure><figure class="mh ki mx mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><img src="../Images/361cc83c378adb197c96eb5993ad9079.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*1RimRqtYJRvsCRbWInymog.png"/></div></figure></div><p id="dd4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在我的第四次尝试中，我将迭代次数增加了4倍，希望它能给我一些最佳值。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es my"><img src="../Images/0ea97e298fb335d99535bfab0d62b397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*xuAE5hPTcObKjKmlW4wUCQ.png"/></div></figure><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="7a3b" class="jd je hi lp b fi lt lu l lv lw"><strong class="lp hj"><em class="lc">4th attempt</em></strong><br/>Learning Rate = 0.0000002<br/>Iterations = 400000000</span></pre><p id="9cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">😱哦，伙计，你仍然可以看到红色和绿色的线不是最佳的。所以在最后一次尝试中，让我们将迭代次数增加到550000000次，看看它是如何工作的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mz"><img src="../Images/9e2019fb4b43a29cade2e076877678a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*6u_jo_23W-9Q-nJLZWzVXA.png"/></div></figure><p id="12fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这花了大约145分钟来运行。但这也不是100%准确。但是现在，我可以应付这些结果。还有，我受够了🙏。让我们用我在最后一次尝试中得到的结果来做预测。</p><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="7ae1" class="jd je hi lp b fi lt lu l lv lw"><strong class="lp hj"><em class="lc">5th attempt</em></strong><br/>Learning Rate = 0.0000002<br/>Iterations = 550000000</span><span id="5541" class="jd je hi lp b fi mb lu l lv lw">Intercept: 89211.91357108342<br/>coefficients: [139.20934164431515, -8621.386066273524]]<br/>Cost: 2.0432840334191492E9</span></pre><p id="9cda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，如果我们预测和python一样(2000平方英尺&amp; 3间卧室)。</p><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="7710" class="jd je hi lp b fi lt lu l lv lw">89211.916 + (2000 * 139.209) + (3 * -8621.386) = <strong class="lp hj">341765.758</strong></span></pre><p id="3e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测值是341，765.758非常接近不是吗？👍</p><p id="587d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你可以看到红线，它还不稳定。所以仍然需要更多的迭代以获得更高的精度。但我已经受够了，因为这花了我两个半小时来执行。那么问题是什么呢？为什么花了这么长时间？</p><p id="7d43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是我们没有扩展功能。我们来看一下数据集。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es na"><img src="../Images/c5e3291a50c9f1b7e95c0880b74c83ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*vkiEQ5Dy3cVAT-dAhVjo0Q.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">4 / 47</figcaption></figure><p id="ea88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到的特征是房子大小(平方英尺)和卧室数量。问题是，这些特征的尺度是如此的不同，并且不在一个相似的数值范围内。这让一切都变得缓慢。</p><p id="fd58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们首先缩放特征。想法是获取大约在-1和+1之间的所有特征数据。</p><p id="0672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这被称为均值归一化。基本上，特征值减去相同特征的平均值，然后除以范围。对于范围，我们可以使用最小-最大值或标准差。(或许你可以在这里找到更好的答案<a class="ae ly" href="https://sebastianraschka.com/Articles/2014_about_feature_scaling.html" rel="noopener ugc nofollow" target="_blank">https://sebastianraschka . com/Articles/2014 _ about _ feature _ scaling . html</a>)</p><p id="11ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为“Coursera”课程使用了标准差，所以我也要使用它。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">均值、标准差扩展函数&amp;返回给定列中所有值的方法</figcaption></figure><p id="3e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们实现了所有需要的功能。现在让我们把它们放在一起，实现“featureNormalize”方法。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="1ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们的梯度下降在一秒内完成🤘。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es nb"><img src="../Images/471287eaf0078cbaa3bb54b83d6677f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*GsDwPsN4PBtABSGklztI6Q.png"/></div></figure><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="6a5a" class="jd je hi lp b fi lt lu l lv lw">Intercept: 340412.659<br/>coefficients: [109447.796,  -6578.354]]<br/>Cost: 2.043280050602829E9</span></pre><p id="8873" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了对2000平方英尺和3个房间进行预测，我们需要根据各自的平均值和标准偏差对这些值进行标准化。为此，我们需要从归一化方法中得到相同的均值和标准差。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kt ku l"/></div></figure><pre class="ke kf kg kh fd lo lp lq lr aw ls bi"><span id="7326" class="jd je hi lp b fi lt lu l lv lw">Mean : [2000.680, 3.170])<br/>Standed diviation : [786.203, 0.753]) </span><span id="1d2b" class="jd je hi lp b fi mb lu l lv lw">Sq feet = (2000–2000.680) /786.203 = -0.000865<br/>Rooms = (3 - 3.170)/0.753 = -0.226</span><span id="77ca" class="jd je hi lp b fi mb lu l lv lw">340412.659 + (109447.796 * -0.000865) + (-0.226 * -6578.354)<br/><strong class="lp hj">= 341804.694</strong></span></pre><p id="79bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是一样的。然而，在特征缩放之后，我们得到结果要快得多。</p><p id="ce83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，我们结束了。😇</p><p id="7541" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上所有代码你都可以在我的<a class="ae ly" href="https://github.com/shehanmdev/MyML" rel="noopener ugc nofollow" target="_blank"> GITHUB </a> repo中找到。</p><p id="e74e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到下次..:)</p></div></div>    
</body>
</html>