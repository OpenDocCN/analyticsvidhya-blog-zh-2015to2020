<html>
<head>
<title>Leaderboards and Rankings with SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排行榜和SQL排名</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/leaderboards-and-rankings-with-sql-f0c7700d41d3?source=collection_archive---------1-----------------------#2019-12-12">https://medium.com/analytics-vidhya/leaderboards-and-rankings-with-sql-f0c7700d41d3?source=collection_archive---------1-----------------------#2019-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="59ca" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak">使用窗口功能</strong></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6d66f6510e1b7aea770a1677404b2e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5QuIIv327lgSoTWd"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">丹尼尔·冯·阿彭在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9ada" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">相信我，SQL的窗口函数是我在数据库世界中见过的强大功能之一。当您想要查询分析信息时，它尤其出色。本文提供的语法基于MySQL，MySQL从版本8开始支持窗口函数。在MySQL 8之前，为了从数据库中获取一些分析数据，我必须编写大量的业务逻辑。</p><p id="f24b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们通过一个例子来深入了解窗口函数，这样你就能很容易地掌握这个特性的威力。让我们为一个简单的游戏创建带有排名的排行榜。</p><h1 id="65b0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">方案</h1><p id="4d71" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">假设你正在开发一款类似<a class="ae jn" href="https://www.quizup.com/en" rel="noopener ugc nofollow" target="_blank"> QuizUp </a>的网络游戏，它允许用户注册并玩游戏。注册用户可以参加主题下的测验。用户每次进行测验时都会得分，但排名时只会考虑最高分。用户将在每个主题内进行排名，在特定主题下，用户还将在国家/地区范围内进一步排名。例如，如果你在玩主题为'<em class="lh"> Databases </em>的游戏，那么你将拥有一个数据库主题排名(所有玩过这个主题的用户的全球排名)，以及一个你所在国家的排名(假设你在美国，你将拥有一个国家排名或洲排名)。</p><p id="52cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在仪表板(或应用程序)中，至少参加过一次特定主题下的测验的所有用户将显示在主题排行榜中。类似这样的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/60ba9dfe12de19d3385520965d5c8974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*WYLoLmpA_7dA_S0fJbyR3A.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片提供:<a class="ae jn" href="https://iphone.qualityindex.com/games/7225323/quizup/" rel="noopener ugc nofollow" target="_blank">https://iphone.qualityindex.com/games/7225323/quizup/</a></figcaption></figure><p id="1967" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个很好的用例，使用窗口函数来实现我们想要在仪表板上显示的内容。</p><h1 id="15d7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">我们的模式</h1><p id="150f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">让我们保持这个例子的模式简单。我们只有一个表叫做<em class="lh">分数</em>。它记录了每个用户每次参加测验时的分数，为了方便起见，我们假设根据游戏时登录的国家或预先给出的帐户信息，我们还记录了每个用户的国家。下表显示了我们将在主题id<em class="lh">101</em>下排列的一组样本数据。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="7e63" class="lo kl hi lk b fi lp lq l lr ls">+---------+------------+----------+-------+<br/>| user_id | country_id | topic_id | score |<br/>+---------+------------+----------+-------+<br/>|       4 | US         |      101 |    72 |<br/>|       3 | CAN        |      101 |    30 |<br/>|       6 | US         |      101 |    72 |<br/>|       4 | US         |      101 |    49 |<br/>|       1 | CAN        |      101 |    53 |<br/>|       8 | US         |      101 |    67 |<br/>|       5 | CAN        |      101 |     6 |<br/>|       7 | CAN        |      101 |    87 |<br/>|       2 | US         |      101 |    41 |<br/>|       3 | CAN        |      101 |    76 |<br/>+---------+------------+----------+-------+</span></pre><p id="9b33" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了简单起见，我们将只考虑两个国家(美国、加拿大)和八个用户(用户id，1..8).</p><h1 id="ebe6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">获取主题内的全局排名</h1><h2 id="4576" class="lo kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第一步:汇总</h2><p id="fe14" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">首先，让我们汇总每个用户和团队的所有分数<em class="lh">。所以，我们将有最高分的每个用户对他/她的国家。</em></p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="3366" class="lo kl hi lk b fi lp lq l lr ls"><strong class="lk hj">SELECT</strong><br/>  user_id,<br/>  country_id,<br/>  MAX(score) AS highScore<br/><strong class="lk hj">FROM</strong> score<br/><strong class="lk hj">WHERE</strong> topic_id = 101<br/><strong class="lk hj">GROUP</strong> <strong class="lk hj">BY</strong> user_id, country_id</span></pre><p id="8a2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用<em class="lh"> country_id </em>进行分组，因为当我们要进行排名时，我们需要有country <em class="lh"> _id </em>字段用于父查询。此外，如果游戏规则已经改变，以总分而不是最高分，简单地说，只有我们必须改变聚合函数从最大值到总和。</p><h2 id="2a67" class="lo kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第二步:排名</h2><p id="e565" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在，我们希望获得每个用户相对于其所属国家的排名。预期的结果应该如下所示。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="8558" class="lo kl hi lk b fi lp lq l lr ls">+---------+------------+-------+-------------+<br/>| user_id | country_id | score | <strong class="lk hj">countryRank</strong> |<br/>+---------+------------+-------+-------------+<br/>|       4 | US         |    72 |           <strong class="lk hj">1</strong> |<br/>|       6 | US         |    72 |           <strong class="lk hj">1</strong> |<br/>|       8 | US         |    67 |           <strong class="lk hj">3</strong> |<br/>|       2 | US         |    41 |           <strong class="lk hj">4</strong> |<br/>|       7 | CAN        |    87 |           <strong class="lk hj">1</strong> |<br/>|       3 | CAN        |    76 |           <strong class="lk hj">2</strong> |<br/>|       1 | CAN        |    53 |           <strong class="lk hj">3</strong> |<br/>|       5 | CAN        |     6 |           <strong class="lk hj">4</strong> |<br/>+---------+------------+-------+-------------+</span></pre><p id="3ccf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们看看获得上述结果的查询。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c1d9" class="lo kl hi lk b fi lp lq l lr ls"><strong class="lk hj">SELECT<br/>  t.user_id,<br/>  t.country_id,<br/>  t.highScore,<br/>  RANK() OVER (PARTITION BY t.country_id <br/>               ORDER BY t.highScore DESC) AS countryRank<br/>FROM (</strong><br/>  SELECT<br/>    user_id,<br/>    country_id,<br/>    MAX(score) AS highScore<br/>  FROM score<br/>  WHERE topic_id = 101<br/>  GROUP BY user_id, country_id<br/><strong class="lk hj">) AS t<br/>ORDER BY t.country_id DESC, countryRank</strong></span></pre><p id="70e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，我们所做的是，将步骤1中的查询作为新查询的派生表，将其包含在来自子句的<strong class="jq hj">中。检查新的投影子句。</strong></p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="680d" class="lo kl hi lk b fi lp lq l lr ls">RANK() OVER <br/>    (PARTITION BY t.country_id ORDER BY t.highScore DESC) <br/>    AS countryRank</span></pre><p id="4b19" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们将"<em class="lh">分区"</em>记录由<em class="lh"> country_id </em>列组成。当数据库遍历每条记录时，它会保留当前记录所属的相应分区。在这种情况下，它是按国家划分的。同时，我们还指示引擎跟踪分区内记录的排序。所以我们说，我们要按计算出的<code class="du mg mh mi lk b"><em class="lh">highestScore</em></code>降序排序。因此，得分最高的人会名列前茅。</p><p id="cce1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，我们需要为分区提供一个聚合函数。因为我们需要tanking，所以在MySQL<a class="ae jn" href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html" rel="noopener ugc nofollow" target="_blank">中有相当多的选择，因为我们可以用几种不同的方式排名，但是有两种值得一提。</a></p><ul class=""><li id="725c" class="mj mk hi jq b jr js ju jv jx ml kb mm kf mn kj mo mp mq mr bi translated"><strong class="jq hj"> DENSE_RANK </strong>:等级相同的行将具有相同的等级，并且没有间隔。即，考虑三个用户U1、U2和U3分别具有高分80、80、78。使用DENSE_RANK将为三个用户提供排名1、1、2。</li><li id="bfed" class="mj mk hi jq b jr ms ju mt jx mu kb mv kf mw kj mo mp mq mr bi translated"><strong class="jq hj">等级</strong>:等级相同的行具有相同的等级，但是等级值可以有差距。即，如果两个用户获得相同的排名，比如第四，那么下一个用户将被排名第六，因为两个用户在第四，因此排名第五是不可用的。</li></ul><p id="944f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们选择排名，因为它(我相信)是排名的一般方式。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="c57d" class="lo kl hi lk b fi lp lq l lr ls"><strong class="lk hj">RANK() OVER (PARTITION BY </strong>country_id<strong class="lk hj"> <br/>               ORDER BY </strong>highScore<strong class="lk hj"> DESC) </strong>AS<strong class="lk hj"> </strong>teamRank</span></pre><p id="0cf3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于我们有两个用户在国家/地区美国具有相同的最高得分，因此他们将被排名为1，并且由于排名功能，下一个最高得分的用户(即#8)将被排名为3。如果我们选择了DENSE_RANK函数，用户#8的排名将是2。</p><p id="5b87" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">查看分区查询中结果的差异。与SQL中的group by子句不同，分区仍然返回所有记录。</p><p id="4653" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经完成了一半。</p><h1 id="bb4a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">获得全球排名</strong></h1><p id="7361" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">如前所述，假设我们需要在仪表板中显示用户的全球排名以及个人的国家排名。首先，让我们看看对它的查询。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="8e1f" class="lo kl hi lk b fi lp lq l lr ls">SELECT<br/>  t.user_id,<br/>  t.country_id,<br/>  t.highScore,<br/>  <strong class="lk hj">RANK() OVER (ORDER BY </strong>t.highScore<strong class="lk hj"> DESC) </strong>AS globalRank<br/>FROM (<br/>  SELECT<br/>    user_id,<br/>    country_id,<br/>    MAX(score) AS highScore<br/>  FROM score<br/>  WHERE topic_id = 101<br/>  GROUP BY user_id, country_id<br/>) AS t<strong class="lk hj"><br/></strong>ORDER BY globalRank</span></pre><p id="9720" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这与步骤2中的查询非常相似，只是我们删除了partition子句。这里发生的情况是，一旦我们删除了partition子句，查询将没有任何分区，而只有一个分区。对于该查询来说，唯一且默认的分区是整个表。因此，当应用<em class="lh">等级</em>时，它计算相对于整个表的等级。因此我们得到了全球排名。这意味着查询将对用户进行排名，而不考虑团队。下面是上述查询的结果。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="64d8" class="lo kl hi lk b fi lp lq l lr ls">+---------+------------+-------+------------+<br/>| user_id | country_id | score | <strong class="lk hj">globalRank</strong> |<br/>+---------+------------+-------+------------+<br/>|       7 | CAN        |    87 |          <strong class="lk hj">1</strong> |<br/>|       3 | CAN        |    76 |          <strong class="lk hj">2</strong> |<br/>|       4 | US         |    72 |          <strong class="lk hj">3</strong> |<br/>|       6 | US         |    72 |          <strong class="lk hj">3</strong> |<br/>|       8 | US         |    67 |          <strong class="lk hj">5</strong> |<br/>|       1 | CAN        |    53 |          <strong class="lk hj">6</strong> |<br/>|       2 | US         |    41 |          <strong class="lk hj">7</strong> |<br/>|       5 | CAN        |     6 |          <strong class="lk hj">8</strong> |<br/>+---------+------------+-------+------------+</span></pre><h1 id="18fa" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">一石二鸟</h1><p id="2fc6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在仪表板中，或者从您的业务层，您真的认为您想要调用两次来获得两个排名，然后为每个用户合并吗</p><p id="c010" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">答案是<strong class="jq hj"> <em class="lh">不</em> </strong>！</p><p id="82df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你不会真的想写两个查询，一个获取团队排名，一个获取全局排名。事实上，<strong class="jq hj">您可以在一个查询</strong>中获得两个等级。</p><blockquote class="mx my mz"><p id="9713" class="jo jp lh jq b jr js ij jt ju jv im jw na jy jz ka nb kc kd ke nc kg kh ki kj hb bi translated">这就是窗口函数的妙处！</p></blockquote><p id="7383" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每个投影子句上可以有任意多的分区。一个分割子句不影响其他投影子句。他们是完全独立的。</p><p id="fd9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，组合查询应该如下所示。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="5c98" class="lo kl hi lk b fi lp lq l lr ls">SELECT<br/>  t.user_id,<br/>  t.country_id,<br/>  t.highScore,<br/>  RANK() OVER (PARTITION BY t.country_id <br/>               ORDER BY t.highScore DESC) AS countryRank,<br/>  RANK() OVER (ORDER BY t.highScore DESC) AS globalRank<br/>FROM (<br/>  SELECT<br/>    user_id,<br/>    country_id,<br/>    MAX(score) AS highScore<br/>  FROM score<br/>  WHERE topic_id = 101<br/>  GROUP BY user_id, country_id<br/>) AS t</span></pre><p id="9c00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们得到了想要的结果，输出如下，计算了两列中的两个等级。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="120b" class="lo kl hi lk b fi lp lq l lr ls">+---------+------------+-------+-------------+------------+<br/>| user_id | country_id | score | <strong class="lk hj">countryRank</strong> | <strong class="lk hj">globalRank</strong> |<br/>+---------+------------+-------+-------------+------------+<br/>|       7 | CAN        |    87 |           1 |          1 |<br/>|       3 | CAN        |    76 |           2 |          2 |<br/>|       4 | US         |    72 |           1 |          3 |<br/>|       6 | US         |    72 |           1 |          3 |<br/>|       8 | US         |    67 |           3 |          5 |<br/>|       1 | CAN        |    53 |           3 |          6 |<br/>|       2 | US         |    41 |           4 |          7 |<br/>|       5 | CAN        |     6 |           4 |          8 |<br/>+---------+------------+-------+-------------+------------+</span></pre><p id="3ed7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能希望在您的应用程序或仪表板的排行榜页面上显示上述结果。但是，如果您必须在特定用户的个人资料页面中显示他/她的两个等级，该怎么办呢？</p><h1 id="e389" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">获取单个用户的两个排名</h1><p id="27a0" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">您可能会认为，通过只过滤该用户id的记录来获得单个用户的排名是微不足道的。用更简单的术语来说，只需在条件中添加一个where子句，<code class="du mg mh mi lk b">user_id = ?</code>在外部查询中的order by子句之前，对吗？</p><p id="b3c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lh">错了！</em></p><p id="6303" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果这样做，您将无法计算排名。对于所有用户来说，都会一直显示团队排名为<em class="lh">第1</em>而全局排名为<em class="lh">第1，</em>这显然是错误的<em class="lh">。</em></p><p id="0150" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种行为的原因很简单。</p><blockquote class="nd"><p id="156a" class="ne nf hi bd ng nh ni nj nk nl nm kj dx translated"><strong class="ak">在SQL世界中，WHERE子句在SELECT子句之前执行。</strong></p></blockquote><p id="5c95" class="pw-post-body-paragraph jo jp hi jq b jr nn ij jt ju no im jw jx np jz ka kb nq kd ke kf nr kh ki kj hb bi translated">因此，当记录将要被分区时，这在投影内部，只有一个记录，并且它是用于被过滤的用户的记录。但是要计算排名，我们需要<code class="du mg mh mi lk b">highScores</code>为<em class="lh">每</em>用户<em class="lh">用户</em>。您既不能在派生表中添加用户筛选，也不能在外部查询中添加用户筛选。</p><p id="595a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么，我们把过滤放在哪里呢？</p><p id="d540" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lh">简单！</em>只需将此查询包含在另一个外部查询中，并从包含的查询中筛选出用户。见下文。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="0314" class="lo kl hi lk b fi lp lq l lr ls"><strong class="lk hj">SELECT<br/>    *<br/>FROM (</strong><br/>  SELECT<br/>    t.user_id,<br/>    t.country_id,<br/>    t.highScore,<br/>    RANK() OVER (PARTITION BY t.country_id <br/>                 ORDER BY t.highScore DESC) AS countryRank,<br/>    RANK() OVER (ORDER BY t.highScore DESC) AS globalRank<br/>  FROM (<br/>    SELECT<br/>      user_id,<br/>      country_id,<br/>      MAX(score) AS highScore<br/>    FROM score<br/>    WHERE topic_id = 101<br/>    GROUP BY user_id, country_id<br/>  ) AS t<br/><strong class="lk hj">) AS rt<br/>WHERE<br/>    rt.user_id = ?</strong></span></pre><p id="b3e8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该查询将返回正确排序的单个用户记录。例如，制作<code class="du mg mh mi lk b">rt.user_id = 8</code>将返回下面的结果。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="d9da" class="lo kl hi lk b fi lp lq l lr ls">+---------+------------+-------+-------------+------------+<br/>| user_id | country_id | score | countryRank | globalRank |<br/>+---------+------------+-------+-------------+------------+<br/>|       8 | US         |    67 |           3 |          5 |<br/>+---------+------------+-------+-------------+------------+</span></pre><p id="eb5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上述查询的三个深度显示了结果转换获得排名的三个阶段。即</p><ol class=""><li id="6277" class="mj mk hi jq b jr js ju jv jx ml kb mm kf mn kj ns mp mq mr bi translated"><strong class="jq hj"> <em class="lh">汇总:</em> </strong>先汇总结果，</li><li id="d7e8" class="mj mk hi jq b jr ms ju mt jx mu kb mv kf mw kj ns mp mq mr bi translated"><strong class="jq hj"> <em class="lh">排名:</em> </strong>然后应用排名，<strong class="jq hj"> <em class="lh"> </em> </strong>然后</li><li id="d622" class="mj mk hi jq b jr ms ju mt jx mu kb mv kf mw kj ns mp mq mr bi translated"><strong class="jq hj"> <em class="lh">筛选:</em> </strong>筛选出需要的输出。</li></ol><p id="cc92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样。</p><h1 id="82aa" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">时间段内的排名</h1><p id="47d8" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">如果您想要计算某个特定时间段的排名，例如:本周或上周，那么我们唯一要做的事情就是将where子句附加到最内层的查询，如<code class="du mg mh mi lk b">ts BETWEEN &lt;startWeek&gt; AND &lt;endWeek&gt;</code>(假设您在score表的模式中有一个时间戳列)。</p><p id="0a0c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与用户过滤不同，在这种情况下，我们应该在计算排名之前只计算给定时间段的高分。这就是为什么我们需要将时间范围过滤放在最里面的查询中。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="3585" class="lo kl hi lk b fi lp lq l lr ls">SELECT<br/>  t.user_id,<br/>  t.country_id,<br/>  t.highScore,<br/>  RANK() OVER (PARTITION BY t.country_id <br/>               ORDER BY t.highScore DESC) AS countryRank,<br/>  RANK() OVER (ORDER BY t.highScore DESC) AS globalRank<br/>FROM (<br/>  SELECT<br/>    user_id,<br/>    country_id,<br/>    MAX(score) AS highScore<br/>  FROM score<br/>  WHERE topic_id = ? <strong class="lk hj">AND ts BETWEEN ? AND ?</strong><br/>  GROUP BY user_id, country_id<br/>) AS t</span></pre></div><div class="ab cl nt nu gp nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hb hc hd he hf"><h2 id="a79c" class="lo kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">最终注释:</h2><ul class=""><li id="41ba" class="mj mk hi jq b jr lc ju ld jx oa kb ob kf oc kj mo mp mq mr bi translated">由于内部查询的深度，这个查询看起来非常低效，但是实际上，当您使用正确的索引时，<em class="lh">它不是</em>。由于评分表可以有多个用户、主题和国家的记录，我们应该有三个单独的索引用于<em class="lh">用户标识</em>、<em class="lh">主题标识</em>和<em class="lh">国家标识</em>列。</li><li id="9c25" class="mj mk hi jq b jr ms ju mt jx mu kb mv kf mw kj mo mp mq mr bi translated">您可以用一个参数化的条件来替换条件<code class="du mg mh mi lk b">topic_id = 101</code>，比如<code class="du mg mh mi lk b">topic_id = ?</code>，这样查询就可以重用了。</li><li id="c9b1" class="mj mk hi jq b jr ms ju mt jx mu kb mv kf mw kj mo mp mq mr bi translated">上面的大多数查询都可以在任何RDBMS上工作，不需要任何改变，但是您需要关心DB对窗口查询的支持。比如MySQL版以后引入的窗口函数。</li></ul></div></div>    
</body>
</html>