<html>
<head>
<title>An Introduction to Monte Carlo: A Useful Tool to Estimate Integrals and Option Prices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蒙特卡洛介绍:估计积分和期权价格的有用工具</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/an-introduction-to-monte-carlo-a-useful-tool-to-estimate-integrals-and-option-prices-5331076222a0?source=collection_archive---------26-----------------------#2020-06-14">https://medium.com/analytics-vidhya/an-introduction-to-monte-carlo-a-useful-tool-to-estimate-integrals-and-option-prices-5331076222a0?source=collection_archive---------26-----------------------#2020-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常在数值分析中，找到问题的精确解是非常复杂的。幸运的是，通常不需要精确的答案，估计可以使问题变得更简单，从而得到一个<em class="jd">接近</em>的答案。一种这样的技术是通过蒙特卡罗，它依赖于从概率分布中重复采样随机值来执行估计。有了足够的样本，估计值会收敛到基于大数定律的平均值。</p><div class="je jf ez fb jg jh"><a href="https://www.investopedia.com/terms/l/lawoflargenumbers.asp" rel="noopener  ugc nofollow" target="_blank"><div class="ji ab dw"><div class="jj ab jk cl cj jl"><h2 class="bd hj fi z dy jm ea eb jn ed ef hh bi translated">大数定律定义</h2><div class="jo l"><h3 class="bd b fi z dy jm ea eb jn ed ef dx translated">概率和统计中的大数定律表明，随着样本量的增加，其平均值越来越接近…</h3></div><div class="jp l"><p class="bd b fp z dy jm ea eb jn ed ef dx translated">www.investopedia.com</p></div></div><div class="jq l"><div class="jr l js jt ju jq jv jw jh"/></div></div></a></div><p id="3c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蒙特卡罗的一个很好的用例是估计积分。回想一下，具有概率密度函数f(x)的随机变量E(x)的期望值可以定义为:</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es jx"><img src="../Images/391ad79ba50a881f5a52f8fd85c326f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*m4aRwpbb-8NAaWDa"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">积分界限取决于概率函数的范围</figcaption></figure><p id="cd1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果给我们一个想要估计的积分，我们可以很容易地把它转换成期望值而不是积分。例如，如果我们想计算sin(x)从0到<em class="jd"> π </em>的积分，我们可以将这个计算重写为:</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es ki"><img src="../Images/7f322c368a71fab2eb321724b372a83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*MUREhIU4QpEAx8kr_hPmMA.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">1/ <em class="kj"> π </em>是概率密度函数，是均匀分布</figcaption></figure><p id="2cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过对均匀分布重复采样来建立蒙特卡罗估计。如果我们将从0到<em class="jd"> π </em>的样本均匀地输入到sin(x)中，并取这些值的平均值，这将给出积分的估计值。蒙特卡洛听起来很复杂，但实际上，它归结为从一个分布中取样，反复代入一个方程，然后取平均值。以下代码片段显示了此处的计算:</p><pre class="jy jz ka kb fd kk kl km kn aw ko bi"><span id="3116" class="kp kq hi kl b fi kr ks l kt ku">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.stats import uniform<br/>msin_estimates = [None]*99<br/>msin_std = [None] *99</span><span id="b92f" class="kp kq hi kl b fi kv ks l kt ku">for i in range(1,100):<br/>    #sample uniformly numbers from 0 to pi<br/>    unif_array = uniform.rvs(size = i*500)*np.pi<br/>    # Plug into equation above<br/>    sin_val = np.sin(unif_array)*np.pi<br/>    # Calculate the mean which we use as the estimate<br/>    msin_estimates[i-1] = np.mean(sin_val)<br/>    msin_std[i-1] = np.std(sin_val)/np.sqrt(i*500)</span></pre><p id="26b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们把它画出来。我们可以把这些值和积分的实际值2画出来。此外，让我们绘制标准偏差图，以表明随着样本量的增加，随着平均值向实际值收敛，标准偏差也向0收敛。</p><pre class="jy jz ka kb fd kk kl km kn aw ko bi"><span id="0bd7" class="kp kq hi kl b fi kr ks l kt ku">## Graph Generation<br/>import matplotlib.pyplot as plt</span><span id="9aa1" class="kp kq hi kl b fi kv ks l kt ku">plt.plot([2]*99)<br/>plt.plot(msin_estimates, '.')<br/>plt.plot(2+np.array(msin_std)*3)<br/>plt.plot(2+np.array(msin_std)*-3)</span><span id="1c4b" class="kp kq hi kl b fi kv ks l kt ku">plt.xlabel('Sample size, per 500')<br/>plt.ylabel('Value')</span></pre><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kw"><img src="../Images/1110423e4bb8d6c5e939683889ba1c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*c4B7u7ZrjaA1qkc-Mjgdmg.png"/></div></div></figure></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="36c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蒙特卡洛的另一个应用是金融中的期权定价，其中模拟股票价格的随机波动，并使用Black-Scholes公式计算看涨和看跌期权的价格，确定期权的价值，公式如下:</p><div class="je jf ez fb jg jh"><a href="https://www.macroption.com/black-scholes-formula/" rel="noopener  ugc nofollow" target="_blank"><div class="ji ab dw"><div class="jj ab jk cl cj jl"><h2 class="bd hj fi z dy jm ea eb jn ed ef hh bi translated">布莱克-斯科尔斯公式(d1，d2，买入价格，卖出价格，希腊)</h2><div class="jo l"><h3 class="bd b fi z dy jm ea eb jn ed ef dx translated">本页解释了d1、d2、看涨期权价格、看跌期权价格的布莱克-斯科尔斯公式，以及…</h3></div><div class="jp l"><p class="bd b fp z dy jm ea eb jn ed ef dx translated">www.macroption.com</p></div></div><div class="jq l"><div class="li l js jt ju jq jv jw jh"/></div></div></a></div><p id="2ec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用以下信息估计一个欧式看跌期权的价格</p><ul class=""><li id="fe05" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">股票波动率为30%</li><li id="75ff" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">无风险利率为10%</li><li id="a0fa" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">平均股票回报率为15%</li><li id="fc9d" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">目前的股价是100美元</li><li id="e92c" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">欧式看跌期权的执行价格是110美元</li><li id="f557" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">合同期限为6个月</li></ul><p id="4aa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们使用两个辅助函数:terminal_value_of_share模拟随机行走，我们模拟Z，它来自正态分布并给出Z得分，这意味着估计值与其平均值相差多少标准差。由此我们可以代入等式，得到贴现看跌期权的价格，它也是无风险利率的一个因素。</p><pre class="jy jz ka kb fd kk kl km kn aw ko bi"><span id="decf" class="kp kq hi kl b fi kr ks l kt ku">def terminal_value_of_share(risk_free_rate, S_0, sigma,Z, T):<br/>    return S_0*np.exp((risk_free_rate-sigma**2/2)*T+sigma*np.sqrt(T)*Z)</span><span id="adeb" class="kp kq hi kl b fi kv ks l kt ku">def discounted_put_payoff(S_T, K, risk_free_rate, T):<br/>    return np.exp(-risk_free_rate*T)*np.maximum(K-S_T,0)</span></pre><p id="e137" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这种估计，我们对正态分布进行抽样，估计股票的最终价值，并由此得出看跌合约的价格。我还直接从布莱克-斯科尔斯方程计算了分析价格，看看它们是如何比较的。</p><pre class="jy jz ka kb fd kk kl km kn aw ko bi"><span id="fe66" class="kp kq hi kl b fi kr ks l kt ku">from scipy.stats import norm<br/>import math<br/>risk_free =.1<br/>S_0 = 100<br/>sigma = .3</span><span id="2919" class="kp kq hi kl b fi kv ks l kt ku"><br/>strike = 100<br/>T = .5<br/>current_time = 0</span><span id="5800" class="kp kq hi kl b fi kv ks l kt ku">put_estimates = [None] *50<br/>put_std = [None]*50</span><span id="79f3" class="kp kq hi kl b fi kv ks l kt ku">for i in range(1,51):<br/>    norm_array = norm.rvs(size=1000*i)<br/>    term_val= terminal_value_of_share( risk_free, S_0 ,sigma, norm_array, T)<br/>    put_val = discounted_put_payoff(term_val, strike, risk_free, T)<br/>    put_estimates[i-1] = np.mean(put_val)<br/>    put_std[i-1] = np.std(put_val)/np.sqrt(i*1000)</span><span id="2acf" class="kp kq hi kl b fi kv ks l kt ku">d_1 = (math.log(S_0/strike) + (risk_free +sigma**2/2)* (T))/(sigma*math.sqrt(T))<br/>d_2 = d_1 -sigma*math.sqrt(T)</span><span id="1db5" class="kp kq hi kl b fi kv ks l kt ku">analytic_putprice = -S_0*norm.cdf(-d_1) + strike*math.exp(-risk_free*(T-current_time))*norm.cdf(-d_2)</span></pre><p id="168d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据理论值绘制看跌价格估计值:</p><pre class="jy jz ka kb fd kk kl km kn aw ko bi"><span id="f5e2" class="kp kq hi kl b fi kr ks l kt ku">plt.plot(put_estimates, '.')<br/>plt.plot([analytic_putprice]*50)<br/>plt.plot(analytic_putprice + 3 *np.array(put_std), 'r')<br/>plt.plot(analytic_putprice -3 *np.array(put_std), 'r')</span><span id="2a2d" class="kp kq hi kl b fi kv ks l kt ku">plt.xlabel("Sample Size")<br/>plt.ylabel("Value")<br/>plt.show()</span></pre><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es lx"><img src="../Images/dcb3f7f9004696db32233d7dad9b7c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*m_3EvYqaGjgcD8JPhr0opQ.png"/></div></figure><p id="576a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，估计值再次收敛到理论值。我给出的例子计算起来很简单，但是在处理难以计算精确解的问题时，蒙特卡罗变得不可或缺。</p></div></div>    
</body>
</html>