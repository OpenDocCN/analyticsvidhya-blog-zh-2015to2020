<html>
<head>
<title>Selection Sort: Implementation and Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选择排序:实现和分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/selection-sort-implementation-and-analysis-27b682181883?source=collection_archive---------30-----------------------#2020-04-27">https://medium.com/analytics-vidhya/selection-sort-implementation-and-analysis-27b682181883?source=collection_archive---------30-----------------------#2020-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fa626ee0a99f81451a2b5147edb89af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1DGaNIb3wuiXtbOH"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">赫克托·j·里瓦斯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9842" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">排序在任何计算机应用中都起着重要的作用。在处理大量数据时，通过使用高效的排序算法，我们可以对数据进行排序，从而简化我们的数据分析过程。今天，我们将深入探讨一种这样的排序算法——选择排序<em class="jt">(更多算法，请看</em><a class="ae iu" href="https://getsetcode.blog/algorithms/" rel="noopener ugc nofollow" target="_blank"><em class="jt">https://getsetcode.blog/algorithms/</em></a><em class="jt">)</em></p><p id="42df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">选择排序:定义</strong></p><p id="01a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择排序是比较容易理解的算法之一。让我们先看看这种算法是如何工作的，然后分析处理数据所需的时间，最后了解随着我们输入更多数据，这种效率是如何变化的。我们还将用C#实现该算法。</p><p id="1932" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择排序作用于数组数据结构，一个简单的定义如下——“对于数组中的N个元素，循环N-1次，在每次迭代中，<strong class="ix hj"> <em class="jt">选择最小的元素并将其带到该迭代的第一个索引”</em></strong></p><p id="59d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们直接进入一个例子，并通过我们的方式来理解算法。</p><p id="4ef7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望对以下数组进行排序:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/d2f877809838f99e38a530aa1d569c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/0*o6YGJlet0f5RWrU8"/></div></figure><p id="3037" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据定义，</p><ol class=""><li id="751d" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated">我们要循环4次(<em class="jt"> N-1次)</em>。让我们称1次循环为数组的1次迭代</li><li id="e764" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">在每次迭代中，我们都要找到最小的元素，并把它带到迭代的开始位置。</li></ol><p id="7367" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了完成上述操作，我们定义变量<strong class="ix hj"> <em class="jt"> start </em> </strong>来跟踪每次迭代的开始位置，同时定义变量<strong class="ix hj"> <em class="jt"> min </em> </strong>来跟踪一次迭代中的最小元素。</p><p id="6c1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们从索引0处初始化<strong class="ix hj"> <em class="jt"> start </em> </strong>，并且<strong class="ix hj"><em class="jt">min</em></strong><em class="jt"/>等于索引0处的元素:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/afd8768cc67a3309e2ef8a225b9660d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*0nTwkYIpGcEfv5kD"/></div></div></figure><p id="001f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">迭代1 </strong></p><p id="3fc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在开始迭代数组。每当我们移动到下一个元素时，我们检查该元素是否小于我们的min元素。如果是，我们将该元素赋值给min。如果不是，min保持不变，我们继续前进到下一个元素。我们将这样做，直到到达数组的最后一个元素:</p><p id="12e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意</em> <strong class="ix hj"> <em class="jt">开始</em> </strong> <em class="jt">将始终指向数组</em>的第一个位置</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/dc54f102c5288c8bdb1f5ab859d22a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O2KbFoboiAUAbgsE"/></div></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/5af9f31c2eaa126ab774363bdb321e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5CGwc70KmfsI7gMu"/></div></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/1703eaf89a858c5e3d701db6019ad3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*DfuJMGD_SmKzju9w"/></div></figure><p id="de2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在已经到达了数组的最后一个元素，并且已经在索引3处识别出了最小的元素“0”。</p><p id="9929" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为该迭代的最后一步，我们将交换最小元素，该元素位于起始位置:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/281b9387c397e9c590f03ee32d756591.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/0*EXb3m8qt8GQD2b9E"/></div></div></figure><p id="a646" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将给出下面的数组，最小元素在第一个位置。注意，此时我们已经对第一个元素进行了排序。让我们将第一个元素变灰，以突出显示它已经被排序，并且从下一次迭代开始，我们不需要查看这个元素。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/763a11a10d9b5e4a3884d7273d655eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/0*AeQQkQRfWdwYRQyZ"/></div></figure><p id="38ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">迭代2 </strong></p><p id="37aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最后一次迭代中，我们能够对一个元素进行排序，但是我们还有四个元素要排序！因为索引0处的元素已经排序，所以我们将从索引1开始迭代。让我们再次初始化我们的<strong class="ix hj">开始</strong>和<strong class="ix hj">最小</strong>变量:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/1bbf49ad6c183e725823a28b6c64bd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*ncubFKRAMgWuCvXG"/></div></figure><p id="edbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像上次一样，我们将遍历数组，检查每个索引处的最小元素，直到到达数组的末尾:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/895157cc5588df6366a2dbb6ee762db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lBXmpHuIbEZa10s_"/></div></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/6f8d1f7d5d8b892d454c7b887e09cdf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RHGwthsQiJbEam-h"/></div></div></figure><p id="34f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在已经到达了数组的最后一个元素，并且已经确定了索引4处的最小元素。正如我们在上一次迭代中所做的那样，我们将把这个最小的元素与本次迭代开始位置的元素进行交换:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/c082dd814faaf7bf8c6f153025fd6062.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*V80KEk0vWunTZ-AL"/></div></figure><p id="9b37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一步之后，我们现在已经将数组中的前两个元素放在了正确或排序的位置:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/2f036581549ef2d51c458918d5907ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/0*oT0A6oK1iPFu52ri"/></div></figure><p id="0602" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经掌握了算法，让我们快速地做所有剩余的迭代。</p><p id="a15e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">迭代3 </strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/4bb705b514e8ff61534ae1c82800342f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UVM6dMnJ1bgOPJkj"/></div></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/2c2c6f625ddc602b8b7a0582b5896844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JwTAMm4njAt-fV6C"/></div></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es la"><img src="../Images/207b4c2ebe0371aba1faf9359f35caff.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/0*rAcCrwGK51B-xOeo"/></div></figure><p id="abab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">迭代4 </strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/3a3abed3f648633ebed4adac0b8113f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qWdwEE4M55vIjW2s"/></div></div></figure><p id="310a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，在这个迭代中，标识的最小元素是“5”，它在索引3处，也是这个迭代的<strong class="ix hj">开始</strong>索引。因此，最小元素已经处于正确的位置，我们不需要将它与任何其他元素交换:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/af3d3651942d0ef5978328919f7d6643.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/0*T7Jlw74FCYRTLySA"/></div></figure><p id="2fdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第四次迭代是我们的最后一次迭代。我们在这些迭代中排序了4个元素。我们只剩下最后一个元素，由于所有其他元素都已排序，我们可以有把握地说最后一个元素也在正确的位置。这就是选择排序对N个元素运行N-1次迭代的原因。</p><p id="cf1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">快速回顾</strong></p><ol class=""><li id="2b86" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated">对于N个元素，该算法运行N-1次迭代</li><li id="e81a" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">对于每次迭代，我们确定起始位置，并将最小元素指定为等于该起始位置的元素</li><li id="9bc4" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">我们遍历数组直到最后一个元素。对于每个元素，我们检查它是否小于最小元素。如果是，我们替换最小元素</li><li id="5b8a" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">在迭代结束时，我们已经确定了min元素，并将其与起始位置的元素交换</li></ol><p id="2ef2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用C#实现</strong></p><p id="4c20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是该算法的C#实现。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/8dc241085f934dfb1f5ccff39ca25f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/0*sEeW36sbgYJyfEbp"/></div></figure><ul class=""><li id="62b5" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js le kf kg kh bi translated"><strong class="ix hj"> arr </strong>表示要排序的数组</li><li id="6177" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js le kf kg kh bi translated"><strong class="ix hj"> start </strong>表示数组的开始位置。随着每一次迭代，我们将从1开始递增。该算法将一直运行，直到start到达数组的末尾</li><li id="e7bb" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js le kf kg kh bi translated"><strong class="ix hj"> min </strong>表示最小元素的索引。我们将它初始化为起始位置。</li></ul><p id="9785" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解代码，让我们将代码分成几部分:</p><ol class=""><li id="fcbf" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated">我们将运行该算法，直到<strong class="ix hj"> start </strong>到达数组的末尾:</li></ol><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/ed718f1f457f554ddee6c7676fcb8599.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/0*KGYdfPdzXU6K4ocY"/></div></figure><p id="a4a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.下面的for循环表示一次迭代。我们将min初始化为等于起始索引。然后，我们遍历从“start + 1”索引开始的每个元素，直到数组的末尾。我们将每个元素与“最小”索引处的元素进行比较。如果我们找到一个更小的元素，我们重新分配最小索引</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/ae3a5fdf398df1e00fe60bc970ea48fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/0*hN-BPXTJUA7jNJe_"/></div></figure><p id="a6c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.最后，如果最小索引与起始索引不同，我们交换这两个索引处的元素，将最小的元素放在第一个位置:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/2b2662a9f40ebec486138b3ba1cea884.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/0*ZvQI2spVLgAppGaY"/></div></figure><p id="008d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行上面的算法，我们得到排序后的数组:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es li"><img src="../Images/4f78e541fd29666365eafe40c7d9111f.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/0*UziC4LXdi7U5gooC"/></div></figure><p id="84bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析</strong></p><p id="cef9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在选择排序中有三个主要操作:</p><ol class=""><li id="e39f" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated"><strong class="ix hj">迭代</strong> —在我们5个元素的例子中，我们做了4次迭代。因此，我们可以说，对于N个元素，选择排序将运行N-1次迭代</li><li id="6998" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated"><strong class="ix hj">交换</strong> —在每次迭代结束时，我们执行一次交换——最小元素与第一个位置的元素交换</li><li id="f1e1" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated"><strong class="ix hj">比较</strong> —比较是我们检查每个元素是否小于最小元素时的操作。对于我们的第一次迭代，我们做了4次比较，对于第二次迭代，我们做了3次，对于第三次迭代，我们做了2次比较，对于第四次迭代，我们做了1次比较。换句话说，我们做了:(N-1) + (N-2) + (N-3) … + 1次比较。</li></ol><p id="e7c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于1次迭代，我们做了:1次交换+ N-1次比较</p><p id="14cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于(N-1)次迭代，我们将进行大约:(N-1) * (1次交换+ N-1次比较)</p><p id="cb2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们忽略上面等式中的所有常数，我们将得到N * N，或者N的平方(N)。</p><p id="ecd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，选择排序的复杂度是O(N)。</p><p id="9fc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据增加时算法的效率</strong></p><p id="77c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们推导出算法的复杂度为N的平方。如果我们插入数字，我们可以看到算法的运算次数是如何增加的:</p><p id="ff1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">N = 5，N = 25</p><p id="c1a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">N = 10，N = 100</p><p id="8208" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">N = 15，N = 225</p><p id="0436" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这表明，通过增加5个元素，我们正在以非常快的速度增加操作的数量。仅仅通过从5个元素增加到10个元素，我们就增加了75个操作！当我们从10个元素增加到15个元素时，我们增加了125个操作！</p><p id="4f2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，随着数据的增加，算法效率会降低，因此在对大量数据进行排序时，选择排序不是一个好的选择。</p><p id="8849" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">总结</strong></p><ul class=""><li id="317a" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js le kf kg kh bi translated">选择排序适用于数组数据结构。它在数组中循环N-1次，并在每次循环中找到最小的元素。此元素被第一个位置的元素交换。</li><li id="d31e" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js le kf kg kh bi translated">该算法中的主要操作是<em class="jt">迭代、交换和比较。</em>通过计算运算次数，我们可以推导出选择排序的复杂度为O(N)</li><li id="5f34" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js le kf kg kh bi translated">随着输入数据的增加，算法执行的操作数量会以更快的速度增加，这使得选择排序对于大量数据来说是一个糟糕的选择。</li></ul></div></div>    
</body>
</html>