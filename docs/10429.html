<html>
<head>
<title>Asynchronous Programming in python with AsyncIO(For Beginners)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AsyncIO在python中进行异步编程(适用于初学者)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asyncio-for-beginners-d206f74651c6?source=collection_archive---------15-----------------------#2020-10-18">https://medium.com/analytics-vidhya/asyncio-for-beginners-d206f74651c6?source=collection_archive---------15-----------------------#2020-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5c63acf00277c662fb96b2ff7fafea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X0-98EiQNkwBJj2vnTTqQ.jpeg"/></div></div></figure><div class=""/><p id="1ac8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将通过AsyncIO库解释Python中的异步编程。</p><p id="8ea6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在继续之前，让我们了解一些术语</p><blockquote class="jo jp jq"><p id="fd79" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hu"> <em class="ht">事件循环</em> </strong> <em class="ht"> : </em> <em class="ht">用于并发运行异步任务(可以是协程、未来或任何可唤醒的对象)，可以注册将要执行的任务，执行它们，延迟或取消它们</em></p><p id="8fe6" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">假设我们有2个异步任务(task1和task2 ),现在我在事件循环上调度这两个任务。现在假设事件循环开始执行task1并遇到IO操作，然后它将从task1收回控制权，并将其交给task2执行。当task1完成IO时，当控制权返回task 1时，它将从停止状态恢复，因此两个或更多任务可以同时运行</em></p><p id="7339" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hu"><em class="ht"/></strong><em class="ht">:如果一个对象可以用在</em> <code class="du jv jw jx jy b"><em class="ht">await</em></code> <em class="ht">或</em> <code class="du jv jw jx jy b"><em class="ht">yield from</em></code> <em class="ht">表达式中，我们说它是一个可唤醒的对象。</em></p><p id="6ae2" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">python中有三种主要类型的可用对象:协程、任务和未来。</p></blockquote><h1 id="3252" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">异步输入输出</strong></h1><p id="5067" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">AsyncIO是一个使用单线程或事件循环帮助并发运行代码的库，它基本上使用async/await API进行异步编程。</p><p id="f3ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在python 3.3中发布AsyncIO之前，我们使用线程、greenlet和多处理库来实现python中的异步编程</p><h2 id="d37e" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated">异步编程为什么需要AsyncIO？</h2><ol class=""><li id="9923" class="lq lr ht is b it kx ix ky jb ls jf lt jj lu jn lv lw lx ly bi translated">因为线程可用于同时运行多个任务，但python线程由操作系统管理，与绿色线程相比，操作系统必须进行更多的上下文切换b/w线程</li><li id="3791" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">Greenlet(绿色线程)从操作系统中取走调度程序，并自己运行调度程序，但是CPython默认情况下不使用绿色线程(这就是asyncio、gevent、PyPy等的用途)</li><li id="579a" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">通过使用多处理库，我们可以创建多个进程，我们可以让程序充分利用计算机的所有内核，但是产生进程的成本很高，因此对于I/O操作，线程在很大程度上被选择</li></ol><p id="c36b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总的来说，asyncIO是一种可读性更强、更简洁的异步编程方法。</p><h2 id="4ac1" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated">如何使用asyncIO？</h2><p id="04be" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">当asyncIO发布时，它正在使用带有基于生成器的协程的<code class="du jv jw jx jy b"><a class="ae me" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine" rel="noopener ugc nofollow" target="_blank">@asyncio.coroutine</a></code>装饰器来实现异步编程</p><p id="0792" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Asyncio生成器协同程序使用<code class="du jv jw jx jy b">yield from</code>语法来挂起协同程序。</p><p id="ae30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中,<code class="du jv jw jx jy b">some_async_task()</code>是一个基于生成器的协程，要执行这个协程，首先我们需要获得事件循环(在第11行),然后使用(<code class="du jv jw jx jy b">loop.run_until_complete)</code>)调度这个任务在一个事件循环中运行(注意:直接调用<code class="du jv jw jx jy b">some_async_task()</code>不会调度这个任务执行，它只会返回生成器对象)</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><blockquote class="jo jp jq"><p id="e00a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">此处第8行</em> <code class="du jv jw jx jy b"><em class="ht">asyncio.sleep()</em></code> <em class="ht">是一个协程(我们可以在此使用任何协程或任务/未来)当语句</em> <code class="du jv jw jx jy b"><em class="ht">yield from</em></code> <em class="ht">执行它时，它将放弃控制权返回事件循环让其他协程执行，当协程</em> <code class="du jv jw jx jy b"><em class="ht">asyncio.sleep()</em></code> <em class="ht">完成且事件循环将控制权返回</em> <code class="du jv jw jx jy b"><em class="ht">some_async_task()</em></code> <em class="ht">协程时，它将运行进一步的指令(如第9行)</em></p></blockquote></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="cbda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Python 3.5中，该语言引入了对协程的本地支持。现在我们可以使用async/await语法来定义本机协程</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><blockquote class="jo jp jq"><p id="3595" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">以<code class="du jv jw jx jy b">async def</code>为前缀的方法自动成为本机协程。</p><p id="654f" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">await</code>可用于获得可应用对象的结果(可以是协程、任务或未来)</p></blockquote><h2 id="fa88" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated"><code class="du jv jw jx jy b">How to run the event loop?</code></h2><p id="d42f" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在python 3.7之前，我们手动创建/获取事件循环，然后调度我们的任务，如下所示:</p><pre class="mf mg mh mi fd ms jy mt mu aw mv bi"><span id="0040" class="lc ka ht jy b fi mw mx l my mz"><strong class="jy hu">loop = asyncio.get_event_loop()</strong> #if there is no event loop then it will create new one. </span><span id="3ee5" class="lc ka ht jy b fi na mx l my mz"><strong class="jy hu">loop.run_until_complete(coroutine())</strong> #run until coroutine is completed.</span></pre><p id="99f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在python 3.7及更高版本中，以下是运行事件循环的首选方式</p><pre class="mf mg mh mi fd ms jy mt mu aw mv bi"><span id="56e1" class="lc ka ht jy b fi mw mx l my mz"><strong class="jy hu">asyncio.run(coroutine())</strong></span><span id="71bc" class="lc ka ht jy b fi na mx l my mz"># This function runs the passed coroutine, taking care of managing the asyncio event loop and <em class="jr">finalizing asynchronous generators</em>.</span></pre><p id="105c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">AsyncIO提供高级API和低级API，一般来说，应用程序开发人员使用高级API，库或框架开发人员使用低级API</p><h2 id="047e" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated"><code class="du jv jw jx jy b"><strong class="ak">Futures</strong></code> <strong class="ak">在Asyncio </strong></h2><p id="dd0b" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">它是一个低级的可感知的对象，应该在未来有一个结果。</p><p id="b317" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当一个未来对象被等待时，这意味着协程将一直等待，直到该未来对象在某个其它地方被解析。</p><p id="3f73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个API允许基于回调的代码与async/await一起使用</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="f06d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常在应用程序级代码中，我们不处理未来对象，它通常由asyncio API或库公开。</p><h2 id="7e09" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated">AsyncIO中的任务</h2><p id="3573" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">Task是futures的子类，用于在一个事件循环中同时运行协同程序。</p><p id="47fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建任务有多种方式:</p><ul class=""><li id="dcf8" class="lq lr ht is b it iu ix iy jb nb jf nc jj nd jn ne lw lx ly bi translated"><code class="du jv jw jx jy b">loop.create_task()</code> →通过低级API，它只接受协程。</li><li id="1ccf" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn ne lw lx ly bi translated"><code class="du jv jw jx jy b">asyncio.ensure_future()</code> →通过低级API，它可以接受任何可用的对象，这将在所有python版本上工作，但可读性较差。</li><li id="d463" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn ne lw lx ly bi translated"><code class="du jv jw jx jy b">asyncio.create_task()</code> →通过高级API，它在Python 3.7+中工作，接受协程并将它们包装成任务</li></ul><h2 id="9890" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated">asyncio.create_task()</h2><p id="d2ca" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">当一个协程被打包到一个具有类似于<code class="du jv jw jx jy b">asyncio.create_task()</code>的功能的任务中时，这个协程会被自动调度为很快运行</p><p id="c715" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，我使用<code class="du jv jw jx jy b">aiohttp</code>库从黑客新闻公共API获取新闻文章，我创建了两个任务(任务1和任务2)来同时获取两条不同的新闻，并显示两条新闻文章的标题。</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="3860" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">asyncio . assure _ future</strong>()类似于<code class="du jv jw jx jy b">asyncio.create_task()</code>，但它也可以接受未来，如下例所示</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="8550" class="lc ka ht bd kb ld le lf kf lg lh li kj jb lj lk kn jf ll lm kr jj ln lo kv lp bi translated">asyncio . gather(* a waitiable _ objects，return_exceptions)</h2><p id="847d" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">它负责收集所有的结果，它将等待所有的awaitables对象完成，并按照给定的await ables对象的顺序返回结果</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="ec49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果任何一个可用对象出现异常，它不会取消其他可用对象</p><p id="09cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，我们同时运行两个任务，我们可以看到，如果<code class="du jv jw jx jy b">some_async_task2</code>出现异常，它不会取消<code class="du jv jw jx jy b">some_async_task()</code>协程</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="7f7e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果return_exceptions为假，并且在任何一个合适的对象中出现任何异常，那么<code class="du jv jw jx jy b">await asyncio.gather()</code>立即返回并在屏幕上显示一个错误。因此，出于演示目的，在第17行，我们正在等待另一个协程(它将在6秒后解析),以确保程序不会在4秒后退出</p><p id="6b28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以在输出中看到第6行的执行</p><p id="c0d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想在一个数组中收集所有的结果(连同异常),那么我们可以使用return_exceptions=True，它将异常作为一个结果，并且它将被聚集在结果列表中。</p><figure class="mf mg mh mi fd hk"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="b0ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在就这样，将来，我会写关于我们如何利用Django的AsyncIO库和ASGI</p></div></div>    
</body>
</html>