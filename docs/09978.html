<html>
<head>
<title>DFS in Binary tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树中的 DFS</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dfs-in-binary-tree-c44715d09480?source=collection_archive---------18-----------------------#2020-09-28">https://medium.com/analytics-vidhya/dfs-in-binary-tree-c44715d09480?source=collection_archive---------18-----------------------#2020-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="cb5f" class="ig ih hi bd ii ij ik il im in io ip dx translated">为了理解二叉树中的深度优先搜索，我们首先需要知道它为什么被称为深度优先搜索。</p></blockquote><p id="ed5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ip hb bi translated">二叉树是承载数据的节点的分层表示。每个节点包含三个字段，一个用于存储我们最终要传递的值，另外两个字段存储左右子节点的地址。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es jn"><img src="../Images/2bfcdfba9e387a43ed1a389a1a1289fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkHudN1JNZY_mldsWWGvfw.png"/></div></div></figure><p id="80cd" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">就像每个层次结构一样，树也有一个参考点。我们称之为<strong class="is hj">根</strong>，是树的最顶端节点，没有父节点。在二叉树中，根最多有两个子节点。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es ke"><img src="../Images/18f10dbf3eef3a8705e2f686f9e11ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*JQW6GHdp42pRjYru1MKsDw.png"/></div></figure><p id="e6f0" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">如果你已经注意到了，树不是线性数据结构，我们不能像在线性数据结构(数组、列表、堆栈)中那样通过索引来访问节点。</p><p id="7ef3" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated"><em class="kf">那么，我们将如何探索这个看起来复杂的结构呢？</em></p><p id="54f0" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated"><em class="kf">在这里，树遍历算法来拯救。我们主要使用两种技术来遍历二叉树。</em></p><blockquote class="if"><p id="1a91" class="ig ih hi bd ii ij kg kh ki kj kk ip dx translated">深度优先搜索</p><p id="86dd" class="ig ih hi bd ii ij kg kh ki kj kk ip dx translated">横向优先搜索</p></blockquote><p id="1d3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ip hb bi translated"><strong class="is hj">顾名思义，DFS 通过递归地深入遍历树，直到可以遍历为止，然后回溯到先前访问过的节点。而 BFS 一层一层地遍历树。</strong></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es ks"><img src="../Images/b8d529de7ef3d03131cc30f193b1f154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0gERPUlAvDCu8p5FRMEGQ.jpeg"/></div></div></figure><p id="49fd" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">想象一下，你在一个迷宫游戏中，你选择一条路，标记你走过的那条路，这样你就不会走第二遍，探索直到你找到终点。一旦你到达终点，你回到先前走过的路，从那一点开始探索，重复这个过程直到你找到出口。</p><p id="f456" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">嗯，DFS 的工作方式完全一样。</p><p id="60ea" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">树中有三种类型的 DFS</p><ul class=""><li id="a653" class="kt ku hi is b it jz ix ka jb kv jf kw jj kx ip ky kz la lb bi translated"><strong class="is hj">预订</strong></li><li id="becd" class="kt ku hi is b it lc ix ld jb le jf lf jj lg ip ky kz la lb bi translated"><strong class="is hj">为了</strong></li><li id="db9a" class="kt ku hi is b it lc ix ld jb le jf lf jj lg ip ky kz la lb bi translated"><strong class="is hj">后序</strong></li></ul><h2 id="59ca" class="lh li hi bd lj lk ll lm ln lo lp lq lr jb ls lt lu jf lv lw lx jj ly lz ma mb bi translated">预定:-父→左→右</h2><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mc"><img src="../Images/87025cf0e0324e1479467f999344cea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kw_LK8L20u7ehzZmgjdJuQ.png"/></div></div></figure><h2 id="40ac" class="lh li hi bd lj lk ll lm ln lo lp lq lr jb ls lt lu jf lv lw lx jj ly lz ma mb bi translated">顺序:-左→父→右</h2><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es md"><img src="../Images/19a784a3f8c5ea0afa5adb96d77edfef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Y7jRLhFgsQF9GlT-3-5KQ.png"/></div></div></figure><h2 id="390e" class="lh li hi bd lj lk ll lm ln lo lp lq lr jb ls lt lu jf lv lw lx jj ly lz ma mb bi translated">后序:-左→右→父</h2><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es me"><img src="../Images/63afb9fe98f6b08e5ecd7431ab7235d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhzbiWlW3BfdSSWDP69oEA.png"/></div></div></figure><p id="47dc" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">正如你在上面注意到的，我们写了三个略有不同的方法。在第一种情况下，我们检查父节点是否存在，如果存在，我们打印当前节点数据。然后，我们进入第二步，递归地调用左边的孩子，直到没有左边的孩子。一旦我们到达那个点，我们移动到父节点的右边，并遵循同样的程序。</p><p id="d106" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">在第二种情况下，我们首先探索父节点的左侧，一旦我们到达端点，函数打印当前节点数据并移向右边的子节点。</p><p id="0e48" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">在后序中也会发生类似的情况，这里我们首先研究了左右子节点，然后再回到父节点。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="31bd" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm ip hb bi translated">感谢您阅读本文，希望您喜欢。</p></div></div>    
</body>
</html>