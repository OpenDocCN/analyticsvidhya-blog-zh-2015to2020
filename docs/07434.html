<html>
<head>
<title>Visualizing Devanagari numerals using PCA and TSNE (pt 1/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用主成分分析和TSNE可视化梵文数字(第1/2部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/visualizing-devanagari-numerals-using-pca-and-tsne-pt-1-2-df15d343bddf?source=collection_archive---------19-----------------------#2020-06-25">https://medium.com/analytics-vidhya/visualizing-devanagari-numerals-using-pca-and-tsne-pt-1-2-df15d343bddf?source=collection_archive---------19-----------------------#2020-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c6ad1ca853feaf6670702e4b6b55badb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XO4BqpS4Pw0r5IaQ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">凯文·Ku在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3777" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主成分分析(PCA)和TSNE是机器学习中最常用的降维技术，后者更有效。</p><p id="8f71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了用于降低维度，我们还可以利用其强大的功能在2D和3D中可视化多维数据集。所以事不宜迟，让我们开始吧。</p><h1 id="552c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数据集概述</h1><p id="d137" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">该数据集包含由20000幅图像[32 x 32 px]组成的梵文数字。</p><p id="a702" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从可视化的角度来看，我们有:</p><ul class=""><li id="97c0" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">1024个灰度级(0到255)像素值的输入特征。</li><li id="5517" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">对应于数字图像的类别标签。</li><li id="2b8c" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">列“字符”代表对应于每个图像的梵文字符名称。</li></ul><p id="c6fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可能看起来有点吓人，但相信我，我们不会在这里使用任何火箭科学，这都是简单的数学</p><div class="lk ll ez fb lm ln"><a href="https://www.kaggle.com/dipbazz/devanagari-numerals-datasets" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">梵文数字数据集</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">Kaggle是世界上最大的数据科学社区，拥有强大的工具和资源来帮助您实现您的数据…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">www.kaggle.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb io ln"/></div></div></a></div><h1 id="d2d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">主成分分析</h1><p id="de18" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">主成分分析可以被认为是将大维度的数据投射到较小的维度上，使得在这个过程中丢失的信息最少。在我们的例子中，我们将尝试建立一个二维空间，这样在投影这些点时，丢失的信息最少。用数学术语来说，我们必须找出方差最大的向量。</p><p id="053c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管我们可以使用内置的scikit-learn库来执行可视化，但让我通过执行幕后发生的所有数学运算来带您了解整个过程。</p><p id="9e94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是首先让我们加载数据集，并通过使用简单的python库来更好地了解它。(<em class="mc">跟着它会很有趣</em>)</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="3e25" class="mm ju hi mi b fi mn mo l mp mq">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/><br/>data_set=pd.read_csv('./digit_data.csv')  #load the digit dataset</span><span id="e170" class="mm ju hi mi b fi mr mo l mp mq">print(data_set.head(5))  #printing out first 5 rows of the dataset</span></pre><p id="42b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里没有什么特别的，我们刚刚加载了数据集并打印了前五行，因为您会很快注意到我们有1027个要素，其中1024个是像素值，3个要素或多或少类似于分类标签，因此我们将使用其中一个要素并删除其余的要素。</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="e9f2" class="mm ju hi mi b fi mn mo l mp mq">labels=data_set['labels']  #storing the class labels into labels </span><span id="a446" class="mm ju hi mi b fi mr mo l mp mq">#drop all other class labels<br/>data=data_set.drop(['labels','devanagari_labels','character'],axis=1)</span></pre><p id="3c19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，让我们通过绘制灰度图像来查看我们的数字。您可以通过更改“num”的值来绘制不同数字的图像，从而对代码进行修改。(<em class="mc">你可以跳过这一部分，但这有什么好玩的呢)</em></p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="8906" class="mm ju hi mi b fi mn mo l mp mq">plt.figure(figsize(7,7))<br/>num=12000<br/>grid_data=data.iloc[x].to_numpy().reshape(32,32)</span><span id="d14b" class="mm ju hi mi b fi mr mo l mp mq">plt.imshow(grid_data,interpolation='none',cmap='gray')</span><span id="afdd" class="mm ju hi mi b fi mr mo l mp mq">plt.show()</span><span id="abec" class="mm ju hi mi b fi mr mo l mp mq">print(label[num])  # printing the class of digit [0-9]</span></pre><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/f1196bc157614cb0f03461792d161806.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*Q__wGPaOb6VXSyRCxOn1Qw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数字6的梵文数字</figcaption></figure><h2 id="8adf" class="mm ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated"><strong class="ak">栏目标准化</strong></h2><p id="fe15" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们现在将对数据进行列标准化，使平均值和方差变为0和1。列标准化有很多内容，我们不可能在这里介绍！所以，继续前进！</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="b56c" class="mm ju hi mi b fi mn mo l mp mq">from sklearn.preprocessing import StandardScaler<br/>standardized_data=StandardScaler().fit_transform(data)</span></pre><h2 id="3487" class="mm ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">救援的特征向量</h2><p id="0e6e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在手头的问题是提出方差最大的2维空间，即关于数据的最大信息将被保留。</p><p id="5b27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是协方差矩阵的特征向量保留了最大方差。保留的信息量取决于本征向量的本征值，即较高的本征值表示较高的信息量。我们将利用这个性质得到我们的二维空间。</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="bde8" class="mm ju hi mi b fi mn mo l mp mq">from scipy.linalg import eigh <br/>sample_data=standardized_data </span><span id="28fa" class="mm ju hi mi b fi mr mo l mp mq">#calcualting the covariance matrix<br/>covar_matrix=np.matmul(sample_data.T,standardized_data)</span><span id="466e" class="mm ju hi mi b fi mr mo l mp mq">values,vectors=eigh(covar_matrix,eigvals=(1022,1023))</span><span id="3ded" class="mm ju hi mi b fi mr mo l mp mq">vectors=vectors.T</span></pre><p id="94d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">准备好我们的二维空间后，我们将把我们的数据点投影到这个平面上，以获得将用于PCA可视化的更新的点。</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="2e39" class="mm ju hi mi b fi mn mo l mp mq">#<strong class="mi hj"><em class="mc">projecting onto the 2 dimensional plan</em></strong><br/>new_coordinates=np.matmul(vectors,sample_data.T)</span><span id="0e8c" class="mm ju hi mi b fi mr mo l mp mq">new_coordinates=np.vstack((new_coordinates,labels)).T</span></pre><p id="0bda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">瞧吧！我们已经完成了，现在让我们把这些点标出来，想象一下我们的努力。</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="e604" class="mm ju hi mi b fi mn mo l mp mq">import seaborn as sns</span><span id="9997" class="mm ju hi mi b fi mr mo l mp mq">#<strong class="mi hj">creating the dataframe from new coordinates</strong></span><span id="1d28" class="mm ju hi mi b fi mr mo l mp mq">dataframe=pd.DataFrame(data=new_coordinates,columns=("1st_Principal","2nd_Principal","label"))</span><span id="e8db" class="mm ju hi mi b fi mr mo l mp mq">sns.FacetGrid(dataframe,hue='label',height=6).map(plt.scatter,'1st_Principal','2nd_Principal').add_legend()</span><span id="3a8f" class="mm ju hi mi b fi mr mo l mp mq">plt.show()</span></pre><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/4673b8924cc864b8ca22794a436295e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*NxgpkkbmLR4SBWhfao7SfQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">梵文数字的PCA</figcaption></figure><p id="aa56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在下一篇文章中研究TSNE可视化，您将会惊讶地看到绘制在7x7图表上的信息量。</p><div class="lk ll ez fb lm ln"><a rel="noopener follow" target="_blank" href="/@shuklapoornendu/visualizing-devanagari-numerals-using-pca-and-tsne-pt-2-2-3359f08dda94"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">使用主成分分析和TSNE可视化梵文数字(第2/2部分)</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">在我们开始之前，如果你是第一次看到这篇文章，那么请看看这篇文章的第一部分…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">medium.com</p></div></div><div class="lw l"><div class="nh l ly lz ma lw mb io ln"/></div></div></a></div><h2 id="ab9f" class="mm ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">结论</h2><p id="343d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">虽然，上面的图看起来有点模糊和随机，但有几件事，人们可以通过看它推断出来:-</p><ul class=""><li id="0097" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">我们的数据集中的大多数点被分组在一起，即所有的1形成一个定义明确的簇，并且对于大多数点也是如此。</li><li id="97eb" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">似乎有数据点在彼此之上的插值，因此我们不能真正区分所有的2是否正在形成任何簇。</li><li id="9be4" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">关于代表7的数据点的信息几乎可以忽略不计。</li></ul><p id="43d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">PCA并没有真正考虑到点之间的邻域属性，因此我们无法确定聚类中点的一致性。</p></div></div>    
</body>
</html>