<html>
<head>
<title>Optimizing Sklearn Ensembles (with homogeneous weights)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Sklearn集成(具有均匀权重)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/optimizing-sklearn-ensembles-with-homogeneous-weights-2db698a72b7a?source=collection_archive---------8-----------------------#2019-10-28">https://medium.com/analytics-vidhya/optimizing-sklearn-ensembles-with-homogeneous-weights-2db698a72b7a?source=collection_archive---------8-----------------------#2019-10-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="095f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个人都知道Python的Scikit-Learn包的不可思议的潜力。在它的资源中，有一种回归器通过回归器委员会的投票(平均)来起作用。那就是<a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.VotingRegressor.html" rel="noopener ugc nofollow" target="_blank">投票回归量</a>。</p><p id="890b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇短文中，我将展示一种选择最佳回归变量的方法，将委员会或回归变量与遗传算法相结合。</p><p id="d3bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一，遗传算法会优化什么？—回归变量集中每个回归变量的参数，然后它将寻找最佳回归变量集来整合委员会。所以让我们开始吧。</p><p id="1669" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将制作一个名为<strong class="ih hj">的Python类ensemble_search。</strong></p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e28f" class="jn jo hi jj b fi jp jq l jr js">import numpy as np<br/>import random<br/>from tqdm import tqdm<br/>from sklearn.metrics import mean_absolute_error as mae<br/>from sklearn.metrics import mean_squared_error as mse<br/>from sklearn.linear_model import LinearRegression as LR<br/>from sklearn.ensemble import RandomForestRegressor as RFR<br/>from sklearn.svm import SVR <br/>from sklearn.ensemble import AdaBoostRegressor as ADA<br/>from sklearn.ensemble import BaggingRegressor as BAG<br/>from sklearn.ensemble import GradientBoostingRegressor as GBR<br/>from sklearn.linear_model import RANSACRegressor as RAN<br/>from sklearn.linear_model import PassiveAggressiveRegressor as PAR<br/>from sklearn.linear_model import SGDRegressor as SGD<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import VotingRegressor<br/>from sklearn.datasets import make_regression<br/>from sklearn import preprocessing</span></pre><p id="1b7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是将要使用的包和回归模型。回归模型越多越好。</p><p id="9aaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该类将使用您的数据的训练/测试部分、您的群体大小以及您希望它运行的最大时期数进行初始化。</p><p id="16e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面显示了该类的完整代码以及如何在一些回归数据上运行它的示例。每种方法都在后面解释。这里是github中<a class="ae jd" href="https://github.com/hugoabreu1002/Optimizaded_Ensemble_Sklean" rel="noopener ugc nofollow" target="_blank">代码</a>的链接。</p><figure class="je jf jg jh fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">密码</figcaption></figure><p id="cca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> gen_population </strong>如其所言，用于生成人口，这是一个列表的列表。填充列表中的每个列表都由另一个列表组成，现在是regeressors名称、对象及其参数(这是一个字典)。群体(列表)中的个体(列表)是许多模型的串联，这些模型在for循环中进一步参数化。模型可以重复。</p><p id="5558" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">群体中的每个个体都用一些随机参数初始化。回归量的数量也是一个需要优化的参数。</p><p id="5c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> set_fitness </strong>方法用于为群体中的每个个体赋予一个适应值，这里使用的是预测回归和真实y set (y_test)之间的MAE(平均绝对误差)。</p><p id="3ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> next_population </strong>方法的作用是对种群执行交叉。在调用这个方法之前，群体必须从最好的个体到最差的个体进行排序。然后，该方法将每个回归变量的参数混合到群体的个体中。</p><p id="6298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> early_stop </strong>是在算法完成所有历元之前停止算法，只有在历元上的适应度达到最小值时才停止算法。最后2个二阶导数的平均值大于零，而一阶导数的平均值接近零。</p><p id="92ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> search_best </strong>是一种将所有东西粘在一起的方法，生成给定大小的种群，为种群中的每个个体设置适应度，对个体进行排序以了解最佳和最差，并执行交叉。所有这些步骤都在一个循环中完成，而没有达到最大次数或停止条件。</p><p id="b0ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，为了检验算法是否有效，我们对make_regression样本进行了一次测试。</p></div></div>    
</body>
</html>