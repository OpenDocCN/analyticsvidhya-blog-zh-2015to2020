<html>
<head>
<title>Image Equalization (Contrast Enhancing) in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的图像均衡(对比度增强)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-equalization-contrast-enhancing-in-python-82600d3b371c?source=collection_archive---------2-----------------------#2020-11-27">https://medium.com/analytics-vidhya/image-equalization-contrast-enhancing-in-python-82600d3b371c?source=collection_archive---------2-----------------------#2020-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c0e295add404486e5ca6c05f65ca5bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rn0uOW-9xlnVNiGG"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安德烈亚斯·古尔霍恩在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8b04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我练习图像处理已经有一段时间了——处理图像(准确地说是图像矩阵)。在此过程中，我开始探索图像的均衡方法，以便在一定程度上增强<a class="ae iu" href="https://theailearner.com/2019/01/30/what-is-contrast-in-image-processing/" rel="noopener ugc nofollow" target="_blank">对比度</a>，使处理后的图像看起来比原始图像更好。这种技术被称为<a class="ae iu" href="https://en.wikipedia.org/wiki/Histogram_equalization" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">直方图均衡</strong> </a>。</p><p id="785f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经常发生的情况是，当图像被捕获时，它将不会与自然视图相同。为了满足自然视图的水平，需要进行后期处理。因此，直方图均衡化(标准化)是通过调整图像的像素值来增强对比度的技术之一。</p><p id="7d43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个例子——原始图像和均衡图像。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/bf5e9a5446a714634152cddeb7e28208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*zE73QdA0uJ3Y6Cba.png"/></div></figure><p id="26f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们要绘制图像直方图，它看起来会像下面这样</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/1fbc5fe045e3893a8537c236f036ca76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wawG_Zjj_ati0z6w.png"/></div></div></figure><p id="9ef4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">鸣谢</strong> —以上图片取自互联网，用于展示示例。</p><h1 id="e4e5" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">直方图均衡化的重要性</h1><ul class=""><li id="af00" class="kx ky hi ix b iy kz jc la jg lb jk lc jo ld js le lf lg lh bi translated">这种方法对于明亮和黑暗的图像都更有效，特别是在医学领域中，在分析 X 射线图像中具有更高的重要性。</li><li id="e706" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">它也非常有助于查看科学图像，如热图像和卫星图像。</li></ul><h1 id="d335" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">履行</h1><p id="bac1" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">在本文中，我将通过使用<code class="du lq lr ls lt b">openCV</code>库和从头开始使用<code class="du lq lr ls lt b">NumPy</code>和<code class="du lq lr ls lt b">Matplotlib</code>来实现这个方法。虽然我想不使用<code class="du lq lr ls lt b">NumPy</code>，但计算起来会花费很多时间。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/18305c130ac5255d7e7a39a385ec518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Nm7Ec_i9OjDnCPM59Nkdg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="07f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>——对于从头开始编码，我将使用<code class="du lq lr ls lt b">openCV</code>来读取图像，而不是其他。</p><p id="f363" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经采取了<a class="ae iu" href="https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png" rel="noopener ugc nofollow" target="_blank">莉娜图像</a>测试功能。我已经在我的工作目录中保存了相同的内容。</p><h1 id="501b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">导入需求</h1><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h1 id="ffbd" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">阅读图像</h1><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="6f6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述函数读取<code class="du lq lr ls lt b">gray_scale</code>或<code class="du lq lr ls lt b">RGB</code>中的图像，并返回图像矩阵。</p><h1 id="6a3a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">用库实现代码</h1><p id="5bf6" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">对于均衡，我们可以简单地使用库<code class="du lq lr ls lt b">cv2</code>中可用的<code class="du lq lr ls lt b">equalizeHist()</code>方法。我们有两个方面-</p><ol class=""><li id="5401" class="kx ky hi ix b iy iz jc jd jg lx jk ly jo lz js ma lf lg lh bi translated">当图像被读入<code class="du lq lr ls lt b">RGB</code>时。</li></ol><ul class=""><li id="f3ee" class="kx ky hi ix b iy iz jc jd jg lx jk ly jo lz js le lf lg lh bi translated">根据颜色组合分离像素。我们可以使用图书馆<code class="du lq lr ls lt b">cv2</code>里的<code class="du lq lr ls lt b">split()</code>方法。</li><li id="8625" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">对每个矩阵应用均衡方法。</li><li id="ac34" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">使用库<code class="du lq lr ls lt b">cv2</code>中可用的方法<code class="du lq lr ls lt b">merge()</code>合并均衡后的图像矩阵。</li></ul><p id="ac29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.在<code class="du lq lr ls lt b">gray_scale</code>中读取图像时。</p><p id="5afe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.绘制原始图像和均衡图像。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="0c4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们测试一下上面的函数—</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/97ca83444a8b61422651567d1305881a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*jkgyHHYX0CmlC2tuRAD_Lg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/00d1e354dbc73c892b4c8ef34cb9cb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*2ffxh1TIgNfNq5IfuqYDhA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="d9dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的图很清楚，我们可以说均衡后的图像比原始图像看起来更好。这是使用<code class="du lq lr ls lt b">cv2</code>库实现的。</p><h1 id="3e27" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">从头开始代码实现</h1><p id="8ac1" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">为此，我使用<code class="du lq lr ls lt b">NumPy</code>进行所有的矩阵运算。同样，我们可以用<code class="du lq lr ls lt b">for</code>循环来做，但是这将花费更多的时间来计算。即使在这里，我们也和以前一样有两个方面-</p><ol class=""><li id="fa86" class="kx ky hi ix b iy iz jc jd jg lx jk ly jo lz js ma lf lg lh bi translated">在<code class="du lq lr ls lt b">RGB</code>中读取图像时。</li></ol><ul class=""><li id="0b6d" class="kx ky hi ix b iy iz jc jd jg lx jk ly jo lz js le lf lg lh bi translated">根据颜色组合分离像素。我们可以使用<code class="du lq lr ls lt b">NumPy</code>操作对其进行分割。</li><li id="d5fa" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">对每个矩阵应用均衡方法。</li><li id="8371" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">使用库<code class="du lq lr ls lt b">NumPy</code>中可用的方法<code class="du lq lr ls lt b">dstack(tup=())</code>合并均衡后的图像矩阵。</li></ul><p id="fe52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.在<code class="du lq lr ls lt b">gray_scale</code>中读取图像时。</p><p id="6b79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.绘制原始图像和均衡图像。</p><p id="8b95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们编写自己的函数来计算图像均衡。图像像素值通常在 0 到 255 的范围内。所以总共，我们将有 256 个像素。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="4790" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">演职员表</strong> —以上代码是从<strong class="ix hj"> <em class="mc">托利·沃克</em> </strong>写的<a class="ae iu" rel="noopener" href="/hackernoon/histogram-equalization-in-python-from-scratch-ebb9c8aa3f23">文章</a>中得到的灵感。</p><p id="82d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当原始图像矩阵作为参数传递时，上面的函数返回均衡的图像矩阵。</p><p id="bf06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们编写另一个函数，使用上述函数计算<code class="du lq lr ls lt b">RGB</code>图像和<code class="du lq lr ls lt b">gray_scale</code>图像的均衡。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="54ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们测试一下上面的函数—</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/aaa35dc5c9fc878546d4bbdff51f0712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*MX4HEIiPi5TaS4i_"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/d618ccd4356db425abd37845516e7dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*A0NQtrC6n6Zij-Id"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="5d49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的图很清楚，我们可以说均衡后的图像比原始图像看起来更好。这是使用<code class="du lq lr ls lt b">NumPy</code>库从头开始实现的。</p><h1 id="bc6e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">比较</h1><p id="3b1f" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">让我们比较一下从<code class="du lq lr ls lt b">cv2</code>库中获得的均衡图像和从零开始编写的代码获得的均衡图像。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/435228ff942e392dc9aeb6515a65f788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*CpwWw8OcZ7p6Np76"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="2c02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以注意到<code class="du lq lr ls lt b">library image</code>和<code class="du lq lr ls lt b">scratch image</code>之间有一点点不同。但与<code class="du lq lr ls lt b">original image</code>相比，两者似乎都很清晰。在这里我用自己的外卖来完成我的文章。</p><h1 id="e5b8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">外卖食品</h1><ul class=""><li id="5f08" class="kx ky hi ix b iy kz jc la jg lb jk lc jo ld js le lf lg lh bi translated">就我个人而言，通过探索和实施不同的方法来增加图像强度，我学到了很多。特别是，通过参考和学习，尝试从零开始实现代码。</li><li id="d942" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">使用库方法总是好的，因为它们看起来更优化并且 100%有效。</li><li id="77b0" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js le lf lg lh bi translated">图像处理是一个非常重要的学习科目，一个人真的值得带着如此多的好奇心和自己的探索去尝试实践。</li></ul><p id="e40d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请阅读我的其他文章，让我知道你的想法</p><ol class=""><li id="9d4a" class="kx ky hi ix b iy iz jc jd jg lx jk ly jo lz js ma lf lg lh bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/image-flipping-and-mirroring-with-numpy-and-opencv-aecc08558679">图像镜像和翻转</a></li><li id="344a" class="kx ky hi ix b iy li jc lj jg lk jk ll jo lm js ma lf lg lh bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/image-convolution-from-scratch-d99bf639c32a">图像卷积</a></li></ol></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="9378" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢，你可以在这里给我买咖啡。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://www.buymeacoffee.com/msameeruddin"><div class="er es mk"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a></figure></div></div>    
</body>
</html>