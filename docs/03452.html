<html>
<head>
<title>RESTful API, How to| Part 2 — Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RESTful API，如何|第2部分—实现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/restful-api-how-to-part-2-implementation-e3bca6072b70?source=collection_archive---------7-----------------------#2020-02-02">https://medium.com/analytics-vidhya/restful-api-how-to-part-2-implementation-e3bca6072b70?source=collection_archive---------7-----------------------#2020-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/26217e8b04e7bb3598c08fcc82e2ec3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TWsDMnzMQyUYhTP1"/></div></div></figure><p id="0210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设计和实施服务是我日常工作的一部分，我想分享一些最佳实践和技巧，可以帮助你的工作。</p><p id="ce63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个关于RESTful API的系列文章中，我将讨论几个主题:</p><ul class=""><li id="b70c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/analytics-vidhya/restful-api-how-to-part-1-design-4f89803dff15">设计</a></li><li id="48a7" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj">实施</strong></li><li id="b5d1" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">测试</li><li id="b828" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">部署</li></ul><h1 id="6a7b" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">一些信息</h1><blockquote class="lb lc ld"><p id="a9fe" class="iq ir le is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated"><em class="hi">我们将使用</em><a class="ae jx" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">swagger</em></strong></a><em class="hi">来设计我们的API，</em><a class="ae jx" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">python</em></strong></a><em class="hi">语言来创建微服务，最后</em><a class="ae jx" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">Docker</em></strong></a><em class="hi">来交付最终的解决方案。所有的代码都可以在这个</em> <a class="ae jx" href="https://github.com/dandpz/restfulapi-howto" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="hi">回购</em> </strong> </a> <em class="hi">中找到。</em></p></blockquote></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="8682" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jx" rel="noopener" href="/@daniele.dapuzzo/restful-api-how-to-part-1-design-4f89803dff15">之前的</a>文章中，我们写了我们服务的swagger描述符。多亏了Swagger编辑器，可以下载不同编程语言的自动生成的服务器(见下图)。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/3205f42165e2efb3e72f4faf1db0a665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFqKv8MsquAJ7SNW7uRyow.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">生成服务器— Swagger编辑器</figcaption></figure><p id="3ac2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在编辑器页面点击<em class="le">生成服务器</em>并选择<strong class="is hj"> python-flask </strong>，几秒钟后一个包含源代码的ZIP文件就会下载到你的电脑上。</p><p id="8f81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成的服务器是我们服务的一个存根，但是让我们避免创建项目、所有模型等所有无聊的东西，只留下业务逻辑来实现。它利用了<a class="ae jx" href="https://pypi.org/project/connexion/" rel="noopener ugc nofollow" target="_blank">连接，一个由Zalando开发的OpenAPI框架，该框架包装了基于</a><a class="ae jx" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a>处理http请求的Flask服务器。</p><h1 id="903f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">次要重构</h1><blockquote class="ly"><p id="3c62" class="lz ma hi bd mb mc md me mf mg mh jn dx translated">此重构引用了旧版本的swagger codegen，在新版本中可能没有必要。</p></blockquote><p id="51fc" class="pw-post-body-paragraph iq ir hi is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hb bi translated">乍一看，服务器似乎已经完成了，但是默认情况下它使用的是旧版本的connexion，所以让我们做一些修改来改进它。</p><p id="641b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你按照README.md的说明去做，你会注意到Swagger页面和编辑器的略有不同。</p><p id="5a6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将编辑需求:</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="f2a1" class="ms ke hi mo b fi mt mu l mv mw">flask==1.1.1<br/>werkzeug==0.16.0<br/>connexion[swagger-ui]==2.5.1<br/>python_dateutil==2.6.0<br/>setuptools==40.8.0<br/>swagger_ui_bundle==0.0.6<br/>Flask-SQLAlchemy==2.4.1</span></pre><p id="fef9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在运行应用程序之前，让我们也编辑一下<em class="le"> __main__。py </em>文件，并添加一些我们稍后会用到的文件夹和文件。特别是，我们添加了一个包含不同环境配置的文件和一个包含数据库实例的文件。稍后我们将深入了解这两者。</p><blockquote class="lb lc ld"><p id="554b" class="iq ir le is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">__main__。巴拉圭</p></blockquote><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="b607" class="ms ke hi mo b fi mt mu l mv mw">#!/usr/bin/env python3<br/><br/>import connexion<br/>from flask import Flask<br/>from swagger_ui_bundle import swagger_ui_3_path<br/>import os<br/>from swagger_server.database import db<br/><br/><br/>from swagger_server import encoder<br/><br/>options = {"swagger_path": swagger_ui_3_path}<br/><br/><br/>def create_app():<br/>    _app = connexion.App(__name__, specification_dir='./swagger/')<br/>    _app.app.json_encoder = encoder.JSONEncoder<br/>    _app.add_api('swagger.yaml', arguments={'title': 'TO-DO list'}, options=options, )<br/>    configure_app(_app.app)<br/>    init_app(_app.app)<br/>    return _app<br/><br/><br/>def configure_app(flask_app):<br/>    flask_app.config.from_object(f"swagger_server.config.{os.getenv('APPLICATION_ENV', 'Development')}")<br/><br/><br/>def init_app(flask_app: Flask):<br/>    db.init_app(flask_app)<br/><br/><br/>if __name__ == '__main__':<br/>    app = create_app()<br/>    app.run(port=app.app.config["PORT"])</span></pre><p id="342d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经设置了一些东西，我们可以继续实现业务逻辑和数据库集成了。正如你可能已经看到的，我们将使用<a class="ae jx" href="https://pypi.org/project/Flask-SQLAlchemy/" rel="noopener ugc nofollow" target="_blank"> Flask-SQLAlchemy </a>一个Flask插件在<a class="ae jx" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>之上，这是一个著名的ORM，可以让你轻松使用SQL。</p><h2 id="ffe8" class="ms ke hi bd kf mx my mz kj na nb nc kn jb nd ne kr jf nf ng kv jj nh ni kz nj bi translated">配置</h2><p id="7bd5" class="pw-post-body-paragraph iq ir hi is b it nk iv iw ix nl iz ja jb nm jd je jf nn jh ji jj no jl jm jn hb bi translated">首先，我们应该开始创建开发/测试/生产配置。</p><p id="a008" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从默认配置值的基类开始，我们一次添加一个其他的；我们将使用环境变量来定义当前设置，以便“通过配置”运行我们的应用程序。</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="2a3c" class="ms ke hi mo b fi mt mu l mv mw">import os<br/><br/><br/>class Config(object):<br/>    PORT = 8080<br/>    HOST = "0.0.0.0"<br/>    DEBUG = True<br/><br/>    SQLALCHEMY_TRACK_MODIFICATIONS = False<br/><br/><br/>class Development(Config):<br/>    SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/test.db'<br/>    FLASK_ENV = "development"<br/><br/><br/>class Testing(Config):<br/>    SQLALCHEMY_DATABASE_URI = 'sqlite:////tmp/test.db'<br/>    FLASK_ENV = "development"<br/><br/><br/>class Production(Config):<br/>    PORT = os.getenv("PORT")<br/>    HOST = os.getenv("HOST")<br/>    DEBUG = False<br/>    TESTING = False<br/>    FLASK_DEBUG = False<br/>    FLASK_ENV = "production"<br/><br/>    SQLALCHEMY_DATABASE_URI = os.getenv("DB_URI")</span></pre><p id="3c7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在__main__。py我们检查“APPLICATION_ENV”的环境变量值，如果没有找到，就给出一个默认值。</p><blockquote class="lb lc ld"><p id="49c4" class="iq ir le is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">关于生产配置的一个特别注意事项是，我不喜欢为这个设置设置默认值，这样，如果出现问题，整个应用程序就不会开始避免隐藏可能的错误或安全漏洞。</p></blockquote><h2 id="626f" class="ms ke hi bd kf mx my mz kj na nb nc kn jb nd ne kr jf nf ng kv jj nh ni kz nj bi translated">证明</h2><p id="f8eb" class="pw-post-body-paragraph iq ir hi is b it nk iv iw ix nl iz ja jb nm jd je jf nn jh ji jj no jl jm jn hb bi translated">您可能已经注意到，在尝试运行应用程序时，控制台消息显示<strong class="is hj"><em class="le">“…x-basic info func missing”</em></strong>。这是因为我们还没有定义一个方法来实现我们在API描述符中声明的身份验证。</p><p id="0f94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们开始创建一个文件<em class="le"> auth.py </em>，它包含一个方法，允许我们检查向我们的服务发送请求的客户端是否被允许这样做。</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="053b" class="ms ke hi mo b fi mt mu l mv mw">def basic_auth(username, password, required_scopes=None):<br/>    if username == 'guest' and password == 'secret':<br/>        return {<br/>            'sub': 'guest',<br/>            'valid': True<br/>        }<br/>    return None</span></pre><p id="162d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们刚刚定义了一个身份验证检查函数；这还不是全部，我们必须将这个函数链接到swagger文件，以便让Connexion将它添加到它的流中。</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="3384" class="ms ke hi mo b fi mt mu l mv mw">securityDefinitions:<br/>  BasicAuth:<br/>    type: "basic"<br/>    <strong class="mo hj">x-basicInfoFunc: "swagger_server.auth.basic_auth"</strong></span></pre><p id="be6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这只是一个例子，在现实环境中，您可能会使用Oauth2流来检查调用者是否被允许使用这个服务。但这不是本文的目的。</p><h2 id="d3dc" class="ms ke hi bd kf mx my mz kj na nb nc kn jb nd ne kr jf nf ng kv jj nh ni kz nj bi translated">数据库ˌ资料库</h2><p id="802b" class="pw-post-body-paragraph iq ir hi is b it nk iv iw ix nl iz ja jb nm jd je jf nn jh ji jj no jl jm jn hb bi translated">对于这个简单的应用程序，我们将使用<a class="ae jx" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> sqlite </a>进行开发和测试，我们将在下一篇文章中看到如何处理生产数据库。</p><p id="26e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们为将要存储在数据库中的对象创建模型。我们将创建一个DAO(数据访问对象),即一个表示数据库表模型的对象，它将包含CRUD操作的所有方法。<br/>在数据库文件夹中，我们放置了另一个名为models的文件夹(我们可以保持一个更简单的方案，但是当我们有很多模型时这很有用，所以让我们试着把它变成一种习惯)。</p><p id="bccc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于待办对象模型，我们将定义我们在API定义中描述的所有字段。这一次我们将与数据库进行交互，因此它将与生成的模型略有不同。我们还添加了助手方法来调整数据库和控制器之间的对象。</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="ea65" class="ms ke hi mo b fi mt mu l mv mw">import enum<br/><br/>from swagger_server.database import db<br/>from swagger_server.models import Todo, PaginatedResponseData<br/><br/><br/>class Status(enum.Enum):<br/>    done = "done"<br/>    late = "late"<br/>    in_progress = "in progress"<br/>    to_do = "to do"<br/><br/><br/>class TodoModel(db.Model):<br/>    __tablename__ = "todo"<br/>    id = db.Column(db.Integer, primary_key=True)<br/>    name = db.Column(db.String(64))<br/>    description = db.Column(db.String(256), nullable=True)<br/>    due_date = db.Column(db.Date, nullable=True)<br/>    status = db.Column(db.Enum(Status), nullable=False)<br/><br/>    def to_obj(self) -&gt; Todo:<br/>        return Todo(<br/>            id=self.id,<br/>            name=self.name,<br/>            description=self.description,<br/>            due_date=self.due_date,<br/>            status=self.status.value,<br/>        )<br/><br/>    def __repr__(self):<br/>        return "&lt;Todo %r&gt;" % self.name<br/><br/>    @classmethod<br/>    def from_obj(cls, obj: Todo) -&gt; "TodoModel":<br/>        return cls(<br/>            id=obj.id,<br/>            name=obj.name,<br/>            description=obj.description,<br/>            due_date=obj.due_date,<br/>            status=Status(obj.status)<br/>        )<br/><br/>    def save(self):<br/>        db.session.add(self)<br/>        db.session.commit()<br/><br/>    @classmethod<br/>    def get_all(<br/>            cls,<br/>            page: int = 1,<br/>            size: int = 20,<br/>            status: str = None<br/>    ):<br/>        if status:<br/>            query = cls.query.filter_by(status=Status(status)).paginate(page, size, False)<br/>        else:<br/>            query = cls.query.paginate(page, size, False)<br/>        total = query.total<br/>        items = query.items<br/>        return PaginatedResponseData(<br/>            page=page,<br/>            size=size,<br/>            total=total,<br/>            count=len(items),<br/>            resources=[i.to_obj() for i in items],<br/>        )<br/><br/>    @classmethod<br/>    def get_by_id(cls, _id: str) -&gt; Todo:<br/>        res = cls.query.filter_by(id=_id).first_or_404()<br/>        return res.to_obj()<br/><br/>    @classmethod<br/>    def update_by_id(cls, _id: str, body: Todo):<br/>        _ = cls.query.filter_by(id=_id).first_or_404()<br/>        cls.from_obj(body).save()<br/><br/>    @classmethod<br/>    def delete_by_id(cls, _id: str):<br/>        res = cls.query.filter_by(id=_id).first_or_404()<br/>        db.session.delete(res)<br/>        db.session.commit()<br/>        return res.to_obj()</span></pre><p id="1eff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候将控制器连接到我们的数据库了！</p><h2 id="dd36" class="ms ke hi bd kf mx my mz kj na nb nc kn jb nd ne kr jf nf ng kv jj nh ni kz nj bi translated">控制器</h2><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="470d" class="ms ke hi mo b fi mt mu l mv mw">import connexion<br/>from werkzeug.exceptions import BadRequest<br/><br/>from swagger_server.database.models.todo import TodoModel<br/>from swagger_server.models.paginated_response_data import (<br/>    PaginatedResponseData,<br/>)  # noqa: E501<br/>from swagger_server.models.todo import Todo  # noqa: E501<br/><br/><br/>def create_todo(body):  # noqa: E501<br/>    <em class="le">"""Create a new to-do<br/><br/>    Create a to-do # noqa: E501<br/><br/>    :param body: <br/>    :type body: dict | bytes<br/><br/>    :rtype: None<br/>    """<br/>    </em>if connexion.request.is_json:<br/>        body = Todo.from_dict(connexion.request.get_json())  # noqa: E501<br/>        TodoModel.from_obj(body).save()<br/>        return None, 200<br/>    else:<br/>        raise BadRequest("missing body")<br/><br/><br/>def delete_todo_by_id(todoId):  # noqa: E501<br/>    <em class="le">"""Delete existing to-do by Id<br/><br/>    Delete a to-do object if exists # noqa: E501<br/><br/>    :param todoId: <br/>    :type todoId: str<br/><br/>    :rtype: Todo<br/>    """<br/>    </em>return TodoModel.delete_by_id(todoId)<br/><br/><br/>def get_todo_by_id(todoId):  # noqa: E501<br/>    <em class="le">"""Retrieve to-do by Id<br/><br/>    Return a to-do object if exists # noqa: E501<br/><br/>    :param todoId: <br/>    :type todoId: str<br/><br/>    :rtype: Todo<br/>    """<br/>    </em>return TodoModel.get_by_id(todoId)<br/><br/><br/>def get_todo_list(status=None, page=None, size=None):  # noqa: E501<br/>    <em class="le">"""Retrieve list of to-do<br/><br/>    Return a paginated list of to-do objects # noqa: E501<br/><br/>    :param status: filter result on to-do status<br/>    :type status: str<br/>    :param page: Page number<br/>    :type page: int<br/>    :param size: Number of records to return per page<br/>    :type size: int<br/><br/>    :rtype: PaginatedResponseData<br/>    """<br/>    </em>return TodoModel.get_all(page, size, status)<br/><br/><br/>def update_todo_by_id(todoId, body):  # noqa: E501<br/>    <em class="le">"""Update existing to-do by Id<br/><br/>    Update a to-do object if exists # noqa: E501<br/><br/>    :param todoId: <br/>    :type todoId: str<br/>    :param body: <br/>    :type body: dict | bytes<br/><br/>    :rtype: None<br/>    """<br/>    </em>if connexion.request.is_json:<br/>        body = Todo.from_dict(connexion.request.get_json())  # noqa: E501<br/>        return TodoModel.update_by_id(todoId, body), 200<br/>    else:<br/>        raise BadRequest("missing body")</span></pre><p id="4e82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们刚刚将所有端点映射到DB模型的方法。</p><p id="a56b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您现在已经<strong class="is hj">准备好</strong>通过web浏览器的Swagger UI进行一个简单的测试。尝试创建一些待办事项，编辑和删除它！</p><blockquote class="lb lc ld"><p id="b35d" class="iq ir le is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">这只是熟悉UI的一个简单的手动测试。<br/>在下一篇文章中，我们将讨论测试，如何向我们的应用程序添加单元测试，以及如何使用Flask-Testing框架来模拟客户端测试我们的API。</p></blockquote><h2 id="c4cb" class="ms ke hi bd kf mx my mz kj na nb nc kn jb nd ne kr jf nf ng kv jj nh ni kz nj bi translated">记录</h2><p id="77f0" class="pw-post-body-paragraph iq ir hi is b it nk iv iw ix nl iz ja jb nm jd je jf nn jh ji jj no jl jm jn hb bi translated">我们将使用Flask的默认记录器，我们不会为这个简单的应用程序添加太多定制。如果你想了解更多关于<em class="le">烧瓶测井</em>的信息，请访问<a class="ae jx" href="https://flask.palletsprojects.com/en/1.1.x/logging/" rel="noopener ugc nofollow" target="_blank">烧瓶文档</a>。</p><p id="3095" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们想在应用程序中引入一个日志记录器，假设我们想知道发送请求的客户机的IP地址。我们可以使用烧瓶记录器:</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="5031" class="ms ke hi mo b fi mt mu l mv mw">from flask import current_app, request<br/><br/><br/>def create_todo(body):  # noqa: E501<br/>    <em class="le">"""Create a new to-do<br/><br/>    Create a to-do # noqa: E501<br/><br/>    :param body: <br/>    :type body: dict | bytes<br/><br/>    :rtype: None<br/>    """<br/>    </em>current_app.logger.debug(f"Client IP ADDRESS: {request.remote_addr}")<br/>    if connexion.request.is_json:<br/>        body = Todo.from_dict(connexion.request.get_json())  # noqa: E501<br/>        TodoModel.from_obj(body).save()<br/>        return None, 200<br/>    else:<br/>        raise BadRequest("missing body")</span></pre><p id="77f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们已经导入了<em class="le"> current_app </em>来使用记录器。一切看起来都很完美，但是正如你所看到的，使用这个方法我们应该在每个方法中添加对记录器的调用，现在它是<strong class="is hj">简单的</strong>，因为我们只想记录远程IP地址，但是<strong class="is hj">如果</strong>我们会知道其他信息，或者更糟，如果我们添加了更多信息，然后我们想要修改它们。</p><p id="e271" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用Python中的一个有用工具:装饰器。</p><p id="9832" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始在util.py中定义我们的装饰器:</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="25d5" class="ms ke hi mo b fi mt mu l mv mw">def log(func):<br/>    @wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        current_app.logger.debug(f"Client IP ADDRESS: {request.remote_addr}")<br/>        current_app.logger.debug(f"Client IP ADDRESS: {request.endpoint}")<br/>        current_app.logger.debug(f"Client IP ADDRESS: {request.user_agent}")<br/>        return func(*args, **kwargs)<br/>    return wrapper</span></pre><p id="c6c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在很容易使用它，只需将"<strong class="is hj"> @log" </strong>放在我们想要修饰的函数之前，让我们看看会发生什么:</p><pre class="lq lr ls lt fd mn mo mp mq aw mr bi"><span id="06e2" class="ms ke hi mo b fi mt mu l mv mw">@log<br/>def get_todo_list(status=None, page=None, size=None):  # noqa: E501<br/>    <em class="le">"""Retrieve list of to-do</em></span><span id="1bd0" class="ms ke hi mo b fi np mu l mv mw">--------------------</span><span id="b926" class="ms ke hi mo b fi np mu l mv mw">[2020-02-02 19:21:53,934] DEBUG in util: Client IP ADDRESS: 127.0.0.1<br/>[2020-02-02 19:21:53,934] DEBUG in util: Client IP ADDRESS: /v1.swagger_server_controllers_todo_controller_get_todo_list<br/>[2020-02-02 19:21:53,934] DEBUG in util: Client IP ADDRESS: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36</span></pre><p id="dda7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，我们现在可以在控制台中查看日志，只添加一行来修饰目标函数。如果我们想改变什么，我们只需要编辑我们的实用函数！</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="89d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是本文的全部内容，我们已经看到了如何实现我们在前面的章节中设计的内容。在下一篇文章中，我将向您展示如何向应用程序中添加测试，以及为什么它们是开发中的要素。</p><blockquote class="lb lc ld"><p id="43fd" class="iq ir le is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated"><strong class="is hj">提醒:</strong>你可以在<strong class="is hj"> </strong> <a class="ae jx" href="https://github.com/dandpz/restfulapi-howto" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">这个GitHub库找到所有更新的代码！</strong> </a></p><p id="208b" class="iq ir le is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">链接到上一篇文章:<a class="ae jx" rel="noopener" href="/analytics-vidhya/restful-api-how-to-part-1-design-4f89803dff15">https://medium . com/analytics-vid hya/restful-API-how-to-part-1-design-4f 89803 dff 15</a></p></blockquote></div></div>    
</body>
</html>