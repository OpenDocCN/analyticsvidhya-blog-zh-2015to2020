<html>
<head>
<title>Deploy a Machine Learning ONNX Model on AWS using FastApi and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用FastApi和Docker在AWS上部署机器学习ONNX模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-a-machine-learning-onnx-model-on-aws-using-fastapi-and-docker-3872c17f99b5?source=collection_archive---------8-----------------------#2020-06-03">https://medium.com/analytics-vidhya/deploy-a-machine-learning-onnx-model-on-aws-using-fastapi-and-docker-3872c17f99b5?source=collection_archive---------8-----------------------#2020-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ac0d4a2ec8f55791685336ca660f11a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1JNq-1DfEnCG1myc1ud_w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://www.slon.pics" rel="noopener ugc nofollow" target="_blank">斯隆</a>拍摄</figcaption></figure><p id="fe71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di"> T </span>关于各种机器学习模型的复杂性，有很多教程，但很少有人谈论实际创建一个生产就绪的API。数据科学家有两种角色。</p><ol class=""><li id="312d" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated">从提供给他们的数据中产生洞察力并创建模型。</li><li id="a8f2" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">开发以ML为核心的软件。</li></ol><p id="f0a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文将专注于第二部分，并将向您展示<strong class="ix hj">如何以ONNX(开放神经网络交换)格式保存机器学习模型，然后从它创建一个生产就绪的API</strong>。如果你在一家公司工作，一个非机器学习的工程师很难从你创建的模型中获得一些洞察力。同时处理机器学习和应用程序开发也变得很困难。生产就绪API使这项工作变得更加容易，因为它使您可以轻松地将您的工作与其他开发人员集成，这些开发人员可以开发出更好的web应用程序。</p><p id="dafc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于那些没有太多模型部署经验的人来说，这篇文章会很有帮助，因为他们不想直接进入复杂的模型，而是想从一个基本的模型开始。在前进之前，克隆这个 <a class="ae iu" href="https://github.com/shgoyal33/Fast_api_model" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">库</strong> </a> <strong class="ix hj">然后跟着前进。</strong></p><p id="5a6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，您将了解如何:</p><ol class=""><li id="6e8d" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated">以onnx格式保存模型。</li><li id="ad82" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">使用FastAPI和uvicorn创建一个API。</li><li id="d096" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">使用docker将应用程序容器化。</li><li id="851d" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">在AWS Elastic Beanstalk上部署Docker映像。</li><li id="ace4" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">使用python测试API。</li></ol><h1 id="1435" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">为什么不把ml模型放在后端？</h1><p id="af29" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">在继续之前，让我们先谈谈我们为什么要这样做。</p><p id="a6c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设你正在制作一个网站或移动应用程序，将使用一些机器学习模型，那么为什么不把整个代码放在后端。一些原因是:</p><ol class=""><li id="7626" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated">当模型是一个独立的实体，而不是在后端从头开始实现时，它就变得可扩展。</li><li id="4121" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">易于与多个应用程序集成，因为开发人员无需担心ML部分，可以直接使用API作为黑盒。</li></ol><p id="cba4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们开始部署。</p><h1 id="bf39" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">开放式神经网络交换(ONNX)</h1><p id="a77f" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">这是交换机器学习和深度学习模型的新标准。它使这些模型可移植，并防止供应商锁定。当模型保存在中时。onnx格式，单个onnxruntime可以用于所有不同模型的推断。本教程将向您展示如何以onnx格式保存一个简单的随机森林分类器，并从中生成推论。所有这些都将在FastAPI应用程序内部完成。</p><p id="af6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">如何将模型保存为ONNX格式？</strong></p><p id="294c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本教程，将使用一个非常传统的数据集，因为它对初学者来说更容易理解。该数据集被称为虹膜数据集。在转到代码之前，确保通过运行以下命令安装skl2onnx。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="c4fd" class="mc kr hi ly b fi md me l mf mg">pip install skl2onnx</span></pre><p id="f537" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您打开model.py文件，您将看到代码。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="3595" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个文件中有两个函数load_data()，它们加载iris数据以将列名和目标名保存在pickle文件中。</p><p id="196a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将通过传递一个字典来调用API，该字典以key作为列名(在本例中是petal_length、petal_width、sepal_length和sepal_width ),以values作为我们要分配的值。输出将是数字0、1或2。然后我们把它映射回花的名字，使它更容易理解。</p><p id="42a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个功能是我们训练一个随机森林模型并以onnx格式保存它。第42行定义了初始数据类型，在我们的例子中是FloatTensorType。我们将形状作为None传递，X.shape[1]。然后我们使用来自<strong class="ix hj"> skl2onnx </strong>的函数convert_sklearn(第45行)。在这个函数中，我们传递rf对象和输入数据类型。然后，我们打开一个文件，将模型(第48–49行)序列化为string，并将模型保存为rf_m.onnx。要了解关于onnx的更多信息，请关注<a class="ae iu" href="https://github.com/onnx/tutorials" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">和</strong> </a>。</p><p id="446d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果您理解了这一点，请打开命令行，转到包含model.py的文件夹(在本例中，它是Fast_api_model-master文件夹)，并使用</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="df7a" class="mc kr hi ly b fi md me l mf mg">python model.py</span></pre><p id="50be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行之后，你会在app文件夹中看到文件<strong class="ix hj"> rf_m.onnx，target.pickle和features.pickle </strong>。</p><h1 id="a1b3" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">使用FastAPI创建端点</h1><p id="9491" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">大多数关于云部署的文章讨论的都是Flask，这没什么不对，但是与FastAPI相比，它没有那么快。就像Flask一样，可以用最少的代码<strong class="ix hj">创建一个端点。它自动创建<strong class="ix hj">开放API(Swagger) </strong>和<strong class="ix hj">氧化还原文档</strong>。在这篇文章中，我不会涉及太多的细节。要了解FastAPI的更多信息，请点击<a class="ae iu" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">此处</strong> </a>。</strong></p><h2 id="39e9" class="mc kr hi bd ks mj mk ml kw mm mn mo la jg mp mq le jk mr ms li jo mt mu lm mv bi translated">紫玉米</h2><p id="3fed" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">为了主持这个模型，我们将使用uvicorn。与更通用的WSGI服务器相比，它是一个允许异步流程的ASGI服务器。这加快了进程。在继续之前，请确保安装了FastAPI和univorn。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="b873" class="mc kr hi ly b fi md me l mf mg">pip install fastapi<br/>pip install uvicorn</span></pre><p id="bb3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要做出推断，您需要onnxruntime。通过运行以下命令进行安装:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="f4f4" class="mc kr hi ly b fi md me l mf mg">pip install onnxruntime</span></pre><p id="5c63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">安装必要的包之后，我们创建main.py文件，这是端点创建的代码。</p><p id="90c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过导入必要的库来开始代码，然后创建一个FASTAPI类的对象，并将其命名为app。这将用于运行应用程序。然后，我们加载使用model.py文件创建的目标和特征文件。现在已经创建了一个推理会话。不管ML库如何，都将使用相同的推理会话，这是创建onnx格式的一个原因。这个推理会话将生成保存onnx文件时使用的输入和输出名称。</p><p id="1fb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">FastAPI受欢迎的原因之一是它能够创建文档，我们在这里通过创建一个从class BaseModel继承的类数据来做到这一点。在本课程中，我们将提供有关用于生成预测的特征的信息。</p><p id="2dc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建端点最关键的步骤是处理GET或POST请求。这里我们通过使用POST请求来访问API，我们通过使用。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="a96a" class="mc kr hi ly b fi md me l mf mg">@app.post(“/predict”)</span></pre><p id="f513" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这告诉应用程序在post请求到来时调用predict函数。在这个函数中，我们首先将数据转换成一个numpy数组。因为我们一次传递一个数据点，所以我们必须将其整形为(1，4)，其中4是数据集中要素的数量。因为我们将输入数据定义为浮点张量，所以我们显式地将输入类型转换为浮点。为了生成预测，我们运行会话并传递输出、输入数据名称以及要生成预测的数据。这个预测值然后被转换成一个字典并被返回。</p><h1 id="5962" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">运行模型并生成请求</h1><p id="6d5b" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">要运行此模型，请打开cmd并遍历到Fast_api_model-master文件夹并执行。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="d792" class="mc kr hi ly b fi md me l mf mg">uvicorn app.main:app</span></pre><p id="c851" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器将启动，您可以通过链接127.0.0.1访问它</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/cf467d6f418a57e4caaa831f891c000a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3x9qxtk6UcNhSVw3Iqy88Q.png"/></div></div></figure><p id="4534" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用requests.post()方法向API发送post请求。发送post请求有多种方法，但我发现这种方法相对简单。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/840b086b241e3c51c7bf6854c8e1121e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*ZKo8WgCh3OoAeaskkumYCg.png"/></div></figure><p id="54f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要访问swagger页面，请转到uvicorn服务器正在运行的URL，并在末尾添加/docs。大摇大摆的页面看起来会像这样。在这里您可以看到模式，其中给出了数据集中使用的特性，您甚至可以从这里测试API。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/6edd932cf134b6a4260faa388bf49083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vopspm8qhiCo3eF8s1Nszw.png"/></div></div></figure><h1 id="b885" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">容器化应用程序</h1><p id="7a33" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">容器的可移植性使得可以轻松快速地部署到多种硬件平台和操作系统上。为此，我们将使用docker。要设置docker，请遵循此处的<a class="ae iu" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">指示。你还需要一个码头枢纽<a class="ae iu" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">账户</strong> </a>。</strong></a></p><p id="c330" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要创建docker映像，需要两个文件</p><ol class=""><li id="059a" class="kc kd hi ix b iy iz jc jd jg ke jk kf jo kg js kh ki kj kk bi translated">Dockerfile文件</li><li id="018c" class="kc kd hi ix b iy kl jc km jg kn jk ko jo kp js kh ki kj kk bi translated">requirements.txt。</li></ol><p id="adb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">docker文件包含创建环境、安装依赖项和运行应用程序的指令。</p><p id="f7b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">requirements.txt文件包含运行应用程序所需的必要包。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="a49d" class="mc kr hi ly b fi md me l mf mg">#app/requirements.txt</span><span id="e4a5" class="mc kr hi ly b fi mz me l mf mg">fastapi==0.54.1<br/>numpy==1.18.1<br/>scikit-learn==0.22<br/>skl2onnx==1.6.1<br/>onnx==1.6.0<br/>onnxconverter-common==1.6.1<br/>onnxruntime==1.2.0<br/>requests==2.22.0<br/>pydantic==1.5.1<br/>uvicorn==0.11.5<br/>pandas==1.0.1</span></pre><p id="9ffb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Fast_api_model-master目录中运行:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="bc4b" class="mc kr hi ly b fi md me l mf mg">docker build -t &lt;image_name&gt;./</span><span id="4001" class="mc kr hi ly b fi mz me l mf mg">docker run --name &lt;container_name&gt; -p 8000:5000 &lt;image_name&gt;</span></pre><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/5c2cc5d83c021a84ea5d3125ff993af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2Dv7PV0B4VXcRnHsbi4tw.png"/></div></div></figure><p id="dc59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要测试应用程序，首先使用以下方法确定主机IP:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="8d1b" class="mc kr hi ly b fi md me l mf mg">docker-machine ip</span></pre><p id="5163" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，它是192.168.99.100。我们可以像测试本地部署一样进行测试。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/740ff8d142c378f524d971f453747f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*2EznIrAkTWYH7zbI7icYgA.png"/></div></figure><p id="bd1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过运行以下命令，将此映像推送到您的docker hub帐户:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="782e" class="mc kr hi ly b fi md me l mf mg">docker tag &lt;image_name&gt; &lt;dockerhub_username&gt;/&lt;image_name&gt;:&lt;tag_name&gt;<br/>docker push &lt;dockerhub_username&gt;/&lt;image_name&gt;</span></pre><h1 id="dbe5" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">AWS弹性豆茎</h1><p id="409f" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">现在我们在<strong class="ix hj"> AWS、</strong>上托管应用程序，你将需要一个AWS帐户(如果你没有，请在<a class="ae iu" href="https://portal.aws.amazon.com/billing/signup?nc2=h_ct&amp;src=header_signup&amp;redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation#/start" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">这里</strong> </a>创建一个)。它会要求一个<strong class="ix hj">信用卡/借记卡</strong>，如果你遵循选项而不改变任何配置，你将有资格获得一个<strong class="ix hj">免费层账户</strong>，并且费用将是最小的。</p><p id="12fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建账户后，搜索<strong class="ix hj">弹力豆茎</strong>并打开。将会看到以下屏幕。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/059dabc61fb86d227a52e126e029a279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZG-aj2uzK-DyIoC060LbA.png"/></div></div></figure><p id="969c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击<strong class="ix hj">创建应用</strong>。添加名称和描述。然后，您必须指定平台，在本例中，该平台将是运行在Linux上的docker。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/db80e08d93eba3b896758905e82c5c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wtxjNgc8ofrOeWHwGxO_NA.png"/></div></div></figure><p id="2ff7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于应用程序代码，我们有两个选项，要么选择“示例代码”，要么选择“上传您的代码”我们将上传我们的代码，为此，我们将创建一个JSON文件，并将其命名为Docker.aws.json。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="5421" class="mc kr hi ly b fi md me l mf mg">{<br/> “AWSEBDockerrunVersion”: “1”,<br/> “Image”: {<br/> “Name”: “&lt;your_dockerhub_username&gt;/&lt;image_name&gt;:&lt;tag_name&gt;”,<br/> “Update”: “true”<br/> },<br/> “Ports”: [<br/> {<br/> “ContainerPort”: “5000”<br/> }<br/> ],<br/> “Logging”: “/var/log/nginx”<br/>}</span></pre><p id="a26f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择<strong class="ix hj">上传您的代码</strong>并上传该文件，点击<strong class="ix hj">创建环境</strong>。</p><p id="eaa3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想要根据您的要求进行自定义，请点按“配置更多选项”这将需要一些时间来部署，完成后，将出现以下屏幕:</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/4a96468d98bfd7d1ad8ee8b8235e9c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VT38TWo3VLUXr_e72nbCjA.png"/></div></div></figure><p id="3729" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过链接进行测试</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="9812" class="mc kr hi ly b fi md me l mf mg"><a class="ae iu" href="http://fastapidemp-env.eba-4mifzq7e.us-east-2.elasticbeanstalk.com/docs" rel="noopener ugc nofollow" target="_blank">http://fastapidemp-env.eba-afmfibac.us-west-1.elasticbeanstalk.com</a></span></pre><p id="e296" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，这个链接在您的部署中是不同的，您可以使用requests.post()函数来测试这个链接。</p><figure class="lt lu lv lw fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/668bafcc7064d6db2eb382e496b0d43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*B_fPlTOeVP81HLWG6ON1nQ.png"/></div></figure><h1 id="4f28" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">摘要</h1><p id="b9c4" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">在本教程中，我们在Iris数据集上训练了一个简单的随机森林分类器，将其保存为onnx格式，使用FastApi创建了一个生产就绪的API，使用docker将其容器化，并将其部署在AWS上。您现在可以创建您的模型并尝试这种方法。这种方法使开发人员更容易使用您的机器学习模型，因为他们只需学习如何使用API，而无需了解模型的本质。如果您有任何反馈，请随时与我分享。这是我第一个关于媒体的博客，如果这对你有帮助，请喜欢这篇文章。感谢阅读！！！！</p></div></div>    
</body>
</html>