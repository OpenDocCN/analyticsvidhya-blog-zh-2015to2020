<html>
<head>
<title>Understanding Model Selection through Cross Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过交叉验证了解模型选择</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-model-selection-through-cross-validation-7638d3c3a139?source=collection_archive---------5-----------------------#2019-10-30">https://medium.com/analytics-vidhya/understanding-model-selection-through-cross-validation-7638d3c3a139?source=collection_archive---------5-----------------------#2019-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="971c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交叉验证是机器学习中使用的一种技术，其中每个数据点都用于训练和测试数据集。这有助于我们通过比较不同算法的平均精度来确定更好的算法。</p><p id="8fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图片提供:<a class="ae jd" href="https://www.analyticsvidhya.com/" rel="noopener ugc nofollow" target="_blank">分析Vidhya </a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4ce82daa414b33358b2f4a032bd2cb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyesnuIsp4Aqu1Y81bLtPg.jpeg"/></div></div></figure><p id="9259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们通过编写一些代码来演示如何应用交叉验证，然后选择一个模型来理解这个概念，那就更好了。</p><p id="8d62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从克里斯·纳伊克的YouTube <a class="ae jd" href="https://www.youtube.com/channel/UCNU_lfiiWBdtULKOw6X0Dig" rel="noopener ugc nofollow" target="_blank">频道</a>上了解到下面这个例子。这个例子的工作代码和数据集也上传到我的<a class="ae jd" href="https://github.com/asheshds/datascience/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中。</p><p id="3cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，让我们开始分析吧。</p><p id="6a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的数据集包含以下特征:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="b747" class="jv jw hi jr b fi jx jy l jz ka">UserID : Unique Identifier for every row<br/>Gender: Gender of a particular User<br/>Age: Age of the corresponding user<br/>Estimated Salary: Estimated Salary of the corresponding<br/>Purchased: 0/1 flag denoting that it was a sale or not</span></pre><p id="02ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个典型的分类问题，我们必须预测相应特征的给定数据集的“已购买”标志。我们将用来预测“已购买”标志的算法是KNN。</p><p id="a28c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见(因为我们的目标是理解交叉验证)，我们忽略了“性别”特征，并且没有在我们的分析中使用它。</p><p id="8c57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先导入我们需要用于分析和读取数据的不同库:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="c21d" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">import</strong> <strong class="jr hj">pandas</strong> <strong class="jr hj">as</strong> <strong class="jr hj">pd</strong><br/><strong class="jr hj">import</strong> <strong class="jr hj">numpy</strong> <strong class="jr hj">as</strong> <strong class="jr hj">np</strong></span><span id="9d4e" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">import</strong> <strong class="jr hj">warnings</strong><br/>warnings.filterwarnings("ignore", category=<strong class="jr hj">FutureWarning</strong>)</span></pre><p id="da3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有了所有必要的数据，我们就使用<a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> sklearn的train_test_split </a>方法将数据分成训练集和测试集:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="99fe" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.model_selection</strong> <strong class="jr hj">import</strong> train_test_split<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 101)</span></pre><p id="85db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们指定随机状态为101。随机状态表示将从整个数据集中以随机方式选择训练和测试数据集。对于不同的随机状态值，我们的模型可以以不同的精确度执行。</p><p id="83d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们完成了train_test_split，我们现在将使KNN模型适合我们的数据，然后预测结果:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="4f1d" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.neighbors</strong> <strong class="jr hj">import</strong> KNeighborsClassifier<br/><br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>knn.fit(X_train, y_train)</span><span id="5629" class="jv jw hi jr b fi kb jy l jz ka">predictions = knn.predict(X_test)</span><span id="702b" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn</strong> <strong class="jr hj">import</strong> metrics<br/>metrics.accuracy_score(y_test, predictions)</span><span id="30bd" class="jv jw hi jr b fi kb jy l jz ka">0.82</span></pre><p id="76d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们看到我们的模型已经产生了82%的准确率。尽管精确度还不错，但现在让我们尝试通过调整随机状态来实现相同的代码:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="46c5" class="jv jw hi jr b fi jx jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.model_selection</strong> <strong class="jr hj">import</strong> train_test_split<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 10)</span><span id="43ae" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.neighbors</strong> <strong class="jr hj">import</strong> KNeighborsClassifier<br/><br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>knn.fit(X_train, y_train)</span><span id="c9c8" class="jv jw hi jr b fi kb jy l jz ka">predictions = knn.predict(X_test)</span><span id="c6ff" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn</strong> <strong class="jr hj">import</strong> metrics<br/>metrics.accuracy_score(y_test, predictions)</span><span id="6b70" class="jv jw hi jr b fi kb jy l jz ka">0.87</span></pre><p id="b0d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们看到，当我们将随机状态设置为10时，我们获得了87%的准确率。然而，我们仍然不确定我们的模型的准确性，因为它只取决于训练和测试分裂是如何发生的，即以何种随机顺序选择数据集的记录。</p><p id="9f18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题可以通过交叉验证来解决。在交叉验证中，所有数据点都用于训练和测试数据。之后，我们可以比较不同算法的平均精度，以确定哪个算法是最适合的。</p><p id="aaa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码中，我们对KNN进行了交叉验证，以获得平均准确度:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="5bb0" class="jv jw hi jr b fi jx jy l jz ka">knn = KNeighborsClassifier(n_neighbors=5)</span><span id="325e" class="jv jw hi jr b fi kb jy l jz ka"><strong class="jr hj">from</strong> <strong class="jr hj">sklearn.model_selection</strong> <strong class="jr hj">import</strong> cross_val_score<br/><br/>print(cross_val_score(knn, X, y, cv=5, scoring='accuracy').mean())</span><span id="9f5b" class="jv jw hi jr b fi kb jy l jz ka">0.7745366463509923</span></pre><p id="99a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这里我们看到KNN的平均准确率是77.4%</p><p id="1b94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以得出结论，无论如何进行训练和测试分割，用于该特定数据集的KNN算法将总是产生大约77.4%的准确度。</p><p id="77c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也使用逻辑回归在同一个数据集上实现了类似的交叉验证概念。你可以在我的<a class="ae jd" href="https://github.com/asheshds/datascience/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到工作Jupyter笔记本。</p><p id="3394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐学习:)</p></div></div>    
</body>
</html>