<html>
<head>
<title>Save and load a TensorFlow Estimator model for predictions.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保存并加载用于预测的TensorFlow估计器模型。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/save-and-load-a-tensorflow-estimator-model-for-predictions-233b798620a9?source=collection_archive---------3-----------------------#2020-10-22">https://medium.com/analytics-vidhya/save-and-load-a-tensorflow-estimator-model-for-predictions-233b798620a9?source=collection_archive---------3-----------------------#2020-10-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="198f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文将详细描述保存TensorFlow (V2)估算器模型，然后重新加载该模型进行预测的过程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0caa3141cefc25befc38b8991ddb998c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPZap7X4nhqiLrkQZe-6wQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">弗兰基·查马基在<a class="ae jt" href="https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ca7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi ju translated">ython有一个非常强大和慷慨的社区，当谈到用Python进行机器学习时，它变得更加强大。每当你想学习新东西的时候，只要点击谷歌，你就会得到大量的资源。同样，当你写一些代码或者使用一些新的库时，你被困在某个地方，无法找到解决方案。</p><blockquote class="kd"><p id="64d3" class="ke kf hi bd kg kh ki kj kk kl km jc dx translated">无论你有什么问题，在StackOverflow上都会有答案。</p></blockquote><p id="9e0a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">虽然几乎每次都是这种情况，但是有些时候问题是如此的新，以至于你无法得到预先解决的答案。因此，对于这些罕见的情况，您将不得不亲自动手。</p><p id="0480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上周，当我试图<em class="ks">保存一个TensorFlow估计器模型，然后使用重新加载的模型</em>进行预测时，出现了这样一个案例。官方<a class="ae jt" href="https://www.tensorflow.org/guide/saved_model#savedmodels_from_estimators" rel="noopener ugc nofollow" target="_blank">文档</a>对此非常简短，没有任何关于正在发生的事情的线索。他们在一个非常基本的数据集上给出了一个小的解决方案，但如果没有对代码中发生的事情进行解释，这对于复杂的场景来说是没有用的。</p><p id="4a94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我点击了谷歌，令我惊讶的是，这个问题没有解决方案。很多和我类似的问题但是没有合适的答案。虽然有答案，但都是Tensorflow版本1。在<a class="ae jt" href="https://stackoverflow.com/questions/46098863/how-to-import-an-saved-tensorflow-model-train-using-tf-estimator-and-predict-on" rel="noopener ugc nofollow" target="_blank">答案</a>中，他们使用了一个模块<em class="ks"> Conrib </em>来做预测，但是这个模块完全从TF V2中移除了。</p><p id="f500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我可以使用Keras或Sklearn来完成我的任务，但是要求是特别针对V2的。所以我必须找到解决办法。</p><p id="a143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也是。因为我是强大的Python社区的一员，所以我有责任与每个人分享这个方法，以便其他人可以使用它。</p><p id="a170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们开始吧。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/6abbb0b8fed276fd71d2fd0b141df1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jk2Uq6xTNLacCTsCkp08gg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">艾玛·弗朗西丝·洛根在<a class="ae jt" href="https://unsplash.com/s/photos/start?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="bb89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于本文的唯一目的是理解如何使用加载的TF估计模型进行预测，所以我将跳过对其他部分不必要的解释。</p><h1 id="b455" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概观</h1><p id="88ab" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">这个端到端的演练使用<code class="du me mf mg mh b">tf.estimator</code> API训练一个逻辑回归模型，然后保存该模型，然后用不同的名称重新加载它以进行预测。</p><p id="f85e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先:<strong class="ih hj">导入库</strong></p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="4365" class="mm lc hi mh b fi mn mo l mp mq">import os<br/>import shutil<br/>import numpy as np<br/>import pandas as pd<br/>import tensorflow as tf</span></pre><p id="a90f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加载数据集</strong></p><p id="6e0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用泰坦尼克号数据集，目标是(相当病态地)预测乘客的存活率，给出诸如性别、年龄、阶级等特征。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="7d59" class="mm lc hi mh b fi mn mo l mp mq">dftrain = pd.read_csv('https://storage.googleapis.com/tf-datasets/titanic/train.csv')</span><span id="c416" class="mm lc hi mh b fi mr mo l mp mq">dfeval = pd.read_csv('https://storage.googleapis.com/tf-datasets/titanic/eval.csv')</span></pre><p id="7932" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的数据集的样子。幸存的列<strong class="ih hj">是我们的目标列，其余的是特性列。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/15636d76654c8c0e5ce6fa0fd746c495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3BVZgikZe1Q4mPHP3_-Rg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">dftrain的前五行</figcaption></figure><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="7d8a" class="mm lc hi mh b fi mn mo l mp mq">╔════════════════════╦════════════════════════════════════╗<br/>║     Column Name    ║            Description             ║<br/>╠════════════════════╬════════════════════════════════════╣<br/>║ survived           ║ Passenger survived or not          ║<br/>║ sex                ║ Gender of passenger                ║<br/>║ age                ║ Age of passenger                   ║<br/>║ n_siblings_spouses ║ siblings and partners aboard       ║<br/>║ parch              ║ of parents and children aboard     ║<br/>║ fare               ║ Fare passenger paid.               ║<br/>║ class              ║ Passenger's class on ship          ║<br/>║ deck               ║ Which deck passenger was on        ║<br/>║ embark_town        ║ Which town passenger embarked from ║<br/>║ alone              ║ If passenger was alone             ║<br/>╚════════════════════╩════════════════════════════════════</span></pre><p id="e1ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模型的特征工程</strong></p><p id="9426" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计器使用一个称为特征列的系统来描述模型应该如何解释每个原始输入特征。估计器需要一个数字输入向量，而要素列描述了模型应该如何转换每个要素。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="c683" class="mm lc hi mh b fi mn mo l mp mq">LABEL = "survived"<br/>NUMERIC_COLUMNS = ['age', 'fare']<br/>CATEGORICAL_COLUMNS = ['sex', 'n_siblings_spouses', 'parch', 'class', 'deck', 'embark_town', 'alone']</span><span id="6a87" class="mm lc hi mh b fi mr mo l mp mq">feature_columns = []</span><span id="9741" class="mm lc hi mh b fi mr mo l mp mq">for feature_name in CATEGORICAL_COLUMNS:<br/>  vocabulary = dftrain[feature_name].unique()<br/>  feature_columns.append(<br/>     tf.feature_column.categorical_column_with_vocabulary_list(<br/>       feature_name, vocabulary))</span><span id="fea1" class="mm lc hi mh b fi mr mo l mp mq">for feature_name in NUMERIC_COLUMNS:<br/>  feature_columns.append(<br/>    tf.feature_column.numeric_column(<br/>      feature_name, dtype=tf.float32))</span></pre><p id="2bac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下两个函数分别负责将数据提供给模型进行训练和评估。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="06f6" class="mm lc hi mh b fi mn mo l mp mq">def make_train_input_fn(df, num_epochs):<br/>  return tf.compat.v1.estimator.inputs.pandas_input_fn(<br/>    x = df,<br/>    y = df[LABEL],<br/>    batch_size = 128, <br/>    num_epochs = num_epochs,<br/>    shuffle = True,<br/>    queue_capacity = 1000<br/>  )</span><span id="543d" class="mm lc hi mh b fi mr mo l mp mq">def make_prediction_input_fn(df):<br/>  return tf.compat.v1.estimator.inputs.pandas_input_fn(<br/>    x = df,<br/>    y = None,<br/>    batch_size = 128,<br/>    shuffle = False,<br/>    queue_capacity = 1000<br/>  )</span></pre><p id="4947" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练模型</strong></p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="e0a6" class="mm lc hi mh b fi mn mo l mp mq"># Instantiate the pre-made estimator<br/>model = tf.estimator.LinearClassifier(feature_columns)</span><span id="d047" class="mm lc hi mh b fi mr mo l mp mq"># Train the model<br/>model.train(make_train_input_fn(dftrain, num_epochs=10))</span></pre><p id="3614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对评估数据集进行预测</strong></p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="3295" class="mm lc hi mh b fi mn mo l mp mq">predDicts = list(model.predict(make_prediction_input_fn(dfeval)))</span></pre><p id="dc5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看前10个预测</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="c8a9" class="mm lc hi mh b fi mn mo l mp mq">preds = []<br/>for pred in predDicts[:10]:<br/>  preds.append(np.argmax(pred["probabilities"]))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mt"><img src="../Images/149fd457a6f4056520ff05f2a1e40569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*6cWG-hA4u3PeXf-ZMHvr2g.png"/></div></figure><p id="d793" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">保存模型</strong></p><p id="2d2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Tensorflow估计器模型不像Sklearn模型那样保存在pickle文件中。以下是存储TF估计模型的方法。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="0faf" class="mm lc hi mh b fi mn mo l mp mq">inputFn = \ tf.estimator.export.build_parsing_serving_input_receiver_fn(<br/>  tf.feature_column.make_parse_example_spec(feature_columns))</span><span id="996a" class="mm lc hi mh b fi mr mo l mp mq">OUTDIR = 'modelDir'<br/>shutil.rmtree(OUTDIR, ignore_errors = True) # start fresh each timemodelBasePath = os.path.join(OUTDIR, "model")</span><span id="c116" class="mm lc hi mh b fi mr mo l mp mq">modelPath = model.export_saved_model(modelBasePath, inputFn)</span></pre></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="2479" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重新加载模型</strong></p><p id="3765" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用不同的模型名称，以确保我们没有使用现有的模型。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="7f25" class="mm lc hi mh b fi mn mo l mp mq">savedModelPath = modelPath<br/>importedModel = tf.saved_model.load(savedModelPath)</span></pre><p id="dd68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">预测采用进口模型</strong></p><p id="0350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用加载估计模型对未知数据集进行预测，我们必须遵循以下小步骤:</p><ol class=""><li id="1bfd" class="mu mv hi ih b ii ij im in iq mw iu mx iy my jc mz na nb nc bi translated">对数据集的所有行重复步骤2–4。</li><li id="e644" class="mu mv hi ih b ii nd im ne iq nf iu ng iy nh jc mz na nb nc bi translated">创建tf.train.Example()对象。该对象将负责将我们的数据传递给模型进行预测。</li><li id="8ad5" class="mu mv hi ih b ii nd im ne iq nf iu ng iy nh jc mz na nb nc bi translated">遍历所有列，并根据该列的数据类型，使用<em class="ks"> bytes_list </em>、<em class="ks"> float_list </em>、<em class="ks"> int64_list </em>中的适当类型，将该列值添加到<em class="ks">示例</em>对象。关于这些类型<a class="ae jt" href="https://www.tensorflow.org/tutorials/load_data/tfrecord" rel="noopener ugc nofollow" target="_blank">的更多信息，请点击</a>。</li><li id="33b5" class="mu mv hi ih b ii nd im ne iq nf iu ng iy nh jc mz na nb nc bi translated">使用此示例对象和导入的模型进行预测。请注意，这个示例对象的作用与将单个行传递给sklearn模型进行预测的作用相同。</li></ol><p id="d191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是同样的Python实现。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="35fa" class="mm lc hi mh b fi mn mo l mp mq">def predict(dfeval, importedModel):<br/>  colNames = dfeval.columns<br/>  dtypes = dfeval.dtypes<br/>  predictions = []<br/>  for row in dfeval.iterrows():<br/>    example = tf.train.Example()<br/>    for i in range(len(colNames)):<br/>      dtype = dtypes[i]<br/>      colName = colNames[i]<br/>      value = row[1][colName]<br/>      if dtype == "object":<br/>        value = bytes(value, "utf-8")<br/>        example.features.feature[colName].bytes_list.value.extend(<br/>            [value])<br/>      elif dtype == "float":<br/>        example.features.feature[colName].float_list.value.extend(<br/>            [value])<br/>      elif dtype == "int":<br/>        example.features.feature[colName].int64_list.value.extend(<br/>            [value])<br/>   <br/>    predictions.append(<br/>      importedModel.signatures["predict"](<br/>        examples=tf.constant([example.SerializeToString()])))</span><span id="fdd2" class="mm lc hi mh b fi mr mo l mp mq">return predictions</span></pre><p id="8c42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将不得不从<strong class="ih hj"> dfeval </strong>中删除标签列，因为我们将传递数据集本身，而不是一个为我们做这件事的函数。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="6ab8" class="mm lc hi mh b fi mn mo l mp mq">dfeval.drop(columns=["survived"], inplace=True)</span></pre><p id="77a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用加载的模型和数据集调用<strong class="ih hj">预测</strong>函数来获得预测。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="dbd2" class="mm lc hi mh b fi mn mo l mp mq">predictions = predict(dfeval, importedModel)</span></pre><p id="f20d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看看前10个预测。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="3b74" class="mm lc hi mh b fi mn mo l mp mq">newPreds = []<br/>  for pred in predictions[:10]:<br/>    # change 'probabilities' with 'predictions' in case<br/>    # of regression model.<br/>    newPreds.append(np.argmax(pred["probabilities"]))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ni"><img src="../Images/ef340bbacc34d1220617e9e97a6b8452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*17R9bbLasHva4VrW6T8lZA.png"/></div></figure><p id="b378" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，两种型号的<strong class="ih hj">输出是相同的</strong>。</p><p id="7244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">这就是我们如何保存张量流估算模型，然后使用重新加载的模型进行预测</em></p><p id="8211" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在Github上的这个<a class="ae jt" href="https://github.com/AjeetSingh02/Notebooks/blob/master/TFestimatorClassificationSaveLoad.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>里找到全部代码。欢迎在评论中提出你在代码中发现的任何错误，或者你有任何疑问或建议。</p><p id="6ba7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，那么你可以想按多少次拍手按钮就按多少次。还有，你可以在<a class="ae jt" href="https://www.linkedin.com/in/singhajeet23/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">LinkedIn</strong></a><strong class="ih hj">上联系我，或者在</strong><a class="ae jt" href="https://github.com/AjeetSingh02" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">GitHub</strong></a><strong class="ih hj">上关注我。</strong></p><blockquote class="kd"><p id="adcb" class="ke kf hi bd kg kh ki kj kk kl km jc dx translated">仅此而已。感谢阅读。快乐学习。</p></blockquote><figure class="nk nl nm nn no ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nj"><img src="../Images/03c250e10ebcd0caa798b827f1ca7923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0eXJ2QgwFQGe-x8FPtQBg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">安妮·斯普拉特在<a class="ae jt" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div></div>    
</body>
</html>