<html>
<head>
<title>Most WANTED PyTorch Tensor operations!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最想要的PyTorch张量运算！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/most-wanted-pytorch-tensor-operations-dfa89b0187ef?source=collection_archive---------11-----------------------#2020-12-04">https://medium.com/analytics-vidhya/most-wanted-pytorch-tensor-operations-dfa89b0187ef?source=collection_archive---------11-----------------------#2020-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ba87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本帖中，我们将向PyTorch介绍我们自己。它是由脸书人工智能研究实验室于2016年开发的。该库主要用于计算机视觉、机器学习和深度学习应用。目前，我正在参加一个名为“PyTorch深度学习:零到GANs”的训练营。在这个程序的范围内，我们将通过使用这个库来学习和实现许多东西。随着我在训练营的进步，我的目标是分享我在这里学到的东西！</p><p id="4d4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不知道PyTorch，不要担心。我也是一个完全的深度学习初学者。我们将在各门课程之间复习定义和解释，希望能一起学习。我们开始吧！</p><h1 id="917e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">PyTorch是什么？</h1><p id="a4dd" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">PyTorch是一个基于Python的科学计算包，面向两组受众:</p><ul class=""><li id="aa81" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">代替NumPy使用GPU的能力</li><li id="4025" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">深度学习研究平台，提供最大的灵活性和速度。[0]</li></ul><p id="1729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的定义提出了这个问题:GPU的到底是什么，使用它们的力量意味着什么？</p><p id="4541" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，GPU代表图形处理单元。据说，在执行某些特定任务时，它们比CPU(中央处理器)更强大、更快。<br/><em class="ku">*这是一个庞大的话题，这里不赘述。如果你对此感到好奇，请点击此链接了解更多信息:【https://bit.ly/2JjYnh8】<a class="ae kv" href="https://bit.ly/2JjYnh8" rel="noopener ugc nofollow" target="_blank"><em class="ku"/></a></em></p><p id="1b70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PyTorch使用<strong class="ih hj">张量</strong>进行数值计算。它包括许多功能，将帮助我们轻松地做这些计算。</p><blockquote class="kw kx ky"><p id="26bd" class="if ig ku ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">一个<strong class="ih hj">张量</strong>是一个数字，向量，矩阵，或者任何n维数组。</p></blockquote><p id="99e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了决定引入哪些功能，我使用了<a class="ae kv" href="https://trends.google.com/trends/explore?q=PyTorch%20tensor" rel="noopener ugc nofollow" target="_blank"> Google Trends！这个平台让我们可以看到人们在谷歌上搜索的趋势。这是我输入“PyTorch张量”时得到的结果。</a></p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/eb4a66320da314240d752deae48c6fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRBdetqtWe1WJzkFwnw0WA.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">一年期的利息</figcaption></figure><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ls"><img src="../Images/d9085225831ee9cb0494b32a47897dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY83Jj7_VdmEvCEw0hJ84A.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">看来中国爱PyTorch！</figcaption></figure><p id="6351" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从分析中，人们主要搜索PyTorch张量的以下函数:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es lt"><img src="../Images/f780d0ae2b0421300121bd904bcd03c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*ZGBeGR7HKPePmkot1pDD4Q.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">在这里你可以看到关于PyTorch张量的十大搜索。</figcaption></figure><p id="768e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将涵盖以下功能:</p><ul class=""><li id="2a2c" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">torch.from_numpy() —。numpy()</li><li id="5291" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.size() — torch.shape()</li><li id="791b" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.rand()</li><li id="15cc" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">。克隆()</li><li id="1831" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">。重塑()</li><li id="5191" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">火炬。Tensor.tolist()</li></ul><h1 id="136b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">如何把一个numpy数组变成PyTorch张量(反之亦然)？</strong></h1><p id="3b1a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">将numpy数组转换成张量相对容易。我们将使用torch.from_numpy()函数。让我们看一个例子。</p><blockquote class="kw kx ky"><p id="9c14" class="if ig ku ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">Numpy是另一个使科学数学运算更容易的库。</p></blockquote><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lu"><img src="../Images/914056ac7d8a2e8f99fe6b1b08bbc259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuH0sqPsRFR-U4oMj9cMJw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">np在这里是numpy的别名。这样我们可以使用numpy方法，只需输入np而不是numpy。我们可以使用任何东西，但是最好遵循通用的约定来编写可读性更好、更容易理解的代码。</figcaption></figure><p id="1038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建了我们的数组，现在是时候导入火炬并转换它了。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lv"><img src="../Images/544a8e4fc9f24c0d8475bc94f4f0ba1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0M4rPhoEhHHxjNLxyhYa1Q.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">瞧啊。我们有了一个全新的张量。还能更容易吗！？</figcaption></figure><p id="69cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们将numpy数组转换为张量时，有一些事情需要考虑。例如:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lw"><img src="../Images/c0bd1a7f72282444a8f1326cff121e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JRO_Q2ycpm45A39KKNIDA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">哎呀numpy数组中的相同元素也发生了变化。那是因为t1和nd_arr共享同一个内存。所以对其中任何一个的修改都会影响到另一个。小心！</figcaption></figure><p id="0ea5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">from_numpy()只支持一些特定的数据类型。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lx"><img src="../Images/dc2c5fb5f80c82b7acb045e4aad6e7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueDBALX9FVhNZChag_G1rw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">我们得到一个类型错误，因为仅支持以下数据类型:float64、float32、float16、complex64、complex128、int64、int32、int16、int8、uint8和bool。</figcaption></figure><p id="64ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一件需要记住的重要事情是:我们从numpy数组转换而来的张量是不可调整大小的。换句话说，你不能改变张量的维数。</p><p id="f78a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这个函数的更多信息，你可以查阅文档:<a class="ae kv" href="https://bit.ly/33E9Cs3" rel="noopener ugc nofollow" target="_blank">https://bit.ly/33E9Cs3</a></p><p id="6de7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经学习了如何将numpy数组转换成pytorch张量，是时候用另一种方法了。把张量变成numpy数组！为此，我们将创建一个新的张量。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ly"><img src="../Images/de5a7a4ea54e78fa115216748f942507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76sCwb7dsT4PPi8PuLDNDA.png"/></div></div></figure><p id="c81a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个过程，我们将使用。numpy()函数。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lz"><img src="../Images/b85b02d53f54e9694e440dadded1fee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atNAH--imhCSE7RbPS30Hw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">因为PyTorch也支持numpy数组支持的数据类型，所以我们不会得到类型错误。</figcaption></figure><p id="23e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记:张量和转换后的numpy数组共享同一个内存位置。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ma"><img src="../Images/10eb8d3da48396795c50f974eb59b187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q61luckYTfxVeVWHgcGj4g.png"/></div></div></figure><p id="49ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个操作被称为“numpy桥”。更多信息，请查看文档:<a class="ae kv" href="https://bit.ly/33Drcw6" rel="noopener ugc nofollow" target="_blank">https://bit.ly/33Drcw6</a></p><h1 id="eba3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">我的张量的大小&amp;形状是什么？</strong></h1><p id="4bf1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当我们比较numpy和PyTorch时，大小和形状概念有点不同。Size指的是一个整数，即numpy数组中元素的数量。Shape指的是一个tuple (a，b)，其中:<br/>-a =数组中的行数，<br/> - b=数组中的列数。</p><p id="2c91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于PyTorch，使用size()和shape没有区别。这就是我们如何了解张量的大小/形状。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mb"><img src="../Images/16a9da094a910d559e148700668d0067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q30EqgplFJVhuP1_U87O-A.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">如您所见，numpy和PyTorch的概念有些不同。这里有一个很好的学习资源:<a class="ae kv" href="https://bit.ly/2IbbEZ8" rel="noopener ugc nofollow" target="_blank">https://bit.ly/2IbbEZ8</a></figcaption></figure><h1 id="5cba" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">如何用随机数构成张量？</strong></h1><p id="c39b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">PyTorch有许多不同的功能，允许我们创建随机张量。</p><ul class=""><li id="45df" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">torch.rand():返回用区间[0，1]上均匀分布的随机数填充的张量</li><li id="d175" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.rand_like(input):返回一个与<code class="du mc md me mf b">input</code>大小相同的张量，用区间[0，1]上均匀分布的随机数填充。</li><li id="cd61" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.randint():返回一个张量，其中填充了在<code class="du mc md me mf b">low</code>(含)和<code class="du mc md me mf b">high</code>(不含)之间均匀生成的随机整数。</li><li id="366c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.randint_like(input):对randint执行完全相同的操作，但使用输入张量指定其大小。</li><li id="02ed" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.randn():从均值为0、方差为1的正态分布(也称为标准正态分布)返回一个填充有随机数的张量。</li><li id="df2f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.randn_like(input):与randn执行完全相同的操作，但使用输入张量指定其大小。</li><li id="377e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">torch.randperm():返回从<code class="du mc md me mf b">0</code>到<code class="du mc md me mf b">n - 1</code>的整数随机排列。</li></ul><p id="f790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们只实现torch.rand()，因为其他函数非常相似。查看文档了解更多信息:<a class="ae kv" href="https://bit.ly/3mxzHjP" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3mxzHjP</a></p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mg"><img src="../Images/c8d084069acc63e446470839a490bf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CM5P2u9yJ-dHwc2UVQxIRg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">如果您再次运行该单元，您将看到不同的元素。</figcaption></figure><p id="1578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指定的大小必须是整数类型。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mh"><img src="../Images/d6e0fa08b0c53981e6a4f53962554f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZr7gvPEL4XyGeg4i5HyFw.png"/></div></div></figure><h1 id="3fb6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">如何复制/克隆张量？</strong></h1><p id="5c6d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们有不止一种方法可以克隆张量[1]。</p><pre class="ld le lf lg fd mi mf mj mk aw ml bi"><span id="7a90" class="mm je hi mf b fi mn mo l mp mq">y = tensor.new_tensor(x) #a<br/><br/>y = x.detach().clone() or x.clone().detach() #b<br/><br/>y = torch.empty_like(x).copy_(x) #c<br/><br/>y = torch.tensor(x) #d</span></pre><p id="ac96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据stackoverflow，b明显优于其他。所以我们现在就实施。你可以在这篇文章中了解到更多关于它背后的原因:https://bit.ly/2JCwyRp</p><p id="d993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个版本中，我们将张量从其计算路径中分离出来并克隆，或者我们先克隆然后分离。<em class="ku">如果您首先分离张量，然后克隆它，计算路径不会被复制，相反的方法会被复制，然后被放弃。由此可见，</em> <code class="du mc md me mf b"><em class="ku">.detach().clone()</em></code> <em class="ku">是非常略有效率的。[1] </em></p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mr"><img src="../Images/df7094059e33356d2e8472d8277ccf75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXqn8PX3BoTC4w7oeM2xqw.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">我们轻易地克隆了我们的张量！</figcaption></figure><p id="76b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，当我们克隆一个张量时，新的张量与原来的张量不共享相同的存储位置。但是一些克隆方法共享相同的内存，确保你选择你需要的那个！</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ms"><img src="../Images/8505042ea65737bbc5e55766341ceae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djBZyC8QBk7d9wGA3oJf_Q.jpeg"/></div></div></figure><p id="5c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进行相同操作的另一种方法是这样，但这不是最佳做法。所以最好避免用这个。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mt"><img src="../Images/440c10a22119fecea525f5560a70b365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_i8s5vElXwDu114CJIrgvQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">当您使用这种方法时，它也是有效的，但是PyTorch抛出一个类似这样的小警告:UserWarning:要从张量复制构造，建议使用sourceTensor.clone()。detach()或sourceTensor.clone()。分离()。需要_grad_(True)，而不是torch.tensor(sourceTensor)。</figcaption></figure><p id="9bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里很好地解释了两种方法的区别:<br/><a class="ae kv" href="https://bit.ly/3qvWv5J" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3qvWv5J</a></p><h1 id="28da" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">如何重塑一个张量？</strong></h1><p id="17e5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">PyTorch提供了操纵张量大小的不同方法。我们将在这里介绍其中一种，剩下的选项留给您。请点击这里查看:<a class="ae kv" href="https://bit.ly/3lHnoQN" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3lHnoQN</a></p><p id="42bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用torch.reshape()方法。它基本上返回一个元素数量相同但形状不同的张量。换句话说，行数和列数是不同的。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mu"><img src="../Images/4aeee5e460970335c16b53bbe72df144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ml7L_RBNGQXeTMRazLimjA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">当你在一个元组中指定新的大小时，它会自动为你创建新的张量。</figcaption></figure><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mv"><img src="../Images/21d4be3ae4d702a87d22b4f6d9403a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbMSIth_eq39XNBvkR8bIA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">小心，调整后的张量和原来的张量共享同一个内存位置！</figcaption></figure><h1 id="c8a0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何从列表中创建一个张量(反之亦然)？</h1><p id="da71" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">把列表变成张量真的很容易。这个过程非常类似于将numpy数组转化为张量。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mw"><img src="../Images/8d8df98554e8d1cf82e09532f483b9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtFXHwW9g5c7AGdXGSnLbg.png"/></div></div></figure><p id="f019" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只要列表包含适当的数据类型和大小，就可以很容易地创建张量。让我们看一个例子:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mx"><img src="../Images/11003361383986d82e986b8c5ab0e274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwEHvd2hoyBfA0oV282FRA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">确保你的维度适合形成张量！</figcaption></figure><p id="3178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以使用torch将张量转换成列表。Tensor.tolist()函数。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es my"><img src="../Images/2e245da2ce63a8f96812c3add93c66c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjKhhIbB4CNoC2LDIU8USw.png"/></div></div></figure><p id="b2d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">暂时就这样吧！希望你喜欢这个教程。敬请期待即将到来的，别忘了自己练习。</p><blockquote class="kw kx ky"><p id="8a39" class="if ig ku ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">包括这篇文章代码的笔记本链接可以在这里找到:【https://jovian.ai/semanurkps/most-wanted-tensor-operations<a class="ae kv" href="https://jovian.ai/semanurkps/most-wanted-tensor-operations" rel="noopener ugc nofollow" target="_blank"/></p><p id="4b6b" class="if ig ku ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">Jovian AI用PyTorch进行深度学习:Zero to GANs<br/>T5】https://jovian . AI/learn/Deep-Learning-with py torch-Zero to GANs</p></blockquote></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="af9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><p id="334e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[0]<a class="ae kv" href="https://pytorch.org/tutorials/beginner/blitz/tensor_tutorial.html" rel="noopener ugc nofollow" target="_blank">https://py torch . org/tutorials/初学者/blitz/tensor _ tutorial . html</a></p><p id="5761" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]<a class="ae kv" href="https://stackoverflow.com/questions/55266154/pytorch-preferred-way-to-copy-a-tensor" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/55266154/py torch-preferred-way-to-copy-a-tensor</a></p></div></div>    
</body>
</html>