<html>
<head>
<title>Why exploratory data analysis is important? Let’s find it out through a simple classification project.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么探索性数据分析很重要？让我们通过一个简单的分类项目来了解一下。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/why-exploratory-data-analysis-is-important-56154607ee9a?source=collection_archive---------28-----------------------#2020-05-12">https://medium.com/analytics-vidhya/why-exploratory-data-analysis-is-important-56154607ee9a?source=collection_archive---------28-----------------------#2020-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d6505737ba4f66ddc8b42fe3d4edd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6JmdXLzo0bvQCJD5ePdcQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">探索性数据分析</figcaption></figure><p id="5f8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用约翰·塔基的话说，</p><blockquote class="js jt ju"><p id="cc2a" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">探索性的数据分析</strong>永远不可能是故事的全部，<strong class="iw hj">却什么都不是</strong>除此之外<strong class="iw hj">可以把</strong>作为<strong class="iw hj">的基石</strong>——作为第一步。</p></blockquote><p id="ee06" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">写这篇文章的动机是我最近参与的项目，通过简单的探索性数据分析(只是一种类型的情节)得出的结论改变了游戏规则。然后我觉得我得分享一下这段经历。因此，我在这里写一篇关于它的文章。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="41f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将处理<a class="ae kg" href="https://www.kaggle.com/c/amazon-employee-access-challenge" rel="noopener ugc nofollow" target="_blank">这个</a>数据集。使用的数据集是亚马逊员工访问数据集。数据由资源是否分配给员工的信息组成。有几列提供了关于雇员及其角色的信息。我们需要预测Action列是否可以将资源授予员工。</p><p id="94e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">没错，就是一个简单的分类问题。数据集有两个CSV文件，即训练和测试。我们将只使用train.csv文件来训练和测试，因为test.csv文件中没有Action列。让我们将数据读入pandas数据框并对其进行处理。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ef7d" class="kq kr hi km b fi ks kt l ku kv">train = pd.read_csv('train.csv')<br/>train.shape</span></pre><p id="738e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">形状是(32769，10)。它有32，769条记录和10个属性。让我们看看头。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="23cc" class="kq kr hi km b fi ks kt l ku kv">train.head()</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/1f5af375365c91ab1f0c79c6a6b5a77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJdK712NXAvtD2E6rHR1DA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据中的几行</figcaption></figure><p id="4d10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从属性的名称中我们可以看到，它们都是名义上的(即它们仅用于标识对象；它们不能作为数字来操作)。让我们了解更多关于列的信息。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d94b" class="kq kr hi km b fi ks kt l ku kv">train.info()</span><span id="84cb" class="kq kr hi km b fi kx kt l ku kv">#the output is...</span><span id="7a72" class="kq kr hi km b fi kx kt l ku kv">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 32769 entries, 0 to 32768<br/>Data columns (total 10 columns):<br/>ACTION              32769 non-null int64<br/>RESOURCE            32769 non-null int64<br/>MGR_ID              32769 non-null int64<br/>ROLE_ROLLUP_1       32769 non-null int64<br/>ROLE_ROLLUP_2       32769 non-null int64<br/>ROLE_DEPTNAME       32769 non-null int64<br/>ROLE_TITLE          32769 non-null int64<br/>ROLE_FAMILY_DESC    32769 non-null int64<br/>ROLE_FAMILY         32769 non-null int64<br/>ROLE_CODE           32769 non-null int64<br/>dtypes: int64(10)<br/>memory usage: 2.5 MB</span></pre><p id="2f0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所有的属性都被编码成整数。没有空值，所以让我们跳过数据清理。但是如果我们观察行(在上图中),在一些列中有重复的值。因此，让我们计算每一列中唯一值的数量。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="826e" class="kq kr hi km b fi ks kt l ku kv">for i in train.columns:<br/>    print(i,len(train[i].unique()))</span><span id="0693" class="kq kr hi km b fi kx kt l ku kv">#the output is ...</span><span id="c06b" class="kq kr hi km b fi kx kt l ku kv">ACTION           2<br/>RESOURCE         7518<br/>MGR_ID           4243<br/>ROLE_ROLLUP_1    128<br/>ROLE_ROLLUP_2    177<br/>ROLE_DEPTNAME    449<br/>ROLE_TITLE       343<br/>ROLE_FAMILY_DESC 2358<br/>ROLE_FAMILY      67<br/>ROLE_CODE        343</span></pre><p id="25f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从输出中我们可以看出，在一些列中有很多重复的值，因为数据集中的记录数量大约为32，000条。ROLE_TITLE和ROLE_CODE具有相同数量的唯一值。嗯，这很可疑！让我们使用计数图探索更多。<br/>我已经为所有的柱子绘制了计数图，但这里我展示的是三个最引人注目的柱子。</p><p id="e040" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">角色标题和角色代码的计数图。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d048" class="kq kr hi km b fi ks kt l ku kv">plt.figure(figsize = (15,7))<br/>sns.countplot(train[‘ROLE_TITLE’])</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/0933ca88a70f4944138c39d374874e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWDSK_dHf9E0pX4DrVnNlg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">角色_职务计数图</figcaption></figure><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="155e" class="kq kr hi km b fi ks kt l ku kv">plt.figure(figsize = (15,7))<br/>sns.countplot(train[‘ROLE_CODE’])</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/d39c55eacef56dfc1fea47355a86c97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2QN9AfxZIls1uWhjeH5Hw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">角色代码计数图</figcaption></figure><p id="4f09" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">究竟是什么！！</strong>除了最右边的部分，它们<strong class="iw hj">看起来完全一样</strong>。谁会想到这两个属性用不同的编码值引用完全相同的东西呢？因此，我们可以在分类时排除其中一个。否则，分类算法可能会假设这些属性之间存在某种关系。</p><p id="d4e5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在第三个情节。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2998" class="kq kr hi km b fi ks kt l ku kv">plt.figure(figsize = (20,10))<br/>sns.countplot(train[‘ROLE_ROLLUP_1’])</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/943e841d4236dd7f7190be565a065601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8VToACBbUtHEpv28yp2kQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Role_rollup_1的计数图</figcaption></figure><p id="b47e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">轰！！！整个ROLE_ROLLUP_1列中的单个值重复了20，000次以上。这意味着在整个数据集的2/3行中。</strong>我们来确认一下。</p><p id="9e0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们来求值，看看重复了多少次。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="da91" class="kq kr hi km b fi ks kt l ku kv">train[‘ROLE_ROLLUP_1’].mode()</span></pre><p id="8dd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们得到117961作为输出。让我们通过熊猫掩蔽来发现它重复了多少次。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a200" class="kq kr hi km b fi ks kt l ku kv">p = train[[‘ROLE_TITLE’,’ROLE_ROLLUP_1',’ACTION’]]<br/>p = p.loc[p[‘ROLE_ROLLUP_1’] == 117961]<br/>p.shape</span></pre><p id="4b13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们得到的形状为(21407，3)。<strong class="iw hj">这是整个32，769条记录数据集中的行数，具有该值的行出现了21，407次。嘣！！</strong></p><p id="7675" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看这个值与ACTION列是否有任何关系。ACTION是表示资源是否被授权的列。让我们通过熊猫掩蔽来找到它。让我们看看这个值被授予了多少次资源。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="19e3" class="kq kr hi km b fi ks kt l ku kv">z = p.loc[p['ACTION'] == 1]<br/>z.shape</span></pre><p id="a53f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们得到的形状为(20320，3)。大约只删除了1100行。这意味着只有一千一百次资源没有被授予。如果我们反过来看，21407次资源中的20320次无论是资源还是任何其他列。</p><p id="72f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">这是巨大的！！！。94.92%的时间资源被授予此ROLE_ROLLUP_1值。</strong></p><p id="152a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谁能想到，在那堆名义属性里，还藏着这种信息！而且更神奇的是这个结论是由单个计数图得出的！！</p><p id="6ab9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我想现在你更明白约翰·塔基的话了…</p><blockquote class="js jt ju"><p id="b6b0" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">探索性的数据分析</strong>永远不可能是全部，<strong class="iw hj">但除此之外<strong class="iw hj">没有什么</strong>可以作为</strong>的基石<strong class="iw hj"/>——作为第一步。</p></blockquote></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="1711" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们来分类！</p><p id="2c93" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们将训练数据帧分成训练集和验证集。我删除了ROLE_CODE，因为它与ROLE_TITLE相同。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6d0e" class="kq kr hi km b fi ks kt l ku kv">from sklearn.model_selection import train_test_split<br/>X = train.drop([‘ACTION’,’ROLE_CODE’,’MGR_ID’],axis = 1)<br/>y = train[‘ACTION’]<br/>X_train,X_valid,y_train,y_valid = train_test_split(X,y,test_size = 0.3)</span></pre><p id="8848" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们应用随机森林分类。让我们考虑200个评估者。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2e1d" class="kq kr hi km b fi ks kt l ku kv">from sklearn.ensemble import RandomForestClassifier<br/>rfc = RandomForestClassifier(n_estimators = 200)<br/>rfc.fit(X_train,y_train)<br/>rfc_pred = rfc.predict(X_valid)</span></pre><p id="d92a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们来计算分类报告和混淆矩阵。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e5bb" class="kq kr hi km b fi ks kt l ku kv">from sklearn.metrics import classification_report,confusion_matrix<br/>print(confusion_matrix(y_valid,rfc_pred))<br/>print(classification_report(y_valid,rfc_pred))</span><span id="fdc4" class="kq kr hi km b fi kx kt l ku kv">#output is...</span><span id="dd38" class="kq kr hi km b fi kx kt l ku kv">[[  94  236]<br/> [  74 6019]]<br/>              precision    recall  f1-score   support<br/><br/>           0       0.56      0.28      0.38       330<br/>           1       0.96      0.99      0.97      6093<br/><br/>    accuracy                           0.95      6423<br/>   macro avg       0.76      0.64      0.68      6423<br/>weighted avg       0.94      0.95      0.94      6423</span></pre><p id="61eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们有95%的准确率！这很好。但是我们的召回率和f1-标签0的分数非常低。这是因为数据集严重偏向标签1。从混淆矩阵中我们可以看到，标签0只出现了330次。</p><p id="60f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，探索性数据分析很重要，因为它提供了对数据集的更好理解。它还提供了开发适当的机器学习模型所需的上下文信息。</p><p id="46da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完成<a class="ae kg" href="https://github.com/narsym/Amazon-Employee-Access-challenge" rel="noopener ugc nofollow" target="_blank">项目</a>的链接。</p><p id="394f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望文章不无聊，感谢阅读！！！</p></div></div>    
</body>
</html>