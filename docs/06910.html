<html>
<head>
<title>How to Import Indian equities Data to zipline on your local machine?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将印度股票数据导入本地机器上的zipline？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-import-indian-equities-data-to-zipline-on-your-local-machine-3b8587aaf112?source=collection_archive---------4-----------------------#2020-06-07">https://medium.com/analytics-vidhya/how-to-import-indian-equities-data-to-zipline-on-your-local-machine-3b8587aaf112?source=collection_archive---------4-----------------------#2020-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="be0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">乘</em><a class="ae je" href="https://www.linkedin.com/in/sabirjana/" rel="noopener ugc nofollow" target="_blank">T5】萨比尔贾纳T7】</a></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/034fb212980e768ef3ef6410985b4fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H45GbAp2VlSKA-xQemeWsA.png"/></div></div></figure></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="ae0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">zipline可能是最成熟和最强大的回溯测试和实时交易引擎。它由quanto pian Inc .<a class="ae je" href="https://www.quantopian.com/home" rel="noopener ugc nofollow" target="_blank">Quantopian </a>开发、维护并用于生产，quanto pian是一家总部位于波士顿的众源技术和资产管理公司。任何人都可以在他们的网站上创建一个免费账户，用丰富的基本面和分钟级数据来开发和回测他们的策略。</p><p id="8d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">zipline是他们网站的回溯测试引擎。但是，它也可以下载并安装在本地。滑索的本地安装有点复杂，因此你需要参考<a class="ae je" href="https://www.zipline.io/" rel="noopener ugc nofollow" target="_blank">滑索文档</a>来了解如何执行本地安装。使用他们的网站，免费获得丰富的历史数据，比在本地运行策略要容易得多。然而，在他们网站上做的一切都需要留在网站上。</p><p id="340b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您有zipline的本地设置时，您需要提供自己的数据。这被称为摄取您自己的定制包。有一些关于如何建立单一资产数据的帮助，但是，没有多少关于多种股票的信息。<a class="ae je" href="https://www.followingthetrend.com/" rel="noopener ugc nofollow" target="_blank"> Andreas F. Clenow </a>在他的杰出著作《交易进化:任何人都可以用Python构建黑仔交易策略》中很好地解释了建立自己的定制捆绑包的过程<a class="ae je" href="https://www.amazon.in/Trading-Evolved-Anyone-Killer-Strategies-ebook/dp/B07VDLX55H" rel="noopener ugc nofollow" target="_blank">。然而，如果你想为印度股票做这件事，尤其是使用免费的Quandl数据，会面临许多挑战。</a></p><p id="ef02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将一步一步地介绍如何为S&amp;P BSE 500成份股创建自己的定制包，假设您已经创建了一个虚拟环境<code class="du jy jz ka kb b">env_zipline</code>，并在本地机器上安装了zipline。</p><p id="dfc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">以下是获取您自己的定制包并测试它的步骤:</strong></p><ol class=""><li id="a97e" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">从Quandl下载500只股票数据，作为个人存储。csv文件。</li><li id="e0c8" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">清理数据以匹配<code class="du jy jz ka kb b">'XBOM’</code>交易日历并创建自定义捆绑包。</li><li id="8386" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">摄取S&amp;P BSE 500指数500只股票过去15年的每日OHLCV数据。</li><li id="8297" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">通过运行Infosys Ltd .股票的移动平均交叉策略来测试您新创建的定制捆绑包。</li></ol></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="c09c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">从Quandl下载500只股票数据，单独存储。csv文件</strong></p><p id="bf12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Quandl提供免费的孟买证券交易所(BSE)数据馈送，包含来自BSE的每日收盘股票价格和指数。这个数据输入包含4，566个时间序列，每个序列对应一个股票或指数。您需要有一个免费的Quandl 帐户来访问此数据馈送。你还需要一个包含标准普尔BSE 500指数500只成份股的股票代码。请到<a class="ae je" href="https://www.bseindia.com/sensex/code/17" rel="noopener ugc nofollow" target="_blank">https://www.bseindia.com/sensex/code/17</a>下载‘BSE 500 index _ constituents . CSV’文件。我假设在您的本地机器上已经有了Anaconda 设置。如果没有，请这样做。这部分我用的是Jupyter笔记本，你可以用任何你熟悉的IDE。</p><p id="1182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有Quandl，请安装它。</p><p id="a6ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jy jz ka kb b">$pip install Quandl</code></p><p id="cd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本节中的代码将执行以下任务:</p><ol class=""><li id="bd1a" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">将“Index Constituents.csv”文件作为熊猫数据帧读取。</li><li id="6453" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">创建一个S&amp;P BSE 500成份股的所有501个报价机的列表。</li><li id="79c6" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">从Quandl下载这些tickers的每日定价数据。</li><li id="a180" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">过滤所需的列以创建您自己的定制包，并将它们重命名为<code class="du jy jz ka kb b">[‘open’,’high’,’low’,’close’,’volume’]</code>。</li></ol><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="6e05" class="ku kv hi kb b fi kw kx l ky kz"># Do necessary Imports<br/>import os<br/>import numpy as np<br/>import pandas as pd<br/>from pathlib import Path<br/>import quandl</span><span id="dc70" class="ku kv hi kb b fi la kx l ky kz"># Read BSE 500 Constituents csv file<em class="jd"><br/></em>bse500_metadata = pd.read_csv('BSE 500index_Constituents.csv')<em class="jd"><br/></em>bse500_metadata.head(2)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lb"><img src="../Images/f0b5e3f8e9767eceb25011eb6ee27d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50zsSMGvMgsAvTXgdZ_59g.png"/></div></div></figure><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="aba3" class="ku kv hi kb b fi kw kx l ky kz"># Get all 500+ tickers<br/>tickers = list(bse500_metadata[‘Scrip Code’])</span><span id="c740" class="ku kv hi kb b fi la kx l ky kz"># Input your quandl key<br/>quandl.ApiConfig.api_key = &lt;"your quandl key goes here"&gt;</span><span id="9fe4" class="ku kv hi kb b fi la kx l ky kz"># Start Bulk download in a loop and create a Dataframe <br/>def get(tickers): <br/> def data(ticker):<br/>  print(‘Processing…’, f’BSE/BOM{ticker}’)<br/>  return (quandl.get(f’BSE/BOM{ticker}’))<br/>  datas = map(data, tickers)<br/>  return(pd.concat(datas, keys=tickers, names=[‘ticker’, ‘date’]))<br/> <br/>df = get(tickers)</span></pre><p id="c9fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将需要一些时间，因为这将下载501 tickers数据。进度将显示为:</p><p id="8ea3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加工… BSE/BOM523395 <br/>加工… BSE/BOM541988 <br/> …</p><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="e0e5" class="ku kv hi kb b fi kw kx l ky kz"># Verify the head of Dataframe<br/>df.head(2)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lc"><img src="../Images/5f6df345115b1578afd43c022cbf97a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOfwbEgf8gGM9VM7kVar4Q.png"/></div></div></figure><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="8732" class="ku kv hi kb b fi kw kx l ky kz"># filter required columns from Dataframe<br/>columns = [‘Open’,’High’,’Low’,’Close’,’No. of Trades’]</span><span id="3e0a" class="ku kv hi kb b fi la kx l ky kz"># Rename the columns as per zipline requirement<br/>prices.columns = ['open','high','low','close','volume']<br/>prices.head(2)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ld"><img src="../Images/1576820dae511199a627c3d0ae6905e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*TPfLcrADsLNUvTIh53joVQ.png"/></div></figure><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="064d" class="ku kv hi kb b fi kw kx l ky kz"># Write a csv file for each ticker<br/>for ticker in tickers:<br/> df = prices.loc[ticker]<br/> df.to_csv(f’bse500/{ticker}.csv’, index=True)</span></pre><p id="b264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将生成501。<code class="du jy jz ka kb b"> bse500</code>文件夹中的csv文件，如500410.csv、500488.csv等。的。csv文件看起来会像这样:</p><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="bda8" class="ku kv hi kb b fi kw kx l ky kz">date,open,high,low,close,volume<br/>1991–01–02,1500.0,1500.0,1475.0,1475.0,0.0<br/>1991–01–03,1475.0,1500.0,1350.0,1400.0,0.0<br/>1991–01–07,1450.0,1475.0,1400.0,1450.0,0.0<br/>1991–01–09,1475.0,1500.0,1450.0,1475.0,0.0<br/>1991–01–11,1425.0,1500.0,1425.0,1500.0,0.0</span></pre></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="3221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">清理数据以匹配</strong> <code class="du jy jz ka kb b"><strong class="ih hj">'XBOM’</strong></code> <strong class="ih hj">交易日历并创建自定义捆绑包</strong></p><p id="3c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要为此编写一个Python脚本。为此，我将使用Anaconda Spyder，但是，您可以自由选择任何Python编辑器。这是一个两步过程。首先，我们将编写一个包，然后，这个新包将被注册。</p><p id="41ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请打开您选择的Python编辑器来创建新的Python脚本。我们进行必要的导入并建立路径。csv文件驻留在。</p><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="a5ff" class="ku kv hi kb b fi kw kx l ky kz"># necessary imports<br/>import pandas as pd<br/>from os import listdir<br/>from trading_calendars import get_calendar</span><span id="94e1" class="ku kv hi kb b fi la kx l ky kz"># the path to where you have your data<br/>path = 'C:\Users\sabirj\Desktop\P4Finance\bse500 bundle\bse500'</span></pre><p id="7f7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要编写<code class="du jy jz ka kb b">ingest</code>函数。在我们的例子中，它将是<code class="du jy jz ka kb b">bse_data</code>。该函数负责将数据加载到内存中，并将其传递给zipline提供的一组writer对象，以将数据转换为zipline的内部格式。该功能执行以下任务:</p><ol class=""><li id="17da" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">全部阅读。指定位置的csv文件。</li><li id="046e" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">准备股息、拆分和元数据数据框架的结构。我们没有分红，也不会将信息拆分到我们的数据中，但这是为了以防万一。</li><li id="3a7b" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">使用<code class="du jy jz ka kb b">start_session, end_session</code>检查我们交易日历的有效交易日历日期。我们将从捆绑包注册的第二部分中读取这些日期。我们将指定对BSE和NSE都有效的交易日历<code class="du jy jz ka kb b">‘XBOM’</code>。</li></ol><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="0edb" class="ku kv hi kb b fi kw kx l ky kz"># The ingest function needs to have this exact signature<br/>def bse_data(environ,<br/>                  asset_db_writer,<br/>                  minute_bar_writer,<br/>                  daily_bar_writer,<br/>                  adjustment_writer,<br/>                  calendar,<br/>                  start_session,<br/>                  end_session,<br/>                  cache,<br/>                  show_progress,<br/>                  output_dir):<br/>    <br/>    # Get list of files from path<br/>    # Slicing off the last part<br/>    # 'example.csv'[:-4] = 'example'<br/>    symbols = [f[:-4] for f in listdir(path)]<br/>    <br/>    if not symbols:<br/>        raise ValueError("No symbols found in folder.")<br/>        <br/>        <br/>    # Prepare an empty DataFrame for dividends<br/>    divs = pd.DataFrame(columns=['sid', <br/>                                 'amount',<br/>                                 'ex_date', <br/>                                 'record_date',<br/>                                 'declared_date', <br/>                                 'pay_date']<br/>    )<br/>    <br/>    # Prepare an empty DataFrame for splits<br/>    splits = pd.DataFrame(columns=['sid',<br/>                                   'ratio',<br/>                                   'effective_date']<br/>    )<br/>    <br/>    # Prepare an empty DataFrame for metadata<br/>    metadata = pd.DataFrame(columns=('start_date',<br/>                                              'end_date',<br/>                                              'auto_close_date',<br/>                                              'symbol',<br/>                                              'exchange'<br/>                                              )<br/>                                     )</span><span id="1339" class="ku kv hi kb b fi la kx l ky kz"># Check valid trading dates, according to the selected exchange    calendar<br/>    sessions = calendar.sessions_in_range(start_session, end_session)</span><span id="25a8" class="ku kv hi kb b fi la kx l ky kz"># Get data for all stocks and write to Zipline<br/>    daily_bar_writer.write(<br/>            process_stocks(symbols, sessions, metadata, divs)<br/>            )</span><span id="5f52" class="ku kv hi kb b fi la kx l ky kz"># Write the metadata<br/>    asset_db_writer.write(equities=metadata)<br/>    <br/>    # Write splits and dividends<br/>    adjustment_writer.write(splits=splits,<br/>                            dividends=divs)</span></pre><p id="1015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将编写生成器函数<code class="du jy jz ka kb b">process_stocks</code>，它将执行以下任务:</p><ol class=""><li id="574a" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">迭代我们的。csv文件来加载历史数据和填充熊猫数据框架。</li><li id="1591" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">对于每个股票，根据有效的交易日历日期过滤并仅获取行。这是非常重要的一步，因为交易日历不支持节假日、额外交易日和Muhurat交易。这种过滤发生在一行中；<code class="du jy jz ka kb b">df = df[df.index.isin(sessions)]</code>。</li><li id="1261" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">返回日棒线编写器所需的历史数据，并填充元数据和红利(如果提供了数据)。</li><li id="1cbd" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">指定<code class="du jy jz ka kb b">‘XBOM’</code>作为我们的交易日历。</li></ol><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="c8f9" class="ku kv hi kb b fi kw kx l ky kz"># Generator function to iterate stocks, build historical data, <br/># metadata and dividend data<br/>def process_stocks(symbols, sessions, metadata, divs):<br/> # Loop the stocks, setting a unique Security ID (SID)<br/> for sid, symbol in enumerate(symbols):<br/>   print(‘Loading {}…’.format(symbol))<br/> <br/>   # Read the stock data from csv file.<br/>   df = pd.read_csv(‘{}/{}.csv’.format(path, symbol), index_col=[0], parse_dates=[0])</span><span id="3f8f" class="ku kv hi kb b fi la kx l ky kz"># filter data for valide trading calendar dates<br/>   df = df[df.index.isin(sessions)]<br/> <br/>   start_date = df.index[0]<br/>   end_date = df.index[-1]</span><span id="3a73" class="ku kv hi kb b fi la kx l ky kz"># Synch to the official exchange calendar<br/>   df = df.reindex(sessions.tz_localize(None))[start_date:end_date]</span><span id="d579" class="ku kv hi kb b fi la kx l ky kz"># Forward fill missing data<br/>   df.fillna(method=’ffill’, inplace=True)<br/> <br/>   # Drop remaining NaN<br/>   df.dropna(inplace=True) <br/> <br/>   # The auto_close date is the day after the last trade.<br/>   ac_date = end_date + pd.Timedelta(days=1)<br/> <br/>   # Add a row to the metadata DataFrame. Don’t forget to add an exchange field.<br/>   metadata.loc[sid] = start_date, end_date, ac_date, symbol, ‘XBOM’<br/> <br/>   # If there’s dividend data, add that to the dividend DataFrame<br/>   if ‘dividend’ in df.columns:<br/>    # Slice off the days with dividends<br/>     tmp = df[df[‘dividend’] != 0.0][‘dividend’]<br/>     div = pd.DataFrame(data=tmp.index.tolist(), columns=[‘ex_date’])<br/> <br/>    # Provide empty columns as we don’t have this data for now<br/>    div[‘record_date’] = pd.NaT<br/>    div[‘declared_date’] = pd.NaT<br/>    div[‘pay_date’] = pd.NaT <br/> <br/>    # Store the dividends and set the Security ID<br/>    div[‘amount’] = tmp.tolist()<br/>    div[‘sid’] = sid<br/> <br/>    # Start numbering at where we left off last time<br/>    ind = pd.Index(range(divs.shape[0], divs.shape[0] + div.shape[0]))<br/>    div.set_index(ind, inplace=True)<br/> <br/>    # Append this stock’s dividends to the list of all dividends<br/>    divs = divs.append(div) <br/> yield sid, df</span></pre><p id="1003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要将文件保存为<code class="du jy jz ka kb b">india_stock_data.py</code>并将其移动到<code class="du jy jz ka kb b">..\ProgramData\Anaconda3\envs\env_zipline\Lib\site-packages\zipline\data\bundles</code>文件夹下。</p><p id="25e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将进入第二部分，即捆绑注册。这相当简单快捷。你需要在<code class="du jy jz ka kb b">Users\&lt;user&gt;\.zipline</code>文件夹下寻找<code class="du jy jz ka kb b">extension.py</code>。请在您选择的Python编辑器中打开此文件，并添加以下代码。这将执行以下任务:</p><ol class=""><li id="56b7" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">Resister <code class="du jy jz ka kb b">bse_data</code>作为一个新的定制捆绑包。</li><li id="1e2f" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">指定在<code class="du jy jz ka kb b">start_session</code>和<code class="du jy jz ka kb b">end_session</code>之间的有效交易日历日期，我们在第一部分中使用这些日期来过滤我们的数据。</li></ol><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="5091" class="ku kv hi kb b fi kw kx l ky kz"># necessary imports<br/>import pandas as pd<br/>from zipline.data.bundles import register, india_stock_data</span><span id="4a68" class="ku kv hi kb b fi la kx l ky kz">start_session = pd.Timestamp(‘2005–01–03’, tz=’utc’)<br/>end_session = pd.Timestamp(‘2020–05–20’, tz=’utc’)</span><span id="bf95" class="ku kv hi kb b fi la kx l ky kz">register(<br/> ‘bse_data’,<br/> india_stock_data.bse_data,<br/> calendar_name=’XBOM’,<br/> start_session=start_session,<br/> end_session=end_session</span><span id="86a7" class="ku kv hi kb b fi la kx l ky kz">)</span></pre></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="b0e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">获取标准普尔BSE 500&amp;的500只股票过去15年的每日OHLCV数据</strong></p><p id="1cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经完成了所有的艰苦工作，现在是加载数据的时候了！您需要进入命令提示符并运行下面给出的命令。</p><p id="6dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jy jz ka kb b">$conda activate env_zipline</code></p><p id="059c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jy jz ka kb b">$zipline ingest -b bse_data</code></p><p id="7dfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该会开始将您的数据加载到zipline，您应该会看到类似这样的内容:</p><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="06ee" class="ku kv hi kb b fi kw kx l ky kz">(env_zipline) PS C:\Users\sabirj&gt; zipline ingest -b bse_data Loading 500003…<br/>Loading 500008…<br/>Loading 500010…<br/>Loading 500020…<br/>Loading 500027…<br/>Loading 500031…<br/>Loading 500033…</span></pre><p id="af53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦数据加载完成，您需要运行下面的命令来检查包。<code class="du jy jz ka kb b">bse_data</code>应该在名单上。</p><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="8098" class="ku kv hi kb b fi kw kx l ky kz">zipline bundles</span><span id="be75" class="ku kv hi kb b fi la kx l ky kz">(env_zipline) PS C:\Users\sabirj&gt; zipline bundles bse_data 2020–06–06 07:16:23.009573<br/>bse_data 2020–06–03 08:02:21.869497<br/>bse_data 2020–06–03 08:01:47.696447<br/>bse_data 2020–06–03 07:57:22.557573<br/>bse_data 2020–06–03 07:50:10.828655<br/>bse_data 2020–06–03 07:44:21.626445<br/>bse_data 2020–06–03 07:35:54.149334<br/>bse_data 2020–06–03 07:21:41.360368<br/>bse_data 2020–06–03 07:15:00.297208<br/>bse_data 2020–06–03 07:12:33.342635<br/>bse_data 2020–06–01 05:27:41.900309<br/>bse_data 2020–06–01 04:25:14.641486<br/>csvdir 2020–05–30 15:48:52.453535<br/>csvdir 2020–05–30 15:47:38.997242<br/>csvdir 2020–05–30 15:44:16.304702<br/>quandl 2020–05–01 09:02:42.886594<br/>quandl 2020–05–01 07:56:14.848811<br/>quandl 2020–05–01 06:39:10.659670<br/>quandl 2020–05–01 06:38:00.607966<br/>quandl 2020–05–01 06:32:41.798931<br/>quandl 2020–05–01 06:29:42.382986<br/>quandl 2020–05–01 06:26:05.043059<br/>quantopian-quandl 2020–05–06 16:02:58.453567</span></pre></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="f9c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通过运行Infosys Ltd .股票的移动平均交叉策略，测试您新创建的定制捆绑包。</strong></p><p id="ec49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们快完成了！然而，测试我们新创建的包是非常重要的。很多时候可以看到，包创建成功，但是当您试图使用它进行回溯测试时，它会抛出一个意外的错误。因此，我想确保我们的定制捆绑包不会出现这种情况。</p><p id="b2fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将为Infosys Ltd .的股票测试一个非常简单的并购交叉策略。我们将50天作为短均线，100天作为长均线。如果短期移动平均线大于长期移动平均线，那么我们就去买10只印孚瑟斯的股票。然而，如果短期均线小于长期均线，我们就平仓。我们将使用2015年1月1日至2020年5月20日的开始和结束日期。这只是为了测试新摄入的捆绑，所以，不要以此来判断策略。我不会解释这部分的代码，因此如果你不知道，你可能需要解决这个问题。</p><p id="b706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是代码。</p><pre class="jg jh ji jj fd kq kb kr ks aw kt bi"><span id="a0d8" class="ku kv hi kb b fi kw kx l ky kz"># necessary inports.<br/>%matplotlib inline<br/>from zipline import run_algorithm<br/>from zipline.api import order_target_percent, order_target, symbol<br/>from datetime import datetime<br/>import pytz<br/>import matplotlib.pyplot as plt</span><span id="b797" class="ku kv hi kb b fi la kx l ky kz"># Set start and end date<br/>start_date = datetime(2015, 1, 1, tzinfo=pytz.UTC)<br/>end_date = datetime(2020, 5, 20, tzinfo=pytz.UTC)</span><span id="de98" class="ku kv hi kb b fi la kx l ky kz">def initialize(context):<br/>    # Infosys Ltd. as stock<br/>    context.stock = symbol('500209')<br/>    context.i = 0</span><span id="b412" class="ku kv hi kb b fi la kx l ky kz">def handle_data(context, data):<br/>    # Skip first 100 days to get full windows<br/>    context.i += 1<br/>    if context.i &lt; 100:<br/>        return</span><span id="135a" class="ku kv hi kb b fi la kx l ky kz">    # Compute averages<br/>    # data.history() has to be called with the same params<br/>    # from above and returns a pandas dataframe.<br/>    short_mavg = data.history(context.stock, 'price', bar_count=50, frequency="1d").mean()<br/>    long_mavg = data.history(context.stock, 'price', bar_count=100, frequency="1d").mean()</span><span id="dcd5" class="ku kv hi kb b fi la kx l ky kz">    # Trading logic<br/>    if short_mavg &gt; long_mavg:<br/>        # order_target orders as many shares as needed to<br/>        # achieve the desired number of shares.<br/>        order_target(context.stock, 10)<br/>    elif short_mavg &lt; long_mavg:<br/>        order_target(context.stock, 0)</span><span id="b1ed" class="ku kv hi kb b fi la kx l ky kz">def analyze(context, perf):<br/>    fig = plt.figure(figsize=(12, 8))<br/>    <br/>    # First chart<br/>    ax = fig.add_subplot(311)<br/>    ax.set_title('Strategy Results')<br/>    ax.plot(perf['portfolio_value'], linestyle='-', <br/>                label='Equity Curve', linewidth=1.0)<br/>    ax.legend()<br/>    ax.grid(False)<br/>    <br/>    # Second chart<br/>    ax = fig.add_subplot(312)<br/>    ax.plot(perf['gross_leverage'], <br/>            label='Exposure', linestyle='-', linewidth=1.0)<br/>    ax.legend()<br/>    ax.grid(True)</span><span id="bc7d" class="ku kv hi kb b fi la kx l ky kz">    # Third chart<br/>    ax = fig.add_subplot(313)<br/>    ax.plot(perf['returns'], label='Returns', linestyle='-.', linewidth=1.0)<br/>    ax.legend()<br/>    ax.grid(True)<br/>    plt.savefig('strategy',dpi=400)<br/>    <br/># Fire off the backtest<br/>results = run_algorithm(<br/>    start=start_date, <br/>    end=end_date, <br/>    initialize=initialize, <br/>    analyze=analyze, <br/>    handle_data=handle_data, <br/>    capital_base=10000, <br/>    data_frequency = 'daily', <br/>    bundle='bse_data' <br/>)</span></pre><p id="4fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果新接收的包工作正常，您应该得到下面的输出。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es le"><img src="../Images/a36bcad36ccc7ccbcbb89aeb8e753d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDmjmh_WOSZKpy0i8sSbdw.png"/></div></div></figure><p id="6b04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在就这样吧！我已经分享了所有需要的代码。只需复制并粘贴这篇文章中的代码，它应该可以工作。但是，如果需要，请随时与我联系。享受zipline的回溯测试吧！</p><p id="829a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在我的<a class="ae je" href="https://github.com/sabirjana/blog/tree/master/Custom_bundle_zipline" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Github </strong> </a>页面找到与本文相关的代码。</p><p id="38de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ol class=""><li id="7be8" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated"><a class="ae je" href="https://www.followingthetrend.com/" rel="noopener ugc nofollow" target="_blank">Andreas f . cle now</a>—<a class="ae je" href="https://www.amazon.in/Trading-Evolved-Anyone-Killer-Strategies-ebook/dp/B07VDLX55H" rel="noopener ugc nofollow" target="_blank">‘交易进化了:任何人都可以用Python构建黑仔交易策略’</a>。</li><li id="cf7d" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated"><a class="ae je" href="https://www.zipline.io/" rel="noopener ugc nofollow" target="_blank">滑索文件</a></li></ol></div></div>    
</body>
</html>