<html>
<head>
<title>The Bellman-Ford Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贝尔曼-福特算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-bellman-ford-algorithm-a0801afc333f?source=collection_archive---------9-----------------------#2020-05-03">https://medium.com/analytics-vidhya/the-bellman-ford-algorithm-a0801afc333f?source=collection_archive---------9-----------------------#2020-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给你一个加权图。您知道源，需要通过最短路径到达所有其他顶点。你是怎么解决这个问题的？你选择Dijkstra的算法。但是如果包含了负权重呢？Dijkstra不能解决这个问题。我们现在需要一个新的算法。</p><p id="0720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝尔曼-福特算法是一种类似于Dijkstra的算法，即它在图中找到从单个源顶点到加权图中所有其他顶点的最短路径，但即使在存在负权重时它也能工作。</p><p id="8c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">灰暗的图表</strong></p><p id="20e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个灰暗的图就是我所说的负权重的图。它实际上不叫这个，但是这个名字很合适，不是吗？负权重就像正权重一样，是边缘顶部的值。为什么有人会有负权重的图呢？因为它们并不像看起来那么没用。负权重可以解释很多现象，例如您的储蓄，其中正边缘可以代表花费的金钱，但负边缘将是您想要获取的边缘，因为它将代表获得的现金，或者热反应，其中每个正权重将代表热耗散，每个负权重将显示热吸收，并且必须计算发现最小能量的反应集。</p><p id="2a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是那么悲观的部分呢？它来了。为<strong class="ih hj">负周期</strong>让路。这是需要小心的。循环是指第一个和最后一个顶点相同的路径，也就是说，它是一条封闭的路径。所以一个负循环就变成了一个加起来是负值的循环。最短路径算法不能检测到这种循环并给出不正确的结果。这是连贝尔曼·福特算法都无法战胜的。请看下面的插图，以获得更好的想法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cc72b02a6564dda8f6858ec282541942.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/0*DgSEF91j8TZspKWF.jpg"/></div></figure><p id="7f12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此图中，顶点B、C和D形成一个循环，其中起始节点是B，它也是结束节点。此外，这个循环也是一个负循环，因为总值总和为负值-1。</p><p id="4354" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">算法</strong></p><p id="108c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这个算法要知道的第一点是，它不适用于像Dijkstra这样贪婪的算法。是的，他们相似但不相同，咄！采用动态规划方法来实现该程序。继续深入理解这个算法。</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="f5cf" class="jq jr hi jm b fi js jt l ju jv">function bellmanFord(G, S)<br/>	for each vertex V in G<br/>			D[V] &lt;- infinite<br/>			<br/>	D[S] &lt;- 0<br/>	for each vertex V in G				<br/>		for each edge (U,V) in G<br/>		  tempDistance &lt;- D[U] + edge_weight(U,V)<br/>			if tempDistance &lt; D[V]<br/>			   D[V] &lt;- tempDistance<br/>			   </span><span id="6c83" class="jq jr hi jm b fi jw jt l ju jv">	for each edge (U,V) in G<br/>		If D[U] + edge_weight(U, V) &lt; D[V]<br/>			Error: Negative Cycle Exists<br/>                        return</span><span id="cd95" class="jq jr hi jm b fi jw jt l ju jv">	print D[]</span></pre><p id="6f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">暂时不要进入恐慌状态。我们会详细讨论。</p><p id="85be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说定义，贝尔曼-福特算法的工作原理是首先<strong class="ih hj">高估从起始顶点到所有其他顶点的路径长度</strong>。然后，它通过寻找比先前高估的路径更短的新路径来迭代地放松那些估计。最后，它<strong class="ih hj">检查负周期</strong></p><p id="24a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更简单地说，假设V是顶点的数量，E是边的数量，S是起始节点，D是跟踪源节点和其余顶点之间的最佳距离的数组。好吗？</p><p id="0729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在高估步骤之后，我们将数组中的每个条目设置为+无穷大，类似于Dijkstra。这是因为到每个节点的距离最初是未知的，所以我们分配可能的最高值。现在我们指定D[S]=0的原因很明显，因为从源到源的最小距离是，猜猜看？明明是0。所以我们已经达到了如下所示的状态</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/f5b36a06c6684ddbe5384df23e9f97c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*N0SMJtyDlvV5MR3hyuHVWw.png"/></div></figure><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="1abb" class="jq jr hi jm b fi js jt l ju jv">for each vertex V in G<br/>			D[V] &lt;- infinite<br/>			previous[V] &lt;- NULL<br/>	distance[S] &lt;- 0</span></pre><p id="51fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，无限的水平对我们来说太高了，压力正在增加。所以是时候重新开始了！在这一步，我们的目标是找到我们一直在寻找的东西，到每个顶点的最短路径。我们开始一个循环，对每条边运行V次，因为在最坏的情况下，一个顶点的路径长度可能需要调整V次。在循环中，对于每条边，我们从边开始的地方取顶点的值(D[U])并将其添加到边成本中。这个增加的值是它们与边结束的顶点的值(D[V])的比较。如果发现总和值更小，则结束顶点值(D[V])变得等于总和。</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="6c45" class="jq jr hi jm b fi js jt l ju jv">for each vertex V in G				<br/>		for each edge (U,V) in G<br/>		  tempDistance &lt;- D[U] + edge_weight(U,V)<br/>			if tempDistance &lt; D[V]<br/>			   D[V] &lt;- tempDistance<br/>			   </span></pre><p id="38eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举个例子，我们将通过几个步骤来理解其功能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/cc6255b103d8f71cc383d0e2b3f18477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*qo6RkqhS1077NIwnkp8zGg.png"/></div></figure><p id="3f27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此图中，0被视为源顶点。从循环开始，我们取的第一条边是0 →1，之后1被赋值为5。接下来，取边1→2、1 →5和1 →6，由此，6的值变为(5+60，即源顶点1的成本加到边的成本，60)= 65，2变为(5+20)= 25，5变为(5+30)= 35。同样，3的值变成35。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jz"><img src="../Images/1e00c86ac5d91a3795a0e1cfb21f389a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*1XOL4lqcQAqESSJmkxe_TQ.png"/></div></figure><p id="813f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在确定了3的成本之后，我们取下一个边，它们是3 →2和2→4。<strong class="ih hj">这使得2的值为(35 -15)=20 </strong>，4的值为100。20是从先前的25降低的值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ka"><img src="../Images/a20d3014ade635192c06f4314b450114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*KPjnLVcJ4hsmIaUNQyZtxQ.png"/></div></figure><p id="4f79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续循环，边4 →9使9的值为200。<strong class="ih hj">现在另一个优化点需要仔细注意。</strong>我们取边5→6，使得6的值(35+5)=40。类似地，取边5→4合计4到60的值。这些值比以前的值更少或更多。</p><p id="d2e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是放松的步骤是如何工作的</p><p id="9f3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">移动到第三步也是最后一步，发现我们的敌人，<strong class="ih hj">消极循环。</strong>现在，为什么我们的算法在负周期面前会失败？这是因为贝尔曼福特放松所有的优势。它会找到全局最优解，因此如果出现负循环，该算法将无限期地继续下去。它总会不断寻找一个更优化的，也就是比以前更负的值。所以有必要确定这些周期。但是怎么做呢？</p><p id="3e48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再次运行相同的循环，获得边缘并放松它们。因为我们已经达到了一个优化值，所以如果我们可以再次放松一个边缘，这意味着我们遇到了一个负面的循环。一旦发生这种情况，IF条件变为真，执行return语句，结束函数，否则打印数组D。</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="c38e" class="jq jr hi jm b fi js jt l ju jv">for each edge (U,V) in G<br/>		If D[U] + edge_weight(U, V) &lt; D[V]<br/>			Error: Negative Cycle Exists<br/>                        return</span><span id="2e84" class="jq jr hi jm b fi jw jt l ju jv">print D[]</span></pre><p id="f3e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在已经成功地完成了贝尔曼-福特算法。耶！</p><p id="5e7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">比较吉克斯特拉和贝尔曼-福特</strong></p><p id="6b4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经讨论了以下主要差异</p><ul class=""><li id="fbe6" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated">两者都是最短路径算法，但是吉克斯特拉降低了武器对抗负权重，而贝尔曼-福特赢得了战争。</li><li id="433d" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">吉克斯特拉使用贪婪的方法，而贝尔曼-福特使用动态规划。</li></ul><p id="27bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止我们还没有触及的区别是</p><ul class=""><li id="f790" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated">吉克斯特拉速度很快。贝尔曼·福特的时间复杂度高于吉克斯特拉。但是，如果最佳时间不是最高优先级，那么毫无疑问贝尔曼福特是一个更好的最短路径算法。</li></ul><p id="f277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就完成了我们的贝尔曼-福特算法之旅。我相信理查德·贝尔曼和小莱斯特·福特会为你感到骄傲的，他们会在坟墓里微笑着睡觉。(是的，我在那里偷偷放了一点历史事实！).</p><p id="1b27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你们喜欢这个博客。一定要留下一些反馈，我真的很期待。尽情享受吧！</p></div></div>    
</body>
</html>