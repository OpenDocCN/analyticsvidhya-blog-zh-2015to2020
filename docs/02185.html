<html>
<head>
<title>Data Scraping in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的数据抓取</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-scraping-in-ruby-80775c5eda77?source=collection_archive---------19-----------------------#2019-12-04">https://medium.com/analytics-vidhya/data-scraping-in-ruby-80775c5eda77?source=collection_archive---------19-----------------------#2019-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/99dcb104c2428709aad75a197aeb6455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_B3j3im0B3ErFJ2O"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">伊利亚·巴甫洛夫在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="8a06" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">数据科学已经迅速发展成为科技领域发展最快的子领域之一。随着我们越来越多地通过社交媒体和智能手机联系在一起，由此产生的数据量令人震惊。不足为奇的是，这些数据可以教会我们很多关于我们如何思考，如何交流，以及我们未来可能感兴趣的东西。结合机器学习的数据分析是极其强大的。</p><p id="975b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">大数据公司使用先进的算法来得出结论，但这一切都要追溯到筛选数据的最基本的部分之一:<strong class="je hj">网络搜集</strong>。Web抓取本质上是收集无组织的数据，将其分割成相关的片段，并使其对人类更具可读性。网络抓取允许我们快速解析和收集网站上的特定信息。基本思想是能够浏览一个页面，并编辑一个有组织的数据列表。手动收集这些信息既乏味又效率低下——这就是为什么网络抓取器非常有用。</p><p id="e180" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">为了更好地理解这一切是如何工作的，我决定通过制作一个简单的刮擦应用程序来练习我的技能。作为一名更注重实践的学习者，在进行了一些简短的背景研究后，我决定开始用Atom编写一些代码，并在进行过程中解决这些问题。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/2b16edb9266b76ff28cb941492bfaf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSFtzE5d_Eqw8nUZN4veZw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">所有这一切的第一步是安装Nokogiri宝石。</figcaption></figure><p id="baef" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj"> Nokogiri </strong></p><p id="3550" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">Nokogiri是一个开源的web抓取库，用于解析Ruby中的HTML和XML文档。这是我在我的Flatiron实验室之外自己使用的第一批宝石之一，谢天谢地，尽管有几个指南警告潜在的安装问题，这个过程是快速和无痛的。安装只需要在终端中写出<em class="kf"> gem install nokogiri </em>并在ruby文件中要求它之后等待gem安装。</p><p id="8006" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj"> OpenURI </strong></p><p id="eb4c" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">OpenURI是web抓取中使用的另一个流行工具。它将HTTP请求方法封装到一个<em class="kf"> open </em>命令中，基本上让您少了一件担心的事情。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/8a7466571d159af3c38aec05cbab2d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-tY5AJZrxTByhPx7uAAMg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">别忘了要求你要用的宝石！</figcaption></figure><p id="fb1e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第一个测试是看我是否能从维基百科的网页抓取条目中获取信息。虽然在第一个测试中没有涉及过滤，但目标是通过OpenURI进行HTTP请求并在我的终端中返回信息。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/2893fc4d82078867c3b5f2eba5749a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PBl-JFZkChhcN8q7khYkQ.png"/></div></div></figure><p id="428c" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我定义了一个名为<em class="kf"> get_page </em>的变量来发出初始请求，将我们连接到服务器。要做到这一点，你必须调用<em class="kf"> Nokogiri::HTML </em>，然后从OpenURI调用<em class="kf"> open </em>命令，最后调用你想从中提取的页面的url。定义完这个之后，您就可以调用特定的<em class="kf">。要过滤的变量的css </em>方法。在这种情况下，我使用Chrome的inspect工具来查找主页面内容的标签<em class="kf">。mw-body-content </em>，以及<em class="kf"> &lt; p &gt; </em>标签内的所有内容(主要可读内容)。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/6f448f759f2a9b27dfc13a78ca5ba9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*qG008E-WfC2bhiIzEsYZVg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">主要内容的CSS选择器。</figcaption></figure><p id="9149" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">当您在“终端”中运行该应用程序时，您会得到以下内容:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/bab099df8a787c63e74505f4be796324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdCivo3uqTxu0Q8aJNrFKA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这向下滚动了一会儿，但你明白了。</figcaption></figure><p id="233c" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">但是加上<em class="kf">之后。text </em>到我们的<em class="kf"> info </em>变量的末尾，结果是一个更加整洁有序的页面内容版本。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/0bc3bce9f2e09d96bfb488a7db5fd94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvUkvnzpJd-unINJSwi__g.png"/></div></div></figure><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/d94182020aed566745f85076611c51a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoEw6Lo5aKWqbU67J63-Dg.png"/></div></div></figure><p id="b0f5" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">最后，如果我们只想获取部分的标题，我们可以通过H3标题进行过滤。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/4e89803bb3cd4fe317318301b91a823b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Y6qBna1IIQxGG-I7uGJnw.png"/></div></div></figure><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/28c665fbdcf7abc1b26c36f615710734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*DxlUwAjo7m7wnOwGMxWc6A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">这太乱了，无法阅读，而且各个标题是分开的</figcaption></figure><p id="3190" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我第一次尝试使用<em class="kf">。split(" "</em>)将单词分开，使其更具可读性，但结果根本不是我想要的。当我运行这个应用程序时，我得到了一个所有标题名称的列表，以及维基在所有条目上包含的每个标题旁边的<em class="kf">编辑</em>选项。标题都是分开的，没有恰当地组合在一起。因为Wiki在每一个标题后都包含了这一点，所以我解决这个问题的方法是利用这个模式。你所要做的就是用一个换行符来代替它。回想老实验室，我想起了gsub 方法。Gsub接受两个参数——左边是您想要选择的字符串，右边是您想要替换的字符串。下面的代码行用一个换行符替换了每个<em class="kf">编辑</em>，因此每个标题都有自己的一行。更容易阅读。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/6401bc11a77821a58a24da5708e99b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqPYtOBAWsfa66lWSI_AVg.png"/></div></div></figure><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/a75b59246ce59e12eb2ee685652f9b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0S1SL9u9zFhjx6BEZBTiQ.png"/></div></div></figure><p id="de0c" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">为了进一步清理，我们应该将所有东西放入它们自己的方法中，以便我们可以更容易地调用它们。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/331d425a9b449bbf898c73ebad5a47d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sU5I-gVim99IH7a0B02uRw.png"/></div></div></figure><p id="bb42" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，我们可以调用这两个方法中的任何一个，我们将能够获得一个有序的标题列表，或者整个正文文本，以便在终端中通读。现在我们已经缩小了这些数据的范围，我们可以在将来使用它们来获得其他属性，比如字符数(<em class="kf">)。长度</em>)，使用<em class="kf">一个特定的单词出现了多少次。选择</em>类型的方法，并且总体上能够解析任何其他站点。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/af41d3251f4ae91952216d02245dcda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dv2yJVuhU_p6__xKhysyuw.png"/></div></div></figure><p id="d950" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我做的最后一个测试是获取最近使用#flatironschool标签的twitter用户的用户名。与我使用的第一个示例非常相似，目标是解析信息并获取我们想要的数据。当我们运行<em class="kf">recent _ flat iron _ tweeters</em>方法时，我们得到下面的终端输出:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/94578f96e29931870097c08d8978c171.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*77X2xZksbGL4rcGzZNA2Yw.png"/></div></figure><p id="f34b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">除了他们的用户名，我还想返回他们的全名。不幸的是，这是我遇到很多问题的地方。有些名字只是名，有些是名和姓，还有一些包括表情符号。表情符号是我遇到的最大的问题，至今还没有解决。</p><p id="6845" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">为了获得用户的全名，我必须调用一个不同的css标识符。这相当简单，只需要改变我第一个twitter方法的一些名字。尝试格式化列表中的名称时出现问题。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/56793be3a7ef7c0eee1394557f95496f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPvshfDY8IHuQcmuOBhIjQ.png"/></div></div></figure><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/1a8e7b7430fafe33144ebeb08ab7ba4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GzprI8pP0HvsnG5BbKIsw.png"/></div></div></figure><p id="8430" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">表情符号让区分名字变得更加困难，因为没有一个所有档案都遵循的一致模式。下一步是找到表情符号的unicode，这样它们就可以被替换成<em class="kf"> gsub </em>。我用所有的标识符创建了一个变量<em class="kf"> regex </em>。<em class="kf"> regex </em>变量是一个名为“Regexp”的类的实例，代表一个正则表达式对象的例子。Regexp用于标识特定的字符。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/45e19be133fab1ca07969d9ac2ff37ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlL2Rk0ZPD22OHfBAgqwNw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这是我目前为止最接近的尝试。</figcaption></figure><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/bc012fda46489da48f7dfc95045793e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_LLtR48sjkRkHHU442iQQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">更有条理的列表——谢谢Eric👍</figcaption></figure><p id="3648" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">简而言之，从网络上收集数据的方法有很多。像谷歌这样的网站一直在抓取整个网络，但在较小的范围内，我们可以看到这些积木是如何组合在一起的。我很高兴学会了如何从页面返回特定的数据，并且我确实从我的问题中学到了很多。不同的网站当然会有很大的不同，所以对一个网站有用的很可能对另一个网站无效。我想坐下来，花更多的时间来调整我所学到的东西，并将其应用到其他网站上。虽然我没有为我想做的所有事情编写完整的方法，但我认为这是一个总体上成功的实验，因为我更好地理解了web抓取原则，并了解了其他CS概念，如正则表达式。</p></div></div>    
</body>
</html>