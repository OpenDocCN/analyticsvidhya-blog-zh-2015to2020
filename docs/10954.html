<html>
<head>
<title>SQL Window Function — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL窗口函数—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sql-windows-function-5dc5cbdb1aa?source=collection_archive---------7-----------------------#2020-11-10">https://medium.com/analytics-vidhya/sql-windows-function-5dc5cbdb1aa?source=collection_archive---------7-----------------------#2020-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="21d2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">SQL中窗口函数的类型介绍和概述。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3bf43fe24acc9106e0cd9f9076ebb85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4YyrDuWYuUvFW3j9yqmyA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片由作者提供，灵感来自<a class="ae jn" href="https://www.toptal.com/sql/intro-to-sql-windows-functions" rel="noopener ugc nofollow" target="_blank">Toptal.com</a></figcaption></figure><p id="920f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">简介:</strong></p><p id="da92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">窗口函数跨一组与当前行有某种关系的表行执行数据分析计算。地址可比较类型的计算可以用一个聚合函数来完成，该函数给出一行或按条件分组(参见图1)。</p><p id="2d99" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Window函数不会导致行组合成一个输出行。保留其单独标识的行也能够访问查询结果的当前行以外的内容。(参见图1)</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/4c99537c1b4337d0f8e3a610c1bd7921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjOX0bwNSxLkBIxzCL7Cpg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图1 —聚合函数和窗口函数的区别</figcaption></figure><p id="a8ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kl">用于解释以下概念的数据库:Postgres数据库和数据集:可从</em><a class="ae jn" href="https://github.com/GDhasade/Medium.com_Contents/tree/master/SQL" rel="noopener ugc nofollow" target="_blank"><em class="kl">Github Order _ table . CSV</em></a>获得</p><p id="ad67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">窗口函数语法:</strong></p><pre class="iy iz ja jb fd km kn ko kp aw kq bi"><span id="117e" class="kr ks hi kn b fi kt ku l kv kw">Window_Function([All] expression) <br/>OVER( [PARTITION BY expression_list] [ORDER BY order_list Row_or_ Range clause] )</span></pre><p id="6958" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">语法的每个部分解释如下:</p><p id="a71d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">窗口_功能:</strong></p><p id="2f47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">window _ functions有3种主要类型</p><ol class=""><li id="5b3e" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lc ld le lf bi translated"><strong class="jq hj">窗口聚合函数:</strong>包含一个支持聚合函数，即AVG()、计数()、最小值()、最大值()、总和()。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lg"><img src="../Images/3e1404de28effd90b225fab5478b1ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVKqRolUhV0e_HI1Ikga2Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">窗口聚合函数</figcaption></figure><p id="7260" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 2。窗口排名聚合函数:</strong>包含一个支持排名的函数，即RANK()、DENSE_RANK()、ROW_NUMBER()。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/7513d790fb6e4d23a257db46822a5b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEvZRpjw1YJoApHE0vAsgw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd li">窗口排名聚合函数</strong></figcaption></figure><p id="08d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 3。窗口分析函数:</strong>由支持排名函数之一组成，即FIRST_VALUE()、LAST_VALUE()、NTH_VALUE()。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/cab9698209229ec739d5fcbb849acb7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68hAU2ntg_tKjs4o5SZlmg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd li">窗口分析功能</strong></figcaption></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="b165" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Over()子句:</strong></p><p id="688d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Over()子句用于为函数(即avg、count等)定义行(即窗口)的分区和排序。)做手术。因此，称为窗口功能。</p><p id="a854" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Over()子句有以下参数:</p><ol class=""><li id="b6fa" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lc ld le lf bi translated"><strong class="jq hj"> Order by: </strong>定义行的逻辑顺序。</li></ol><p id="2408" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">例如:- </strong>根据产品价格对产品标识进行排序。</p><pre class="iy iz ja jb fd km kn ko kp aw kq bi"><span id="ee9c" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">Query:</strong><br/>Select product_id, price, Rank() OVER (ORDER BY price desc) AS Average_price<br/>From orders;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lr"><img src="../Images/da8e74ac6345a071fbaaa79e61ba970b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*sXCEVQkN2HDnchyyCjhF6g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">参数-排序依据</figcaption></figure><p id="ba6c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 2。Partition by:- </strong>将查询结果集划分为<em class="kl">个分区</em>，即分别应用于每个分区的窗口函数。</p><p id="7668" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">例如:- </strong>按性别计算Average_Order_Price，即按性别划分。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/e8f9fa11bf20f7f5aa077c5f6c54bdb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QC78yaRP0cCLl0b4QUtrTw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">参数—分区依据</figcaption></figure><p id="16ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">观察:</strong></p><p id="78d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">计算average_price时考虑了分区列，即性别。因此，对每个性别类别都计算了相同的平均价格。</p><p id="1dbf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 3。ROWS or RANGE子句:</strong>通过指定分区内的起点和终点来限制分区内的行<em class="kl">。Rows或Range子句的默认值是<em class="kl">范围，在无界的前一行和当前行之间</em></em></p><p id="2010" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">行或范围子句的类型:</strong></p><p id="4936" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kl"> a .无边界的前一行和当前行:</em> </strong></p><ul class=""><li id="3713" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lt ld le lf bi translated">它将从第1行到当前行开始考虑聚合函数的行值。</li><li id="f4d2" class="kx ky hi jq b jr lu ju lv jx lw kb lx kf ly kj lt ld le lf bi translated"><strong class="jq hj">例如:- </strong></li></ul><pre class="iy iz ja jb fd km kn ko kp aw kq bi"><span id="7c72" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">Query:</strong></span><span id="eefb" class="kr ks hi kn b fi lz ku l kv kw">SELECT order_id, gender, price, <br/>AVG(price) OVER (ORDER BY price ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS Average_Price<br/>FROM orders;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/69fe63909698bd5987be57d1bf5e2610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8U192rrLvZl5WazgPl6FiA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd li"> <em class="mb">前一行和当前行的无界</em> </strong></figcaption></figure><ul class=""><li id="c46e" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lt ld le lf bi translated"><strong class="jq hj"> <em class="kl">当前行第7位</em> </strong> —平均价格<strong class="jq hj"><em class="kl">:</em></strong>(163+163+163+376+376+376)/7 = 254.2857</li></ul><p id="653a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kl"> b .无界前与无界后:</em> </strong></p><ul class=""><li id="1dfc" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lt ld le lf bi translated">无界在前考虑第一行<em class="kl">和无界在后意味着它将考虑计算列的最后一行。</em></li><li id="c616" class="kx ky hi jq b jr lu ju lv jx lw kb lx kf ly kj lt ld le lf bi translated"><strong class="jq hj">例如:</strong></li></ul><pre class="iy iz ja jb fd km kn ko kp aw kq bi"><span id="1f58" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">Query:</strong><br/>SELECT order_id, gender, price, <br/>AVG(price) OVER (ORDER BY price ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Average_Price<br/>FROM orders;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/de402f2001f79adaa060cee110508358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aeF_iga9SbYOPnWZwAcZvw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd li"> <em class="mb">前无界后无界</em> </strong></figcaption></figure><ul class=""><li id="8683" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lt ld le lf bi translated">我们可以看到，每一列的average_price是相同的，因为它考虑了price列中的所有值。</li></ul><p id="47c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> c .其他类型:</strong></p><p id="837a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kl">在</em>之前的EN 1和之后的1个之间:</strong></p><pre class="iy iz ja jb fd km kn ko kp aw kq bi"><span id="ef74" class="kr ks hi kn b fi kt ku l kv kw"><strong class="kn hj">Query:</strong><br/>SELECT order_id, gender, price, <br/>AVG(price) OVER (ORDER BY price ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS Average_Price<br/>FROM orders;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/36d4a51554469417eb7ec0bf2766f805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkQUfvXN8wYgxie-baA6kA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd li"> <em class="mb">前一个EN 1和后一个</em> </strong></figcaption></figure><p id="9236" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Average_Price通过考虑以下因素进行计算:</p><p id="f76e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">a.当前行值</p><p id="a9d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">b.current_row值的前一行，即前一行。</p><p id="1b62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">c.下一行，即当前行值以下的行。</p><ul class=""><li id="75a6" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lt ld le lf bi translated">同样，我们可以根据需要改变窗口的范围。</li></ul></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="5202" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">结论:</strong></p><p id="04f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">SQL Windows函数非常强大。在这篇博客中，我试图对Windows功能做一个简短的概述。</p><p id="8e7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望这个博客对你有所帮助，也希望它能激发你的兴趣，看看windows函数能做什么。</p><p id="4985" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我强烈建议阅读参考文献以获得更深入的解释。</p><p id="24c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">参考资料/学习资料:</strong></p><ol class=""><li id="491f" class="kx ky hi jq b jr js ju jv jx kz kb la kf lb kj lc ld le lf bi translated">postgresql.org(2019年)。<em class="kl"> PostgreSQL:文档:9.1:窗口函数</em>。[在线]Postgresql.org。可用地点:<a class="ae jn" href="https://www.postgresql.org/docs/9.1/tutorial-window.html." rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/9.1/tutorial-window.html.</a></li><li id="2faa" class="kx ky hi jq b jr lu ju lv jx lw kb lx kf ly kj lc ld le lf bi translated">drill.apache.org(未标出)。<em class="kl"> SQL窗口函数介绍— Apache Drill </em>。[在线]drill.apache.org。可在:<a class="ae jn" href="https://drill.apache.org/docs/sql-window-functions-introduction/" rel="noopener ugc nofollow" target="_blank">https://drill . Apache . org/docs/SQL-window-functions-introduction/</a>【2020年11月10日访问】。</li></ol></div></div>    
</body>
</html>