<html>
<head>
<title>Natural Language Processing: Experimenting spaCy (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理:实验空间(四)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/natural-language-processing-experimenting-spacy-part-4-smartlake-e3ad670c607a?source=collection_archive---------1-----------------------#2019-05-01">https://medium.com/analytics-vidhya/natural-language-processing-experimenting-spacy-part-4-smartlake-e3ad670c607a?source=collection_archive---------1-----------------------#2019-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7d0870e86889e50a10457ce9473d77a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uy8zKcQP5nxg2KUH6rFcqw.jpeg"/></div></div></figure><h1 id="12a1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="d6db" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在前3篇文章中，我们已经说明了Google和AWS NLP APIs的用法，并实验了spacy库从不同的文档中提取实体和名词。我们选择使用个人简介和工作描述，因为这是一个常见的用例，很容易理解。</p><p id="2f0b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们想比以前的文章走得更远，并尝试更详细的空间。</p><h1 id="9808" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">命名实体识别</h1><p id="c1cc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在让我们在这个例子中使用Python库，因为它提供了比使用R库更多的特性(至少就我所理解的而言)。像往常一样，我们需要安装空间库并下载我们想要使用的相应模型(在<a class="ae kr" href="https://spacy.io/usage/" rel="noopener ugc nofollow" target="_blank">https://spacy.io/usage/.</a>下有更多关于这个的内容)</p><p id="8468" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在让我们使用spacy解析一个文档，并打印对应于“PRODUCT”的命名实体的摘录:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3ac8" class="lb ir hi kx b fi lc ld l le lf">import spacy spacy.load('en') <br/>docCV=nlp(textCV) <br/>for ent in docCV.ents: <br/># Print the entity text and its label <br/>  if ent.label_=='PRODUCT': <br/>    print(ent.text, ent.label_,) <br/>Agile PRODUCT <br/>Tier 1 PRODUCT</span></pre><p id="4c4d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">小型英国型号的结果并不令人印象深刻，因此中型型号的结果可能有所不同:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="aac0" class="lb ir hi kx b fi lc ld l le lf">nlp = spacy.load('en_core_web_md')<br/>docCV=nlp(textCV) <br/>for ent in docCV.ents: <br/>  # Print the entity text and its label if ent.label_=='PRODUCT':<br/>    print(ent.text, ent.label_,)</span></pre><p id="766d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">事实上，由于没有检测到产品类型的实体，这是相当令人惊讶的。这很大程度上取决于模型是在哪个文本语料库上训练的。如果我们将相同的模型应用于另一个配置文件，我们会得到以下结果:</p><p id="1c4c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">C++产品<br/> C++产品<br/> Solaris产品<br/> C++产品</p><p id="85e8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Spacy检测到C++和Solaris是产品，但不是Java或JavaScript。因此，让我们将我们自己的检测规则添加到模型中，以更接近我们想要的，即识别人们档案中的技术技能:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f727" class="lb ir hi kx b fi lc ld l le lf">patterns = [{"label": "PROG", "pattern": [{"lower": "java"}]}, {"label": "PROG", "pattern": [{"lower": "javascript"}]}] <br/>ruler = EntityRuler(nlp, patterns=patterns,overwrite_ents=True) nlp.add_pipe(ruler) <br/>docCV=nlp(textCV) <br/>for ents in docCV.ents: <br/># Print the entity text and its label <br/>if ents.label_=='PROG': <br/>  print(ents.text, ents.label_,) <br/>Java PROG <br/>Java PROG <br/>Java PROG <br/>Java PROG <br/>Java PROG</span></pre><p id="0561" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，我们能够将基于规则的实体识别添加到统计模型中。这允许以快速的方式对模型进行微调，以适应特定的领域和需求。</p><p id="fd75" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们也分析一下工作描述，看看仅使用统计模型可以识别出哪种实体:</p><p id="b875" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">SLQ ORG <br/> 7年日期<br/>计算机科学ORG<br/>Java GPE<br/>JavaScript ORG<br/>Boosting、Trees ORG <br/> SLQ ORG <br/>红移ORG <br/> S3、Spark PRODUCT<br/>digital ocean ORG<br/>第三序数<br/>Google Analytics ORG<br/>Adwords ORG<br/>Crimson Hexagon ORG<br/>Map/Reduce ORG<br/>Hadoop ORG<br/>guro bi GPE<br/>MySQL GPE<br/>Business</p><p id="be68" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这很有趣，因为在这种情况下，模型将Java检测为一个地缘政治实体，将JavaScript检测为一个组织。这是自动完成的，不需要为这个特定的文档编写特定的规则。</p><p id="50f9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">总之，我们可以说，实体识别不仅依赖于所使用的统计模型，还依赖于我们正在处理的文档的结构。这比预期的更复杂。</p><h1 id="8b29" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">记录相似之处</h1><p id="bb09" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">spacy的一个很好的特性是能够比较标记(单词)、句子和文档之间的语言和语义相似性。为了做到这一点，我们必须使用加载了词向量的空间模型。为了做到这一点，我们需要加载中型网络英语模型或大型模型。让我们使用命令行加载中型模型:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ffde" class="lb ir hi kx b fi lc ld l le lf">python -m spacy download en_core_web_md</span></pre><p id="0f05" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">预训练模型中的每个单词都有相应的向量，并且文档向量将被默认为所有文档标记(单词)的平均向量。将使用文档向量之间的余弦相似度来计算相似度。结果将是一个介于0和1之间的数字，1是最高分(0的余弦值是1，意味着空间中的向量彼此重合)</p><p id="c020" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们从一般的数据科学家工作描述开始，看看会发生什么。</p><p id="c942" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">docjob . similarity(docCV)<br/>Out[98]:0 . 48686 . 48686868661</p><p id="5d9d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">docjob . similarity(doccv 2)<br/>Out[99]:0 . 46867 . 48686868661</p><p id="6107" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于两份简介都是技术性的，工作描述也包含了大量的技术词汇，所以平均来看，这两份文件非常相似也就不足为奇了。因此，让我们用欧洲议会关于网络安全的另一份出版物来尝试一下:</p><p id="edb5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">doccv . similarity(docDoc)<br/>Out[106]:0 . 54686 . 48686868661</p><p id="9928" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">毫不奇怪，相似性降低了，尽管目标文档本质上也是技术性的。</p><p id="7256" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这就是现在的全部，下一次，让我们看看如何使用spacy进一步优化我们的文档分析。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="e78b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ln">原载于2019年5月1日</em><a class="ae kr" href="https://smartlake.ch/natural-language-processing-experimenting-spacy-part-4/" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://smart lake . ch</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>