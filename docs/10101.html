<html>
<head>
<title>Handling Large CSV files with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫处理大型 CSV 文件</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/handling-large-csv-files-with-pandas-9595f67ad265?source=collection_archive---------3-----------------------#2020-10-05">https://medium.com/analytics-vidhya/handling-large-csv-files-with-pandas-9595f67ad265?source=collection_archive---------3-----------------------#2020-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有一个大的 CSV 文件，你想有效地处理熊猫，你有几个选项，将在这篇文章中解释。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4a59ec75983782a51a60f15e268f549c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttQkGfkCMYZKgNctGuPiMA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">处理数据时速度很重要！</figcaption></figure><blockquote class="jt ju jv"><p id="9ddb" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated"><code class="du ka kb kc kd b"><em class="hi">Pandas is an in-memory tool</em></code></p></blockquote><p id="434c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要能够将您的数据存储在内存中，以便使用 pandas。如果您可以一次处理它的一部分，那么您可以将它读入数据块并处理每个数据块。或者，如果您知道您应该有足够的内存来加载文件，有一些提示可以帮助减少文件大小。</p><p id="123d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，一般来说，您应该拥有三至十倍于您想要操作的数据帧大小的内存。额外的内存应该给你足够的额外空间来执行许多常见的操作。</p><h1 id="fe14" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">1.用 Python 检查你系统的内存</h1><p id="f972" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">让我们从检查我们系统的内存开始。<code class="du ka kb kc kd b">psutil</code>将在 Windows、MAC 和 Linux 上运行。<code class="du ka kb kc kd b"><em class="jw">psutil</em></code> <em class="jw"> </em>可以用 pip install 从 Python 的包管理器下载。</p><p id="f3aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在安装时遇到了<code class="du ka kb kc kd b">psutil</code>的编译错误，请尝试以下步骤。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="0597" class="ll kf hi kd b fi lm ln l lo lp">sudo yum install python3-devel<br/>sudo pip install psutil</span><span id="7b51" class="ll kf hi kd b fi lq ln l lo lp"># now check the version using <br/>pip freeze | grep psutil</span></pre><p id="915d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看我们系统的当前内存。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="949e" class="ll kf hi kd b fi lm ln l lo lp">import psutil<br/>memory = psutil.virtual_memory()<br/>print(f" {'*' * 3} Memory used percentage - {memory.percent} \n {'*' * 4} Free Memory available - { round(memory.free / (1024.0 ** 3))} GB")</span><span id="e9eb" class="ll kf hi kd b fi lq ln l lo lp"># Output<br/>*** Memory used percentage - 63.0 <br/>**** Free Memory available - 6 GB</span></pre></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="eb14" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">2.确定 CSV 文件的内存使用情况</h1><p id="b0e3" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我们现在将估计整个文件将占用多少内存。我已经使用了来自<code class="du ka kb kc kd b"><a class="ae md" href="https://kaggle.com" rel="noopener ugc nofollow" target="_blank">kaggle.com</a></code>的<code class="du ka kb kc kd b">tmdb_5000_movies</code>数据集。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="fec6" class="ll kf hi kd b fi lm ln l lo lp">import pandas as pd</span><span id="6ec9" class="ll kf hi kd b fi lq ln l lo lp">data = pd.read_csv("tmdb_5000_movies.csv")</span><span id="7f6a" class="ll kf hi kd b fi lq ln l lo lp"># Lets check the memory usage of the file <br/>print(f" ** Memory usage of the file - {sum(data.memory_usage()) * 0.000001} MB for {len(data.index)} Rows")</span><span id="2c62" class="ll kf hi kd b fi lq ln l lo lp">&gt;&gt; # Output<br/>** Memory usage of the file - 8.453408 MB for 52833 Rows</span></pre><p id="d506" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc kd b">data.memory_usage()</code>方法显示了数据帧的内存使用情况，而<code class="du ka kb kc kd b">len(data.index)</code>显示了数据帧的总行数。</p><p id="82b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，<strong class="ih hj"><em class="jw"/></strong>52833 行使用了大约<strong class="ih hj"><em class="jw"/></strong><strong class="ih hj"><em class="jw">MB</em></strong>的内存。如果我们有一个<strong class="ih hj"> <em class="jw">十亿行</em> </strong>，那就要占用大约<strong class="ih hj"> <em class="jw"> 151+ GB </em> </strong>的内存。现在，这是一个坏主意，把所有的东西都放在记忆里，让它挂起来，不要这样做。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="6979" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">3.理解 csv 文件中的数据类型</h1><p id="392a" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">CSV 文件不包含关于数据类型的信息，不像数据库，pandas 试图推断列的类型，并从 NumPy 推断它们。</p><p id="0c88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况如何？</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/91f61825090924d29417e2d98bd1950b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37QwakXureE3Bb6l4hsYwA.png"/></div></div></figure><p id="cf5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看这些数据类型的限制。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="8e9d" class="ll kf hi kd b fi lm ln l lo lp">import numpy as np</span><span id="51a9" class="ll kf hi kd b fi lq ln l lo lp"># Limits of Integer Data Type<br/>print(f" ** Output limits of Numpy Integer Data Types ")<br/>print(f" ** limits of Numpy Integer - {np.iinfo(np.int8)}")<br/>print(f" ** limits of Numpy Integer - {np.iinfo(np.int16)}")<br/>print(f" ** limits of Numpy Integer - {np.iinfo(np.int64)}")</span><span id="9caa" class="ll kf hi kd b fi lq ln l lo lp"># Limits of Float Data Type<br/>print(f" ** Output limits of Numpy Float Data Types ")<br/>print(f" ** limits of Numpy Float - {np.finfo(np.float16)}")<br/>print(f" ** limits of Numpy Float - {np.finfo(np.float64)}")<br/></span><span id="69be" class="ll kf hi kd b fi lq ln l lo lp">&gt;&gt; # Output<br/> ** Output limits of Numpy Integer Data Types <br/> ** limits of Numpy Integer - Machine parameters for int8<br/>---------------------------------------------------------------<br/>min = -128<br/>max = 127<br/>---------------------------------------------------------------</span><span id="8b0a" class="ll kf hi kd b fi lq ln l lo lp"> ** limits of Numpy Integer - Machine parameters for int16<br/>---------------------------------------------------------------<br/>min = -32768<br/>max = 32767<br/>---------------------------------------------------------------</span><span id="8a43" class="ll kf hi kd b fi lq ln l lo lp"> ** limits of Numpy Integer - Machine parameters for int64<br/>---------------------------------------------------------------<br/>min = -9223372036854775808<br/>max = 9223372036854775807<br/>---------------------------------------------------------------</span><span id="f15d" class="ll kf hi kd b fi lq ln l lo lp"> ** Output limits of Numpy Float Data Types <br/> ** Memory usage of the file - Machine parameters for float16<br/>---------------------------------------------------------------<br/>precision =   3   resolution = 1.00040e-03<br/>machep =    -10   eps =        9.76562e-04<br/>negep =     -11   epsneg =     4.88281e-04<br/>minexp =    -14   tiny =       6.10352e-05<br/>maxexp =     16   max =        6.55040e+04<br/>nexp =        5   min =        -max<br/>---------------------------------------------------------------</span><span id="1db6" class="ll kf hi kd b fi lq ln l lo lp"> ** Memory usage of the file - Machine parameters for float64<br/>---------------------------------------------------------------<br/>precision =  15   resolution = 1.0000000000000001e-15<br/>machep =    -52   eps =        2.2204460492503131e-16<br/>negep =     -53   epsneg =     1.1102230246251565e-16<br/>minexp =  -1022   tiny =       2.2250738585072014e-308<br/>maxexp =   1024   max =        1.7976931348623157e+308<br/>nexp =       11   min =        -max<br/>---------------------------------------------------------------</span></pre></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="c3d2" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">4.转换数字数据类型</h1><p id="6e85" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">让我们运行<code class="du ka kb kc kd b">.info()</code>方法来深入验证我们的数据类型。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="4761" class="ll kf hi kd b fi lm ln l lo lp"># Lets print the DataFrame information<br/>print(f" {data.info()}")</span><span id="b268" class="ll kf hi kd b fi lq ln l lo lp">&gt;&gt;&gt; # Output<br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 52833 entries, 0 to 52832<br/>Data columns (total 20 columns):<br/> #   Column                Non-Null Count  Dtype  <br/>---  ------                --------------  -----  <br/> 0   budget                52833 non-null  int64  <br/> 1   genres                52833 non-null  object <br/> 2   homepage              18832 non-null  object <br/> 3   id                    52833 non-null  int64  <br/> 4   keywords              52833 non-null  object <br/> 5   original_language     52833 non-null  object <br/> 6   original_title        52833 non-null  object <br/> 7   overview              52800 non-null  object <br/> 8   popularity            52833 non-null  float64<br/> 9   production_companies  52833 non-null  object <br/> 10  production_countries  52833 non-null  object <br/> 11  release_date          52822 non-null  object <br/> 12  revenue               52833 non-null  int64  <br/> 13  runtime               52811 non-null  float64<br/> 14  spoken_languages      52833 non-null  object <br/> 15  status                52833 non-null  object <br/> 16  tagline               43549 non-null  object <br/> 17  title                 52833 non-null  object <br/> 18  vote_average          52833 non-null  float64<br/> 19  vote_count            52833 non-null  int64  <br/>dtypes: float64(3), int64(4), object(13)<br/>memory usage: 8.1+ MB</span></pre><p id="f063" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们总结一下数据类型和列数，看看 pandas 是如何对我们的数据进行分类的。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="3998" class="ll kf hi kd b fi lm ln l lo lp"># lets summarize the data types and count of columns<br/>print(f" ** Summarize the data types and count of columns \n{data.dtypes.value_counts()}")</span><span id="4677" class="ll kf hi kd b fi lq ln l lo lp">&gt;&gt; # Output<br/>object     13<br/>int64       4<br/>float64     3<br/>dtype: int64</span></pre><p id="8096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将重点关注<code class="du ka kb kc kd b">int64</code>和<code class="du ka kb kc kd b">float64</code>数据类型，研究数据/精度，并进行转换。</p><p id="7092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用`<strong class="ih hj"> dtype </strong>`参数来告诉 pandas 使用较小的数字类型，而不是默认的 64 位，现在您明白为什么首先理解数据类型的上述步骤是重要的了。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="d774" class="ll kf hi kd b fi lm ln l lo lp"># Define a dictionary converting the numeric data types<br/>data_types_conversion_numeric = {"popularity": np.float16,<br/>                                 "runtime": np.float16,<br/>                                 "vote_average": np.float16,<br/>                                 "id": np.int16,<br/>                                 "revenue": np.int16,<br/>                                 "vote_count": np.int16}<br/>data_02 = pd.read_csv("tmdb_5000_movies.csv", dtype=data_types_conversion_numeric)<br/>print(f" ** Memory usage of the file - {sum(data_02.memory_usage()) * 0.000001} MB for {len(data_02.index)} Rows")</span><span id="9b33" class="ll kf hi kd b fi lq ln l lo lp">&gt;&gt; #Output<br/> ** Memory usage of the file - 6.551419999999999 MB for 52833 Rows</span></pre><p id="2515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，通过将数据类型更改为使用更小的数字类型，我们节省了<strong class="ih hj"><em class="jw"/></strong>23%的开销，如果您持有的数据很小，您也可以使用<code class="du ka kb kc kd b">int8</code>来进一步节省开销。</p><blockquote class="jt ju jv"><p id="ecbb" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">我们现在是原始大小的 67%。这大约节省了 23%的内存。</p></blockquote></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="a895" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">5.转换对象数据类型</h1><p id="7c82" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">对象数据类型将值视为字符串。pandas 中的字符串值占用大量内存，因为每个值都存储为 Python 字符串，如果该列不是数字，pandas 会将其转换为对象列。</p><p id="f1fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将对象数据类型转换为类别将使用更少的内存，因为 Pandas 只存储一次字符串，而不是为每一行创建新的字符串。</p><p id="d1c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，检查对象列的<code class="du ka kb kc kd b">.value_counts</code>方法。如果基数较低，可以将它们转换为分类列以节省更多内存。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="b38e" class="ll kf hi kd b fi lm ln l lo lp">print(data_02.original_language.value_counts())<br/><br/>&gt;&gt; #Output<br/>en    49555<br/>fr      770<br/>es      352<br/>zh      297<br/>de      297</span></pre><p id="34ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基数没有那么高，我将开始把对象数据类型转换成类别。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="6256" class="ll kf hi kd b fi lm ln l lo lp">data_types_conversion_numeric = {"popularity": np.float16,<br/>                                 "runtime": np.float16,<br/>                                 "vote_average": np.float16,<br/>                                 "id": np.int16,<br/>                                 "revenue": np.int16,<br/>                                 "vote_count": np.int16,<br/>                                 "genres": "category",<br/>                                 "homepage": "category",<br/>                                 "keywords": "category",<br/>                                 "original_language": "category",<br/>                                 "original_title": "category",<br/>                                 "overview": "category",<br/>                                 "production_companies": "category",<br/>                                 "production_countries": "category",<br/>                                 "release_date": "category",<br/>                                 "spoken_languages": "category",<br/>                                 "status": "category",<br/>                                 "tagline": "category",<br/>                                 "title": "category"}<br/>data_02 = pd.read_csv("tmdb_5000_movies.csv", dtype=data_types_conversion_numeric)<br/>print(f" ** Memory usage of the file - {sum(data_02.memory_usage()) * 0.000001} MB for {len(data_02.index)} Rows")<br/><br/><br/>&gt;&gt;&gt; # Output<br/>** Memory usage of the file - 3.9045639999999997 MB for 52833 Rows</span></pre><blockquote class="jt ju jv"><p id="1224" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">我们现在是原始大小的 46%。这大约节省了 54%的内存。</p></blockquote></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="e1e8" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">6.识别和删除熊猫中的重复。</h1><p id="a9e0" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">您正在处理的源文件中很有可能有重复的内容，如果不需要，将它们删除会节省更多的内存。<br/>在我的例子中，为了使文件变大，我必须重复记录:)</p><p id="8075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在删除之前，让我们验证源文件中重复条目的数量。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="bb8e" class="ll kf hi kd b fi lm ln l lo lp">print(f" ** File has {len(data_02) - len(data_02.drop_duplicates())} duplicate rows off the total {len(data_02)}  ")<br/><br/>&gt;&gt; # Output<br/>** File has 48030 duplicate rows off the total 52833</span></pre><p id="8510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc kd b">len(your dataframe)</code>输出数据帧中的总行数，而 len(dataframe.drop_duplicates())将输出数据帧中的唯一值。</p><p id="08bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我上面提到的文件有很多副本，删除它们会节省很多内存。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="f2cd" class="ll kf hi kd b fi lm ln l lo lp">data_03 = data_02.drop_duplicates()<br/>print(f" ** Memory usage of the file after dropping duplicates - {sum(data_03.memory_usage()) * 0.000001} MB for {len(data_03.index)} Rows")<br/><br/>&gt;&gt; # Output<br/>** Memory usage of the file - 1.82954 MB for 4803 Rows</span></pre><p id="70d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这是一些储蓄岗位删除重复。如果你有重复的，想把它们扔掉，那么使用这个步骤。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="44df" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">7.删除不需要的列</h1><p id="cdb4" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">如果您知道有可以忽略的列，那么指定<code class="du ka kb kc kd b">usecols</code>参数来包含您想要加载的列。</p><p id="aad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将忽略“主页”、“关键词”、“T13”、“原标题”和“标语”等列。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="e4dc" class="ll kf hi kd b fi lm ln l lo lp"># prepare a list of columns that you want to load<br/>unwanted_columns = ["homepage", "keywords","original_title", "tagline"]<br/>data_columns = [columns for columns in list(pd.read_csv("tmdb_5000_movies.csv").columns) if columns not in unwanted_columns]<br/><br/># Define a dictionary converting the numeric data types<br/>data_types_conversion = {"popularity": np.float16,<br/>                         "runtime": np.float16,<br/>                         "vote_average": np.float16,<br/>                         "id": np.int16,<br/>                         "revenue": np.int16,<br/>                         "vote_count": np.int16,<br/>                         "genres": "category",<br/>                         "original_language": "category",<br/>                         "overview": "category",<br/>                         "production_companies": "category",<br/>                         "production_countries": "category",<br/>                         "release_date": "category",<br/>                         "spoken_languages": "category",<br/>                         "status": "category",<br/>                         "title": "category"}<br/><br/>data_02 = pd.read_csv("tmdb_5000_movies.csv", dtype=data_types_conversion, usecols=data_columns)<br/>print(f" ** Memory usage of the file after dropping cols - {sum(data_02.memory_usage()) * 0.000001} MB for {len(data_02.index)} Rows")<br/><br/>&gt;&gt; #Output<br/>** Memory usage of the file after dropping cols - 2.791196 MB for 52833 Rows</span></pre><blockquote class="jt ju jv"><p id="2c6d" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">我们现在是原来大小的 32%。这大约节省了 68%的内存。</p></blockquote></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="1eea" class="ke kf hi bd kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx mc kz la lb bi translated">8.用熊猫处理大量数据。</h1><p id="8140" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">如果您可以一次处理大量数据，并且不需要将所有数据都存储在内存中，则可以使用 chunk size 参数。我个人建议这是你最后的选择。</p><pre class="je jf jg jh fd lh kd li lj aw lk bi"><span id="fcdf" class="ll kf hi kd b fi lm ln l lo lp"># read the csv file<br/>data = pd.read_csv("tmdb_5000_movies.csv")<br/><br/># prepare a list of columns that you want to load<br/>unwanted_columns = ["homepage", "keywords","original_title", "tagline"]<br/>data_columns = [columns for columns in list(pd.read_csv("tmdb_5000_movies.csv").columns) if columns not in unwanted_columns]<br/><br/># Define a dictionary converting the numeric data types<br/>data_types_conversion = {"popularity": np.float16,<br/>                         "runtime": np.float16,<br/>                         "vote_average": np.float16,<br/>                         "id": np.int16,<br/>                         "revenue": np.int16,<br/>                         "vote_count": np.int16,<br/>                         "genres": "category",<br/>                         "original_language": "category",<br/>                         "overview": "category",<br/>                         "production_companies": "category",<br/>                         "production_countries": "category",<br/>                         "release_date": "category",<br/>                         "spoken_languages": "category",<br/>                         "status": "category",<br/>                         "title": "category"}<br/><br/>data_02 = pd.read_csv("tmdb_5000_movies.csv", dtype=data_types_conversion, usecols=data_columns,chunksize=10000)<br/><br/><br/># Process the data frame in chunks<br/>for chunk in data_02:<br/>    print(f" ** Memory usage of the file after dropping cols - {sum(chunk.memory_usage()) * 0.000001} MB for {len(chunk.index)} Rows")<br/>    print(f"Do some more processing here... ")<br/><br/><br/>&gt;&gt; #Output<br/> ** Memory usage of the file after dropping cols - 1.2492079999999999 MB for 10000 Rows<br/> ** Memory usage of the file after dropping cols - 1.249212 MB for 10000 Rows<br/> ** Memory usage of the file after dropping cols - 1.249212 MB for 10000 Rows<br/> ** Memory usage of the file after dropping cols - 1.249212 MB for 10000 Rows<br/> ** Memory usage of the file after dropping cols - 1.249212 MB for 10000 Rows<br/> ** Memory usage of the file after dropping cols - 0.5628639999999999 MB for 2833 Rows</span></pre><blockquote class="jt ju jv"><p id="74bd" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">我们现在是原始大小的 14 %。大约节省了<strong class="ih hj"> 86% </strong>的内存。</p></blockquote></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="6011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您通读这篇文章。我今天就到这里。如果你喜欢这篇文章，并且对你有所帮助，请随时关注我。</p><p id="e200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你认为这篇文章对某人有很大帮助，请随意分享。</p></div></div>    
</body>
</html>