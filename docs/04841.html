<html>
<head>
<title>Decorator Design Pattern — miraf</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装饰设计模式——miraf</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/decorator-design-pattern-miraf-d978735df38c?source=collection_archive---------13-----------------------#2020-04-02">https://medium.com/analytics-vidhya/decorator-design-pattern-miraf-d978735df38c?source=collection_archive---------13-----------------------#2020-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">装饰者设计模式的目标是实现这样的原则:<br/> <em class="jm">【开放用于扩展，封闭用于修改】</em></p><p id="60a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为在软件开发领域，我们唯一确定的和唯一不变的是“变化”，一个好的设计模式应该可以扩展。但是当新的需求出现时，我们不应该不修改已经实现的类，因为我们已经花了很多时间来纠正它的代码。我们需要在不修改已经实现的类的情况下改变行为(或者扩展它们)。</p><p id="0261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所知，有一种方法可以扩展一个类的功能，这就是继承。但是继承并不总是解决问题的答案，也不是解决问题的有效方法。</p><p id="21ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">让我们开始思考一个问题来知道“为什么？”以及“怎么做？”</em></p><p id="b9b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你开了一家自己的冰激凌店，你打算卖不同口味和配料的冰激凌。首先，你有圆锥。然后有许多口味的冰淇淋可供选择:巧克力、香草、芒果等。你可以吃混合口味的冰淇淋。</p><h2 id="9227" class="jn jo hi bd jp jq jr js jt ju jv jw jx iq jy jz ka iu kb kc kd iy ke kf kg kh bi translated">尝试1:</h2><p id="2ab3" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">实现这一点的一种方法是为巧克力冰淇淋、香草冰淇淋、巧克力和香草冰淇淋、巧克力冰淇淋和巧克力酱等创建类..</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/8305a6cb6fc670056e087a700f3ff67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tp1tXuDx4PRBmSMkNE4eMQ.png"/></div></div></figure><p id="ca2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Icecream类是一个抽象类，包含抽象方法。</p><p id="b82a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些方法在子类中实现和定义</p><p id="589d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每种成本()方法计算冰淇淋的成本+每种配料的成本。</p><p id="bafc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们很容易看到，当我们将有很多成分时，我们会遇到“班级爆炸”，因为我们将有大量的班级！</p><p id="d992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设巧克力的价格发生了变化，在这种情况下，你必须去上每一堂有巧克力味道的课并改变价格。<br/>或者想象一下，你的餐厅决定创造一种新口味，因此我们必须实现所有口味的组合。</p><h2 id="90f4" class="jn jo hi bd jp jq jr js jt ju jv jw jx iq jy jz ka iu kb kc kd iy ke kf kg kh bi translated">尝试2:</h2><p id="0c34" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">你能想到的另一个实现选择是创建一个名为“Icecream”的抽象类，但是你在其中放入每种配料的“实例变量”,就像这样:</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kz"><img src="../Images/86caa675eda8a253b3c764ae02103e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CN3yK-TL06Cjm5-LSVix1w.png"/></div></div></figure><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="ba1a" class="jn jo hi lb b fi lf lg l lh li">public class Icecream {<br/>    // declare instance vars for ingredients as well getters and setters<br/>    <br/>    public double cost(){<br/>        double c=2;<br/>        if(hasChocolate()){<br/>            c+=5;<br/>        }<br/>        if(hasVanilla()){<br/>            c+=5;<br/>        }<br/>        if(hasChocolateSauce()){<br/>            c+=3;<br/>        }<br/>        if(hasCaramelSauce()){<br/>            c+=3;<br/>        }<br/>        return c;<br/>    }<br/>}</span></pre><p id="d846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能会出现一些问题和需求变化，并影响设计:</p><p id="5a65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jm">如果一种成分的价格发生变化怎么办？</em> </strong> <br/>我们将被迫修改现有代码</p><p id="a962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jm">添加了新的成分怎么办？<br/> </em> </strong>我们将被迫添加新方法和改变成本()方法</p><p id="6ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你想在你的餐厅增加一种新的食物，比如同样口味的蛋糕？ <br/> …..</p><p id="d42a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jm">如果顾客想要双份巧克力酱怎么办？<br/> </em> </strong> <em class="jm"> …..</em></p><h2 id="77fc" class="jn jo hi bd jp jq jr js jt ju jv jw jx iq jy jz ka iu kb kc kd iy ke kf kg kh bi translated">继承vs组合</h2><p id="3d7c" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">上面的例子表明，继承可能既不“可维护”，也不“灵活”。行为和子类是在编译时静态设置的，它们都继承了相同的行为。<br/>组合帮助我们继承行为，并在运行时动态扩展它们。</p><p id="3a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是如何！</p><h1 id="4f92" class="lj jo hi bd jp lk ll lm jt ln lo lp jx lq lr ls ka lt lu lv kd lw lx ly kg lz bi translated">装饰模式来了。</h1><p id="525e" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">在装饰模式中:<br/>1-任何“可选地添加”在冰淇淋蛋筒上的东西，都被称为“装饰者”。<br/>2-这里的圆锥体将是“装饰”对象。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ma"><img src="../Images/dc741e43ddfb6bb667775d22e0bee456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8q-BrcydZOFEYHiCxYLnA.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">从https://online.visual-paradigm.com<a class="ae mf" href="https://online.visual-paradigm.com" rel="noopener ugc nofollow" target="_blank">获得的装饰设计模式通用类图</a></figcaption></figure><p id="4f1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将修改上面的类图来解决我们的问题，因此我们将有:</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mg"><img src="../Images/6586cab5f50a277d3a5ad459b2f3bc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yl50Y78gTGqX7In1O8QKTA.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">使用装饰模式的冰淇淋问题的类图</figcaption></figure><p id="f82c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然,“Decorator”类从Icecream接口继承方法，Decorator从“Decorator”类继承“Icecream”实例变量。</p><p id="09eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些重要注意事项:</p><ul class=""><li id="3560" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">每个装饰者都有一个组件。</li><li id="ca81" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">每个组件都实现相同的接口或抽象类(在这种情况下不会有很大的不同，只是一种设计选择)。</li></ul><p id="0278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BiscuitCone类如下所示:</p><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="c113" class="jn jo hi lb b fi lf lg l lh li">public class BiscuitCone implements IcecreamInterface {</span><span id="4163" class="jn jo hi lb b fi mv lg l lh li">private String Contents;<br/>    private double Cost;</span><span id="bdf6" class="jn jo hi lb b fi mv lg l lh li">public BiscuitCone() {<br/>        this.Contents = "Simple Cone";<br/>        this.Cost = 1;<br/>    }</span><span id="414f" class="jn jo hi lb b fi mv lg l lh li"><a class="ae mf" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public String getContents() {<br/>        return Contents;<br/>    }</span><span id="2ca6" class="jn jo hi lb b fi mv lg l lh li"><a class="ae mf" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public double getCost() {<br/>        return Cost;<br/>    }<br/>}</span></pre><p id="59cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">界面IceCreamI:</p><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="945a" class="jn jo hi lb b fi lf lg l lh li">public interface IcecreamInterface {</span><span id="e5c3" class="jn jo hi lb b fi mv lg l lh li">public double getCost();</span><span id="4e6a" class="jn jo hi lb b fi mv lg l lh li">public String getContents();<br/>}</span></pre><p id="e486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">装饰超类:</p><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="736f" class="jn jo hi lb b fi lf lg l lh li">public abstract class Decorator implements IcecreamInterface {</span><span id="bc27" class="jn jo hi lb b fi mv lg l lh li">IcecreamInterface I;</span><span id="b458" class="jn jo hi lb b fi mv lg l lh li">public Decorator(IcecreamInterface I) {<br/>        this.I = I;<br/>    }</span><span id="c9d6" class="jn jo hi lb b fi mv lg l lh li">}</span></pre><p id="06a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Chocolate Decorator: <br/>注意:因为“Decorator”类实现了IcecreamInterface，所以Chocolate Decorator不需要显式地实现它。</p><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="db85" class="jn jo hi lb b fi lf lg l lh li">public class ChocolateDeco extends Decorator {</span><span id="0b09" class="jn jo hi lb b fi mv lg l lh li">public ChocolateDeco(IcecreamInterface I) {<br/>        super(I);<br/>    }</span><span id="5e83" class="jn jo hi lb b fi mv lg l lh li"><a class="ae mf" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public double getCost() {<br/>        return I.getCost() + 2;<br/>    }</span><span id="326f" class="jn jo hi lb b fi mv lg l lh li"><a class="ae mf" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public String getContents() {<br/>        return I.getContents()+", Chocolate";<br/>    }</span><span id="1a31" class="jn jo hi lb b fi mv lg l lh li">}</span></pre><p id="7e9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">焦糖装饰课:</p><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="9a98" class="jn jo hi lb b fi lf lg l lh li">public class CaramelDeco extends Decorator {</span><span id="5862" class="jn jo hi lb b fi mv lg l lh li">public CaramelDeco(IcecreamInterface I) {<br/>        super(I);<br/>    }</span><span id="b021" class="jn jo hi lb b fi mv lg l lh li"><a class="ae mf" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public double getCost() {<br/>        return I.getCost() + 4;<br/>    }</span><span id="b88a" class="jn jo hi lb b fi mv lg l lh li"><a class="ae mf" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public String getContents() {<br/>        return I.getContents() + ", Caramel";<br/>    }</span><span id="81c0" class="jn jo hi lb b fi mv lg l lh li">}</span></pre><p id="8daf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为另外两个装饰者做同样的事情。</p><h2 id="cb0b" class="jn jo hi bd jp jq jr js jt ju jv jw jx iq jy jz ka iu kb kc kd iy ke kf kg kh bi translated">现在，奇迹发生了😄</h2><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="fc20" class="jn jo hi lb b fi lf lg l lh li">public class Decorator_icecream {</span><span id="ffe9" class="jn jo hi lb b fi mv lg l lh li">public static void main(String[] args) {<br/>        IcecreamInterface II = new BiscuitCone();<br/>        II = new CaramelDeco(II);<br/>        II = new ChocolateDeco(II);<br/>        System.out.println(II.getContents());</span><span id="2042" class="jn jo hi lb b fi mv lg l lh li">}</span><span id="8b59" class="jn jo hi lb b fi mv lg l lh li">}</span></pre><p id="a080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是所发生的事情，BiscuitCone的一个实例被创建，然后用CaramelDecorator修饰，再用ChocolateDecorator修饰。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mw"><img src="../Images/600b718c246b70479d499426251f7918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_EoXNyLlypidusxHhFWLw.png"/></div></div></figure><p id="ab49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当创建II.getContents()时，它首先调用ChocolateDecorator类的getContents()方法(作为II ChocolateDecorator类的一个实例)。<br/>在CaramelDecorator类内部getContents的实现中，调用了它通过构造函数得到的IcecreamInterface的引用的getContents()方法，这个构造函数是CaramelDecorator类的一个对象。</p><p id="6454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这里的输出将是:</strong></p><pre class="ko kp kq kr fd la lb lc ld aw le bi"><span id="d8f4" class="jn jo hi lb b fi lf lg l lh li"><em class="jm">Simple Cone, Caramel, Chocolate</em></span></pre><h2 id="b79a" class="jn jo hi bd jp jq jr js jt ju jv jw jx iq jy jz ka iu kb kc kd iy ke kf kg kh bi translated">参考资料:</h2><div class="mx my ez fb mz na"><a href="https://refactoring.guru/design-patterns/decorator" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">装饰者</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">Decorator是一种结构设计模式，它允许您通过将这些对象放入…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">重构大师</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no kx na"/></div></div></a></div><div class="mx my ez fb mz na"><a href="https://dzone.com/articles/decorator-design-pattern-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">Java中的装饰设计模式——DZone Java</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">今天，我将讨论一种广为人知且经常使用的模式，称为装饰设计模式。的…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">dzone.com</p></div></div><div class="nj l"><div class="np l nl nm nn nj no kx na"/></div></div></a></div><div class="mx my ez fb mz na"><a href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">头先设计模式</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">设计模式有什么特别之处？在任何给定的时刻，都有人在为同样的软件设计问题而挣扎…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">www.oreilly.com</p></div></div><div class="nj l"><div class="nq l nl nm nn nj no kx na"/></div></div></a></div></div><div class="ab cl nr ns gp nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="hb hc hd he hf"><p id="d3e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">原载于2020年4月2日https://mirafblog.com</em><a class="ae mf" href="https://mirafblog.com/decorator-design-pattern/" rel="noopener ugc nofollow" target="_blank"><em class="jm"/></a><em class="jm">。</em></p></div></div>    
</body>
</html>