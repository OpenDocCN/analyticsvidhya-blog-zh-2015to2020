<html>
<head>
<title>Solving Business Problems with Analytics: Workload Evaluation (1.3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用分析解决业务问题:工作负载评估(1.3)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/solving-business-problems-with-analytics-workload-evaluation-1-3-30d2bf287891?source=collection_archive---------24-----------------------#2020-03-03">https://medium.com/analytics-vidhya/solving-business-problems-with-analytics-workload-evaluation-1-3-30d2bf287891?source=collection_archive---------24-----------------------#2020-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="2b4c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">生成和加载测试数据</h1><p id="7346" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本文是关注使用分析解决常见业务问题的系列文章的第一篇。对于第一个问题，即工作负载评估，我决定分成五个较小的部分，这样我就可以更详细地讨论这个问题，并希望为解决这类问题提供一个有用的例子。这五个会议将是: <a class="ae kc" rel="noopener" href="/analytics-vidhya/how-to-translate-business-problems-into-analytical-problems-d1e4f1305ff0"> <em class="kb">将业务问题转化为分析问题</em> </a> <em class="kb">、</em> <a class="ae kc" rel="noopener" href="/analytics-vidhya/solving-business-problems-with-analytics-workload-evaluation-1-2-6d54ad1c15b0"> <em class="kb">重新评估纸上解决方案</em> </a> <em class="kb">、生成和加载测试数据(当前会议)、提出解决方案，以及最后的项目总结和演示。</em></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/dca216d3e5ecbee11ea5825d6236d76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ic3kW-dJC6mAYutK"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">照片由<a class="ae kc" href="https://unsplash.com/@zmachacek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">zdenk Macháek</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b8aa" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在之前的一次会议中，我提出了一个常见的日常业务问题，即试图衡量和评估员工的工作量。我们的目标是回答这些典型的问题:</p><ul class=""><li id="8242" class="ky kz hi jf b jg kt jk ku jo la js lb jw lc ka ld le lf lg bi translated">我们如何衡量当前的工作量？</li><li id="abc7" class="ky kz hi jf b jg lh jk li jo lj js lk jw ll ka ld le lf lg bi translated">我们的工作负载能力是多少？</li><li id="762a" class="ky kz hi jf b jg lh jk li jo lj js lk jw ll ka ld le lf lg bi translated">我们需要多少员工来完成我们的要求？</li><li id="c574" class="ky kz hi jf b jg lh jk li jo lj js lk jw ll ka ld le lf lg bi translated">我们应该期望一名员工完成什么？</li><li id="24df" class="ky kz hi jf b jg lh jk li jo lj js lk jw ll ka ld le lf lg bi translated">员工工作量是否平衡？</li></ul><p id="aaea" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在那篇文章中，我将重点放在将业务问题转化为一个可以用可量化的方式测试和解决的分析问题上。在本次会议中，我们将生成测试数据，以跟进建议的解决方案。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h2 id="e2cf" class="lt ig hi bd ih lu lv lw il lx ly lz ip jo ma mb it js mc md ix jw me mf jb mg bi translated"><strong class="ak"> <em class="mh">回顾(如果还新鲜，可以跳过这一节到下一个标题)</em> </strong></h2><p id="5a13" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们决定，要解决所有这些问题，我们必须首先从我们现有的信息开始。我们知道我们有一些员工，我们知道我们有一些工作量要完成。好的，到目前为止很简单。我们需要做的最重要的事情是确定如何衡量要求我们完成的总工作量。这些问题中的每一个都依赖于这个问题的解决方案；这一定是我们的起点。</p><p id="9cc8" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">我们如何衡量总工作量？这需要你研究现实世界中的潜在变量。与你交谈的每一位经理对此可能会有不同的答案，所以尽你所能为这次评估收集所有的特征。对于我们的例子，我们提出了一些通用的方法:购买、开具的发票和购买金额。我们需要评估并确定每个场景的最佳度量。然后，我们必须将这些测量值标准化，并将它们加在一起，以获得总工作量。因为我们试图测量功，最好的测量方法将与完成单位体积的努力有最线性的关系。虽然努力是一件很难衡量的事情，但是我们可以通过观察它的成本来推断它的价值；在一个组织中，努力的代价是时间。因此，为了评估工作量的最佳潜在测量值，我们将评估每个工作量测量值的相关系数，最高值将是我们的选择。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="330d" class="lt ig hi mj b fi mn mo l mp mq"><em class="kb">ρx,y = co-variance(x,y)/(σₓ*σᵧ)<br/>Where x = effort, and y = volume<br/>effort = 1+((x-μ)/σ)<br/>volume = sum(units)<br/><br/>volume_category = {category|max{ρ(effort,vol_measure):∀vol_measure}}</em></span><span id="94c7" class="lt ig hi mj b fi mr mo l mp mq"><em class="kb">normalized_units = ∑{units/max(units)|volume_category}<br/>_________________</em></span><span id="a17b" class="lt ig hi mj b fi mr mo l mp mq"><em class="kb">relative_volume = effort * normalized_units</em></span></pre><p id="0d03" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">因此，现在我们有了总工作量的度量，其他的一切都自然而然地到位了。下一个障碍是确定单个贡献者的工作量。</p><p id="6d24" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">为了评估这一点，我们用平均总工作量除以完成这项工作所需的平均时间来衡量工作效率。为了确定期望从平均贡献者那里得到多少，我们将取效率测量的平均值，并返回平均体积贡献，其中效率在总体平均值的标准偏差内。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="5f4f" class="lt ig hi mj b fi mn mo l mp mq"><em class="kb">avg_volume = avg(relative_volume)/employee<br/>avg_efficiency = avg_volume/avg(time)<br/>_________________</em></span><span id="9ce7" class="lt ig hi mj b fi mr mo l mp mq"><em class="kb">exp_vol_contribution = avg_volume &lt;--- avg_efficiency - σ &lt; avg_volume &lt; efficiency + σ</em></span></pre><p id="3b43" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">既然我们知道了如何衡量总工作量和员工的预期贡献，我们就可以很容易地回答剩下的问题了。</p><p id="e54e" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">为了评估所需的员工，我们只需将我们的总工作量除以预期贡献。为了评估我们当前的工作负载能力，我们将我们当前的员工乘以预期贡献。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="a7b0" class="lt ig hi mj b fi mn mo l mp mq"><em class="kb">req_contributors = relative_volume/exp_vol_contribution</em><br/><em class="kb">capacity = exp_vol_contribution * count(employees)</em></span></pre><p id="d430" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">我们现在可以回答我们面临的每一个问题。现在，为了在实践中看到这个解决方案，我们首先必须生成一些测试数据。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ms"><img src="../Images/01c565cdcab4f6dbbc3e3b21c931a69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TugU9CWUpLW6-4gX"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">克里斯里德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="f387" class="lt ig hi bd ih lu lv lw il lx ly lz ip jo ma mb it js mc md ix jw me mf jb mg bi translated"><strong class="ak">生成测试数据</strong></h2><p id="12fc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将使用Python来生成我们的测试数据。</p><p id="b54b" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">首先，我们将导入随机库并创建一个字典来存储我们的结果。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="0093" class="lt ig hi mj b fi mn mo l mp mq">import random as rand<br/>values = {}</span></pre><p id="6c9f" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">发票数量:</em> </strong></p><p id="2282" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">接下来，我们将使用随机库来生成发票计数列表；这个数字就是一次采购所需的发票数量。为此，我们将创建一个快速函数，它接受一个列表对象、我们的样本大小和一个上限。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="941b" class="lt ig hi mj b fi mn mo l mp mq">def rand_inv(list_to_append,n,upper_limit):</span></pre><p id="ad25" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">然后，我们将使用for循环生成一个大于零的随机整数，并将其添加到一个列表中，以确定迭代次数和上限。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="d3ab" class="lt ig hi mj b fi mn mo l mp mq">for i in range(samples):<br/>     r = rand.randint(1,upper_limit)<br/>     list_to_append.append(r)</span></pre><p id="b236" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">之后，我们将定义样本大小，并在字典中创建一个名为“invoices”的空列表来存储函数结果。最后，我们将简单地调用函数。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="2ce5" class="lt ig hi mj b fi mn mo l mp mq">samples = 5000<br/>values['invoices'] = []</span><span id="26ce" class="lt ig hi mj b fi mr mo l mp mq">rand_inv(values['invoices'],samples,5)</span></pre><p id="4f66" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">一起:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="9553" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">或者，如果列表理解是你的事情(他们应该是):</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="a4f1" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">采购价格:</em> </strong></p><p id="1913" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">我们将做同样的事情，并创建一个函数来生成每次购买的价格。我们将通过创建另一个函数来生成一个介于1和我们定义的范围限制之间的随机数，然后将结果追加到一个指定的列表中。之后，我们将在字典中创建一个空列表来存储函数结果并调用函数。</p><p id="e386" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">注意，由于货币值通常有两位小数，我们将调用<em class="kb"> rand.uniform() </em>函数，并将其包含在<em class="kb"> round() </em>函数中，以限制其两位小数。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="7453" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">列表理解:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="3af5" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">另一方面，在这一点上应该清楚，列表理解是你的朋友。</p><p id="f37f" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">分类值:</em> </strong></p><p id="c438" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">我们还需要生成一些分类值。为此，我们将在列表中定义所有选项，然后使用一个随机整数从列表中调用一个值。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="818a" class="lt ig hi mj b fi mn mo l mp mq">business_unit = ['supply','mining','aerospace','infantry','defense']<br/>client = ['terran industries','protoss corporation','zerg inc']<br/>vendor = ['brood corp','liberty national','swarm llc','void co']<br/>employee = ['kerrigan','raynor','fenix']</span></pre><p id="5b94" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">接下来，我们将创建一个函数，它将类别、相应的列表对象和样本大小作为参数。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="2756" class="lt ig hi mj b fi mn mo l mp mq">def create_categories(category,source_list,samples):</span></pre><p id="6a99" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">然后，我们将在值字典中为该类别创建一个列表，并为<em class="kb"> rand.randint() </em>函数定义范围限制。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="3758" class="lt ig hi mj b fi mn mo l mp mq">    values[category] = []<br/>    range_limit = len(source_list)-1</span></pre><p id="685e" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">然后，我们将创建一个for循环，为每个样本生成一个随机整数，并将相关的类别列表项追加到值字典列表中。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="5669" class="lt ig hi mj b fi mn mo l mp mq">for i in range(samples): <br/>        r = rand.randint(0,range_limit) <br/>        values[category].append(source_list[r])</span></pre><p id="32c3" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">然后我们会为每组参数调用我们的函数。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="38b7" class="lt ig hi mj b fi mn mo l mp mq">create_categories('business_unit',business_unit,samples)<br/>create_categories('client',client,samples) <br/>create_categories('vendor',vendor,samples) <br/>create_categories('employee',employee,samples)</span></pre><p id="59e2" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">一起:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="4dd8" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">同样，我们可以使用列表理解来巩固这些步骤，而不是编写一个又长又乱的函数。这一次，我们还将使用lambda函数来使它更加清晰。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="f3aa" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">日期:</em> </strong></p><p id="80e6" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">接下来，我们必须为我们的交易和支付日期生成随机日期。</p><p id="841b" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">我们将从从日期时间库中导入<em class="kb">日期时间</em>和<em class="kb">时间增量</em>开始。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="fea3" class="lt ig hi mj b fi mn mo l mp mq">from datetime import datetime<br/>from datetime import timedelta</span></pre><p id="ee6d" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">现在我们将创建一个函数，它将开始日期限制、结束日期限制和样本大小作为参数。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="e0a9" class="lt ig hi mj b fi mn mo l mp mq">def rand_date(start_date_limit,end_date_limit,samples):</span></pre><p id="487c" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">然后，我们将在字典中创建空列表，并确定时间窗口内的秒数。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="c1d2" class="lt ig hi mj b fi mn mo l mp mq">values['t_date'] = []<br/>values['p_date'] = []</span><span id="9648" class="lt ig hi mj b fi mr mo l mp mq">time_delta = end_date_limit - start_date_limit<br/>seconds_delta = time_delta.total_seconds()</span></pre><p id="aad0" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在该范围内为每个样本创建一个随机开始日期，并添加到我们的列表中。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="f496" class="lt ig hi mj b fi mn mo l mp mq">for i in range(samples):<br/>    random_second = rand.randrange(seconds_delta)<br/>    start_date = start_date_limit + timedelta(seconds=random_second)<br/>    values['t_date'].append(start_date)</span></pre><p id="263e" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">此后，我们将开始日期作为新的下限，并生成相应的结束日期，这样结束日期将始终在开始日期之后。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="ccbe" class="lt ig hi mj b fi mn mo l mp mq">time_delta = end_date_limit - start_date<br/>seconds_delta = time_delta.total_seconds()</span><span id="6846" class="lt ig hi mj b fi mr mo l mp mq">random_second = rand.randrange(seconds_delta)<br/>end_date = start_date + timedelta(seconds=random_second)         values['p_date'].append(end_date)</span></pre><p id="4fa5" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">定义我们的开始和结束参数，然后调用我们的函数。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="7d28" class="lt ig hi mj b fi mn mo l mp mq">start_date_limit = datetime.strptime('1/1/19','%m/%d/%y') end_date_limit = datetime.strptime('12/31/19','%m/%d/%y')</span><span id="15da" class="lt ig hi mj b fi mr mo l mp mq">rand_date(start_date_limit,end_date_limit,samples)</span></pre><p id="8d0a" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">接下来，我们将导入熊猫并将字典加载到数据帧中。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="0978" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">同样，为了简化，我们将使用lambda函数并列出理解。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mv"><img src="../Images/1941c50a42b38a8f8be74c1fcc445745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cxDF8pln48FZ7rM_"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">丹尼尔·林肯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="67e2" class="lt ig hi bd ih lu lv lw il lx ly lz ip jo ma mb it js mc md ix jw me mf jb mg bi translated">创建测试环境</h2><p id="3b3b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经有了测试数据，我们将在PostgreSQL数据库中创建一个测试环境来存储我们的数据，以便将来进行转换。</p><p id="f1c9" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">首先，我们将导入<em class="kb"> pandas </em>库，并将我们的测试数据字典加载到dataframe中。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="c367" class="lt ig hi mj b fi mn mo l mp mq">import pandas as pd</span><span id="29b4" class="lt ig hi mj b fi mr mo l mp mq">df = pd.DataFrame(values)<br/>df.head()</span></pre><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mw"><img src="../Images/76d9e685850876a5167578e182ca0290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NBq0gbZPta0V2TrYWXRzA.png"/></div></div></figure><p id="3614" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">创建数据库:</em> </strong></p><p id="6126" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">接下来，我们必须创建我们的数据库。我们将从导入<em class="kb"> psycopg2 </em>库和<em class="kb">ISOLATION _ LEVEL _ auto commit</em>扩展开始。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="6af3" class="lt ig hi mj b fi mn mo l mp mq">import psycopg2<br/>from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT</span></pre><p id="eef4" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">现在我们将定义我们的连接并创建一个测试数据库。务必确保要创建的任何数据库连接在完成后都已关闭。这将帮助您避免将来出现问题，即使这是一个测试环境。</p><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="3b0a" class="lt ig hi mj b fi mn mo l mp mq">with psycopg2.connect("user=postgres password=****") as conn:<br/>    conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)<br/>    cur = conn.cursor()<br/>    create_database = 'Create Database wlcap_test_env;'</span><span id="1acc" class="lt ig hi mj b fi mr mo l mp mq">    try:<br/>        cur.execute(create_database)<br/>        cur.close()<br/>    except:<br/>        cur.close()</span></pre><p id="d453" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><em class="kb">*如果没有安装PostgreSQL，可以在这里</em>  <em class="kb">找到</em> <a class="ae kc" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"> <em class="kb">。</em></a></p><p id="9b54" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">一起:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="1edf" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">我添加了一个catch来删除并重新创建数据库，这样我就可以继续重新运行整个脚本，而不用担心数据库是否存在。</p><p id="ad0d" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">接下来，我们将创建一个函数来执行查询，以便在将来节省时间。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="39b7" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">关闭与打开的数据库的任何连接是非常重要的，因此编写函数来执行查询可以让您将整个过程放在函数中，而不用担心有打开的连接。</p><p id="b6bb" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">创建模式和表</em> </strong></p><p id="ce8f" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">让我们创建我们的模式和主表。您不必为此创建一个模式，因为这是一个测试环境，但是根据您所做的转换有多广泛或者您需要做多少测试，这可能有助于您保持有组织性。如果您不选择创建模式，您的表将被添加到数据库的“公共”模式中。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="1f2a" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">导入数据:</em> </strong></p><p id="11f2" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">现在为了加载我们的数据，我们需要为它的pandas集成导入<em class="kb">sqlalchemy . create _ engine</em>。如果您愿意，以上所有操作也可以使用sqlalchemy来完成。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mt mu l"/></div></figure><pre class="ke kf kg kh fd mi mj mk ml aw mm bi"><span id="4ed9" class="lt ig hi mj b fi mn mo l mp mq">Output: [(0001, 4, 414909.0, ‘defense’, ‘zerg inc’, ‘void co’, ‘fenix’, datetime.datetime(2019, 8, 1, 16, 30, 37), datetime.datetime(2019, 10, 21, 6, 33, 42)), (0002, 3, 305631.0, ‘infantry’, ‘protoss corporation’, ‘brood corp’, ‘raynor’, datetime.datetime(2019, 2, 24, 0, 9, 24), datetime.datetime(2019, 7, 15, 11, 5, 9)), (0003, 4, 510451.0, ‘defense’, ‘protoss corporation’, ‘void co’, ‘kerrigan’, datetime.datetime(2019, 9, 15, 11, 40, 18), datetime.datetime(2019, 11, 8, 8, 14, 2)), (5004, 2, 211791.0, ‘aerospace’, ‘protoss corporation’, ‘void co’, ‘kerrigan’, datetime.datetime(2019, 2, 28, 16, 33, 37), datetime.datetime(2019, 12, 21, 3, 56, 43)), (0005, 4, 801484.0, ‘mining’, ‘protoss corporation’, ‘liberty national’, ‘fenix’, datetime.datetime(2019, 6, 7, 16, 29, 15), datetime.datetime(2019, 7, 24, 5, 36, 47))]</span></pre><p id="3337" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">为了节省时间，您还可以让<em class="kb"> pandas </em>和<em class="kb"> sqlalchemy </em>在<em class="kb"> df.to_sql </em>命令上自动创建表。这样做将允许您跳过create table查询，而不必定义每个字段。</p><p id="ebbd" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj">总结</strong></p><p id="ccf5" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在这个会话中，我们生成了5000条测试数据记录，在PostgreSQL中创建了一个测试数据库，创建了一个模式和表，并将测试数据加载到数据库中。作为额外收获，我们还看到了列表理解和lambda函数非常有用的另一个例子。</p><p id="b977" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">在下一节课中，我们将使用新数据完成工作负载评估。</p></div></div>    
</body>
</html>