<html>
<head>
<title>Beating NumPy performance speed by extending Python with C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过用C扩展Python来提高性能速度</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/beating-numpy-performance-by-extending-python-with-c-c9b644ee2ca8?source=collection_archive---------1-----------------------#2019-10-21">https://medium.com/analytics-vidhya/beating-numpy-performance-by-extending-python-with-c-c9b644ee2ca8?source=collection_archive---------1-----------------------#2019-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5ddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">嵌入</em> <strong class="ih hj"> <em class="jd"> C </em> </strong> <em class="jd">成</em><strong class="ih hj"><em class="jd">Python</em></strong><em class="jd">进行性能提速。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b087573cf093db6501dc87b704089906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z7BQPleuE1o4h4Hh"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">尼克·希利尔在<a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有没有想过NumPy是如何快速完成复杂的计算的？秘密在于它使用了低级编程语言<strong class="ih hj">—</strong>—<strong class="ih hj">C</strong>。将数据传递给<strong class="ih hj"> C </strong>，执行计算并将其返回给<strong class="ih hj"> Python。你会问什么更简单？事实上，这并不像你可能认为的那样是一项完全琐碎的任务。</strong></p><p id="fbf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将展示如何用C语言扩展你的Python代码以获得更好的性能速度，还将展示如何比NumPy代码更快地进行计算。这里假设你已经熟悉了一些<strong class="ih hj"> Python </strong>和<strong class="ih hj"> C </strong>的基础知识。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="d738" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated"><strong class="ak">比较纯Python点积和NumPy的性能</strong></h2><p id="7910" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在这篇文章中，我将比较在两个任意矩阵上执行点积的速度。</p><p id="a7d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> Python、</strong>和<strong class="ih hj"> </strong>任何其他编程语言<strong class="ih hj"> </strong>中，做2个矩阵的点积最简单直接的方法就是使用3个嵌套的for循环。让我们考虑下面的例子。</p><p id="c331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先导入所有必要的模块，并在<strong class="ih hj"> python_dot_product.py </strong>文件中创建用于比较性能的辅助函数，</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="4f4c" class="kc kd hi ld b fi lh li l lj lk">#python_dot_product.py</span><span id="5a93" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">import </strong>time<br/><strong class="ld hj">import </strong>numpy<strong class="ld hj"> as </strong>np<strong class="ld hj"><br/>import </strong>random<strong class="ld hj"> as </strong>rn</span><span id="5f8a" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj"><br/>def</strong> timer(<em class="jd">func</em>):<br/>    <strong class="ld hj">def</strong> wrapper(*<em class="jd">args</em>, **<em class="jd">kwargs</em>):<br/>        before = time.time()<br/>        result = func(*<em class="jd">args</em>, **<em class="jd">kwargs</em>)<br/>        after = time.time()<br/>        <strong class="ld hj">return</strong> after - before, result<br/>    <strong class="ld hj">return</strong> wrapper<br/></span><span id="328b" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">def </strong>generate(<em class="jd">size, range_</em>):<br/>    arr = [[[rn.randrange(*range_) <strong class="ld hj">for</strong> _ <strong class="ld hj">in</strong> range(size)] <strong class="ld hj">for</strong> _ <strong class="ld hj">in</strong> range(size)] <strong class="ld hj">for</strong> _ <strong class="ld hj">in</strong> range(2)]<br/>    <strong class="ld hj">return</strong> arr</span></pre><p id="0647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj">定时器</strong>函数只是一个简单的装饰函数，帮助我们测量执行函数所用的时间，而<strong class="ih hj">生成</strong>函数只是为我们提供一个2D随机数数组。</p><p id="d69c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了本教程的方便，我将使用大小为<strong class="ih hj"> MxM </strong>的矩阵。</p><p id="3b82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是创建点产品的<strong class="ih hj"> Python </strong>和<strong class="ih hj"> NumPy </strong>实现函数，并对它们应用我们的<strong class="ih hj">定时器</strong>装饰器。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="c020" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">@timer</strong><br/><strong class="ld hj">def</strong> python_implementation(<em class="jd">arr1</em>, <em class="jd">arr2</em>):<br/>    result = [[0 <strong class="ld hj">for</strong> _ <strong class="ld hj">in</strong> range(len(arr1))] <strong class="ld hj">for</strong> _ <strong class="ld hj">in</strong> range(len(arr2[0]))]<br/>    <strong class="ld hj">for</strong> i <strong class="ld hj">in</strong> range(len(arr1)):<br/>        <strong class="ld hj">for</strong> j <strong class="ld hj">in</strong> range(len(arr2[0])):<br/>            <strong class="ld hj">for</strong> k <strong class="ld hj">in</strong> range(len(arr2[0])):<br/>                result[i][j] += arr1[i][k] * arr2[k][j]<br/>    <strong class="ld hj">return</strong> result<br/></span><span id="2ea6" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">@timer<br/>def</strong> numpy_implementation(<em class="jd">arr1, arr2</em>):<br/>    <strong class="ld hj">return</strong> np.array(arr1).dot(arr2)</span></pre><p id="4ea9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后比较结果。我将用矩阵大小为<strong class="ih hj"> 500x500 </strong>的函数来测试我们的函数，向您展示性能上的明显差异。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="8b54" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">if</strong> __name__ == '__main__':<br/>    data = generate(<em class="jd">size=500, range_=(1, 100)</em>)<br/>    numpy_time_taken, numpy_result = numpy_implementation(*data)<br/>    python_time_taken, python_result = python_implementation(*data)<br/>    print(f"time taken with numpy: {numpy_time_taken} seconds")<br/>    print(f"time taken with python: {python_time_taken} seconds")</span></pre><p id="9397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="0650" class="kc kd hi ld b fi lh li l lj lk">time taken with numpy: <strong class="ld hj">0.16844797134399414</strong> seconds<br/>time taken with python: <strong class="ld hj">32.14348006248474</strong> seconds</span></pre><p id="4e41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，原来<strong class="ih hj"> NumPy </strong>比天真的<strong class="ih hj"> Python </strong>实现点积大约快<strong class="ih hj"> 320 </strong>倍。</p><p id="e7a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们如何加快我们的代码呢？问题是我们的实现具有时间复杂度为<strong class="ih hj">O(n)</strong>，这是非常低效的。但是我们能减少它吗？是的，我们可以稍微修改我们的<strong class="ih hj"> python_implementation </strong>函数以获得更低的时间复杂度，但是尽管如此，即使你最小化时间复杂度和在<strong class="ih hj"> Python </strong>中完成的操作，它也永远不会接近<strong class="ih hj"> NumPy </strong>的性能。</p><p id="29d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们如何接近甚至击败NumPy？这是我们必须深入挖掘的地方，并开始用C代码扩展我们的Python代码。因为<strong class="ih hj"> Python </strong>是解释型语言，比编译型的<strong class="ih hj"> C </strong>慢，所以后者会快很多。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="2afd" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">实现C模块以便Python与之交互</h2><p id="8e1b" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在<strong class="ih hj"> c_extension.c </strong>文件中，我们将在<strong class="ih hj"> C </strong>中为我们的点积函数创建实际的逻辑，稍后可以从Python中调用。</p><p id="ab49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最重要的是进口。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="c40f" class="kc kd hi ld b fi lh li l lj lk">//c_extension.c</span><span id="6bc1" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">#include</strong> "Python.h"<br/><strong class="ld hj">#include</strong> "stdlib.h"<br/><strong class="ld hj">#include</strong> "omp.h"</span></pre><p id="6854" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> #include "Python.h" </strong>行基本上说的是我们在导入<strong class="ih hj"> Python </strong>开发头，它将允许我们传递、处理和返回<strong class="ih hj"> Python </strong>数据类型和对象。如果您在导入<strong class="ih hj"> Python.h </strong>头文件时遇到问题，请访问<a class="ae ju" href="https://stackoverflow.com/questions/21530577/fatal-error-python-h-no-such-file-or-directory" rel="noopener ugc nofollow" target="_blank">此处</a>获取解决方案。</p><p id="bb01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将需要它，因为<strong class="ih hj"> Python </strong>中的一切都是对象，而<strong class="ih hj"> C </strong>没有对象。</p><p id="bc4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> stdlib.h </strong> —用于访问内存分配函数。</p><p id="41ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不知道标题是什么，现在不要担心它。我们将稍后到达那里。</p><p id="ae5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从编写我们的<strong class="ih hj">点积</strong>函数的原型开始。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="a180" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject*</strong> dot_product(<strong class="ld hj">PyObject*</strong> self, <strong class="ld hj">PyObject*</strong> args)</span></pre><p id="9211" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从关于将C嵌入Python的官方教程<a class="ae ju" href="https://docs.python.org/3/extending/extending.html#" rel="noopener ugc nofollow" target="_blank">来看，这是一个获取并返回Python对象的C函数的样子。</a></p><p id="80fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们简单地创建一个C函数，它可以接收和返回Python对象。现在我们可以实现实际的逻辑了。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="f499" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject*</strong> dot_product(<strong class="ld hj">PyObject*</strong> self, <strong class="ld hj">PyObject*</strong> args) {<br/>    <strong class="ld hj">PyObject</strong>* mat1, *mat2;</span><span id="8326" class="kc kd hi ld b fi ll li l lj lk">    <strong class="ld hj">if</strong>(!<strong class="ld hj">PyArg_ParseTuple</strong>(args, "O|O", &amp;mat1, &amp;mat2)) {<br/>        <strong class="ld hj">return</strong> NULL;<br/>    }<br/>}</span></pre><p id="94de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们一行一行地看看这里到底发生了什么。</p><ul class=""><li id="f983" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated"><strong class="ih hj">py object *</strong>self-是一个默认参数，它必须出现在任何想要与Python交互的C函数中。你可以把它想象成Python对象方法中的一个<strong class="ih hj"> self </strong>参数。</li><li id="fda9" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated"><strong class="ih hj"> PyObject* </strong> args —这实际上是所有参数作为一个<strong class="ih hj">元组</strong>传递的地方。</li><li id="5ec9" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated"><strong class="ih hj"> PyObject* </strong> mat1，mat2 —创建类型为<strong class="ih hj"> PyObject </strong>的指针，我们将在这里存储我们的2D数组。</li><li id="c1ad" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">PyArg_ParseTuple  —这是所有神奇事情发生的地方。这个函数接受传递给C函数的所有参数(在我们的例子中是<strong class="ih hj"> args </strong>)作为一个元组，并对它们进行解析，以便您可以将它们赋给一些变量，并在以后引用它们。这个函数的第一个参数是我们作为参数接受的参数(<strong class="ih hj"> args </strong>)。第二个实际上是一个模式，它告诉这个函数您期望什么数据类型或对象。在我们的例子中，我们有"<strong class="ih hj"> O|O" </strong>，这基本上意味着我们期待2个Python对象(在我们的例子中，这些对象将是2个Python列表)。更多信息见<a class="ae ju" href="https://pythonextensionpatterns.readthedocs.io/en/latest/parsing_arguments.html" rel="noopener ugc nofollow" target="_blank">这个</a>。其余的参数只是变量，我们解析的参数将放在这里。在if语句中返回NULL 只会在您没有传递足够的解析模式中指定的参数时抛出一个异常。</li></ul><p id="3d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在当我们在C中收到Python列表时，我们可以对它们执行任何类型的操作。首先要做的是获取尺寸。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="b66b" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject*</strong> dot_product(<strong class="ld hj">PyObject*</strong> self, <strong class="ld hj">PyObject*</strong> args) {<br/>    //previous code omitted<br/>    <br/>    //getting dimensions of our lists<br/>    <strong class="ld hj">int</strong> mat1_rows, mat1_columns, mat2_rows, mat2_columns;</span><span id="3247" class="kc kd hi ld b fi ll li l lj lk">    mat1_rows = <strong class="ld hj">PyObject_Length</strong>(mat1);<br/>    mat1_columns = <strong class="ld hj">PyObject_Length</strong>(<strong class="ld hj">PyList_GetItem</strong>(mat1, 0));<br/>    mat2_rows = <strong class="ld hj">PyObject_Length</strong>(mat2);<br/>    mat2_columns = <strong class="ld hj">PyObject_Length</strong>(<strong class="ld hj">PyList_GetItem</strong>(mat2, 0));<br/>}</span></pre><p id="b8dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们只是用指向行数的函数来获取列表的长度。<strong class="ih hj">PyList _ GetItem</strong>(<em class="jd">object，index </em>)函数获取List的一个元素，就像在Python中你通常会做的<strong class="ih hj"><em class="jd">list【index】</em></strong><em class="jd">。然后我们取1个元素的长度，它指向矩阵中的列数。</em></p><p id="618f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在当我们有了维度和数组本身，我们就可以实现点积逻辑了。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="81b4" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject*</strong> dot_product(<strong class="ld hj">PyObject*</strong> self, <strong class="ld hj">PyObject*</strong> args) {<br/>    //previous code omitted<br/>    <br/>    <strong class="ld hj">PyObject</strong> <strong class="ld hj">*</strong>pyResult = <strong class="ld hj">PyList_New</strong>(mat1_rows);<br/>    <strong class="ld hj">PyObject*</strong> item, <strong class="ld hj">*</strong>mat1_current_row;<br/>    <strong class="ld hj">int</strong> total;</span><span id="e62d" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">    for</strong>(<strong class="ld hj">int</strong> i = 0; i &lt; mat1_rows; i++) {<br/>        item = <strong class="ld hj">PyList_New</strong>(mat2_columns);<br/>        mat1_current_row = <strong class="ld hj">PyList_GetItem</strong>(mat1_current_row, i);</span><span id="3282" class="kc kd hi ld b fi ll li l lj lk">        <strong class="ld hj">for</strong>(<strong class="ld hj">int</strong> j = 0; j &lt; mat2_columns; j++) {<br/>        total = 0;</span><span id="6a29" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">            for</strong> (<strong class="ld hj">int</strong> k = 0; k &lt; mat2_rows; k++) {<br/>            total += \(<strong class="ld hj">int</strong>)<strong class="ld hj">PyLong_AsLong</strong>(<strong class="ld hj">PyList_GetItem</strong>(mat1_current_row, k)) * \<br/>(<strong class="ld hj">int</strong>)<strong class="ld hj">PyLong_AsLong</strong>(<strong class="ld hj">PyList_GetItem</strong>(<strong class="ld hj">PyList_GetItem</strong>(mat2, k), j));<br/>            }<br/>        <strong class="ld hj">PyList_SetItem</strong>(item, j, <strong class="ld hj">PyLong_FromLong</strong>(total));<br/>        }<br/>    <strong class="ld hj">PyList_SetItem</strong>(pyResult, i, item);<br/>    }</span><span id="e91e" class="kc kd hi ld b fi ll li l lj lk">}</span></pre><p id="2fc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与我们已经在Python中实现的逻辑相同。让我们在这里澄清一些时刻:</p><ul class=""><li id="be8d" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated"><strong class="ih hj"> PyList_New </strong>代表自己。我们正在创建长度为mat1_rows的Python列表。</li><li id="189d" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated"><strong class="ih hj"> PyLong_AsLong </strong>正在将python <strong class="ih hj"> long </strong>对象转换成C <strong class="ih hj"> long </strong>对象，这样你就可以在C中对其进行操作，就像这里我们将它添加到C整数<strong class="ih hj"> total </strong>变量中。没有办法把它转换成普通整数，所以我们必须在转换后把它转换成int。</li><li id="e102" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">PyList_SetItem 也代表它自己。类似于Python的<strong class="ih hj"> <em class="jd">列表【索引】=值</em> </strong> <em class="jd">。</em>但这里只是一个函数<strong class="ih hj">PyList _ SetItem</strong>T10【listObject，index，value】。</li><li id="8d2f" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated"><strong class="ih hj"> PyLong_FromLong </strong>与<strong class="ih hj"> PyLong_AsLong </strong>相同，反之亦然。所以我们将C <strong class="ih hj"> long </strong>转换成Python <strong class="ih hj"> long </strong>对象。</li></ul><p id="aa23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这些操作之后，我们完成了点积，并准备将结果返回给Python。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="0ead" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject*</strong> dot_product(<strong class="ld hj">PyObject*</strong> self, <strong class="ld hj">PyObject*</strong> args) {<br/>    //previous code omitted<br/>    <br/>    <strong class="ld hj">return</strong> <strong class="ld hj">Py_BuildValue</strong>("O", pyResult);<br/>}</span></pre><p id="5b05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是如何将Python对象从C语言返回到Python语言。正如你已经猜到的，Py_BuildValue 将从传递给它的值中构建Python对象。第一个参数表示我们想要构建什么类型的对象。在我们的例子中，这仍然是列表对象，所以您传递指向任意对象的<strong class="ih hj"> "O" </strong>模式(例如，对于像<strong class="ih hj"> int这样的原始数据类型，</strong>模式将是“I”)。</p><p id="37eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后要做的是添加以下代码:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="0b2f" class="kc kd hi ld b fi lh li l lj lk">//c_extension.c</span><span id="0c19" class="kc kd hi ld b fi ll li l lj lk">//previous code omitted</span><span id="34d8" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">static</strong> <strong class="ld hj">PyMethodDef</strong> module_methods[] = {<br/>        {"dot_product", (<strong class="ld hj">PyCFunction</strong>) <strong class="ld hj">dot_product</strong>, <strong class="ld hj">METH_VARARGS</strong>, "Calculates dot product of two matrices"}<br/>};<br/><br/><strong class="ld hj">static</strong> <strong class="ld hj">struct</strong> <strong class="ld hj">PyModuleDef</strong> cModPyDem = {<br/>        <strong class="ld hj">PyModuleDef_HEAD_INIT</strong>,<br/>        "c_extension",<br/>        "",<br/>        -1,<br/>        module_methods<br/>};<br/><br/><br/><strong class="ld hj">PyMODINIT_FUNC</strong> PyInit_c_extension(<strong class="ld hj">void</strong>) {<br/>    <strong class="ld hj">return</strong> <strong class="ld hj">PyModule_Create</strong>(&amp;cModPyDem);<br/>}</span></pre><p id="0450" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> module_methods </strong>是方法表，我们在其中定义了可从我们的扩展中调用的所有方法，而<strong class="ih hj"> PyInit_extension_c </strong>是初始化函数，当我们开始构建我们的扩展时，将调用该函数。我不会深入细节，但是你可以查看这个<a class="ae ju" href="https://docs.python.org/2/extending/extending.html#the-module-s-method-table-and-initialization-function" rel="noopener ugc nofollow" target="_blank">官方指南</a>关于如何设置方法表和初始化功能。这里唯一要记住的是<strong class="ih hj"> PyInit_ </strong>应该用您的扩展名继续(在我们的例子中是<strong class="ih hj"> c_extension </strong>)。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="3f47" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">构建Python扩展</h2><p id="cad0" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">现在，当我们完成了C，是时候回到Python了。为了使用我们的<strong class="ih hj"> c_extension.c </strong>文件，我们必须将其构建为Python模块。使用以下代码创建一个<strong class="ih hj"> setup.py </strong>文件:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="ff22" class="kc kd hi ld b fi lh li l lj lk"># setup.py</span><span id="8f12" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">from</strong> setuptools <strong class="ld hj">import</strong> setup, Extension<br/><strong class="ld hj">import</strong> os<br/><br/><br/>os.environ["CC"] = "gcc-9"</span><span id="07a7" class="kc kd hi ld b fi ll li l lj lk">ext = <strong class="ld hj">Extension</strong>(<br/>      'c_extension',<br/>      sources = [<strong class="ld hj">'path/to/your/c_extension.c'</strong>])<br/><br/><strong class="ld hj">setup</strong>(name='c_extension',<br/>       version='1.0',<br/>       description='This is a demo package',<br/>       ext_modules=[ext])</span></pre><p id="731c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有当你想明确地告诉Python你想使用哪个编译器时，才使用<strong class="ih hj"> os.environ["CC"] </strong>。为了方便起见，我使用了<strong class="ih hj"> gcc-9 </strong>，因为我的默认编译器是<strong class="ih hj"> clang </strong>。</p><p id="32eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在构建扩展之前，我建议你在你的项目中创建虚拟环境，如果你还没有的话。如果这样做了，在从您的<strong class="ih hj"> setup.py </strong>文件所在的目录运行以下命令之前激活它:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="87d0" class="kc kd hi ld b fi lh li l lj lk">python setup.py build_ext --inplace</span></pre><p id="0d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="e086" class="kc kd hi ld b fi lh li l lj lk">pip install .</span></pre><p id="e425" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在你的virtualenv中安装<strong class="ih hj"> c_extension </strong>模块。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="863a" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">测试C扩展</h2><p id="1657" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">现在让我们回到<strong class="ih hj"> python_dot_product.py，</strong>导入我们的扩展并创建函数来测试它。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="bc8f" class="kc kd hi ld b fi lh li l lj lk"># python_dot_product.py</span><span id="48c5" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">import</strong> c_extension</span><span id="be86" class="kc kd hi ld b fi ll li l lj lk"><br/><strong class="ld hj">@timer</strong><br/><strong class="ld hj">def</strong> c_implementation(arr1, arr2):<br/>    <strong class="ld hj">return</strong> c_extension.dot_product(arr1, arr2)</span></pre><p id="109c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并运行:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="cf9b" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">if</strong> __name__ == '__main__':<br/>    data = generate(size=500, range_=(1, 100))<br/>    numpy_time_taken, numpy_result = numpy_implementation(*data)<br/>    python_time_taken, python_result = python_implementation(*data)<br/>    c_time_taken, c_result = c_implementation(*data)<br/>    <strong class="ld hj">print</strong>(f"time taken with numpy: {numpy_time_taken} seconds")<br/>    <strong class="ld hj">print</strong>(f"time taken with python: {python_time_taken} seconds")<br/>    <strong class="ld hj">print</strong>(f"time taken with c: {c_time_taken} seconds")</span></pre><p id="93cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="2323" class="kc kd hi ld b fi lh li l lj lk">time taken with numpy: <strong class="ld hj">0.1746230125427246</strong> seconds<br/>time taken with python: <strong class="ld hj">33.78820300102234</strong> seconds<br/>time taken with c: <strong class="ld hj">2.838326930999756</strong> seconds</span></pre><p id="70a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇！看看我们的性能速度有了多么显著的提高。从32-33秒缩短到仅2.8秒！现在你可以看到这种技术有多强大了。仅使用c，性能就提高了近12倍。</p><p id="ecf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们仍然可以做得更好。目前我们的<strong class="ih hj"> c_extension.c </strong>代码还没有优化。这意味着在执行矩阵乘法时，我们还没有进行任何内存优化。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="fcb1" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">存储器安排和存取</h2><p id="58ca" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">为了了解如何优化我们的代码，我们必须了解一些关于内存安排和处理器如何访问它的时刻。</p><p id="cb35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">堆vs栈</strong></p><p id="f945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们谈论内存分配和访问时，我们必须知道数据存储在哪里，处理器访问它的速度有多快。堆栈和堆是运行时程序中数据存在的两个地方。这两者之间唯一的区别是在<strong class="ih hj">栈</strong>上数据被直接访问，而在<strong class="ih hj">堆</strong>上数据被间接访问。但这意味着什么呢？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/69b4897bdab428b46ee1b556e10514ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ac9JB56cVGxPOUZgaOHIFQ.jpeg"/></div></div></figure><p id="7eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你创建一个预定义内存大小的变量，比如<strong class="ih hj"> int、</strong>或<strong class="ih hj"> </strong>分配固定大小的内存<strong class="ih hj">、</strong>在编译阶段，编译器知道在运行之前应该分配多少内存，因此这些数据放在<strong class="ih hj">堆栈</strong>中。当在<strong class="ih hj">堆栈</strong>中时，需要时可以直接访问。但是当你使用像<strong class="ih hj"> malloc </strong>、<strong class="ih hj"> calloc </strong>等内存分配函数时，其中分配的内存大小只在运行时定义，这些数据放在<strong class="ih hj">堆</strong>中，并将通过指针(间接)访问。因此，从<strong class="ih hj">堆</strong>访问数据总是比从<strong class="ih hj">栈</strong>访问数据慢。</p><p id="3dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内存排列</strong></p><p id="c25c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个N维数组在内存中都是有序的。说到内存访问，计算机喜欢把相关的数据放在一起。简单地顺序访问是更快的计算方式，因为每次需要获取特定值时，不会在内存位置之间跳转。按顺序表示二维数组的两种方式是以行为主和以列为主。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mb"><img src="../Images/80fe2e80153a45d0c6e615a1ffe36477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWGkF3_NpZGoBuK322lzrw.png"/></div></div></figure><p id="81da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将我们的阵列从2D转换到1D，内存跳跃将被消除+我们将减少缓存未命中。</p><p id="5eea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们知道从<strong class="ih hj">栈</strong>和<strong class="ih hj">堆</strong>访问数据的区别以及内存安排时，我们就可以开始优化我们的代码了！</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="c39a" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">优化C代码</h2><p id="cbf3" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">既然现在我们知道了从<strong class="ih hj">栈</strong>和<strong class="ih hj">堆</strong> d中访问数据的区别，我们可以在<strong class="ih hj"> c_extension.c </strong>中创建预定义大小的数组。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="476e" class="kc kd hi ld b fi lh li l lj lk">//c_extension.c</span><span id="92b4" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">#define</strong> <strong class="ld hj">MAX_SIZE</strong> 500*500<br/><strong class="ld hj">typedef</strong> <strong class="ld hj">double</strong> BASE_TYPE;<br/><strong class="ld hj">BASE_TYPE</strong> row_major[<strong class="ld hj">MAX_SIZE</strong>];<br/><strong class="ld hj">BASE_TYPE</strong> column_major[<strong class="ld hj">MAX_SIZE</strong>];</span></pre><p id="ab42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以用实际值填充预定义的数组，但在此之前，需要注意一点。</p><p id="4c0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们处理像<strong class="ih hj"> PyList_SetItem </strong>和<strong class="ih hj"> PyList_GetItem </strong>、<strong class="ih hj">T5这样的Python函数时，实际上它们非常慢。因此，在任何实际计算之前，我们最好将所有数据从Python对象转移到C数组中。这将加快这一进程。</strong></p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="8270" class="kc kd hi ld b fi lh li l lj lk">//c_extension.c</span><span id="b026" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj"><br/>BASE_TYPE</strong> **init_result_array(<strong class="ld hj">int</strong> total_rows, <strong class="ld hj">int</strong> total_columns) {<br/>    //creating 2D array for copying Python list object into</span><span id="a9e7" class="kc kd hi ld b fi ll li l lj lk">    <strong class="ld hj">BASE_TYPE</strong> **result_array = (<strong class="ld hj">BASE_TYPE</strong> **)calloc(total_rows, sizeof(<strong class="ld hj">BASE_TYPE</strong> *));<br/>    for(<strong class="ld hj">int</strong> row = 0; row &lt; total_rows; row++) {<br/>        result_array[row] = (<strong class="ld hj">BASE_TYPE</strong> *)calloc(total_columns, sizeof(<strong class="ld hj">BASE_TYPE</strong>));<br/>    }<br/>    <strong class="ld hj">return</strong> result_array;<br/>}</span><span id="3215" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">BASE_TYPE</strong> **convert(<strong class="ld hj">PyObject</strong> *ndimarray, int rows, int columns) {<br/>    //Unwraps Python list into C pointer to 2D array<br/><br/>    <strong class="ld hj">BASE_TYPE</strong> **c_array = init_result_array(rows, columns);<br/>    <strong class="ld hj">PyObject</strong> *current_row;<br/>    for (<strong class="ld hj">int</strong> i = 0; i &lt; rows; ++i) {<br/>        current_row = <strong class="ld hj">PyList_GetItem</strong>(ndimarray, i);<br/>        for (<strong class="ld hj">int</strong> j = 0; j &lt; columns; ++j) {<br/>            c_array[i][j] = (<strong class="ld hj">BASE_TYPE</strong> )<strong class="ld hj">PyLong_AsLong</strong>(<strong class="ld hj">PyList_GetItem</strong>(current_row, j));<br/>        }<br/>    }<br/>    <strong class="ld hj">return</strong> c_array;<br/>}</span></pre><p id="2dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要创建行和列主变换函数。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="b96b" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">void</strong> transform_row_major(<strong class="ld hj">BASE_TYPE</strong> **ndimarray, <strong class="ld hj">int</strong> rows, <strong class="ld hj">int</strong> columns) {<br/>    <strong class="ld hj">for </strong>(<strong class="ld hj">int</strong> i = 0; i &lt; rows; i++) {<br/>        <strong class="ld hj">for</strong> (<strong class="ld hj">int</strong> j = 0; j &lt; columns; j++) {<br/>            row_major[i * columns + j] = ndimarray[i][j];<br/>        }<br/>    }<br/>}<br/><br/><br/><strong class="ld hj">void</strong> transform_column_major(<strong class="ld hj">BASE_TYPE</strong> **ndimarray, <strong class="ld hj">int</strong> rows, <strong class="ld hj">int</strong> columns) {<br/>    <strong class="ld hj">for</strong> (<strong class="ld hj">int</strong> i = 0; i &lt; rows; i++) {<br/>        <strong class="ld hj">for</strong> (<strong class="ld hj">int</strong> j = 0; j &lt; columns; j++) {<br/>            column_major[j * rows + i] = ndimarray[i][j];<br/>        }<br/>    }<br/>}</span></pre><p id="49c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后是将C指针转换回python 2D列表对象的函数。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="97b4" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject</strong>* build_python_array(<strong class="ld hj">BASE_TYPE</strong>** result_array, <strong class="ld hj">int</strong> rows, <strong class="ld hj">int</strong> columns) {<br/>    // Building Python result object from C 2D array pointer<br/><br/>    <strong class="ld hj">PyObject</strong> *item;<br/>    <strong class="ld hj">PyObject</strong> *pyResult = PyList_New(rows);<br/>    <strong class="ld hj">for</strong> (<strong class="ld hj">int</strong> i= 0; i&lt; rows; ++i) {<br/>        item = PyList_New(columns);<br/>        <strong class="ld hj">for</strong> (<strong class="ld hj">int</strong> j= 0; j&lt; columns; ++j) {<br/>            <strong class="ld hj">PyList_SetItem</strong>(item, j, <strong class="ld hj">PyLong_FromLong</strong>(result_array[i][j]));<br/>        }<br/>        <strong class="ld hj">PyList_SetItem</strong>(pyResult, i, item);<br/>    }<br/>    <strong class="ld hj">return</strong> pyResult;<br/>}</span></pre><p id="d626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们实现<strong class="ih hj">点积优化</strong>函数。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="181e" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject</strong>* dot_product_optimized(<strong class="ld hj">PyObject</strong>* self, <strong class="ld hj">PyObject</strong>* args) {<br/>    <strong class="ld hj">PyObject</strong> *mat1;<br/>    <strong class="ld hj">PyObject</strong> *mat2;<br/><br/>    <strong class="ld hj">if</strong> (!<strong class="ld hj">PyArg_ParseTuple</strong>(args, "O|O", &amp;mat1, &amp;mat2)){<br/>        <strong class="ld hj">return</strong> NULL;<br/>    }<br/>    <strong class="ld hj">int</strong> mat1_rows, mat1_columns, mat2_rows, mat2_columns;<br/>    mat1_rows = <strong class="ld hj">PyObject_Length</strong>(mat1);<br/>    mat1_columns = <strong class="ld hj">PyObject_Length</strong>(<strong class="ld hj">PyList_GetItem</strong>(mat1, 0));<br/>    mat2_rows = <strong class="ld hj">PyObject_Length</strong>(mat2);<br/>    mat2_columns = <strong class="ld hj">PyObject_Length</strong>(<strong class="ld hj">PyList_GetItem</strong>(mat2, 0));<br/><br/>    <strong class="ld hj">BASE_TYPE</strong> **mat1_c = convert(mat1, mat1_rows, mat1_columns);<br/>    <strong class="ld hj">BASE_TYPE</strong> **mat2_c = convert(mat2, mat2_rows, mat2_columns);<br/>    transform_row_major(mat1_c, mat1_rows, mat1_columns);<br/>    transform_column_major(mat2_c, mat2_rows, mat2_columns);<br/>    <strong class="ld hj">BASE_TYPE</strong> **result = init_result_array(mat1_rows, mat2_columns);<br/>    <strong class="ld hj">int</strong> tot, iOff, jOff;<br/>    <strong class="ld hj">for </strong>(<strong class="ld hj">int</strong> i=0; i &lt; mat1_rows; i++) {<br/>        iOff = i * mat1_columns;<br/>        <strong class="ld hj">for </strong>(<strong class="ld hj">int</strong> j=0; j &lt; mat2_columns; j++) {<br/>            tot = 0;<br/>            jOff = j * mat2_rows;<br/>            <strong class="ld hj">for </strong>(<strong class="ld hj">int</strong> k=0; k &lt; mat2_rows; k++){<br/>                tot += row_major[iOff + k] * column_major[jOff + k];<br/>        }<br/>        result[i][j] = tot;<br/>    }<br/>        <strong class="ld hj">return</strong> <strong class="ld hj">Py_BuildValue</strong>("O", build_python_array(result, mat1_rows, mat2_columns));<br/>}</span></pre><p id="7e9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并将其添加到方法表中。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="40a7" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">static</strong> <strong class="ld hj">PyMethodDef</strong> module_methods[] = {<br/>        {"dot_product", (<strong class="ld hj">PyCFunction</strong>) dot_product, <strong class="ld hj">METH_VARARGS</strong>, "Calculates dot product of two matrices"},<br/>        {"dot_product_optimized", (<strong class="ld hj">PyCFunction</strong>) dot_product_optimized, <strong class="ld hj">METH_VARARGS</strong>, "Optimized version of dot_product"}<br/>};</span></pre><p id="4ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> python_dot_product.py </strong>中构建扩展并实现新功能。</p><p id="1487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将只留下新的解决方案+ <strong class="ih hj"> NumPy </strong>实现。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="3458" class="kc kd hi ld b fi lh li l lj lk">#python_dot_product.py<br/></span><span id="4505" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">@timer</strong><br/><strong class="ld hj">def</strong> c_optimized_implementation(arr1, arr2):<br/>    <strong class="ld hj">return</strong> c_extension.dot_product_optimized(arr1, arr2)</span><span id="7b19" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">if</strong> __name__ == '__main__':<br/>    data = generate(size=500, range_=(1, 100))<br/>    numpy_time_taken, numpy_result = numpy_implementation(*data)<br/>    c_optimized_time_taken, c_optimized_result = c_optimized_implementation(*data)<br/>    <strong class="ld hj">print</strong>(f"time taken with numpy: {numpy_time_taken} seconds")<br/>    <strong class="ld hj">print</strong>(f"time taken with optimized c: {c_optimized_time_taken} seconds")</span></pre><p id="ea8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="2479" class="kc kd hi ld b fi lh li l lj lk">time taken with numpy: <strong class="ld hj">0.18149495124816895</strong> seconds<br/>time taken with optimized c: <strong class="ld hj">0.42600393295288086</strong> seconds</span></pre><p id="517d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">了解如何通过执行内存优化来显著减少执行时间。从<strong class="ih hj"> 2.8 </strong>秒到<strong class="ih hj"> 0.42 </strong>！它几乎比直接的C实现快7倍。但是我们仍然比数字慢了大约4倍。</p><p id="b522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经走了很远，但我们还没有完成。我们还可以实现一种技术来胜过NumPy。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="7f9b" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">过程并行化</h2><p id="dcb9" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这就是我们要打败NumPy的地方。使用并行处理将允许我们把for循环分成n个部分，每个线程都要计算它的部分。OpenMp 库将为我们做所有的工作。这就是我们需要<strong class="ih hj"> #include "omp.h" </strong>行的地方。为了实现这一点，我们必须稍微修改我们的代码。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="95e9" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">PyObject</strong>* dot_product_optimized_parallel(<strong class="ld hj">PyObject</strong>* self, <strong class="ld hj">PyObject</strong>* args) {<br/>    <strong class="ld hj">PyObject</strong> *mat1;<br/>    <strong class="ld hj">PyObject</strong> *mat2;<br/><br/>    if (!<strong class="ld hj">PyArg_ParseTuple</strong>(args, "O|O", &amp;mat1, &amp;mat2)){<br/>        <strong class="ld hj">return</strong> NULL;<br/>    }<br/>    int mat1_rows, mat1_columns, mat2_rows, mat2_columns;<br/>    mat1_rows = <strong class="ld hj">PyObject_Length</strong>(mat1);<br/>    mat1_columns = <strong class="ld hj">PyObject_Length</strong>(PyList_GetItem(mat1, 0));<br/>    mat2_rows = <strong class="ld hj">PyObject_Length</strong>(mat2);<br/>    mat2_columns = <strong class="ld hj">PyObject_Length</strong>(PyList_GetItem(mat2, 0));<br/>    <strong class="ld hj">BASE_TYPE</strong> **mat1_c = convert(mat1, mat1_rows, mat1_columns);<br/>    <strong class="ld hj">BASE_TYPE</strong> **mat2_c = convert(mat2, mat2_rows, mat2_columns);<br/>    transform_row_major(mat1_c, mat1_rows, mat1_columns);<br/>    transform_column_major(mat2_c, mat2_rows, mat2_columns);<br/>    <strong class="ld hj">BASE_TYPE</strong> **result = init_result_array(mat1_rows, mat2_columns);<br/>    <strong class="ld hj">#pragma omp parallel num_threads(6)</strong><br/>    {<br/>        <strong class="ld hj">int</strong> tot, iOff, jOff;<br/>        <strong class="ld hj">#pragma omp for</strong><br/>        <strong class="ld hj">for</strong>(<strong class="ld hj">int</strong> i=0; i &lt; mat1_rows; i++) {<br/>            iOff = i * mat1_columns;<br/>            <strong class="ld hj">for</strong>(<strong class="ld hj">int</strong> j=0; j &lt; mat2_columns; j++) {<br/>                tot = 0;<br/>                jOff = j * mat2_rows;<br/>                <strong class="ld hj">for</strong>(<strong class="ld hj">int</strong> k=0; k &lt; mat2_rows; k++){<br/>                    tot += row_major[iOff + k] * column_major[jOff + k];<br/>                }<br/>                result[i][j] = tot;<br/>            }<br/>        }<br/>    };<br/>    <strong class="ld hj">return</strong> <strong class="ld hj">Py_BuildValue</strong>("O", build_python_array(result, mat1_rows, mat2_columns));<br/>}</span></pre><p id="fbd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与之前相同，但是现在我们已经定义了<strong class="ih hj"> #pragma omp parallel </strong>作用域，它告诉程序这个部分将被并行化。使用<strong class="ih hj"> num_threads </strong>定义将创建多少个线程。我建议您创建与处理器中内核数量相同的内核。#pragma omp  for让我们的for循环并行运行而不出错，因为如果没有它，你将不得不手动地在线程间分配所有的工作。例如，如果我们的I从0到36，它将这样划分:</p><ul class=""><li id="da60" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">线程数量。1-从0到6的迭代</li><li id="8e3e" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">线程数量。2-从6到12的迭代</li><li id="7d4f" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">线程数量。3-从12到18的迭代</li><li id="de4d" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">线程数量。4-从18到24的迭代</li><li id="114a" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">线程数量。5—迭代次数从24到30</li><li id="340d" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">线程数量。6-从30到36的迭代</li></ul><p id="07de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一切都由<strong class="ih hj"> #pragma omp为</strong>处理。</p><p id="870b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，OpenMp 可以为您提供更多的东西。可以查看一下<a class="ae ju" href="https://computing.llnl.gov/tutorials/openMP/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="357a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让它工作，我们必须修改我们的setup.py文件，告诉编译器我们想要使用OpenMp库。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="c3ac" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">from</strong> setuptools <strong class="ld hj">import</strong> setup, Extension<br/><strong class="ld hj">import</strong> os<br/><br/><br/>os.environ["CC"] = "gcc-9"<br/>ext = <strong class="ld hj">Extension</strong>(<br/>      'c_extension',<br/>      sources = [<strong class="ld hj">'path/to/your/c_extension.c'</strong>],<br/>      extra_compile_args=['-<strong class="ld hj">fopenmp</strong>'],<br/>      extra_link_args=['-<strong class="ld hj">lgomp</strong>'])<br/><br/><strong class="ld hj">setup</strong>(name = 'c_extension',<br/>       version ='1.0',<br/>       description='This is a demo package',<br/>       ext_modules=[ext])</span></pre><p id="44a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要添加<strong class="ih hj"> extra_compile_args </strong>和<strong class="ih hj"> extra_link_args </strong>参数，所以现在编译器会知道你想要使用<strong class="ih hj"> OpenMp </strong>库，所有的<strong class="ih hj"> #pragma </strong>语句都会被考虑进去。这就是我推荐你使用<strong class="ih hj"> gcc </strong>编译器的地方，如果你的默认编译器是<strong class="ih hj"> clang </strong> (Mac用户)。</p><p id="f6c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在构建扩展并实现测试功能。</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="2789" class="kc kd hi ld b fi lh li l lj lk">#python_dot_product.py<br/></span><span id="d2e9" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">@timer</strong><br/><strong class="ld hj">def</strong> c_optimized_parallel_implementation(arr1, arr2):<br/>    <strong class="ld hj">return</strong> c_extension.<strong class="ld hj">dot_product_optimized_parallel</strong>(arr1, arr2)</span></pre><p id="9333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并运行:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="144f" class="kc kd hi ld b fi lh li l lj lk"><strong class="ld hj">if</strong> __name__ == '__main__':<br/>    data = generate(size=500, range_=(1, 100))<br/>    numpy_time_taken, numpy_result = numpy_implementation(*data)<br/>    c_optimized_time_taken, c_optimized_result = c_optimized_implementation(*data)<br/>    c_optimized_parallel_time_taken, _ = c_optimized_parallel_implementation(*data)<br/>    <strong class="ld hj">print</strong>(f"time taken with numpy: {numpy_time_taken} seconds")<br/>    <strong class="ld hj">print</strong>(f"time taken with optimized c: {c_optimized_time_taken} seconds")<br/>    <strong class="ld hj">print</strong>(f"time taken with optimized parallelized c: {c_optimized_parallel_time_taken} seconds")</span></pre><p id="2a5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="36dd" class="kc kd hi ld b fi lh li l lj lk">time taken with numpy: <strong class="ld hj">0.1738600730895996</strong> seconds<br/>time taken with optimized c: <strong class="ld hj">0.4289052486419678</strong> seconds<br/>time taken with optimized parallelized c: <strong class="ld hj">0.06976795196533203</strong> seconds</span></pre><p id="435d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很了不起，是吧？现在我们大约比<strong class="ih hj"> NumPy </strong>快3倍！</p><p id="1b80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，您可以使用这个例子用C扩展您的Python代码来完成任何涉及数值计算的任务。这给了你速度上的优势。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="b0ba" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">可视化性能速度</h2><p id="ac17" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这是不同实现的性能速度的可视化。我将用步骤100在尺寸为<strong class="ih hj"> 100x100 </strong>到<strong class="ih hj"> 1400x1400 </strong>的矩阵上测试它们。使用matplotlib:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="00c1" class="kc kd hi ld b fi lh li l lj lk">#python_dot_product.py</span><span id="1fa3" class="kc kd hi ld b fi ll li l lj lk"><br/><strong class="ld hj">import</strong> matplotlib.pyplot <strong class="ld hj">as</strong> plt</span><span id="8974" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">def</strong> writeStats(stats, f, data, size, implementation):<br/>    time_taken, _ = f(*data)<br/>    stats[implementation].<strong class="ld hj">append</strong>({'size': size, 'time_taken': time_taken})<br/>    <strong class="ld hj">return</strong> stats<br/></span><span id="7a96" class="kc kd hi ld b fi ll li l lj lk"><strong class="ld hj">if</strong> __name__ == '__main__':<br/>    implementations = [f <strong class="ld hj">for</strong> f in <strong class="ld hj">globals</strong>().<strong class="ld hj">keys</strong>() if <strong class="ld hj">callable</strong>(<strong class="ld hj">globals</strong>()[f]) <strong class="ld hj">and</strong> '_' <strong class="ld hj">in</strong> f <strong class="ld hj">and</strong> f != 'python_implementation']<br/>    stats = {k: [] <strong class="ld hj">for</strong> k <strong class="ld hj">in</strong> implementations}<br/><br/>    <strong class="ld hj">for</strong> i <strong class="ld hj">in</strong> <strong class="ld hj">range</strong>(100, 1500, 100):<br/>        data = generate(i, range_=(1, 100))<br/>        <strong class="ld hj">for</strong> implementation in implementations:<br/>            stats = <strong class="ld hj">writeStats</strong>(stats, <strong class="ld hj">globals</strong>()[implementation], data, i, implementation)<br/><br/>    <strong class="ld hj">for</strong> implementation, stats_ in <strong class="ld hj">stats</strong>.<strong class="ld hj">items</strong>():<br/>        plt.<strong class="ld hj">plot</strong>([n['size'] <strong class="ld hj">for</strong> n <strong class="ld hj">in</strong> stats[implementation]], [n['time_taken'] <strong class="ld hj">for</strong> n <strong class="ld hj">in</strong> stats[implementation]], label=implementation)<br/>    plt.<strong class="ld hj">legend</strong>()<br/>    plt.<strong class="ld hj">xlabel</strong>('Matrix size')<br/>    plt.<strong class="ld hj">ylabel</strong>('Time taken')<br/>    plt.<strong class="ld hj">show</strong>()</span></pre><p id="6895" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mc"><img src="../Images/120ea4bec4a1712e1c435c5d07959aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lIHhc2SRI9Kab6-wbQpY-Q.png"/></div></figure><h2 id="fa56" class="kc kd hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">结论</h2><p id="1a28" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">现在你知道如何用c扩展你的Python代码了。事实上，这在很多情况下都会派上用场。点产品示例只是一个演示，展示了它的强大功能。</p></div></div>    
</body>
</html>