<html>
<head>
<title>Inventory Prediction (Intermittent Demands) with KNN &amp; RNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KNN和RNN的库存预测(间歇需求)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/inventory-prediction-intermittent-demands-with-knn-rnn-b14f9388bdbf?source=collection_archive---------7-----------------------#2020-03-20">https://medium.com/analytics-vidhya/inventory-prediction-intermittent-demands-with-knn-rnn-b14f9388bdbf?source=collection_archive---------7-----------------------#2020-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db0f2d559f5d6afaf82097be3d0e270d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mO2o_dGJvDm1uT1RPa22UA.jpeg"/></div></div></figure><p id="8ae0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哇哦！</p><p id="a7ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">机器学习已经进行了6个月，这是我的“第一个”挑战(尝试用我在过去6个月里学到的东西重做我过去的项目)</p><p id="309e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">⭐ <em class="jo">先决条件</em> <br/> <em class="jo"> 1) K近邻<br/> 2)递归神经网络</em></p><p id="38ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">⭐ <em class="jo">这篇文章的目的<br/>详述了我的项目方法。我是来学习的！任何人有任何建议/反馈，请随时在下面评论！</em></p><p id="4dbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们开始吧！💪</p><h1 id="98bc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">目录</h1><p id="9185" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">🐼<a class="ae ks" href="#2ef6" rel="noopener ugc nofollow"> <strong class="is hj">项目概述</strong> </a> <br/>🐼<a class="ae ks" href="#c991" rel="noopener ugc nofollow"> <strong class="is hj">【我的尝试】项目#1 (RNN) </strong> </a> <br/>🐼<a class="ae ks" href="#0232" rel="noopener ugc nofollow"> <strong class="is hj">项目外带</strong> </a></p><h1 id="2ef6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">项目概述</strong></h1><p id="a889" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">曾经有一个项目要求您预测库存销售，而您的团队收到的唯一数据是每个库存项目的每月销售数字？销售甚至是稀疏和断断续续的(即不定期发生)，使得任何种类的预测乍一看似乎是不可能的。</p><p id="7ecd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更清楚地了解我的团队需要处理什么，让我们看一下数据截图(数据被屏蔽以隐藏敏感信息)。由于业务性质(修理工业机械)，销售是断断续续的。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/f3f76328e6c87debb9b3ab29542a9f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dB1os_lPMeSsFEamLVbZ4g.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">图1:数据截图</figcaption></figure><p id="972e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的第一反应是获取更多的数据，否则我们怎么能仅凭上面的数据进行预测呢？不幸的是，对于我的团队来说，这并没有按计划进行，所以我们不得不利用我们所拥有的。</p><p id="fa58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终，结果是<strong class="is hj">不令人满意</strong>。</p><p id="8b02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在了解了各种机器学习模型后，我决定再次尝试这个项目，希望能取得更好的结果。</p><h1 id="c991" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我尝试解决项目#1 (RNN)</h1><p id="801e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">为解决问题而采取的步骤概述:</strong></p><ol class=""><li id="a863" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated"><a class="ae ks" href="#995a" rel="noopener ugc nofollow">探索性数据分析(‘EDA’)</a></li><li id="d2c1" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#da6e" rel="noopener ugc nofollow">数据预处理</a></li><li id="48ab" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#7281" rel="noopener ugc nofollow">用模型进行训练和预测(RNN) </a></li></ol></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h2 id="995a" class="lx jq hi bd jr ly lz ma jv mb mc md jz jb me mf kd jf mg mh kh jj mi mj kl mk bi translated">步骤1)探索性数据分析(“EDA”)</h2><p id="665a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我不会深入探讨为EDA做了什么。为了节省你的时间，让我们直接跳到结果。对于那些不确定EDA是什么的人，这里有一篇关于它的好文章。<a class="ae ks" rel="noopener" href="/code-heroku/introduction-to-exploratory-data-analysis-eda-c0257f888676">点击这里</a></p><p id="f1dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">根据EDA，以下是调查结果:</strong></p><ol class=""><li id="0b31" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">数据集稀疏，超过95%的数据销售时间少于15/33个月；</li><li id="2bfe" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">某些库存项目的销售高度相关，因为工业机械的维修通常需要库存的组合；</li><li id="ad33" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">过去几个月的销售对于预测当月的销售很有用(销售通常基于持续几个月的项目；</li><li id="6452" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">数据集是有限的，每个库存项目仅提供了30+月销售额。总共有400多个独特的库存项目。</li></ol><p id="7df2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于以上发现，以下是我的行动计划:</p><ol class=""><li id="5581" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">仅对销售额≥15/33个月的库存进行预测。对于那些有&lt;15/33 months, I believe that the client should not stock up;</li><li id="5e67" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">Categorize each inventory item using K-nearest neighbors algorithm (‘KNN’);</li><li id="4ff6" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">Use Recurrent Neural Network (‘RNN’) model where the past 3 months sales will be used to predict current months sales;</li><li id="9781" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">Assume that all inventories in a category behaves similarly. We will train the RNN model using all data from all inventories in a category. Prediction of an inventory will be based on the category it belongs to.</li></ol><p id="ba25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">销售的人(以上是我目前能做出的最佳判断，如果有人有更好的方法，请告诉我！)</em></p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h2 id="da6e" class="lx jq hi bd jr ly lz ma jv mb mc md jz jb me mf kd jf mg mh kh jj mi mj kl mk bi translated">步骤2)数据的预处理</h2><p id="56e5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">采取以下步骤对数据进行预处理:</strong></p><ol class=""><li id="13a7" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated"><a class="ae ks" href="#73ce" rel="noopener ugc nofollow">从数据集</a>中过滤出&lt; 15/33月销售额的存货项目</li><li id="b67b" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#d2e1" rel="noopener ugc nofollow">K-最近邻(‘KNN’)对剩余库存项目进行分类</a></li><li id="c817" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#2826" rel="noopener ugc nofollow">将分类数据集分割成训练数据集和测试数据集</a></li><li id="9e62" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#7281" rel="noopener ugc nofollow">将训练数据集和测试数据集拆分为X (3个月前)和y(当月)</a></li><li id="0ed2" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#62ab" rel="noopener ugc nofollow">缩放数据集</a></li></ol><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="5db9" class="lx jq hi mm b fi mq mr l ms mt"># Import libraries<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="fafc" class="lx jq hi mm b fi mu mr l ms mt">import math<br/>from sklearn.metrics import r2_score, mean_squared_error<br/>from sklearn.preprocessing import MinMaxScaler, RobustScaler<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.cluster import KMeans</span><span id="a24e" class="lx jq hi mm b fi mu mr l ms mt">from keras.models import Sequential<br/>from keras.layers import Dense<br/>from keras.layers import LSTM<br/>from keras.layers import Dropout<br/>from keras import optimizers</span></pre><p id="73ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。从数据集</strong>中过滤出&lt; 15/33月销售额的库存项目</p><p id="efde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我运行了下面的代码来获取一个数据集‘inventory _ df ’,它包含销售额≥ 15/33个月的库存。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="4261" class="lx jq hi mm b fi mq mr l ms mt"># Importing the training set<br/>dataset = pd.read_csv("Data_Modified.csv")</span><span id="4ed2" class="lx jq hi mm b fi mu mr l ms mt"># Extract the inventories features<br/>inventory_df = dataset.iloc[:,1:].astype('int')</span><span id="d4de" class="lx jq hi mm b fi mu mr l ms mt"># Filter out inventories that has sales of &lt;15/33 months<br/>number_of_zeroes = (inventory_df == 0).astype(int).sum(axis=0)</span><span id="f8e7" class="lx jq hi mm b fi mu mr l ms mt">insufficient_data_columns = []<br/>for inventory in range (0, inventory_df.shape[1]):<br/>    if inventory_df.shape[0] - number_of_zeroes[inventory] &lt;=17:<br/>        insufficient_data_columns.append(inventory)</span><span id="0644" class="lx jq hi mm b fi mu mr l ms mt">inventory_df = inventory_df.drop(inventory_df.iloc[:, insufficient_data_columns], axis=1)</span></pre><p id="d2e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。k-最近邻(' KNN ')对剩余库存项目进行分类</strong></p><p id="f74a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我继续绘制类内平方和(wcss)与类数的关系图，以找到库存项目的最佳类别数。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="3e94" class="lx jq hi mm b fi mq mr l ms mt">from sklearn.cluster import KMeans</span><span id="a8ac" class="lx jq hi mm b fi mu mr l ms mt"># Using the elbow method to find the optimal number of clusters<br/>inventory_array = inventory_df.T.iloc[:,:].astype('int').values<br/>wcss = []<br/>for i in range(1,15):<br/>    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=300, n_init=10, random_state=0)<br/>    kmeans.fit(inventory_array)<br/>    wcss.append(kmeans.inertia_)<br/>plt.plot(range(1, 15), wcss)<br/>plt.title('The Elbow Method')<br/>plt.xlabel('Number of clusters')<br/>plt.ylabel('WCSS')<br/>plt.show()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/9f908202223f5ddf89ab8f64c4ef6601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*mwcmsHy2mBlyVPvVY9HZwQ.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">图2:肘法</figcaption></figure><p id="f2b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从模型中，我选择聚类为4。如果你想更多地了解KNN，我发现了一篇对我很有用的文章。<a class="ae ks" href="https://towardsdatascience.com/a-simple-introduction-to-k-nearest-neighbors-algorithm-b3519ed98e" rel="noopener" target="_blank">点击这里</a></p><p id="0c13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将k-means应用于数据集，以获得一个列表“inventory_with__categories ”,该列表将每个库存编号与其各自的类别(0–3)相匹配。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="7337" class="lx jq hi mm b fi mq mr l ms mt"># Applying k-means to the dataset<br/>kmeans = KMeans(n_clusters=4, init='k-means++', max_iter=300, n_init=10, random_state=0)<br/>categories = kmeans.fit_predict(X)</span><span id="9aa6" class="lx jq hi mm b fi mu mr l ms mt"># Create a list matching inventory numbers with their category<br/>inventory_with_categories = []<br/>for i in range (len(inventory_df.columns)):<br/>    one_inventory_with_category = [inventory_df.columns[i], categories[i]]<br/>    inventory_with_categories.append(one_inventory_with_category)</span></pre><p id="e926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据类别“inventory_with_categories”拆分原始数据集“inventory_df”。这允许我得到‘complete _ dataset’，一个包含每个类别数据集的列表。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="dc85" class="lx jq hi mm b fi mq mr l ms mt"># Split the dataset by categories<br/>def split_dataset_by_category (inventory_dataset, inventory_categories, number_of_categories=4):<br/>    complete_dataset = []<br/>    for i in range(number_of_categories):<br/>        training_set_cat = pd.DataFrame()<br/>        for inventorynumber, category in inventory_categories:<br/>            if category == i:<br/>                if training_set_cat.empty:<br/>                    training_set_cat = inventory_dataset.loc[:,[inventorynumber]]<br/>                else:<br/>                    training_set_cat = pd.concat([training_set_cat, inventory_dataset.loc[:, [inventorynumber]]], axis=1)<br/>        complete_dataset.append(training_set_cat)<br/>    <br/>    return complete_dataset</span><span id="5119" class="lx jq hi mm b fi mu mr l ms mt">complete_dataset = split_dataset_by_category (inventory_df, inventory_with_categories, number_of_categories=4)</span></pre><p id="3e38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我注意到有些类别包含超过5个库存项目，这对模型的训练来说太少了。</p><p id="cf3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我尝试用不同的变化重做整个过程(例如，改变类别的数量，将≤ 15/33个月改为≤ 10/33个月等。)，希望能在每个品类中获得更多的库存商品。然而，一些类别仍然只有很少的库存项目。</p><p id="65ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，我决定继续这个项目，并使用库存项目数量最多的类别(类别= 0，库存数量= 69)来粗略了解使用RNN是否是一种合理的方法。</p><p id="2826" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。将分类数据集分成训练数据集和测试数据集</strong></p><p id="4c46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将“完整数据集”拆分为“完整训练数据集”和“完整测试数据集”。两者都是包含每个类别的训练数据集和测试数据集的列表。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="40c7" class="lx jq hi mm b fi mq mr l ms mt"># Split into training and test set<br/>def split_train_test(complete_dataset):<br/>    complete_train_dataset = []<br/>    complete_test_dataset = []<br/>    for dataset in complete_dataset:<br/>        dataset_train, dataset_test = train_test_split(dataset, test_size=0.2, shuffle=False, random_state=0)<br/>        complete_train_dataset.append(dataset_train)<br/>        complete_test_dataset.append(dataset_test)<br/>    return complete_train_dataset, complete_test_dataset</span><span id="3623" class="lx jq hi mm b fi mu mr l ms mt">complete_train_dataset, complete_test_dataset = split_train_test(complete_dataset)</span></pre><p id="7281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。将训练数据集和测试数据集分成X(前3个月)和y(当前月)</strong></p><p id="33dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将“complete_train_dataset”和“complete_test_dataset”拆分为X和y。X(过去3个月的销售额)将用于预测y(当月销售额)。这允许我返回‘split _ complete _ train _ dataset’和‘split _ complete _ test _ dataset ’,这两个列表都包含每个类别X和y。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="e2da" class="lx jq hi mm b fi mq mr l ms mt">def split_into_batches(complete_dataset, batch=3):<br/>    split_dataset = []<br/>    for dataset in complete_dataset:<br/>        dataset = dataset.values<br/>        <br/>        X_total = [] # 3 month input for EACH COLUMN<br/>        y_total = [] # 1 month output for EACH COLUMNS<br/>        for inventory in range (0, dataset.shape[1]):<br/>            X = []<br/>            y = []<br/>            for i in range(batch, dataset.shape[0]):<br/>                X.append(dataset[i-batch:i, inventory])<br/>                y.append(dataset[i, inventory])<br/>                <br/>            X, y = np.array(X), np.array(y)<br/>        <br/>            X_total.append(X)<br/>            y_total.append(y)<br/>        <br/>        X_total = np.concatenate(X_total)<br/>        y_total = np.concatenate(y_total)<br/>        <br/>        split_dataset.append([X_total, y_total])<br/>        <br/>    return split_dataset</span><span id="c08b" class="lx jq hi mm b fi mu mr l ms mt">split_complete_train_dataset = split_into_batches(complete_train_dataset, batch=3)<br/>split_complete_test_dataset = split_into_batches(complete_test_dataset, batch=3)</span></pre><p id="62ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。缩放数据集</strong></p><p id="99bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于预处理的最后一步，我使用了<a class="ae ks" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html" rel="noopener ugc nofollow" target="_blank"> sklearn鲁棒定标器</a>。我选择了这个定标器，因为它对“异常值”具有很强的鲁棒性，因为数据稀疏，销售断断续续，销售可以被视为“异常值”。</p><p id="4ab7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缩放后，我得到' scaled _ split _ complete _ train _ dataset '，' scaled _ split _ complete _ test _ dataset '和' complete_y_train_scalers '。“complete_y_train_scalers”是最后预测的逆变换所必需的。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="a194" class="lx jq hi mm b fi mq mr l ms mt"># Scale using RobustScaler<br/>def robust_scaler_reshape(split_complete_train_dataset, split_complete_test_dataset):<br/>    scaled_split_complete_train_dataset = []<br/>    complete_y_train_scalers = []<br/>    <br/>    scaled_split_complete_test_dataset = []<br/>    <br/>    for i in range (len(split_complete_train_dataset)):<br/>        # Scale and reshape X_train<br/>        sc_train_X = RobustScaler(quantile_range=(25.0, 75.0))<br/>        X_train_scaled = sc_train_X.fit_transform(split_complete_train_dataset[i][0])<br/>        X_train_scaled = np.reshape(X_train_scaled, (X_train_scaled.shape[0], X_train_scaled.shape[1], 1))<br/>        <br/>        # Scale and reshape X_test<br/>        X_test_scaled = sc_train_X.transform(split_complete_test_dataset[i][0])<br/>        X_test_scaled = np.reshape(X_test_scaled, (X_test_scaled.shape[0], X_test_scaled.shape[1], 1))<br/>        <br/>        # Scale and reshape y_train<br/>        sc_train_y = RobustScaler(quantile_range=(25.0, 75.0))<br/>        y_train_scaled = sc_train_y.fit_transform(split_complete_train_dataset[i][1].reshape(-1, 1))<br/>        <br/>        # Scale and reshape y_test<br/>        y_test_scaled = sc_train_y.transform(split_complete_test_dataset[i][1].reshape(-1, 1))<br/>        <br/>        scaled_split_complete_train_dataset.append([X_train_scaled, y_train_scaled])<br/>        scaled_split_complete_test_dataset.append([X_test_scaled, y_test_scaled])<br/>        complete_y_train_scalers.append(sc_train_y)<br/>        <br/>    return scaled_split_complete_train_dataset, scaled_split_complete_test_dataset, complete_y_train_scalers    <br/>    <br/>scaled_split_complete_train_dataset, scaled_split_complete_test_dataset, complete_y_train_scalers = robust_scaler_reshape(split_complete_train_dataset, split_complete_test_dataset)</span></pre></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h2 id="15f9" class="lx jq hi bd jr ly lz ma jv mb mc md jz jb me mf kd jf mg mh kh jj mi mj kl mk bi translated">步骤3)用模型(RNN)进行训练和预测</h2><p id="a48c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">由于问题的性质，我选择了RNN(也就是说，本月的销售额可以用上月的销售额来预测)。我还尝试使用其他监督机器学习模型(如XGBoost)来解决这个问题。如果有人想知道进展如何，一定要让我知道，我可以在以后写一篇文章来跟进！😊</p><p id="4999" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">采用以下步骤训练模型并进行预测</strong></p><ol class=""><li id="a00b" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated"><a class="ae ks" href="#fea9" rel="noopener ugc nofollow">训练模型</a></li><li id="fa95" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#d14f" rel="noopener ugc nofollow">利用测试数据预测</a></li><li id="a86e" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><a class="ae ks" href="#9c0f" rel="noopener ugc nofollow">可视化结果</a></li></ol><p id="fea9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。训练模型</strong></p><p id="d281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我分别为每个类别训练RNN模型，并返回“all_models”，这是一个包含每个类别的训练模型的列表。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="eb5a" class="lx jq hi mm b fi mq mr l ms mt">def model_training(scaled_split_complete_train_datase):<br/>    category = 0<br/>    all_models = []<br/>    for training_category in scaled_split_complete_train_datase:<br/>        <br/>        regressor = Sequential()<br/>        # Adding the first LSTM layer and some Dropout regularisation<br/>        regressor.add(LSTM(units = 500, return_sequences = True, input_shape = (training_category[0].shape[1], 1)))<br/>        regressor.add(Dropout(rate = 0.2))<br/>        <br/>        # Adding the second LSTM layer and some Dropout regularisation<br/>        regressor.add(LSTM(units = 100, return_sequences = True))<br/>        regressor.add(Dropout(rate = 0.2))<br/>        <br/>        # Adding the third LSTM layer and some Dropout regularisation<br/>        regressor.add(LSTM(units = 50, return_sequences = True))<br/>        regressor.add(Dropout(rate = 0.2))<br/>        <br/>        # Adding the fourth LSTM layer and some Dropout regularisation<br/>        regressor.add(LSTM(units = 25, return_sequences = False))<br/>        regressor.add(Dropout(rate = 0.2))<br/>        <br/>        # Adding the output layer<br/>        regressor.add(Dense(units = 1))<br/>        <br/>        # Compiling the RNN<br/>        adam = optimizers.Adam(lr=0.001)<br/>        regressor.compile(optimizer = adam, loss = 'mean_squared_error')</span><span id="6f43" class="lx jq hi mm b fi mu mr l ms mt"># Fitting the RNN to the Training set<br/>        history = regressor.fit(training_category[0], training_category[1], epochs = 500, batch_size = 10, use_multiprocessing=True) #Usually 200 epochs<br/>        <br/>        category += 1<br/>        print(f'MSE for category {category}: {str(history.history["loss"])}')<br/>        <br/>        all_models.append(regressor)<br/>        <br/>    return all_models</span><span id="05c4" class="lx jq hi mm b fi mu mr l ms mt">all_models = model_training(scaled_split_complete_train_dataset)</span></pre><p id="d14f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。利用测试数据进行预测</strong></p><p id="fbf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用上面训练的模型，我对测试数据集进行了预测，并返回了“模型_性能”和“所有_预测”。<br/>“模型_性能”包含每个模型的R2和RMSE。<br/>‘all _ predictions’是包含每个预测的数据帧的列表。每个数据帧都有预测数据集和实际数据集。</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="d569" class="lx jq hi mm b fi mq mr l ms mt">def model_predict(all_models, scaled_split_complete_test_dataset, complete_y_train_scalers):<br/>    model_performance = []<br/>    all_predictions = []<br/>    for i in range(len(all_models)):<br/>        predicted_inventory_sale = all_models[i].predict(scaled_split_complete_test_dataset[i][0])<br/>        predicted_inventory_sale = complete_y_train_scalers[i].inverse_transform(predicted_inventory_sale)<br/>        tested_inventory_sale = complete_y_train_scalers[i].inverse_transform(scaled_split_complete_test_dataset[i][1])<br/>        <br/>        # Analysis of model performance<br/>        R_squared = r2_score(tested_inventory_sale, predicted_inventory_sale)<br/>        RMSE = math.sqrt(mean_squared_error(tested_inventory_sale, predicted_inventory_sale))<br/>        model_performance.append([i, R_squared, RMSE])<br/>        <br/>        # Combine predictions into a dataframe<br/>        predictions = np.concatenate([tested_inventory_sale.reshape(-1,1), predicted_inventory_sale.reshape(-1,1)], axis=1)<br/>        predictions = pd.DataFrame(predictions, columns=['total_test', 'total_pred'])  <br/>        all_predictions.append(predictions)<br/>        <br/>    model_performance = pd.DataFrame(model_performance, columns=['category', 'R2', 'RMSE'])  <br/>    <br/>    return model_performance, all_predictions</span><span id="fa71" class="lx jq hi mm b fi mu mr l ms mt">model_performance, all_predictions = model_predict(all_models, scaled_split_complete_test_dataset, complete_y_train_scalers)</span></pre><p id="9c0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。可视化我们的结果！</strong></p><p id="a917" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先来看看我们的模型在测试数据上的表现</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/7fc63dc119f00d13d0facbc642c7397b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*tVJzc5W0B8s0s9px29uksw.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">图3:每个类别的模型性能</figcaption></figure><p id="367d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上表显示了每个类别的模型性能。如上所述，我们将只查看类别0和类别1，类别2和类别3中只有1个库存项目。</p><p id="3c39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从表中可以看出，该模型的R2得分较低，表现不佳。</p><p id="6dad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们为类别0绘制一个简单的图形！</p><pre class="ku kv kw kx fd ml mm mn mo aw mp bi"><span id="8c3a" class="lx jq hi mm b fi mq mr l ms mt"># Visualise predictions for category 0<br/>plt.plot(all_predictions[1].loc[:, 'total_test'].values, color = 'red', label = 'Pred')<br/>plt.plot(all_predictions[1].loc[:, 'total_pred'].values, color = 'blue', label = 'Real')<br/>plt.title('Inventory Sale Prediction')<br/>plt.xlabel('Time')<br/>plt.ylabel('Inventory Sale')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/c1d1e62fe5d4d1f06f76be0853eb74fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*tf9fIjxQVba1-IQ5HRbUJQ.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">图4:类别0的预测与实际(库存销售)的图表</figcaption></figure><p id="deab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从图表来看，这个模型似乎预测得很好。低R2分数很可能来自于尖峰信号。用RNN模型的其他参数重新训练该模型很可能会产生更好的结果。</p><h1 id="0232" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">外卖食品</h1><p id="13d6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">唷！终于搞定了。这个项目总共花了我2天时间，以下是我的主要收获:</p><ol class=""><li id="ded6" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">RNN模型肯定可以用来预测这样的数据集。我相信如果库存分类能够和客户一起完成，模型的性能会更好。此外，更多的数据(例如，更多的月销售额)肯定会产生更好的模型。</li></ol><p id="dccb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">机器学习领域我还是新手。如果您对如何改进该方法有任何建议/反馈，请在下面留下您的评论！🙇</p></div></div>    
</body>
</html>