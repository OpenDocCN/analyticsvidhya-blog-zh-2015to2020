<html>
<head>
<title>Signature Recognition Using OpenCV -Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OpenCV 进行签名识别-第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/signature-recognition-using-opencv-part-2-62685586d566?source=collection_archive---------5-----------------------#2020-12-08">https://medium.com/analytics-vidhya/signature-recognition-using-opencv-part-2-62685586d566?source=collection_archive---------5-----------------------#2020-12-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ba69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的前一篇文章中，我们尝试使用 contour 从 pdf 中检测签名区域，并绘制一个矩形覆盖签名区域。你可以在<a class="ae jd" href="https://ramji-b.medium.com/signature-recognition-using-opencv-2c99d878c66d" rel="noopener">第一部</a>中读到。</p><p id="0d75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在第 1 部分中所述，我们将涵盖形态学变换以从裁剪后的签名中移除额外的空格，以及结构相似性指数以比较原始签名图像和已识别签名图像之间的相似性。</p><h1 id="9536" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">从 PDF 中裁剪签名区域</h1><p id="d811" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了裁剪图像，我们需要从第 1 部分收集矩形左上角的坐标、宽度和高度。</p><div class="kh ki kj kk fd ab cb"><figure class="kl km kn ko kp kq kr paragraph-image"><img src="../Images/1316192e8c84f6f4bf4c1a3365b189d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*JoeGQChwieWX11da43NsBg.png"/></figure><figure class="kl km ku ko kp kq kr paragraph-image"><img src="../Images/e9793913230b08b1f5e59368c5c6b18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*ZFvKyHq0DJLWAMha9_Pc-g.png"/><figcaption class="kv kw et er es kx ky bd b be z dx kz di la lb translated">原始图像和裁剪区域</figcaption></figure></div></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="38bd" class="je jf hi bd jg jh lj jj jk jl lk jn jo jp ll jr js jt lm jv jw jx ln jz ka kb bi translated">形态转换</h1><p id="b792" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">形态学变换是基于图像的操作，被执行来从图像中移除额外的空白，或者连接破碎的图像或者加厚图像中的字符等。换句话说，我们可以说执行形态学操作是为了从图像中去除噪声。基本上它包括侵蚀、扩张、打开和关闭。这里是阅读这个概念的链接。</p><p id="e060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://docs.opencv.org/master/d9/d61/tutorial_py_morphological_ops.html" rel="noopener ugc nofollow" target="_blank">https://docs . opencv . org/master/d9/d61/tutorial _ py _ morphology _ ops . html</a></p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="6449" class="lt jf hi lp b fi lu lv l lw lx">def remove_white_space(image):<br/> gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br/> blur = cv2.GaussianBlur(gray, (25,25), 0)<br/> thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]</span><span id="f951" class="lt jf hi lp b fi ly lv l lw lx">noise_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))<br/> opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, noise_kernel, iterations=2)<br/> close_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7,7))<br/> close = cv2.morphologyEx(opening, cv2.MORPH_CLOSE, close_kernel, iterations=3)</span><span id="eddf" class="lt jf hi lp b fi ly lv l lw lx"># Find enclosing boundingbox and crop ROI\n”,<br/> coords = cv2.findNonZero(close)<br/> x,y,w,h = cv2.boundingRect(coords)</span><span id="07a3" class="lt jf hi lp b fi ly lv l lw lx">return image[y:y+h, x:x+w</span></pre><div class="kh ki kj kk fd ab cb"><figure class="kl km lz ko kp kq kr paragraph-image"><img src="../Images/e9793913230b08b1f5e59368c5c6b18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*ZFvKyHq0DJLWAMha9_Pc-g.png"/></figure><figure class="kl km lz ko kp kq kr paragraph-image"><img src="../Images/e9793913230b08b1f5e59368c5c6b18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*ZFvKyHq0DJLWAMha9_Pc-g.png"/></figure></div><div class="ab cb"><figure class="kl km ma ko kp kq kr paragraph-image"><img src="../Images/f594abaa2a56bd783ec999327de3f457.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*xfG6-yp6y-OL4FdyWIBDbg.png"/></figure><figure class="kl km mb ko kp kq kr paragraph-image"><img src="../Images/947a51465f6959dae96b13a4e51cb76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*4N9VSIwlZnGsYdJ-SttDfA.png"/><figcaption class="kv kw et er es kx ky bd b be z dx mc di md lb translated">左侧:原始图像右侧:执行形态变换后</figcaption></figure></div></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="ef70" class="je jf hi bd jg jh lj jj jk jl lk jn jo jp ll jr js jt lm jv jw jx ln jz ka kb bi translated">结构相似指数(SSIM)</h1><p id="fcd8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">SSIM 是一种用于测量两幅图像之间相似性的方法。该方法由王等人提出，用于预测数字电视和电影图像的质量。</p><p id="c9ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数学公式:</p><figure class="kh ki kj kk fd km er es paragraph-image"><div class="er es me"><img src="../Images/cd01e8b7504b881235e08d205bf91858.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*0FKvFCYdhOJF0spGeYVgXg.png"/></div></figure><p id="71f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式的参数包括每个图像中的<em class="mf"> N x N </em>窗口的<em class="mf"> (x，y) </em>位置、在<em class="mf"> x </em>和<em class="mf"> y </em>方向上的像素强度的平均值、<em class="mf"> x </em>和<em class="mf"> y </em>方向上的强度方差以及协方差。</p><p id="4564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了使用 ssim 比较图像，我们需要传递两个相同大小的灰度图像。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="87bf" class="lt jf hi lp b fi lu lv l lw lx">from skimage.measure import compare_ssim as ssim</span><span id="d655" class="lt jf hi lp b fi ly lv l lw lx">i = cv2.cvtColor(cv2.imread('sample_2.png'),cv2.COLOR_BGR2RGB)</span><span id="1574" class="lt jf hi lp b fi ly lv l lw lx">wrong_image = cv2.resize(cv2.cvtColor(i.copy(),cv2.COLOR_BGR2GRAY),(100,100))<br/>original_image = cv2.resize(cv2.cvtColor(cropped_image.copy(),cv2.COLOR_BGR2GRAY),(100,100))</span><span id="be9a" class="lt jf hi lp b fi ly lv l lw lx">print(ssim(original_image,original_image))<br/>print(ssim(original_image,wrong_image))</span></pre><blockquote class="mg mh mi"><p id="38ba" class="if ig mf ih b ii ij ik il im in io ip mj ir is it mk iv iw ix ml iz ja jb jc hb bi translated">SSIM 得分:“1.0”和“0.50”</p></blockquote><p id="cb7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这两篇文章可能已经给出了关于如何使用 OpenCV 及其相关概念的基本概念。继续学习！！！</p></div></div>    
</body>
</html>