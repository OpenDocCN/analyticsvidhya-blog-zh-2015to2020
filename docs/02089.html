<html>
<head>
<title>Control Statement and Loops In R — 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R — 4中的控制语句和循环</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/control-statement-and-loops-in-r-4-3663b782b064?source=collection_archive---------9-----------------------#2019-11-29">https://medium.com/analytics-vidhya/control-statement-and-loops-in-r-4-3663b782b064?source=collection_archive---------9-----------------------#2019-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="38b4" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">如果您还没有阅读R基础系列的第3部分，请阅读下面的文章，在这篇文章中我们讨论了在R —  2中编写函数。本系列涵盖了R的基础知识，包括数据类型、控制结构、循环、函数和高级数据结构。</p><p id="1521" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">如果您已经熟悉这些主题，并且正在使用r寻找统计和机器学习中所有重要主题的全面介绍，请从以下系列开始，其中讨论了与数据科学相关的所有必要主题。</p><p id="5f5a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><a class="ae jh" rel="noopener" href="/@viveksrinivasan/many-ways-of-reading-data-into-r-1-52b02825cb27">将数据读入R — 1的多种方式</a></p><p id="9a23" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这篇文章的内容是我在IIM-B时代得到介绍的几本书的要点。</p><p id="2aa9" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">人人为我——贾里德·p·兰德</p><p id="67ea" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">实用数据科学与R — Nina Zumel和John Mount</p><p id="03a0" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">文中讨论的所有代码块都以R markdown的形式出现在<a class="ae jh" href="https://github.com/viveksrinivasanss/Data_Science_Using_R" rel="noopener ugc nofollow" target="_blank"> Github链接</a>中。</p><p id="e0ef" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">请使用链接<a class="ae jh" rel="noopener" href="/@viveksrinivasan"> Vivek Srinivasan </a>查看我写的所有文章。</p></blockquote><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/beb1b736d5da07c2dfbcae3dfc83e8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84yRt7CJJhe309HwWG5YNw.png"/></div></div></figure><p id="dd85" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi jx translated">控制语句允许我们控制编程的流程，并根据测试的值导致不同的事情发生。测试产生一个逻辑、<code class="du kg kh ki kj b">TRUE </code>或<code class="du kg kh ki kj b">FALSE</code>，用于if类语句。主要控制语句有<code class="du kg kh ki kj b">if</code>、<code class="du kg kh ki kj b">else</code>、<code class="du kg kh ki kj b">ifelse </code>和开关。</p><h2 id="96ad" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">如果和否则</h2><p id="d908" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">最常见的测试是if命令。它本质上是说。如果某事是<code class="du kg kh ki kj b">TRUE</code>，则执行某个动作；否则，不要执行该操作。我们测试的东西放在<code class="du kg kh ki kj b">if</code>命令后面的括号里。</p><p id="8a82" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">最基本的检查有:等于<code class="du kg kh ki kj b">(==)</code>，小于<code class="du kg kh ki kj b">(&lt;)</code>，大于等于<code class="du kg kh ki kj b">(&gt;=)</code>，不等于<code class="du kg kh ki kj b">(!=)</code>。如果这些测试通过，则导致<code class="du kg kh ki kj b">TRUE</code>，如果测试失败，则导致<code class="du kg kh ki kj b">FALSE</code>。如前所述，<code class="du kg kh ki kj b">TRUE </code>在数字上等同于<code class="du kg kh ki kj b">1</code>,<code class="du kg kh ki kj b">FALSE </code>等同于<code class="du kg kh ki kj b">0</code>。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="1be7" class="kk kl hi kj b fi lo lp l lq lr"># set up a variable to hold 1<br/>toCheck &lt;- 1</span><span id="a32c" class="kk kl hi kj b fi ls lp l lq lr"># if toCheck is equal to 1, print hello<br/>if(toCheck == 1)<br/>{<br/>  print("hello")<br/>}</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lt"><img src="../Images/81274dd84f8f99f90802ff6458a3cc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVOJEU3KIt640ycNXGd_8A.png"/></div></div></figure><p id="619e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">注意<code class="du kg kh ki kj b">if</code>语句类似于函数，因为所有的语句(可以是一个或多个)都在花括号内。</p><p id="4bff" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">生活并不总是如此简单，以至于只有在某些关系是<code class="du kg kh ki kj b">TRUE</code>的情况下，我们才想要行动。如果那种关系是<code class="du kg kh ki kj b">FALSE</code>，我们通常想要不同的行动。在下面的例子中，我们将一个<code class="du kg kh ki kj b">if</code>语句后跟一个<code class="du kg kh ki kj b">else </code>语句放在一个函数中，这样就可以重复使用。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="3f1d" class="kk kl hi kj b fi lo lp l lq lr"># first create the function<br/>check.bool &lt;- function(x)<br/>{<br/>  if(x == 1)<br/>  {<br/>    # if the input is equal to 1, print hello<br/>    print("hello")<br/>  }else<br/>  {<br/>    # otherwise print goodbye<br/>    print("goodbye")<br/>  }<br/>}</span><span id="d4c8" class="kk kl hi kj b fi ls lp l lq lr">check.bool(0)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lu"><img src="../Images/c534a6c39505c24c6b2f1f0301774b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Thl3SiY8Ev9o5Sec7-Na6w.png"/></div></div></figure><p id="d624" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">除了<code class="du kg kh ki kj b">1</code>之外的任何东西都会导致该函数打印“再见”这正是我们想要的。通过<code class="du kg kh ki kj b">TRUE </code>会打印“hello”，因为<code class="du kg kh ki kj b">TRUE </code>在数字上与<code class="du kg kh ki kj b">1</code>相同。也许我们想连续测试几个案例。这就是我们可以使用<code class="du kg kh ki kj b">else if</code>的地方。我们首先测试一个语句，然后进行另一个测试，然后可能会陷入无所不包的境地。我们将修改<code class="du kg kh ki kj b">check.bool</code>来测试一个条件，然后测试另一个条件。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="11b8" class="kk kl hi kj b fi lo lp l lq lr">check.bool &lt;- function(x)<br/>{<br/>  if(x == 1)<br/>  {<br/>    # if the input is equal to 1, print hello<br/>    print("hello")<br/>  }else if(x == 0)<br/>  {<br/>    # if the input is equal to 0, print goodbye<br/>    print("goodbye")<br/>  }else<br/>  {<br/>    # otherwise print confused<br/>    print("confused")<br/>  }<br/>}</span><span id="9c6e" class="kk kl hi kj b fi ls lp l lq lr">check.bool(2)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lv"><img src="../Images/5bbfee9c9859b54ae18048c236b45119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBN82SP-wDVi-jvXqAfSYg.png"/></div></div></figure><h2 id="0258" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">Switch语句</h2><p id="70d7" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">如果我们有多个案例要检查，重复编写<code class="du kg kh ki kj b">else if </code>可能会很麻烦且效率低下。这就是<code class="du kg kh ki kj b">switch </code>最有用的地方。第一个参数是我们正在测试的值。后续的参数是一个特定的值，应该是什么结果。最后一个参数，如果没有给定值，就是默认结果。为了说明这一点，我们构建了一个接受一个值并返回相应结果的函数。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="2e9f" class="kk kl hi kj b fi lo lp l lq lr">use.switch &lt;- function(x)<br/>{<br/>  switch(x,<br/>         "a"="first",<br/>         "b"="second",<br/>         "z"="last",<br/>         "c"="third",<br/>         "other")<br/>}</span><span id="d52f" class="kk kl hi kj b fi ls lp l lq lr">use.switch("a")</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lw"><img src="../Images/1a3704c679a4d525d561d9b996a91a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJO3jT5gP5YOOlV_xE161A.png"/></div></div></figure><p id="1a28" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">如果第一个参数是数字，则它在位置上与后面的参数匹配，不管后面的参数的名称是什么。如果数值参数大于后续参数的数量，则返回<code class="du kg kh ki kj b">NULL </code>。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="11c9" class="kk kl hi kj b fi lo lp l lq lr"># nothing is returned<br/>is.null(use.switch(6))</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lx"><img src="../Images/d582f1e624f8183c2ca84b63b5da97c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5jlAae-8fGNa7CLPhxG3A.png"/></div></div></figure><h2 id="8a13" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">ifelse</h2><p id="b831" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">而<code class="du kg kh ki kj b">if</code>就像传统语言中的if语句<code class="du kg kh ki kj b">ifelse</code>更像Excel中的<code class="du kg kh ki kj b">if</code>函数。第一个参数是要测试的条件(很像传统的if语句)，第二个参数是测试为<code class="du kg kh ki kj b">TRUE </code>时的返回值，第三个参数是测试为<code class="du kg kh ki kj b">FALSE</code>时的返回值。与传统的if不同，这里的妙处在于它可以处理矢量化的参数。</p><p id="4c85" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">正如R中经常出现的情况，使用矢量化可以避免<code class="du kg kh ki kj b">for </code>循环，并加快我们的代码。<code class="du kg kh ki kj b">ifelse </code>的细微差别可能很棘手，所以我们展示了许多例子。我们从一个非常简单的例子开始，测试1是否等于1，如果是<code class="du kg kh ki kj b">TRUE</code>，则打印<code class="du kg kh ki kj b">“Yes”</code>，如果是<code class="du kg kh ki kj b">FALSE</code>，则打印<code class="du kg kh ki kj b">“No”</code>。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="7ebb" class="kk kl hi kj b fi lo lp l lq lr"># see if 1 == 1<br/>ifelse(1 == 1, "Yes", "No")</span><span id="0dae" class="kk kl hi kj b fi ls lp l lq lr"># see if 1 == 0<br/>ifelse(1 == 0, "Yes", "No")</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lu"><img src="../Images/f6012845802394dafe0ff32c61b86e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NU59pTW3ErXvIoBoJeY4A.png"/></div></div></figure><p id="2666" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">这显然给了我们想要的结果。<code class="du kg kh ki kj b">ifelse </code>使用之前见过的所有常规等式测试和任何其他逻辑测试。然而，值得注意的是，如果只测试单个元素(长度为1的向量或简单的is.na)，使用<code class="du kg kh ki kj b">if </code>比<code class="du kg kh ki kj b">ifelse</code>更有效。这可能会导致我们代码的加速。接下来，我们将说明矢量化的第一个参数。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="59c3" class="kk kl hi kj b fi lo lp l lq lr">toTest &lt;- c(1, 1, 0, 1, 0, 1)<br/>ifelse(toTest == 1, "Yes", "No")</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ly"><img src="../Images/87028a61f505a5c850467afaacf94960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzNBxAjxEijAIPfJTHNCDw.png"/></div></div></figure><p id="6678" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">现在假设toTest有<code class="du kg kh ki kj b">NA</code>元素。在这种情况下，来自<code class="du kg kh ki kj b">ifelse </code>的相应结果是<code class="du kg kh ki kj b">NA</code>。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="b477" class="kk kl hi kj b fi lo lp l lq lr">toTest &lt;- c(1, 1, 0, 1, 0, 1)<br/>ifelse(toTest == 1, toTest*3, toTest)</span><span id="4545" class="kk kl hi kj b fi ls lp l lq lr">## vectors with NA values<br/>toTest &lt;- c(1, NA, 0, 1, 0, 1)<br/>ifelse(toTest == 1, toTest*3, toTest)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lz"><img src="../Images/ae3ea41965bdc6f9aae7deb1a4692656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BB57ya1fdZVAWJLMxIoWPQ.png"/></div></div></figure><h2 id="037e" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">复合测试</h2><p id="83b1" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">用<code class="du kg kh ki kj b">if</code>、<code class="du kg kh ki kj b">ifelse </code>和<code class="du kg kh ki kj b">switch </code>测试的语句可以是导致逻辑<code class="du kg kh ki kj b">TRUE </code>或<code class="du kg kh ki kj b">FALSE</code>的任何参数。这可以是相等性检查，甚至是<code class="du kg kh ki kj b">is.numeric</code>或<code class="du kg kh ki kj b">is.na</code>的结果。有时我们想一次测试多种关系。这是使用逻辑运算符<code class="du kg kh ki kj b">and</code>和<code class="du kg kh ki kj b">or</code>完成的。这些是用于<code class="du kg kh ki kj b">and </code>的<code class="du kg kh ki kj b">&amp;</code>和<code class="du kg kh ki kj b">&amp;&amp;</code>以及用于<code class="du kg kh ki kj b">or</code>的<code class="du kg kh ki kj b">|</code>和<code class="du kg kh ki kj b">||</code>。</p><p id="64d0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">这些差别很细微，但会影响我们代码的速度。<code class="du kg kh ki kj b">if </code>最好用双面<code class="du kg kh ki kj b">(&amp;&amp; or ||) </code>，而<code class="du kg kh ki kj b">ifelse</code>需要单面<code class="du kg kh ki kj b">(&amp; or |)</code>。double表单只比较每边的一个元素，而single表单比较每边的每个元素。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="50af" class="kk kl hi kj b fi lo lp l lq lr">a  &lt;- c(1, 1, 0, 1)<br/>b  &lt;- c(1, 0, 0, 1)</span><span id="14da" class="kk kl hi kj b fi ls lp l lq lr"># this checks each element of a and each element of b<br/>ifelse(a == 1 &amp; b == 1, "Yes", "No")</span><span id="0e60" class="kk kl hi kj b fi ls lp l lq lr"># this only checks the first element of a and the first element of b<br/># it only returns one result<br/>ifelse(a == 1 &amp;&amp; b == 1, "Yes", "No")</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ma"><img src="../Images/79b491ed6180dcf30412cf45cd91bb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ca_EVqz6mbZyHQbOEaQOkQ.png"/></div></div></figure><p id="ea8f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">double </code>和<code class="du kg kh ki kj b">single </code>表单的另一个区别是它们的处理方式。当使用单个表单时，总是检查操作符的两侧。使用<code class="du kg kh ki kj b">double </code>表单，有时只需要检查左侧。例如，如果测试<code class="du kg kh ki kj b">1 == 0 &amp;&amp; 2 == 2</code>，左侧失败，那么没有理由检查右侧。同样，测试<code class="du kg kh ki kj b">3 == 3 || 0 == 0</code>时，左侧通过，所以无需检查右侧。如果左侧失败，右侧会抛出一个错误，这可能特别有帮助。</p><p id="5ebc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">可以测试不止两个条件。许多条件可以使用多个<code class="du kg kh ki kj b">and </code>或<code class="du kg kh ki kj b">or </code>操作符串在一起。就像数学运算一样，不同的子句可以用括号分组。没有括号，运算顺序类似于<code class="du kg kh ki kj b">PEMDAS</code>，其中<code class="du kg kh ki kj b">and </code>相当于乘法，<code class="du kg kh ki kj b">or </code>相当于加法，所以<code class="du kg kh ki kj b">and </code>优先于<code class="du kg kh ki kj b">or</code>。</p><h2 id="0d3c" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">循环，迭代的非R方式</h2><p id="2870" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">当开始使用<code class="du kg kh ki kj b">R</code>时，大多数人在需要迭代<code class="du kg kh ki kj b">vector</code>、<code class="du kg kh ki kj b">list </code>或<code class="du kg kh ki kj b">data.frame</code>的元素时都会使用循环。虽然在其他语言中这样做很自然，但对于R，我们通常希望使用<code class="du kg kh ki kj b">vectorization</code>。也就是说，有时循环是不可避免的，所以R同时提供了<code class="du kg kh ki kj b">for </code>和<code class="du kg kh ki kj b">while </code>循环。</p><h2 id="91a0" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">对于循环</h2><p id="cb2a" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">最常用的循环是<code class="du kg kh ki kj b">for </code>循环。它遍历一个<code class="du kg kh ki kj b">index </code>——作为一个<code class="du kg kh ki kj b">vector </code>提供——并执行一些操作。使用<code class="du kg kh ki kj b">for</code>声明该循环，它将一个貌似英语的参数分成三部分。</p><p id="5d13" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">第三部分是任何类型的任何<code class="du kg kh ki kj b">vector </code>值，最常见的是<code class="du kg kh ki kj b">numeric </code>或<code class="du kg kh ki kj b">character</code>。第一部分是从第三部分的向量中迭代赋值的变量。中间部分简单的就是单词<code class="du kg kh ki kj b">in </code>表示变量(第一部分)在向量中(第三部分)。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="16f8" class="kk kl hi kj b fi lo lp l lq lr"># build a vector holding fruit names<br/>fruit  &lt;- c("apple", "banana", "pomegranate")</span><span id="9620" class="kk kl hi kj b fi ls lp l lq lr">for(a in fruit)<br/>{<br/>  print(sprintf("Length of %s is %s",a,as.character(nchar(a))))<br/>}</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mb"><img src="../Images/57ee402a30b8d5981f83594d876e84c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pL3r3me4iF-v0dYZ2ey6sg.png"/></div></div></figure><p id="0ac1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">同样，R的内置矢量化功能可以让这一切变得更加容易。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="c391" class="kk kl hi kj b fi lo lp l lq lr">nachar(fruit)</span></pre><h2 id="8ac8" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">while循环</h2><p id="63fd" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">虽然在<code class="du kg kh ki kj b">R</code>中使用的频率远不如<code class="du kg kh ki kj b">for </code>循环，但是<code class="du kg kh ki kj b">while </code>循环实现起来也一样简单。只要测试的条件证明为真，它就重复运行括号内的代码。在下面的例子中，我们打印x的值，并迭代它，直到它达到5。这是一个非常简单的例子，但是仍然展示了它的功能。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="0a4b" class="kk kl hi kj b fi lo lp l lq lr">x  &lt;- 1<br/>while(x &lt;= 5)<br/>{<br/>  print(x)<br/>  x &lt;- x + 1<br/>}</span></pre><h2 id="74a8" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">控制回路</h2><p id="2a6a" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">有时我们不得不跳到循环的<code class="du kg kh ki kj b">next </code>迭代，或者完全<code class="du kg kh ki kj b">break </code>退出。这是通过<code class="du kg kh ki kj b">next </code>和<code class="du kg kh ki kj b">break</code>完成的。我们用一个<code class="du kg kh ki kj b">for </code>循环来演示。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="4aee" class="kk kl hi kj b fi lo lp l lq lr">## Example for skipping an iteration<br/>for(i in 1:10)<br/>{<br/>  if(i == 3)<br/>  {<br/>    next<br/>  }<br/>  print(i)<br/>}</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mc"><img src="../Images/cd51d4a74918fc4d1d4cf2baaede5186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py3A7T2Uvq1c3kjhPqB07Q.png"/></div></div></figure><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="1990" class="kk kl hi kj b fi lo lp l lq lr">## Example for breaking the loop<br/>for(i in 1:10)<br/>{<br/>  if(i == 3)<br/>  {<br/>    break<br/>  }<br/>  print(i)<br/>}</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es md"><img src="../Images/068a739380229a204a9b587912e93b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2a2-hSJbHu2xzXbxRe6IBw.png"/></div></div></figure><p id="c1a4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">在这里，即使我们告诉<code class="du kg kh ki kj b">R</code>迭代前十个整数，它在2之后停止，因为我们在3处中断了循环。</p><p id="d6f3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">两个主要的循环是<code class="du kg kh ki kj b">for</code>，它遍历一个固定的元素序列，以及<code class="du kg kh ki kj b">while </code>，只要某个条件成立，它就继续循环。如前所述，如果解决方案可以通过<code class="du kg kh ki kj b">vectorization </code>或<code class="du kg kh ki kj b">matrix algebra</code>在没有循环的情况下完成，则避免循环。避免嵌套循环尤为重要。在<code class="du kg kh ki kj b">R</code>中，其他循环内部的循环速度极慢。</p><p id="a3d8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">所以我们已经全面地介绍了R编程的基础知识。如果您有兴趣学习R中的一些高级编程和机器学习，请从下面给出的链接中的高级R系列开始。</p><blockquote class="if ig ih"><p id="b77f" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><a class="ae jh" rel="noopener" href="/@viveksrinivasan/many-ways-of-reading-data-into-r-1-52b02825cb27">将数据读入R — 1的多种方式</a></p><p id="5725" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">一定要通过评论和分享文章来分享你的想法和支持。</p></blockquote></div></div>    
</body>
</html>