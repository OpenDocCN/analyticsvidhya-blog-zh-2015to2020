<html>
<head>
<title>How to use RabbitMQ with python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何配合 python 使用 RabbitMQ？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-use-rabbitmq-with-python-e0ccfe7fa959?source=collection_archive---------1-----------------------#2020-10-20">https://medium.com/analytics-vidhya/how-to-use-rabbitmq-with-python-e0ccfe7fa959?source=collection_archive---------1-----------------------#2020-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="593f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客的目的是通过使用 RabbitMQ 作为测试用例来制作一个快速的“hello world”式的应用程序。RabbitMQ 是一个开源、轻量级、易于云部署且高度可扩展的消息传递代理。它被 Reddit、Stack、Trivago 等科技公司使用。这个博客是在你自己的基于 python 的项目中安装和使用 rabbitMQ 的快速入门指南。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="9ab7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">装置</h1><h2 id="fa0e" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated">设置 rabbitmq 服务器</h2><p id="2fee" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">要访问 python 中的 RabbitMQ 或我们称之为“<strong class="ih hj">rabbit MQ 的纯 Python AMQP 0–9–1 客户端</strong>”，有一个名为 pika 的包(库)，可以使用 pip 安装。但是首先我们需要安装“rabbitmq-server ”,它将作为后端系统程序运行。<br/> *安装 erlang <br/> *安装 rabbitmq-server <br/> *启用 rabbitmq-server 作为系统程序<br/> *后端启动 rabbitmq-server<br/>*启用 rabbit MQ 管理插件</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a0d2" class="ki jl hi lg b fi lk ll l lm ln">sudo apt-get update &amp;&amp; sudo apt-get upgrade<br/>sudo apt-get install erlang<br/>sudo apt-get install rabbitmq-server<br/>sudo systemctl enable rabbitmq-server<br/>sudo systemctl start rabbitmq-server<br/>sudo rabbitmq-plugins enable rabbitmq_management</span></pre><ul class=""><li id="a043" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">创建用户名和密码以登录 rabbitmq 管理</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="247d" class="ki jl hi lg b fi lk ll l lm ln">##user is the username and password is the new password<br/>sudo rabbitmqctl add_user user password<br/>##giving that user adiministraitve rights<br/>sudo rabbitmqctl set_user_tags user administrator</span></pre><ul class=""><li id="a003" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">授予管理员权限</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2445" class="ki jl hi lg b fi lk ll l lm ln">sudo rabbitmqctl set_permissions -p / user "." "." "."</span></pre><p id="49ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将启动 rabbitmq 服务器。现在，您可以使用 python 中名为 pika 的 AMQP rabbitmq 客户端访问它了。</p><h2 id="1fc2" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated">安装 Pika</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="ab65" class="ki jl hi lg b fi lk ll l lm ln">pip install pika</span></pre><p id="32ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经准备好从 python 访问和管理 rabbitmq 了</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="e7e4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">消息生产者和消费者“应用程序”</h1><figure class="lb lc ld le fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/7bfe20a163c087d056c963dc87a5681a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tea8urA4XbvsBXkY42hRDQ.jpeg"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">一个例子的简单图示</figcaption></figure><p id="ecac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，我们有消息的生产者和消费者。因此，这个设计有两个方面，一个是生产者，另一个是消费者。我们将看到两端，并为此编写一个 python 脚本。</p><h2 id="8d26" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated">生产者</h2><blockquote class="mj mk ml"><p id="c954" class="if ig mm ih b ii ij ik il im in io ip mn ir is it mo iv iw ix mp iz ja jb jc hb bi translated">* <strong class="ih hj">凭证</strong> -在这里，我们将定义 rabbitmq-server(请参考上面的安装部分)<br/> * <strong class="ih hj">主机</strong>知道的用户名和密码-默认情况下，我们使用“localhost”或 0.0.0.0 作为监听服务器，但它可以在具有 rabbitmq-server 监听<br/> * <strong class="ih hj">端口</strong>的云上拥有任何其他 IP 地址-默认情况下，这是 5672， 但是它应该指向我们的服务器正在监听的端口<br/> * <strong class="ih hj">交换</strong>——这可以假设为一个需要声明的桥名，以便可以访问队列<br/>*<strong class="ih hj">routing _ key</strong>——这是一个与该键对应的绑定键，我们可以将其设置为任何名称<br/>*<strong class="ih hj">basic _ publish</strong>——这是我们调用的将消息发送到相应队列的方法</p></blockquote><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="5b01" class="ki jl hi lg b fi lk ll l lm ln">#producer<br/><strong class="lg hj">import pika</strong></span><span id="67df" class="ki jl hi lg b fi mq ll l lm ln">#declaring the credentials needed for connection like host, port, username, password, exchange etc<br/><strong class="lg hj">credentials = pika.PlainCredentials(‘tester’,’secretPass’)<br/>connection= pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’, credentials= credentials))<br/>channel= connection.channel()</strong></span><span id="2367" class="ki jl hi lg b fi mq ll l lm ln"><strong class="lg hj">channel.exchange_declare(‘test’, durable=True, exchange_type=’topic’)</strong></span><span id="a260" class="ki jl hi lg b fi mq ll l lm ln"><strong class="lg hj">channel.queue_declare(queue= ‘A’)<br/>channel.queue_bind(exchange=’test’, queue=’A’, routing_key=’A’)</strong></span><span id="788f" class="ki jl hi lg b fi mq ll l lm ln"><strong class="lg hj">channel.queue_declare(queue= ‘B’)<br/>channel.queue_bind(exchange=’test’, queue=’B’, routing_key=’B’)</strong></span><span id="f0b8" class="ki jl hi lg b fi mq ll l lm ln"><strong class="lg hj">channel.queue_declare(queue= ‘C’)<br/>channel.queue_bind(exchange=’test’, queue=’C’, routing_key=’C’)</strong></span><span id="94d2" class="ki jl hi lg b fi mq ll l lm ln">#messaging to queue named C<br/><strong class="lg hj">message= ‘hello consumer!!!!!’</strong><br/><strong class="lg hj">channel.basic_publish(exchange=’test’, routing_key=’C’, body= message)</strong></span><span id="e0e6" class="ki jl hi lg b fi mq ll l lm ln"><strong class="lg hj">channel.close()</strong></span></pre><p id="3c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用在安装 rabbimq-server 时创建的相同凭证。</p><figure class="lb lc ld le fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mr"><img src="../Images/fe873af3d6727fbbd100215a9895d10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skEe0Al3ZfaX68LP-tQdjA.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">交换名:在我的例子中是 dde</figcaption></figure><figure class="lb lc ld le fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ms"><img src="../Images/ed0545c4ab2d726ad7cc63bc938c2acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUvKb5_yZJRzhHYpfQt9QA.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">在 dde 交换中:声明了五个队列</figcaption></figure><h2 id="196d" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated">消费者</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2ba5" class="ki jl hi lg b fi lk ll l lm ln">#consumer</span><span id="59d5" class="ki jl hi lg b fi mq ll l lm ln"><strong class="lg hj">import pika</strong><br/>#declaring the credentials needed for connection like host, port, username, password, exchange etc<br/><strong class="lg hj">credentials = pika.PlainCredentials('tester','secretPass')<br/>connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', port='5672', credentials= credentials))<br/>channel = connection.channel()<br/>channel.exchange_declare('test', durable=True, exchange_type='topic')</strong></span><span id="3b3b" class="ki jl hi lg b fi mq ll l lm ln">#defining callback functions responding to corresponding queue callbacks<br/><strong class="lg hj">def callbackFunctionForQueueA(ch,method,properties,body):<br/> print('Got a message from Queue A: ', body)<br/>def callbackFunctionForQueueB(ch,method,properties,body):<br/> print('Got a message from Queue B: ', body)<br/>def callbackFunctionForQueueC(ch,method,properties,body):<br/> print('Got a message from Queue C: ', body)</strong></span><span id="5799" class="ki jl hi lg b fi mq ll l lm ln">#Attaching consumer callback functions to respective queues that we wrote above<br/><strong class="lg hj">channel.basic_consume(queue='A', on_message_callback=callbackFunctionForQueueA, auto_ack=True)<br/>channel.basic_consume(queue='B', on_message_callback=callbackFunctionForQueueB, auto_ack=True)<br/>channel.basic_consume(queue='C', on_message_callback=callbackFunctionForQueueC, auto_ack=True)<br/>#this will be command for starting the consumer session<br/>channel.start_consuming()</strong></span></pre><h2 id="2cff" class="ki jl hi bd jm kj kk kl jq km kn ko ju iq kp kq jy iu kr ks kc iy kt ku kg kv bi translated">这经常发生</h2><p id="cf49" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">由于阻塞连接，如果通道长时间连接，则服务器拒绝连接。为了克服这一点，我们可以通过两种方法，一种是改变长期的连接类型，另一种是只有当你想发送或接收某些东西时才建立连接。第二个是更好的方法。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="c24d" class="ki jl hi lg b fi lk ll l lm ln">def startConsumer():<br/> connection= pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))<br/> #creating channels<br/> channel= connection.channel()<br/> #connecting queues to channels<br/> channel.basic_consume(queue=’<strong class="lg hj">A</strong>’,  on_message_callback=<strong class="lg hj">callbackFunctionForQueueA</strong>, auto_ack=True)<br/> channel.basic_consume(queue=’<strong class="lg hj">B</strong>’, on_message_callback=<strong class="lg hj">callbackFunctionForQueueB</strong>, auto_ack=True)<br/> channel.basic_consume(queue=’<strong class="lg hj">C</strong>’, on_message_callback=<strong class="lg hj">callbackFunctionForQueueC</strong>, auto_ack=True)</span><span id="5175" class="ki jl hi lg b fi mq ll l lm ln">#Starting Threads for different channels to start consuming enqueued requests<br/> Thread(target= channel.start_consuming()).start()</span><span id="6bb9" class="ki jl hi lg b fi mq ll l lm ln">while True:<br/> try:<br/>  startConsumer()<br/> except:<br/>  continue</span></pre><h1 id="c00d" class="jk jl hi bd jm jn mt jp jq jr mu jt ju jv mv jx jy jz mw kb kc kd mx kf kg kh bi translated">结论</h1><p id="988e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">这个博客旨在成为 python 入门所需的最少代码，我们可以在它的基础上开发更多高级功能，并利用它来构建一个伟大的项目。</p><p id="0be9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进一步阅读，pika 有很棒的文档可供我们阅读:-<a class="ae my" href="https://pika.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">https://pika.readthedocs.io/en/stable/</a></p></div></div>    
</body>
</html>