<html>
<head>
<title>Memory Area and Execution Engine in JVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JVM中的内存区域和执行引擎</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/memory-area-and-execution-engine-in-jvm-28c23dd5fdfe?source=collection_archive---------12-----------------------#2020-05-09">https://medium.com/analytics-vidhya/memory-area-and-execution-engine-in-jvm-28c23dd5fdfe?source=collection_archive---------12-----------------------#2020-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/688e03dda49597cb495b63139c547b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*zrxTfu2MYIdYWQ4iUbLFeA.png"/></div></figure><p id="52f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗨伙计们！你过得怎么样？在之前的博客中，我们已经看到了类加载器子系统是如何工作的，以及它在运行时加载类和验证字节码的功能。今天我们将看到执行还需要哪些类型的内存，以及执行引擎在JVM进程中的作用。我们先讨论一下内存区域。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/5c0d79d6929aacbe5d3c2a800525c06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*re4aSRm0K8nBTVzv4_PcqQ.gif"/></div></figure><h2 id="82d0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated">存储区</h2><p id="51e9" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">内存区也可以称为数据区或运行时内存区，所以请不要与名称混淆。🤪基本上，当加载类或执行字节码时，需要内存来保存类数据，为对象分配内存，不仅如此，还要跟踪指令已经加载到哪里。所以现在你可能已经理解了我们需要不同的内存区域，它们实际上存在于JVM中。</p><p id="5a97" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，存储区可以分为以下类型:</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/6aa6bccc2737061910d5553217f32c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*sxfLVJ6qAmLYT3P2fqSxgA.png"/></div></figure><ul class=""><li id="2dbc" class="kq kr hi io b ip iq it iu ix ks jb kt jf ku jj kv kw kx ky bi translated"><strong class="io hj">方法区:</strong>在方法区内，将存储包括静态变量在内的类级数据。</li><li id="5af6" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated"><strong class="io hj">堆区域:</strong>这是动态内存分配通常发生的区域。它存储object，每当你用new，malloc关键字创建实例变量时也是数组(在java中数组是object)。</li><li id="3507" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated"><strong class="io hj">堆栈区:</strong>为每个正在执行的线程创建运行时堆栈。现在，假设我们正在进行方法调用，因此每个方法调用都充当堆栈框架，被注入到堆栈区域内的线程的运行时堆栈中。所有的局部变量都存储在堆栈中。</li></ul><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es le"><img src="../Images/ebd3f708efe2fca07957c0f499e49a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*ZZuBHLQazavHGjPHrlGiQQ.png"/></div></figure><ul class=""><li id="df11" class="kq kr hi io b ip iq it iu ix ks jb kt jf ku jj kv kw kx ky bi translated"><strong class="io hj"> PC寄存器:</strong>每个线程都有单独的PC寄存器，以便保存指令地址并执行另一个线程，同时在切换时更新当前指令地址，该地址可以继续处理。</li><li id="fe21" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated"><strong class="io hj">本地方法堆栈:</strong>这包含关于特定线程的每个堆栈帧的信息。</li></ul><p id="ab21" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意:</strong>方法区和堆区<strong class="io hj">将不是线程安全的</strong>，因为资源将在线程间共享，而对于栈区的情况，它<strong class="io hj">将是线程安全的</strong>，因为它不是共享资源。</p><p id="c3f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">直到这里。类文件已经加载，现在角色来到执行引擎来执行文件。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/0153f75459f1c69a127a553a6454f13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*g6SBV3hdSbOJ1O1R8oyzLA.gif"/></div></figure><h2 id="435b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated">执行引擎</h2><p id="2241" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">执行引擎通过将字节码转换成机器码来帮助执行字节码，并与存储区进行交互。以下是执行过程中涉及的组件:</p><ul class=""><li id="43b1" class="kq kr hi io b ip iq it iu ix ks jb kt jf ku jj kv kw kx ky bi translated"><strong class="io hj">解释器</strong>:负责逐行读取、解释、执行java程序。因此，如果任何方法被调用多次，就需要新的解释，这是它的主要缺点。</li><li id="c3a1" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated"><strong class="io hj"> JIT编译器(Just In Time):</strong>JIT编译器的概念只适用于重复的方法，而不是每个方法。为了克服解释器在解释字节码时所面临的问题，每当JIT编译器发现重复的代码时，它就编译整个字节码并把它变成机器码。这个机器码将直接用于重复的方法调用。</li><li id="7a30" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated">中间代码生成器</li><li id="2166" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated">代码优化器</li><li id="dee5" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated">目标代码生成器</li><li id="e752" class="kq kr hi io b ip kz it la ix lb jb lc jf ld jj kv kw kx ky bi translated">仿形铣床</li></ul><p id="a972" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:Profiler是用来识别JIT中热点重复方法的。</p><p id="8e44" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了给执行引擎提供本地库，我们有了连接本地库和执行引擎的JNI。</p><p id="d719" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> JNI(Java原生接口):</strong>作为执行引擎和原生方法库之间的桥梁，在执行时提供库。</p><p id="bb11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">本地方法库:</strong>包含执行引擎在执行字节码时需要的库。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="7136" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那是关于JVM架构和它的工作。</p><p id="c22a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我遗漏了什么，请评论出来，并在评论框中告诉我你的建议。✌ <a class="ae ln" rel="noopener" href="/@barunsarraf/jvm-architecture-and-working-9f17945d7408">阅读了</a>我之前关于JVM中的类加载器子系统的博客。</p><h2 id="375f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated">快乐编码。！</h2></div></div>    
</body>
</html>