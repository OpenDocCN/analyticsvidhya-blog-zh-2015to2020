<html>
<head>
<title>Become a Better R Programmer with the Awesome ‘lobstr’ Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用令人敬畏的“lobstr”软件包成为一名更好的R程序员</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/become-a-better-r-programmer-with-the-awesome-lobstr-package-af97fcd22602?source=collection_archive---------0-----------------------#2018-09-19">https://medium.com/analytics-vidhya/become-a-better-r-programmer-with-the-awesome-lobstr-package-af97fcd22602?source=collection_archive---------0-----------------------#2018-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/38a4013ba695d5dc3e92c6b5947eb565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnGc0ocFWc9O8eYwaddxpg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片提供:<a class="ae iu" href="https://pixabay.com/en/coding-programming-working-macbook-926242/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/en/coding-programming-working-macbook-926242/</a></figcaption></figure><blockquote class="iv"><p id="4ac3" class="iw ix hi bd iy iz ja jb jc jd je jf dx translated">“工具会放大你的才能。你的工具越好，你越知道如何使用它们，你的工作效率就越高。”—安德鲁·亨特，务实的程序员</p></blockquote><p id="df1a" class="pw-post-body-paragraph jg jh hi ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc jf hb bi translated">程序员的主要工具是他或她对编程语言的选择。说到数据科学，R一直是我构建模型的首选语言。</p><p id="02a1" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">出于各种原因，r是最流行的编程语言之一(至少在数据科学中是这样):</p><ul class=""><li id="2faa" class="ki kj hi ji b jj kd jn ke jr kk jv kl jz km jf kn ko kp kq bi translated">易于使用的语法</li><li id="ca2c" class="ki kj hi ji b jj kr jn ks jr kt jv ku jz kv jf kn ko kp kq bi translated">优雅的可视化/绘图系统</li><li id="5980" class="ki kj hi ji b jj kr jn ks jr kt jv ku jz kv jf kn ko kp kq bi translated">丰富的包装生态系统，以及</li><li id="4e77" class="ki kj hi ji b jj kr jn ks jr kt jv ku jz kv jf kn ko kp kq bi translated">丰富的社区支持</li></ul><p id="c61e" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">是一个直观的R包，有潜力让你成为更好的程序员。当我在搜索<a class="ae iu" href="https://github.com/r-lib" rel="noopener ugc nofollow" target="_blank"> R Infrastructure </a>的GitHub页面寻找新的R包时，我偶然发现了<code class="du kw kx ky kz b">lobstr</code>，它被证明是一个非常有用的包！</p><h1 id="ec9e" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关于lobstr</h1><p id="b4cf" class="pw-post-body-paragraph jg jh hi ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc jf hb bi translated"><code class="du kw kx ky kz b">lobstr</code>由令人惊叹的Hadley Wickham设计，试图帮助普通开发者更好地理解R。用他自己的话来说，<code class="du kw kx ky kz b">lobstr</code>提供了深入挖掘R对象细节的工具。</p><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es md"><img src="../Images/e35dfc5da46fab583d8b8ef030be6e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/0*KASflt8jHlj0kzh2.png"/></div></figure><p id="a622" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated"><code class="du kw kx ky kz b">lobstr</code>也可以被认为是<code class="du kw kx ky kz b">str</code> base-R函数的改进版本。</p><h1 id="70b2" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">安装软件包</h1><p id="5518" class="pw-post-body-paragraph jg jh hi ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc jf hb bi translated"><code class="du kw kx ky kz b">lobstr</code>尚未在CRAN上发布，所以目前只能从GitHub安装。在使用下面的安装代码之前，请确保您已经安装了<code class="du kw kx ky kz b">devtools</code>包。</p><pre class="me mf mg mh fd mi kz mj mk aw ml bi"><span id="8934" class="mm lb hi kz b fi mn mo l mp mq"># install.packages(“devtools”)<br/>devtools::install_github(“r-lib/lobstr”)</span></pre><h1 id="fa44" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">lobstr中的不同函数</h1><p id="baef" class="pw-post-body-paragraph jg jh hi ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc jf hb bi translated"><code class="du kw kx ky kz b">lobstr</code>提供三个简单的功能:</p><ul class=""><li id="929c" class="ki kj hi ji b jj kd jn ke jr kk jv kl jz km jf kn ko kp kq bi translated"><code class="du kw kx ky kz b">ref()</code> —参考文献</li><li id="6020" class="ki kj hi ji b jj kr jn ks jr kt jv ku jz kv jf kn ko kp kq bi translated"><code class="du kw kx ky kz b">ast()</code> —抽象语法树</li><li id="2a25" class="ki kj hi ji b jj kr jn ks jr kt jv ku jz kv jf kn ko kp kq bi translated"><code class="du kw kx ky kz b">cst()</code> —调用堆栈树</li></ul><p id="d808" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">这三个函数服务于三个不同的目的，我们会了解<code class="du kw kx ky kz b">ref()</code>和<code class="du kw kx ky kz b">ast()</code>的细节。我们现在将省去<code class="du kw kx ky kz b">cst()</code>,因为它仍在进行初始开发和测试。</p><h2 id="217f" class="mm lb hi bd lc mr ms mt lg mu mv mw lk jr mx my lo jv mz na ls jz nb nc lw nd bi translated"><strong class="ak">参考文献— ref() </strong></h2><p id="096c" class="pw-post-body-paragraph jg jh hi ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc jf hb bi translated">你有没有想过当你把一个现有的R对象赋给一个新的对象名会发生什么？它是否创建了一个新的对象，使内存翻倍，或者它只是创建了一个引用？</p><p id="ffad" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">会帮助你理解这一点。为了回答上述问题，让我们创建一个简单的数字向量。我们就叫它<code class="du kw kx ky kz b">simple_vector</code>。现在，让我们从同一个<code class="du kw kx ky kz b">simple_vector</code>创建一个新的列表，我们称之为<code class="du kw kx ky kz b">double_vector</code>。</p><p id="167c" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">我们在列表<code class="du kw kx ky kz b">double_vector</code>中两次使用<code class="du kw kx ky kz b">simple_vector </code>的原因是为了检查R是否分配了两个不同的内存空间，或者它是否只是引用了原来的<code class="du kw kx ky kz b">simple_vector</code>。</p><p id="e30f" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">最后，我们将使用<code class="du kw kx ky kz b">simple_vector</code>和<code class="du kw kx ky kz b">double_vector</code>创建另一个列表<code class="du kw kx ky kz b">triple_vector</code>。请注意，对象<code class="du kw kx ky kz b">double_vector</code>和<code class="du kw kx ky kz b">triple_vector</code>的类型为<code class="du kw kx ky kz b">list</code>(非向量)。</p><pre class="me mf mg mh fd mi kz mj mk aw ml bi"><span id="338d" class="mm lb hi kz b fi mn mo l mp mq"><strong class="kz hj">library</strong>(lobstr)<br/><br/><br/>simple_vector &lt;- c(2.0,3.0,4.0)<br/><br/><br/>double_vector &lt;- list(simple_vector,simple_vector)<br/><br/>triple_vector &lt;- list(double_vector,simple_vector)<br/><br/><br/>ref(simple_vector)<br/><em class="ne">#&gt; [1:0x7f9ba555aa58] &lt;dbl&gt;</em><br/><br/>ref(double_vector)<br/><em class="ne">#&gt; █ [1:0x7f9ba26be4c8] &lt;list&gt; </em><br/><em class="ne">#&gt; ├─[2:0x7f9ba555aa58] &lt;dbl&gt; </em><br/><em class="ne">#&gt; └─[2:0x7f9ba555aa58]</em><br/><br/>ref(triple_vector)<br/><em class="ne">#&gt; █ [1:0x7f9ba13fcf08] &lt;list&gt; </em><br/><em class="ne">#&gt; ├─█ [2:0x7f9ba26be4c8] &lt;list&gt; </em><br/><em class="ne">#&gt; │ ├─[3:0x7f9ba555aa58] &lt;dbl&gt; </em><br/><em class="ne">#&gt; │ └─[3:0x7f9ba555aa58] </em><br/><em class="ne">#&gt; └─[3:0x7f9ba555aa58]</em></span></pre><p id="f616" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">现在使用函数<code class="du kw kx ky kz b">ref()</code>，我们可以找到R对象的内存引用，正如你在上面看到的，<code class="du kw kx ky kz b"><em class="ne">0x7f9ba555aa58</em></code> <em class="ne"> </em>是<code class="du kw kx ky kz b">simple_vector</code>的内存引用，当你<code class="du kw kx ky kz b">ref(double_vector)</code>时，你可以看到列表对象两次引用回<code class="du kw kx ky kz b">simple_vector</code>的内存引用，同样的情况也发生在<code class="du kw kx ky kz b">ref(triple_vector)</code>上，其中<code class="du kw kx ky kz b">triple_vector</code>引用两次，一次是引用回<code class="du kw kx ky kz b">simple_vector</code>的<code class="du kw kx ky kz b">double_vector</code>的地址，另一次是引用到<code class="du kw kx ky kz b">simple_vector</code>本身。</p><p id="cf6f" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">出色地绘制了一个树形结构，帮助我们可视化内存引用。这样，我们就可以确定我们是在R中创建新的内存分配，还是引用现有的内存对象，从而在编写代码时进行更好的内存管理。</p><h2 id="72c4" class="mm lb hi bd lc mr ms mt lg mu mv mw lk jr mx my lo jv mz na ls jz nb nc lw nd bi translated">抽象语法树— ast()</h2><p id="e8ef" class="pw-post-body-paragraph jg jh hi ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc jf hb bi translated">正如维基百科上提到的，</p><blockquote class="nf ng nh"><p id="653e" class="jg jh ne ji b jj kd jl jm jn ke jp jq ni kf jt ju nj kg jx jy nk kh kb kc jf hb bi translated">在计算机科学中，<strong class="ji hj">抽象语法树</strong> ( <strong class="ji hj"> AST </strong>)，或者仅仅是<strong class="ji hj">语法树</strong>，是用编程语言编写的源代码的抽象语法结构的树表示。</p></blockquote><p id="0d44" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">像每一种编程语言一样，R中的任何表达式都可以用语法树的形式来表达。在开发和测试复杂的表达式时，以ASTs的形式可视化表达式非常有帮助。</p><p id="0248" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">让我们测试一下，看看它能为我们做些什么。首先，使用<code class="du kw kx ky kz b">ast(1+2)</code>来可视化一个简单的加法表达式，显示出<code class="du kw kx ky kz b">+</code>是将<code class="du kw kx ky kz b">1</code>和<code class="du kw kx ky kz b">2</code>传递给的操作符。这导致了加法操作，但是当我们必须将加法操作的输出分配给一个新对象时，那么<code class="du kw kx ky kz b">&lt;-</code>就变成了根节点。</p><pre class="me mf mg mh fd mi kz mj mk aw ml bi"><span id="0309" class="mm lb hi kz b fi mn mo l mp mq">library(lobstr)</span><span id="2e79" class="mm lb hi kz b fi nl mo l mp mq">#ast</span><span id="cee7" class="mm lb hi kz b fi nl mo l mp mq">#simple addition</span><span id="e2a0" class="mm lb hi kz b fi nl mo l mp mq">ast(1 + 2)<br/>#&gt; █─`+` <br/>#&gt; ├─1 <br/>#&gt; └─2</span><span id="61ab" class="mm lb hi kz b fi nl mo l mp mq">#simple addition with result assignment</span><span id="c1ae" class="mm lb hi kz b fi nl mo l mp mq">ast(x &lt;- 1 + 2)<br/>#&gt; █─`&lt;-` <br/>#&gt; ├─x <br/>#&gt; └─█─`+` <br/>#&gt; ├─1 <br/>#&gt; └─2</span></pre><p id="f898" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">虽然我们可以继续使用<code class="du kw kx ky kz b">ast()</code>来理解复杂的表达式，但是对于另一个琐碎的(但令人困惑的)操作来说，也很方便，即操作符优先。</p><p id="1dac" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">表达式<code class="du kw kx ky kz b">y &lt;- 2 + 3 * 5 / 9 ^ 2</code>很难在几秒钟内手工完成，即使它包含简单的算术运算符。这是因为在我们的头脑中使用运算符优先级并不总是容易的。但是这里有<code class="du kw kx ky kz b">ast()</code>在做同样的事情:</p><pre class="me mf mg mh fd mi kz mj mk aw ml bi"><span id="56bc" class="mm lb hi kz b fi mn mo l mp mq">#operator precedence</span><span id="343e" class="mm lb hi kz b fi nl mo l mp mq">ast(y &lt;- 2 + 3 * 5 / 9 ^ 2)<br/>#&gt; █─`&lt;-` <br/>#&gt; ├─y <br/>#&gt; └─█─`+` <br/>#&gt; ├─2 <br/>#&gt; └─█─`/` <br/>#&gt; ├─█─`*` <br/>#&gt; │ ├─3 <br/>#&gt; │ └─5 <br/>#&gt; └─█─`^` <br/>#&gt; ├─9 <br/>#&gt; └─2</span></pre><p id="8cda" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">很神奇，对吧？</p><h1 id="1e4f" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="b62a" class="pw-post-body-paragraph jg jh hi ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc jf hb bi translated">因此，通过使用<code class="du kw kx ky kz b">lobstr</code>函数<code class="du kw kx ky kz b">ref()</code>和<code class="du kw kx ky kz b">ast()</code>，我们可以更好地进行R编程——编写内存高效的代码，并以更好的方式理解表达式求值。你在上面看到的完整代码可以在<a class="ae iu" href="https://github.com/amrrs/blogpost_codes/blob/master/lobstr_intro.R" rel="noopener ugc nofollow" target="_blank">这里</a>获得，而<code class="du kw kx ky kz b">lobstr </code>文档可以在这里<a class="ae iu" href="http://lobstr.r-lib.org/" rel="noopener ugc nofollow" target="_blank">获得。</a></p><p id="c348" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc jf hb bi translated">您对此套餐有什么体验？请在下面的评论中告诉我们！</p></div></div>    
</body>
</html>