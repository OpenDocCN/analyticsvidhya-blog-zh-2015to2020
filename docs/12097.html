<html>
<head>
<title>The Mutable Default Argument Mess in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中可变的默认参数Mess</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-mutable-default-argument-mess-in-python-c0692c3032de?source=collection_archive---------32-----------------------#2020-12-30">https://medium.com/analytics-vidhya/the-mutable-default-argument-mess-in-python-c0692c3032de?source=collection_archive---------32-----------------------#2020-12-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/aa820996364ba03cfd800d177a1fb84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwpftPtTsvxTgt5WXnltng.png"/></div></div></figure><div class=""/><p id="911b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">见见凯文，🙋‍♂️·凯文正在学习Python。一天，他被要求解决如下问题:</p><blockquote class="jn jo jp"><p id="c8f0" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">设计一个函数，将' # '追加到作为参数提供的列表中，然后打印出来。如果没有提供参数，那么函数应该使用一个空列表作为缺省值。</p></blockquote><p id="a6cd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">凯文很快想出了以下解决方案:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="f195" class="kd ke hs jz b fi kf kg l kh ki">def append(l = []):<br/>    l.append('#')<br/>    print(l)</span></pre><p id="da8c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看起来不错，该测试解决方案了:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4d93" class="kd ke hs jz b fi kf kg l kh ki">append([1, 2, 3])<br/># OUTPUT: [1, 2, 3, '#'] | OK</span><span id="90d1" class="kd ke hs jz b fi kj kg l kh ki">append()<br/># OUTPUT: ['#']    | OK</span><span id="f8ee" class="kd ke hs jz b fi kj kg l kh ki">append()<br/># OUTPUT: ['#', '#']  | Strange!!</span></pre><ul class=""><li id="f09e" class="kk kl hs ir b is it iw ix ja km je kn ji ko jm kp kq kr ks bi translated">对<code class="du kt ku kv jz b">append</code>的第一次调用运行良好。它将#添加到列表<code class="du kt ku kv jz b">[1, 2, 3]</code>中，然后打印它。</li><li id="13c6" class="kk kl hs ir b is kw iw kx ja ky je kz ji la jm kp kq kr ks bi translated">第二个也像预期的那样起作用。这一次没有提供列表作为参数，所以它使用默认的空列表并附加了一个#号。</li><li id="5ac2" class="kk kl hs ir b is kw iw kx ja ky je kz ji la jm kp kq kr ks bi translated">现在，第三个电话导致了意想不到的事情。</li><li id="f1ac" class="kk kl hs ir b is kw iw kx ja ky je kz ji la jm kp kq kr ks bi translated">当我们再次无争论地调用<code class="du kt ku kv jz b">append</code>时，它打印出<code class="du kt ku kv jz b">['#', '#']</code>而不是我们在上面的调用中得到的<code class="du kt ku kv jz b">['#']</code>。</li></ul><h1 id="3ec5" class="lb ke hs bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么会这样？</h1><p id="9313" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">发生这种情况的原因是Python只在第一次定义函数时定义了一次默认参数<em class="jq">。</em></p><p id="7678" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是因为python是逐行解析的，当解析器遇到<code class="du kt ku kv jz b">def</code>时，它会将默认参数设置为一个值，该值将在以后的每次调用中使用。</p><p id="fc00" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当默认参数是<strong class="ir ht">可变的</strong>时，Python的这种行为就变得特别值得关注。</p><p id="a97b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<strong class="ir ht"> immutables </strong>的值不可更改，如果您更新函数中的自变量变量，它将创建一个新的对象并开始指向该对象，而不是更改原来的默认对象。</p><p id="c55b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是在可变默认参数的情况下，解析函数时创建的对象被更新，而不是为该函数调用创建不同的对象。</p><h1 id="a6c8" class="lb ke hs bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">解决办法</h1><p id="63d8" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">这个问题的解决方案是使用不可变的默认参数，而不是可变的。首选是<code class="du kt ku kv jz b">None</code>(尽管您可以选择任何不可变的值)。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="6091" class="kd ke hs jz b fi kf kg l kh ki">def append(l = None):<br/>    if l is None:<br/>        l = []<br/>    l.append('#')<br/>    print(l)</span></pre><p id="b953" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们测试这个解决方案-</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="71d5" class="kd ke hs jz b fi kf kg l kh ki">append([1, 2, 3])<br/># OUTPUT: [1, 2, 3, '#']    | OK</span><span id="0022" class="kd ke hs jz b fi kj kg l kh ki">append()<br/># OUTPUT: ['#']     | OK</span><span id="3d48" class="kd ke hs jz b fi kj kg l kh ki">append()<br/># OUTPUT: ['#']        | Works fine!</span></pre><p id="b24d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">太好了！这个解决方案如预期的那样有效。</p><p id="74c2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是为什么呢？让我们看看里面。</p><h1 id="ba27" class="lb ke hs bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么该解决方案有效？</h1><p id="04fc" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">观看此视频，了解错误版本的代码中发生了什么-</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">解决方案第一版的工作</figcaption></figure><p id="3485" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，在这种情况下，原始的<code class="du kt ku kv jz b">l</code>被修改，而不是为每个函数调用创建一个新的<code class="du kt ku kv jz b">l</code>，因为<code class="du kt ku kv jz b">list</code>是一个可变值。</p><p id="7942" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，看看代码的正确版本-</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">解决方案第二版的工作</figcaption></figure><p id="1fd3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里因为<code class="du kt ku kv jz b">None</code>是一个不可变的值，所以它不能被改变，并且为每个函数调用创建一个新的列表对象。</p><blockquote class="jn jo jp"><p id="59c9" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">注意:默认参数是函数对象的一个属性，因此，最初它对所有函数调用都是一样的。</p></blockquote><h1 id="2de2" class="lb ke hs bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">感谢阅读😊</h1><p id="4bcb" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">如果你觉得这篇文章有帮助，请点赞并分享！欢迎在评论中反馈意见。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h2 id="b3cc" class="kd ke hs bd lc mq mr ms lg mt mu mv lk ja mw mx lo je my mz ls ji na nb lw nc bi translated">您可能还喜欢:</h2><ul class=""><li id="973d" class="kk kl hs ir b is ly iw lz ja nd je ne ji nf jm kp kq kr ks bi translated"><a class="ae ng" href="https://blog.yuvv.xyz/modern-cpp-features" rel="noopener ugc nofollow" target="_blank">现代C++特性</a></li><li id="2dc6" class="kk kl hs ir b is kw iw kx ja ky je kz ji la jm kp kq kr ks bi translated"><a class="ae ng" href="https://blog.yuvv.xyz/what-happens-when-you-run-a-computer-program" rel="noopener ugc nofollow" target="_blank">当你运行一个计算机程序时会发生什么？</a></li><li id="9dc4" class="kk kl hs ir b is kw iw kx ja ky je kz ji la jm kp kq kr ks bi translated"><a class="ae ng" href="https://blog.yuvv.xyz/comprehensions-in-python-explained" rel="noopener ugc nofollow" target="_blank">Python中的理解:解释</a></li><li id="626a" class="kk kl hs ir b is kw iw kx ja ky je kz ji la jm kp kq kr ks bi translated"><a class="ae ng" href="https://blog.yuvv.xyz/linux-commands-reference-with-examples" rel="noopener ugc nofollow" target="_blank"> Linux命令参考示例</a></li></ul><p id="1278" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章最初发表在<a class="ae ng" href="https://blog.yuvv.xyz/the-mutable-default-argument-mess-in-python" rel="noopener ugc nofollow" target="_blank"> Yuvraj的CS博客</a></p><p id="7684" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae ng" href="https://twitter.com/yuvraajsj18" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ng" href="https://github.com/yuvraajsj18" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae ng" href="https://www.linkedin.com/in/yuvraajsj18/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。</p></div></div>    
</body>
</html>