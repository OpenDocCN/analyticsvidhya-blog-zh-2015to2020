<html>
<head>
<title>Python Functions and features that makes the language breakthrough when compared to other</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与其他语言相比，Python函数和特性是语言的突破</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-functions-and-features-that-makes-the-language-breakthrough-when-compared-to-other-4890bd6020ba?source=collection_archive---------34-----------------------#2020-07-12">https://medium.com/analytics-vidhya/python-functions-and-features-that-makes-the-language-breakthrough-when-compared-to-other-4890bd6020ba?source=collection_archive---------34-----------------------#2020-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/5ec334fa2b29d22a09464ddcd62bd2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Duer1F9sk_ET4ECu_TTPUw.jpeg"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">来自<a class="ae jc" href="https://burst.shopify.com/api-work-productivity?utm_campaign=photo_credit&amp;amp;utm_content=Free+Software+Programming+Plan+Photo+%E2%80%94+High+Res+Pictures&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">突发事件</a>的<a class="ae jc" href="https://burst.shopify.com/@sarahpflugphoto?utm_campaign=photo_credit&amp;amp;utm_content=Free+Software+Programming+Plan+Photo+%E2%80%94+High+Res+Pictures&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">莎拉·普鲁格</a>的照片</figcaption></figure><p id="b7d0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在现代，计算机科学及其众多的子学科与现实世界中的许多案例相结合，编程语言在计算机科学的发展中起着非常重要的作用，我认为编程语言是任何计算机科学问题的骨架。因此，拥有一种全功能的编程语言为计算机科学开发者解决问题提供了更多的控制。Python就是这样一种编程语言，它提供了各种方便用户的工具和功能。在stack overflow 2020开发者调查中，它也被评为最受欢迎和第三受欢迎的语言。因此，从调查结果来看，它可以理解有大量的社区支持python，这有助于它更快地发展。</p><p id="83e8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在考虑了python的使用和上下文之后，让我们来讨论这篇文章。在这里，我们将介绍帮助python获得这些调查结果的各种方法和函数。此外，这些功能和工具也将帮助读者进行竞争性编码。</p><h1 id="b8e4" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak"> 1。计数器:- </strong></h1><p id="40db" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">计数器类是Python集合模块提供的一种特殊类型的数据集对象。集合模块为用户提供了专门的容器数据类型，从而为Python的通用内置(如字典、列表和元组)提供了一种替代方案。它返回一个字典，这个字典查找数据结构中特定元素的出现。就像下面的例子，当列表被传递给计数器时，它返回一个字典，该字典将关键字作为列表项，关键字的值是它们在列表中出现的值。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="6929" class="lj kc hi lf b fi lk ll l lm ln">#importing counter<br/>from collections import Counter</span><span id="bec1" class="lj kc hi lf b fi lo ll l lm ln">l=[1,2,3,3,435,5,67,666,11,11,1,1]<br/>c=Counter(l)<br/>print(c)</span></pre><p id="e9ea" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="6bc6" class="lj kc hi lf b fi lk ll l lm ln">[out]:Counter({1: 3, 3: 2, 11: 2, 2: 1, 435: 1, 5: 1, 67: 1, 666: 1})</span></pre><p id="97fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">计数器的most_common函数示例，<br/>为了方便用户，计数器附带了许多函数，但对我来说，most_common函数非常有用，它从提供的数据结构中返回出现次数最高的项。</p><p id="b7ab" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在下面给出的示例中，most_common方法应用于上面示例中生成的计数器。传递2是因为参数意味着我们只需要出现次数最多的两个项目。它返回具有2个元素元组的列表，元组的第一个元素指示关键字，元组的第二个元素指示该关键字的出现。如下例所示，在返回列表的第0个索引上，出现了两个元素的元组，其中指示出现了3次的键1。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="3dba" class="lj kc hi lf b fi lk ll l lm ln"><em class="lp">#this provides most common two elements that are 1 which is 3 times and 3 which is two times<br/></em>c.most_common(2)</span></pre><p id="c111" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="a5ce" class="lj kc hi lf b fi lk ll l lm ln">[out]: [(1,3),(3,2)]</span></pre><p id="4c2d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">2 .枚举:- </p><p id="854c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">枚举函数在for循环中很有帮助，因为在for循环中需要iterable元素的索引。在某些用例中进行竞争性编码时，需要用值维护iterable的索引，因此为了执行上述任务，python具有枚举功能。</p><p id="578c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在下面的代码片段中,“I”关键字维护索引，而“j”维护索引I处的值。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="fa91" class="lj kc hi lf b fi lk ll l lm ln">l=[1,42,990,5,7,8,64]<br/><strong class="lf hj">for</strong> i,j <strong class="lf hj">in</strong> enumerate(l):    <br/>    print(str(i)+"-------&gt;"+str(j))</span></pre><p id="dca1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="d446" class="lj kc hi lf b fi lk ll l lm ln">[out]:0-------&gt;1<br/>1-------&gt;42<br/>2-------&gt;990<br/>3-------&gt;5<br/>4-------&gt;7<br/>5-------&gt;8<br/>6-------&gt;64</span></pre><p id="89b5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 3.zip :- </strong></p><p id="7fab" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当需要组合两个或多个数据结构的各个元素时，使用zip函数，它将两个或多个iterable作为参数</p><p id="156a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在下面的例子中，我们有两个列表l和k，当我们将这两个列表传递给zip函数时，它返回一个迭代器，当显示为列表时，其中包含几个两元素元组，元组的第一个元素来自第一个列表，元组的第二个元素来自第二个列表。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="5967" class="lj kc hi lf b fi lk ll l lm ln">l=[1,2,3]<br/>k=[4,5,6]<br/>a=zip(l,k)<br/>print(a)<em class="lp">#returns iterator object</em><br/>print(list(a))<em class="lp">#clubbed both list</em></span></pre><p id="7dda" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="d43c" class="lj kc hi lf b fi lk ll l lm ln">[out]:&lt;zip object at 0x0000020198B6F908&gt;<br/>[(1, 4), (2, 5), (3, 6)]</span></pre><p id="787c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 4 .地图:- </strong></p><p id="5215" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当您需要对iterable的每个元素应用任何特定的函数时，可以使用map函数</p><p id="4710" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们想计算一个列表中所有元素的平方，那么我们可以在python中只用一行代码来完成。如下例所示，在map函数中传递的两个参数中，第一个是我们希望应用于列表中每个元素的函数，第二个是列表本身。这里我们使用lambda函数作为参数，我们将在本文后面讨论。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="1cff" class="lj kc hi lf b fi lk ll l lm ln">l=[1,2,3] <br/>a=map(<strong class="lf hj">lambda</strong> x:x**2,l) <br/>print(a)<em class="lp">#returns iterator object</em> <br/>print(list(a))<em class="lp">#updated list</em></span></pre><p id="461d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="c315" class="lj kc hi lf b fi lk ll l lm ln">[out]:&lt;map object at 0x0000020198C93BC8&gt;<br/>[1, 4, 9]</span></pre><p id="5364" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">5 .过滤器:- </p><p id="7d3b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这与map函数的工作方式类似，但它包括条件功能。因此，如果我们想只对列表中的选定元素应用特定的函数，而不是像在map中那样对所有元素应用，那么就要使用过滤器。Filter函数还接受两个参数，其中第一个参数是函数，如果为列表中的元素返回“True ”,则只考虑该特定元素，否则它将被丢弃。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="e653" class="lj kc hi lf b fi lk ll l lm ln"><strong class="lf hj">def</strong> is_even(i):     <br/>   <strong class="lf hj">return</strong> i%2==0      <br/>l=[1,2,3,4] <br/>filtered=filter(is_even,l) <br/>print(filtered)<em class="lp">#filtered iterator object</em> print(list(filtered))<em class="lp">#filtered list</em></span></pre><p id="6344" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="c5fa" class="lj kc hi lf b fi lk ll l lm ln">[out]:&lt;filter object at 0x0000020199150448&gt;<br/>[2, 4]</span></pre><p id="45db" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 6。__词典__ </strong></p><p id="4a85" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这对于python中面向对象的开发人员来说是一个福音。它以字典形式<br/>给出了所有实例属性的信息，如下例所示。如果我们想要任何对象的所有详细信息，我们必须调用__dict__方法来显示它的所有变量和值。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="28b1" class="lj kc hi lf b fi lk ll l lm ln">class emplyoee:<br/>    def __init__(self,name,age,pay):<br/>        self.name=name<br/>        self.age=age<br/>        self.pay=pay<br/>emp=emplyoee("devarsh",20,100000)<br/>print(emp.__dict__)<em class="lp">#printing all attribute</em></span></pre><p id="b49a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="d86e" class="lj kc hi lf b fi lk ll l lm ln">[out]: {'name': 'devarsh', 'age': 20, 'pay': 100000}</span></pre><p id="47eb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 7。已命名的对:- </strong></p><p id="9244" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您需要访问字典形式的元组，您可以提供一个键来在元组中进行搜索，那么命名元组是最好的方法。因此，命名元组包含了元组和字典的优点。在命名元组中，我们可以用一个键搜索元组中的一个元素。<br/>在下面的例子中，首先在导入命名元组之后，我们声明了命名元组“dev ”,它以列表格式存储年龄和工资。之后，我们通过创建一个实例“d”来添加名为tuple的“dev”中的值。现在，在“d”的帮助下，我们可以搜索我们在实例化“age”键时输入的年龄。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="d87d" class="lj kc hi lf b fi lk ll l lm ln">from collections import namedtuple<br/>#declaring named tuples</span><span id="6eea" class="lj kc hi lf b fi lo ll l lm ln">dev = namedtuple("Dev",["age","pay"])<br/>d = dev(20,100000)<br/>print(d.age)  <em class="lp">#we can access tuple with the key</em><br/>print(d[1])</span></pre><p id="e5e0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="cf85" class="lj kc hi lf b fi lk ll l lm ln">[out]: 20 100000</span></pre><p id="8760" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">排序:- </p><p id="2ee2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Sorted是python中主要用于非就地排序<strong class="jf hj"> </strong>的函数。<strong class="jf hj"> </strong>通过保持reverse等于TRUE，我们可以对提供的列表进行逆序排序。排序函数的主要用途是借助key参数，因为使用它我们可以对iterable的内部元素进行排序。例如，我们可以在包含列表中各种元组的数据结构中根据元组索引进行排序。</p><p id="bd21" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在排序函数中，键参数被定义为控制所提供列表排序的函数。因此，我们可以在关键参数的帮助下执行自定义排序</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="97fe" class="lj kc hi lf b fi lk ll l lm ln">l=[1,2,5,4,7,8,96,3,2,1,4,50,56] <br/>print("Sorted")<br/>print(sorted(l))<em class="lp">#returns another sorted list</em></span><span id="37a9" class="lj kc hi lf b fi lo ll l lm ln">print("original list") <br/>print(l)<em class="lp">#first list not sorted as it is</em> </span><span id="af6f" class="lj kc hi lf b fi lo ll l lm ln">l=[(2,3,4),(4,7,5),(5,8,3),(8,4,1)] </span><span id="7de9" class="lj kc hi lf b fi lo ll l lm ln"><em class="lp">#if we want above list to be sorted with respect to second element of tuple then</em> <br/>print("Sorting according to second element of the tuple in reverse")</span><span id="df1b" class="lj kc hi lf b fi lo ll l lm ln">print(sorted(l,reverse=<strong class="lf hj">True</strong>,key=<strong class="lf hj">lambda</strong> x:x[1]))<em class="lp">#prints sorted list according to second element of tuple in descending order</em></span></pre><p id="9987" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="658a" class="lj kc hi lf b fi lk ll l lm ln">[out]: Sorted<br/>[1, 1, 2, 2, 3, 4, 4, 5, 7, 8, 50, 56, 96]<br/>original list<br/>[1, 2, 5, 4, 7, 8, 96, 3, 2, 1, 4, 50, 56]<br/>Sorting according to second element of the tuple in reverse<br/>[(5, 8, 3), (4, 7, 5), (8, 4, 1), (2, 3, 4)]</span></pre><p id="3160" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 9 .使用键</strong>的最小最大值</p><p id="4587" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">列表中的Min和max函数只是用来从iterable中获取最小值和最大值，但是在key函数的帮助下，我们可以根据情况需要提取min和max。<br/>假设我们需要根据位于列表不同索引处的字符串的长度提取最小值和最大值，下面的代码用于实现这一点。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="3aeb" class="lj kc hi lf b fi lk ll l lm ln">l=["devarsh","h","patel"] <br/>print("print the maximum length string ") <br/>print("----&gt;"+str(max(l,key=<strong class="lf hj">lambda</strong> x:len(x)))) <br/>print("print the minimum length string ") <br/>print("----&gt;"+str(min(l,key=<strong class="lf hj">lambda</strong> x:len(x))))</span></pre><p id="774f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="2986" class="lj kc hi lf b fi lk ll l lm ln">[out]:print the maximum length string  <br/>----&gt;devarsh <br/>print the minimum length string  <br/>----&gt;h</span></pre><p id="0bf5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 10。默认词典:- </strong></p><p id="a89e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们需要从集合模块中导入默认字典，这是一个与字典类似的数据结构，但是如果我们请求字典中不存在的键，那么它不会返回键错误，但不会返回任何错误。当有很高的可能性从用户端搜索关键字时，使用Defaultdict，而不是在字典中。因此，这可以防止键错误并阻止python程序暂停。Defaultdict在参数中起作用，返回键不存在时要显示的消息。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="b952" class="lj kc hi lf b fi lk ll l lm ln"><strong class="lf hj">from</strong> <strong class="lf hj">collections</strong> <strong class="lf hj">import</strong> defaultdict<br/><strong class="lf hj">def</strong> msg():<br/>    <strong class="lf hj">return</strong> "not present"<br/>d=defaultdict(msg)<br/>d["name"]="Devarsh"<br/>d["surname"]="patel"<br/>print(d["name"])<br/>print(d["age"])<em class="lp">#age is not present so it will return the not present from the msg function</em></span></pre><p id="6825" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="5d36" class="lj kc hi lf b fi lk ll l lm ln">[out]:Devarsh<br/>not present</span></pre><p id="db70" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 11。Re库(正则表达式):- </strong></p><p id="83ce" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正则表达式对于文本处理非常重要，因此python附带了用于此目的的re库<br/>其背后的基本思想是创建模式，然后启动查询在字符串中搜索该模式。因此，re库中的基本概念是通过编译各种正则表达式来创建模式，就像下面的表达式一样，我们编译模式来从句子中查找单词。之后，通过将模式作为参数与string一起传递，可以将find和finditer等各种方法应用于字符串。这里我应用了finditer方法来查找单词，因为它返回带有索引跨度的单词。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="7435" class="lj kc hi lf b fi lk ll l lm ln">st="My name is devarsh h patel.Hello all how are  you this is number to test 12456789 and special character too !@ # $%"<br/>print("All words in the string")<br/>pattern=re.compile(r"\w+")<em class="lp">#/w+ is a regular expression to find words</em><br/>match=re.finditer(pattern,st)<em class="lp">#find iter returns span that is index too so it is useful</em><br/><strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> match:<br/>    print(i)</span></pre><p id="0bb8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="02e1" class="lj kc hi lf b fi lk ll l lm ln">[out]: All words in the string<br/>&lt;re.Match object; span=(0, 2), match='My'&gt;<br/>&lt;re.Match object; span=(3, 7), match='name'&gt;<br/>&lt;re.Match object; span=(8, 10), match='is'&gt;<br/>&lt;re.Match object; span=(11, 18), match='devarsh'&gt;<br/>&lt;re.Match object; span=(19, 20), match='h'&gt;<br/>&lt;re.Match object; span=(21, 26), match='patel'&gt;<br/>&lt;re.Match object; span=(27, 32), match='Hello'&gt;<br/>&lt;re.Match object; span=(33, 36), match='all'&gt;<br/>&lt;re.Match object; span=(37, 40), match='how'&gt;<br/>&lt;re.Match object; span=(41, 44), match='are'&gt;<br/>&lt;re.Match object; span=(46, 49), match='you'&gt;<br/>&lt;re.Match object; span=(50, 54), match='this'&gt;<br/>&lt;re.Match object; span=(55, 57), match='is'&gt;<br/>&lt;re.Match object; span=(58, 64), match='number'&gt;<br/>&lt;re.Match object; span=(65, 67), match='to'&gt;<br/>&lt;re.Match object; span=(68, 72), match='test'&gt;<br/>&lt;re.Match object; span=(73, 81), match='12456789'&gt;<br/>&lt;re.Match object; span=(82, 85), match='and'&gt;<br/>&lt;re.Match object; span=(86, 93), match='special'&gt;<br/>&lt;re.Match object; span=(94, 103), match='character'&gt;<br/>&lt;re.Match object; span=(104, 107), match='too'&gt;</span></pre><p id="de92" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 12。λ函数:- </strong></p><p id="c868" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个函数也称为匿名函数，这个函数没有名字，它接受参数，并在一行代码中返回结果。具体来说，它用于定义排序和相似函数的键<br/>冒号的左边是函数的参数，右边是函数的返回值。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="bc7b" class="lj kc hi lf b fi lk ll l lm ln"><em class="lp">#function to calculate the number is even or not</em><br/><em class="lp">#normal function</em><br/>print("Normal function")<br/><strong class="lf hj">def</strong> is_even(i):<br/>    <strong class="lf hj">return</strong> i%2==0<br/>print(is_even(1))<br/><em class="lp">#with the help of lambda</em><br/>print("lambda function")<br/>x=<strong class="lf hj">lambda</strong> s:s%2==0<br/>print(x(2))</span></pre><p id="5aef" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="4129" class="lj kc hi lf b fi lk ll l lm ln">[out]:Normal function<br/>False<br/>lambda function<br/>True</span></pre><p id="1cf9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 13。装饰师</strong></p><p id="32ef" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Decorators为开发人员提供了更改或添加函数的能力，一些代码行甚至不需要更改函数的源代码。<br/>decorator主要用于开发人员想要更新库中某个功能的时候。在下面的例子中，我们增加了计算函数执行时间的功能，甚至不需要修改函数的任何代码。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="77c2" class="lj kc hi lf b fi lk ll l lm ln"><em class="lp"># time calculating decorator</em><br/><strong class="lf hj">import</strong> <strong class="lf hj">time</strong><br/><strong class="lf hj">def</strong> t(fun):<br/>    <strong class="lf hj">def</strong> wrapper(q):<br/>        t1=time.time()<br/>        returned=fun(q)<br/>        <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> range(1,1000000): <em class="lp"># to increase run time</em><br/>            <strong class="lf hj">pass</strong>    <br/>        t2=time.time()<br/>        time_taken=t2-t1<br/>        print("time taken to execute function  "+str(time_taken))<br/>        <strong class="lf hj">return</strong> returned<br/>    <strong class="lf hj">return</strong> wrapper<br/>        <br/>@t<br/><strong class="lf hj">def</strong> square(q):<br/>    <strong class="lf hj">return</strong> q**2<br/>print("The square of the number is " + str(square(4)))</span></pre><p id="72ae" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="5ce4" class="lj kc hi lf b fi lk ll l lm ln">[out]:time taken to execute function  0.021939992904663086<br/>The square of the number is 16</span></pre><p id="ae2b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 14。发电机</strong></p><p id="3615" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">生成器是迭代器，帮助使用实例化数据，而不是使用整个数据。此任务防止系统加载全部数据，而是加载唯一需要的部分。<br/>主要是当用户需要在程序中处理数百万数据而不耗尽内存时使用生成器。</p><p id="6b93" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">创建发生器有两种方法:</p><p id="4a24" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">1.借助yield关键字</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="2fc0" class="lj kc hi lf b fi lk ll l lm ln"><em class="lp">#generator function</em><br/><strong class="lf hj">def</strong> g():<br/>    <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> range(1,11):<br/>        <strong class="lf hj">yield</strong> i<br/>print(g)<em class="lp">#ierator of genartor created</em><br/><strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> g():<br/>    print(i)</span></pre><p id="5325" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="7e01" class="lj kc hi lf b fi lk ll l lm ln">[out]:&lt;function g at 0x0000020198D6B5E8&gt; <br/>1 2 3 4 5 6 7 8 9 10</span></pre><p id="08f7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">2.生成器理解</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="830a" class="lj kc hi lf b fi lk ll l lm ln"><em class="lp">#generator compprehension</em><br/>g=(i <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> range(1,11))<em class="lp">#generator created</em><br/>print(g)<em class="lp">#ierator of genartor created</em><br/><strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> g:<br/>    print(i)</span></pre><p id="660b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="70a6" class="lj kc hi lf b fi lk ll l lm ln">[out]:&lt;generator object &lt;genexpr&gt; at 0x0000020199174D48&gt; <br/>1 2 3 4 5 6 7 8 9 10</span></pre><p id="cea1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 15。*参数:- </strong></p><p id="e1b2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当我们需要向函数传递任意数量的参数时，我们将函数参数定义为*args，它接受任意数量的参数并将其转换为元组。当传递给函数的参数数量没有预先定义时，使用args。就像下面的例子一样，在计算平方的函数中，我们分别传递一个两个和三个参数，函数对所有三个值都能准确地工作。</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="22e6" class="lj kc hi lf b fi lk ll l lm ln"><strong class="lf hj">def</strong> square(*args):<br/>    print(type(args))<br/>    <strong class="lf hj">return</strong> [i**2 <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> args]<br/><em class="lp">#passing different number of argument</em><br/>print(square(1,2,3))<br/>print(square(5,7))<br/>print(square(9))</span></pre><p id="33ed" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="68c9" class="lj kc hi lf b fi lk ll l lm ln">[out]:&lt;class 'tuple'&gt; <br/>[1, 4, 9] <br/>&lt;class 'tuple'&gt; <br/>[25, 49] <br/>&lt;class 'tuple'&gt; <br/>[81]</span></pre><p id="2f24" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 16**kwargs </strong></p><p id="0741" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当我们需要将字典类型的数据结构参数传递给函数时，我们将函数参数定义为**kwargs，它将字典类型的数据结构作为参数，并将其转换为纯字典</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="73a7" class="lj kc hi lf b fi lk ll l lm ln"><strong class="lf hj">def</strong> info(**kwargs):<br/>    <strong class="lf hj">for</strong> i,j <strong class="lf hj">in</strong> kwargs.items():<br/>        print(str(i)+"---&gt;"+str(j))<br/>print(info(name="devarsh",surname="patel"))</span></pre><p id="4c13" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="3ffe" class="lj kc hi lf b fi lk ll l lm ln">[out]:name---&gt;devarsh <br/>surname---&gt;patel</span></pre><p id="a712" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 17。使用集合从列表或任何合适的可重复项中删除重复值</strong></p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="6222" class="lj kc hi lf b fi lk ll l lm ln">l=[1,1,1,1,1,2,2,2,3,3,3,5,4,7,5] <br/>l=set(l)<em class="lp">#removed dupllicate</em> <br/>print(list(l))</span></pre><p id="2dad" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="cf09" class="lj kc hi lf b fi lk ll l lm ln">[out]:[1, 2, 3, 4, 5, 7]</span></pre><p id="ce39" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 18。所有功能</strong></p><p id="142c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果列表中的所有值都为真，则All函数返回真</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="048e" class="lj kc hi lf b fi lk ll l lm ln">l=[i%2==0 <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> range(1,11)] <em class="lp">#appends true if even else false </em><br/>print(l)<br/>print(all(l))</span></pre><p id="2c2b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="1993" class="lj kc hi lf b fi lk ll l lm ln">[out]:[False, True, False, True, False, True, False, True, False, True] False</span></pre><p id="5140" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 19。任何功能</strong></p><p id="cb12" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果列表中的任何值为真，则任何函数都返回真</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="3f26" class="lj kc hi lf b fi lk ll l lm ln">l=[i%2==0 <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> range(1,11)]  <em class="lp">#appens true if even else false </em><br/>print(l)<br/>print(any(l))</span></pre><p id="d31e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">输出:</p><pre class="in io ip iq fd le lf lg lh aw li bi"><span id="c133" class="lj kc hi lf b fi lk ll l lm ln">[out]:[False, True, False, True, False, True, False, True, False, True]<br/>True</span></pre><h1 id="7678" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">结论</strong></h1><p id="50f6" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这个博客的基本目的是让读者了解python晦涩的功能。通过了解这些函数，用户可以使用python以有效的方式产生更多的结果。因此，在这篇博客中，我们讨论了python中的各种工具和函数，这将有助于初学者更好地以实用的方式理解python语言工具。</p><p id="a3b1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于博客的完整代码访问:<a class="ae jc" href="https://github.com/Devarsh23/Python-Tools-and-functions" rel="noopener ugc nofollow" target="_blank">https://github.com/Devarsh23/Python-Tools-and-functions</a></p></div></div>    
</body>
</html>