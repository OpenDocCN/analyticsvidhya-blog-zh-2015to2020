<html>
<head>
<title>Facial Recognition Using Open-CV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Open-CV的面部识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/facial-recognition-using-open-cv-1d58be3db40b?source=collection_archive---------9-----------------------#2019-10-08">https://medium.com/analytics-vidhya/facial-recognition-using-open-cv-1d58be3db40b?source=collection_archive---------9-----------------------#2019-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7412b9e5b2dfca263b14566f433b11be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DKSQVZdEa2GEv2ksxWViTg.gif"/></div></div></figure><p id="7c68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从自动标记图片到解锁手机，人脸识别的应用无所不在。随着最近深度学习的进步，人脸识别的准确性也有所提高。在这个项目中，我们学习了如何开发一个可以检测和识别人脸的人脸识别系统。</p><p id="5c71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">人脸识别系统基本上可以在两种模式下运行</strong>:</p><ul class=""><li id="3682" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">面部图像的验证或认证:将输入的面部图像与要求认证的用户的面部图像进行比较。</li><li id="a9d0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">面部识别:它将输入的面部图像与数据集中的所有面部图像进行比较，以找到与该面部相匹配的用户。</li></ul><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/a9c46e6294829a86545b2e1746362826.png" data-original-src="https://miro.medium.com/v2/format:webp/1*x5eNA4b3sfPmOigYRTvGlg.png"/></div></figure><p id="d948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用Python和OpenCV编码人脸识别:</strong>我们在这个项目中要对人脸识别流程进行划分。</p><ul class=""><li id="aebb" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">准备训练数据:读取每个人/对象的训练图像及其标签，从每个图像中检测人脸，并为每个检测到的人脸分配其所属的人的整数标签。</li><li id="8768" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">训练人脸识别器:通过向OpenCV的LBPH识别器输入我们在步骤1中准备的数据来训练它。</li><li id="4e67" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">预测:向人脸识别器引入一些测试图像，看看它是否预测正确。</li></ul><h2 id="a220" class="kh ki hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated">算法:</h2><ul class=""><li id="42d0" class="jo jp hi is b it lc ix ld jb le jf lf jj lg jn jt ju jv jw bi translated">我使用了一种古老且更流行的人脸识别算法:<strong class="is hj">【局部二值模式直方图(LBPH)】</strong>。</li><li id="3d12" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">因为这是一个比较容易的人脸识别算法，每个人都可以理解它没有大的困难。</li><li id="7b89" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">它在1994年首次被描述(LBP ),并且已经被发现是纹理分类的强大特征。</li></ul><p id="ffed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">算法步骤:</strong></p><p id="a1ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参数</strong>:</p><p id="9a5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">LBPH使用4个参数:</p><p id="5912" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1 —半径</strong>:半径用于构建圆形局部二进制模式，代表中心像素周围的半径。它通常设置为1。</p><p id="0597" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2 —邻居</strong>:构建圆形局部二值模式的样本点数。计算成本越高。通常设置为8。</p><p id="5112" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3 —网格X </strong>:水平方向的单元格个数。单元越多，网格越细，得到的特征向量的维度越高。通常设置为8。</p><p id="8ed4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4 —网格Y </strong>:垂直方向的单元格个数。单元越多，网格越细，得到的特征向量的维度越高。通常设置为8。</p><h2 id="073c" class="kh ki hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated"><strong class="ak">训练算法</strong>:</h2><p id="cf98" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">首先，我们需要训练算法。为此，我们需要使用一个包含我们想要识别的人的面部图像的数据集。我们还需要为每张图像设置一个ID(它可能是一个数字或人名)，因此算法将使用这些信息来识别输入图像并给你一个输出。同一个人的图像必须有相同的ID。训练集已经构建好了。</p><h2 id="8578" class="kh ki hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated"><strong class="ak">应用LBP操作</strong>:</h2><p id="12f3" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">LBPH的第一个计算步骤是通过突出面部特征来创建以更好的方式描述原始图像的中间图像。为此，该算法基于参数的<strong class="is hj">半径</strong>和<strong class="is hj">邻居</strong>，使用了滑动窗口的概念。</p><p id="a851" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一张灰度的面部图像。</p><p id="374b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以得到这个图像的一部分，作为一个3x3像素的窗口。</p><p id="c8a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">♀也可以表示为包含每个像素(0~255)强度的3x3矩阵。</p><p id="17f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">♀然后，我们需要取矩阵的中心值作为阈值。</p><p id="c623" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于中心值(阈值)的每个邻居，我们设置一个新的二进制值。我们将等于或高于阈值的值设置为1，将低于阈值的值设置为0。</p><p id="01e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，矩阵将只包含二进制值(忽略中心值)。我们需要将矩阵中每个位置的每个二进制值逐行连接成一个新的二进制值(例如10001101)。</p><p id="e1d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">♀然后，我们将这个二进制值转换为十进制值，并将其设置为矩阵的中心值，它是原始图像的一个像素。</p><p id="121d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该程序(LBP程序)结束时，我们有一个新的图像，它更好地代表了原始图像的特征</p><p id="c30a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图显示了此过程:</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/5efaae6bb4302c86c2d4fbcccd8ad1d2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*JOOavchVlRWOBbkAv0sSTA.png"/></div></figure><p id="d415" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提取直方图</strong>:现在，使用上一步生成的图像，我们可以使用<strong class="is hj">网格X </strong>和<strong class="is hj">网格Y </strong>参数将图像分成多个网格，如下图所示:</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/88f1a6f13f0f6e37f6f4791c3aa12814.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GxMmBlEMUK4HIj4ghP4nEQ.png"/></div></figure><p id="416d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据上图，我们可以提取每个区域的直方图，如下所示:</p><p id="5e90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们有一个灰度图像，每个直方图(来自每个网格)将只包含256个位置(0~255 ),代表每个像素强度的出现次数。</p><p id="f00e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们需要连接每个直方图，以创建一个新的更大的直方图。假设我们有8×8的网格，在最终的直方图中我们将有8×8×256 = 16.384个位置。最终的直方图表示图像原始图像的特征。</p><h2 id="cdc6" class="kh ki hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated"><strong class="ak">执行面部识别</strong>:</h2><p id="b62b" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">在这一步，算法已经被训练好了。创建的每个直方图用于表示来自训练数据集的每个图像。因此，给定一个输入图像，我们对这个新图像再次执行这些步骤，并创建一个代表该图像的直方图。</p><p id="071f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，要找到与输入图像匹配的图像，我们只需比较两个直方图，并返回直方图最接近的图像。</p><p id="ca17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用各种方法来比较直方图(计算两个直方图之间的距离)，例如，<strong class="is hj">欧氏距离</strong>、<strong class="is hj">卡方</strong>、<strong class="is hj">绝对值</strong>等。</p><p id="96a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，我们可以根据以下公式使用欧几里德距离(这是众所周知的):</p><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/773f70f6915af831cd4555fef32b2348.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NKJ3U3mNdBbMu7uSeeA3kw.png"/></div></figure><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/cafc825ebb70c294e1a912b666d78ac8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FS1iWchT69ckvjGXBM4V1w.png"/></div></figure><p id="5fb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取GitHub上的代码:<a class="ae lk" href="https://github.com/PRATYUSHNAIR1976/Facial-Recognition-using-opencv" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/prayushnair 1976/face-Recognition-using-opencv</a></p><h1 id="4f42" class="ll ki hi bd kj lm ln lo kn lp lq lr kr ls lt lu ku lv lw lx kx ly lz ma la mb bi translated">输出:</h1><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/01b7f3289e9fa4705c66af7c4a550437.png" data-original-src="https://miro.medium.com/v2/format:webp/1*W5zNUB3dKHEg5GY_lSZ9Zg.png"/></div></figure><figure class="kc kd ke kf fd ij er es paragraph-image"><div class="ab fe cl kg"><img src="../Images/2a280e65629537eba7bf8f27122fdbc8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*yVK1hNXM0B7olgFl-oGmxA.png"/></div></figure></div></div>    
</body>
</html>