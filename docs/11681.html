<html>
<head>
<title>Handling Go routines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理围棋套路</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/handling-go-routines-d80298f9582e?source=collection_archive---------6-----------------------#2020-12-14">https://medium.com/analytics-vidhya/handling-go-routines-d80298f9582e?source=collection_archive---------6-----------------------#2020-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d2119751b8d48a6d51c4ecd4cf0a00ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJNp-m2OWWE8xBYl4OaccA.jpeg"/></div></div></figure><p id="a99f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建go例程很简单，因为go例程是轻量级的，所以我们可以创建数千个go例程来执行任务。但是每个例程都有代价，消耗内存或CPU使用等资源的代价。</p><p id="3dd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管围棋程序很容易使用，但管理它们也很重要。我们需要确保go例程应该在分配的任务完成后释放计算资源。大多数情况下，我们使用go例程并发执行多个任务，但如果我们让go例程挂起，从长远来看，这将导致计算资源的高消耗。</p><p id="f0a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消耗资源并且在完成后不释放它们的问题将导致可用于其他进程运行的资源减少。这将导致系统持续冻结，CPU负载急剧增加。使用go例程后运行速度快10倍的代码，将开始运行速度慢100倍于之前的代码。有时候解决这个问题的唯一方法就是关机。</p><p id="a851" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一种方法是使用运行时包将有限的CPU分配给golang代码，并分配有限的资源，但这并不能解决问题。我们应该对这个问题实施持久解决方案。给围棋程序分配工作量，并在分配的任务完成后关闭它们将是处理它的最佳方式。</p><p id="fde1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看一些go常规泄露的例子。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="e265" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面提到的代码将按预期工作，没有错误，但go例程将继续运行，因为循环永不结束，这将导致泄漏，因为没有信号或方法在出现错误时停止它。</p><p id="8eee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看另一个go例程泄漏的例子，当运行多个go例程时，这些例程一起写入同一个通道。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="0762" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们对select使用默认情况，所以在例程中不会发生死锁。尽管多次运行程序，但传递给通道的值可能永远不会收到，例如REST api请求的情况。</p><p id="9198" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一个第三方包，通过运行测试来找出程序内部是否有漏洞。该软件包是开源的，可用作日常检漏仪<a class="ae ju" href="https://github.com/uber-go/goleak" rel="noopener ugc nofollow" target="_blank">https://github.com/uber-go/goleak</a>。我使用了相同的包来找出程序中运行的go例程是否包含漏洞。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="e0c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在为第二个例子中提到的程序创建上述测试文件之后。我们可以使用<code class="du jv jw jx jy b">go test</code>运行测试文件。它将返回未能完成执行的go例程的编号。然后，我们需要验证go例程泄漏点并解决它。</p><p id="7349" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决上述漏洞，我们必须确保在一个通道上发送的所有值都应该被接收到。另一种选择是不在信道上发送无法接收的值。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="7e7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上述情况下，我已经发送了一个信号，在一段时间后停止循环，以确保不会有泄漏。有其他方法可以解决这个问题，即。接收通道上发送的所有值或不离开go例程挂起。</p><p id="de77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结论:- 使用go例程很容易，但是管理它们对于确保我们的软件长期高效运行很重要。如果处理不当，会导致进程阻塞，消耗大量cpu和内存资源来运行小块代码。关注更新…</p></div></div>    
</body>
</html>