<html>
<head>
<title>Random Floats in Any Range</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">任意范围内的随机浮动</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/random-floats-in-any-range-9b40d30b637b?source=collection_archive---------16-----------------------#2020-05-14">https://medium.com/analytics-vidhya/random-floats-in-any-range-9b40d30b637b?source=collection_archive---------16-----------------------#2020-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4618d1b66871266323748a6501b78ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNY8dHECpdDdT9mhyDKsUA.jpeg"/></div></div></figure><p id="3033" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近遇到了这样一种情况，我想测试一个方法，给它输入随机的浮点数，并验证它没有边界。我原以为这是一件简单的事情，但是在这篇文章中我们会探究很多陷阱。</p><p id="3e6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从一个规范开始:我想要一个函数，它可以生成没有特殊属性的随机浮点数。即。应使用整个范围，无特殊值，同时使用大正值(如1e38)、小正值(如1e-20)、小负值(如-1e-20)和大负值(如-1e38)。</p><p id="f3d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在所有示例中，我们都假设可以访问该变量:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8975" class="jx jy hi jt b fi jz ka l kb kc">private Random rand = new Random();</span></pre><h2 id="e71f" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">没有范围</h2><p id="0179" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">在Java中，获得一个随机浮点数很容易:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8e99" class="jx jy hi jt b fi jz ka l kb kc">return rand.nextFloat();</span></pre><p id="db60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这种方法不符合我们的规范，因为它只生成范围在[0；1].</p><h2 id="48a8" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">正范围</h2><p id="3f04" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们需要扩大范围。让我们从将范围扩展到[0；N]对于任何N ≤ <code class="du lb lc ld jt b">Float.MAX_VALUE</code>。数学很简单:</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es le"><img src="../Images/fe8dd3d890647982fa7b150874998443.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*qdZD_Wm8vTz7fUnNbIOLvQ.png"/></div></figure><p id="2d95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它直接翻译成代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f47d" class="jx jy hi jt b fi jz ka l kb kc">return rand.nextFloat() * N;</span></pre><h2 id="ee56" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">小范围</h2><p id="e845" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们要做的下一件事是扩展我们的函数，这样我们也可以改变较低的值。我们已经有一个[0；N]，如果我们从期望的[ <em class="lf"> min </em>开始，我们就可以利用这一点；<em class="lf"> max </em>然后从范围的两个分量中减去<em class="lf"> min </em>，如下所示:</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/2ca7208d8c6a4505e0f98507a5300d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*y_D_F2gMxsYssvJRU7EFbw.png"/></div></figure><p id="bb33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导致这种方法:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e078" class="jx jy hi jt b fi jz ka l kb kc">return rand.nextFloat() * (max - min) + min;</span></pre><p id="a92f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对于小范围非常有效，但请记住，我们的初始函数并不适用于所有n。我们在这种情况下的问题是，如果<code class="du lb lc ld jt b">min</code>为负，那么<code class="du lb lc ld jt b">max — min</code>可能会大于<code class="du lb lc ld jt b">Float.MAX_VALUE</code>，从而导致∞。</p><h2 id="e53c" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">大范围</h2><p id="56bd" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">为了解决这个溢出问题，我们可以使用一个技巧:我们可以将范围从中间分开，然后使用一个随机布尔值来确定使用两半中的哪一半。但是我们仍然需要注意范围，因为我们不能将数字相加(由于同样的溢出)。解决方案是将分割推进到每个组件上:</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/8dce70b594a6dcc8d0c39ad36a572d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*a8UX30aLlcxBpa8PXrGRNA.png"/></div></figure><p id="629b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关键的洞见是，无论我们加多少数，如果它们都被除以2，它们就永远不会溢出。该代码遵循以下公式:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1243" class="jx jy hi jt b fi jz ka l kb kc">float midpoint = max/2 + min/2;<br/>float half_range = max/2 - min/2;<br/>int plus_minus = rand.nextBoolean() ? 1 : -1;<br/>return midpoint + plus_minus * rand.nextFloat() * half_range;</span></pre><p id="b745" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个，我们可以在<code class="du lb lc ld jt b">-Float.MAX_VALUE</code>(为什么不是<code class="du lb lc ld jt b">Float.MIN_VALUE</code>)的整个范围内生成浮点？)到<code class="du lb lc ld jt b">Float.MAX_VALUE</code>而不出错。但是，如果我们查看输出，我们只会看到“E36”到“E38”范围内的数字。这是为什么呢？我们的函数不是均匀分布的吗？当我们只依赖均匀分布的随机生成器时，这怎么可能呢？</p><p id="a394" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">起初，这个问题相当微妙。我们确实在整个范围内产生了均匀分布的数字，从绘制它们可以看出这一点。每个数字被选中的概率相同，但是从E37到E38的数字比从E34到E35的数字多1000倍。所以随机选择，我们更有可能选择E值较高的数字。</p><p id="00de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其实我们也不希望他们千篇一律。我们既要大的<em class="lf">又要小的</em>(接近于零)数。</p><h2 id="bee4" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">指数一致</h2><p id="4ad6" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">在这一点上，我们有了新的见解。我们希望数字以它们的位模式均匀分布。因此，我们可以采取的一个策略是生成一个随机的位模式(int ),然后将其转换为float。这种显而易见的方法(<code class="du lb lc ld jt b">(float)rand.nextInt()</code>)不起作用，因为Java试图保留值而不是位模式。所以我们需要使用:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c4bc" class="jx jy hi jt b fi jz ka l kb kc">return Float.intBitsToFloat(rand.nextInt());</span></pre><p id="c64a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">画出这个结果，看起来我们只产生了0附近的数字，但那是因为我们现在需要在对数标度上画出它。这样做我们看到它是一条直线，对应于在每个[Ex；E(x+1)]范围。</p><p id="21a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有最后一个问题，它还为特殊值<code class="du lb lc ld jt b">Float.NaN</code>、<code class="du lb lc ld jt b">Float.NEGATIVE_INFINITY</code>和<code class="du lb lc ld jt b">Float.POSITIVE_INFINITY</code>生成位模式。</p><h2 id="599e" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">没有特殊值</h2><p id="45d8" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们没有研究我们想要剔除的位模式，也没有想出一些复杂的公式，而是使用了渲染引擎中的一个简单技术。</p><blockquote class="li lj lk"><p id="d685" class="iq ir lf is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">在渲染引擎中，我们有时希望通过圆形光圈进行均匀的光线投射，而不是想出如何在圆形中均匀的公式，我们通过正方形生成光线，然后如果光线在圆形之外，我们简单地重新滚动它。</p></blockquote><p id="025e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重新滚动不需要的值是将一个随机算法域映射到另一个域的标准方法。它实现起来很简单，并且保留了分布:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9fc2" class="jx jy hi jt b fi jz ka l kb kc">float result;<br/>do {<br/>  result = Float.intBitsToFloat(rand.nextInt());<br/>} while (result != Float.NaN<br/>      &amp;&amp; result != Float.POSITIVE_INFINITY<br/>      &amp;&amp; result != Float.NEGATIVE_INFINITY);<br/>return result;</span></pre><p id="4a74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法的唯一缺点是我们不能保证这个算法会终止。事实上，正是因为这个原因，它被称为半算法。但实际上它终止了，而且很快，最重要的是实现起来很快。</p><p id="3a37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，如果你找到了一个简单到可以在推特上发布的实际算法，请发推特给我@themaxipaxi我很想看看。如果你喜欢解决一个问题，像我们一样一步一步地完善它，你应该看看我的关于重构的书:</p><figure class="jo jp jq jr fd ij er es paragraph-image"><a href="https://www.manning.com/books/five-lines-of-code"><div class="er es lo"><img src="../Images/ac2e56b71c80f26c090280c2ea7d0b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*gVCoNzmp-Ua8ui0NQlEVaw.png"/></div></a></figure></div></div>    
</body>
</html>