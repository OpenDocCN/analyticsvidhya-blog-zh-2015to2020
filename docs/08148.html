<html>
<head>
<title>My first deep learning model using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我第一个使用PyTorch的深度学习模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/my-first-deep-learning-model-using-pytorch-406caa278df6?source=collection_archive---------16-----------------------#2020-07-19">https://medium.com/analytics-vidhya/my-first-deep-learning-model-using-pytorch-406caa278df6?source=collection_archive---------16-----------------------#2020-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="aaba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继我之前的帖子<a class="ae jd" rel="noopener" href="/@poojamahajan5131/getting-started-with-deep-learning-359fa9801b86"> <strong class="ih hj">深度学习入门</strong> </a>和<a class="ae jd" rel="noopener" href="/@poojamahajan5131/max-pooling-210fc94c4f11"> <strong class="ih hj"> Max Pooling </strong> </a>之后，在这篇帖子中，我将在Pytorch中构建一个简单的卷积神经网络。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/0d02a15e02cbb249eb9c66119f980c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-H3doTlzvdx3UJJG4ebvrw.jpeg"/></div></figure><p id="b0b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用<strong class="ih hj"> FMNIST数据集</strong>。时尚MNIST数据集由时尚连锁店Zalando的图片组成。它包含60，000幅图像的训练集和10，000幅图像的测试集。每个图像的大小为28 x 28像素，并与来自10个类别的标签相关联。它类似于通常被称为图像识别的“Hello World”的MNIST数据集。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/766935241ff52ba2ca2f87de355d6b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*kMPNMU-HcHbxi-uUP82PeQ.jpeg"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">:D</figcaption></figure><h1 id="0320" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak"> 1。导入所需的库</strong></h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/dc06e88887066a99fb9b172d4dded144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsZT79LCLVnEE-_nupytOQ.png"/></div></div></figure><ul class=""><li id="d62a" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj">火炬</strong> —进口pytorch</li><li id="5b74" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">torch.nn</strong>—py torch提供的torch . nn模块，用于创建和训练神经网络</li><li id="4008" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj"> torch.nn.functional </strong> -这特别提供了直接使用的便捷功能，例如——Relu或我们神经元的“校正线性”激活功能。</li><li id="a7a5" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj"> torch.optim </strong> -实现各种优化算法的包。</li><li id="0e89" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">这个软件包由流行的数据集、模型架构和计算机视觉的通用图像转换组成</li><li id="c681" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj"> torchsummary </strong> —用于获取pytorch中的模型摘要</li><li id="5e4b" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">tqdm</strong>—用于显示迭代进度栏的包</li></ul><h1 id="7d24" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">2.正在加载数据集</h1><p id="cdb5" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">pytorch中的数据加载器有助于简化数据加载。它在给定的数据集上提供了一个iterable。在本练习中，我们将对训练和测试数据集采用64的批量大小。</p><p id="adb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Torchvision的<strong class="ih hj"> transforms </strong>函数用于访问各种图像变换——在这种情况下，转换为张量，然后使用均值和标准差进行归一化(在这种情况下，两者都是0.5)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ln"><img src="../Images/4f6932f7c3653cf3fc8243090b5f1c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sn45KwWyF0vy59K-qZD5bg.png"/></div></div></figure><p id="a610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看它看起来怎么样！！</p><p id="06fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在尝试加载一批测试数据集。从一批的形状来看，我们得到了[64，1，28，28]。这意味着我们有64个28×28像素的灰度示例(即没有RGB通道)。我们可以使用matplotlib绘制其中一些。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lo"><img src="../Images/7bad12385beb70ba82c382d3140cd445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPR-WoGO44TjPMjtXQ_OiA.png"/></div></div></figure><h1 id="d362" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">3.构建网络</h1><p id="2a21" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">现在让我们继续建立我们的网络。我使用二维卷积层的块和这些块之间的Maxpool2d层来构建我的网络。作为激活函数，我选择了<a class="ae jd" href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="noopener ugc nofollow" target="_blank">整流线性单元</a>。使用这些数量的卷积层背后的想法是达到<strong class="ih hj">-至少</strong> <strong class="ih hj">相当于图像大小</strong>(在这种情况下为28)的感受域。</p><p id="02b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> forward() pass </strong>定义了我们使用给定的层和函数序列计算输出的方式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lp"><img src="../Images/6a39e84055cf43ab3eb197a45eea113d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdVilu1DmChiJSWh-r__SA.png"/></div></div></figure><p id="a8eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下公式计算每层后的输出大小:-</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lq"><img src="../Images/3895bf1fd283603faddcd210811caaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_TlBjYulCukfjcXL1DZMw.png"/></div></div></figure><p id="7851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">车型总结</strong></p><p id="526e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型摘要用于了解有多少参数与每一层相关联，以及每一层之后我们的输出形状看起来如何。需要注意的一点是，我们可以将<strong class="ih hj"> torch.nn </strong>层视为包含可训练参数，而<strong class="ih hj"> torch.nn.functional </strong>层则是纯功能性的，没有单独涉及的参数。</p><p id="93e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在GPU上训练Pytorch神经网络很容易。幸运的是，Google Colab让我们可以免费使用GPU。CUDA是NVIDIA开发的并行计算平台和编程模型，用于自带GPU的通用计算。当使用GPU时，我们指定CUDA设备，并将所有输入和目标发送到GPU。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lr"><img src="../Images/6f04259980e47153926d6804a95478fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQN6vWMFVdi_Hx141r4Prg.png"/></div></div></figure><h1 id="1590" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak"> 4。训练模型</strong></h1><p id="1125" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我们首先需要使用model.train() 设置<strong class="ih hj">训练模式。在每个时期对所有训练数据进行迭代。Dataloader处理单个批次的加载。</strong></p><p id="4f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Pytorch中，我们需要将梯度设置为零，因为pytorch会在后续的反向传递中累积梯度。因此，当您开始训练循环时，理想情况下，您应该将梯度归零，以便正确更新参数。</p><p id="3d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们产生网络的输出(正向传递)。计算输出和地面真实标签之间的负对数似然损失。<strong class="ih hj"> backward()用于收集一组新的梯度，使用optimizer.step() </strong>将其传播回每个网络参数。优化器的工作是基于损失函数确定网络将如何更新。优化器使用损失值来更新网络的权重。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ls"><img src="../Images/b6c37c0870086130779fed6089cc568b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aycfZx_s6gQu1umOu_TuQ.png"/></div></div></figure><p id="ee40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">model.eval()或model.train(mode=False)用于告知您正在测试。在我们的测试循环中，我们跟踪正确的预测。使用torch.no_grad，即上下文管理器禁用梯度计算。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lt"><img src="../Images/f90a704b761481230dcd7bdecaa2e0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqVW8gO1UWd2msK5r_nEOw.png"/></div></div></figure><p id="472d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们来训练这个模型，看看它是如何工作的。在这里，我用0.01的学习率和0.9的动量对这个模型进行了3个时期的训练。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lu"><img src="../Images/aceff9534821f534db70175f7e1f805d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AF0HgaH19fl1jBqUCNcTlQ.png"/></div></div></figure><p id="f940" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样，我们最终成功地在pytorch中实现了我们的第一个神经网络，使用卷积和最大池的简单概念作为我们网络的构建模块。</p><p id="3b6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章旨在让你了解如何使用PyTorch的功能编写一个神经网络。我在这个练习中使用了Google Colab。您可以在这个资源库中找到相关的代码:-</p><div class="lv lw ez fb lx ly"><a href="https://github.com/poojamahajan0712/medium_blog/blob/master/FMNIST_Pytorch/Pytorch_FMNIST_basic.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">poojamahajan0712/medium_blog</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">permalink dissolve GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jk ly"/></div></div></a></div><p id="12b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在以后的文章中深入挖掘这些问题的本质细节。在那之前保持安全！！</p></div></div>    
</body>
</html>