<html>
<head>
<title>Converting Boolean-Logic Decision Trees to Finite State Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将布尔逻辑决策树转换为有限状态机</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/converting-boolean-logic-decision-trees-to-finite-state-machines-180ad195abf2?source=collection_archive---------3-----------------------#2020-01-08">https://medium.com/analytics-vidhya/converting-boolean-logic-decision-trees-to-finite-state-machines-180ad195abf2?source=collection_archive---------3-----------------------#2020-01-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="02f6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">更简单、高性能地检测网络安全事件</h2></div><p id="eece" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在分析网络安全事件时，检测算法根据布尔表达式评估属性，以确定事件是否属于某个类别。本文描述了如何将布尔表达式转换为有限状态机，以实现更简单、更高性能的评估。</p><p id="1453" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开源项目Cyberprobe以这种实现为特色。用Python实现了规则到有限状态机(FSM)的转换以及FSM形式的规则的应用。Cyberprobe支持使用数百万条规则，这些规则可以在单个处理器内核上以每秒20万次以上的速度应用。</p><h1 id="5ca3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">问题</strong></h1><p id="00e4" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">将布尔逻辑标准应用于事件解决了许多扫描和检测问题。例如，发生了一个事件，该事件是由与受保护的服务的交互产生的。该事件具有以下属性:</p><ul class=""><li id="930b" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js kv kw kx ky bi translated">源地址:<code class="du kz la lb lc b">123.123.123.123:14001</code></li><li id="77ad" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">目的地地址:<code class="du kz la lb lc b">192.168.0.1:19001</code></li><li id="fed2" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">网址:<code class="du kz la lb lc b">https://myservice.com/path1</code></li></ul><p id="cf84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我试图检测的事物类别的一个或多个布尔表达式:</p><blockquote class="li lj lk"><p id="e6af" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">如果TCP端口号是80或8080，IP地址是10.0.0.1，URL是http://www.example.com/malware.dat或http://example.com/malware.dat…</p></blockquote><p id="28e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目的是对照一大组布尔表达式来分析这种事件的高速率流，以便对事件进行分类。</p><p id="0d63" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于没有内置运算符优先级的英语，布尔表达式很快变得不可读。</p><h1 id="bce1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">布尔表达式</strong></h1><p id="49e4" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">布尔运算符表示为函数，<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>表示属性类型/值匹配项。</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="d078" class="lx ju hi lc b fi ly lz l ma mb">and(<br/>    or(<br/>        tcp:80, tcp:8080<br/>    ),<br/>    ipv4:10.0.0.1,<br/>    or(<br/>        url:http://www.example.com/malware.dat,<br/>        url:http://example.com/malware.dat<br/>    )<br/>)</span></pre><p id="00b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">布尔表达式由、<code class="du kz la lb lc b"><strong class="iz hj">and(…)</strong></code>、<code class="du kz la lb lc b"><strong class="iz hj">or(…)</strong></code>和<code class="du kz la lb lc b"><strong class="iz hj">not(…)</strong></code>函数的组合以及<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>匹配项组成。我使用<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>对匹配术语，因为这在我工作的领域很有用，但是我们也可以很容易地使用字符串。</p><h1 id="8e68" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">输入</strong></h1><p id="9544" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">当评估事件的属性时，属性是<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>对。例如</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="c883" class="lx ju hi lc b fi ly lz l ma mb">ipv4:123.123.123.123<br/>tcp:14001<br/>ipv4:192.168.0.1<br/>tcp:19001<br/>url:https://myservice.com/path1</span></pre><h1 id="df59" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">基本评估算法</h1><p id="c65b" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">使用<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>对输入评估布尔表达式的简单方法是将布尔表达式表示为一棵树，然后使用<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>对触发评估。观察值存储在树中。</p><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mc"><img src="../Images/ac3707a3ad5be94c9f8f515f25daf7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crA5LfNXaLhJCm--toMAJA.png"/></div></div></figure><p id="38eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据事件评估布尔树的规则是:</p><ul class=""><li id="3e18" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js kv kw kx ky bi translated">对于每个<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>属性，查看布尔树中是否有对应的<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>项。如果存在，将term node设置为true，并计算父节点。</li><li id="40ca" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">在对父节点<strong class="iz hj"> <em class="ll">或</em> </strong>求值时，当任一子节点为真时，则<strong class="iz hj"> <em class="ll">或</em> </strong>节点为真，并对其父节点求值。</li><li id="b159" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">评估父节点<strong class="iz hj"> <em class="ll">和</em> </strong>时，如果所有子节点都为真，则<strong class="iz hj"> <em class="ll">和</em> </strong>节点为真，评估其父节点。</li><li id="64be" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">当评估一个父<strong class="iz hj"> <em class="ll">非</em> </strong>节点时，当子节点为真时，<strong class="iz hj"> <em class="ll">非</em> </strong>节点为假。一旦所有属性的评估完成，如果一个<strong class="iz hj"> <em class="ll">而不是</em> </strong>节点没有因为其子节点为假而被视为假，则它被评估为真，并且它的父节点被评估。</li></ul><p id="3ea1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个简单的算法。本文的重点是提供一种优化。</p><p id="d7e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个折衷，将布尔树转换成FSM的算法是计算密集型的:它的复杂性与节点的数量成非线性关系:它与组合节点(如下所述)和<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>项的乘积成线性关系。在实际场景中，当规则被解析时，布尔表达式将被转换成FSM，此后FSM可以被多次使用。</p><h1 id="429f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">转换为有限状态机</h1><h2 id="91d5" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated"><strong class="ak">第一步:识别“基本状态”</strong></h2><p id="eed6" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">为了找到FSM，我们寻找布尔树中的所有节点，在这些节点中，随着评估的进行，需要观察状态。如果你看上面的例子，你可以看到<strong class="iz hj"> <em class="ll">或</em> </strong>节点和<strong class="iz hj"> <em class="ll">和</em> </strong>节点是不同的。<strong class="iz hj"> <em class="ll">或</em> </strong>节点的子节点在被评估为真时立即导致其父节点为真，因此不需要保持关于<strong class="iz hj"> <em class="ll">或</em> </strong>节点的子节点的状态。然而，当<strong class="iz hj"> <em class="ll">和</em> </strong>节点的子节点为真时，这可能需要被存储用于以后的评估，以确定<strong class="iz hj"> <em class="ll">和</em> </strong>节点可以被评估为真的点。</p><p id="c56e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对<strong class="iz hj"> <em class="ll">而非</em> </strong>节点的评估也是复杂的:一个<strong class="iz hj"> <em class="ll">而非</em> </strong>节点可以被评估为真，因为它的子节点在分析期间保持假评估。</p><p id="b66a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们这里陈述的规则是，布尔树中的某些节点可以描述为<strong class="iz hj"> <em class="ll">基本状态</em> </strong>:</p><ol class=""><li id="2bbe" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js mx kw kx ky bi translated">树根本质上是一个<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>状态，这意味着布尔表达式为真。这是一个基本状态。</li><li id="b68f" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated">一个<strong class="iz hj"> <em class="ll">非</em> </strong>节点永远不是一个<strong class="iz hj"> <em class="ll">基本状态</em> </strong>。</li><li id="fdfd" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated"><strong class="iz hj"> <em class="ll">和</em> </strong>节点的子节点是基本状态，除非它是<strong class="iz hj"> <em class="ll">而不是</em> </strong>节点。</li><li id="dfe3" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated">一个<strong class="iz hj"> <em class="ll">非</em> </strong>节点的子节点是一个基本状态，除非它是一个<strong class="iz hj"> <em class="ll">非</em> </strong>节点本身。</li></ol><p id="47e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，基本状态是两个<strong class="iz hj"> <em class="ll">或</em> </strong>节点，以及<code class="du kz la lb lc b"><strong class="iz hj">ip:10.0.0.1</strong></code>节点。所有人都符合规则3。</p><p id="0043" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该实现给每个状态一个状态名，由字母<strong class="iz hj"> <em class="ll"> s </em> </strong>加上一个唯一的数字组成，以深度优先的方式分配。带有状态的布尔树示例如下所示；<strong class="iz hj"> <em class="ll">和</em> </strong>节点的三个子节点是给定的状态，父节点<strong class="iz hj"> <em class="ll">和</em> </strong>代表命中状态。</p><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mc"><img src="../Images/65920a509a311c176a85f0446b8ab4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gF1tq14B7uToplMFmMrB7g.png"/></div></div></figure><h2 id="16a7" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated"><strong class="ak">第二步:识别“组合状态”</strong></h2><p id="f6ce" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">基本状态是需要记录部分状态的节点。FSM中的一个节点同时代表<em class="ll">所有</em>状态，即所有有效的基本状态组合。于是<strong class="iz hj"> <em class="ll">组合状态</em> </strong>集合包含了<strong class="iz hj"> <em class="ll">基本状态</em> </strong>的所有组合。这包括空集和所有状态的联合。</p><p id="8295" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">组合状态需要有一个状态名:在我的实现中，我通过排序将状态组合成一个名称，用一个前面带<code class="du kz la lb lc b"><strong class="iz hj">s</strong></code>的连字符分隔状态号。例如，状态<code class="du kz la lb lc b"><strong class="iz hj">s4</strong></code>、<code class="du kz la lb lc b"><strong class="iz hj">s7</strong></code>、<code class="du kz la lb lc b"><strong class="iz hj">s13</strong></code>的组合被称为<code class="du kz la lb lc b"><strong class="iz hj">s4–7-13</strong></code>。</p><p id="5ffa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">空集有一个特殊的名字，我们称之为<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>。它表示FSM的初始状态，其中没有任何信息是已知的。</p><p id="cf46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一种特殊的状态<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>,用于描述包括根节点评估为真的基本状态的任意组合。其他状态的组合被忽略。</p><p id="2556" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，组合状态集包括:</p><ul class=""><li id="3fac" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>:空集</li><li id="075b" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">s3</strong></code>:第一个<strong class="iz hj"> <em class="ll">或</em> </strong>节点:</li><li id="9053" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">s4</strong></code>:节点<code class="du kz la lb lc b"><strong class="iz hj">ip:10.0.0.1</strong></code></li><li id="12b7" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">s7</strong></code>:第二个<strong class="iz hj"> <em class="ll">或</em> </strong>节点</li><li id="bd35" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">s3-4</strong></code>:第一个<strong class="iz hj"> <em class="ll">或</em> </strong>节点和<code class="du kz la lb lc b"><strong class="iz hj">ip:10.0.0.1</strong></code></li><li id="982d" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">s4-7</strong></code><strong class="iz hj"><em class="ll">:</em></strong><code class="du kz la lb lc b"><strong class="iz hj">ip:10.0.0.1</strong></code>节点和第二个<strong class="iz hj"> <em class="ll">或</em> </strong>节点</li><li id="0b2c" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">s3-7</strong></code>:第一个和第二个<strong class="iz hj"> <em class="ll">或</em> </strong>节点</li><li id="960a" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated"><code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code> <strong class="iz hj"> <em class="ll"> : </em> </strong>根节点</li></ul><h2 id="872d" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated"><strong class="ak">第三步:找到所有匹配项</strong></h2><p id="f0b4" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">这是布尔表达式树中所有<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>匹配节点的集合。</p><h2 id="0c43" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated"><strong class="ak">步骤4:查找所有转场</strong></h2><p id="e5d5" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">这一步本质上是计算出所有的<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>匹配节点对所有的组合状态做了什么。有一个特殊的匹配术语，<code class="du kz la lb lc b"><strong class="iz hj">end:</strong></code>，用于评估术语列表完成时<strong class="iz hj"> <em class="ll">而非</em> </strong>节点会发生什么。</p><p id="e3da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">算法是:</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="25d8" class="lx ju hi lc b fi ly lz l ma mb">For every combination state:<br/>    Work out the state name of that 'input' combination state<br/>    For every match term:<br/>        Given the input state<br/>        What state results from evaluating that term as true?<br/>        Work out the state name of that 'output' combination state<br/>        Record a transition (input, match term, output)<br/>    Given the input state<br/>    What state results from evaluating end: as true?<br/>    Work out the state name of that 'output' combination state<br/>    Record a transition (input, end:, output)</span></pre><p id="5ca4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这个分析，当整个布尔表达式评估为真时，即布尔表达式的根节点为真时，我们给它一个特殊的名称<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>。</p><p id="f778" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是一套完整的三元组:<strong class="iz hj"> <em class="ll">(输入，术语，输出)</em> </strong>。如果输入和输出状态相同，我们可以忽略转换，这样FSM只包含改变状态的边沿。</p><p id="ea1e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，FSM有一些低效之处:FSM可能有一些区域无法从<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>导航到。这将在下一步中解决。</p><h2 id="b763" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated"><strong class="ak">第五步:移除无效过渡</strong></h2><p id="25ab" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">不是所有的组合状态都可以从<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>到达，因此发现的一些转换可以作为不相关的被丢弃。</p><p id="9818" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先构建一组可以导航到<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>的状态:</p><ol class=""><li id="b443" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js mx kw kx ky bi translated">创建一个仅包含组合状态<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>的集合。</li><li id="acf1" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated">迭代FSM，添加导航到集合中任何状态的所有转换。</li><li id="5d45" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated">重复2。直到发现完整的状态集。</li></ol><p id="046d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们知道了所有可能导致<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>的状态。然而，将会有导致不在该集合中的状态的转变，因此永远不能行进到<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>。因此，对无效转换的第一个简化是将所有不在这个集合中的转换减少到名为<code class="du kz la lb lc b"><strong class="iz hj">fail</strong></code>的单个状态。</p><p id="6572" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">FSM还有第二个简化:有些状态从<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>开始就不可导航，可以删除:</p><ol class=""><li id="4764" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js mx kw kx ky bi translated">构造一个只包含<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>的集合。</li><li id="a6c6" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated">迭代FSM，找到从集合中的任何状态都有导航的所有转换。</li><li id="31d9" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js mx kw kx ky bi translated">重复2。直到发现该组状态。</li></ol><p id="3426" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们知道了FSM中不可触及的区域，它们可以被移除。</p><h2 id="54f0" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated"><strong class="ak">合成有限状态机</strong></h2><p id="50c8" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">上述二叉树的有限状态机描述如下。<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>状态代表初始FSM状态。<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>状态表示布尔表达式成功评估为真。我们已经提到了<code class="du kz la lb lc b"><strong class="iz hj">fail</strong></code>状态，该状态仅在使用<strong class="iz hj"> <em class="ll">而非</em> </strong>表达式时出现，不会作为上述布尔表达式的结果出现。下面是一个例子。</p><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es my"><img src="../Images/f93d60c593652438726b078dcf43093e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Hv1aT81nSIc_ysbOEyb7A.png"/></div></div></figure><h2 id="5f9d" class="lx ju hi bd jv mk ml mm jz mn mo mp kd jg mq mr kf jk ms mt kh jo mu mv kj mw bi translated">使用有限状态机</h2><p id="99fe" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">使用FSM评估布尔表达式很简单:</p><ul class=""><li id="6277" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js kv kw kx ky bi translated">FSM在<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>状态下启动。</li><li id="7438" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">当发现属性时，将<code class="du kz la lb lc b"><strong class="iz hj">type:value</strong></code>与当前状态的转换进行比较。如果存在转换，则FSM进入新状态。</li><li id="9051" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">当达到<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>状态时，这相当于布尔表达式评估为真。</li><li id="0206" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">当达到<code class="du kz la lb lc b"><strong class="iz hj">fail</strong></code>状态时，不需要进一步的属性发现，并且评估可以快速失败。</li></ul><p id="3fcb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于每一项，只需要一次FSM查找，这意味着这种方法具有性能优势。</p><h1 id="fa9c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">示例2:使用not</h1><p id="96f1" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">对于本例，使用的是<strong class="iz hj"> <em class="ll">而不是</em> </strong>节点:</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="9fe1" class="lx ju hi lc b fi ly lz l ma mb">and(<br/>    not(<br/>        or(<br/>            tcp:8081, tcp:8082<br/>        )<br/>    ),<br/>    and(<br/>        tcp:80,<br/>        or(<br/>            url:http://www.example.com/malware.dat,<br/>            url:http://example.com/malware.dat<br/>        )<br/>    )<br/>)</span></pre><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mz"><img src="../Images/b05b0ebcfa5aec4acda1cee10c22255c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_K63qN_bo2aYtlRdRkQKyA.png"/></div></div></figure><p id="fec1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在删除无效转换和发现故障状态之前查看此图是很有趣的。一些示例工件:</p><ul class=""><li id="f213" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js kv kw kx ky bi translated">没有到仅由状态<code class="du kz la lb lc b"><strong class="iz hj">s9</strong></code>组成的组合状态的转换。这是因为在没有将<code class="du kz la lb lc b"><strong class="iz hj">s5</strong></code>和<code class="du kz la lb lc b"><strong class="iz hj">s8</strong></code>都评估为真的情况下，不可能达到这种状态。有从<code class="du kz la lb lc b"><strong class="iz hj">s9</strong></code>到hit的转换，但是没有通向<code class="du kz la lb lc b"><strong class="iz hj">s9</strong></code>状态的路径，所以它们永远不会被采用。</li><li id="7c65" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">状态<code class="du kz la lb lc b"><strong class="iz hj">s5-8</strong></code>同样无效，如果<code class="du kz la lb lc b"><strong class="iz hj">s5</strong></code>和<code class="du kz la lb lc b"><strong class="iz hj">s8</strong></code>被评估为真，<code class="du kz la lb lc b"><strong class="iz hj">s9</strong></code>也为真。在这两种情况下，这个条件的有效状态都是<code class="du kz la lb lc b"><strong class="iz hj">s5-8-9</strong></code>。这导致具有两个节点的FSM的不可到达部分不与FSM的其余部分连接。</li><li id="fe66" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">任何<code class="du kz la lb lc b"><strong class="iz hj">s3</strong></code>为真的状态都不能导致<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>，因为根<strong class="iz hj"> <em class="ll">和</em> </strong>节点必然为假。所有包含<code class="du kz la lb lc b"><strong class="iz hj">s3</strong></code>的节点都可以被替换为<code class="du kz la lb lc b"><strong class="iz hj">fail</strong></code>状态。</li></ul><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es na"><img src="../Images/559ea48af35cf4b017a9e7b0f730dd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsZDI75jGuunnlH4FdXNpQ.png"/></div></div></figure><p id="95c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在移除无效转换和映射到失败状态之后，FSM更容易理解:</p><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nb"><img src="../Images/a38853bef9a855ba2ab5aac69e926175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f86bpVgie3EYUowtp5tnyQ.png"/></div></div></figure><p id="d83c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个例子说明了<code class="du kz la lb lc b"><strong class="iz hj">fail</strong></code>状态:一旦转换导致这个状态，就不可能有进一步的信息允许转换到<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>状态。发现<code class="du kz la lb lc b"><strong class="iz hj">tcp:8081</strong></code>或<code class="du kz la lb lc b"><strong class="iz hj">tcp:8082</strong></code>处于任何状态都会导致转换到<code class="du kz la lb lc b"><strong class="iz hj">fail</strong></code>状态。根据您的分析策略，失败状态可能是有用的:它可能是快速失败和进一步评估的捷径。该示例还说明了导致<code class="du kz la lb lc b"><strong class="iz hj">hit</strong></code>的特殊<code class="du kz la lb lc b"><strong class="iz hj">end:</strong></code>术语。</p><h1 id="7e95" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">示例3:更多状态</h1><p id="6550" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">由于所有的<strong class="iz hj"> <em class="ll">和</em> </strong>条件，这个例子需要保存更多的状态。</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="5919" class="lx ju hi lc b fi ly lz l ma mb">and(<br/>    or(<br/>         url:http://www.example.com/malware.dat,<br/>         url:http://example.com/malware.dat<br/>    ),<br/>    ipv4:10.0.0.1,<br/>    not(<br/>        and(<br/>            or(<br/>                tcp:8081,<br/>                tcp:8082<br/>            ),<br/>            ipv4:10.0.0.2<br/>        )<br/>    )<br/>)</span></pre><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nc"><img src="../Images/b1e9d33b01cb1268353cb0f3df542a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtuhnm8L394fbIUqN_nzMQ.png"/></div></div></figure><p id="86d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果得到的FSM具有许多状态:</p><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es nd"><img src="../Images/8527b7d92a5042ae05f9ed8dc50e0198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8_Ym3Oi5uiZTIjd_dLUWQ.png"/></div></div></figure><h1 id="bd19" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">同时评估多个规则</h1><p id="c2b0" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">FSM模型有助于使用大量规则进行高性能扫描，每个规则都使用上述方法转换为FSM。虽然理论上可以从单个FSM制造出超精细FSM，但是FSM的尺寸很快变得难以控制。因为对于该组有贡献的FSM中的每个状态组合，在超级FSM中需要有单个状态。</p><p id="cc6d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，同时跟踪大量的FSM状态可能是计算密集型的。</p><p id="a5b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一种简单的评估方法是识别一组<strong class="iz hj"> <em class="ll">启动器</em> </strong>，它们是每个FSM中脱离<code class="du kz la lb lc b"><strong class="iz hj">init</strong></code>状态的一组项。如果在分析属性时检测到任何启动器，则相应的FSM将被激活，并放在FSM集上，在随后的匹配项评估中跟踪该FSM集的状态变化。这种方法减少了需要跟踪的FSM的数量。我发现在实践中，这导致了用于评估的一小组FSM。</p><p id="be5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这种方法，使FSM快速失效并将其从被跟踪的FSM集合中移除是不合适的；必须跟踪FSM到故障状态，以防止FSM随后被重新激活。</p><h1 id="f03d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">实施:网络调查指标</h1><p id="ab83" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">cyberprobe 项目包括一个以JSON格式编写规则的方法<a class="ae ne" href="https://cybermaggedon.github.io/cyberprobe-docs/cyberprobe.html#Cyberprobe-indicator-format" rel="noopener ugc nofollow" target="_blank">。有许多实用程序可以解析规则格式并输出FSM信息，例如<code class="du kz la lb lc b"><strong class="iz hj">indicators-show-fsm</strong></code>获取一个规则/指示器文件并转储文件中每个规则的FSM。这是以人类可读的形式显示状态转换的输出:</a></p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="eb6e" class="lx ju hi lc b fi ly lz l ma mb">[indicators]$ <strong class="lc hj">indicators-show-fsm case1.json</strong> <br/>3ce77704-abe4–4527–84e6-ed6a745aebcf: URL of a page serving malware<br/> init — tcp:8080 -&gt; s6<br/> init — tcp:80 -&gt; s6<br/> init — url:http://example.org/malware.dat -&gt; s3<br/> init — url:http://www.example.org/malware.dat -&gt; s3<br/> s3 — tcp:8080 -&gt; hit<br/> s3 — tcp:80 -&gt; hit<br/> s6 — url:http://example.org/malware.dat -&gt; hit<br/> s6 — url:http://www.example.org/malware.dat -&gt; hit</span></pre><p id="496d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kz la lb lc b"><strong class="iz hj">indicators-graph-fsm</strong></code>是一个实用程序，它接受一个规则/指示器文件和一个规则ID，并输出一个描述FSM的Graphviz格式的图，这就是我如何生成本文中的图:</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="0dea" class="lx ju hi lc b fi ly lz l ma mb">[indicators]$ <strong class="lc hj">indicators-graph-fsm case1.json \<br/>    3ce77704-abe4–4527–84e6-ed6a745aebcf &gt; graph.dot</strong><br/>[indicators]$ <strong class="lc hj">dot -Tpng graph.dot &gt; graph.png</strong></span></pre><p id="a623" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kz la lb lc b"><strong class="iz hj">indicators-dump-fsm</strong></code>是一个获取指示器文件并以JSON格式输出FSM的实用程序。</p><p id="34b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用<code class="du kz la lb lc b"><a class="ae ne" href="https://github.com/cybermaggedon/cyberprobe/blob/master/indicators/cyberprobe/fsm_extract.py" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj">cyberprobe.fsm_extract</strong></a></code>模块在代码中嵌入FSM转换:</p><pre class="lp lq lr ls fd lt lc lu lv aw lw bi"><span id="73a9" class="lx ju hi lc b fi ly lz l ma mb">#!/usr/bin/env python3</span><span id="5442" class="lx ju hi lc b fi nf lz l ma mb">import sys<br/>import cyberprobe.fsm_extract as fsme<br/>from cyberprobe.logictree import And, Or, Not, Match</span><span id="57ff" class="lx ju hi lc b fi nf lz l ma mb">expression = And([<br/>    Or([<br/>        Match("tcp", "80"), Match("tcp", "8080")<br/>    ]),<br/>    Match("ipv4", "10.0.0.1"),<br/>    Or([<br/>        Match("url", "<a class="ae ne" href="http://www.example.com/malware.dat" rel="noopener ugc nofollow" target="_blank">http://www.example.com/malware.dat</a>"),<br/>        Match("url", "http:/example.com/malware.dat")<br/>    ])<br/>])</span><span id="07c9" class="lx ju hi lc b fi nf lz l ma mb">fsm = fsme.extract(expression)</span><span id="94c3" class="lx ju hi lc b fi nf lz l ma mb"># Dump out FSM<br/>for v in fsm:<br/>    for w in v[1]:<br/>        print("  %s -- %s:%s -&gt; %s" % (v[0], w[0], w[1], v[2]))</span></pre><h1 id="0057" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">简单说一下性能</h1><p id="d008" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">为了对我的算法进行基准测试，我将FSM方法的性能与上面“基本算法”中讨论的基本布尔树算法进行了比较，两者都用Python进行了编码。下图以使用中的规则数为x轴，以事件处理率为y轴。这是显示正在使用的规则数量如何影响事件吞吐量的一种方式。橙色线代表FSM的性能。您可以看到，使用的规则数量对算法吞吐量的影响非常小。注意x轴上的对数刻度。</p><p id="8d73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是在我的旧MacBook上的VirtualBox上运行的，例如，期望从云虚拟机获得更好的性能。</p><p id="33c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是对性能的一个快速浏览，也许我会在后面写一篇关于性能的后续文章。</p><figure class="lp lq lr ls fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es ng"><img src="../Images/cce21aebe25fcc08da9069fa775b23c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nK03iNjGcLfqU8T55lwHeA.png"/></div></div></figure><h1 id="6a19" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">结论</h1><p id="a004" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">在本文中，我讨论了:</p><ul class=""><li id="5fa0" class="kq kr hi iz b ja jb jd je jg ks jk kt jo ku js kv kw kx ky bi translated">布尔表达式如何表示为树</li><li id="ba7e" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">将布尔表达式映射到有限状态机</li><li id="002a" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">FSM的使用如何简化检测逻辑并实现性能优势</li><li id="5f6e" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">如何使用多个有限状态机计算并发布尔表达式</li><li id="7478" class="kq kr hi iz b ja ld jd le jg lf jk lg jo lh js kv kw kx ky bi translated">FSM方法在开源cyberprobe项目中实现</li></ul></div></div>    
</body>
</html>