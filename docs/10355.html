<html>
<head>
<title>Cluster Analysis with DBSCAN : Density-based spatial clustering of applications with noise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DBSCAN的聚类分析:基于密度的带噪声应用程序空间聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cluster-analysis-with-dbscan-density-based-spatial-clustering-of-applications-with-noise-6ade1ec23555?source=collection_archive---------4-----------------------#2020-10-15">https://medium.com/analytics-vidhya/cluster-analysis-with-dbscan-density-based-spatial-clustering-of-applications-with-noise-6ade1ec23555?source=collection_archive---------4-----------------------#2020-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9b72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di"> C </span>聚类分析(luster Analysis)是一种无监督的机器学习方法，将数据点划分为簇或组，使得一个簇/组中的所有数据点具有相似的属性或特征。聚类分析有四个主要类别:分区方法(K-means)、层次方法(BIRCH)、基于密度的方法(DBSCAN)和基于网格的方法。</p><p id="fa60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，所有的聚类算法都有相同的方法，即寻找数据点之间的相似性并将它们分组在一起。这里我们将重点介绍基于密度的聚类方法DBSCAN(含噪声应用的基于密度的空间聚类)方法。</p><p id="4f57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jm">什么是基于密度的聚类？<br/> </em> </strong> It <strong class="ih hj"> </strong>是一种在数据中识别与众不同的聚类的方法，其核心思想是，一个聚类是一组高数据点密度，通过低数据点密度的区域与其他此类聚类分开。主要思想是找到高度密集的区域，并将它们视为一个集群。它可以很容易地从大量包含噪声和异常值的数据中发现不同形状和大小的簇。</p><p id="0f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DBSCAN算法使用两个主要参数:</p><ul class=""><li id="824b" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> minPts: </strong>被认为是密集的区域中聚集在一起的点的最小数量(阈值)，即可以形成一个聚类的数据点的最小数量</li><li id="5ba6" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj"> eps (ε): </strong>用于定位任意点邻域内的点的距离度量。</li></ul><p id="b03c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法考虑了两个概念，称为密度可达性和密度连通性。</p><ul class=""><li id="bc3b" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj">密度可达性</strong>:如果一个点与另一个点在特定距离(eps)之内，则该点可以从另一个点到达，这表明一个集群有多稠密可以到达。</li><li id="b08a" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">密度连接:</strong> DBSCAN涉及基于传递性的链接方法，以确定点是否位于特定的簇中。例如，如果a- &gt; b- &gt; c- &gt; d，其中p- &gt; q表示q在p的邻域内，则a点和d点可以连通。</li></ul><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/c6fc13122fbdeb51380930b299bd7d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MH9tyNcD5g6hp9UuPIR1cQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">密度可达性和密度连通性</figcaption></figure><p id="a22f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种方法中，有三种不同类型的数据点:</p><ol class=""><li id="bdd0" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc kr jt ju jv bi translated"><strong class="ih hj">核心数据点:</strong>距离“ε”内至少有“minPts”的数据点。</li><li id="7c14" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc kr jt ju jv bi translated"><strong class="ih hj">边界数据点:</strong>距离核心数据点“ε”以内的数据点，但不是核心点。</li><li id="afcd" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc kr jt ju jv bi translated"><strong class="ih hj">噪声数据点:</strong>既不是核心数据点也不是边界数据点的数据点。</li></ol><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ks"><img src="../Images/33808fab0a9e1c280af1c4ecfe3f281b.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*A68mP2yO_QtFJHcgYdlDHg.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">点的类型</figcaption></figure><p id="0671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">DBS can聚类的算法步骤</strong></p><ol class=""><li id="7b2d" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc kr jt ju jv bi translated">最初，它从一个随机的未访问的起始数据点开始。'ɛ'距离内的所有点都被归类为邻域点。</li><li id="6529" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc kr jt ju jv bi translated">它需要邻域内最小数量的“minPts”点来开始聚类过程。否则，该点将被标记为“噪声”</li><li id="2b31" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc kr jt ju jv bi translated">距离'ɛ'以内的所有点都成为同一个集群的一部分。对添加到群集组的所有新点重复该过程。继续下去，直到它访问并标记该聚类的'ɛ'邻域内的每个点。</li><li id="07ff" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc kr jt ju jv bi translated">在该过程完成时，它从新的未访问点再次开始，从而导致发现更多的聚类或噪声。在该过程的最后，确保将每个点标记为聚类或噪声。</li></ol><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kt"><img src="../Images/b7f0dad95670613ede8ad8cc8bf4067d.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*WBRWZwSeIw-V4Hw9-_0xrQ.gif"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">DBSCAN的工作</figcaption></figure><p id="75ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们使用来自<a class="ae ku" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html#sklearn.datasets.make_circles" rel="noopener ugc nofollow" target="_blank"> sklearn.datasets </a>和DBSCAN模块的样本数据集实现相同的功能，其中'<strong class="ih hj">【ε】'为0.3，'<strong class="ih hj"> minPts' </strong>为10。</strong></p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="3100" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，执行相同的操作，我们可以发现，它将所有数据点分类为两个圆形聚类，并且离群数据点(黑色中的数据点)被视为噪声。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kx"><img src="../Images/05f3df5fe6248dc0bb3a5bf2d25c9766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*qjIc4xmvlQ_Ma4i71V6fig.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">聚类的输出</figcaption></figure><p id="351b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在问题来了，“当我们有更简单的算法作为k-means时，为什么要进行DBSCAN？”<br/>  K-means算法倾向于只形成<strong class="ih hj">球形簇</strong>。当数据本质上不是球形时，即在所有方向上变化相等时，它会失败。此外，K-means对异常值敏感，所以基本上数据点的微小变化可能会影响聚类结果。此外，DBSCAN自己检测集群的数量，不需要任何先验知识。然而，K-means不是这种情况，我们需要在建模之前决定聚类‘K’的数量<strong class="ih hj"/>。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es ky"><img src="../Images/228789153e2df481e0674bf2eebd6f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPQZZ1xTOjhfV_8rwe3DjQ.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">K均值和DBSCAN的区别</figcaption></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="6160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里可以参考<strong class="ih hj"> GitHub代码</strong>:<a class="ae ku" href="https://github.com/kavyagajjar/Clustering/blob/main/DBSCAN/Cluster_Analysis_with_DBSCAN.ipynb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/kavyagajjar/Clustering/blob/main/DBS can/Cluster _ Analysis _ with _ DBS can . ipynb</a></p><p id="6980" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，请参考此<a class="ae ku" href="https://scikit-learn.org/stable/auto_examples/cluster/plot_cluster_comparison.html#sphx-glr-auto-examples-cluster-plot-cluster-comparison-py" rel="noopener ugc nofollow" target="_blank">链接</a>了解不同集群技术之间的差异</p></div></div>    
</body>
</html>