<html>
<head>
<title>Python Generators/Coroutines/Async IO with examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python生成器/协同例程/异步IO及示例</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-generators-coroutines-async-io-with-examples-28771b586578?source=collection_archive---------1-----------------------#2020-04-12">https://medium.com/analytics-vidhya/python-generators-coroutines-async-io-with-examples-28771b586578?source=collection_archive---------1-----------------------#2020-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="63fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我做的一项咨询工作中，我使用了python asyncio，并理解了其简单语法中的困难。需要阅读一些博客和例子来理解它是如何工作的。这个主题是压倒性的，因为它与生成器/旧协程语法的历史有关，并且需要一些关于一些概念的基础知识来更好地理解。</p><p id="b061" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想分享我的学习，这将有助于理解核心基础知识和简短的定义和简单的代码示例，这样使用asyncio会更容易一些。:).</p><p id="3a6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">话题</strong></p><p id="1864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)简介<br/> 2)历史&amp;工作原理<br/> 3)总结<br/> 4)简单的HTTP API爬虫示例</p><h1 id="03ea" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak"> 1。简介</strong></h1><p id="4bc4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">以下是对主题中使用的术语的简要概述。</p><p id="b8e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kg">并发vs并行</em> </strong></p><ul class=""><li id="78e4" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">并发性——执行两个或更多任务的能力，这些任务可以在重叠的时间段内开始、运行和完成(可以是在多核上真正的并行执行，或者在线程的帮助下在单核机器上进行时间分片)。</li><li id="3468" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">并行性——是指同时并行执行任务。(例如，至少两个线程同时执行)</li><li id="8576" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">线程—线程有助于执行多个任务，这有助于实现并发/并行。在单个python进程中，由于<a class="ae kv" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a> (CPython实现)，线程并行是不可能的。GIL是一种互斥机制，可以防止多个线程同时在Python对象上执行。因此在一个python进程中，一次只能执行多个线程中的一个线程。</li><li id="3801" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">多进程—需要多个python进程来实现并行性。<strong class="ih hj">多处理</strong>包提供本地和远程并发，通过使用子进程而不是线程来有效地避开GIL。</li></ul><p id="a7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kg">同步Vs异步</em> </strong></p><p id="c933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同步/异步是关于计算/任务如何在单个线程的上下文中完成的。</p><ul class=""><li id="c3e2" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">同步—阻止任务的执行。线程(cpu)的计算/任务执行被阻塞/等待操作(IO)完成。<br/>例如，处理http请求的单个线程进行db调用，等待DB响应返回http响应，然后获取下一个http请求。</li><li id="c35d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">异步—任务的并发执行。由单个线程执行的多个任务可以彼此独立地开始、暂停和完成。异步任务不会阻塞通常等待IO的操作。这对于IO受限(磁盘/网络)的用例非常有帮助，因为当我们等待IO时，CPU可以用于其他目的。<strong class="ih hj">python中的协程</strong>有助于实现这一点。<br/> <strong class="ih hj">例如</strong>处理http请求的单线程进行DB调用，并挂起当前任务等待DB响应。同一个线程获得一个新的请求并开始处理。</li></ul><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es kw"><img src="../Images/e2db4fbdb7f6c43d3e51f5a6da19a70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*Lj0pqRqdtBS8ufuF6yPXhw.png"/></div></figure><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/cd9c278a883853be68af27577466451e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYZg5_6xvY9JKcFxNRUmzA.png"/></div></div></figure><h1 id="a1d8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak"> 2)历史&amp;它是如何运作的？</strong></h1><h2 id="27b8" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">迭代器:</h2><p id="3178" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">迭代器是可以被惰性迭代(使用__iter__和__next__)的对象。</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="04d2" class="lj je hi ly b fi mc md l me mf">list = [1, 2]<br/>iterator = iter(list)<br/>print(next(iterator)) <br/>print(iterator.__next__())<br/>print(next(iterator))</span><span id="91cb" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output:<br/></strong>1<br/>2<br/>Raise StopIteration exception since no items to iterate</span></pre><h2 id="d0a1" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated"><strong class="ak">发电机:</strong></h2><p id="130c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">生成器(常规)</strong>是迭代器，有助于简化构建定制逻辑迭代器的复杂性。它为每次运行动态生成一个值(例如，懒惰的生产者)。</p><p id="fb8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何创建？</strong></p><p id="c79a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生成器是任何带有<code class="du mh mi mj ly b">yield</code>语句而不是<code class="du mh mi mj ly b">return</code>语句的普通函数</p><blockquote class="mk"><p id="80b0" class="ml mm hi bd mn mo mp mq mr ms mt jc dx translated"><code class="du mh mi mj ly b">yield</code>是一个关键字，用法和<code class="du mh mi mj ly b">return</code>一样，只是函数会返回一个生成器。<code class="du mh mi mj ly b">yield</code>语句暂停函数，保存其所有状态，然后在后续调用中从上一个状态继续执行(更多信息参见<a class="ae kv" href="https://www.programiz.com/python-programming/generator" rel="noopener ugc nofollow" target="_blank">此处</a>)。</p></blockquote><pre class="mu mv mw mx my lx ly lz ma aw mb bi"><span id="e0bd" class="lj je hi ly b fi mc md l me mf">import random</span><span id="920f" class="lj je hi ly b fi mg md l me mf">def simple_generator():<br/>    yield 10<br/>    yield 100<br/><br/><br/>gen = simple_generator()<br/>print(gen)<br/>print(next(gen))<br/>print(gen.__next__())<br/>try:<br/>    print(next(gen))<br/>except StopIteration:<br/>    print('iteration stopped')</span><span id="23f5" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output:</strong><br/>&lt;<strong class="ly hj">generator object</strong> simple_generator at 0x100fa48b8&gt;<br/>10<br/>100<br/>iteration stopped</span></pre><p id="65ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相同的示例生成器对象可以与“for”循环交互，因为它是一个迭代器</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="b234" class="lj je hi ly b fi mc md l me mf">def magic_pot(start=1, end=1000):<br/>    while True:<br/>        yield random.randint(start, end)</span><span id="60cd" class="lj je hi ly b fi mg md l me mf">gen = magic_pot()<br/>for a in gen:    <br/>    print(a)</span><span id="4af2" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output: </strong>prints numbers without stopping<br/>569<br/>...</span></pre><p id="5dc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以将生成器管道化，类似于Unix管道。</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="d0af" class="lj je hi ly b fi mc md l me mf">def read_file(file_name):<br/>    for row in open(file_name, "r"):<br/>        yield row<br/><br/><br/>def read_csv_row(file_name):<br/>    for row in read_file(file_name):<br/>        yield row.split(',')<br/><br/><br/>def read_csv(file_name):<br/>    for items in read_csv_row(file_name):<br/>        print("Row: " + str(items))<br/><br/><br/>read_csv('test.csv')</span><span id="ca15" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output:<br/></strong>Row: ['col1', 'col2', 'col3\n']<br/>Row: ['1', '2', '3\n']<br/>Row: ['3', '4', '5']</span></pre><p id="da8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kv" href="https://www.python.org/dev/peps/pep-0380/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> PEP-380 </strong> </a> <strong class="ih hj">，</strong> <code class="du mh mi mj ly b"><strong class="ih hj">yield from</strong></code> <strong class="ih hj">是为了简化发电机的管路而引入的)</strong></p><ul class=""><li id="ca67" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">Python 3.3中添加的<code class="du mh mi mj ly b">yield from</code>使得重构生成器以及将它们链接在一起变得更加容易</li></ul><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="8cf6" class="lj je hi ly b fi mc md l me mf"><strong class="ly hj"># Example:</strong></span><span id="fd0a" class="lj je hi ly b fi mg md l me mf">def read_file(file_name):<br/>    for row in open(file_name, "r"):<br/>        yield row</span><span id="8246" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj">"or"</strong></span><span id="af2c" class="lj je hi ly b fi mg md l me mf">def read_file(file_name):<br/>    yield from open(file_name, "r")</span></pre><h2 id="4f72" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">协程:</h2><blockquote class="mk"><p id="71f3" class="ml mm hi bd mn mo mp mq mr ms mt jc dx translated">协程是计算机程序组件，它通过允许在某些位置暂停和恢复执行的多个入口点，来概括用于非抢占式多任务处理的子程序。</p></blockquote><p id="3620" class="pw-post-body-paragraph if ig hi ih b ii mz ik il im na io ip iq nb is it iu nc iw ix iy nd ja jb jc hb bi translated">协程有助于实现协同多任务/ <strong class="ih hj">并发</strong>。它们是通过能够暂停&amp;恢复线程中的任务来帮助并行执行的功能/任务。(例如，异步I/O和其他形式的事件驱动编程或协作多任务)</p><h2 id="2587" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">将<strong class="ak">进化为</strong>“生成器协程”:</h2><p id="713d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">生成器不能在执行期间接受参数，这使得很难控制生成器函数内部的逻辑流(例如，协程A等待来自另一个http调用协程B的响应，协程A挂起-&gt;协程B Http完成-&gt;恢复协程A(来自协程B的Http响应))。</p><p id="e2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用PEP-342(Python 2.5 <strong class="ih hj"> ) </strong>对Generators进行了改进，以支持协同程序，这有助于将参数传递给generators来控制执行流。这最终有助于实现<strong class="ih hj">协同能力</strong>其他形式的<strong class="ih hj">合作多任务</strong>。</p><p id="18ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kv" href="https://www.python.org/dev/peps/pep-0342/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> PEP-342 </strong> </a></p><blockquote class="ne nf ng"><p id="30c8" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated">Python的生成器函数几乎是协程——但不完全是——因为它们允许暂停执行以产生一个值，但不提供在执行恢复时传入的值或异常。</p><p id="dea1" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated"><strong class="ih hj">发生器</strong>不能在其他函数执行时产生控制，除非这些函数本身被表示为发生器，并且外部发生器被编写为响应内部发生器产生的值而产生控制。这使得即使相对简单的用例(如<strong class="ih hj">异步通信</strong>)的实现也变得复杂，因为调用任何函数要么需要生成器阻塞(即不能产生控制)，要么必须在每个需要的函数调用周围添加大量样板循环代码</p><p id="33ee" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated">然而，如果可以在生成器挂起时将值(<strong class="ih hj"> send() </strong>)或异常传递到生成器中，那么一个简单的<strong class="ih hj">协同例程调度程序或蹦床函数</strong>就可以让协程在没有阻塞的情况下相互调用——这对异步应用程序来说是一个巨大的福音。然后，这些应用程序可以编写协同例程，通过将控制权让给I/O调度程序来执行非阻塞套接字I/O，直到数据已经发送或变得可用。与此同时，执行I/O的代码将简单地执行如下操作:</p><p id="9848" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated">data =(yield non blocking _ read(my _ socket，nbytes))</p><p id="f494" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated">为了<strong class="ih hj">暂停执行</strong>直到nonblocking_read()协程产生一个值。</p></blockquote><p id="6888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上PEP增加的改进为生成器增加了<strong class="ih hj"> send()、throw()、close() </strong>方法。<code class="du mh mi mj ly b">yield</code>已被更改为表达式，其行为类似于双向通信工具，如下例所述。</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="f366" class="lj je hi ly b fi mc md l me mf"><strong class="ly hj">Example — generator with send() and yield expression</strong></span><span id="5634" class="lj je hi ly b fi mg md l me mf">import random</span><span id="97a6" class="lj je hi ly b fi mg md l me mf">def magic_pot(start=1, end=1000):<br/>    while True:<br/>        stop = <strong class="ly hj">(yield random.randint(start, end))</strong><br/>        print("stop %s" % stop)<br/>        if stop is True:<br/>            yield "magic pot stopped"<br/>            break</span><span id="84ef" class="lj je hi ly b fi mg md l me mf">gen = magic_pot()<br/>print(gen)<br/>print(gen.send(None))  <strong class="ly hj"># same as next(gen)</strong><br/>print("second")<br/>print(next(gen))<br/>print(gen.send(True))  <strong class="ly hj"># input value for generator</strong></span><span id="915e" class="lj je hi ly b fi mg md l me mf">try:<br/>    print(next(gen))<br/>except StopIteration:<br/>    print('iteration stopped')</span><span id="ff4f" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj">Output:<br/></strong>&lt;generator object magic_pot at 0x10ab39840&gt;<br/>735<br/>second<br/>stop None              <strong class="ly hj"># stop is printed after the next(gen)</strong><br/>506<br/>stop True<br/>magicpot stopped<br/>iteration stopped</span><span id="b7a9" class="lj je hi ly b fi mg md l me mf">In the code, <br/>- '<strong class="ly hj">yield random.randint(start, end)' </strong>returns an output<strong class="ly hj"> </strong>which is triggered by next(gen) or gen.send(None)<strong class="ly hj"><br/>- '(yield random.randint(start, end))' </strong>captures the subsequent iteration input parameter(using gen.send(None) or gen.send(Any))<strong class="ly hj"> </strong>which is used to control flow inside the generator coroutine. In this example, gen.send(True) is passed to stop the coroutine. <br/><strong class="ly hj">- (yield) works bidirectional with output and input.</strong></span></pre><h2 id="740f" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">协同程序与生成器:</h2><p id="1dae" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">协程是一个遵循特定约定的生成器。</p><ul class=""><li id="1dd9" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">协程<strong class="ih hj">将控制权</strong>让给另一个协程，并且<strong class="ih hj">可以从它放弃控制权的地方继续执行</strong>。</li><li id="be76" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">协程是数据消费者，而生成器是数据生产者</li><li id="fe5a" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">可以在初始化后将值发送到基于生成器的协程(使用<strong class="ih hj">send()</strong>&amp;<strong class="ih hj">(yield)</strong>语句)，而常规生成器不能。</li></ul><h2 id="9ba4" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated"><strong class="ak"> AsyncIO — </strong>异步I/O、事件循环、协程和任务</h2><p id="6e2a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><em class="kg">来自Python文档:</em></p><blockquote class="ne nf ng"><p id="c530" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated">该模块为使用协程编写单线程并发代码、通过套接字和其他资源多路复用I/O访问、运行网络客户端和服务器提供了基础架构。我们将看看下面的每个主题。</p><p id="0d7f" class="if ig kg ih b ii ij ik il im in io ip nh ir is it ni iv iw ix nj iz ja jb jc hb bi translated">事件循环是每个asyncio应用程序的核心。事件循环运行异步任务和回调，执行网络IO操作，并运行子进程。应用程序开发人员通常应该使用高级别的asyncio函数，如asyncio.run()，并且应该很少需要引用循环对象或调用其方法。</p></blockquote><h2 id="66f9" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">异步发电机协同程序:</h2><p id="4b23" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在python 3.4中，基于生成器的协同程序是使用新的<a class="ae kv" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>模块库用<code class="du mh mi mj ly b"><a class="ae kv" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine" rel="noopener ugc nofollow" target="_blank">@asyncio.coroutine</a></code> decorator创建的。Asyncio生成器协同程序使用<code class="du mh mi mj ly b">yield from</code>语法来挂起协同程序。</p><p id="5c5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">asyncio协程可以:</p><ul class=""><li id="9105" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">“屈服于”另一个协程</li><li id="4042" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">“屈服于”未来</li><li id="783e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">返回表达式</li><li id="652d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">引发异常</li></ul><p id="0e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mh mi mj ly b">yield from</code>语句将控制权交还给事件循环，让其他协程执行。</p><ul class=""><li id="e45f" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae kv" href="http://www.python.org/dev/peps/pep-0380" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> PEP 380 </strong> </a>中引入了“yield from”语法，代替了生成器协程的原始yield语法。“yield from”用于生成器协程内部。<code class="du mh mi mj ly b">yield from </code>迭代器或本机/生成器协程/未来。</li><li id="eb68" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">允许生成器使用“yield from”调用本机协同程序(<strong class="ih hj"> async def) </strong>，也允许生成器协同程序由本机协同程序使用await表达式调用。</li><li id="5822" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">“yield”用法使它们成为必须迭代的常规生成器/迭代器，并且不能与asyncio方法一起工作。</li></ul><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="2eca" class="lj je hi ly b fi mc md l me mf">import asyncio<br/>import random<br/><br/>@asyncio.coroutine<br/>def compute_coroutine(x):<br/>    yield from asyncio.sleep(random.random()) <strong class="ly hj"># yield from native coroutine</strong><br/>    print(x * 2)<br/><br/>asyncio.run(compute_coroutine(2))</span><span id="77bf" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output<br/>4</strong></span><span id="504f" class="lj je hi ly b fi mg md l me mf">asyncio.run()<br/> - starts compute_coroutine() coroutine<br/> - suspends compute_coroutine() and start asyncio.sleep()<br/> - resumes compute_coroutine()<br/> - coroutines are suspended/executed with the help of asyncio event loop</span><span id="3434" class="lj je hi ly b fi mg md l me mf">--------------------------------------------------------------------</span><span id="61f6" class="lj je hi ly b fi mg md l me mf">@asyncio.coroutine<br/>def coroutine_generator(x):<br/>    for i in range(0, x):<br/>        yield i<br/>    print("input=%s" % x)<br/><br/><br/>asyncio.run(coroutine_generator(2))</span><span id="e066" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output - yield inside coroutine cannot be used with asyncio<br/></strong>RuntimeError: Task got bad yield: 0</span></pre><h2 id="b574" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">本机协同程序:</h2><p id="b4e8" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><code class="du mh mi mj ly b">async/await</code>从Python 3.5开始引入关键字，使协程编程的语法更有意义，是最新的语法。</p><ul class=""><li id="39c1" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">异步定义返回一个<em class="kg">本机协程</em>对象。异步定义函数总是协程，即使没有await。</li><li id="9211" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">常规生成器返回一个<em class="kg">生成器</em>对象</li><li id="ecb8" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">asyncio.coroutine返回<em class="kg">基于生成器的协程对象</em></li><li id="9716" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">types.coroutine返回基于生成器的coroutine对象</li></ul><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="b21e" class="lj je hi ly b fi mc md l me mf">import asyncio<br/>import types<br/><br/>@asyncio.coroutine<br/>def async_gen_data():<br/>    yield 10</span><span id="a981" class="lj je hi ly b fi mg md l me mf"><br/>@types.coroutine<br/>def types_gen_data():<br/>    yield 10<br/><br/><br/>async def async_native_coroutine():<br/>    print('async_native_coroutine')<br/><br/><br/>async def async_native_coroutine_generator():<br/>    print('async_native_coroutine_generator')<br/>    yield 100<br/><br/><br/>print(async_gen_data())<br/>print(types_gen_data())<br/>print(async_native_coroutine())<br/>print(async_native_coroutine_generator())</span><span id="886b" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output:<br/></strong>&lt;<strong class="ly hj">generator</strong> object async_gen_data at 0x10b6c1e58&gt;<br/>&lt;<strong class="ly hj">generator</strong> object types_gen_data at 0x10b6c1e58&gt;<br/>&lt;<strong class="ly hj">coroutine</strong> object async_native_coroutine at 0x10b6d9748&gt;<br/>&lt;<strong class="ly hj">async_generator</strong> object async_native_coroutine_generator at 0x10b709f28&gt;</span><span id="e91d" class="lj je hi ly b fi mg md l me mf">We will see more on @types.coroutine / async_generator in the further sections.</span></pre><h2 id="0b30" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">等待</h2><ul class=""><li id="d125" class="kh ki hi ih b ii kb im kc iq nk iu nl iy nm jc km kn ko kp bi translated">“await”应与async def一起使用。<code class="du mh mi mj ly b">await</code>用于获取协程对象的执行结果</li><li id="35eb" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">async/await是@asyncio.coroutine/'yield from '的最新等效项</li><li id="d5e6" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">await适用于生成器/本机协程对象和使用__await__方法返回迭代器的对象。</li><li id="65d7" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">在引擎盖下，<code class="du mh mi mj ly b">await</code>借用了<code class="du mh mi mj ly b">yield from</code>的实现，并额外检查了它的参数是否确实是可实现的。</li><li id="e989" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">本机/生成器协同程序，未来，任务</strong>是<strong class="ih hj">可实现的</strong></li></ul><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="4336" class="lj je hi ly b fi mc md l me mf"><strong class="ly hj"># example1: async native coroutine</strong></span><span id="6a40" class="lj je hi ly b fi mg md l me mf">import asyncio<br/><br/><br/>async def f1():<br/>    print('before')<br/>    await asyncio.sleep(1)<br/>    print('after 1 sec')<br/></span><span id="8529" class="lj je hi ly b fi mg md l me mf">asyncio.run(f1()) # runs in a event loop and execute</span><span id="34d4" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output<br/></strong>&lt;coroutine object f1 at 0x101d852c8&gt;<br/>after 1 sec</span><span id="7c0d" class="lj je hi ly b fi mg md l me mf">---------------------------------</span><span id="f00d" class="lj je hi ly b fi mg md l me mf">print(f1())</span><span id="594b" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output</strong><br/>RuntimeWarning: coroutine 'f1' was never (coroutine needs to be awaited)</span><span id="b391" class="lj je hi ly b fi mg md l me mf">---------------------------------<br/>await f1()      </span><span id="4c08" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output<br/></strong>SyntaxError: 'await' outside function (should be used inside async function/native coroutine)</span></pre><p id="5bad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">并发协同程序(<em class="kg"> async/await，@ asyncio . coroutine/yield from</em>):</strong></p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="e01d" class="lj je hi ly b fi mc md l me mf">import asyncio<br/>import random</span><span id="7cf2" class="lj je hi ly b fi mg md l me mf">@asyncio.coroutine<br/>def compute(tid, x):<br/>    print("%s: input=%s with sleep=%s" % (tid, x, sleep))<br/>    yield from asyncio.sleep(random.random())  # async future<br/>    return x * 2</span><span id="c0b4" class="lj je hi ly b fi mg md l me mf">@asyncio.coroutine<br/>def print_sum(tid, x):<br/>    result = yield from compute(tid, x)  # return a value<br/>    print("%s: result=%s" % (tid, result))</span><span id="b814" class="lj je hi ly b fi mg md l me mf">async def task(tid, x):<br/>    return await print_sum(tid, x)  # await a coroutine</span><span id="3157" class="lj je hi ly b fi mg md l me mf">async def main():<br/>    await asyncio.gather(<br/>        task("t1", 2),<br/>        print_sum("t2", 3),<br/>        task("t3", 4),<br/>    )</span><span id="6b1a" class="lj je hi ly b fi mg md l me mf">asyncio.run(main())</span><span id="f755" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output - execute 3 tasks concurrently<br/></strong>t1: input=2 with sleep=0.7909687238238471<br/>t2: input=3 with sleep=0.25100171976591423<br/>t3: input=4 with sleep=0.4164068460815761<br/>t2: result=6<br/>t3: result=8<br/>t1: result=4</span><span id="fd47" class="lj je hi ly b fi mg md l me mf"><em class="kg">await asyncio.gather()</em> - Run alls coroutines concurrently inside the event loop and gathers all the results to be returned by main()</span></pre><p id="2cc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协程compute() "yield from "语句将控制权交还给事件循环(暂停)，并在协程<code class="du mh mi mj ly b">asyncio.sleep()</code>完成后继续执行。请注意，<code class="du mh mi mj ly b">asyncio.sleep()</code>本身是一个协程，被阻塞的协程在睡眠后恢复。事件循环基于可运行的协同程序执行，并且输出执行顺序(t1，t2，t3)基于示例中的延迟而变化。</p><h2 id="8a81" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">事件循环:</h2><ul class=""><li id="cfca" class="kh ki hi ih b ii kb im kc iq nk iu nl iy nm jc km kn ko kp bi translated"><a class="ae kv" href="https://www.educative.io/blog/python-concurrency-making-sense-of-asyncio" rel="noopener ugc nofollow" target="_blank">事件循环</a>使用协作调度，这意味着事件循环一次运行一个任务。当一个任务等待Future完成时，事件循环运行其他任务、回调或执行IO操作。任务也可以取消。</li><li id="5696" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">事件循环与一个线程相关联</li><li id="a41c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">SelectorEventLoop —基于<strong class="ih hj">选择器</strong>模块(epoll()/kqueue()/select())的事件循环，用于高级和高效的I/O多路复用。</li><li id="ef71" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">ProactorEventLoop—windows的事件循环</li></ul><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="97fa" class="lj je hi ly b fi mc md l me mf"><strong class="ly hj"># event loop with multiple coroutines calls</strong></span><span id="b105" class="lj je hi ly b fi mg md l me mf">import asyncio<br/>import threading<br/>from asyncio import events</span><span id="c598" class="lj je hi ly b fi mg md l me mf">async def f1():<br/>    print('tid:%s - before' % threading.get_ident())<br/>    await asyncio.sleep(1)<br/>    print('tid:%s - after 1 sec' % threading.get_ident())</span><span id="d87c" class="lj je hi ly b fi mg md l me mf">def run(fn):<br/>    loop = events.new_event_loop()<br/>    loop.run_until_complete(fn)<br/>    loop.close()<br/></span><span id="3268" class="lj je hi ly b fi mg md l me mf">print('tid:%s - start' % threading.get_ident())<br/><strong class="ly hj"># creates 2 new event loop for each run() <br/></strong>run(f1())<br/>run(f1())</span><span id="f912" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output</strong><br/>tid:4638019008 - start<br/>tid:4638019008 - before<br/>tid:4638019008 - after 1 sec<br/>tid:4638019008 - before<br/>tid:4638019008 - after 1 sec</span><span id="1696" class="lj je hi ly b fi mg md l me mf">Event loop uses only unix thread(tid is the same in all outputs) to schedule tasks for each run() which created new_event_loop() every-time.</span></pre><h2 id="6c3c" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated"><strong class="ak">期货</strong></h2><p id="3075" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">一个<code class="du mh mi mj ly b"><a class="ae kv" href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future" rel="noopener ugc nofollow" target="_blank">Future</a></code>是一个特殊的<strong class="ih hj">低级</strong>可调用对象，代表一个异步操作的<strong class="ih hj">最终结果</strong>。Future对象正在等待，这意味着协程将等待，直到Future在其他地方被解析</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="2f74" class="lj je hi ly b fi mc md l me mf">import asyncio</span><span id="bcfb" class="lj je hi ly b fi mg md l me mf">async def num_calc(name, number):<br/>    f = 1<br/>    for i in range(2, number + 1):<br/>        await asyncio.sleep(1)<br/>        f *= i<br/>    print(f"Task {name}: multiplier({number}) = {f}")<br/>    return f</span><span id="ff52" class="lj je hi ly b fi mg md l me mf">async def main():<br/>    <strong class="ly hj">#</strong> <strong class="ly hj">schedule calls concurrently &amp; gathers all async future results</strong><br/>    results = await asyncio.gather(num_calc("A", 2), num_calc("B", 3), num_calc("C", 4) )  <br/>    print(results)    </span><span id="4fce" class="lj je hi ly b fi mg md l me mf">asyncio.run(main())</span><span id="233f" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output<br/></strong>Task A: multiplier(2) = 2<br/>Task B: multiplier(3) = 6<br/>Task C: multiplier(4) = 24<br/>[2, 6, 24]</span><span id="8570" class="lj je hi ly b fi mg md l me mf"># Results [2, 6, 24] are printed based on await on the futures</span></pre><p id="64a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">期货之间的协调</strong></p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="249c" class="lj je hi ly b fi mc md l me mf">import asyncio<br/>from asyncio import Future<br/><br/><br/>async def child_future(future):<br/>    print("child sleep")<br/>    await asyncio.sleep(1)<br/>    print("child woke")<br/>    future.done()<br/>    future.set_result("future is resolved")<br/>    return "child complete"<br/><br/><br/>async def parent(future):<br/>    print("parent wait for child")<br/>    print(await future)<br/>    return "parent complete"<br/><br/><br/>async def main():<br/>    future = Future()<br/>    print(await asyncio.gather(parent(future), child_future(future)))<br/><br/><br/>asyncio.run(main())</span><span id="0b0f" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output : parent waits for child to complete the task</strong><br/>parent wait for child<br/>child sleep<br/>child woke<br/>future is resolved<br/>['parent complete', 'child complete']</span></pre><h2 id="d08e" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated"><strong class="ak">任务:</strong></h2><p id="8e20" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><em class="kg">任务是未来的子类。任务</em>用于在事件循环中同时调度协程<em class="kg">。协程被打包到一个<em class="kg">任务</em>中，其功能类似于<code class="du mh mi mj ly b"><a class="ae kv" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task" rel="noopener ugc nofollow" target="_blank">asyncio.create_task()</a></code>协程被自动调度为很快运行。Task有add_done_callback()来处理进一步的代码清理/完成逻辑。</em></p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="ce9e" class="lj je hi ly b fi mc md l me mf">import asyncio<br/><br/><br/><strong class="ly hj">async def</strong> nested():<br/>    return 42<br/><br/><br/>def result_callback(future):<br/>    print("Callback: %s" % future.result())<br/><br/><br/><strong class="ly hj">async def</strong> main():<br/><strong class="ly hj">    # Schedule nested() to run soon concurrently with "main()".</strong><br/>    task = asyncio.create_task(nested())<br/>    task.<strong class="ly hj">add_done_callback</strong>(result_callback)<br/><br/>    # "task" can now be used to cancel "nested()", or<br/>    # can simply be awaited to wait until it is complete:<br/>    await task<br/><br/><br/>asyncio.run(main())</span><span id="18e1" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output<br/></strong>Callback: 42</span><span id="6c9a" class="lj je hi ly b fi mg md l me mf">Prints callback result after the task is complete.</span></pre><h2 id="c1ea" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">@ <a class="ae kv" href="https://www.python.org/dev/peps/pep-0492/#id55" rel="noopener ugc nofollow" target="_blank"> types.coroutine </a>:</h2><p id="8a7b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Decorator将生成器标记为协程。与asyncio.coroutine()非常相似，不太值得关注。它允许asyncio中现有的<em class="kg">基于生成器的协同程序</em>和<em class="kg">本地协同程序(async)之间的互操作性。</em></p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="3d16" class="lj je hi ly b fi mc md l me mf">import types</span><span id="8720" class="lj je hi ly b fi mg md l me mf">async def magic_pot(db):<br/>    return 1                 </span><span id="91b7" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj">@types.coroutine<br/></strong>def process_magic_pot():<br/>    data = yield from magic_pot(db) <br/>    print(data)</span><span id="e3c1" class="lj je hi ly b fi mg md l me mf">pmp = process_magic_pot()<br/>print(magic_pot())<br/>print(pmp)<br/>asyncio.run(pmp)</span><span id="00f0" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output:<br/></strong>&lt;coroutine object magic_pot at 0x107ed5c48&gt;<br/>&lt;generator object process_magic_pot at 0x107f542a0&gt;<br/>1</span></pre><h2 id="1f0a" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated"><strong class="ak">异步发电机:</strong></h2><p id="d829" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">本机协程内的“yield”返回异步生成器</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="9145" class="lj je hi ly b fi mc md l me mf"><strong class="ly hj">Rationale: (</strong>from<strong class="ly hj"> </strong><a class="ae kv" href="https://www.python.org/dev/peps/pep-0255" rel="noopener ugc nofollow" target="_blank">PEP 255</a>)</span><span id="0ea8" class="lj je hi ly b fi mg md l me mf">Regular generators enabled an elegant way of writing complex <em class="kg">data producers</em> and have them behave like an iterator. However, currently there is no equivalent concept for the <br/><em class="kg">asynchronous iteration protocol</em> (async for). </span><span id="5b0a" class="lj je hi ly b fi mg md l me mf">This makes writing asynchronous data producers unnecessarily complex, as one must define a class that implements __aiter__ and __anext__ to be able to use it in an async for statement.</span><span id="7ccf" class="lj je hi ly b fi mg md l me mf">def func():            # a function<br/>    return<br/><br/>def genfunc():         # a generator function<br/>    yield</span><span id="3e6c" class="lj je hi ly b fi mg md l me mf">async def coro():      # a coroutine function<br/>    await smth()</span><span id="8ff4" class="lj je hi ly b fi mg md l me mf">async def read(db):    # a coroutine function without await<br/>    pass</span><span id="752f" class="lj je hi ly b fi mg md l me mf">async def asyncgen():  # an async generator coroutine function<br/>    await smth()<br/>    yield 42</span><span id="82cf" class="lj je hi ly b fi mg md l me mf">The result of calling an <em class="kg">asynchronous generator function</em> is an <em class="kg">asynchronous generator object</em>, which implements the asynchronous iteration protocol defined in <a class="ae kv" href="https://www.python.org/dev/peps/pep-0492" rel="noopener ugc nofollow" target="_blank">PEP 492</a>.</span></pre><p id="7bb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">新的异步迭代协议支持带异步/等待的生成器</strong></p><p id="c131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kg">异步迭代协议</em></p><ol class=""><li id="203d" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc nn kn ko kp bi translated">一个__aiter__方法返回一个<em class="kg">异步迭代器</em>。</li><li id="d7f5" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc nn kn ko kp bi translated">__anext__方法返回一个可调整的对象，该对象使用StopIteration异常来“产生”值，并使用StopAsyncIteration异常来表示迭代结束。</li></ol><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="2dfb" class="lj je hi ly b fi mc md l me mf">async def async_generator():<br/>    for i in range(2):<br/>        await asyncio.sleep(1)<br/>        yield i * i<br/><br/><br/>async def main():<br/>    gen = async_generator()<br/>    print(gen)<br/>    print(await gen.__anext__()) <strong class="ly hj"># await for the 'yield'</strong><br/>    print(await gen.__anext__())<br/>    await gen.aclose()           <strong class="ly hj"># close the generator for clean-up</strong><br/><br/>asyncio.run(main())<br/><br/><strong class="ly hj"># Output</strong><br/>0<br/>1</span><span id="d484" class="lj je hi ly b fi mg md l me mf">'yield' has to be awaited until exhausted to close the async generator in a clean way. Otherwise, it can cause task 'shutdown' exceptions.</span></pre><h2 id="cf28" class="lj je hi bd jf lk ll lm jj ln lo lp jn iq lq lr jr iu ls lt jv iy lu lv jz lw bi translated">异步用于:</h2><p id="90a0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">简化了异步发电机的迭代(yield)。</p><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="b793" class="lj je hi ly b fi mc md l me mf"># combination of using async generator and coroutine</span><span id="ce13" class="lj je hi ly b fi mg md l me mf">async def main():<br/>    <strong class="ly hj">async for</strong> i in async_generator():<br/>        print(i)<br/><br/>loop = asyncio.get_event_loop()<br/>asyncio.ensure_future(main())<br/>asyncio.ensure_future(main())<br/>loop.run_forever()</span><span id="0776" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output<br/></strong>0<br/>0<br/>1<br/>1</span></pre><h1 id="426d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.摘要</h1><ul class=""><li id="03c1" class="kh ki hi ih b ii kb im kc iq nk iu nl iy nm jc km kn ko kp bi translated">yield关键字创建常规生成器。“yield from”是迭代和耗尽生成器的捷径</li><li id="ecda" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj"> generator.send() </strong>帮助向协程发送值。‘yield’对于协程之间的迭代是双向的。</li><li id="c09e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae kv" href="https://www.educative.io/blog/python-concurrency-making-sense-of-asyncio" rel="noopener ugc nofollow" target="_blank">事件循环</a>使用协同调度。并发任务被安排在一个由线程管理的事件循环中。</li><li id="2d02" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">@asyncio.coroutine创建asyncio生成器协程对象，并使用“yield from”来处理本机/生成器协程。<code class="du mh mi mj ly b">yield from</code>语句将控制权交还给事件循环，让其他协程执行。</li><li id="b456" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">@types.coroutine类似于@asyncio.coroutine，它有助于将常规生成器转换为协同程序对象，并在本机协同程序之间实现互操作。</li><li id="59e0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">asyncio是一个使用<strong class="ih hj"> async/await </strong>语法编写<strong class="ih hj">并发</strong>代码的库。</li><li id="4bf2" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">用<strong class="ih hj"> async/await </strong>语法声明的协同程序是编写asyncio应用程序的首选方式。</li><li id="55cb" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">async/await是@asyncio.coroutine/'yield from '的最新等效项</li><li id="383d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">本机/生成器协同程序，未来，任务是<strong class="ih hj">可实现的</strong></li><li id="90de" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Future是一个特殊的低级对象，表示异步操作的最终结果。</li><li id="11d8" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">任务是未来的一个子类。任务用于调度 <strong class="ih hj"> <em class="kg">事件循环</em> </strong> <em class="kg">中的<strong class="ih hj">协程<em class="kg">并发</em> </strong> <em class="kg">执行。</em></em></li><li id="c0bb" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj"> async for </strong>用于迭代异步生成器</li><li id="6961" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj"> async with </strong>用于执行带清理(垃圾收集)的异步操作</li></ul><h1 id="e274" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4.简单的HTTP API爬虫示例</h1><pre class="kx ky kz la fd lx ly lz ma aw mb bi"><span id="2dc1" class="lj je hi ly b fi mc md l me mf"><strong class="ly hj"># Simple example to crawl http urls in parallel</strong></span><span id="c317" class="lj je hi ly b fi mg md l me mf">import aiohttp<br/>import asyncio<br/>import time<br/><br/><br/><strong class="ly hj">async def</strong> get_req(page_no):<br/>    print("called at time1: " + str(time.time()))<br/>    async with aiohttp.ClientSession() as session:<br/>        async with session.get("http://reqres.in/api/users?page=" + str(page_no), headers={}) as resp:<br/>            print("called at time2: " + str(time.time()))<br/>            return await resp.json()<br/><br/><br/><strong class="ly hj">async def</strong> fetch_all_urls():<br/>    results = await <strong class="ly hj">asyncio.gather</strong>(*[get_req(page_no) for page_no in range(1, 5)], return_exceptions=True)<br/><strong class="ly hj">    # results = [await get_req(page_no) for page_no in range(1, 5)]</strong><br/>    for result in results:<br/>        print('page: %s, size: %s' % (result['page'], len(result['data'])))<br/>    return results<br/><br/><br/><strong class="ly hj">def</strong> get_htmls():<br/>    loop = asyncio.get_event_loop()<br/>    htmls = loop.run_until_complete(fetch_all_urls())<br/>    return htmls<br/><br/><br/>start = time.time()<br/>print("start time: " + str(start))<br/>get_htmls()<br/>print("time taken: " + str(time.time() - start))</span><span id="5e39" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># Output:</strong><br/>start time: 1583848827.362924<br/>called at time1: 1583848827.363832<br/>called at time1: 1583848827.365168<br/>called at time1: 1583848827.365639<br/>called at time1: 1583848827.365942<br/>called at time2: 1583848827.625053<br/>called at time2: 1583848827.6382<br/>called at time2: 1583848827.656707<br/>called at time2: 1583848827.981515<br/>page: 1, size: 6<br/>page: 2, size: 6<br/>page: 3, size: 0<br/>page: 4, size: 0<br/>time taken: 0.6193337440490723</span><span id="c47e" class="lj je hi ly b fi mg md l me mf"><strong class="ly hj"># </strong>Uncomment the bold line (replace "await asyncio.gather" line with the next commented line and check the results). Request are completed done sequentially and takes 2 seconds to complete. In this case, await iterated sequentially can lose all concurrency and thats how started this journey of understanding the asyncio.</span></pre><p id="2505" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献:</strong></p><p id="35a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别感谢所有帮助我理解复杂概念的人，感谢他们的博客/演示。我使用了一些参考链接中的部分定义/示例参考。</p><ul class=""><li id="2893" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae kv" href="https://www.dabeaz.com/coroutines/Coroutines.pdf" rel="noopener ugc nofollow" target="_blank">www.dabeaz.co</a>m出色的演示文稿和<a class="ae kv" href="http://www.dabeaz.com/coroutines/" rel="noopener ugc nofollow" target="_blank">源代码</a></li><li id="4a65" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Abu Ashraf Masnun就这些主题撰写了出色的文章。查看他的博客(<a class="ae kv" href="http://masnun.com" rel="noopener ugc nofollow" target="_blank">http://masnun.com</a>)</li><li id="cb36" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae kv" href="https://realpython.com/async-io-python/#other-features-async-for-and-async-generators-comprehensions" rel="noopener ugc nofollow" target="_blank">https://real python . com/async-io-python/# other-features-async-for-and-async-generators-comprehensions</a></li><li id="d1e4" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae kv" href="https://www.educative.io/blog/python-concurrency-making-sense-of-asyncio" rel="noopener ugc nofollow" target="_blank">https://www . educative . io/blog/python-concurrency-making-sense-of-asyn CIO</a></li><li id="2346" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae kv" href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" rel="noopener ugc nofollow" target="_blank">https://snarky . ca/how-the-heck-do-async-await-work-in-python-3-5/</a></li></ul><p id="894c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请让我知道你对定义/代码的反馈/修正。如果你正在读这最后一行，你有足够的耐心/兴趣来读这么长的帖子，为此表示感谢:)。</p></div></div>    
</body>
</html>