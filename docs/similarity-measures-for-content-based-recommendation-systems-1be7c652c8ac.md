# 基于内容的推荐系统的相似性度量

> 原文：<https://medium.com/analytics-vidhya/similarity-measures-for-content-based-recommendation-systems-1be7c652c8ac?source=collection_archive---------9----------------------->

对于推荐系统，尤其是基于内容的推荐系统，要推荐的产品之间的相似性成为一个重要的衡量标准。

我们举个例子来理解基于内容的推荐。

假设一个朋友来找你寻求电影建议。我们不会随意地给电影取名字，相反，我们会记住朋友对电影类型的喜好，并相应地向他们推荐电影。基于内容的推荐系统采用相同的方法。

考虑一个场景，其中用户正在查看一组特定的产品。基于用户正在查看的产品的属性，我们可以推荐具有相似属性的产品。一些基于内容的推荐系统对底层数据中可用的各种特征使用多种相似性度量。

在本文中，我们将使用两种相似性度量方法:

1 —皮尔逊系数和

2-余弦相似性

使用的数据集将是 UCI 机器学习知识库上可用的葡萄酒数据集。代码实现在 R 中(R 版本 3.5.3，RStudio 1.1.447)。我建议你也这样做，以便更好地理解这个过程。

```
> library(data.table)
> wine.data <- fread("[https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data](https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data)")
```

下载完数据集后，让我们探索一下其中的数据。

```
> head(wine.data)
   V1    V2   V3   V4   V5  V6   V7   V8   V9  V10  V11  V12  V13  V14
1:  1 14.23 1.71 2.43 15.6 127 2.80 3.06 0.28 2.29 5.64 1.04 3.92 1065
2:  1 13.20 1.78 2.14 11.2 100 2.65 2.76 0.26 1.28 4.38 1.05 3.40 1050
3:  1 13.16 2.36 2.67 18.6 101 2.80 3.24 0.30 2.81 5.68 1.03 3.17 1185
4:  1 14.37 1.95 2.50 16.8 113 3.85 3.49 0.24 2.18 7.80 0.86 3.45 1480
5:  1 13.24 2.59 2.87 21.0 118 2.80 2.69 0.39 1.82 4.32 1.04 2.93  735
6:  1 14.20 1.76 2.45 15.2 112 3.27 3.39 0.34 1.97 6.75 1.05 2.85 1450
```

元数据说 V1 代表“栽培品种”,这基本上是基于化学性质的组合对葡萄酒的分类。

```
> table(wine.data$V1)1  2  3 
59 71 48
```

该数据集具有 3 种不同类型的“栽培品种”特征。从 V2 到 V14 列是葡萄酒的不同化学特性。

我们的下一步将是把酒的类型和酒的化学性质分成两个不同的数据集。

```
> wine_type <- wine.data[,1]
> wine_features <- wine.data[,-1]
```

我们可以从数据集中看到，要素具有不同的取值范围。在计算相似性指数或对葡萄酒属性进行矢量化时，这可能是个问题。为了解决这个问题，我们可以对所有要素的值进行缩放，以保持值的一致性。

```
> wine_features <- data.frame(scale(wine_features))
> head(wine_features)
         V2          V3         V4         V5         V6        V7        V8         V9        V10
1 1.5143408 -0.56066822  0.2313998 -1.1663032 1.90852151 0.8067217 1.0319081 -0.6577078  1.2214385
2 0.2455968 -0.49800856 -0.8256672 -2.4838405 0.01809398 0.5670481 0.7315653 -0.8184106 -0.5431887
3 0.1963252  0.02117152  1.1062139 -0.2679823 0.08810981 0.8067217 1.2121137 -0.4970050  2.1299594
4 1.6867914 -0.34583508  0.4865539 -0.8069748 0.92829983 2.4844372 1.4623994 -0.9791134  1.0292513
5 0.2948684  0.22705328  1.8352256  0.4506745 1.27837900 0.8067217 0.6614853  0.2261576  0.4002753
6 1.4773871 -0.51591132  0.3043010 -1.2860793 0.85828399 1.5576991 1.3622851 -0.1755994  0.6623487
         V11        V12       V13         V14
1  0.2510088  0.3611585 1.8427215  1.01015939
2 -0.2924962  0.4049085 1.1103172  0.96252635
3  0.2682629  0.3174085 0.7863692  1.39122370
4  1.1827317 -0.4263410 1.1807407  2.32800680
5 -0.3183774  0.3611585 0.4483365 -0.03776747
6  0.7298108  0.4049085 0.3356589  2.23274072
```

由于 R 中的大多数相似性函数要求输入数据是矩阵格式，我们可以将数据集转换成矩阵形式，并为数据分配行名。数据集中的每一行都表示矢量格式的葡萄酒属性。

```
> wine_mat <- data.matrix(wine_features)
> rownames(wine_mat) <- seq(1:dim(wine_features)[1])
> wine_mat[1:2,]
         V2         V3         V4        V5         V6        V7        V8         V9        V10        V11
1 1.5143408 -0.5606682  0.2313998 -1.166303 1.90852151 0.8067217 1.0319081 -0.6577078  1.2214385  0.2510088
2 0.2455968 -0.4980086 -0.8256672 -2.483841 0.01809398 0.5670481 0.7315653 -0.8184106 -0.5431887 -0.2924962
        V12      V13       V14
1 0.3611585 1.842721 1.0101594
2 0.4049085 1.110317 0.9625263
```

现在让我们转置矩阵，这样我们就有了每种葡萄酒的所有属性映射。

```
> wine_mat <- t(wine_mat)
```

我们每行代表一种葡萄酒。换句话说，每一行都有葡萄酒的几个属性。我们将使用皮尔逊系数来寻找葡萄酒之间的相似性。皮尔逊系数衡量两个变量之间的相关性。在我们的例子中，每一行都被视为一个变量。

```
> cor_matrix <- cor(wine_mat, use = "pairwise.complete.obs", method = "pearson")
> dim(cor_matrix)
[1] 178 178
> cor_matrix[1:5,1:5]
          1          2         3             4             5
1 1.0000000  0.7494842 0.5066551  0.7244043066  0.1850897291
2 0.7494842  1.0000000 0.4041662  0.6896539740 -0.1066822182
3 0.5066551  0.4041662 1.0000000  0.5985843958  0.1520360593
4 0.7244043  0.6896540 0.5985844  1.0000000000 -0.0003942683
5 0.1850897 -0.1066822 0.1520361 -0.0003942683  1.0000000000
```

从上面的输出中我们可以看到，生成的矩阵大小为 178 x178。这意味着每种葡萄酒与数据集中的其他葡萄酒相比都有相似性得分。所有对角元素。也就是说，每种葡萄酒彼此之间的相似性得分都是满分。正数将显示正相关，同样，负数在结果矩阵中也是如此。

现在让我们看看如何使用这个相似度矩阵根据用户的葡萄酒选择来推荐葡萄酒。

```
> user_view <- wine_features[3,]
> user_view
         V2         V3       V4         V5         V6        V7       V8        V9      V10       V11
3 0.1963252 0.02117152 1.106214 -0.2679823 0.08810981 0.8067217 1.212114 -0.497005 2.129959 0.2682629
        V12       V13      V14
3 0.3174085 0.7863692 1.391224
> sim_items <- cor_matrix[3,]
> sim_items.sorted <- sort(sim_items, decreasing = TRUE)
> sim_items.sorted[1:5]
        3        52        51        85        15 
1.0000000 0.7719273 0.7606256 0.7475886 0.7325499
```

我们最后可以看到，酒号 52、52、85 和 15 与用户最初查看的酒号 3 相似。

我们还可以从向量空间模型中考虑一些其他方法来找到相似性，如欧几里德距离或余弦相似性。

让我们继续讨论余弦相似性，并在 R:

```
> library("lsa")
> cor_matrix = cosine(wine_mat)
> dim(cor_matrix)
[1] 178 178
> cor_matrix[1:5,1:5]
          1          2         3         4          5
1 1.0000000  0.5622599 0.6726599 0.8107890  0.4871602
2 0.5622599  1.0000000 0.2368420 0.4871792 -0.1573216
3 0.6726599  0.2368420 1.0000000 0.7461053  0.5227389
4 0.8107890  0.4871792 0.7461053 1.0000000  0.4043439
5 0.4871602 -0.1573216 0.5227389 0.4043439  1.0000000
```

我们已经使用了库“lsa”来使用其中的余弦函数。输出是相同的矩阵，它给出了数据集中每种葡萄酒与其他每种葡萄酒之间的余弦相似性。

让我们再次测试它，向用户推荐葡萄酒选择。

```
> user_view <- wine_features[3,]
> user_view
         V2         V3       V4         V5         V6        V7       V8        V9      V10       V11
3 0.1963252 0.02117152 1.106214 -0.2679823 0.08810981 0.8067217 1.212114 -0.497005 2.129959 0.2682629
        V12       V13      V14
3 0.3174085 0.7863692 1.391224
> sim_items <- cor_matrix[3,]
> sim_items.sorted <- sort(sim_items, decreasing = TRUE)
> sim_items.sorted[1:5]
        3        31        52        49        56 
1.0000000 0.8271992 0.8192096 0.8137115 0.8057562
```

我们可以看到，根据余弦相似度，与 3 号酒相似的酒是 31 号酒、52 号酒、49 号酒和 56 号酒。

总之，在向量空间模型中有如此多的相似性方法，人们可以对它们进行实验，并选择最适合人们寻求解决的用例的方法。