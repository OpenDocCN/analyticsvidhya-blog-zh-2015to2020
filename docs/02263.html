<html>
<head>
<title>Getting started with Flask on Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker上的Flask入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-flask-on-docker-2885ad859b9a?source=collection_archive---------12-----------------------#2019-12-08">https://medium.com/analytics-vidhya/getting-started-with-flask-on-docker-2885ad859b9a?source=collection_archive---------12-----------------------#2019-12-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">lask是python中用于web开发的一个漂亮的微框架。在本文中，我们将看到如何使用Docker将其部署在您个人喜爱的云基础设施上！</p><p id="3356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章的全部代码可以在<a class="ae jm" href="https://github.com/shubham1172/quickstart-docker-flask" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个hello-world Flask应用程序，并使用Gunicorn服务器托管它。请注意，Flask应用程序通常可以使用内置的调试服务器托管，但它并不适合生产。</p><blockquote class="jn"><p id="30b8" class="jo jp hi bd jq jr js jt ju jv jw jc dx translated">虽然轻量级且易于使用，但Flask的内置服务器不适合生产，因为它不能很好地扩展~ <a class="ae jm" href="http://flask.pocoo.org/docs/1.0/deploying/#deployment" rel="noopener ugc nofollow" target="_blank"> Flask docs </a></p></blockquote><p id="db9b" class="pw-post-body-paragraph if ig hi ih b ii jx ik il im jy io ip iq jz is it iu ka iw ix iy kb ja jb jc hb bi translated">这就是我们使用WSGI服务器的原因。Gunicorn简单可靠。</p><h1 id="34c9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">那么，Docker是什么？</strong></h1><blockquote class="jn"><p id="b89e" class="jo jp hi bd jq jr js jt ju jv jw jc dx translated">Docker是推动容器运动的公司，也是解决混合云中每个应用程序的唯一容器平台提供商。~码头工人</p></blockquote><p id="ef3e" class="pw-post-body-paragraph if ig hi ih b ii jx ik il im jy io ip iq jz is it iu ka iw ix iy kb ja jb jc hb bi translated">容器是为应用程序提供运行环境的逻辑包。这是一个虚拟化的环境，包含代码、库和其他一切。容器使得在任何地方运行软件都很容易，不会与运行环境发生任何冲突！</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/bfbb362cd063b460be78d3ea5d48d7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eqRQOjcOMhzDdiMa.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">Docker将软件打包成标准化单元，用于开发、运输和部署—<a class="ae jm" href="https://www.docker.com/what-container" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/what-container</a></figcaption></figure><p id="5c39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker是一个容器平台。更多关于dockers <a class="ae jm" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="d394" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置</h1><p id="aa9d" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">为此活动创建一个文件夹，并导航到其中。我们将使用它来存储应用程序的源代码。</p><pre class="lb lc ld le fd lv lw lx ly aw lz bi"><span id="6d4e" class="ma kd hi lw b fi mb mc l md me">$ mkdir flask-app<br/>$ cd flask-app</span></pre><h1 id="ba76" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">编写web应用程序</h1><p id="98a8" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">我们将在Flask中编写一个非常基本的web应用程序，它在“/”端点上返回hello-world。</p><p id="c336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器代码将如下所示:</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="d47e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它只是在“/”处创建一个端点，并返回JSON:</p><pre class="lb lc ld le fd lv lw lx ly aw lz bi"><span id="5e93" class="ma kd hi lw b fi mb mc l md me">{message: "hello, world!"}</span></pre><p id="8aff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还为我们的应用程序编写了两个文件:</p><ul class=""><li id="7d5c" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated"><em class="mq"> __init__。py </em> —创建应用程序实例</li><li id="4a76" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated"><em class="mq"> requirements.txt </em> —列出需要的模块</li></ul><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="mf mg l"/></div></figure><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="mf mg l"/></div></figure><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mw"><img src="../Images/f613ec167ef2b5c0f32ad8c3fea97fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*V2apGyaXgRoEX0QXEgdoNg.png"/></div></figure><p id="cd6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">移动<strong class="ih hj"> src </strong>文件夹中的所有代码，文件树应该如图所示。</p><p id="15d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们快速启动终端并测试这个服务器！</p><pre class="lb lc ld le fd lv lw lx ly aw lz bi"><span id="da1a" class="ma kd hi lw b fi mb mc l md me">$ pip3 install -r src/requirements.txt<br/>$ gunicorn src:app</span></pre><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mx"><img src="../Images/88ffda891fb64af2021c89580c0d7dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*CTnZX8hSWQuEaSRuVbxCvQ.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">/'服务hello-world！</figcaption></figure><h1 id="c3d1" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">配置Gunicorn服务器</h1><p id="0d8b" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">现在我们已经启动并运行了我们的应用程序，我们需要正确地配置web服务器。现在它处于非常基本的配置，没有多线程或日志记录。</p><p id="a530" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们继续在<em class="mq">conf/guni corn _ config . py</em>中编写我们的配置</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="mf mg l"/></div></figure><ul class=""><li id="321c" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">绑定—将web服务器绑定到端口8000，并向所有接口公开</li><li id="c11a" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">workers —为请求提供服务的工作线程数</li><li id="ee04" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">accesslog和format —以给定的格式记录到STDOUT。</li></ul><p id="3f44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这个文件的所有信息都可以在<a class="ae jm" href="http://docs.gunicorn.org/en/stable/settings.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><h1 id="4984" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Dockerizing！</h1><p id="26b5" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">现在，这个web应用程序和服务器已经启动并运行，我们希望将其封装到Docker容器中。为此，我们必须编写一个<em class="mq"> Dockerfile </em>。</p><blockquote class="my mz na"><p id="23b8" class="if ig mq ih b ii ij ik il im in io ip nb ir is it nc iv iw ix nd iz ja jb jc hb bi translated">Docker可以通过读取docker文件中的指令来自动构建映像。Dockerfile是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。~ <a class="ae jm" href="https://docs.docker.com/engine/reference/builder/#usage" rel="noopener ugc nofollow" target="_blank"> Docker文档</a></p></blockquote><p id="b06b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的docker文件看起来像:</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="84b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将逐行研究这个Dockerfile文件！</p><ul class=""><li id="4433" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">第1行:FROM允许我们在基础映像上初始化构建。在我们的例子中，我们使用了一个<a class="ae jm" href="https://github.com/docker-library/python/blob/b99b66406ebe728fb4da64548066ad0be6582e08/3.6/alpine3.7/Dockerfile" rel="noopener ugc nofollow" target="_blank"> python:3.6.5-alpine </a>图像。Alpine是一个小型的Linux发行版(~ 5MB)。因为体积小，所以被Docker应用大量使用。简而言之，我们的应用程序使用了带有python 3.6.5的Linux环境。</li><li id="a7dc" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">第3行:我们创建一个名为app的WORKDIR，在这里将设置pwd。</li><li id="1364" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">第8行:将当前目录中的所有内容(我们的服务器代码和配置)复制到app目录中。</li><li id="558b" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">第11行:安装依赖项。</li><li id="63ff" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">第14行:这暴露了我们容器的端口8000，用于容器间的通信。稍后，我们将把这个端口连接到主机，以便在其上提供我们的web应用程序。</li><li id="e5b7" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">第16行:作为令牌列表传递的最后一个命令。它使用配置文件运行Gunicorn服务器。</li></ul><h1 id="8b5f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">一切准备就绪</h1><p id="4e10" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">现在我们有一个docker文件，我们需要做的就是建立一个图像。在这之后，我们将能够<em class="mq">运行</em>我们的图像并看到web应用程序的运行！</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es ne"><img src="../Images/c897770d44cebcd71bf1a0ee8f103a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*I-0PATbFvpwsqVcM4VvZZw.png"/></div></figure><p id="6431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的源代码现在应该看起来像图片。注意Dockerfile在src文件夹之外。</p><p id="3413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要创建一个docker映像并运行它！</p><pre class="lb lc ld le fd lv lw lx ly aw lz bi"><span id="255a" class="ma kd hi lw b fi mb mc l md me">$ docker build -t helloworld .<br/>$ docker run -p 80:8000 helloworld </span></pre><ul class=""><li id="7840" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">docker build从docker文件创建一个图像，并且-t将一个<em class="mq">标签</em>赋予我们的图像<em class="mq"> </em>。</li><li id="be3d" class="mh mi hi ih b ii mr im ms iq mt iu mu iy mv jc mm mn mo mp bi translated">docker run接受标记参数来运行映像，而-p将容器的端口发布给主机。</li></ul><p id="6a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们的web应用程序现在在端口80可用。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es nf"><img src="../Images/c9c9b55a8904d9ae3b1995053b57bbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*WXM9iETab8bVIjNXBUof8Q.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">卷曲本地主机，查看应用程序启动和运行！</figcaption></figure><p id="6337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用<code class="du ng nh ni lw b">docker ps</code>列出活动容器</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es nj"><img src="../Images/c0a43d89cf0a9489cf150d21c6cdae4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKR_hzsvaXz80iYcf5UR3Q.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">关于活动容器的一切！</figcaption></figure><p id="fd0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们的容器是如何被随机命名的！详见 <a class="ae jm" href="https://github.com/moby/moby/blob/5aa44cdf132788cc0cd28ce2393b44265dd400e9/pkg/namesgenerator/names-generator.go#L600" rel="noopener ugc nofollow" target="_blank"> <em class="mq">本</em> </a> <em class="mq">围棋文件！</em></p><h1 id="3fc9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">正在部署。</h1><p id="2a83" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">现在我们有了一个docker映像和驻留在其中的我们自己的应用程序。我们现在想做什么？如何让这个映像对我们的AWS EC2实例或某个Linux云服务器可用？</p><h2 id="c0e4" class="ma kd hi bd ke nk nl nm ki nn no np km iq nq nr kq iu ns nt ku iy nu nv ky nw bi translated"><a class="ae jm" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank">码头枢纽</a>！</h2><p id="d934" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">我们将把我们的图像推送到Docker Hub上的一个公共注册表中，以后我们可以从那里提取图像。为此:</p><p id="03b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Docker Hub上创建一个帐户，并创建一个新的存储库！</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es nx"><img src="../Images/6d23ce45408d0fc0b9de588da18986a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opdlCTdrqxwwSM9Tx_vMyw.png"/></div></div></figure><p id="885f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要在命令行上标记我们的图像，并推送它。</p><pre class="lb lc ld le fd lv lw lx ly aw lz bi"><span id="7d28" class="ma kd hi lw b fi mb mc l md me">$ docker login<br/>$ docker tag helloworld &lt;username&gt;/&lt;repository-name&gt;<br/>$ docker push &lt;username&gt;/&lt;repository-name&gt;</span></pre><p id="1386" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在可以使用<code class="du ng nh ni lw b">docker pull</code>从任何地方提取该图像</p><h1 id="b4be" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">例如:Linux Box上的Docker</h1><p id="2441" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">在任何Linux服务器上，</p><pre class="lb lc ld le fd lv lw lx ly aw lz bi"><span id="b900" class="ma kd hi lw b fi mb mc l md me">$ docker run &lt;username&gt;/&lt;repository-name&gt;</span></pre><p id="2907" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker自动从Docker Hub中提取图像并运行实例！</p><p id="8887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，docker映像可以部署在任何地方。</p><h1 id="f28c" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="7e9e" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq ls is it iu lt iw ix iy lu ja jb jc hb bi translated">我们看到了如何使用Docker环境将我们的应用程序容器化并在任何地方托管它。想了解更多关于码头工人的信息，请阅读<a class="ae jm" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">官方文件</a>，亲自动手处理集装箱。</p></div></div>    
</body>
</html>