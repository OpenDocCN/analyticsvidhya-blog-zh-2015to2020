<html>
<head>
<title>Python: Under The Hood [Garbage Collection]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:引擎盖下[垃圾收集]</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-under-the-hood-garbage-collection-7cc55977c482?source=collection_archive---------19-----------------------#2020-05-07">https://medium.com/analytics-vidhya/python-under-the-hood-garbage-collection-7cc55977c482?source=collection_archive---------19-----------------------#2020-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/84b214ab87cbe328e5a57a2c4862271f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPhtmRdktXK9Aldvyl02yw.png"/></div></div></figure><p id="2f21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗨，欢迎来到Python的第二部分:引擎盖下系列，在本文中，我们将看看什么是垃圾收集，以及它在Python语言的上下文中是如何工作的。</p><p id="881f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先说一下<strong class="is hj"> <em class="jo">什么是垃圾回收？</em> </strong>和<strong class="is hj"> <em class="jo">是做什么用的？</em> </strong></p><blockquote class="jp"><p id="d7c7" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">垃圾收集是计算机科学中的一项技术，用于通过将程序不再需要的对象从内存中移除来清除它们所占用的内存。</p></blockquote><p id="8893" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">所有HLL编程语言都在内部实现了垃圾收集作为语言的核心，这样开发人员就不需要处理显式的内存分配和释放。</p><p id="bf00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，来问一下<strong class="is hj"> <em class="jo">它是做什么的？</em>T11】</strong></p><p id="587d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它主要做两件事:</p><ol class=""><li id="1a88" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">内存清理</li><li id="39ab" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">堆碎片</li></ol><p id="d3e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我理解内存清理，但是什么是堆碎片？T15】</p><p id="7fd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">python中的程序需要连续的内存块，当一个对象在执行过程中被删除时，一个特定的内存块就会被释放出来，准备被另一个对象占用。</p><p id="9524" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里唯一的问题是，python中并不是每个对象都需要一个内存块。有些可能会占用多个内存块，比如python中的list就需要连续的内存块。</p><p id="673d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，堆碎片的作用是，</p><blockquote class="jp"><p id="b390" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">它聚合内存中的所有空闲块，形成一个连续的内存块。</p></blockquote><p id="d211" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">让我们用一个例子来理解这一点</p><p id="cd08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">比方说，我们的程序在执行过程中有一个这样的内存结构。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/eb480d6e690e51dcbbdc691afd2f467a.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*SpNhsbM_FcFGIuE7gR9SSg.jpeg"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">堆内存表示</figcaption></figure><p id="acee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们的垃圾收集器从内存中移除了第三个对象(300 ),然后我们尝试创建一个包含3个整数值的列表对象。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/64906cc1c6cf83e3d932f3fd6129b88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*Z-D9pgSCc7LH4SdJDqJSxA.jpeg"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">由于连续内存不可用，无法添加列表</figcaption></figure><p id="0f0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使有3个块可用于包含3个整数对象，但是由于该列表需要连续的存储块，并且只有2个块可用，因此该操作不能在该特定存储块上执行。</p><p id="3bf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，这不是管理内存的最有效方式。因此，堆碎片来拯救我们了。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/46b3a39d3a9a46821d216ef9ea111c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*om3Y42eNE4Ko3Uo2CtRHEw.jpeg"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">碎片化后添加列表操作</figcaption></figure><p id="c7e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GC在删除对象后执行碎片化并连续释放内存块。从而允许执行“添加”列表操作。</p><p id="8bd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">酷！现在来说说<strong class="is hj"><em class="jo">python是如何实现垃圾回收的？</em> </strong>。</p><p id="a202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管有多种垃圾收集技术或垃圾收集器GC。你可以在这里看看这些类型。</p><p id="52d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是，Python使用了两个垃圾收集器，名为引用垃圾收集器和分代垃圾收集器。</p><h2 id="3d4e" class="le lf hi bd lg lh li lj lk ll lm ln lo jb lp lq lr jf ls lt lu jj lv lw lx ly bi translated">引用垃圾收集器</h2><p id="8e02" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">python中的每个PyObject都维护一个RefCount，它计算它拥有的引用数，即有多少变量指向该对象。</p><p id="4dcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的第一篇文章中，我讨论了RefCount在程序执行状态期间如何变化。</p><p id="0fa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">引用GC是python中主要的垃圾收集机制，没有办法禁用或替换实现。但是，我们可以使用sys模块中的getrefcount( <variable>)来计算一个对象拥有的引用数。</variable></p><pre class="kt ku kv kw fd me mf mg mh aw mi bi"><span id="24d9" class="le lf hi mf b fi mj mk l ml mm">import sys<br/>a = "xyz"<br/>sys.getrefcount(a)<br/>&gt;&gt;2</span></pre><p id="f031" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意这里有两个引用。一个是在第2行创建变量，第二个是在第3行将变量"</em><strong class="is hj"><em class="jo"/></strong><em class="jo">传递给</em><strong class="is hj"><em class="jo">sys . getrefcount()</em></strong><em class="jo">函数。</em></p><p id="1e39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管有如此健壮的实现，它也有一些缺点。</p><ul class=""><li id="1ab5" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn mn kk kl km bi translated"><strong class="is hj">它不检测循环引用。</strong></li></ul><p id="9107" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当两个对象相互引用时，就会出现循环引用。因此，这些对象的RefCount永远不会达到零。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/4afb22dbd6c7451c4a9cb54082f9de77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nhMaQcQyPEtwhsSPNcP3w.jpeg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">对象之间的循环引用</figcaption></figure><ul class=""><li id="406a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn mn kk kl km bi translated">这不是线程安全的。</li></ul><p id="382d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在多线程环境中，两个线程可能同时访问/修改同一个对象。而引用GC却没有处理它的机制。</p><h2 id="50d4" class="le lf hi bd lg lh li lj lk ll lm ln lo jb lp lq lr jf ls lt lu jj lv lw lx ly bi translated">分代垃圾收集器</h2><p id="5e45" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">分代GC背后的关键概念是大多数新对象很快变得不可访问。因此，我们可以根据对象的寿命将它们分开，并分配到不同的代中。</p><blockquote class="mp mq mr"><p id="438a" class="iq ir jo is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated">Python有三代对象。一个对象一次只能驻留在一代中。</p></blockquote><p id="1df2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在执行过程中，每当解释器遇到一个新对象，它就把这个对象放入第0代。</p><p id="cfe3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于每一代，垃圾收集器保存有限数量的对象，即阈值。当对象数量超过该阈值时，将执行垃圾收集过程。如果一个对象在这个过程中幸存下来，那么该对象将向上移动到下一代(或者在第三代对象的情况下停留在同一代)。</p><p id="59c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与引用垃圾收集不同，您可以修改分代垃圾收集行为，例如修改阈值、手动触发垃圾收集过程或完全禁用垃圾收集。点击<a class="ae ld" href="https://docs.python.org/3/library/gc.html" rel="noopener ugc nofollow" target="_blank">此处</a>查看GC文档了解更多信息。</p><p id="1e06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧！但是<strong class="is hj">是否解决了</strong> <strong class="is hj">循环引用的问题？</strong></p><blockquote class="jp"><p id="3a72" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">是的，分代GC通过观察引用的创建和覆盖来跟踪跨代的对象引用，并且能够检测不可到达的对象，而不必遍历整个引用树。</p></blockquote><p id="c25b" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">那么线程问题呢？</p><p id="b6d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python通过一种非常有趣的方式处理多线程来解决这个问题。Python实现了一种称为全局解释器锁或GIL的机制。</p><p id="56ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从最基本的意义上来说，</p><blockquote class="jp"><p id="675e" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">GIL只允许一个线程在任何时间点都处于执行状态。</p></blockquote><p id="2414" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">因此，不需要线程安全的环境。</p><p id="9182" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的下一篇文章是我们将更多地了解GIL。</p></div></div>    
</body>
</html>