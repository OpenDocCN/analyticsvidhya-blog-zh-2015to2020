<html>
<head>
<title>Synchronization and Critical Section Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步和临界区问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/synchronization-and-critical-section-problem-7b214cad4c87?source=collection_archive---------14-----------------------#2020-03-22">https://medium.com/analytics-vidhya/synchronization-and-critical-section-problem-7b214cad4c87?source=collection_archive---------14-----------------------#2020-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b8db98c81f357348eb0d162ff8528102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*lvMbVqsW7jerNp1X.jpg"/></div></figure></div><div class="ab cl im in gp io" role="separator"><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir"/></div><div class="hb hc hd he hf"><h1 id="3536" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">什么是同步？</h1><p id="ff14" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">在多编程或多线程编程环境中的同步是协调共享数据的访问和操作的过程。如果你读过我以前的一些博客，你会注意到我们偶尔会遇到两个线程试图同时访问相同共享数据的问题。为了处理这个常见问题，我们必须了解如何同步访问这些共享数据。</p><h1 id="2230" class="it iu hi bd iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq bi translated">临界截面问题</h1><p id="4a03" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><strong class="jt hj">临界</strong>段位于代码中一个线程正在访问可能被另一个线程访问的共享数据的任何地方。同步将试图防止两个线程同时访问临界区/共享数据。</p><h2 id="bf8e" class="kv iu hi bd iv kw kx ky iz kz la lb jd kc lc ld jh kg le lf jl kk lg lh jp li bi translated">实现同步</h2><p id="ddd2" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">实现同步有许多方法，但它们都遵循以下通用伪代码:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ea28" class="kv iu hi lo b fi ls lt l lu lv">// Some code<br/>.<br/>.<br/>.<br/>acquire_access <br/>    // critical section <br/>    // access and update shared data<br/>release_access<br/>.<br/>.<br/>.<br/>// some code</span></pre><p id="152c" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated">如果另一个线程正在使用访问权限，获取访问权限将导致该线程等待；如果没有其他线程正在使用访问权限，它将成功获取访问权限。一旦线程完成，它就释放访问，以便另一个线程可以使用它。</p><p id="f795" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated">最简单的实现是使用所谓的<code class="du mb mc md lo b">Semaphore</code></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6009" class="kv iu hi lo b fi ls lt l lu lv">sem_t mutex;<br/>sem_init(&amp;mutex, 0, 1);<br/>int critical_section = 0;</span><span id="0b8d" class="kv iu hi lo b fi me lt l lu lv">//thread 1</span><span id="56f5" class="kv iu hi lo b fi me lt l lu lv">sem_wait(&amp;mutex);<br/>critical_section ++;<br/>sem_post(&amp;mutex);</span><span id="4011" class="kv iu hi lo b fi me lt l lu lv">//thread 2</span><span id="e424" class="kv iu hi lo b fi me lt l lu lv">sem_wait(&amp;mutex);<br/>critical_section ++;<br/>sem_post(&amp;mutex);</span></pre><h2 id="4242" class="kv iu hi bd iv kw kx ky iz kz la lb jd kc lc ld jh kg le lf jl kk lg lh jp li bi translated">近距离观察</h2><p id="9530" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我们从声明一个互斥变量开始。我们用<code class="du mb mc md lo b">sem_init(&amp;mutex, 0, 1)</code>初始化它。第一个参数是我们试图初始化的信号量，<code class="du mb mc md lo b">0</code>允许信号量在线程间共享，<code class="du mb mc md lo b">1</code>是我们想要用来初始化<code class="du mb mc md lo b">sem_t mutex</code>的值。<a class="ae kp" href="http://man7.org/linux/man-pages/man3/sem_init.3.html" rel="noopener ugc nofollow" target="_blank">了解更多</a>。总是将信号量初始化为正数，稍后我会解释为什么。</p><p id="3e01" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated"><code class="du mb mc md lo b">thread 1</code>和<code class="du mb mc md lo b">thread 2</code>的片段非常相似。我们调用<code class="du mb mc md lo b">sem_wait(&amp;mutex)</code>，这相当于获取访问权。下面是这个函数如何工作的伪代码</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7a7f" class="kv iu hi lo b fi ls lt l lu lv">sem_wait(semaphore){<br/>    if semaphore greater than 0<br/>        semaphore -1<br/>        return;<br/>    else<br/>        wait/sleep<br/>}</span></pre><p id="365f" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated">根据上面的代码，即使是第一个访问临界区的线程，信号量也必须初始化为正数。当第一个线程访问临界区时，<code class="du mb mc md lo b">mutex = 1</code>，调用<code class="du mb mc md lo b">sem_wait</code>将减少互斥量和<code class="du mb mc md lo b">mutex = 0</code>并返回。允许第一个线程进入临界区。</p><p id="51fb" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated">当第一个线程正在访问临界区时，另一个线程试图进入临界区，它调用<code class="du mb mc md lo b">sem_wait(&amp;mutex)</code>，但是<code class="du mb mc md lo b">mutex= 0</code>因此它被置于睡眠或被迫等待。</p><p id="2467" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated">第一个使用完临界区，调用<code class="du mb mc md lo b">sem_post(&amp;mutex)</code>，相当于释放访问。下面是<code class="du mb mc md lo b">sem_post</code>的伪代码。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7b68" class="kv iu hi lo b fi ls lt l lu lv">sem_post(semaphore){<br/>    semaphore + 1<br/>    wake up the first thread in line to access the critical section  <br/>}</span></pre><p id="b99f" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated">在第一个线程调用<code class="du mb mc md lo b">sem_post(&amp;mutext)</code>后，第二个线程醒来并进入临界区，过程重复。</p><h1 id="23cc" class="it iu hi bd iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq bi translated">最后一个音符</h1><p id="d390" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">如果你想进入多线程编程，理解这个概念是至关重要的。</p></div><div class="ab cl im in gp io" role="separator"><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir"/></div><div class="hb hc hd he hf"><p id="2c98" class="pw-post-body-paragraph jr js hi jt b ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko hb bi translated"><em class="mf">最初发布于</em><a class="ae kp" href="https://www.devsurvival.com/synchronization-and-critical-section/" rel="noopener ugc nofollow" target="_blank">https://www . dev survival . com/synchron ization-and-critical-section/</a></p></div></div>    
</body>
</html>