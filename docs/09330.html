<html>
<head>
<title>C++ Intro to Standard Template Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++标准模板库介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-intro-to-standard-template-library-f9b9aded007d?source=collection_archive---------33-----------------------#2020-09-01">https://medium.com/analytics-vidhya/c-intro-to-standard-template-library-f9b9aded007d?source=collection_archive---------33-----------------------#2020-09-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/819d307a486573d89b32e96d9b9112d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXpdAT7EJe6gH08hInhjvw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">弗兰克·麦肯纳在<a class="ae iu" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="299d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">STL 简介</h1><p id="aeef" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">容器公开了<em class="kr">迭代器</em>接口，算法在<em class="kr">迭代器</em>上工作。</p><h1 id="b74c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><code class="du ks kt ku kv b">std::vector</code></h1><p id="04fe" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">遍历向量的例子如下。迭代器的行为类似于增强指针。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="60d1" class="le iw hi kv b fi lf lg l lh li">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="81c7" class="le iw hi kv b fi lj lg l lh li">int main()<br/>{<br/>    vector&lt;int&gt; nums;<br/>    nums.push_back(3);<br/>    nums.push_back(1);<br/>    nums.push_back(2);</span><span id="b595" class="le iw hi kv b fi lj lg l lh li">    vector&lt;int&gt;::iterator first = nums.begin();<br/>    vector&lt;int&gt;::iterator onePastLast = nums.end();</span><span id="a5f9" class="le iw hi kv b fi lj lg l lh li">    for(vector&lt;int&gt;::iterator i = first; i != onePastLast; i++)<br/>    {<br/>        cout &lt;&lt; "Next Element is " &lt;&lt; *i &lt;&lt; endl;<br/>    }</span><span id="c324" class="le iw hi kv b fi lj lg l lh li">    //sorting a vector<br/>    sort(first,onePastLast); //after sorting 1,2,3<br/>}</span></pre><h1 id="d736" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">容器的类型</h1><ul class=""><li id="d603" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">序列容器(数组和链表):vector、deque、list、forward list 和 array</li><li id="9a98" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">关联容器(二叉树) :集合、多重集合、映射和多重映射</li><li id="44e8" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">无序容器(哈希表) :无序集/多重集，无序映射/多重映射</li></ul><h2 id="7cf7" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">序列容器</h2><p id="2ea6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">向量是一个单向增长的动态数组。它有一个返回大小的<code class="du ks kt ku kv b">size()</code>成员函数。可以使用索引操作符<code class="du ks kt ku kv b">[]</code>访问向量。然而，使用该操作符<br/>不提供范围检查。使用<code class="du ks kt ku kv b">vec.at(2)</code>，它会抛出指数超出范围异常。C++11 遍历向量的方式是:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="e145" class="le iw hi kv b fi lf lg l lh li">for(auto&amp; v : vec)<br/>{<br/>    cout &lt;&lt; "Element is "&lt;&lt; v &lt;&lt; endl;<br/>}</span></pre><p id="580b" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated"><code class="du ks kt ku kv b">empty()</code>可以检查容器是否是空的。<code class="du ks kt ku kv b">size</code>提供容器的大小。<code class="du ks kt ku kv b">clear()</code>移除容器中的所有项目。<code class="du ks kt ku kv b">swap</code>交换两个容器的内容。</p><h2 id="2153" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">矢量的性能特征</h2><ul class=""><li id="ad17" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">O(1)在末尾插入/移除</li><li id="01c9" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">O(N)在开头或中间插入/删除</li><li id="5284" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">搜索</li></ul><h2 id="5963" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">双端队列</h2><p id="1e6b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">deque 可以在结尾或开头增长。示例:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="a94c" class="le iw hi kv b fi lf lg l lh li">deque&lt;int&gt; q = {1,2,3};<br/>deq.push_front(5); <br/>deq.push_back(10);</span><span id="a1e2" class="le iw hi kv b fi lj lg l lh li">cout &lt;&lt; deq[2] &lt;&lt; endl;</span></pre><h2 id="fba2" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">德克的性能特点</h2><ul class=""><li id="7976" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">O(1)在开头或结尾插入/删除</li><li id="29e2" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">O(N)在中间插入/移除</li><li id="6b7b" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">搜索</li></ul><h2 id="335e" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">目录</h2><p id="5dea" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">列表是一个双向链表，可以按如下方式可视化:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/4445b76b7ea8ae7ff479f9438c3eb939.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*PZ3GlcalNpTrMGAr.png"/></div></figure><p id="09bd" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">列表在列表中的任何地方提供快速插入/移除。</p><h2 id="e951" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">列表的性能特征</h2><ul class=""><li id="9365" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">O(1)在任何地方插入/移除</li><li id="4d7f" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">搜索</li><li id="3310" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">随机存取</li></ul><p id="de25" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">代码示例:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6084" class="le iw hi kv b fi lf lg l lh li">list&lt;int&gt; lst = {5,2,9};<br/>lst.push_back(6);<br/>lst.push_front(10);</span><span id="8f24" class="le iw hi kv b fi lj lg l lh li">list&lt;int&gt;::iterator foundLoc = find(lst.begin(), lst.end(), 2);<br/>lst.insert(foundLoc,8); //{5,8,2,9}</span><span id="f45b" class="le iw hi kv b fi lj lg l lh li">foundLoc++; //iterator points to 9<br/>lst.erase(foundLoc); //removes 9</span></pre><p id="b2b9" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">因为 vector 将数据存储在连续的内存块中。因此，当它被放入缓存时，很多数据都可以被缓存。但是，对于链表，可能会有许多缓存未命中。</p><p id="3496" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">列表可用于快速拼接:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="a3d3" class="le iw hi kv b fi lf lg l lh li">lst.splice(itr,mylist2,itr_one, itr_two);</span></pre><p id="c7cc" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">前向链表就像链表一样，只是它是单向链接的。</p><p id="453e" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">STL 为原生数组提供了一个薄薄的包装。但是它们不能动态调整大小。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="4db5" class="le iw hi kv b fi lf lg l lh li">array&lt;int 3&gt;a = {3,4,5};</span></pre><h2 id="cac7" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">关联容器</h2><p id="e608" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">关联容器由二叉树实现，并且总是被排序。按照“push_back()或<code class="du ks kt ku kv b">push_front()</code>。</p><p id="8e93" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">集合不提供重复的项目。插入需要 O(N log N)。成员函数<code class="du ks kt ku kv b">find</code>花费 O(log N)时间。<code class="du ks kt ku kv b">insert</code>函数返回一对值(<code class="du ks kt ku kv b">pair&lt;set&lt;int&gt;::iterator, bool&gt;ret</code>)。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="e409" class="le iw hi kv b fi lf lg l lh li">set&lt;int&gt; st;<br/>st.insert(3);<br/>st.insert(1);<br/>st.insert(2); {1,2,3}</span></pre><p id="609e" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated"><code class="du ks kt ku kv b">multiset</code>允许重复项目。插入总是成功的。对于 set 和 multiset，元素的值不能修改。</p><h2 id="4136" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">集合/多重集合的属性</h2><ul class=""><li id="d5d3" class="lk ll hi jv b jw jx ka kb ke lm ki ln km lo kq lp lq lr ls bi translated">o(对数)搜索</li><li id="9ee3" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">与向量和队列相比，遍历速度较慢</li><li id="5abe" class="lk ll hi jv b jw lt ka lu ke lv ki lw km lx kq lp lq lr ls bi translated">没有随机访问</li></ul><h2 id="6535" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">地图/多功能地图</h2><p id="b9b7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Map 和 multimap 处理键和值。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="ae6c" class="le iw hi kv b fi lf lg l lh li">map&lt;char,int&gt; mymap;<br/>mymap.insert(make_pair('a',100));</span><span id="31b9" class="le iw hi kv b fi lj lg l lh li">map&lt;char,int&gt;::iterator it = mymap.begin();</span><span id="87c6" class="le iw hi kv b fi lj lg l lh li">it = mymap.find('a'); //O(log(n))</span><span id="c2e5" class="le iw hi kv b fi lj lg l lh li">//printing out:<br/>for(it = mymap.begin() ; it != mymap.end(); it++)<br/>{<br/>    cout &lt;&lt; (*it).first &lt;&lt; "=&gt;" &lt;&lt; (*it).second &lt;&lt; endl;<br/>}</span></pre><p id="ca0d" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">多重映射允许重复键。地图是根据关键字排序的。Set 和 multimap 是 map/multimap 的特例，其中键与值相同。</p><h2 id="36f5" class="le iw hi bd ix ly lz ma jb mb mc md jf ke me mf jj ki mg mh jn km mi mj jr mk bi translated">无序关联容器(C++11)</h2><p id="3430" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">无序容器是由哈希表实现的。在哈希表中查找元素是 O(1)。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="5219" class="le iw hi kv b fi lf lg l lh li">unordered_set&lt;string&gt; myset = {"Red", "Green", "Blue"};<br/>unordered_set&lt;string&gt;::const_iterator it = myset.find("Green"); //Amortized O(1)<br/>if(it != myset.end()) //need to check!<br/>{<br/>    cout &lt;&lt; "Found " &lt;&lt; *it &lt;&lt; endl;<br/>}</span><span id="7e1f" class="le iw hi kv b fi lj lg l lh li">vector&lt;string&gt; myvec = {"Teal","Purple"};<br/>myset.insert(myvec.begin(), myvec.end());</span></pre><p id="7856" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">分摊的 O(1)可能会因为哈希冲突而降级。无序映射示例:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="de2b" class="le iw hi kv b fi lf lg l lh li">unordered_map&lt;char, string&gt; day = {{'S',"Sunday"}, {'M',"Monday"}};</span><span id="40cf" class="le iw hi kv b fi lj lg l lh li">cout &lt;&lt; day['S'] &lt;&lt; endl; //has no range check<br/>cout &lt;&lt;day.at['S'] &lt;&lt; endl; //has range check</span><span id="35bd" class="le iw hi kv b fi lj lg l lh li">day['W'] = "Wednesday"; //same as inserting. Can modify existing member<br/>day.insert(make_pair('T',"Thursday"));</span></pre><p id="4d35" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">multimap 和 unordered_multimap 不能用于关联数组，因为它们没有唯一键，也没有实现<code class="du ks kt ku kv b">[]</code>操作符。</p><p id="b789" class="pw-post-body-paragraph jt ju hi jv b jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq hb bi translated">STL 提供了容器适配器堆栈(LIFO)、队列(FIFO)和优先级队列-第一项具有最高优先级。基于数组的容器，如 vector 和 deque，可能会在添加/删除元素时使指针(原始指针、迭代器和引用)失效。</p><h1 id="c6d1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">参考</h1><p id="a99c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">https://www.youtube.com/watch?v=gxZJ5JNuWMY 伯虔 STL 视频:<a class="ae iu" href="https://www.youtube.com/watch?v=gxZJ5JNuWMY" rel="noopener ugc nofollow" target="_blank"/></p><div class="mr ms ez fb mt mu"><a href="https://codingadventures1.blogspot.com/2020/02/stl-part-i.html" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">STL 第一部分</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">容器暴露接口，算法在迭代器上工作。遍历一个向量的例子是…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni io mu"/></div></div></a></div></div></div>    
</body>
</html>