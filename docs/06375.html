<html>
<head>
<title>Object Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-oriented-programming-9bbf8a6de2b3?source=collection_archive---------7-----------------------#2020-05-20">https://medium.com/analytics-vidhya/object-oriented-programming-9bbf8a6de2b3?source=collection_archive---------7-----------------------#2020-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9540" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">面向对象的概念及其使用</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/4d0af25bfe07704b4c4ac1b2bb27146e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/0*TgT3nCQQ06E8U51H.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated"><a class="ae jj" href="https://static.javatpoint.com/images/java-oops.png" rel="noopener ugc nofollow" target="_blank">ref:https://static . Java point . com/images/Java-oops . png</a></figcaption></figure><p id="e78e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi kg translated">当你听到OOP时，你会想到什么？？有时候看起来就像三个字母。是的，是真的，是三个字母。但是在这背后，有一些每个程序员都应该知道的概念。</p><p id="6522" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">OOP代表面向对象编程。面向对象编程可以被解释为一组强大的概念，试图将现实世界的对象建模成代码。我们考虑类、对象和方法..用oop概念写代码的时候等等。我们需要在编码时熟悉这些词。<br/>那么让我们来看看这些强有力的概念是什么。</p><p id="18c7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">OOP中有四个主要的概念。他们是，</p><ul class=""><li id="6771" class="kp kq hi jm b jn jo jq jr jt kr jx ks kb kt kf ku kv kw kx bi translated">遗产</li><li id="1d80" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">多态性</li><li id="4c10" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">抽象</li><li id="eee6" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">包装</li></ul><p id="cc3b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在我将逐一解释这些事情。首先我们需要知道一些关键词。他们是，</p><h2 id="e5ad" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">班级</h2><p id="8296" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">一堂课就像一张蓝图。这也是一个逻辑定义。它布局了对象的基本结构。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/2cb20cae30210a60395097ba5f06a46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xf3wfEehMVdvznQNuzwrQg.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">一个类的例子</figcaption></figure><p id="5f87" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">根据这一点，我们班是动物。所以动物代表了动物的种类。与动物相关的属性和函数位于类中。</p><h2 id="7b5c" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">目标</h2><p id="99d6" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">现实世界中存在的一切都是对象。对象也是模拟现实世界对象的类的实例。例如，一个类可能产生几个对象</p><blockquote class="mi mj mk"><p id="24d0" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated">根据房屋蓝图，我们可以建造几栋相似的房屋，但位置和名称不同。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/9069c8d6dc0ae80cda79bac59218b524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DMtbinn1hdqihoIzhdZrg.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">animalObj是动物类的对象名</figcaption></figure><p id="b2d5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这就是在java中用类形成对象的方法。在创建该类的对象后，该类中的所有内容都可以访问。</p><p id="9b14" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在让我们来确定oop的主要概念是什么。</p><h2 id="7e13" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">遗产</h2><p id="7331" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">这就像在现实世界中一代一代地继承相同的属性。</p><p id="7caf" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">例子:-动物发出声音，但是狗的声音和猫的声音是不同的，其他的也是。使得声音功能来自动物。</p><p id="fb63" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在让我们以代码为例。这有助于避免冗余。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/00b8d7970757cacd8639471002c5b280.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*yJCmONcc9m4fmdb2qceKjA.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">继承的例子</figcaption></figure><p id="6c6b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">想想一部旧手机。我们可以接电话，发短信，有时我们只能听收音机。但是一部新手机的功能不止这些。摄像头、视频、全球定位系统..等等。但它的功能就像老式手机一样，可以打电话、发短信、听广播..等等。因此，新手机拥有与旧手机相同的功能，这就是继承。</p><p id="e93e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在让我们用一个代码深入研究继承。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mq"><img src="../Images/176da44b71a66467c7d7a5419e3006fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8Rw8RzunY-cd33j8JLDOA.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">没有继承</figcaption></figure><p id="c8c6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">相同的功能在两个类中重复出现。但是当我们使用继承概念时，我们可以避免这个问题。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/5226f3da0a6f20cd6834f3cda0d57bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzuLO5-ZCjuky3xnlZIaHQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">遗产</figcaption></figure><p id="d73e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在继承的概念中我们有一个疑问。如果新电话是从旧电话继承来的，则超类(旧电话)的一些功能和属性不同于子类(新电话)。因此，需要在新手机类别中替换新手机的功能。所以我们应该有办法做到这一点，不是吗？。😁</p><p id="6088" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">当然有一种方法，那就是调用方法重写。在超越的意义上，你可能会有所感触。😉如果你觉得没有任何意义，不要担心我会教you✌️。</p><h2 id="5a52" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">方法覆盖</h2><p id="f1d1" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">这意味着当我们用不同的主体重写一个与超类中相同的方法时。例子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/125faa9c2c14c26e469dc8c77d00e180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*2cXgAknszNaF5_JWkx52-g.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">认为:人，猫，狗，继承自动物类</figcaption></figure><p id="6e83" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">只考虑吃函数，通常我们使用方法eat()作为超类。但是人和狗、猫的吃法是有区别的。所以我们不能只是继承那些方法然后使用它们。我们必须随心所欲地修改它。现在考虑一下人类阶级。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/d010c20ff92f7bc2e951829af211fa58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ja85fBJnNEBkELpltD9ZYA.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">方法重写示例</figcaption></figure><p id="ccaa" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们重写了eat()方法的主体；适合男士类。这就是调用方法重写。这是一个非常有用的概念。</p><p id="a4fc" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">当谈到方法覆盖时，我们不能只让方法重载。这也是一个简单的概念，但作为方法覆盖非常有用。现在就来看看吧。</p><h2 id="4b6d" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">方法重载</h2><p id="3988" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">这也是一个很重要的概念。这意味着我们在一个类中多次使用同一个方法。</p><p id="9ccc" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">但是调用该方法时可能会出错，因为有太多的方法具有相同的名称。所以这不可能发生。不能多次存在相同的命名方法。</p><p id="a3ad" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">显然应该有区别，不是吗？你可能会想到不同的😉。</p><p id="4dec" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这是参数签名。同名方法中应该是不同的。参数签名是带有参数的东西。就想一个这样的方法。</p><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="7e02" class="ld le hi mt b fi mx my l mz na">void method(int a){<br/>//something here<br/>}</span></pre><p id="bfd5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这里的参数都是整型的。所以参数签名是' int a '</p><pre class="iy iz ja jb fd ms mt mu mv aw mw bi"><span id="5fc8" class="ld le hi mt b fi mx my l mz na">void method(int a, String s){<br/>//something here<br/>}</span></pre><p id="d748" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在这个方法中，参数签名是<code class="du nb nc nd mt b">int a , String s </code>,所以你可以看到有相同的方法名并不重要，因为它有不同的参数。那是参数签名。</p><p id="dc5b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在让我们看一个例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/98a1d615369ccb9623e156a71ef6fd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSxY9DzobnLoEB-I-edI-A.png"/></div></div></figure><p id="66a9" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">过载方法示例</p><p id="1582" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">就像上面的例子，如果我们调用method1()，它是关于第7行的一个方法。如果我们调用一个方法1(5 ),它是关于第10行的一个方法。如果我们调用一个method1(3，4)，它是关于第14行中的方法。就是这样。</p><h2 id="8576" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">多态性</h2><p id="8bad" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">多态性意味着同一事物的多种形式。比如相同的属性用不同的方法，相同的方法用不同的属性。</p><p id="9062" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一个子类的对象可以赋值给超类引用，并且有许多带有超类引用的形式。我的意思是许多形式😉。这就是多态性。</p><blockquote class="mi mj mk"><p id="1632" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated">有两种类型的多态性。</p></blockquote><ol class=""><li id="316d" class="kp kq hi jm b jn jo jq jr jt kr jx ks kb kt kf ne kv kw kx bi translated"><strong class="jm hj">静态多态</strong>以及被认为是<strong class="jm hj">编译时多态</strong></li><li id="9719" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ne kv kw kx bi translated"><strong class="jm hj">动态多态</strong>以及被认为是<strong class="jm hj">的运行时多态</strong></li></ol><p id="2947" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">关于这个概念，我们应该知道两件事。</p><ul class=""><li id="cc06" class="kp kq hi jm b jn jo jq jr jt kr jx ks kb kt kf ku kv kw kx bi translated">覆盖-用于运行时多态性</li><li id="438e" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">重载-用于编译时多态</li></ul><p id="8e65" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">举个例子。就这样想。</p><p id="908a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">有一类人。在它里面有一个函数walk()，所以我们可以在扩展后覆盖它。(继承)</p><p id="c757" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一个继承的功能是在子类中“手牵手向前走”。这就是方法重载。<br/>而另一个继承的功能是子类内的“反向步行”。这就是方法重写。</p><p id="b51f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">运行时多态性和编译时多态性的主要区别是JVM识别哪个方法应该在哪个时间运行并运行它。但是在编译时，重载的方法可以被识别，而重写的方法不能被识别，因为哪个方法应该运行的决定是在运行时决定的。这就是为什么它被称为运行时多态性。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/bfb5eb6ffd3e11c28d2a6c6a21aa9429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdhMoU2FTIHAiyE7DVCrCw.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">静态绑定-编译时多态性(不同的参数签名)</figcaption></figure><p id="9ebc" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">它有相同的方法，但不同的参数签名。这是方法重载。这被称为编译时多态性(我们一眼就能看出方法的不同)</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/db28c07089f47b813595b56f72a597db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRqt635p7fKLI2xwRG6jyA.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">动态多态-运行时多态</figcaption></figure><p id="aa1f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这里，子类的对象已经分配给了超类的引用。当我们调用vh.drive()时，它运行car类中的drive方法。</p><h2 id="d3cf" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">抽象</h2><p id="b396" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">当我们只是使用函数而不知道机制(函数发生了什么)时，就使用了抽象，并且忽略了对象的不相关的特征。抽象用于信息隐藏。</p><p id="d6da" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><em class="ml">在现实世界的例子中:- </em></p><blockquote class="mi mj mk"><p id="eee9" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated">我们知道如何通过按压加速踏板来加速车辆。我们也知道如何通过踩刹车垫来停车。但是我们不知道这些功能的机制，我们只是想用就用。但是我们不需要这个机制。就用那些函数吧。这是一个抽象概念。让我们看得更远。</p></blockquote><p id="a7da" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><em class="ml">另一个例子:- </em></p><blockquote class="mi mj mk"><p id="3c56" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated">在咖啡机中，我们不知道咖啡是如何制作的，有哪些成分，但我们知道当按下按钮时，可以从机器中得到一杯咖啡。(我们知道产量但不知道机理)。</p></blockquote><p id="23a5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在你可能会怀疑，如果抽象方法没有体，怎么隐藏信息，或者怎么写方法体。😉</p><p id="7033" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">答案很简单。我们可以使用方法覆盖技术来访问抽象方法。我们必须使用继承并获得超类的抽象方法。</p><p id="01c7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">参见上面的例子</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/03f45161bbea3cb473fdf10c75ea41dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dk8_xUhrJSVFv5PkVfy3Yw.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">抽象</figcaption></figure><blockquote class="mi mj mk"><p id="a3e6" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated"><strong class="jm hj">抽象的优势</strong></p></blockquote><ul class=""><li id="6ed1" class="kp kq hi jm b jn jo jq jr jt kr jx ks kb kt kf ku kv kw kx bi translated">避免重复，提高可重用性</li><li id="e69d" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">降低复杂性</li><li id="f729" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">安全数据</li></ul><blockquote class="mi mj mk"><p id="33be" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated"><strong class="jm hj">抽象类&amp;抽象方法</strong></p></blockquote><ul class=""><li id="cd01" class="kp kq hi jm b jn jo jq jr jt kr jx ks kb kt kf ku kv kw kx bi translated">抽象方法应该在抽象类中，但是抽象类不应该只有抽象方法</li><li id="420e" class="kp kq hi jm b jn ky jq kz jt la jx lb kb lc kf ku kv kw kx bi translated">抽象方法不应该有主体。</li></ul><h2 id="1bde" class="ld le hi bd lf lg lh li lj lk ll lm ln jt lo lp lq jx lr ls lt kb lu lv lw lx bi translated">包装</h2><p id="5c24" class="pw-post-body-paragraph jk jl hi jm b jn ly ij jp jq lz im js jt ma jv jw jx mb jz ka kb mc kd ke kf hb bi translated">封装意味着在一个部分中封装属性和方法。就像一个医疗胶囊，里面装着药物，但我们不知道它们的成分是什么，也看不到它们，因此我们没有苦味。我们只看到胶囊。</p><p id="fe4f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">数据隐藏是封装概念中的关键特征。我们使用访问修饰符来实现封装概念。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/c21704e1586254bf25ccd09213e56c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MuKH88mVK0u-BkoRxq0PA.png"/></div></div></figure><p id="8ac1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在上面的例子中，姓名、年龄是保密的。不能直接访问，所以我们可以使用getters和setters来获取和设置胶囊中的值。getName()、getAge()是用于获取值的getters。和setName()、setAge()是用于设置值的设置器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/183cad4ec29087efc42afc415e6d467d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3XvZSd7thEHxYhb7eCLQQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">包装</figcaption></figure><p id="d6f8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这就是我们如何在java中使用封装。</p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="46ba" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我希望你从这篇文章中有所收获。这就是oop的概念及其用途。</p><blockquote class="nm"><p id="47d4" class="nn no hi bd np nq nr ns nt nu nv kf dx translated">编码快乐！！</p></blockquote><h2 id="3f37" class="ld le hi bd lf lg nw li lj lk nx lm ln jt ny lp lq jx nz ls lt kb oa lv lw lx bi translated">关于作者</h2><blockquote class="mi mj mk"><p id="61bb" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated">卡温杜·加扬塔</p><p id="3f88" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated"><em class="hi">本科</em></p><p id="2c63" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated"><em class="hi">软件工程荣誉理学士</em></p><p id="90b9" class="jk jl ml jm b jn jo ij jp jq jr im js mm ju jv jw mn jy jz ka mo kc kd ke kf hb bi translated"><em class="hi">凯拉尼亚大学。</em></p></blockquote></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><div class="iy iz ja jb fd ob"><a href="https://kavindu-gayantha.github.io/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab dw"><div class="od ab oe cl cj of"><h2 class="bd hj fi z dy og ea eb oh ed ef hh bi translated">卡温杜·加扬塔</h2><div class="oi l"><h3 class="bd b fi z dy og ea eb oh ed ef dx translated">编辑描述</h3></div><div class="oj l"><p class="bd b fp z dy og ea eb oh ed ef dx translated">kavindu-gayantha.github.io</p></div></div><div class="ok l"><div class="ol l om on oo ok op jd ob"/></div></div></a></div></div></div>    
</body>
</html>