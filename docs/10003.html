<html>
<head>
<title>Python Package Management with Pipenv</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pipenv的Python包管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-package-management-with-pipenv-63a2bab99300?source=collection_archive---------11-----------------------#2020-09-29">https://medium.com/analytics-vidhya/python-package-management-with-pipenv-63a2bab99300?source=collection_archive---------11-----------------------#2020-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pipenv是一个现代的包管理器，它将其他语言中的最佳包管理实践引入到Python中。为了理解Pipenv的好处，让我们从为什么我们应该使用包管理器开始。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/0c7558c5fdb9391ddd8f602a9e05d5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3AZBuLDQQsS8OMMc"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@stefyaich?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">夏羽·亚伊奇</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d8d6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为什么要做包管理？</h1><p id="bf69" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在一些只有一两个程序员的小项目中使用Python是微不足道的。然而，随着团队和项目规模的增长，问题开始出现。</p><p id="9f15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一群人在一个Python项目中工作。艾伦成功地开始了这个项目，然后把它转给了鲍勃。Bob在他的机器上检查了这个项目，发现它不能在他的机器上运行，因为Alan使用了一些包的较新版本。Bob试图将这些包更新到Alan使用的相同版本，但是后来他发现这些更新破坏了他与Carthy合作的项目的另一部分。在这一点上，Bob的选择是要么修复Alan代码中的依赖问题，要么修复Carthy代码中的依赖问题，这两者都不容易，而且没有破坏其他代码的风险。</p><p id="acc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这类问题是包管理器的任务。</p><p id="ec09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现代包装管理包括两个主要概念:</p><ol class=""><li id="1f8f" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">依赖性管理</li><li id="5d8b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">环境隔离</li></ol><p id="b411" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖管理声明项目使用什么包，这些包依赖于什么其他包，以及它们确切使用什么版本。它允许在同一个项目中工作的每个人都使用相同的版本，消除了代码中的兼容性和功能性问题。</p><p id="0d1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">环境隔离是一种保持每个项目的依赖关系完全隔离的机制。它允许一个项目使用一组依赖项，而另一个项目使用另一组依赖项，它们可能是不同的版本。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="0450" class="ju jv hi bd jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr bi translated">Python的包管理方式</h1><p id="56cb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Python的一个主要缺点是缺乏内置的包管理系统。与其他现代语言如<em class="lx"> NodeJS </em>或<em class="lx"> Go </em>不同，Python没有设计包管理机制。默认情况下，每个软件包都由用户手动安装到所谓的“基础环境”中，在这个环境中，安装的软件包可以在整个系统中看到和使用。这种行为正是前面提到的问题的原因。基础环境(也称为全局环境)的使用使得项目无法独立管理它们的依赖关系。</p><p id="2f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python程序员通过使用<code class="du ly lz ma mb b">virtualenv</code>包和<code class="du ly lz ma mb b">pip</code>( Python的默认包安装程序)创建一个“临时”包管理实践来解决这个限制。</p><p id="6dae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma mb b">virtualenv</code>包允许一个项目通过创建一个虚拟环境来实现环境隔离，这个虚拟环境隐藏了基础环境。在虚拟环境中，所有代码的行为就好像包安装在基础环境中一样，即使它们安装在项目本身中。</p><p id="6c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现依赖管理，Python程序员使用所谓的<code class="du ly lz ma mb b">requirements.txt</code>文件作为依赖声明。该文件是使用<code class="du ly lz ma mb b">pip</code>创建的，在重新创建项目时由<code class="du ly lz ma mb b">pip</code>使用。</p><h1 id="d62a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">标准包装管理实践</h1><p id="8ed9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">第一个程序员通过以下方式创建新项目:</p><ol class=""><li id="078f" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">使用<code class="du ly lz ma mb b">virtualenv</code>为项目创建一个新的虚拟环境</li><li id="95d2" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">使用<code class="du ly lz ma mb b">pip install</code>安装所有依赖项</li><li id="5e10" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">使用<code class="du ly lz ma mb b">pip freeze &gt; requirements.txt</code>命令创建需求文件。</li></ol><p id="f586" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个程序员可以通过</p><ol class=""><li id="fd3b" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">使用<code class="du ly lz ma mb b">virtualenv</code>为项目创建一个新的虚拟环境</li><li id="dfc3" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">使用<code class="du ly lz ma mb b">pip install -r requirements.txt</code>安装所有依赖项</li></ol><h1 id="f19d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">当前解决方案的问题</h1><p id="d9f8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">虽然标准实践允许Python程序员实现其他语言的包管理器所提供的相同功能，但它包含两个主要缺陷:</p><ol class=""><li id="120c" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">虚拟环境和依赖关系管理是分开的</li><li id="9d3a" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">需求文件不是真正的依赖管理</li></ol><h2 id="9233" class="mc jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">1.虚拟环境和依赖关系管理是分开的</h2><p id="374f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">对于Python程序员来说，处于错误的环境中太容易了。当程序员创建需求文件时，他们可能会错误地位于基础环境而不是虚拟环境中。因此，他们创建的需求文件列出了他们基础环境中的包，而这些包可能与项目中使用的包非常不同。更糟糕的是，当程序员从需求文件中安装依赖项时，它们也可能在基础环境中，而不是在预期的环境中。列出的软件包在系统范围内安装，其影响是他们想象中最糟糕的。</p><p id="1e50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python虚拟环境不容易激活的事实对这种情况没有帮助。人们很容易忘记在<code class="du ly lz ma mb b">pip install -r requirements.txt</code>之前<code class="du ly lz ma mb b">source venv/bin/activate</code>，并看到他们的工作机器在他们眼前腐败。</p><h2 id="f93a" class="mc jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">2.需求文件不是真正的依赖管理</h2><p id="f49e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><code class="du ly lz ma mb b">pip freeze &gt; requirements.txt</code>到底是做什么的？<code class="du ly lz ma mb b">pip freeze</code>命令的作用是将所有已安装软件包的列表及其版本号打印到屏幕上。<code class="du ly lz ma mb b">&gt; requirements.txt</code>是一个叫做<em class="lx">重定向</em>的小命令行技巧。这意味着将这些打印文本写入<code class="du ly lz ma mb b">requirements.txt</code>文件。因此，需求文件的内容是环境中所有已安装的包及其版本号的列表。</p><p id="0810" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将它与其他包管理器的依赖关系管理文件进行比较，例如<em class="lx"> npm </em>或<em class="lx"> cargo </em>，差异非常明显。</p><p id="51a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。这个requirements.txt属于什么项目？</strong></p><p id="38bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖文件应该包含项目的名称和版本号，这样就不可能混淆项目/版本之间的依赖关系。</p><p id="489b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。没有依赖关系层次</strong></p><p id="c4d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个程序员安装了他们需要的一个包。然后他们创建了一个<code class="du ly lz ma mb b">requirements.txt</code>文件，发现里面列出了十几个软件包。<code class="du ly lz ma mb b">requirements.txt</code>中列出的大多数包都是列表中其他包的依赖项。项目所依赖的、由程序员安装的包和那些<em class="lx">顶层</em>包所依赖的包之间没有区别。</p><p id="b7cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么使用<code class="du ly lz ma mb b">requirements.txt</code>作为依赖文件是个坏主意的主要原因。当存在冲突包问题时，大多数情况下，冲突包是那些依赖包，而不是顶层包。因为程序员自己通常不知道他们安装的包依赖于什么包，所以手动避免冲突是不可能的。</p><p id="7b30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现代的包管理器通常将依赖分成这两组。由程序员手动安装的“真正的”依赖项存储在主依赖项文件中。依赖关系的依赖关系在安装过程中被解析，并存储在一个单独的文件中，通常称为<em class="lx">锁文件</em>。</p><p id="2869" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。作为要求的包版本。</strong></p><p id="f7de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ly lz ma mb b">requirements.txt</code>中的版本号是准确的。当它显示<code class="du ly lz ma mb b">numpy==1.19.1</code>时，只能安装1.19.1版本。依赖文件中的版本号应该是有条件的。例如，它应该指出项目是否需要1.19.1版本，或者包括任何更新的版本(&gt; =1.19.1)，或者任何版本(*)。这允许解析器找到最适合项目的版本。实际使用的版本将被记录在锁文件中。</p><p id="8781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数包管理器还将主要依赖项(程序逻辑所需的包)和用于开发目的(如测试和调试)的开发依赖项分开。通过这种设置，只有相关的包将被打包并分发给最终用户。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="4590" class="ju jv hi bd jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr bi translated">Pipenv简介</h1><p id="8677" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Pipenv 是一个Python包管理器，旨在为Python引入一个优秀的现代包管理器。来自Pipenv官方文档:</p><blockquote class="mq mr ms"><p id="aa15" class="if ig lx ih b ii ij ik il im in io ip mt ir is it mu iv iw ix mv iz ja jb jc hb bi translated"><em class="hi"> Pipenv是一个生产就绪的工具，旨在将所有打包世界的精华引入Python世界。</em></p></blockquote><p id="6e98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pipenv是<code class="du ly lz ma mb b">virtualenv</code>和<code class="du ly lz ma mb b">pip</code>的包装器。它支持Python中的依赖管理和环境隔离，这符合其他语言的包管理器所遵循的实践。使用pipenv解决了上述所有问题，无需任何手动过程。</p><h1 id="f09a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何使用pipenv</h1><h2 id="36a1" class="mc jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">装置</h2><p id="74d5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">按照<a class="ae jd" href="https://pypi.org/project/pipenv/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/pipenv</a>上的说明安装pipenv</p><h2 id="cce4" class="mc jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">创建新项目并安装新包</h2><p id="6542" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要创建一个新项目，只需通过</p><pre class="jf jg jh ji fd mw mb mx my aw mz bi"><span id="bdd6" class="mc jv hi mb b fi na nb l nc nd">pipenv install &lt;package name&gt;</span></pre><p id="419a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pipenv将创建新的Pipfile——这是一个依赖文件——如果还不存在的话。否则，它将更新Pipfile来添加新的包。</p><p id="02d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，Pipenv将解析依赖列表并创建锁文件(Pipfile.lock)。</p><h2 id="3e8e" class="mc jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">激活虚拟环境</h2><p id="c66b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要激活和使用虚拟环境，只需运行</p><pre class="jf jg jh ji fd mw mb mx my aw mz bi"><span id="8978" class="mc jv hi mb b fi na nb l nc nd">pipenv shell</span></pre><p id="fab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进入在虚拟环境中运行的新外壳。所有已安装的软件包对于在这个shell中运行的任何程序都是可见的。</p><p id="8622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种选择是直接在虚拟环境中启动程序，而不进入shell。奔跑</p><pre class="jf jg jh ji fd mw mb mx my aw mz bi"><span id="d07e" class="mc jv hi mb b fi na nb l nc nd">pipenv run &lt;program name&gt;</span></pre><p id="b0ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个命令在许多常见的Python用例中非常方便，比如在使用Jupyter Notebook时。人们可以简单地</p><pre class="jf jg jh ji fd mw mb mx my aw mz bi"><span id="1f5f" class="mc jv hi mb b fi na nb l nc nd">pipenv run jupyter notebook</span></pre><p id="559b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在虚拟环境中启动新笔记本。</p><h2 id="9cff" class="mc jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">停用虚拟环境</h2><p id="1147" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要停用虚拟环境，只需在shell中键入<code class="du ly lz ma mb b">exit</code>。</p><h1 id="0e88" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="4316" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">尽管Python传统上缺乏一个好的包管理器，Pipenv最终将现代包管理的最佳特性带到了这种语言中，因此Python程序员现在可以跨多个项目高效、安全地工作。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="4164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lx">原载于2020年9月29日https://wattanit.com</em><a class="ae jd" href="https://wattanit.com/2020/09/python-package-management-with-pipenv/" rel="noopener ugc nofollow" target="_blank"><em class="lx"/></a><em class="lx">。</em></p></div></div>    
</body>
</html>