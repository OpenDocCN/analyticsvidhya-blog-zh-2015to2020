<html>
<head>
<title>Data Structures in Python 3; Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3中的数据结构；第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-structures-in-python-3-part-2-f019a95a8f45?source=collection_archive---------38-----------------------#2020-04-13">https://medium.com/analytics-vidhya/data-structures-in-python-3-part-2-f019a95a8f45?source=collection_archive---------38-----------------------#2020-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5002" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">字典和集合</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e940d68a2cd2a619c12be9c54d4a378a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7B4JdzawgVtu-tr3A-obw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用<a class="ae jt" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="de09" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">大家好！</p><p id="62e4" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在我的<a class="ae jt" rel="noopener" href="/@gaurav.prabhu7/data-structures-in-python-3-part-1-ec125c3c3dc6">上一篇文章</a>中，我曾经写过关于列表和元组的内容。我希望你们都喜欢它，如果你还没有读过，请去看看吧！</p><p id="a7e3" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在这篇文章中，我将讨论Python 3中的字典和集合数据结构。</p><h1 id="949f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">词典:</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/8103e013fcd9af979bb34686e052cc07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojzVIeckVUuBAPy8KO0TiQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Python中字典的图形表示</figcaption></figure><p id="ce92" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">与列表和元组不同，<em class="kt">字典</em>是一个无序的对象集合。字典中的每个元素都存储为“键-值”对。如果你熟悉散列表，那么这就是字典！</p><p id="df25" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">字典中的<strong class="jw hj">键</strong>可以是:</p><ol class=""><li id="787a" class="ku kv hi jw b jx jy kb kc kf kw kj kx kn ky kr kz la lb lc bi translated">性格；角色；字母</li><li id="80e1" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">线</li><li id="81fa" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">布尔代数学体系的</li><li id="2e64" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">元组</li><li id="ab9c" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">整数</li><li id="f166" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">浮点数</li></ol><p id="4fbc" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">和<strong class="jw hj">值</strong>可以是任何数据类型。注意我们<strong class="jw hj">不能为键使用列表或集合</strong>。</p><p id="a1a4" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">说明</strong>:</p><p id="76c7" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">List和set都是<strong class="jw hj">可变或可改变的</strong>对象。但是字典的关键永远不应该改变！特定键的值可以更改，但是字典中的键一旦创建就不能更改。可以，需要的话可以删除。</p><p id="bc7d" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你想对单个值使用多值键，或者如果你的键应该由多个元素组成，那么你应该<strong class="jw hj">使用一个元组</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/916aac3038ff7ab79e42deb3b99aad1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8g1DBtto99rAbexIW_NmVw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">字典中的多值键</figcaption></figure><p id="7f93" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">创建字典</strong>:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="05e8" class="lo ig hi lk b fi lp lq l lr ls"># First Method<br/>my_dict = dict()</span><span id="fde9" class="lo ig hi lk b fi lt lq l lr ls"># Second Method<br/>programming_languages = {1 : "C", 2: "C++", 3: "Python"}</span><span id="8375" class="lo ig hi lk b fi lt lq l lr ls"># Third Method<br/>cities= dict([(1, "Mangalore"), (2, "Bangalore")])</span></pre><p id="1674" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">可以使用<strong class="jw hj"> dict </strong>关键字或者使用一对大括号“{}”或者甚至使用元组列表并将其传递给<strong class="jw hj"> dict </strong>关键字来创建字典。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="cc43" class="lo ig hi lk b fi lp lq l lr ls">states = dict([("India", ["Karnataka", "Andhra Pradesh", "Tamil Nadu", "Maharashthra"])])<br/>print(states)</span><span id="13eb" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {'India': ['Karnataka', 'Andhra Pradesh', 'Tamil Nadu', 'Maharashthra']}</span></pre><p id="93c6" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在上面的例子中，我传递了一个列表作为元组的第二个元素，这是因为我想要一个列表中的值的字典。</p><p id="15f0" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">访问字典的元素</strong>:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="342d" class="lo ig hi lk b fi lp lq l lr ls">programming_languages = {1 : "C", 2: "C++", 3: "Python"}</span><span id="3de4" class="lo ig hi lk b fi lt lq l lr ls"># Method 1<br/>programming_languages[1] # C<br/>programming_languages[2] # C++<br/>programming_languages[3] # Python</span><span id="c6b3" class="lo ig hi lk b fi lt lq l lr ls"># Method 2<br/>for key in programming_languages.keys():<br/>    print(programming_languages[key])</span><span id="3f7b" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># C<br/># C++<br/># Python</span><span id="c361" class="lo ig hi lk b fi lt lq l lr ls"># Method 3<br/>for values in programming_languages.values():<br/>    print(values)</span><span id="c960" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># C<br/># C++<br/># Python</span><span id="503c" class="lo ig hi lk b fi lt lq l lr ls"># Method 4<br/>programming_languages.get(3) # Python</span></pre><p id="e8b5" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在第一种方法中，我们使用了字典的键来检索它的值。例如，我们知道“1”是“C”的键，因此当我们想要访问值“C”时，我们使用它的键“1”。</p><p id="7d65" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">注意<strong class="jw hj"> 1 </strong>是字典中的键<strong class="jw hj">不是索引</strong>。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="49bf" class="lo ig hi lk b fi lp lq l lr ls">dictionary = { "one": 1, "two": 2 }<br/>dictionary["one"] # 1</span></pre><p id="631d" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你试图访问一个不存在的密钥，你会得到一个密钥错误。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d3e0" class="lo ig hi lk b fi lp lq l lr ls">&gt;&gt;&gt; dictionary = { "one": 1, "two": 2 }<br/>&gt;&gt;&gt; dictionary[1]</span><span id="07af" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">------------</strong><br/><strong class="lk hj">KeyError</strong>                                  Traceback (most recent call last)<br/><strong class="lk hj">&lt;ipython-input-13-4f998a957d86&gt;</strong> in &lt;module&gt;<br/>      1 dictionary <strong class="lk hj">=</strong> <strong class="lk hj">{</strong> <strong class="lk hj">"one":</strong> <strong class="lk hj">1,</strong> <strong class="lk hj">"two":</strong> <strong class="lk hj">2</strong> <strong class="lk hj">}</strong><br/><strong class="lk hj">----&gt; 2 </strong>dictionary<strong class="lk hj">[1]</strong></span><span id="58a5" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">KeyError</strong>: 1</span></pre><p id="2434" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果我们想访问字典中的所有键或值，或者两者都访问，该怎么办？</p><p id="c782" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">然后我们使用以下方法:</p><ol class=""><li id="82dc" class="ku kv hi jw b jx jy kb kc kf kw kj kx kn ky kr kz la lb lc bi translated">keys()--&gt;返回字典中所有键的列表。</li><li id="8453" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">values() -&gt;返回字典中所有值的列表。</li><li id="0555" class="ku kv hi jw b jx ld kb le kf lf kj lg kn lh kr kz la lb lc bi translated">items() -&gt;返回一个元组列表，其中每个元组都是一个键-值对，如创建字典的方法3所示。</li></ol><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="42cc" class="lo ig hi lk b fi lp lq l lr ls">dictionary = { "list 1": [ 1, 2, 3 ], "list 2": [10, 20, 30] }<br/>for i in dictionary.items():<br/>    print(i)</span><span id="d44c" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># ('list 1', [1, 2, 3])<br/># ('list 2', [10, 20, 30])</span><span id="9eb7" class="lo ig hi lk b fi lt lq l lr ls">dictionary = { "list 1": [ 1, 2, 3 ], "list 2": [10, 20, 30] }<br/>for (key, value) in dictionary.items():<br/>    print("Key is {0}\tValue is {1}".format(key, value))</span><span id="4912" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># Key is list 1	Value is [1, 2, 3]<br/># Key is list 2	Value is [10, 20, 30]</span></pre><p id="78b1" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">嵌套字典</strong>:</p><p id="a378" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">嵌套字典只不过是另一个字典中的一个字典。对于另一个字典中的下一个字典，内部字典应该是父字典的特定键的值。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="cb7a" class="lo ig hi lk b fi lp lq l lr ls">movies = { "Hollywood" : {"Marvel" : ["Thor", "Ant Man", "Iron Man"]}, "Bollywood" : ["Uri", "Badla", "Raazi"]}</span><span id="3f7d" class="lo ig hi lk b fi lt lq l lr ls">movies["Hollywood"]</span><span id="694a" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {'Marvel': ['Thor', 'Ant Man', 'Iron Man']}</span><span id="570c" class="lo ig hi lk b fi lt lq l lr ls">movies["Hollywood"]["Marvel"]<br/># Output:<br/># ['Thor', 'Ant Man', 'Iron Man']</span></pre><p id="e228" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在这个例子中，父字典<em class="kt"> movies </em>有两个关键字“好莱坞”和“宝莱坞”，<em class="kt">漫威</em>是父字典的内部字典。</p><p id="c8a2" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">从字典中删除元素</strong>:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="acab" class="lo ig hi lk b fi lp lq l lr ls">movies = { "Hollywood" : {"Marvel" : ["Thor", "Ant Man", "Iron Man"]}, "Bollywood" : ["Uri", "Badla", "Raazi"]}</span><span id="4d70" class="lo ig hi lk b fi lt lq l lr ls"># Method 1<br/>del movies["Bollywood"]       <br/>del movies["Hollywood"]["Marvel"]</span><span id="908e" class="lo ig hi lk b fi lt lq l lr ls"># Method 2<br/>programming_languages.pop(2) # C++<br/># Removes item based on index</span><span id="6dec" class="lo ig hi lk b fi lt lq l lr ls"># Method 3<br/>programming_languages.popitem() # (3, 'Python')<br/># Removes last element</span><span id="2931" class="lo ig hi lk b fi lt lq l lr ls"># Clears all elements<br/>programming_languages.clear()</span></pre><p id="4b66" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">从字典中删除条目的第一种方法是使用<strong class="jw hj"> del </strong>关键字。通过使用<em class="kt"> del </em>关键字，可以从字典中删除整个键-值对。<em class="kt"> del </em>关键字通常用于删除整个对象并显式释放内存位置。要使用<em class="kt"> del </em>关键字从字典中删除键值对，基本语法如下:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d4e1" class="lo ig hi lk b fi lp lq l lr ls">del dictionary_name[key]</span></pre><p id="35f6" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">首先，我们应该访问字典的键，然后将它提供给关键字<em class="kt"> del </em>。</p><p id="3ad9" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">注意</strong>:如果你没有给出括号“[]”内的“key”，那么你会得到一个错误。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="b10b" class="lo ig hi lk b fi lp lq l lr ls">&gt;&gt;&gt; programming_languages = {1 : "C", 2: "C++", 3: "Python"}<br/>&gt;&gt;&gt; del programming_languages[]</span><span id="86c4" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">File "&lt;ipython-input-26-dc1af3caedca&gt;", line 2</strong><br/><strong class="lk hj">    del programming_languages[]</strong><br/><strong class="lk hj">                              ^</strong><br/><strong class="lk hj">SyntaxError:</strong> invalid syntax</span></pre><p id="1a9a" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果您没有提到“[]”中的键，那么整个字典都会被删除。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="93d4" class="lo ig hi lk b fi lp lq l lr ls">&gt;&gt;&gt; programming_languages = {1 : "C", 2: "C++", 3: "Python"}<br/>&gt;&gt;&gt; del programming_languages<br/>&gt;&gt;&gt; print(programming_languages)</span><span id="80ae" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">---------------</strong><br/><strong class="lk hj">NameError</strong>                                 Traceback (most recent call last)<br/><strong class="lk hj">&lt;ipython-input-27-06cfbe8ee886&gt;</strong> in &lt;module&gt;<br/>      1 programming_languages <strong class="lk hj">=</strong> <strong class="lk hj">{1</strong> <strong class="lk hj">:</strong> <strong class="lk hj">"C",</strong> <strong class="lk hj">2:</strong> <strong class="lk hj">"C++",</strong> <strong class="lk hj">3:</strong> <strong class="lk hj">"Python"}</strong><br/>      2 <strong class="lk hj">del</strong> programming_languages<br/><strong class="lk hj">----&gt; 3 </strong>print<strong class="lk hj">(</strong>programming_languages<strong class="lk hj">)</strong></span><span id="4de3" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">NameError</strong>: name 'programming_languages' is not defined</span></pre><h1 id="5712" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置:</h1><p id="8fbd" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr hb bi translated">在数学中，我们已经知道“集合是一个定义明确的对象集合”。Python中的一组数据结构，类似于数学中的定义，是定义明确的对象的集合。最重要的是，集合是独特或不同对象的集合。这意味着，集合数据结构中的元素不能重复。</p><p id="5e6e" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">创作集</strong>:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="1374" class="lo ig hi lk b fi lp lq l lr ls"># Method 1<br/>my_set = set([1, 't', 3.14, "Python", True])<br/># {1, 3.14, 't', 'Python'}</span><span id="1fab" class="lo ig hi lk b fi lt lq l lr ls"># Method 2<br/>set1 = {5, 6, 7}</span><span id="4b3c" class="lo ig hi lk b fi lt lq l lr ls"># Method 3<br/>new_set = set()</span></pre><p id="c4a0" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">Python中的set可以使用一个<strong class="jw hj"> set </strong>关键字或一对大括号“{}”来创建。不要因为大括号“{}”而将集合与字典混淆。使用一对大括号创建集合和字典。但是<em class="kt">字典</em>更多的是一个键值对，而集合只是元素的集合。</p><blockquote class="lz ma mb"><p id="c765" class="ju jv kt jw b jx jy jz ka kb kc kd ke mc kg kh ki md kk kl km me ko kp kq kr hb bi translated">即使他们外表看起来一样，但他们的内在却大不相同。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mf"><img src="../Images/01a15c16c29b619a889e14874589ed07.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*8RCifNkb7nqcYp5NTypcfw.jpeg"/></div></figure><p id="75c0" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">还要注意，在字典的情况下，我们在<em class="kt"> dict </em>方法中发送了一个<strong class="jw hj">元组列表</strong>，但是在集合的情况下，我们只向<em class="kt">集合</em>方法发送了一个<strong class="jw hj">列表</strong>。</p><p id="ee4b" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">设定分度</strong>:</p><p id="6ff9" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们<strong class="jw hj">不能</strong>指标一套！如果您尝试对集合进行索引，将会出现错误。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="7393" class="lo ig hi lk b fi lp lq l lr ls">s = {1, 2, 3}<br/>print(s[0])</span><span id="03e8" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">--------------</strong><br/><strong class="lk hj">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="lk hj">&lt;ipython-input-36-57de2ead9154&gt;</strong> in &lt;module&gt;<br/>      1 s <strong class="lk hj">=</strong> <strong class="lk hj">{1,</strong> <strong class="lk hj">2,</strong> <strong class="lk hj">3}</strong><br/><strong class="lk hj">----&gt; 2 </strong>print<strong class="lk hj">(</strong>s<strong class="lk hj">[0])</strong></span><span id="4b21" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">TypeError</strong>: 'set' object is not subscriptable</span></pre><p id="cb4d" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为什么？</p><p id="2046" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="kt"> set </em>数据类型主要是为了获取唯一的元素，而不是为了单独访问单个元素。集合中的元素是不可变的，而集合作为一个整体是可变的。此外，由于集合中的元素没有任何相关的索引，我们<strong class="jw hj">不能在集合中进行项目分配</strong>。</p><p id="b854" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">向集合添加元素</strong>:</p><p id="ef01" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">可以使用<em class="kt">添加</em>方法将元素添加到集合中。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d08e" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4}<br/>num_set.add(5)<br/>print(num_set)<br/># {1, 2, 3, 4, 5}</span></pre><p id="9479" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">向集合中添加修复性元素:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="c54b" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4, 5}<br/>print("Before adding elements:\t", num_set)<br/>num_set.add(4)<br/>num_set.add(5)<br/>num_set.add(6)<br/>num_set.add(7)<br/>print("After adding elements:\t", num_set)</span><span id="8eec" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># Before adding elements:	 {1, 2, 3, 4, 5}<br/># After adding elements:	 {1, 2, 3, 4, 5, 6, 7}</span></pre><p id="38c2" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你想一次将多个元素添加到一个集合中，那是不可能的。您不能直接将列表添加到集合中，而是必须<strong class="jw hj">遍历列表并逐个添加元素</strong>。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="67d8" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4, 5}<br/>elements_to_add = [10, 20, 30, 40, 50]<br/>num_set.add(elements_to_add)</span><span id="3615" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">-------------------</strong><br/><strong class="lk hj">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="lk hj">&lt;ipython-input-15-88645e7828d0&gt;</strong> in &lt;module&gt;<br/>      1 num_set <strong class="lk hj">=</strong> <strong class="lk hj">{1,</strong> <strong class="lk hj">2,</strong> <strong class="lk hj">3,</strong> <strong class="lk hj">4,</strong> <strong class="lk hj">5}</strong><br/>      2 elements_to_add <strong class="lk hj">=</strong> <strong class="lk hj">[10,</strong> <strong class="lk hj">20,</strong> <strong class="lk hj">30,</strong> <strong class="lk hj">40,</strong> <strong class="lk hj">50]</strong><br/><strong class="lk hj">----&gt; 3 </strong>num_set<strong class="lk hj">.</strong>add<strong class="lk hj">(</strong>elements_to_add<strong class="lk hj">)</strong></span><span id="7914" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">TypeError</strong>: unhashable type: 'list'</span></pre><p id="1acc" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在让我们试着一次添加一个元素。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="950a" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4, 5}<br/>elements_to_add = [10, 20, 30, 40, 50]<br/>for i in elements_to_add:<br/>    num_set.add(i)<br/>print(num_set)</span><span id="f470" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {1, 2, 3, 4, 5, 40, 10, 50, 20, 30}</span></pre><p id="ae01" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">不能向集合中添加列表，但可以向集合中添加包含多个元素的元组。这是因为元组是<em class="kt">不可变的</em>，集合中的元素也是如此。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="c6ce" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4, 5}<br/>elements_to_add = (10, 20, 30, 40, 50)<br/>num_set.add(elements_to_add)<br/>print(num_set)</span><span id="10f5" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {1, 2, 3, 4, 5, (10, 20, 30, 40, 50)}</span></pre><p id="e612" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">请注意，元组(10，20，30，40，50)是按原样添加的，而不是作为单个元素添加的。现在让我们尝试将元组的元素逐个添加到集合中。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d047" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4, 5}<br/>elements_to_add = (10, 20, 30, 40, 50)<br/>for i in elements_to_add:<br/>    num_set.add(i)<br/>num_set.add(elements_to_add)<br/>print(num_set)</span><span id="5e8c" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {1, 2, 3, 4, 5, 40, (10, 20, 30, 40, 50), 10, 50, 20, 30}</span></pre><p id="f13c" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">您可以看到元组中的单个元素被重新添加到集合中，尽管它们存在于元组中。<strong class="jw hj">这是因为集合将元组视为一个单独的元素</strong>。这意味着如果你添加相同的元组两次，它将只被添加一次。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="fe54" class="lo ig hi lk b fi lp lq l lr ls">num_set = {1, 2, 3, 4, 5}<br/>elements_to_add = (10, 20, 30, 40, 50)<br/>num_set.add(elements_to_add)<br/>num_set.add(elements_to_add)<br/>print(num_set)</span><span id="785a" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {1, 2, 3, 4, 5, (10, 20, 30, 40, 50)}</span></pre><p id="8237" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">从集合中删除元素</strong>:</p><p id="dc17" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">可以使用<em class="kt">移除</em>方法移除列表中的元素。请记住，因为集合没有索引，所以您不能基于索引移除元素，而是基于<strong class="jw hj">元素名称</strong>。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="8b45" class="lo ig hi lk b fi lp lq l lr ls">my_set = { "Pascal", "C", "C++", "Java", "Python"}<br/>my_set.remove("Pascal")<br/>print(my_set)</span><span id="eb5f" class="lo ig hi lk b fi lt lq l lr ls">#  Output:<br/># {'Python', 'C++', 'Java', 'C'}</span></pre><p id="4840" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">同样，您不能一次删除n个元素，但一次只能删除一个。</p><p id="183b" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">另一种移除集合元素的方法是使用<em class="kt"> pop </em>方法。<em class="kt"> pop </em>方法从集合的开始一个接一个地删除元素。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="fcd0" class="lo ig hi lk b fi lp lq l lr ls">my_set = { 'a', 'b', 'c', 'd'}<br/>my_set.pop()<br/># 'a'<br/># my_set: { 'b', 'c', 'd' }</span><span id="9bb2" class="lo ig hi lk b fi lt lq l lr ls">my_set.pop()<br/># 'b'<br/># # my_set: { 'c', 'd' }</span></pre><p id="eec5" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们可以通过循环集合来弹出元素吗？</p><p id="b846" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">嗯……不！</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="0c9c" class="lo ig hi lk b fi lp lq l lr ls">my_set = { 'a', 'b', 'c', 'd'}<br/>for element in my_set:<br/>    print(my_set.pop())</span><span id="8d6a" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">-----------------</strong><br/><strong class="lk hj">RuntimeError</strong>                              Traceback (most recent call last)<br/><strong class="lk hj">&lt;ipython-input-35-6f5684bf96b2&gt;</strong> in &lt;module&gt;<br/>      1 my_set <strong class="lk hj">=</strong> <strong class="lk hj">{</strong> <strong class="lk hj">'a',</strong> <strong class="lk hj">'b',</strong> <strong class="lk hj">'c',</strong> <strong class="lk hj">'d'}</strong><br/><strong class="lk hj">----&gt; 2 for</strong> element <strong class="lk hj">in</strong> my_set<strong class="lk hj">:</strong><br/>      3     print<strong class="lk hj">(</strong>my_set<strong class="lk hj">.</strong>pop<strong class="lk hj">())</strong></span><span id="ac31" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">RuntimeError</strong>: Set changed size during iteration</span></pre><p id="de20" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为什么？</p><blockquote class="lz ma mb"><p id="5854" class="ju jv kt jw b jx jy jz ka kb kc kd ke mc kg kh ki md kk kl km me ko kp kq kr hb bi translated">您可能还记得，我们不能使用索引来访问集合中的元素，因为没有与集合中的元素相关联的索引。因此，Python解释器依赖于集合的大小，使用指向集合对象的指针逐个删除元素。</p></blockquote><p id="1bc9" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为了更好地理解我的解释，请参考用Cython编写的Python 的<a class="ae jt" href="https://github.com/python/cpython/blob/48b069a003ba6c684a9ba78493fbbec5e89f10b8/Objects/setobject.c#L878" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><p id="713a" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">冻结设置</strong>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/54dd992697f68e71f51c7055b0a5d881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1KwD689ZcnrgJMJP5PCAw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用<a class="ae jt" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="e2cd" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如前所述，集合中的元素是不可变的，但是整个集合本身是可变的(可以添加或删除元素)。如果你想让整个集合不可变，那么你应该使用一种叫做“冻结集合”的东西。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="1380" class="lo ig hi lk b fi lp lq l lr ls"># A frozen set <br/>frozen_set = frozenset(["e", "f", "g"]) <br/>frozen_set.add("h")</span><span id="5888" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">-----------------</strong><br/><strong class="lk hj">AttributeError</strong>                            Traceback (most recent call last)<br/><strong class="lk hj">&lt;ipython-input-21-b29a691a0e06&gt;</strong> in &lt;module&gt;<br/>      1 frozen_set <strong class="lk hj">=</strong> frozenset<strong class="lk hj">(["e",</strong> <strong class="lk hj">"f",</strong> <strong class="lk hj">"g"])</strong><br/><strong class="lk hj">----&gt; 2 </strong>frozen_set<strong class="lk hj">.</strong>add<strong class="lk hj">("h")</strong></span><span id="9b45" class="lo ig hi lk b fi lt lq l lr ls"><strong class="lk hj">AttributeError</strong>: 'frozenset' object has no attribute 'add'</span></pre><p id="fa4d" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="kt">冻结的</em>集合是不可更改的集合。只能用于执行<strong class="jw hj">并集</strong>和<strong class="jw hj">交集</strong>等集合操作。</p><p id="e13d" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">集合的联合</strong>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/23424a970b4623efa957833c2347b750.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*QL7rBtl6KTCi1Hn3v9mDmQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">集合并的图解</figcaption></figure><p id="6eba" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">正如数学所示，集合A对集合B的并集是集合A和集合B的所有事件的独特组合。Python中集合的并集是使用<em class="kt"> union </em>方法完成的。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="2015" class="lo ig hi lk b fi lp lq l lr ls"># Basic Syntax:<br/>set1.union(set2)</span><span id="453a" class="lo ig hi lk b fi lt lq l lr ls"># Example:<br/>even = {0,2,4,6,8}<br/>odd = {1,3,5,7}<br/>numbers = even.union(odd)<br/>print(numbers)</span><span id="7844" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {0, 1, 2, 3, 4, 5, 6, 7, 8}</span></pre><p id="be5a" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">集合的交集</strong>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/9dd92ee9efd5999769b16f27307351c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pd52V-5dRlWQBeiOEs67Jw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用<a class="ae jt" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建</figcaption></figure><p id="567f" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">集合的交给出了两个集合共有的元素的集合。Python中集合的交集是使用<em class="kt">交集</em>方法完成的。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="f1e0" class="lo ig hi lk b fi lp lq l lr ls"># Basic Syntax:<br/>set1.intersection(set2)</span><span id="156f" class="lo ig hi lk b fi lt lq l lr ls"># Example:<br/>even = {0,2,4,6,8}<br/>prime = {2,3,5,7,11,13,17,19,23}<br/>intersecting_numbers = even.intersection(prime)<br/>intersecting_numbers<br/>print(intersecting_numbers)<br/># Output:<br/># {2}</span></pre><p id="afe4" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在上面的例子中，只有2是两个<em class="kt">偶数</em>和<em class="kt">素数</em>的公共元素，这就是为什么这两个集合的交互只给出2。</p><p id="ed81" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">一套的区别</strong>:</p><p id="c42f" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">两个集合的差异给了我们第一个集合中的元素，而这些元素在第二个集合中是没有的。Python中一个集合的差可以通过使用<em class="kt">差</em>方法或者使用“-”运算符来实现。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="65d4" class="lo ig hi lk b fi lp lq l lr ls">set1 = { 1, 2, 3, 4, 5, 6}<br/>set2 = { 2, 4, 6, 8, 10}<br/>diff1 = set1.difference(set2)<br/>print(diff1)<br/>diff2 = set1 - set2<br/>print(diff2)</span><span id="6846" class="lo ig hi lk b fi lt lq l lr ls"># Output:<br/># {1, 3, 5}<br/># {1, 3, 5}</span></pre><p id="6358" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">集合的子集和超集</strong>:</p><p id="02cc" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果集合<em class="kt"> A </em>的所有元素都属于集合<em class="kt"> B，则集合<em class="kt"> A </em>是集合<em class="kt"> B </em>的子集。在这种情况下，集合<em class="kt"> B </em>是集合<em class="kt"> A </em>的超集。在Python中，我们可以使用<em class="kt"> issuperset </em>和<em class="kt"> issubset </em>布尔方法来确定一个给定的集合是另一个集合的子集还是超集。</em></p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d7b0" class="lo ig hi lk b fi lp lq l lr ls">setA = { "C", "C++", "Python" }<br/>setB = {"Python"}<br/>print(setB.issubset(setA)) # True</span><span id="c87a" class="lo ig hi lk b fi lt lq l lr ls">print(setA.issuperset(setB)) # True</span></pre><p id="0159" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">不相交的集合</strong>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/b74a49dbfba8cb82a7e1e5fa870710e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*8g_Ll-S7aC8s-_1zdXvAZw.png"/></div></figure><p id="ce36" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果集合<em class="kt"> A </em>和<em class="kt"> B </em>中没有一个元素相互匹配，则称两个集合<em class="kt"> A </em>和<em class="kt"> B </em>为<em class="kt">不相交</em>。在Python中，我们可以使用<em class="kt"> isdisjoint </em>布尔方法来确定两个集合是否分离。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="977f" class="lo ig hi lk b fi lp lq l lr ls">setA = { "C", "C++", "Python" }<br/>setB = {"Java", "Ruby", "C#"}<br/>setA.isdisjoint(setB) # True</span></pre><p id="8cdf" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这些都在第2部分中。</p><p id="bded" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">请继续关注Python中数据结构的第3部分！</p></div></div>    
</body>
</html>