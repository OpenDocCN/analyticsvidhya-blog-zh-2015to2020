<html>
<head>
<title>The 3 pillars of the OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OOP的三大支柱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-3-pillars-of-the-oop-4308edeb6230?source=collection_archive---------30-----------------------#2020-04-10">https://medium.com/analytics-vidhya/the-3-pillars-of-the-oop-4308edeb6230?source=collection_archive---------30-----------------------#2020-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/60efd2b4706e5e2a48eb709ff4a37b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*TJJj9RA7We_DBNu16KBNRg.jpeg"/></div></figure><p id="9d7e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">几天前，我参加了一个Python开发人员的面试，除了学习该语言的语法之外，我认为再看一眼“面向对象编程的三大支柱”是一个不错的主意。换句话说，这仅仅意味着<strong class="io hj">是什么使得一个OOP语言成为一个OOP语言。</strong></p><p id="07b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在网上资源中，你可能不会只找到3个，而是4个，甚至5个，它们可以用不同的方式调用，但定义是一样的。</p><p id="134d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">没关系，但在我看来，我们可以恢复我将在这篇文章中解释的所有内容。</p><p id="4855" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我喜欢从根本上理解事物，所以让我们快速看一下OOP是什么。</p><p id="be0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">来自<a class="ae jk" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>定义:</p><p id="9b81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">面向对象编程</strong> ( <strong class="io hj"> OOP </strong>)是一种基于<a class="ae jk" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank">对象</a>概念的<a class="ae jk" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener ugc nofollow" target="_blank">编程范式</a>，它可以包含<a class="ae jk" href="https://en.wikipedia.org/wiki/Data" rel="noopener ugc nofollow" target="_blank">数据</a>，以<a class="ae jk" href="https://en.wikipedia.org/wiki/Field_(computer_science)" rel="noopener ugc nofollow" target="_blank">字段</a>(通常称为<em class="jl">属性</em>或<em class="jl">属性</em>)的形式，以及代码，以过程的形式(通常称为<a class="ae jk" href="https://en.wikipedia.org/wiki/Method_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="jl">方法</em> </a>)</p><p id="393a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">面向对象的语言有<a class="ae jk" href="https://en.wikipedia.org/wiki/Java_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Java </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/C%2B%2B" rel="noopener ugc nofollow" target="_blank"> C++ </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)" rel="noopener ugc nofollow" target="_blank"> C# </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/PHP" rel="noopener ugc nofollow" target="_blank"> PHP </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/Ruby_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Ruby </a>、<a class="ae jk" href="https://en.wikipedia.org/wiki/Perl" rel="noopener ugc nofollow" target="_blank"> Perl </a>等等。</p><p id="611b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，它们是一些特定的特性，一门编程语言必须能够提供这些特性，才能被称为面向对象的语言。正如我之前所说，我将在3:</p><ul class=""><li id="e88e" class="jm jn hi io b ip iq it iu ix jo jb jp jf jq jj jr js jt ju bi translated"><strong class="io hj">封装</strong></li><li id="5242" class="jm jn hi io b ip jv it jw ix jx jb jy jf jz jj jr js jt ju bi translated"><strong class="io hj">专精</strong></li><li id="6a49" class="jm jn hi io b ip jv it jw ix jx jb jy jf jz jj jr js jt ju bi translated"><strong class="io hj">多态性</strong></li></ul><p id="dc86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从现在开始，我将附上用<strong class="io hj"> Python </strong>语言代码编写的例子，因为这是迄今为止我最喜欢的一个。<strong class="io hj">不要担心</strong>，当然这些概念仍然适用于其他所有面向对象语言，并且也是基于<a class="ae jk" href="https://hackr.io/blog/best-programming-languages-to-learn-2020-jobs-future" rel="noopener ugc nofollow" target="_blank"> hacker.io </a>最流行的语言统计数据，Python做得一点也不差！。</p><h2 id="4d5a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">包装</h2><p id="865d" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">你定义的每一个类都应该是完全封装的，这意味着每一个定义的类都应该包含整个类的数据和操作这些数据的函数。</p><p id="80db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从<a class="ae jk" href="https://www.oreilly.com/library/view/programming-visual-basic/0596004389/ch04s04.html" rel="noopener ugc nofollow" target="_blank">或</a>上的例子可以看出:</p><p id="3292" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">“如果你创建一个雇员对象，从你程序的角度来看，这个雇员对象应该完整地定义每个雇员的所有信息。</p><p id="670c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通常，您不希望一个类定义雇员的工作信息，而另一个不相关的类定义雇员的联系信息。相反，您希望将所有这些信息封装在Employee类中，也许是通过将联系信息聚合为Employee类的成员。"</p><p id="b48e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们的例子中，我们将引入一个“Person”类:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="bf0d" class="ka kb hi lf b fi lj lk l ll lm">class Person():<br/>    ''' Person class '''</span><span id="8b93" class="ka kb hi lf b fi ln lk l ll lm">def __init__(self, name='Noname', age=0, gender='None', sexuality='None', religion='None'):<br/>        '''Initialize person'''<br/>        self.__name = name<br/>        self.__age = age<br/>        self.__gender = gender<br/>        self.__sexuality = sexuality<br/>        self.__religion = religion</span><span id="284d" class="ka kb hi lf b fi ln lk l ll lm">def get_name(self):<br/>        '''Return person name'''<br/>        return self.__name</span><span id="f344" class="ka kb hi lf b fi ln lk l ll lm">def set_name(self, name):<br/>        '''Set person age'''<br/>        self.__name = name<br/>        return self.__name</span><span id="09c1" class="ka kb hi lf b fi ln lk l ll lm">def get_age(self):<br/>        '''Return person age'''<br/>        return self.__age</span><span id="d543" class="ka kb hi lf b fi ln lk l ll lm">def set_age(self, n):<br/>        '''Set person age'''<br/>        self.__age = n<br/>        return self.__age</span><span id="840e" class="ka kb hi lf b fi ln lk l ll lm">def get_gender(self):<br/>        '''Return person gender'''<br/>        return self.__gender</span><span id="8ece" class="ka kb hi lf b fi ln lk l ll lm">def set_gen(self, gen):<br/>        '''Set person age'''<br/>        self.__gender = gen<br/>        return self.__gender</span><span id="3f87" class="ka kb hi lf b fi ln lk l ll lm">def get_sexuality(self):<br/>        '''Return person sexuality'''<br/>        return self.__sexuality</span><span id="3456" class="ka kb hi lf b fi ln lk l ll lm">def set_sex(self, sex):<br/>        '''Set person sexuality'''<br/>        self.__sexuality = sex<br/>        return self.__sexuality</span><span id="a3b5" class="ka kb hi lf b fi ln lk l ll lm">def get_religion(self):<br/>        '''Return person religion'''<br/>        return self.__religion</span><span id="c0b0" class="ka kb hi lf b fi ln lk l ll lm">def set_rel(self, rel):<br/>        '''Set person rel'''<br/>        self.__religion = rel<br/>        return self.__religion</span></pre><p id="8eda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设这是一个人需要的所有信息和数据，我们将假设我们只需要提取和更新这些信息。我们可以注意到，所有的数据和处理这些数据的函数(<a class="ae jk" href="https://www.tutorialspoint.com/difference-between-method-and-function-in-python" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">方法</strong> </a>)都在类本身的定义中。然后我们可以说这个类完全被<strong class="io hj">封装了</strong>。</p><h2 id="28ce" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated"><strong class="ak">专业化</strong></h2><p id="fbff" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">专门化允许你在你的类之间建立层次关系。这意味着可以定义一个从另一个现有类派生的类。通过这样做,“子”类将继承“父”类的特征。</p><blockquote class="lo"><p id="0907" class="lp lq hi bd lr ls lt lu lv lw lx jj dx translated">这对于避免不必要的重复代码非常有用。</p></blockquote><p id="bf02" class="pw-post-body-paragraph im in hi io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated">我们将创建一个“教师”类来更好地理解这一点。</p><p id="b523" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">想一想:</strong>老师本身就是人对吗？</p><p id="dc89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我想强调的是，没有必要为了返回或设置教师的信息(如姓名、年龄或person类中已经存在的任何其他属性)而复制代码。</p><blockquote class="lo"><p id="7d49" class="lp lq hi bd lr ls lt lu lv lw lx jj dx translated">这就是<strong class="ak">继承</strong>有用的地方！</p></blockquote><pre class="md me mf mg mh le lf lg lh aw li bi"><span id="13d6" class="ka kb hi lf b fi lj lk l ll lm">class Teacher(Person):<br/>    '''Teacher class inherits from Person class'''</span><span id="9143" class="ka kb hi lf b fi ln lk l ll lm">def __init__(self, knowledge, experience):<br/>        '''Initializing teacher'''<br/>        super().__init__()<br/>        self.__knowledge = knowledge<br/>        self.__experience = experience</span><span id="6ea4" class="ka kb hi lf b fi ln lk l ll lm">def get_knowledge(self):<br/>        '''Return teacher knowledge'''<br/>        return self.__knowledge</span><span id="b671" class="ka kb hi lf b fi ln lk l ll lm">def set_knowledge(self, know):<br/>        '''Set teacher knowledge'''<br/>        self.__knowledge = know<br/>        return self.__knowledge</span><span id="1b09" class="ka kb hi lf b fi ln lk l ll lm">def get_experience(self):<br/>        '''Return teacher experience'''<br/>        return self.__experience</span><span id="c1d4" class="ka kb hi lf b fi ln lk l ll lm">def set_experience(self, exp):<br/>        '''Set teacher experience'''<br/>        self.__experience = exp<br/>        return self.__experience</span></pre><p id="f3b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你看到了吗？…使用这一原则，我们不必为教师类重新定义相同的属性和方法，而只需为教师类专门定义这些属性和方法。</p><p id="ff60" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了调用父类方法，我们使用了<strong class="io hj"> super() </strong>内置函数。如果你想了解更多，点击<a class="ae jk" href="https://www.programiz.com/python-programming/methods/built-in/super" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="783d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">多态性</h2><p id="a5b9" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">但是..请稍等。如果老师不想分享一些私人信息，如他/她的宗教信仰或性取向，该怎么办？。</p><p id="9ed2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们应该完全尊重这个决定，对吗？</p><p id="8a54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正确的做法应该是先问老师他/她是否想公开这些信息，你不这样认为吗？</p><p id="cd2f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">也就是说，我们现在知道<strong class="io hj">get _ religion()方法必须不同于Person类one。</strong></p><p id="2ce4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是多态性发挥作用的地方:</p><p id="900f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">来自<a class="ae jk" href="https://overiq.com/python-101/inheritance-and-polymorphism-in-python/" rel="noopener ugc nofollow" target="_blank">overig.com</a>:</p><p id="7c2f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从字面上来看，多态性意味着采取各种形式的能力。在Python中，多态性允许我们在子类中定义与其父类同名的方法。</p><p id="7702" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">众所周知，子类继承了父类的所有方法。但是，您会遇到从父类继承的方法不太适合子类的情况。在这种情况下，您必须在子类中重新实现方法。这个过程称为方法重写。"</p><p id="dca5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">覆盖教师类的get_religion()方法:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="02f4" class="ka kb hi lf b fi lj lk l ll lm">def get_religion(self):<br/>        '''<br/>        Return teacher religion<br/>        if he/she wants to<br/>        '''</span><span id="87c5" class="ka kb hi lf b fi ln lk l ll lm">print('Do you want to share this?')<br/>answer = input()</span><span id="ac50" class="ka kb hi lf b fi ln lk l ll lm">if answer == 'yes':<br/>            print('Thank you for your consent')<br/>            return (super().get_religion())</span><span id="2043" class="ka kb hi lf b fi ln lk l ll lm">if answer == 'no':<br/>            print('Sorry person doesn't want to share religion')<br/>            return</span><span id="7175" class="ka kb hi lf b fi ln lk l ll lm">else:<br/>            print('Answer needs to be yes or no')<br/>            return</span></pre><blockquote class="lo"><p id="8d7d" class="lp lq hi bd lr ls mi mj mk ml mm jj dx translated">有道理吧？</p></blockquote><p id="b797" class="pw-post-body-paragraph im in hi io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated">让我们做一个小测试:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="1f16" class="ka kb hi lf b fi lj lk l ll lm">man = Person('sech', 34, 'Male', 'Hetero', 'Christian')<br/>print('Person religion is: ', man.get_religion())</span><span id="1b8e" class="ka kb hi lf b fi ln lk l ll lm">Teacher_1 = Teacher('Math', 4)<br/>Teacher_1.set_rel('Catolic')<br/>print('Teacher Religion is: ', Teacher_1.get_religion())</span></pre><p id="caee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="150d" class="ka kb hi lf b fi lj lk l ll lm">Person religion is:  Christian<br/>Do you want to share this?<br/>yes<br/>Thank you for your consent<br/>Teacher Religion is:  Catolic</span></pre><p id="afc8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想要代码来做你自己的测试，欢迎点击这里<a class="ae jk" href="https://github.com/sechchr22/Educative/blob/master/3_OOP_principles.py" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"/>。</a></p><p id="1a98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望这对你有所帮助。</p><blockquote class="lo"><p id="b28f" class="lp lq hi bd lr ls lt lu lv lw lx jj dx translated">归根结底，知识是属于每个人的</p><p id="ba6d" class="lp lq hi bd lr ls lt lu lv lw lx jj dx translated">下次见！</p></blockquote></div></div>    
</body>
</html>