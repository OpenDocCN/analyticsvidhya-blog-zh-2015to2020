# 在 Python 中一切都是对象:可变和不可变的数据类型

> 原文：<https://medium.com/analytics-vidhya/everything-is-an-object-in-python-mutable-and-immutable-data-types-a2cdc3617096?source=collection_archive---------16----------------------->

![](img/80651e5ff69fc09d064108cc3de9e1f8.png)

python 编程语言徽标

# 介绍

Python 是一种解释型高级编程语言，一切都是对象，从您定义的整数、您显示的简单字符串到您创建的个性化类。换句话说，你定义的所有东西一个类和变量的实例只是我们用来调用这些实例的“名字”或“标签”。要了解这种“一切都是对象”方法背后的原因，这里引用 Guido Van Rossum(python 的创始人)的话:

> 我对 Python 的一个目标是让所有对象都是“第一类”我的意思是，我想要所有可以用这种语言命名的对象(例如，整数、字符串、函数、类、模块、方法等等)。)拥有平等的地位。也就是说，它们可以赋给变量，放在列表中，存储在字典中，作为参数传递，等等。'

每个对象都有自己的属性、方法和特定的行为(取决于对象是由开发人员创建的类的实例还是某种数据类型的实例……)。通常，对象(或实例)具有由它定义的类的结构，并且可以根据该类中定义的方法来行为。这意味着我们可以说，我们创建的每个实例都是所寻找的类的唯一表示，并且它的定义方式应该符合我们的需求。在本文中，我们将更深入地探讨这个主题。

# id 和类型函数

Python 为我们提供了两个方便的函数，帮助我们获得关于代码中任何实例的有用信息。

## id()

函数的作用是:返回指定对象的唯一 id。这个 id 是一个整数，它保证在对象的生命周期中是唯一的和恒定的。每个对象都有一个唯一的 id，后者是在创建时分配给对象的。对象 id 是它的内存地址。

```
>>> # simple example usage of the id function
>>> n = 5
>>> id(n)
10105216
```

## 类型()

type()函数返回作为参数传递的变量(对象)的类类型。它通常用于在操作数据之前测试/验证给定的数据。

```
>>> # simple example usage of the type() function
>>> n = 5
>>> type(n)
<class 'int'>
>>> s = "hello world"
>>> type(n)
<class 'str'>
```

# 相等比较运算符(==)

python 中的==运算符用于检查 2 个变量(即实例、对象..)有没有同值。

```
>>> string1 = "what goes around, comes around."
>>> string2 = "what goes around, comes around."
>>> string1 == string2
True
>>> n1 = 100
>>> n2 = 524
>>> n1 == n2
False
```

# 特殊运算符是和不是

**是**运算符，**不是**运算符检查对象标识的相等性，如果我们比较的对象具有相同的 id，则它们相等，否则它们不相等。检查两个变量是否相同是一个非常重要的主题，不可能在一篇文章段落中完全涵盖。但是，我们将看到一些例子，帮助我们更好地理解这些特殊操作符以及 python 的行为。

```
>>> # Example 1
>>> s1 = "name"
>>> s2 = "name"
>>> s1 is s2
True
>>> # Example 2
>>> s1 = "this string: has characters other than alphanumeric ones..!"
>>> s2 = "this string: has characters other than alphanumeric ones..!"
>>> # s1 and s2 have the same values.
>>> s1 == s2
True
>>> s1 is s2
False
>>> s1 is not s2
True
```

与第一个例子不同，在第二个例子中 **s1** 和 **s2** 在内存中不引用相同的东西，尽管它们具有相同的数据值。这是因为它们包含非字母数字字符(字母“a”到“z”以及数字 0 到 9)。

一般来说，如果两个字符串只有字母数字字符，或者它们位于同一个内存块(文件、函数、类或单个解释命令)，那么它们将共享内存。

对于非字母数字字符串，只有在相同的封闭语法块中定义时，它们才共享内存(换句话说，它们在同一行中定义)，下面是一个很好的例子:

```
>>> # Example where x and y have the same value and it's just a string of non-alphanumeric characters.
>>> x='`!@#$%^&*() \][=-. >:"?<a';  y='`!@#$%^&*() \][=-. >:"?<a';
>>> x is y
True
```

现在，如果我们重做同样的工作，但是我们只是在不同的行中定义 x 和 y。

```
>>> x='`!@#$%^&*() \][=-. >:"?<a';
>>> y='`!@#$%^&*() \][=-. >:"?<a';
>>> x is y
False
```

更深入的解释，请查看这个[栈溢出链接](https://stackoverflow.com/a/16757434/7055501)。

整数也有类似的情况。

```
>>> # Example 1
>>> a = 100
>>> b = 100
>>> a is b
True
>>> # Example 2
>>> a = 550
>>> b = 550
>>> a is b
False
>>> # Example 3
>>> a = -800
>>> b = -800
>>> a is b
False
```

在 python 中，具有从-5 到 256 的相同值的整数变量具有相同的 id。但是，对于所有其他值，它们有不同的 id。

Python 使用 Flyweight 模式，这是编程语言中使用的一种设计模式，允许具有相同值的不同实例引用相同的内存地址。但是，这只适用于我们在上面的例子中看到的某些情况。

## 混乱的 python 语法(元组创建)

```
>>> # Different ways for tuple definition
>>> t = 1, 2, 3, #tuple having 3 items
>>> t = (1, 2, 3) #tuple having 3 items
>>> t = 1, #tuple having 1 item
>>> type(t)
<class 'tuple'>
>>> t = (1)
>>> type(t)
<class 'int'>
```

如果您想要创建一个只包含一个条目的元组，无论您是否将数据放在括号内，您都需要在给定值后添加一个逗号'**，**'。否则，您最终会得到一个不需要的数据类型。

# 可变和不可变对象

正如我们已经看到的，每个对象都通过它的值、id 和类型来区分。每个对象都是有特定类型的数据，可以是字符串、整数、浮点数……根据对象的类型，我们可以知道对象是可变的还是不可变的。因为在 python 中，有些类型是可变的，有些不是。

**PS** :每个对象都有一个惟一的 id，一旦对象被创建，这个 id 就不会改变。

# 不可变对象

不可变对象只是不能改变其内容(值)的对象。因此，为了改变不可变对象的值，我们需要根据我们的需要更新它的值，然后使引用我们的不可变对象的变量(如前所述，将其视为“名称”或“标签”)引用更新的值。

不可变的日期类型如下:

*   （同 Internationalorganizations）国际组织
*   漂浮物
*   小数
*   复杂的
*   弯曲件
*   线
*   元组
*   范围
*   frozenset
*   字节

为了理解不可变对象的行为，我们将在我们的例子中只涉及一些最常用的对象。

对象是类的实例，如果你已经学过 OOP，你会知道类可以有方法来修改，删除…它们对应的实例。不可变类型不能被改变，因此用来创建它们的类没有更新它们的值的方法。

```
>>> # Example trying to update the value of and int object
>>> a = 500
>>> id(a)
139710181638032
>>> a = 600
>>> id(a)
139710173508176
```

正如我们在这里看到的，a 的值成功地改变了，但是我们真正做了什么呢？a 是一个整数，这是一个不可变的数据类型，不能更新，所以当我们想要更新 a 的值时，我们真正做的是创建一个新的 integer 对象，并使用' **a** '作为对它的引用。请记住，每个对象都有一个唯一的 id，不能改变。我知道现在这可能令人困惑，但是一旦我们到达不可变的数据类型，所有这些将看起来不那么奇怪。

```
>>> # Example with a string
>>> str = "hello"
>>> id(str)
139710180408600
>>> str += " world" #same as str = str + " world"
>>> id(str)
139710180430768
>>> str
'hello world'
```

对于字符串也是一样，当我们想要更新 **str** (第 5 行)时，我们只是让变量 **str** 引用一个字符串实例(该字符串实例是变量 str 引用的字符串文字加上“世界”的组合)(如果你没有得到，你必须知道 python 解释器，从右到左解释我们的代码的每一行)，因为这是 python 对不可变类型的行为方式。

在 python 中，当你引用一个给定名字的不可变类型时。然后，您使用相同的名称，认为您将只更新它所引用的值，那么不！您只是让相同的名称引用保存更新值的新实例。这就是为什么 id 在每次更新后都是不同的(这只是一个信号，告诉你你正在创建一个新的对象，而不是更新一个旧的)。

```
>>> # Example with tuples
>>> list = [1, 2, 3]
>>> t = (0, list, 4, 5)
>>> t  #to print the value of t
(0, [1, 2, 3], 4, 5)
>>> t[0] = 7 #Trying to change the first item in the tuple t
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

当我们想要更新 tuple t 中的元素时，我们不能，因为它会修改给定项的 id，并且 tuple 会知道这不是相同的，因为它会有一个不同于以前的 id。这可以在接下来的测试中得到更好的理解。我们知道元组中的第二个元素只是一个对列表的引用，(列表是一个可变的数据类型)。

```
>>> id(list)
140227844896776
>>> id(t[1])
140227844896776
>>> t[1] is list
True
```

因此，即使 tuple 是一种不可变的数据类型，它仍然可以包含可以修改的可变数据，这将间接修改 tuple 的内容。

```
>>> list.pop()
3
>>> list
[1, 2]
>>> t
(0, [1, 2], 4, 5)
>>> t[1] is list
True
```

# **可变对象**

可变对象是在创建后可以改变的对象。与不可变数据不同，当我们引用一个具有给定名称(变量名)的可变对象并试图通过该名称改变该对象的值时，对象值将会改变，对象仍将具有与以前相同的 id，因为我们没有创建新的实例，我们只是更新了同一个实例的值。

可变的数据类型如下:

*   设置
*   词典
*   目录
*   bytearray
*   用户定义的类(除非用户明确地使它们不可变)

```
>>> list = [1, 2, 3]
>>> id(list)
140227777936008
>>> list.append(4)
>>> id(list)
140227777936008
```

负责创建这些可变数据类型的 python 类通常有修改/操作其实例的方法，通常这些方法用于插入、删除、修改数据、检索数据…

# 为什么这很重要，Python 对待可变对象和不可变对象有什么不同？

如果您想创建一个使用尽可能少的内存的程序，那么弄清楚 python 对可变和不可变数据的不同行为是非常重要的。

对于不可变数据类型，不存在太多的内存消耗问题，因为每次我们修改对象大小(值)时，用于不可变对象的内存大小都会被重新分配和释放。

对于可变数据类型，每次我们认为我们在改变数据的值时，我们都在相反地创建新的对象，这意味着消耗更多的内存。因此，知道哪种数据类型能满足我们的需求是非常重要的，尤其是当我们在制作一个大型软件的时候。

# 参数如何传递给函数，这对可变和不可变对象意味着什么？

当谈到调用/使用函数时，有两种方式可以用来进行函数调用。要么是**通过值调用**，要么是**通过引用调用**。

## 按值调用

是一种向函数传递参数的方法，它将参数值复制到函数的形参中。如果在函数内部我们改变了参数的值，我们的参数不会受到影响。这里有一个更好的例子:

```
>>> def change_number(n):
...     n = n * 2
... 
>>> a = 40
>>> change_number(a)
>>> a
40
```

当我们将一个不可变的数据类型传递给一个可以对其参数进行一些更改的函数时，我们传递的数据不会改变，因为它是不可变的，所以它的值被复制到函数的形参中。

## 引用调用

是一种向函数传递参数的方法，其中我们传递的参数和函数的形参都指向相同的内存位置(相同的实例)。

```
>>> def change_list(l):
...     l.extend([12, 15, 18])
... 
>>> list = [0, 3, 6, 9]
>>> change_list(list)
>>> list
[0, 3, 6, 9, 12, 15, 18]
```

与通过值调用不同，传递的参数根据应用于其对应函数的形参的操作而改变值。因为我们传递和修改可变的对象，这个方法被称为对象调用。另一个例子可以更好地解释这种方式:

```
>>> class User:
...     def __init__(self, name, age):
...             self.name = name
...             self.age = age
... 
>>> me = User("edin", 26)
>>> def change_user(usr):
...     usr.name = "default_name"
... 
>>> me.name
'edin'
>>> me.age
26
>>> change_user(me)
>>> me.name
'default_name'
```