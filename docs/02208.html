<html>
<head>
<title>Airflow Tricks — Xcom and SubDAG</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流技巧— Xcom和SubDAG</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/airflow-tricks-xcom-and-subdag-361ff5cd46ff?source=collection_archive---------1-----------------------#2019-12-06">https://medium.com/analytics-vidhya/airflow-tricks-xcom-and-subdag-361ff5cd46ff?source=collection_archive---------1-----------------------#2019-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/435eae324e0113cd62efca84ef3ef01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVA3ZgCqowu74ONIzhBrww.jpeg"/></div></div></figure><div class=""/><p id="ba5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我做数据工程师2年了，一直用<a class="ae jo" href="https://airflow.apache.org" rel="noopener ugc nofollow" target="_blank">气流</a>维护大部分数据管线。这是一个非常直观的界面，组织数据管道非常简单。在这篇文章中，我想分享一些我在气流DAGs中使用的技巧。</p><h1 id="c947" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">技巧1 — Xcom</h1><p id="12fe" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Xcom是“cross-communication”的缩写，可以让你在任务之间传递消息。尽管任务被认为是原子的，并且不在它们之间共享资源，但是有时在它们之间交换消息变得有用。Xcom有两个方面；推杆和推杆。推送器发送一个消息，而拉取器接收该消息。</p><p id="1823" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例(<code class="du ks kt ku kv b">BashOperator</code>适用于推料器和拉料器):</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="4dd2" class="le jq ht kv b fi lf lg l lh li"># Get modified files in a folder since the last execution time<br/>pusher = BashOperator(<br/>        task_id='get_files',<br/>        bash_command='files=$(find \"$(cd .; pwd)\" -newermt {{ prev_ds }} ! -newermt {{ ds }}); echo $files',<br/>        xcom_push=True,  # This will send stdout to Xcom.<br/>        dag=dag)</span><span id="a471" class="le jq ht kv b fi lj lg l lh li"># Pull Xcom from a task, "get_files"<br/>puller = BashOperator(<br/>        task_id='process_files',<br/>        bash_command='python process.py --files \"{{ task_instance.xcom_pull(task_ids='get_files') }}\"',<br/>        dag=dag)</span></pre><h1 id="6000" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">诀窍2 —子标签</h1><p id="1876" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">子DAG是可插入的模块DAG，可以插入到父DAG中。当一个DAG内或其他DAG之间有重复的流程时，这很有用。</p><p id="0a3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:</p><ol class=""><li id="9cd4" class="lk ll ht is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">创建一个子标记(subdag.py)。SubDAG应该是一个返回DAG对象的函数。子标记的dag_id必须用<code class="du ks kt ku kv b">{parent dag id}.{SubDagOperator's task id}</code>格式化。</li></ol><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="253a" class="le jq ht kv b fi lf lg l lh li">def dag_preprocess(dag_id, schedule_interval, start_date, table_name):<br/>    dag = DAG(<br/>        dag_id=dag_id,  <br/>        schedule_interval=schedule_interval,<br/>        start_date=start_date)</span><span id="4d14" class="le jq ht kv b fi lj lg l lh li">    preprocess_files = BashOperator(<br/>        task_id='preprocess_files',<br/>        bash_command='python preprocess_files.py',<br/>        dag=dag)</span><span id="e398" class="le jq ht kv b fi lj lg l lh li">    preprocess_db_data = BashOperator(<br/>        task_id='preprocess_db',<br/>        bash_command='python preprocess_db.py --table {{ params. table}}',<br/>        params={<br/>            'table': table_name<br/>        },<br/>        dag=dag)</span><span id="af6a" class="le jq ht kv b fi lj lg l lh li">    return dag</span></pre><p id="8268" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建父DAG。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d552" class="le jq ht kv b fi lf lg l lh li">from airflow.operators.subdag_operator import SubDagOperator<br/>from subdug import dag_preprocess</span><span id="0715" class="le jq ht kv b fi lj lg l lh li">DAG_ID = 'parent_dag'<br/>default_args = {<br/>    'owner': 'emmasuzuki',<br/>    'depends_on_past': False,<br/>    'start_date': datetime(2019, 11, 1)<br/>}</span><span id="5989" class="le jq ht kv b fi lj lg l lh li">dag = DAG(DAG_ID, default_args=default_args, schedule_interval='@daily')</span><span id="06db" class="le jq ht kv b fi lj lg l lh li">SUBDAG_TASK_ID = 'preprocess'<br/>preprocess = SubDagOperator(<br/>    task_id=SUBDAG_TASK_ID,<br/>    subdag=dag_preprocess('%s.%s' % (DAG_ID, SUBDAG_TASK_ID),<br/>               dag.schedule_interval,<br/>               default_args['start_date'],<br/>               'mytable'),<br/>    dag=dag)</span><span id="07aa" class="le jq ht kv b fi lj lg l lh li">postprocess = BashOperator(<br/>    task_id='postprocess',<br/>    bash_command='bash postprocess.sh',<br/>    dag=dag)</span><span id="0c98" class="le jq ht kv b fi lj lg l lh li">preprocess &gt;&gt; postprocess</span></pre><p id="c804" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个<code class="du ks kt ku kv b">parent_dag</code>在Airflow UI中看起来会是这样的。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/a1e8b36a3afb2bdb79a73eb754133d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*uiKipGYSfi2TWhBc9azjOg.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">父DAG中的任务</figcaption></figure><p id="e0a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您点击<code class="du ks kt ku kv b">preprocess</code>任务，您将看到一个额外的菜单，弹出“放大子DAG”。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es ly"><img src="../Images/85ff00ec65b505ba846d987891c08ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*AFAo0CeHlOmufx3RZRUmEA.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">子操作符点击菜单</figcaption></figure><p id="9547" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击按钮会显示子标签内容。用户界面和菜单应该像你的常规DAG一样。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/7a570016018289dba813fca7b9dcab3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*rJZ7OHuWbciWggKKlPdUUA.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">子标签中的任务</figcaption></figure><p id="4d2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于SubDag的一个注意事项是，默认情况下，它使用SequentialExecutor这意味着所有流程都将按顺序执行，而不管是否存在任务依赖关系。</p><blockquote class="ma mb mc"><p id="d9da" class="iq ir md is b it iu iv iw ix iy iz ja me jc jd je mf jg jh ji mg jk jl jm jn hb bi translated">可以为子标记指定一个执行器。如果您想在进程内运行子标记并有效地将其并行度限制为1，那么通常使用SequentialExecutor。使用LocalExecutor可能会有问题，因为它可能会使您的工作人员超额订阅，在一个插槽中运行多个任务</p></blockquote><p id="d9e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考号:<a class="ae jo" href="https://airflow.apache.org/docs/stable/concepts.html?highlight=subdag" rel="noopener ugc nofollow" target="_blank">https://airflow.apache.org/docs/stable/concepts.html?高亮显示=子标签</a></p><p id="0c0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用它们的缺省值是安全的，但是，如果您的子标记非常简单并且这个缺陷不适用，那么您可以将一个执行程序指定为</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="b087" class="le jq ht kv b fi lf lg l lh li">from airflow.executors.local_executor import LocalExecutor</span><span id="2dc9" class="le jq ht kv b fi lj lg l lh li">...</span><span id="6ca8" class="le jq ht kv b fi lj lg l lh li">preprocess = SubDagOperator(<br/>    task_id=SUBDAG_TASK_ID,<br/>    subdag=dag_preprocess('%s.%s' % (DAG_ID, SUBDAG_TASK_ID),<br/>               dag.schedule_interval,<br/>               default_args['start_date'],<br/>               'mytable'),<br/>    executor=LocalExecutor(),<br/>    dag=dag)</span></pre><p id="f9d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SubDAG通过提取任何公共流程来简化DAG，并提高流程的可重用性。</p><p id="3a80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是气流技巧的简短列表，但是气流不需要技巧。大多数气流特性都很简单，非常适合我的数据需求。我对管道监控的低成本感到满意。</p></div></div>    
</body>
</html>