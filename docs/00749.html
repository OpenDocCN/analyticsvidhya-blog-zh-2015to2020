<html>
<head>
<title>Visitor Segmentation using K-means Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K-均值聚类的访问者细分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/visitor-segmentation-using-k-means-clustering-c874dcd41785?source=collection_archive---------4-----------------------#2019-09-03">https://medium.com/analytics-vidhya/visitor-segmentation-using-k-means-clustering-c874dcd41785?source=collection_archive---------4-----------------------#2019-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="484d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户细分或聚类在许多方面都很有用。它可以用于有针对性的营销。有时，在构建预测模型时，对数据进行聚类并为每个聚类构建单独的预测模型会更有效。在本文中，我将解释如何使用部署在Flask中的k-means模型来创建集群。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/1eb67a772e656989dd90dc6dff2883e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*KV7q9k9Kf44djmU-0svQqQ.jpeg"/></div></figure><h1 id="d43c" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">k-均值算法</h1><p id="e7b4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">AndreyBu拥有超过5年的机器学习经验，目前正在向人们传授他的技能，他说“K-means的目标很简单:将相似的数据点组合在一起，并发现潜在的模式。为了实现这个目标，K-means在数据集中寻找固定数量(<em class="kp"> k </em>)的聚类</p><p id="5e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看K-means机器学习算法如何使用Python编程语言工作的步骤。我们将使用Scikit-learn库和一些随机数据来说明K-means聚类的简单解释。</p><p id="66c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步:导入库</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="c81b" class="kv jm hi kr b fi kw kx l ky kz">import pandas as pdimport numpy as np<br/></span><span id="1c43" class="kv jm hi kr b fi la kx l ky kz">from sklearn import preprocessingimport matplotlib.pyplot as pltfrom sklearn.cluster import KMeans</span><span id="6a47" class="kv jm hi kr b fi la kx l ky kz">import Flask, request, jsonify, render_template</span></pre><p id="8072" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的代码中可以看出，我们将在项目中导入以下库:</p><ul class=""><li id="55cd" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">熊猫用于阅读和书写电子表格</li><li id="6335" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">用于执行有效计算的数字</li><li id="e06d" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">用于数据可视化的Matplotlib</li><li id="484f" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">Python编程语言的Sklearn</li><li id="b05f" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">展开用烧瓶</li></ul><p id="d994" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步:数据预处理</strong></p><p id="7bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一种将原始数据转换成可理解格式的数据挖掘技术。原始数据(真实世界的数据)总是不完整的，并且这些数据不能通过模型发送。这将导致某些错误。这就是为什么我们需要在通过模型发送之前预处理数据。</p><p id="0181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我遵循的步骤:</p><ol class=""><li id="fb64" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lp lh li lj bi translated"><strong class="ih hj">删除重复行</strong></li><li id="20fa" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lp lh li lj bi translated"><strong class="ih hj">用特征的平均值、中值或众数替换缺失值</strong></li><li id="a7a5" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lp lh li lj bi translated"><strong class="ih hj">使用标签编码器将分类变量转换成数字数据</strong></li><li id="5924" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lp lh li lj bi translated"><strong class="ih hj">使用特征缩放限制变量的范围</strong></li></ol><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="1b38" class="kv jm hi kr b fi kw kx l ky kz">def Preproceesing():</span><span id="237e" class="kv jm hi kr b fi la kx l ky kz">    d.drop_duplicates(keep='first')<br/>    d.x1.fillna(d.x1.mean(), inplace=True) # x1 example <br/>    le = preprocessing.LabelEncoder() #label encoder<br/>    le.fit(d.x1)<br/>    d.x1=le.transform(d.x1)<br/>    in_max_scaler = preprocessing.MinMaxScaler() #feature scaling<br/>    scaled_array = min_max_scaler.fit_transform(d)  <br/>    d = pd.DataFrame(scaled_array,columns=d.columns)<br/>    return d</span></pre><p id="3f9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3:用于数据可视化的PCA</strong></p><p id="2f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于许多机器学习应用程序来说，能够可视化您的数据很有帮助。您可以使用PCA将4维数据缩减为2维或3维，以便您可以绘制数据，并有望更好地理解数据。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="ca17" class="kv jm hi kr b fi kw kx l ky kz">def PCA(d):<br/>    pca = PCA()<br/>    pca.fit(d)<br/>    pca_samples = pca.transform(d)<br/>    return pca_samples</span></pre><p id="8fc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第四步:建模</strong></p><p id="9ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是训练k-means和寻找质心的代码:</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="dcbe" class="kv jm hi kr b fi kw kx l ky kz">clusterer = KMeans(n_clusters=4,random_state=42,n_init=10).fit(d)<br/>       centers = clusterer.cluster_centers_<br/>       labels= clusterer.predict(d)</span></pre><blockquote class="lq lr ls"><p id="9a75" class="if ig kp ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">为了确定k-均值的最佳聚类数，肘方法是确定k的最佳值的最流行的方法之一</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/69b4c373deaf7e53e0e6b347fd523a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*DDCwRT7Eg3n2j8il.png"/></div></figure><p id="baf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须选择“弯头”处的k值，即在该点之后，失真/惯性开始以线性方式减小。</p><h2 id="16f2" class="kv jm hi bd jn lx ly lz jr ma mb mc jv iq md me jz iu mf mg kd iy mh mi kh mj bi translated">我们怎么能说聚类质量度量是好的呢？</h2><p id="76d1" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">轮廓值是对象与其自己的簇(内聚)相比与其他簇(分离)相似程度的度量。轮廓的范围从1到+1，其中高值表示对象与其自己的簇匹配良好，而与相邻簇匹配较差。如果大多数对象都有较高的值，那么集群配置是合适的。如果许多点具有低值或负值，则聚类配置可能具有太多或太少的聚类。</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="9886" class="kv jm hi kr b fi kw kx l ky kz">from sklearn.metrics import silhouette_score</span><span id="241a" class="kv jm hi kr b fi la kx l ky kz">silhouette_score(d,labels)</span></pre><h2 id="9d34" class="kv jm hi bd jn lx ly lz jr ma mb mc jv iq md me jz iu mf mg kd iy mh mi kh mj bi translated">步骤4:部署</h2><p id="d331" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">对于我们的应用程序，我们将定义一个route @<strong class="ih hj">app . route('/clustering ')，【T1]来调用我们的模型，如下面的代码所示:</strong></p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="ec2b" class="kv jm hi kr b fi kw kx l ky kz">app = Flask(__name__)<br/>app.config["DEBUG"] = True</span><span id="d7ec" class="kv jm hi kr b fi la kx l ky kz">@app.route('/clustering')<br/>def predict():<br/>    data= pd.read_csv('dataset.csv')<br/>    data=prepross(data)<br/>    data=pca(data)<br/>    clusterer = KMeans(n_clusters=4,random_state=42,n_init=10).fit(d)<br/>    centers = clusterer.cluster_centers_<br/>    labels= clusterer.predict(d)<br/>    return jsonify(labels)<br/></span><span id="a927" class="kv jm hi kr b fi la kx l ky kz">if __name__ == '__main__':<br/>      app.run(debug='true' )</span></pre><p id="61fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试它，保存你的文件为<em class="kp"> app.py </em>并执行它。默认情况下，API将在端口5000上运行。然后使用Postman或在终端上键入以下命令:</p><pre class="je jf jg jh fd kq kr ks kt aw ku bi"><span id="3912" class="kv jm hi kr b fi kw kx l ky kz">C:\Users\USER\Desktop\media\heroku&gt; python app.py</span></pre><p id="896c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很容易理解，尤其是如果你使用<a class="ae ko" href="https://www.liveedu.tv/guides/artificial-intelligence/" rel="noopener ugc nofollow" target="_blank"> K-means聚类教程</a>来加速你的学习。，它可以快速提供培训结果。因此，您可以通过使用k-means聚类来生成客户聚类，从而获得有意义的见解和建议。</p><p id="aca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想玩我的<strong class="ih hj">源码</strong>，可以在这里找到<a class="ae ko" href="https://github.com/ChaimaaMafroudd/Visitor-Segmentation-using-K-means-Clustering" rel="noopener ugc nofollow" target="_blank"> <em class="kp">。</em></a></p></div></div>    
</body>
</html>