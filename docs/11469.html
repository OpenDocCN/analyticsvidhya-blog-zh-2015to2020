<html>
<head>
<title>Asynchronous Javascript (1) callbacks and promise</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步 Javascript (1)回调和承诺</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asynchronous-javascript-1-callbacks-and-promise-5f9ffc61b2e5?source=collection_archive---------10-----------------------#2020-12-04">https://medium.com/analytics-vidhya/asynchronous-javascript-1-callbacks-and-promise-5f9ffc61b2e5?source=collection_archive---------10-----------------------#2020-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/145994b3ea31518c8a1238056ebdc663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Cx46wiFfYA17JANd6Xf9Jg.jpeg"/></div></figure><h1 id="0b5b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak"> 1。回调</strong></h1><p id="7e6b" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">首先，我们必须理解 Javascript 中的一些关键概念——同步/异步和阻塞/非阻塞</p><p id="236f" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">考虑以下片段</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="ea4b" class="kw in hi ks b fi kx ky l kz la">//simple callbacks example</span><span id="d5f7" class="kw in hi ks b fi lb ky l kz la">const greetings = () =&gt; {<br/> console.log('Hello');<br/>};</span><span id="eb59" class="kw in hi ks b fi lb ky l kz la">const greetingsLater = () =&gt; {<br/> console.log('Hi');<br/>}</span><span id="22ca" class="kw in hi ks b fi lb ky l kz la">setTimeout(greetingsLater, 5000);<br/>greetings();</span></pre><p id="b1f4" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">像大多数编程语言一样，Javascript 从上到下一行一行地执行代码——在上面的代码片段中，它创建了两个函数——“greetings”和“greetingsLater”，然后通过内置函数“setTimeout”执行函数“greetingsLater”，最后执行 greetings</p><p id="0607" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">其他内置的异步函数包括:setInterval()、requestAnimationFrame()、navigator . geolocation . getcurrentposition…</p><p id="1e39" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">它将输出</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="73d3" class="kw in hi ks b fi kx ky l kz la">Hello<br/>Hi //after 5 seconds later</span></pre><p id="dcac" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">代替</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d8cf" class="kw in hi ks b fi kx ky l kz la">//after 5 seconds later<br/>Hi<br/>Hello</span></pre><p id="8e80" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">为什么？</p><p id="a9cd" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">因为 setTimeout()是一个内置 Javascript 函数，它有一个特殊的机制将操作交给浏览器。每当 Javascript 看到这种异步函数时，它会切换到浏览器并进入下一行，而不是等待计时器结束— <strong class="jm hj">非阻塞</strong>。<br/>浏览器接管它并监控定时器，当定时器结束时，浏览器将任务“greetingsLater”放入浏览器中的“待办事项”——<strong class="jm hj">消息队列，一旦 Javascript 引擎——<strong class="jm hj">栈</strong>空闲，Javascript 将执行函数“greetings la ter”——<strong class="jm hj">异步</strong></strong></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="9e1c" class="kw in hi ks b fi kx ky l kz la">//blocking example</span><span id="371c" class="kw in hi ks b fi lb ky l kz la">const greetings = () =&gt; {<br/> console.log(‘Hello’);<br/>};<br/>const greetingsLater = () =&gt; {<br/> console.log(‘Hi’);<br/>};<br/>//a for loop which takes time<br/>for (i=1; i&lt;999999999; i++) {<br/>}<br/>greetingsLater();<br/>greetings();</span></pre><p id="89f2" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">阻塞</p><p id="d213" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">上面的代码片段是<strong class="jm hj">阻塞</strong>的例子——函数“greetingsLater”和“greetings”在 for 循环中只能执行一次。通常，我们不希望它出现在 Javascript 中，因为它会冻结应用程序，同时我们什么也做不了，这会导致糟糕的用户体验。</p><p id="2589" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">回调总是稍后执行</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6ad9" class="kw in hi ks b fi kx ky l kz la">//simple callbacks example 2</span><span id="2410" class="kw in hi ks b fi lb ky l kz la">const greetings = () =&gt; {<br/> console.log('Hello');<br/>};</span><span id="caf1" class="kw in hi ks b fi lb ky l kz la">const greetingsLater = () =&gt; {<br/> console.log('Hi');<br/>}</span><span id="7811" class="kw in hi ks b fi lb ky l kz la">setTimeout(greetingsLater, 0);<br/>greetings();</span></pre><p id="acce" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">上面的代码片段与第一个代码片段相同，只是我们在“setTimeout”中放了零，这意味着以 0 毫秒的延迟执行。尽管如此，因为这是一个回调，所以仍然需要等待，如果 Javascript engine-stack 得到了其他任务(在大多数情况下是指不是回调的任务)，那么它将首先执行其他任务。因此，在这种情况下，它仍然先执行“greetings()”，然后执行“greetingsLater”</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="add9" class="kw in hi ks b fi kx ky l kz la">Hello<br/>Hi //immediately display after Hello, as provided 0 in setTimeout</span></pre><p id="eee3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">如果我们有多个异步任务，会发生什么？</p><p id="0790" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">我们可以通过使用嵌套回调来控制它们的顺序，但是很难读取，不是吗？</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d022" class="kw in hi ks b fi kx ky l kz la">function gettingLocation() {<br/>  setTimeout(function() {<br/>    console.log('Some task required before retrieving location');<br/>      setTimeout(<br/>        navigator.geolocation.getCurrentPosition (<br/>            posData =&gt; {<br/>                console.log(posData);<br/>                setTimeout(() =&gt; { <br/>                    setTimeout(console.log('Some task after getting the location'), 0) <br/>                    }, 0);},<br/>            error =&gt; {<br/>                console.log(Error);<br/>                setTimeout(() =&gt; {<br/>                    setTimeout(console.log('Some task after fail getting the location'), 0) <br/>                }, 0);}<br/>       ), 0);<br/>  }, 0);<br/>};</span></pre><p id="c7fa" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这就是为什么 Javascript 引入了 Promise 和 async await</p><h1 id="c607" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak"> 2。承诺</strong></h1><p id="f985" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Promise 是一种语法，允许我们以同步方式执行异步代码。简而言之，我们可以控制异步代码的流程，尤其是那些相互依赖的任务。只有单一的嵌套层，没有更多的回调地狱</p><p id="3a7d" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">大多数现代 Javascript API 都支持 promise，但是有些函数如 setTimeout()和 navigator . geolocation . getcurrentposition 不支持 promise，我们可以手动或使用一些库如<a class="ae lc" href="http://bluebirdjs.com/docs/api/promise.promisify.html" rel="noopener ugc nofollow" target="_blank"> bluebird、</a>将它“包装”成 Promise，这个过程称为<strong class="jm hj"> Promisfy </strong></p><h2 id="297b" class="kw in hi bd io ld le lf is lg lh li iw jv lj lk ja jz ll lm je kd ln lo ji lp bi translated"><strong class="ak">许诺</strong></h2><p id="9512" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">通常，我们会这样设置超时。假设我们想在 3 秒钟后打印一些东西</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="5852" class="kw in hi ks b fi kx ky l kz la">setTimeout(() =&gt; console.log('3 seconds Done!'), 3000)</span></pre><p id="0546" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">现在，我们将创建一个函数来“包装”setTimeout，以便返回 Promise 对象。第一个‘resolve’和‘reject’是我们要传递给 new Promise()的参数，你可以随意命名。然后我们将使用它们来包装成功或失败的结果。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="fa3e" class="kw in hi ks b fi kx ky l kz la">function delay(ms) {<br/>   return new Promise((resolve, reject) =&gt; setTimeout(<br/>() =&gt; (resolve(console.log('3 seconds Done!')), () =&gt; reject(console.log('fail')) ), ms));<br/>}</span></pre><p id="16cf" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">通常，我们会在“then”语句中使用结果，而对于 setTimeout，我们没有任何失败。所以，它会是这样的</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a47f" class="kw in hi ks b fi kx ky l kz la">function delay(msg, ms) {<br/>   return new Promise(resolve =&gt; setTimeout(<br/>() =&gt; resolve(msg), ms));<br/>}</span><span id="75e9" class="kw in hi ks b fi lb ky l kz la">//in arrow function<br/>const delay = (msg, ms) =&gt; new Promise(resolve =&gt; setTimeout(<br/>() =&gt; resolve(msg), ms));</span></pre><p id="121a" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">你可能会觉得奇怪，为什么我们要把一个函数放在 argument 里，然后马上被 JavaScript 执行。这就是所谓“揭示构造器模式”。如果你熟悉 Java，你可能会认为它是一个私有函数，但是因为 JavaScript 没有“私有/公共”的概念，所以他们这样设计是为了限制访问。<br/>有关更多信息，请参考以下链接</p><ol class=""><li id="8d88" class="lq lr hi jm b jn ki jr kj jv ls jz lt kd lu kh lv lw lx ly bi translated"><a class="ae lc" href="https://www.i-programmer.info/programming/javascript/11379-javascript-async-promises-the-revealing-constructor-pattern.html?start=1" rel="noopener ugc nofollow" target="_blank">https://www . I-programmer . info/programming/JavaScript/11379-JavaScript-async-promises-the-revealing-constructor-pattern . html？start=1 </a></li><li id="6875" class="lq lr hi jm b jn lz jr ma jv mb jz mc kd md kh lv lw lx ly bi translated"><a class="ae lc" href="https://stackoverflow.com/questions/37651780/why-does-the-promise-constructor-need-an-executor" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/37651780/why-the-promise-constructor-need-a-executor</a></li></ol><p id="1c70" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">我们现在有了返回 promise 对象的函数，我们如何使用它。只需在“then”语句中声明一个以“data”为参数的函数。“数据”是承诺“解决”的结果(对于“拒绝”的返回，我们将在下一节讨论)，即“3 秒钟完成！”或者上面的“失败”</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="defe" class="kw in hi ks b fi kx ky l kz la">delay(3000).then(data =&gt; console.log('data:', data));</span></pre><p id="a731" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">Promisfy 的另一个例子—navigator . geolocation . getcurrentposition()</p><p id="f8fc" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">与上面的例子相似。基于它的<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition" rel="noopener ugc nofollow" target="_blank"> API </a>，我们必须传递“成功”和“错误”的回调，以及一个用于选项的变量。所以我们只是将 resolve 和 reject 分别放在“成功”和“错误”回调中</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="9393" class="kw in hi ks b fi kx ky l kz la">const geoLocation = (opts) =&gt; new Promise((resolve, reject) =&gt; navigator.geolocation.getCurrentPosition(<br/>posData=&gt;{resolve(posData)}, error=&gt;{reject(error)}, opts));</span></pre><p id="a8ce" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这次我们可以测试“拒绝”,因为我们可以阻止浏览器的位置访问来触发这种情况。为了得到错误，只需在消费上述承诺时，在“then”语句中传递第二个参数</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b28c" class="kw in hi ks b fi kx ky l kz la">geoLocation().then(<br/>data =&gt; console.log('data', data), <br/>err =&gt; console.log(err)<br/>);</span></pre><p id="47e1" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">您也可以使用“catch”语句</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="54cf" class="kw in hi ks b fi kx ky l kz la">geoLocation()<br/>.then(data =&gt; console.log('data', data))<br/>.catch(err =&gt; console.log(err));</span></pre><p id="42f0" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">承诺链<br/> </strong>参考第 1 节中的 callhell 示例，我们可以通过 more then 和 catch 将这段代码转换为承诺链。除了使用上一次的结果——“解决”或“拒绝”，它还可以通过返回另一个承诺来处理另一个异步任务。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4c78" class="kw in hi ks b fi kx ky l kz la">//Promisfied setTimeout<br/>const delay = (msg, ms) =&gt; new Promise(resolve =&gt; setTimeout(<br/>() =&gt; resolve(msg), ms));</span><span id="b79b" class="kw in hi ks b fi lb ky l kz la">//Promisfied navigator.geolocation.getCurrentPosition<br/>const geoLocation = (opts) =&gt; new Promise((resolve, reject) =&gt; navigator.geolocation.getCurrentPosition(<br/>posData=&gt;{resolve(posData)}, error=&gt;{reject(error)}, opts));</span><span id="f605" class="kw in hi ks b fi lb ky l kz la">delay('Some task required before retrieving location', 0)<br/>.then(data =&gt; console.log(data))<br/>.then(() =&gt; geoLocation())<br/>.then(data =&gt; {console.log(data); return delay('Some task after getting the location', 0)})<br/>.catch(err =&gt; {console.log(err); return delay('Some task after fail getting the location', 0)})<br/>.then(data =&gt; console.log(data));</span></pre><p id="bfbf" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">如果成功检索位置，它打印</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4421" class="kw in hi ks b fi kx ky l kz la">Some task required before retrieving location<br/>GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1607081342802}<br/>Some task after getting the location</span></pre><p id="df83" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">如果检索位置失败，它将打印</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6d49" class="kw in hi ks b fi kx ky l kz la">Some task required before retrieving location<br/>GeolocationPositionError {code: 1, message: "User denied Geolocation"}<br/>Some task after fail getting the location</span></pre><p id="3164" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">关于“catch”语句的更多信息</p><p id="92b3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">“catch”语句可以放在第一行之后，它将捕捉“catch”语句之前的任何错误。<br/>考虑下面的代码片段</p><p id="a38e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">这里的“catch”将捕获来自 geoLocation()的错误，并恢复“then”语句</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a9db" class="kw in hi ks b fi kx ky l kz la">//assume fail to get location<br/>geoLocation()<br/>.catch(err =&gt; console.log(err))<br/>.then(data =&gt; console.log('data', data));</span><span id="7b30" class="kw in hi ks b fi lb ky l kz la">//Output<br/>//GeolocationPositionError {code: 1, message: "User denied Geolocation"}<br/>//data undefined</span></pre><p id="a6b2" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">在下面的例子中，因为第一个“then”语句有错误，所以它跳过其他“then”语句，直到“catch”语句，然后继续。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="87cf" class="kw in hi ks b fi kx ky l kz la">//assume fail to get location<br/>delay("msg", 1000)<br/>.then(data =&gt; console.log('data', data))<br/>.then(()=&gt;geoLocation())<br/>.then(data =&gt; console.log('data', data))<br/>.then(()=&gt; {return delay("msg2", 1000)})<br/>.then(data =&gt; console.log('data', data))<br/>.catch(err =&gt; console.log(err))<br/>.then(()=&gt; {return delay("msg3", 1000)})<br/>.then(data =&gt; console.log('data', data));</span><span id="ed39" class="kw in hi ks b fi lb ky l kz la">//Output<br/>//data msg<br/>//GeolocationPositionError {code: 1, message: "User denied Geolocation"}<br/>//data msg3</span></pre><p id="ecfc" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">* *在“then”语句中的第二个参数— reject，与上面提到的“catch”语句具有相同的功能。就我个人而言，我更喜欢“catch”语句，因为它提供了更多的灵活性。</p><p id="c105" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">尝试下面的工作示例，查看控制台中的输出</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure></div></div>    
</body>
</html>