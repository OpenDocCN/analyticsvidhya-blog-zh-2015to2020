<html>
<head>
<title>Converting Texts to document-term matrix using Count Vectorizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用计数矢量器将文本转换为文档术语矩阵</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/converting-texts-to-document-term-matrix-using-count-vectorizer-c247127b61ba?source=collection_archive---------7-----------------------#2020-01-03">https://medium.com/analytics-vidhya/converting-texts-to-document-term-matrix-using-count-vectorizer-c247127b61ba?source=collection_archive---------7-----------------------#2020-01-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8b32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在ML中处理文本是最刺激智力的练习之一，但是这个练习的缺点是我们的ML算法不能直接处理文本，所有这些ML算法都需要数字作为参数。这意味着我们的文本数据应该被转换成数字向量。在自然语言处理行话中，这被称为特征提取。具体来说，文本特征提取。</p><p id="40f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CountVectorizer是一个用sklearn编写的类，帮助我们将文本数据转换为数字向量。我将使用sklearn中提供的示例。先做最重要的事情；我们需要从sklearn导入该类，以便访问它。</p><p id="53a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们将使用sk learn<a class="ae jd" href="#_ftn1" rel="noopener ugc nofollow">【1】</a>中提供的例子，我们将有一个包含四个文档的语料库。这是我们要转换成向量的文本数据。假设你还在上高二，一个向量就是一个指针，或者简单的说，一个1*1的数组。例如，在下面的语料库中，我们将有四个向量，在每个向量中，我们将存储一些表示文本数据的数字输入。语料库是语言片断的集合，集合可能包括列表、图表、树等。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="fdc3" class="jn jo hi jj b fi jp jq l jr js">corpus = [</span><span id="6122" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">... </strong>    'This is the first document.',</span><span id="2bf8" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">... </strong>    'This document is the second document.',</span><span id="8d8e" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">... </strong>    'And this is the third one.',</span><span id="7707" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">... </strong>    'Is this the first document?',</span><span id="1e2b" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">... </strong>]</span></pre><p id="fab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们获取类的实例，这样我们就可以利用它的方法，将文本数据转换成ML算法所需的数字输入</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f2c5" class="jn jo hi jj b fi jp jq l jr js">vectorizer = CountVectorizer()</span></pre><p id="f8ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个类有几个参数。其中最重要的是分析器，它有三个选项。Word、char和char_ws。在analyzer中，您可以指定n-gram应该如何处理您的数据，应该将其视为字符还是单词。因此，如果您将分析器设置为word，将n-gram_range设置为(2，2)，它将选择两个相邻的单词并将它们连接起来。如果你的n-gram_range设置为(1，2)，我们的字典将取一个单词加对(相邻对)。既然我们已经初始化了这个类，我们就有了一个可以用来访问其中的方法的对象。其中有一个名为fit_transform的函数()，我们将把语料库作为参数，并将文本数据转换为向量。这种方法利用一种称为单词包(BoW)的方法来实现这一点。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1f55" class="jn jo hi jj b fi jp jq l jr js">X = vectorizer.fit_transform(corpus)</span></pre><p id="49d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一袋单词</p><p id="0b91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单词包所做的，类似于python中flatten()函数所做的；</p><p id="9a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.<strong class="ih hj">它首先将数组形状折叠成一维，然后移除所有重复的数组</strong>。因此，我们将得到如下输出:</p><p id="994e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">'这个'，'是'，'这个'，'第一个'，'文件'，'第二个'，'第三个'，'一个'</p><p id="b4f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">但是get_feature_names()函数会返回这样的结果:</strong></p><p id="3f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和'，'文档'，'第一个'，'是'，'第一个'，'第二个'，'第三个'，'这个'</p><p id="0015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为数组是按字母顺序排序的。</p><p id="911c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。</strong> <strong class="ih hj">它使用我们得到的字典得到文档-术语矩阵向量</strong></p><p id="0909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的字典里有9个元素。因此，在数组的每个向量(索引)中，我们有9个元素。</p><p id="0e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似这样的事情(这是在计算之前)</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8398" class="jn jo hi jj b fi jp jq l jr js">[ 0  0  0  0  0  0  0  0  0 ]</span><span id="28a0" class="jn jo hi jj b fi jt jq l jr js">[ 0  0  0  0  0  0  0  0  0 ]</span><span id="127c" class="jn jo hi jj b fi jt jq l jr js">[ 0  0  0  0  0  0  0  0  0 ]</span><span id="790e" class="jn jo hi jj b fi jt jq l jr js">[ 0  0  0  0  0  0  0  0  0 ]</span></pre><p id="7100" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住所有这些数字，代表我们的字典'和'，'文件'，'第一'，'是'，'一'，'第二'，'的'，'第三'，'这'</p><p id="4c60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于第一个元素，你问它是否出现在处理的文档中，它出现了多少次。因为“这是第一份文件。”我们看到字典中的第一个术语“and”在我们的文档中没有出现(我们处理的是第一个文档)，所以我们用0替换它的索引。第二个术语是“文档”，它在文档中出现过一次，所以我们用1替换第二个索引。最后，对于第一个向量，应该是这样的。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="3f96" class="jn jo hi jj b fi jp jq l jr js">[0 1 1 1 0 0 1 0 1]</span></pre><p id="2446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引文</p><p id="0b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="http://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html" rel="noopener ugc nofollow" target="_blank">sci kit-learn:Python中的机器学习</a>，Pedregosa <em class="ju">等人</em>，JMLR 12，第2825–2830页，2011年。</p><p id="997b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . feature _ extraction . text . count vectorizer . html</a></p></div></div>    
</body>
</html>