<html>
<head>
<title>Creating a Game Bot to Play ‘Link Up’ with Graph Theory, Tensorflow and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个游戏机器人，用图论、Tensorflow和Keras玩“连接”</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-a-game-bot-to-play-link-up-with-graph-theory-tensorflow-and-keras-531686b5a69b?source=collection_archive---------30-----------------------#2020-05-11">https://medium.com/analytics-vidhya/creating-a-game-bot-to-play-link-up-with-graph-theory-tensorflow-and-keras-531686b5a69b?source=collection_archive---------30-----------------------#2020-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dd01" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx">用圖論, Tensorflow和Keras製作自動玩「連連看」的程式</h2></div><ol class=""><li id="6e9e" class="ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated"><strong class="iz hj">最终结果</strong></li></ol><p id="25f6" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">1.1 Gif</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kc"><img src="../Images/160cb4db73b4b22f1a326bb2fc7a160c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*jBWNl_uImziW1ExPekwCMw.gif"/></div></figure><p id="afb3" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">1.2 YouTube链接</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="4bc3" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">如上图，最终工具可以有效识别游戏面板中的磁贴，并按照一定的规则自动点击。对屏幕动态变化的反应快速准确。</p><p id="f710" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">1.3 Github链接</p><p id="6d7e" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">https://github.com/lester1027/game_bot_linkup<a class="ae km" href="https://github.com/lester1027/game_bot_linkup" rel="noopener ugc nofollow" target="_blank"/></p><p id="9b2f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 2。动机</strong></p><p id="63e9" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">在我的闲暇时间，我向我的女朋友挑战玩链接。连接是一种游戏，玩家试图一次将两个相同类型的瓷砖连接在一起。链接的瓷砖将会消失。连接它们的路径必须包含等于或少于两个转弯。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kn"><img src="../Images/a60c9419c0ae23404c600525ae37f2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1E2bDSlvPC949h7t6u2Bkw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">没有转折点</figcaption></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kw"><img src="../Images/ba97da327c82861ab855a060a122639f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBAbcQ-BvOl_MR4BHLtXnQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">一个转折点</figcaption></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es kx"><img src="../Images/d0e46fcb65342de3741e9d384628e38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSJg7HLM_V_xvGjsj7ED5A.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">两个转折点</figcaption></figure><p id="e80f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">打了很多回合，都输了。原来我女朋友是这个游戏的高手。放学后她经常花很多时间在这上面。面对她令人难以置信的反射弧，作为一个新手，我毫无胜算。因此，我想到了向我们可爱的机器——计算机借用动力。</p><p id="25b4" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 3。目标</strong></p><p id="353b" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">然后，我开始计划一个程序，它可以为我自动化整个游戏过程。简而言之，某种类型的游戏黑客，尽管这里没有涉及真正的黑客。下面列出了该程序的功能。</p><ul class=""><li id="a37d" class="ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk ky jm jn jo bi translated">在游戏面板中找到方块上的图案</li><li id="b87a" class="ix iy hi iz b ja kz jc la je lb jg lc ji ld jk ky jm jn jo bi translated">确定瓷砖属于哪个类别</li><li id="4265" class="ix iy hi iz b ja kz jc la je lb jg lc ji ld jk ky jm jn jo bi translated">存储图块的位置和类别信息</li><li id="dc98" class="ix iy hi iz b ja kz jc la je lb jg lc ji ld jk ky jm jn jo bi translated">制定游戏规则</li><li id="7d3d" class="ix iy hi iz b ja kz jc la je lb jg lc ji ld jk ky jm jn jo bi translated">确定目标牌是否符合规则</li><li id="9b4b" class="ix iy hi iz b ja kz jc la je lb jg lc ji ld jk ky jm jn jo bi translated">将鼠标光标移动到目标图块，如果是，则单击它们</li><li id="af5d" class="ix iy hi iz b ja kz jc la je lb jg lc ji ld jk ky jm jn jo bi translated">如果没有，选择另一对牌或等待游戏面板屏幕的下一个时间步</li></ul><p id="cd59" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 4。方法</strong></p><p id="2740" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">4.1分类瓷砖</p><p id="2f9c" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">当我在网上为这个兼职项目寻找见解时，我发现了一个很好的<a class="ae km" href="https://inventwithpython.com/blog/2014/12/17/programming-a-bot-to-play-the-sushi-go-round-flash-game/" rel="noopener ugc nofollow" target="_blank">游戏机器人教程</a>，它的作者编写了一个程序来自动化一个寿司制作游戏。这里使用的图像识别技术只是读取游戏面板中一些目标位置的RGB值。对于图形效果简单的游戏，这种方法足够有用。但是，对于我正在尝试解决的游戏来说，这种方法并不能胜任，原因如下。</p><p id="dd4e" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">I .此游戏中的瓷砖不能每次都以完全相同的高度和宽度尺寸切割。有时会有一到两个像素的误差。</p><p id="6e65" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">二。由于照明效果，当块出现在不同位置时，来自同一类图案的像素的RGB值可能改变。</p><p id="8931" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">三。当触发图形效果时，像素的RGB值也可以改变。一些目标像素甚至可能被覆盖。</p><p id="e52f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">由于这个游戏的情况比较复杂，所以需要更聪明的方法。计算机视觉是一种值得尝试的合适方法。如今它被广泛应用于图像分类任务中。</p><p id="4ac7" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">我需要训练一个计算机视觉模型来完成这项任务。使用了《用Python进行计算机视觉的深度学习》一书中的一些代码。我使用Tensorflow和Keras库进行机器学习。Tensorflow负责低层张量运算。Keras是包装Tensorflow操作的高级API。它使Tensorflow生态系统更加人性化。在这个项目中，一个简单的CNN被训练来捕捉图像中的特征，并使用它们来预测类别。它包括17个类别的分类，因为瓷砖中有17种不同的图案。CNN由标准卷积层、激活层、批量标准化层、汇集层和丢弃层组成。然后矩阵被展平，并且softmax函数被用作最终的激活函数。交叉熵用于确定预测的类别。</p><pre class="kd ke kf kg fd le lf lg lh aw li bi"><span id="fc1b" class="lj lk hi lf b fi ll lm l ln lo">model.add(Conv2D(128, (3, 3), padding=’same’))</span><span id="2050" class="lj lk hi lf b fi lp lm l ln lo">model.add(Activation(‘relu’))</span><span id="9026" class="lj lk hi lf b fi lp lm l ln lo"><em class="lq"># model.add(BatchNormalization(axis=channel_dim))</em></span><span id="3a63" class="lj lk hi lf b fi lp lm l ln lo">model.add(MaxPooling2D(pool_size=(2, 2)))</span><span id="2d69" class="lj lk hi lf b fi lp lm l ln lo">model.add(Dropout(0.25))</span><span id="0e3f" class="lj lk hi lf b fi lp lm l ln lo"><em class="lq"># First (and only) set of FC =&gt; RELU layers</em></span><span id="56be" class="lj lk hi lf b fi lp lm l ln lo">model.add(Flatten())</span><span id="69d1" class="lj lk hi lf b fi lp lm l ln lo">model.add(Dense(512))</span><span id="6c64" class="lj lk hi lf b fi lp lm l ln lo">model.add(Activation(‘relu’))</span><span id="27af" class="lj lk hi lf b fi lp lm l ln lo">model.add(BatchNormalization())</span><span id="b8b0" class="lj lk hi lf b fi lp lm l ln lo">model.add(Dropout(0.5))</span><span id="1ad7" class="lj lk hi lf b fi lp lm l ln lo"><em class="lq"># Softmax classifier</em></span><span id="5455" class="lj lk hi lf b fi lp lm l ln lo">model.add(Dense(classes))</span><span id="69f3" class="lj lk hi lf b fi lp lm l ln lo">model.add(Activation(‘softmax’))</span></pre><p id="1d2f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">首先，捕捉游戏面板的截图。然后根据预定义的pos_dict提取截图中的瓦片。pos_dict的关键字是瓦片的行和列索引。它的值是每个图块的四个顶点的x和y坐标。对分割的图像应用灰度，从而只留下图像的一个通道，以减少分类期间的处理时间。已处理图像中的所有像素值都被重新缩放到(0，1)范围。预处理后，像素值存储在val_dict中。</p><pre class="kd ke kf kg fd le lf lg lh aw li bi"><span id="a1cd" class="lj lk hi lf b fi ll lm l ln lo">def categorize(model):</span><span id="fd83" class="lj lk hi lf b fi lp lm l ln lo">‘’’</span><span id="765c" class="lj lk hi lf b fi lp lm l ln lo">#input:None</span><span id="984d" class="lj lk hi lf b fi lp lm l ln lo">#output: a dictionary containing the cropped and grayscaled images</span><span id="2631" class="lj lk hi lf b fi lp lm l ln lo">‘’’</span><span id="23fd" class="lj lk hi lf b fi lp lm l ln lo">val_dict =grabBox()</span><span id="f731" class="lj lk hi lf b fi lp lm l ln lo">type_dict={}</span><span id="9eca" class="lj lk hi lf b fi lp lm l ln lo"><em class="lq">#for each position of the game panel</em></span><span id="a480" class="lj lk hi lf b fi lp lm l ln lo">for row in range(n_row):</span><span id="dc40" class="lj lk hi lf b fi lp lm l ln lo">for col in range(n_col):</span><span id="e3a4" class="lj lk hi lf b fi lp lm l ln lo">val=val_dict[(row,col)]</span><span id="f288" class="lj lk hi lf b fi lp lm l ln lo"><em class="lq">#resize</em></span><span id="c59c" class="lj lk hi lf b fi lp lm l ln lo">sp = SimplePreprocessor(pixels,pixels)</span><span id="1f1f" class="lj lk hi lf b fi lp lm l ln lo">val=sp.preprocess(val)</span><span id="2250" class="lj lk hi lf b fi lp lm l ln lo"><em class="lq">#image to array operation</em></span><span id="273e" class="lj lk hi lf b fi lp lm l ln lo">iap = ImageToArrayPreprocessor()</span><span id="91aa" class="lj lk hi lf b fi lp lm l ln lo">val=iap.preprocess(val)</span><span id="efce" class="lj lk hi lf b fi lp lm l ln lo">val=val.reshape(-1,pixels,pixels,1)</span><span id="e082" class="lj lk hi lf b fi lp lm l ln lo">type_dict[(row,col)]=type_list[model.predict(val,batch_size=1).argmax()]</span><span id="8fd3" class="lj lk hi lf b fi lp lm l ln lo">return type_dict</span></pre><p id="a43e" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">4.2图表分析</p><p id="537f" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">图论用于分析从游戏面板收集的信息。图是一组顶点V和一组边E，组成一个有序对G=(V，E)。当我们只考虑一类目标瓷砖时，存储的图案可以被标记为三种类型:目标、障碍物和空瓷砖。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lr"><img src="../Images/1316e6f6045581d9cd247949a499fcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_UiDPEDpm2yE7hYgJ7SWg.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">原始截图</figcaption></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ls"><img src="../Images/92a695072d05808c4cdc49e96c84862a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vK_Lyg65hUG1-fHF5BKTzQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">目标瓷砖:黑鸭子(蓝色)、障碍瓷砖(红色)和空瓷砖(灰色)(此处添加了两列和两行，因为路径可以向外构建)</figcaption></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lt"><img src="../Images/ce7575371b4afd72cd01b6ea3714dd8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHHiKkEP_Veo5Fk14XSnRA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">从上面的概念形成的图</figcaption></figure><p id="d4dd" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">在构建图之后，使用广度优先搜索(BFS)算法来确定从一个瓦片到另一个瓦片的最短路径。输入是图和遍历图时的初始顶点。该函数的输出是一个列表，其中包含遍历的顶点的顺序和一个字典，该字典包含作为键的顶点和作为值的父顶点。</p><p id="28c4" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">然而，BFS算法无法生成转弯次数最少的路径，而这是本项目所必需的。因此，编写了一个名为count_turn()的函数来计算行走路径中的最小转弯次数。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es lu"><img src="../Images/3723268c6425edfb393531f0275c8760.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/format:webp/1*nuOUuieIT9yY9SOLp-9pyw.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">最短的路径，但没有最少的转弯点</figcaption></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es lu"><img src="../Images/faf88ee3b623afedd2ee255fcee07188.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/format:webp/1*StwflyJVGvZpWh2Zd_ZA3Q.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">最短的路径，最少的转弯点</figcaption></figure><p id="44ad" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">如果计数小于或等于2，则对应的路径是有效路径。</p><p id="81d1" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">在分析过程之后，程序可以将鼠标光标移动到目标瓷砖的中心，并一个接一个地点击它们。</p><p id="2608" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">当链接的瓷砖因链接成功而消失时，程序会对游戏面板进行另一次截图，并重复上述过程。如果在这个循环中没有有效的路径生成，程序将继续寻找由其他图块生成的潜在路径。</p><p id="7bb4" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated"><strong class="iz hj"> 5。后记</strong></p><p id="10b7" class="pw-post-body-paragraph jp jq hi iz b ja jb ij jr jc jd im js je jt ju jv jg jw jx jy ji jz ka kb jk hb bi translated">我用这个程序成功打败了我的女朋友。从那以后她再也没有和我玩过这个游戏。</p></div></div>    
</body>
</html>