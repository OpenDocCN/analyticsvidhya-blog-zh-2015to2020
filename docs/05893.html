<html>
<head>
<title>Implement a Binary Search Tree in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Ruby中实现二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implement-a-binary-search-tree-in-ruby-c3fa9192410b?source=collection_archive---------2-----------------------#2020-05-05">https://medium.com/analytics-vidhya/implement-a-binary-search-tree-in-ruby-c3fa9192410b?source=collection_archive---------2-----------------------#2020-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/96bf534c9ebd8c6d9c1dbc6288db0741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oP7AeCxIcBaAoAzqzIzCmQ.jpeg"/></div></div></figure><p id="27f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我之前的帖子介绍过<a class="ae jo" rel="noopener" href="/analytics-vidhya/implement-a-linked-list-in-ruby-2aae925acd9c"> <strong class="is hj">单链表</strong> </a>。由于链表在插入和删除元素方面的性能，它是一种广泛使用的数据结构。但是，如果数据集中有一个顺序，并且您希望非常频繁地搜索某个特定的项目，那么链表不是最佳选择，因为它的线性搜索时间很长。我们正在寻找的是一个简单的数据结构，其大多数操作的平均运行时间是次线性的。我们提到的数据结构是<strong class="is hj">二叉查找树(BST) </strong>。</p><h2 id="55e4" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">树是什么，我们为什么想要它？</h2><p id="9d78" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><strong class="is hj">树</strong>是一种数据结构，用于以<strong class="is hj">层次模式</strong>存储数据。它由节点组成。一棵树有一个顶级节点(称为根节点)和一堆更低的节点。每个节点只能有一个父节点(根节点除外)，但可以有零个或多个子节点！</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/693ffd652d2b4bad1362acd96efbe36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JR__fqQqt0EkS5_aLsm4rQ.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">一棵简单的树</figcaption></figure><p id="a7cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种独特的数据结构有很多好处。关于树的一个伟大的事情是每个节点看起来像它自己的<strong class="is hj">子树</strong>。这意味着我们可以通过使用<strong class="is hj">递归</strong>来节省代码。此外，二叉查找树经常用于搜索。搜索操作只需要O(log(n))的运行时间。</p><h2 id="2e24" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">BST的特性</strong></h2><p id="4e79" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">二叉查找树是一种树数据结构。它和树有相同的结构。但是有它自己的特性:</p><ul class=""><li id="5c5c" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">在二叉查找树中，每个节点只包含一个左子节点和一个右子节点；</li><li id="9c94" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">左子树中的每个节点的数据值比该节点的数据值小<strong class="is hj">；</strong></li><li id="b082" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">右边子树中的每个节点的数据值大于(或等于)节点的数据值</li></ul><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/9e485980013fb51b03f78a4d16edbcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NR_Hwab2DUj8ruLgFy6WQg.jpeg"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">一个二叉查找树</figcaption></figure><p id="fc5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以用这个<a class="ae jo" href="https://www.cs.usfca.edu/~galles/visualization/BST.html" rel="noopener ugc nofollow" target="_blank">网站</a>来玩玩，看看BST是怎么构造的！</p><h1 id="4bcb" class="ln jq hi bd jr lo lp lq jv lr ls lt jz lu lv lw kc lx ly lz kf ma mb mc ki md bi translated">和我一起用Ruby编写BST代码吧！</h1><h2 id="c6de" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">步骤1:为节点和BST创建一个类</strong></h2><p id="00e4" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">BST由节点组成。每个节点都有一个值，两个指针分别指向左右两个子节点。我们可以先实现一个节点类:</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="4b76" class="jp jq hi mf b fi mj mk l ml mm">class TreeNode<br/>    attr_accessor :value, :left, :right</span><span id="4261" class="jp jq hi mf b fi mn mk l ml mm">   <strong class="mf hj"> #node is initialized with a value, and two children are nil</strong><br/>    def initialize(value)<br/>        @value = value<br/>        @left = nil<br/>        @right = nil<br/>    end<br/>end</span></pre><p id="baab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">节点类到此为止！超级简单吧？</p><p id="9281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们编写一个BST类:</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="e675" class="jp jq hi mf b fi mj mk l ml mm">class BST<br/>    attr_accessor :root, :size</span><span id="a2fc" class="jp jq hi mf b fi mn mk l ml mm">    def initialize()<br/>        @root = nil<br/>        @size = 0;<br/>    end<br/>end</span></pre><p id="6ab0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在这里为BST设置了两个变量:<strong class="is hj">根</strong>和<strong class="is hj">大小</strong>因为:1)。BST必须有一个根。这是树的起点。2):为了简化计算，当我们插入或删除一个节点时，我们可以很容易地给类变量@size加1或减1。</p><h2 id="ad01" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">第二步:实例方法:插入(值)</strong></h2><p id="743f" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">回想一下BST的属性:<strong class="is hj">左子</strong>的值是<strong class="is hj">小于</strong>本身的值，<strong class="is hj">右子</strong>的值是<strong class="is hj">大于</strong>本身的值。这就是插入新值的模式。当我们看到一个新值时，我们想把它和根的值进行比较，如果新值大于根的值，我们就向右走。否则，我们走左边。</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="9b05" class="jp jq hi mf b fi mj mk l ml mm">def insert(value)<br/>    if @root == nil<br/>        @root = TreeNode.new(value)<br/>    else<br/>        curr_node = @root<br/>        previous_node = @root</span><span id="91ba" class="jp jq hi mf b fi mn mk l ml mm">        #<strong class="mf hj">while loop helps finding the position of insertion</strong><br/>        while curr_node != nil<br/>            previous_node = curr_node<br/>            if value &lt; curr_node.value<br/>                curr_node = curr_node.left<br/>            else<br/>                curr_node = curr_node.right<br/>            end<br/>        end<br/>        if value &lt; previous_node.value<br/>            previous_node.left = TreeNode.new(value)<br/>        else<br/>            previous_node.right = TreeNode.new(value)<br/>        end<br/>    end<br/>    @size += 1<br/>end</span></pre><h2 id="e979" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">第三步:实例方法:find_min()和find_max() </strong></h2><p id="1294" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">显然，最小值节点是最左边的子节点。最大值节点是最右边的子节点。</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="8111" class="jp jq hi mf b fi mj mk l ml mm">def find_max(node = self.root)<br/>    if node == nil<br/>        return nil<br/>    elsif node.right == nil<br/>        return node<br/>    end<br/>    return find_max(node.right)<br/>end</span><span id="0a34" class="jp jq hi mf b fi mn mk l ml mm">def find_min(node = self.root)<br/>    if node == nil<br/>        return nil<br/>    elsif node.left == nil<br/>        return node<br/>    end<br/>    return find_min(node.left)<br/>end</span></pre><h2 id="99f7" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">第四步:实例方法:包含(值)？</h2><p id="9f50" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">这是一个布尔函数，当BST有我们传入的值时，它将返回true。</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="4a51" class="jp jq hi mf b fi mj mk l ml mm">def contains?(value, node = self.root)<br/>    if node == nil<br/>        return false<br/>    elsif value &lt; node.value<br/>        return contains?(value, node.left)<br/>    elsif value &gt; node.value<br/>        return contains?(value, node.right)<br/>    else<br/>        return true<br/>    end<br/>end</span></pre><p id="703a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码背后的算法是，我们递归地找到左子树和右子树，看看节点的值是否匹配我们想要找到的值。</p><h2 id="e156" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">第五步:实例方法:print() </strong></h2><p id="aec8" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">对于BST，有四种常见的遍历:</p><ul class=""><li id="05a1" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><strong class="is hj">按序</strong>:先递归处理左边的节点，然后是这个节点，再递归处理右边的节点。这将导致“正常秩序”</li><li id="6c68" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">预排序</strong>:先处理这个节点，然后递归处理左边的节点，再递归处理右边的节点</li><li id="884e" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">后序</strong>:递归处理左边的节点，然后是右边的节点，然后是这个节点</li><li id="bf07" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj"> Level-order </strong>:根据深度处理节点:首先是最接近根的节点，然后是更低的节点。</li></ul><p id="981e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我将使用<strong class="is hj">有序遍历</strong>来实现我的print():</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="73b8" class="jp jq hi mf b fi mj mk l ml mm">def print_in_order(node = self.root)<br/>    if node != nil<br/>        print "("<br/>        print_in_order(node.left)<br/>        print ", #{node.value}, "<br/>        print_in_order(node.right)<br/>        print ")"<br/>    end<br/>end</span></pre><h2 id="ad3f" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">第六步:实例方法:移除(值)</strong></h2><p id="d1b7" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">当我们想从BST中删除一个节点时，我们需要考虑三种情况:</p><ul class=""><li id="da95" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">如果节点有<strong class="is hj">零个子节点:</strong>它是‘叶子’节点，我们可以简单地从树中删除；</li><li id="ea66" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">如果节点有<strong class="is hj">一个子节点</strong>(左子或右子):我们移除这个节点后，需要将其子节点提升到该位置；</li><li id="8218" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">如果节点有<strong class="is hj">两个子节点</strong>:我们需要找到一个候选来提升。候选者可以是右边子树的最小数据或左边子树的最大数据。</li></ul><p id="1baf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我画了一些图表来说明这些情况:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/a6e51dfea18722d34b6f586490146b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3CzqIgFVG0e4dQRow1ZOQ.jpeg"/></div></div></figure><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/c65be04ac0449fff81ec52541ef74f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q38zPObESfnlt9VPHons8A.jpeg"/></div></div></figure><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="3f39" class="jp jq hi mf b fi mj mk l ml mm">def remove(value, node = self.root)<br/>    removeHelper(value, node = self.root)<br/>    @size -= 1<br/>    node<br/>end</span><span id="fe69" class="jp jq hi mf b fi mn mk l ml mm">private<br/><strong class="mf hj">#this helper method will avoid the multiple size decreses in recursion</strong><br/>def removeHelper(value, node = self.root)<br/>    if node == nil<br/>        return nil<br/>    end<br/>    if node.value &gt; value<br/>        node.left = removeHelper(value, node.left)<br/>    elsif node.value &lt; value<br/>        node.right = removeHelper(value, node.right)<br/>    else<br/>        if node.left != nil &amp;&amp; node.right != nil<br/>            temp = node<br/>            min_of_right_subtree = find_min(node.right)<br/>            node.value = min_of_right_subtree.value<br/>            node.right = removeHelper(min_of_right_subtree.value, node.right)<br/>        elsif node.left != nil<br/>            node = node.left<br/>        elsif node.right != nil<br/>            node = node.right<br/>        else<br/>            node = nil<br/>        end<br/>    end<br/>    return node<br/>end</span></pre><h2 id="8092" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">第七步:实例方法:clear() </strong></h2><p id="ebdb" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">clear()是一个简单的方法:我们将根设置为nil，并将大小重置为零！</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="3419" class="jp jq hi mf b fi mj mk l ml mm">def clear()<br/>    self.root = nil<br/>    self.size = 0<br/>end</span></pre><h2 id="8dbe" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">第八步:实例方法:size() </strong></h2><p id="7967" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">这是最简单的方法！因为我们已经有了一个代表树的大小的类变量@size，在这里，我们可以简单地返回这个值:</p><pre class="kq kr ks kt fd me mf mg mh aw mi bi"><span id="62b5" class="jp jq hi mf b fi mj mk l ml mm">def size()<br/>    @size<br/>end</span></pre><p id="a77f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我实现BST的全部内容！你可以在这里查看全部代码:<a class="ae jo" href="https://gist.github.com/wyy1234567/c07b38530ce4e400cdfa278cb4bb3425" rel="noopener ugc nofollow" target="_blank"> <em class="mq">链接</em> </a>。</p><p id="272d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢你阅读这篇文章，我希望它会有所帮助！</p></div></div>    
</body>
</html>