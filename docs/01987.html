<html>
<head>
<title>In depth explanation of FeedForward in Neural Network mathematically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从数学上深入解释神经网络中的前馈</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/in-depth-explanation-of-feedforward-in-neural-network-mathematically-448092216b63?source=collection_archive---------5-----------------------#2019-11-25">https://medium.com/analytics-vidhya/in-depth-explanation-of-feedforward-in-neural-network-mathematically-448092216b63?source=collection_archive---------5-----------------------#2019-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9c42e9039c269e4714645dacf02c6cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*_P6NgCRbiskarDV9YZOvqQ.png"/></div></figure><p id="be73" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了解释前馈过程，让我们看一下人工神经网络的基本模型，其中我们只有一个隐藏层。输入分别连接到隐藏层中的神经元，隐藏层中的神经元分别连接到输出层中的神经元，其中每个神经元代表单个输出。我们可以把它看作是数学函数的集合。每个输入通过一组我们需要修改的权重在数学上连接到一个隐层神经元，每个隐层神经元以类似的方式连接到输出层。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/5b35cd457416c3f797cad9dd3589a577.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*ct9UHlpsc-PIK5mCg7L7ag.png"/></div></figure><p id="8b67" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输入的数量、层中隐藏神经元的数量和输出的数量没有限制。这些数字之间也没有任何关联，所以我们可以有n个输入，m个隐藏神经元和k个输出。在更近、甚至更简单的观察中，我们可以看到每个输入都乘以相应的权重，并在下一层的神经元上加上一个偏差。偏差是神经元的外部参数，可以通过添加外部固定值输入来建模。整个求和过程通常会通过激活函数到达下一层或输出端。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/2e48ead3f2d10e525cf29ff2765004ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BCbd0eNMSxuH_oDF9TcNg.png"/></div></div></figure><p id="a8a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的目标是以这样一种方式设计一个系统，它将为我们提供特定输入x的正确输出y。本质上，我们真正想要的是找到将输入连接到隐藏层的最优权重集以及将隐藏层连接到输出的最优权重集。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ju"><img src="../Images/d4e1918d81f0c3a77ba4eaa9b1bbd5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oW38yY6jEs9NB7rV2vCe9Q.png"/></div></div></figure><p id="1473" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，我们需要开始训练阶段，为我们的系统找到最佳的砝码组。这个阶段将包括两个步骤:前馈和反向传播。在前馈部分，我们将计算系统的输出。输出将与正确的输出进行比较，给出错误的指示。在反向传播部分，我们将改变权重，以尽量减少误差。并再次启动前馈，直到我们找到系统的最佳权重集。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jv"><img src="../Images/211b720346dbbd357b3318568682186e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*xbnLhTvjYPknGQlOcbcfOA.png"/></div></div></figure><h1 id="e258" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">前馈过程的数学解释</h1><h2 id="ca5d" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated">计算隐藏状态的值</h2><p id="b6e9" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">为了使计算更容易，我们将决定有n个输入，单个隐藏层中的3个神经元和两个输出。实际上，我们可以在一个隐藏层中拥有数千个神经元。我们将使用W_1作为从x到h的一组权重，W_2作为从h到y的一组权重。由于我们只有一个隐藏层，所以我们在每个前馈循环中将只有两个步骤。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ln"><img src="../Images/d326c63461198a2a9aa9b7f6386149d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycDUAMaxDYaHx7xl9pqEjg.png"/></div></div></figure><p id="705d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，隐藏层和输出层都显示为向量，因为它们都由多个神经元表示。</p><p id="0ddf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了使用非线性激活函数之外，所有计算都涉及输入和权重的线性组合。换句话说，我们将使用矩阵乘法。用于<a class="ae lo" href="http://linear.ups.edu/html/section-LC.html" rel="noopener ugc nofollow" target="_blank">线性组合</a>和<a class="ae lo" href="https://en.wikipedia.org/wiki/Matrix_multiplication" rel="noopener ugc nofollow" target="_blank">矩阵乘法</a>的链接。</p><h2 id="906d" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated">步骤1(找到h)</h2><p id="ab80" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">如果我们在一个隐藏层中有一个以上的神经元，h实际上是一个向量。每个输入是一个向量，连接到隐层中的每个神经元。隐藏层的向量h’将通过将输入向量乘以权重矩阵W1 <em class="lp"> W </em> 1来计算，如下所示:</p><p id="11e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lp">h</em>′=(<em class="lp">x</em>T10】W1)</p><p id="77e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用向量乘矩阵乘法，我们可以用下面的方式来看这个计算</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lq"><img src="../Images/ad17d471c4eb252e6272caecc19cb95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5_x1YPT2RPCUwaivLFRhg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">等式1</figcaption></figure><p id="c9d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在找到h’之后，为了确保h的值不会爆炸和增加太多，我们需要一个激活函数(φ)来完成隐藏层值的计算。该激活函数可以是双曲正切、Sigmoid或ReLU函数。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lv"><img src="../Images/0f3340c01c60e80dc72c8d6aa9b4065c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcWen5XLjTiAwbLA1B9FTQ.png"/></div></div></figure><p id="be49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以使用下面两个等式来表示最终的隐藏向量h:</p><p id="6be9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">h =φ(x W1)</p><p id="1377" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者</p><p id="9205" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">h =φ(h′)</p><p id="75b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于Wij表示权重矩阵中的权重分量，将神经元<strong class="io hj"> i </strong>从输入连接到隐藏层中的神经元<strong class="io hj"> j </strong>，我们也可以用以下方式编写这些计算:(注意，在这个例子中，我们有<em class="lp"> n </em>个输入，只有3个隐藏神经元)</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lw"><img src="../Images/43100e651efcf63a32df9c90a03766d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKjC03HYtIZnn9qk27sM-A.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">等式2</figcaption></figure><p id="1d07" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关于激活功能以及如何使用它们的更多信息可以在<a class="ae lo" href="https://github.com/Kulbear/deep-learning-nano-foundation/wiki/ReLU-and-Softmax-Activation-Functions" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="a2dd" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated">第二步(寻找y)</h2><p id="7c9e" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">计算输出向量的过程在数学上类似于计算隐藏层向量的过程。我们再一次使用一个向量乘以矩阵，然后是一个激活函数。向量是新计算的隐藏层，矩阵是连接隐藏层和输出的矩阵。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/25b501c80a3a0d2e9c44aebd75d30f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*Vpbbx8LtQRKhYc_5OlpkIg.png"/></div></figure><p id="ff8e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本质上，神经网络中的每个新层是通过矩阵乘法由向量计算的，其中向量表示新层的输入，而矩阵是将这些新输入连接到下一层的矩阵。</p><p id="06d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们的例子中，输入向量是h，矩阵是W2，因此y =h W2。在某些应用中，使用softmax函数可能是有益的(如果我们希望所有输出值介于0和1之间，并且它们的总和为1)。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/d031458e81c0e4b646ed8c5d2510013e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*_PRaArCx8XQ7CpJQjYSqUw.png"/></div></figure><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lz"><img src="../Images/9ccdda26794188a90b2f3ba2ac61d9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AE2i4wZkPPC_2FNEbPsPyw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">Softmax函数</figcaption></figure><p id="868a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了很好地逼近输出y，我们需要不止一层的隐藏层，甚至可以有几千层。本质上，你可以把这些神经元看作是可以堆叠的积木。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/f3ea1bb29270161e5da2951e8e300dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*vFOzcMSOR1pPFNacPLn76w.png"/></div></figure><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mb"><img src="../Images/ce0fe38be2f74cef5b145e2e32f34b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPr6bKHZ8keyFXarxlMqIg.png"/></div></div></figure><p id="92d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，我们没有强调偏置输入。偏见不会改变这些计算。简单地认为它是一个恒定的输入，通常是一个，它也通过一个权重连接到隐藏层的每个神经元。bias与任何其它输入之间的唯一区别是，当其它输入改变时，它保持不变。就像所有其他输入一样，连接到下一层的权重也会更新。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es mc"><img src="../Images/f3b2feaacd6b2c6547a30b8cddb933a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TA1yrvRcYxBdAcfCWN-1sA.png"/></div></div></figure><p id="4166" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的目标是找到最佳的权重集，为我们提供特定输入的期望输出。在训练阶段，我们实际上知道给定输入的输出。我们计算系统的输出，以便调整权重。我们通过找出错误并努力将其最小化来做到这一点。训练阶段的每一次迭代都会减少一点误差，直到我们最终确定误差足够小。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es md"><img src="../Images/38e9bdd03665d2ab0c26483061588c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgYKzFfvQJuo8vd_PPYuVw.png"/></div></div></figure><p id="9f3e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最常用的两个误差函数是<a class="ae lo" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">均方误差(MSE) </a>(通常用于回归问题)和<a class="ae lo" href="https://www.ics.uci.edu/~pjsadows/notes.pdf" rel="noopener ugc nofollow" target="_blank">交叉熵</a>(通常用于分类问题)。</p><p id="60d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上述计算中，我们使用了MSE的变化。</p><p id="8be5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来的文章将关注反向传播过程，或者我们也称之为使用链式法则的随机梯度下降。</p><p id="74cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">反向传播的深入解释链接可以在<a class="ae lo" rel="noopener" href="/@aungkyawmyint_26195/deep-dive-into-back-propagation-part-i-e1a92b6dbdb9">这里</a>找到。</p><p id="df5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">内容鸣谢:Udacity深度学习计划</p></div></div>    
</body>
</html>