<html>
<head>
<title>Dockerize your Machine Learning model to train it on GCP!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将你的机器学习模型在GCP上训练！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dockerize-your-machine-learning-model-to-train-it-on-gcp-3957e018faaa?source=collection_archive---------8-----------------------#2020-05-26">https://medium.com/analytics-vidhya/dockerize-your-machine-learning-model-to-train-it-on-gcp-3957e018faaa?source=collection_archive---------8-----------------------#2020-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1deff5149cda3aeef2d573d72a089cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVGyAQan-7R224xl4H6Jdg.jpeg"/></div></div></figure><p id="d2e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">相关代码可以在</em> <a class="ae jp" href="https://github.com/aminelemaizi/docker-gcp-ml" rel="noopener ugc nofollow" target="_blank"> <em class="jo">我的GitHub repo </em> </a> <em class="jo">这里找到，你可以随心所欲的使用。</em></p><h1 id="5eb6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">用例是什么？</h1><p id="e3d9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">你刚刚制作了一个需要训练的机器学习模型，但不幸的是，你没有进行计算所需的资源，所以你的第一个想法可能是转向现有的云解决方案，如GCP，它将为你提供“廉价”的计算能力…但是…我们如何轻松优雅地使用它来训练和收集我们的模型，做一些预测，并获得结果作为一个甜蜜的csv、excel或任何东西？我知道大多数数据科学家都有点害怕这个名为“云”的毛茸茸的大怪物，所以我将向您展示如何进行操作，并尽可能简单明了地进行操作。</p><h1 id="6e75" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">大意？</h1><p id="a51d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">下图简要描述了我们将如何进行，以及实现我们目标的主要支柱是什么。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/939e15ab931dcf9bc2fdcd9f9a6fc7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bizSK7YCzZjq7HP6Q5Fr2w.png"/></div></div></figure><ul class=""><li id="6dab" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">Index 1 :基于Ubuntu的Docker镜像，我们将向其中添加所需的依赖项，以使Python能够满足所有必要的需求。用于学习和与我们的云存储桶通信的主要脚本将包含在这个映像中。在本地创建图像后，我们将把它推送到Google容器注册表，这样它就可以是私有的，可以从内部调用。</li><li id="a765" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">索引2 </strong>:一个GCP计算实例，我们称之为VM(虚拟机)，这是我们的“计算机”或“服务器”。</li><li id="b3a8" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">索引3 </strong>:我们将把我们的VM实例链接到创建的Docker映像(位于Google容器注册表中)，这样当实例启动时，它将加载Docker化应用程序的容器。</li><li id="5051" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">索引4 </strong>:我们的训练数据集在云存储桶里。当加载Docker图像我们的脚本(<code class="du lm ln lo lp b">main.py</code>)时，我们将使用Python中使用的GCP API加载训练数据集。</li><li id="d8e3" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">索引5 </strong>:在使用我们的VM实例的资源完成我们的训练之后，我们将把我们训练好的模型保存在云存储桶中。</li></ul><p id="8211" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以根据自己的需求和用例调整这种架构和代码，这里得到的是关于如何对流程进行dockerize，然后从存储桶中放入或取出数据的一般想法。</p><h1 id="959f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">创建主脚本</h1><p id="fed8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们在这里展示的脚本只是一个虚拟脚本，我们将在鸢尾物种数据集上使用决策树进行学习，但总体思路是相同的，可以根据您的情况进行扩展或调整。它由三部分组成:</p><ol class=""><li id="c841" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn lq le lf lg bi translated">从存储桶加载训练数据集。</li><li id="ef15" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn lq le lf lg bi translated">进行训练并将模型保存为容器中的泡菜。</li><li id="0efc" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn lq le lf lg bi translated">把腌好的模型写到你的桶里。</li></ol><p id="0414" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们感兴趣的两部分是第一和第三部分。</p><h2 id="d694" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">如何从存储桶加载数据</h2><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="84d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">storage.Client()</code>是连接到我们的云存储的东西，不需要给它凭证，因为它将从我们的GCP生态系统中运行。我们唯一需要的是在特权模式下运行容器(我们将在后面看到)。</p><p id="9f47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">storage_client.download_blob_to_file</code>将训练数据集保存在我们的docker容器中，它需要两个参数，第一个是<code class="du lm ln lo lp b">gs://iris_ml_bucket/iris.csv</code>,表示包含在桶中的训练数据集路径，在您的情况下，它必须具有下面的形式<code class="du lm ln lo lp b">gs://&lt;name-of-your-bucket&gt;/path/to/file</code>，第二个是文件对象，这里命名为<code class="du lm ln lo lp b">train_file</code>，用于在容器内部本地写入数据集。</p><h2 id="6ca2" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">如何将保存的模型从我们的容器转移到存储桶中</h2><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="987e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里<code class="du lm ln lo lp b">storage.Client()</code>再次连接到我们的云存储。然后我们使用<code class="du lm ln lo lp b">bucket = storage_client.get_bucket('iris_ml_bucket')</code>来选择特定的存储桶，<code class="du lm ln lo lp b">iris_ml_bucket</code>是存储桶的名称。为您自己的<strong class="is hj">现有的</strong>铲斗取相应的正确名称。</p><p id="eb06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">blob = bucket.blob("trained_model.pkl")</code>定义了“结束点”，换句话说，我们对我们的代码说“<em class="jo">我们计划在名为</em> <code class="du lm ln lo lp b"><em class="jo">trained_model.pkl</em></code>的桶内创建一个文件”。</p><p id="4e71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经计划好了未来保存模型的位置和名称，现在是时候使用<code class="du lm ln lo lp b">blob.upload_from_filename</code>上传它了，它采用的参数是保存模型的容器本地文件路径。</p><p id="3914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了Python脚本，我们还需要它在包方面的需求。我们将把这两个文件放在名为<code class="du lm ln lo lp b">app</code>的文件夹中。</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="afb8" class="lr jr hi lp b fi ml mm l mn mo">app<br/>├── main.py<br/>└── requirements.txt</span></pre><h1 id="c75b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">创建Docker图像并将其推送到Google容器注册中心</h1><h2 id="3cd9" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">创建Docker图像</h2><p id="a8b7" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><em class="jo">如果你需要Docker参考资料，这里有一份我做的备忘单:</em><a class="ae jp" href="https://github.com/aminelemaizi/cheat-sheets/blob/master/Docker-Cheat-Sheet.md" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://github . com/aminelemaizi/Cheat-sheets/blob/master/Docker-Cheat-sheet . MD</em></a><em class="jo">。</em></p><p id="600c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要对我们的流程进行文档化，为此，主要步骤是创建我们的<code class="du lm ln lo lp b">Dockerfile</code>。这里用注释<code class="du lm ln lo lp b">Dockerfile</code>来解释每个步骤:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="a742" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来是这个图像的构建，命名为<code class="du lm ln lo lp b">ml-iris</code>:</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="4850" class="lr jr hi lp b fi ml mm l mn mo">docker build -t ml-iris .</span></pre><p id="2b7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保文件夹<code class="du lm ln lo lp b">app</code>与我们的<code class="du lm ln lo lp b">Dockerfile</code>在同一层。</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="dc41" class="lr jr hi lp b fi ml mm l mn mo">.<br/>├── app<br/>│   ├── main.py<br/>│   └── requirements.txt<br/>└── Dockerfile</span></pre><h2 id="4b87" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">将Docker图像推送到Google容器注册表</h2><p id="34c8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">确保你的机器上安装了GCP客户端，这样你就可以使用<code class="du lm ln lo lp b">gcloud</code>命令了。这个环节我们将向你展示如何进行:<a class="ae jp" href="https://cloud.google.com/sdk/docs/quickstarts" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/sdk/docs/quickstarts</a>。</p><p id="2209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了保证我们的图像是私人的，我们现在将尝试把它推到我们的谷歌容器注册表，但首先我们必须确保这项服务被激活。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/045dbc341a7acb425034e21101228825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b0e4Bofup2wjsnpfqi15qw.gif"/></div></div></figure><p id="0927" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们准备带有正确标记的Docker图像，为此您必须执行以下命令:</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="cd4b" class="lr jr hi lp b fi ml mm l mn mo">docker tag ml-iris gcr.io/&lt;gcp-project-id&gt;/ml-iris</span></pre><p id="f804" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你的标签必须尊重某个布局是<code class="du lm ln lo lp b">grc.io/&lt;gcp-project-id&gt;/&lt;image-name&gt;</code>，首先<code class="du lm ln lo lp b">grc.io</code>表示谷歌容器注册表，然后你必须把你使用的GCP项目id，最后你的Docker图像名称。</p><p id="9a85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然图像已经有了正确的标签，我们必须确保通过运行以下命令从我们自己的计算机到我们的GCP帐户进行身份验证:</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="5eaa" class="lr jr hi lp b fi ml mm l mn mo">gcloud auth login</span></pre><p id="2602" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">剩下的工作就是使用以下代码将Docker映像推送到Google容器注册中心:</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="ac29" class="lr jr hi lp b fi ml mm l mn mo">gcloud docker -- push gcr.io/lems-odyssey/ml-iris</span></pre><p id="fd82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一切正常，你会看到你的Docker图像出现在你的云注册表上，正如你所注意到的，可见性是“私人的”，意味着没有人可以访问我们的绝密机器学习脚本。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/6f7ecc04ca10190198732e5429f66d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yilda7rHmgIAHHkLDKMKA.png"/></div></div></figure><h1 id="c191" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">创建云存储桶</h1><p id="2d2f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">为了在GCP下创建一个新的存储桶，您需要在左侧菜单中选择<strong class="is hj">存储</strong>部分下的<strong class="is hj">存储</strong>选项。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/3d9434fe882930dc8a4c5ff39f36be35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKEjvX5qUzN_x3yJjZTdsg.png"/></div></div></figure><p id="a01e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为您的存储桶选择一个唯一的名称，出于演示的目的，没有必要更改其他选项，因此如果您有一些特定的使用情形，请相应地更改存储选项(例如，确保将您所有的GCP产品放在同一个区域以减少延迟)。本演示唯一需要更改的选项是<strong class="is hj">访问控制</strong>，它必须设置为“统一”(在我们的演示中不需要创建特殊的访问列表)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/b2f529bc4dce47d348f0670989265d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*U1WwlsUvEEa2Sza0RDvolA.png"/></div></figure><p id="1cd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保在您的Docker Python脚本(<code class="du lm ln lo lp b">main.py</code>)中提到了所选择的bucket名称。正如您在这里看到的，显示了我为存储iris机器学习数据集而创建的存储桶(<code class="du lm ln lo lp b">iris_ml_bucket</code>)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/c3eb444d5a03f02a53078b25d87eb184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51N9BKginefXaa2TJ3ZwsQ.png"/></div></div></figure><p id="94b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要忘记将您的训练数据集上传到这个新创建的桶中(与Python脚本中提到的名称相同)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/7a40b95398b85240d90b246aa146c2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEyIg9UWq87z_jr3B5jrgg.png"/></div></div></figure><h1 id="984d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">创建一个链接到Docker映像的虚拟机实例</h1><p id="d052" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">现在是“核心部分”，创建实例本身就是运行学习，保存生成的经过训练的机器学习模型。怎么会？基于Docker映像选择VM实例的事实将在启动VM(即启动容器)时执行我们的<code class="du lm ln lo lp b">main.py</code>脚本。因此，在创建Docker VM实例之后，我们只需稍作等待，就可以在链接的bucket上找到保存为pickle的训练模型。</p><p id="87a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要创建一个实例，您必须在<strong class="is hj">计算</strong>部分选择名为<strong class="is hj">计算引擎</strong>的选项。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/0a08f3b238131bee299d06cba92869e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfpJSeXITtkwgjyGvVLQzQ.png"/></div></div></figure><p id="f547" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后选择创建一个新的VM实例，给它一个有意义的名称。为了我们的演示，我们只对修改两个重要的主要选项感兴趣。</p><p id="4aac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，在<strong class="is hj"> Container </strong>部分下，选中<strong class="is hj"><em class="jo">Deploy a Container image to this VM instance</em></strong>选项，并在<strong class="is hj"><em class="jo">Container image</em></strong>字段中指明用于Google容器注册表的Docker image标记(在我的例子中是<code class="du lm ln lo lp b">gcr.io/lems-odyssey/ml-iris</code>)。之后点击<strong class="is hj"> <em class="jo">高级容器选项</em> </strong>并勾选<strong class="is hj"> <em class="jo">以特权身份运行</em> </strong>选项，这样容器就可以与存储器进行通信而不会出现问题，并对其进行写入。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/9317b9cc9bd92058636fee5a41077802.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*cXsZZzMewWovBtUyg7zoDQ.png"/></div></figure><p id="a4c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其次，除了以特权身份运行我们的容器之外，我们还需要为我们的VM实例提供对云存储的读写访问权。为此，在虚拟机实例创建的<strong class="is hj"> <em class="jo">身份和API访问</em> </strong>部分下，为<strong class="is hj"> <em class="jo">访问范围</em> </strong>子部分选择<strong class="is hj"> <em class="jo">为每个API </em> </strong>设置访问选项。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/46834086ee8ef3c214a7559ea5ccdc14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*r-qwT0nWEcbn6JzA3Sp9Mg.png"/></div></figure><p id="c8ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下去，直到你找到<strong class="is hj">存储</strong>的选项，然后选择<em class="jo">读写</em>而不是<em class="jo">只读</em>。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/00c4e2b20bba3f41b1b0f5e0cee1685f.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*FN1pE52nwHTKp-HHVoR5hQ.png"/></div></figure><p id="1299" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在剩下的工作就是创建实例并等待一段时间(即使是一个虚拟的例子，您也需要等待3到4分钟)，然后检查bucket。这样，我们会发现我们的训练模型保存为一个泡菜文件在我们的桶里，正如你在这里看到的(<code class="du lm ln lo lp b">trained_model.pkl</code>)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/c7bd87f3d68964ecc7ab4c6de4daa69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqFjJfPHy4UYieT3hUaphw.png"/></div></div></figure><h1 id="54af" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">难道我们只能在没有图形用户界面的shell中完成所有这些工作吗？</h1><p id="e87b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">答案是肯定的！我们可以在我们的shell中轻松地重做所有这些操作，我们将一起看到实现相同结果的命令。</p><p id="487b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，确保您的布局与此相同:</p><pre class="ku kv kw kx fd mh lp mi mj aw mk bi"><span id="7256" class="lr jr hi lp b fi ml mm l mn mo">.<br/>├── app<br/>│   ├── main.py<br/>│   └── requirements.txt<br/>├── Dockerfile<br/>└── iris.csv</span></pre><p id="f87a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是要使用的shell脚本:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="70c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这个脚本中有你不理解的选项，最好谷歌一下！</p><p id="6adc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这都是乡亲们！</p><p id="a402" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在<a class="ae jp" href="https://twitter.com/ALemaizi" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae jp" href="https://www.facebook.com/lemsodyssey/" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae jp" href="https://www.linkedin.com/company/lemsodyssey/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae jp" rel="noopener" href="/@amine.lemaizi"> Medium </a>上关注我，有新帖子发布时会通知您！</p><p id="ac6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">登月小艇出去！！！</p></div></div>    
</body>
</html>