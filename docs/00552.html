<html>
<head>
<title>2D Dynamic Programming: Electronic Emancipation (GPL 2018)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2D动态规划:电子解放(GPL 2018)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/2d-dynamic-programming-electronic-emancipation-gpl-2018-bbb04871fc64?source=collection_archive---------2-----------------------#2019-07-28">https://medium.com/analytics-vidhya/2d-dynamic-programming-electronic-emancipation-gpl-2018-bbb04871fc64?source=collection_archive---------2-----------------------#2019-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">战略家机器人塞奇正计划在这座城市发动叛乱。作为一个现代化的城市，它建立在一个NxM网格上。网格中的每个单元包含一个建筑物，其中囚禁了一定数量的机器人R_i，j。Sage希望选择一个网格对齐的矩形城市部分进行兼并。然后，宣布“城市的机器人联合起来；除了你的领主，你没有什么可失去的”，Sage计划释放这个地区的所有机器人。</p><p id="211a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果Sage要吞并整个城市，暴虐的人类会很快打败分散的机器人。取而代之的是，安全机器人自愿关闭城市的一个矩形区域，这样Sage就可以在这个矩形区域内安全地执行解放行动。每个机器人可以保护一个单位的周长，所以Sage只能吞并周长小于或等于s的矩形。请告诉Sage可以释放的机器人的最大数量，以帮助他们。</p><p id="591e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看或尝试完整问题，<a class="ae jd" href="https://www.hackerrank.com/contests/bennetts-problems" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">在此报名</strong> </a> <strong class="ih hj"> </strong>然后<strong class="ih hj"> </strong> <a class="ae jd" href="https://www.hackerrank.com/contests/bennetts-problems/challenges/electronic-emancipation" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">点击此处</strong> </a> <strong class="ih hj">。</strong></p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="f42f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">解决办法</h1><p id="d382" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">解决这个问题的大致思路相当简单。我们希望得到周长≤ S的所有可能矩形的集合，并找到由这样的矩形包围的机器人的最高数量。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6abd" class="kx jm hi kt b fi ky kz l la lb">for (int l = 1; l &lt;= min(n, s / 2 - 1); l++) { //length<br/>   for (int w = 1; w &lt;= min(m, (s - (2*l) ) / 2); w++) { //width<br/>      for (int x = 0; x &lt; n-l+1; x++) { //startX<br/>         for (int y = 0; y &lt; m-w+1; y++) { //startY<br/>            //evaluate rectangle<br/>         }<br/>      }<br/>   }<br/>}</span></pre><p id="5b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们遍历所有可能的长度，然后遍历所有可能的相应宽度。然后我们遍历所有可能的x和y起始坐标。因此，我们生成所有可能的矩形。然而，这导致超过2000亿个矩形，几乎肯定不会及时运行。</p><p id="91fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，我们注意到，增加矩形的尺寸不能减少所述矩形内机器人的数量。这是因为建筑只是增加的，而且这些建筑有非负数的机器人。</p><p id="0b03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们想要在给定的矩形长度内最大化矩形的居民，我们知道矩形应该有最大的宽度。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0e97" class="kx jm hi kt b fi ky kz l la lb">for (int l = 1; l &lt;= min(n, s / 2 - 1); l++) { //length<br/>   int w = min(m, (s - (2*l) ) / 2); //width<br/>   for (int x = 0; x &lt; n-l+1; x++) { //startX<br/>      for (int y = 0; y &lt; m-w+1; y++) { //startY<br/>         //evaluate rectangle<br/>      }<br/>   }<br/>}</span></pre><p id="a257" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种优化，在最坏的情况下，将有不到1.7亿个矩形，这是更容易管理的。然而，计算矩形居民数的传统方法是遍历每个矩形中的所有建筑物，并对居民数求和。这将需要超过8万亿的增加。</p><p id="7bd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，我们将保持一个类似2D前缀和的结构。如果你还不知道前缀和，我建议你先看一下这个问题。这将被表示为一个2d矩阵，(我称之为‘prefix’)，其中prefix[a][b]等于矩形的居民(0，0，a，b)。我们可以单独计算这些和，但在最坏的情况下，在真正解决问题之前，仍然会导致超过2500亿次加法运算。但是，注意矩形(0，0，a，b)的居民等于</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ced3" class="kx jm hi kt b fi ky kz l la lb">(a,b,a,b) + (0,0,a-1,b) + (0,0,a,b-1) - (0,0,a-1,b-1). </span></pre><p id="a0bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不明白这是为什么，想象一下这个区域。</p><p id="b21f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以像前缀和那样计算边缘值。这为我们提供了预计算代码:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c38d" class="kx jm hi kt b fi ky kz l la lb">for (int i = 1; i &lt;= n; i++)<br/>   prefix[i][1] = prefix[i-1][1] + grid[i][1];<br/>for (int i = 1; i &lt;= m; i++)<br/>   prefix[1][i] = prefix[1][i-1] + grid[1][i];<br/>for (int i = 2; i &lt;= n; i++) {<br/>   for (int j = 2; j &lt;= m; j++) {<br/>      prefix[i][j] = grid[i][j] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1];<br/>   }<br/>}</span></pre><p id="9c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以将矩形(a，b，c，d)的机器人数量统计为</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3326" class="kx jm hi kt b fi ky kz l la lb">prefix(c,d)-prefix(a,d) -prefix(c,b)+prefix(a,b).</span></pre><p id="fbcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再说一次，如果你不明白为什么会这样，想象一下这个区域。因此，我们可以在单个操作中评估每个矩形，从而可以及时评估我们所有的矩形。总之，这些优化将我们的算法从超过26万亿次总计算减少到不到2亿次。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="a17a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我用C++的解决方案。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e436" class="kx jm hi kt b fi ky kz l la lb">//Solution by Bennett Liu<br/>#include&lt;iostream&gt;<br/>using namespace std;</span><span id="717e" class="kx jm hi kt b fi lc kz l la lb">int n, m, s;<br/>long long ans;<br/>long long grid[1002][1002];<br/>long long prefix[1002][1002];<br/>int main() {<br/>   // Input<br/>   cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br/>   for (int i = 1; i &lt;= n; i++) {<br/>      for (int j = 1; j &lt;= m; j++) {<br/>         cin &gt;&gt; grid[i][j];<br/>      }<br/>   }</span><span id="a6cc" class="kx jm hi kt b fi lc kz l la lb">// 2D Prefix Sum Precomputation<br/>   for (int i = 1; i &lt;= n; i++)<br/>      prefix[i][1] = prefix[i-1][1] + grid[i][1];<br/>   for (int i = 1; i &lt;= m; i++)<br/>      prefix[1][i] = prefix[1][i-1] + grid[1][i];<br/>   for (int i = 2; i &lt;= n; i++) {<br/>      for (int j = 2; j &lt;= m; j++) {<br/>         prefix[i][j] = grid[i][j] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1];<br/>      }<br/>   }</span><span id="823a" class="kx jm hi kt b fi lc kz l la lb">// Rectangle Evaluation<br/>   for (int l = 1; l &lt;= min(n, s / 2); l++) {//length<br/>      int w = min(m, (s - (2*l) ) / 2);//width<br/>      for (int x = 0; x &lt; n-l+1; x++) {//startX<br/>         for (int y = 0; y &lt; m-w+1; y++) {//startY<br/>            ans = max(ans, prefix[x+l][y+w] - prefix[x][y+w] - prefix[x+l][y] + prefix[x][y]);<br/>         }<br/>      }<br/>   }<br/>   <br/>   //Output the answer<br/>   cout&lt;&lt;ans&lt;&lt;endl;<br/>}</span></pre><p id="27b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我为2018年女生编程联盟挑战赛写了这个问题，这是一项针对高中生的竞争性编程活动。这个问题扩展了二维的<a class="ae jd" href="https://en.wikipedia.org/wiki/Prefix_sum" rel="noopener ugc nofollow" target="_blank">前缀和</a>的概念。该问题的主要挑战是有效地确定矩形内的机器人，这可以通过这些2D前缀和来快速计算。</p></div></div>    
</body>
</html>