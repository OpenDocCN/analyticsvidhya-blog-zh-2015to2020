<html>
<head>
<title>How to create a music visualizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建音乐可视化工具</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-create-a-music-visualizer-7fad401f5a69?source=collection_archive---------1-----------------------#2020-04-30">https://medium.com/analytics-vidhya/how-to-create-a-music-visualizer-7fad401f5a69?source=collection_archive---------1-----------------------#2020-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都喜欢音乐。音乐可以是任何形式和种类，每个人都有不同的品味。共同的因素是我们都可以听音乐，但为什么只有当我们也能看到音乐时才听音乐呢？</p><p id="bae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是关于我制作音乐可视化工具的经验。本文还将解释如何创建可视化工具。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><a class="ae jo" href="https://gitlab.com/avirzayev/music-visualizer" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/avirzayev/music-visualizer</a></figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/7922696a21c6dee4316e858014b02b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJ2MrN4a3tSx71NCcmF2fw.png"/></div></div></figure><h1 id="1abc" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">怎样才能把音乐形象化？</h1><p id="bdfc" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们需要知道音乐是如何组成的，以及如何将这些部分形象化。音乐是声音的组合。声音是我们的耳朵探测到的频繁振动。振动由频率和振幅——速度和响度——来定义。</p><p id="6576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的方法就是画一排条形。每个条形代表一个频率。当音乐继续时，这些小节会上下移动，这取决于频率的幅度。</p><h1 id="78f5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用Python实现</h1><p id="cd41" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在开始编码之前，您需要安装一个图形库和一个声音分析器库。在我的项目中，我使用了Pygame(图形)和Librosa(声音)。</p><p id="6f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Librosa有非常有用的功能，可以帮助我们分析声音。文档:【https://librosa.github.io/librosa/ T2】</p><p id="10b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一段代码，它返回一个对应于某个时间的频率幅度的二维数组:</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="67f4" class="le jx hi la b fi lf lg l lh li"># getting information from the file<br/>time_series, sample_rate = librosa.load(filename)</span><span id="73cf" class="le jx hi la b fi lj lg l lh li"># getting a matrix which contains amplitude values according to frequency and time indexes<br/>stft = np.abs(librosa.stft(time_series, hop_length=512, n_fft=2048*4))</span><span id="942c" class="le jx hi la b fi lj lg l lh li"># converting the matrix to decibel matrix<br/>spectrogram = librosa.amplitude_to_db(stft, ref=np.max)</span></pre><p id="4ef4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">librosa.load()正在读取给定的文件，并保存有关该文件的信息以备后用。mple_rate是每个周期采样的数量。time_series是一个一维数组，表示获取每个样本的时间。</p><p id="7eba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Libros.stft()返回一个包含频率和时间的二维数组。然后你可以看到我把这个数组从振幅转换成分贝。除非你想用分贝单位，否则这一步是不必要的。</p><blockquote class="lk ll lm"><p id="78e5" class="if ig ln ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated"><strong class="ih hj">短时傅立叶变换</strong> ( <strong class="ih hj"> STFT </strong>)，是一种傅立叶相关变换，用于确定随时间变化的信号局部的正弦频率和相位内容。(维基百科)</p></blockquote><p id="b7ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">hop_length是帧之间的样本数。n_fft是每帧的样本数。我发现当增加n_fft时，结果变得更精确，我将其设置为默认值的4倍。</p><p id="f579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以使用matplotlib查看STFT的结果:</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="c84f" class="le jx hi la b fi lf lg l lh li">librosa.display.specshow(self.spectrogram,<br/>                         y_axis='log', x_axis='time')</span><span id="6a71" class="le jx hi la b fi lj lg l lh li">plt.title('Your title')<br/>plt.colorbar(format='%+2.0f dB')<br/>plt.tight_layout()<br/>plt.show()</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lr"><img src="../Images/d8b1e25a706039fd46b0e94f7fb179ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_IFP5ZR4WykqW_qo1doeoA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">现在你可以看到每个时间和频率的分贝。0db是最大声的。</figcaption></figure><p id="4417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用索引来访问数组的值。但是我们应该根据它的时间和频率来选择值。这段代码可能有所帮助:</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="2509" class="le jx hi la b fi lf lg l lh li">frequencies = librosa.core.fft_frequencies(n_fft=2048*4)  # getting an array of frequencies</span><span id="f621" class="le jx hi la b fi lj lg l lh li"># getting an array of time periodic<br/>times = librosa.core.frames_to_time(np.arange(self.spectrogram.shape[1]), sr=sample_rate, hop_length=512, n_fft=2048*4)</span><span id="143f" class="le jx hi la b fi lj lg l lh li">self.time_index_ratio = len(times)/times[len(times) - 1]</span><span id="87fc" class="le jx hi la b fi lj lg l lh li">self.frequencies_index_ratio = len(frequencies)/frequencies[len(frequencies)-1]</span></pre><p id="5caa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我把二维数组分成几个数组，这些数组表示某些索引的时间或频率。采样率是恒定的。因此，我们可以在时间和指数之间建立一个比率，频率也是如此。然后，我们把时间和频率乘以比率，我们得到指数:</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="531b" class="le jx hi la b fi lf lg l lh li">def get_decibel(self, target_time, freq):</span><span id="a695" class="le jx hi la b fi lj lg l lh li">return spectrogram[int(freq*frequencies_index_ratio)][int(target_time*self.time_index_ratio)]</span></pre><p id="c8dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需要用我在开始提到的“移动条”来表示它。</p><p id="fc06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个代表我们的频率栏的类:</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="9eac" class="le jx hi la b fi lf lg l lh li">class AudioBar:</span><span id="ad61" class="le jx hi la b fi lj lg l lh li">def __init__(self, x, y, freq, color, width=50, min_height=10, max_height=100, min_decibel=-80, max_decibel=0):</span><span id="fe02" class="le jx hi la b fi lj lg l lh li">self.x, self.y, self.freq = x, y, freq</span><span id="006e" class="le jx hi la b fi lj lg l lh li">self.color = color</span><span id="a716" class="le jx hi la b fi lj lg l lh li">self.width, self.min_height, self.max_height = width, min_height, max_height</span><span id="24c6" class="le jx hi la b fi lj lg l lh li">self.height = min_height</span><span id="98c1" class="le jx hi la b fi lj lg l lh li">self.min_decibel, self.max_decibel = min_decibel, max_decibel</span><span id="8982" class="le jx hi la b fi lj lg l lh li">self.__decibel_height_ratio = (self.max_height - self.min_height)/(self.max_decibel - self.min_decibel)</span><span id="d37c" class="le jx hi la b fi lj lg l lh li">def update(self, dt, decibel):</span><span id="4570" class="le jx hi la b fi lj lg l lh li">desired_height = decibel * self.__decibel_height_ratio + self.max_height</span><span id="3dc7" class="le jx hi la b fi lj lg l lh li">speed = (desired_height - self.height)/0.1</span><span id="75f4" class="le jx hi la b fi lj lg l lh li">self.height += speed * dt</span><span id="831d" class="le jx hi la b fi lj lg l lh li">self.height = clamp(self.min_height, self.max_height, self.height)</span><span id="b3d4" class="le jx hi la b fi lj lg l lh li">def render(self, screen):</span><span id="a03e" class="le jx hi la b fi lj lg l lh li">pygame.draw.rect(screen, self.color, (self.x, self.y + self.max_height - self.height, self.width, self.height))</span></pre><p id="f76a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了x，y坐标，条形的频率，颜色，以及高度和分贝的范围。我定义了一个高度和分贝之间的比率，以确定后来酒吧的高度。在update()方法中，我获得了与当前分贝相对应的期望的条形高度，并设置了条形增长的速度。</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="32cd" class="le jx hi la b fi lf lg l lh li">bars = []<br/>frequencies = np.arange(100, 8000, 100)</span><span id="373e" class="le jx hi la b fi lj lg l lh li">for c in frequencies:<br/>    bars.append(AudioBar(x, 300, c, (255, 0, 0), max_height=400, width=width))<br/>    x += width</span></pre><p id="6499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我创建了一个数组来保存条形。我创建了80个从100Hz到8000Hz的小节，步长为100，并将它们添加到数组中。</p><p id="1292" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您只需运行一个Pygame窗口并绘制条形图:</p><pre class="jd je jf jg fd kz la lb lc aw ld bi"><span id="04f1" class="le jx hi la b fi lf lg l lh li">t = pygame.time.get_ticks()<br/>getTicksLastFrame = t</span><span id="a517" class="le jx hi la b fi lj lg l lh li">pygame.mixer.music.load(filename)<br/>pygame.mixer.music.play(0)</span><span id="7c6a" class="le jx hi la b fi lj lg l lh li"># Run until the user asks to quit<br/>running = True<br/>while running:</span><span id="75c2" class="le jx hi la b fi lj lg l lh li">t = pygame.time.get_ticks()<br/>    deltaTime = (t - getTicksLastFrame) / 1000.0<br/>    getTicksLastFrame = t</span><span id="bbe0" class="le jx hi la b fi lj lg l lh li"># Did the user click the window close button?<br/>    for event in pygame.event.get():<br/>        if event.type == pygame.QUIT:<br/>            running = False</span><span id="84cc" class="le jx hi la b fi lj lg l lh li"># Fill the background with white<br/>    screen.fill((255, 255, 255))</span><span id="6056" class="le jx hi la b fi lj lg l lh li">for b in bars:<br/>        b.update(deltaTime, get_decibel(pygame.mixer.music.get_pos()/1000.0, b.freq))<br/>        b.render(screen)</span><span id="89cd" class="le jx hi la b fi lj lg l lh li"># Flip the display<br/>    pygame.display.flip()</span><span id="68d2" class="le jx hi la b fi lj lg l lh li"># Done! Time to quit.<br/>pygame.quit()</span></pre><p id="1c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我还使用pygame.mixer来播放音乐，并使用pygame.mixer.music.get_pos()来访问时间</p><p id="01ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你做了一个音乐可视化工具！你可以在这里找到完整的代码:<a class="ae jo" href="https://gitlab.com/avirzayev/medium-audio-visualizer-code/-/blob/master/main.py" rel="noopener ugc nofollow" target="_blank">https://git lab . com/avirzayev/medium-audio-visualizer-code/-/blob/master/main . py</a></p><h1 id="997e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">扩展您的项目</h1><p id="0c59" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">本文介绍了创建简单音乐可视化工具的基础知识。您可以使用这个小例子来创建令人惊叹的可视化工具。</p><p id="963f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，通过用类包装代码来简化代码。创建一个用于音频分析的类会使代码更整洁，并帮助您避免再次编写相同的代码。</p><p id="53bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，你可以尝试用另一种方式来可视化你的代码。你可以把它们排成一个圆圈，而不是画一排横条。您还可以创建一些影响可视化工具外观的触发器。例如，您可以创建一个低音触发器，当有一定量的低音时，您可以让条形改变颜色。</p><p id="5438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，你可以创建奇妙的可视化工具，你可以用这篇文章来指导你。编码快乐！</p></div></div>    
</body>
</html>