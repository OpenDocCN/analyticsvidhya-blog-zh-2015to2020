<html>
<head>
<title>Types of activation functions in Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习中激活函数的类型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/types-of-activation-functions-in-deep-learning-6c9d4ede6186?source=collection_archive---------18-----------------------#2020-11-22">https://medium.com/analytics-vidhya/types-of-activation-functions-in-deep-learning-6c9d4ede6186?source=collection_archive---------18-----------------------#2020-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在制作深度学习模型时，我们通常需要考虑深度学习的各个方面。选择正确的层数、激活函数、历元数、损失函数、优化器等等。</p><p id="efbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在为我的一个项目重温这些概念，所以我决定写一下我们使用的不同的激活函数。</p><h1 id="693f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">那么激活功能有什么用呢？</h1><p id="2498" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">那么，为什么我们甚至使用激活函数，而不是直接将求和结果提供给下一层。</p><p id="68b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们这样做，问题将是神经网络层不能随着时间的推移学习复杂的功能。激活功能为模型增加了非线性。这有助于它学习复杂的函数。通过对从层的权重获得的值使用激活函数来计算发送到下一层的特定节点处的结果。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/4d126fcda6ab42f50876dae0e1ab3436.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*KLqNf2RPUYelZ8uzMbN6Hg.png"/></div></figure><p id="9433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上图所示，每个神经元都要做<strong class="ih hj">两个计算</strong>。首先对前几层的权重求和，然后计算激活函数。</p><p id="6158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我想我们知道为什么激活功能如此必要了。</p><p id="02bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来看看几个激活函数。</p><h1 id="a105" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak"> 1。乙状结肠</strong></h1><p id="6303" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是我们做二元分类时最常用的激活函数之一。该函数给定为:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ko"><img src="../Images/b4c6e59eaae5b229e3bfd00cd6272a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*zbU8FKOG-B2E2t2IkW6WOw.png"/></div></figure><p id="6bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数的值在 0 到 1 之间。为了了解这些值是如何分布的，我们可以画出这个函数</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kp"><img src="../Images/40bb4c0becfba4d3ab06feb6a26eaf18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*90uAwbkslvcqFR_U9-816w.png"/></div></figure><p id="02be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在反向传播过程中，借助导数的链式法则更新权值。这给 sigmoid 函数带来了一个问题，因为函数的导数的<strong class="ih hj">值的范围是从 0 到 0.25。</strong>因为值很小，所以如果我们在深度神经网络中使用 sigmoid 函数，我们可能会面临消失梯度的<strong class="ih hj">问题。</strong></p><p id="9258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是消失渐变？</strong></p><p id="0a22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用链式法则更新权重。但是在深度学习中有一个问题。如果函数的导数非常小，则被更新的权重变化非常小。这使得训练非常慢，因为训练都是关于更新权重以便它们收敛。</p><p id="b5df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我举一个小例子来说明直觉。假设我们正在从输出端更新第四个隐藏层。由于我们使用的是链式法则，我们将乘以前几层的导数。假设导数分别是 0.14，0.07，0.001。现在，如果我们将它们相乘，我们会得到值 0.0000098。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kq"><img src="../Images/f24bdc0745e1a39ddf5f19b69a6e15a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*iY-PsKgp1Ntzmg1Ij_h5pA.png"/></div></figure><p id="2110" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，该值是将用于更新权重的δWt。该值将带来非常小的变化，并且随着层数的增加而不断增加，因此命名为<strong class="ih hj">消失梯度。</strong></p><p id="11a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所以乙状结肠的使用通常仅限于二进制分类的输出。</strong></p><h1 id="9b4b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.谭双曲线</h1><p id="628f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">tan 双曲线或 tan h 在某些性质上类似于乙状结肠。该函数如下所示:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kr"><img src="../Images/caa3ba77b5dff9f97a6d7ef0fd7acd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*7qPyhETKG6fUv3_f40OzQQ.png"/></div></figure><p id="0766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数的值介于 1 到-1 之间。分布如下所示</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ks"><img src="../Images/74daa600d48145bb7e141823a22674b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*vDIPgYYHwtynBx1-U1hkzg.png"/></div></figure><p id="dfb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数的形状有点类似于 sigmoid，但其范围不是从 0 到 1，而是从-1 到 1，这使得它比 sigmoid 更有优势，因为它变成零中心。以零为中心的函数比以零为中心的函数收敛得更快。尽管如此，它仍然面临着像乙状结肠一样的渐变消失的问题。</p><h1 id="05b9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.ReLU</h1><p id="c0c1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">2010 年 Geoffery Hinton 和 Nair 推广了 ReLU 功能。它是最常用的激活功能之一。它简单地表示为:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kt"><img src="../Images/a2beee9490e3daffc301e709d5a43540.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*-iasTguHWg3ZILL62tPoQg.png"/></div></figure><p id="74c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于大于 0 的值，它是变量本身的值，当变量的值小于 0 时，它变为 0。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ku"><img src="../Images/d176fe9e14e32e109b04fe37e74a6cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*FtGYLjnpatB2LdpD36DNjQ.png"/></div></figure><p id="87dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数在很大程度上解决了渐变消失的问题，因为对于所有大于 0 的值，该函数的导数都是 1。但是这里有一个问题。对于小于 0 的值，它将变为 0。因此，对于值小于 0 的图层，该值变为 0，并且由于我们借助链规则更新值，我们有时会发现<strong class="ih hj">的权重根本没有更新的情况，因为应用时的乘积变为 0。</strong></p><p id="2c38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这个问题叫做神经元死亡</strong>。这是因为在这种情况下，神经元无法执行其任务。因此，有相当多的即兴版本。</p><p id="9771" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导数如下图所示:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kv"><img src="../Images/ccc267c5afa9a1166237b4fcb5d74600.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*p6fMXzgO5HMoo501IOsHgw.png"/></div></figure><p id="ddc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来讨论 ReLU 函数的一些临时版本</p><h1 id="00a2" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4.泄漏 ReLU</h1><p id="01fb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">ReLU 函数面临神经元死亡的问题。泄漏 ReLU 通过稍微重新定义功能来克服这个缺点。</p><p id="0afa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数可表示为</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/6e31db01fa9972a6539f6982c131f473.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*oSZwgCx1Uv_fpzHRKSQ65g.png"/></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/711e7f45541394b23211f73a6ad88644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1rV1aorDonrMSVNj4UxJQ.png"/></div></div></figure><p id="46bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左边是普通的 ReLU 函数，右边是泄漏的 ReLU 函数。图中“a”的值很小，可以防止函数的导数变成 0。因此，这就避免了我们在 ReLU 中遇到的神经元死亡的问题。</p><p id="3438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但我们又有一个问题。假设在一个非常深的网络中，有许多导数的值小于 0。我们现在再次面临渐变消失的问题。虽然与棕褐色双曲线和乙状结肠相比，它不那么严重，但它仍然会使训练变慢。</p><p id="b7e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们有另一种高级形式的泄漏 ReLU。</p><h1 id="6125" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">5.参数 ReLU</h1><p id="70ed" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这个函数与泄漏的 ReLU 非常相似，但是这里当变量为负时，函数的系数不是常数，而是一个可学习的参数。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lc"><img src="../Images/377eb17f45ebc994db4337fe7c4ca379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*K0NaFL7CjMkF-P1Fm7M9wA.png"/></div></figure><p id="1c34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左边是 ReLU 函数，中间是泄漏 ReLU，右边是参数 ReLU。不要混淆，因为此图中的参数 ReLU 与上图中的泄漏 ReLU 相同。在泄漏 ReLU 中，系数是常数，而在参数 ReLU 中，它是可训练的超参数。</p><p id="1ea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为它是一个可训练的参数，所以它比泄漏 ReLU 执行得更好，尽管现在我们有更多的计算要做。</p><h1 id="e4d5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">6.指数线性单位</h1><p id="21bd" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是 ReLU 激活功能的另一个临时版本。与其他形式的 ReLU 一样，它对负值的处理也有所不同。对于正值，上述所有 ReLU 单元执行相同的操作。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ld"><img src="../Images/e1ec2e27913a688b2f818375659ff476.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*k3IpgkyomuIfPZEABytHuw.png"/></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es le"><img src="../Images/ae3a7984b73aaa8754c5ad23b72b1cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*cd6a3sLeKNr2K0MP6s1BGQ.png"/></div></figure><p id="e683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">alpha 值定义了小于 0 的值的曲线。它是一个超参数，其值取决于用例及数据集。</p><h1 id="4d11" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">6.Softmax</h1><p id="135c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">softmax 激活函数定义为</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lf"><img src="../Images/5a2424deceb05abcfc3b13604b029656.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*KF-l2pk_LCKKFW2ru8av3w.png"/></div></figure><p id="756e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它通常用于多类分类问题的输出层。它给出了不同类别的概率。它也可以像 sigmoid 函数一样用于二元分类</p><h1 id="20a0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="8d37" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这些是深度学习中少数几个最常用的激活函数。虽然大多数深度学习框架都实现了这些功能，但最好能知道这些功能是什么，因为有时当我们处理模型问题时，这非常重要。例如，您可能正在尝试进行二进制分类，并且您在输出中使用了 ReLU 层，因为您认为它在任何地方都工作得很好。知道一个激活实际上做了什么可能会让你避免这样的问题。</p><p id="bac5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢</p></div></div>    
</body>
</html>