<html>
<head>
<title>Computer Vision: Segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉:分割</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/computer-vision-segmentation-42ffff0d7d40?source=collection_archive---------11-----------------------#2020-02-02">https://medium.com/analytics-vidhya/computer-vision-segmentation-42ffff0d7d40?source=collection_archive---------11-----------------------#2020-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="862a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天是另一个图像处理算法:<strong class="ih hj">阈值分割。</strong>你们中的许多人都是漫威或DC的超级英雄世界的粉丝。我们来看一个超人的随机场景:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e1e751e78ca648a7301c3600b6a05d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*hohFlCQ-lV7V9o-EWCfUlw.jpeg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">网址:【https://www.pinterest.com/pin/791507703239539817/ T2】</figcaption></figure><p id="f7c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没错。你看到的是CGI技术。在这篇文章中，假设你和我想把超人从场景中分割出来，因为我们喜欢这样。在本文中，让我们通过量化 实现<a class="ae jp" href="https://en.wikipedia.org/wiki/Thresholding_(image_processing)" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">阈值分割超人。</strong></a></p><h1 id="7811" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阈值分割</h1><p id="46b1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">分割</strong>是一种基于多种方法将物体从背景中移除的技术[1]:</p><ul class=""><li id="8abe" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">基于强度的分割:阈值</li><li id="6bd0" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">基于边缘的分割</li><li id="6219" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">基于区域的分割</li></ul><p id="84e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们通过使用<strong class="ih hj">量化对</strong>进行阈值处理来关注<strong class="ih hj">基于亮度的分割。</strong></p><h1 id="68f7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">量化</strong></h1><p id="0b0e" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">是一种基于数学的算法，通过将图像直方图分成总误差方差最小的两半来寻找阈值<strong class="ih hj"><em class="lh"/></strong>【2】。</p><p id="f6d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lh">设p为图片直方图，使p(x)为值为x的像素个数，对于x = 0，…，M，我们在寻找一个阈值t和两个值q1，q2，使得范围0 ≤ x &lt; t内的所有像素用q1代替，范围t ≤ x ≤ M内的所有像素用q2代替。将以下表达式定义为总误差:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/efc6d17b2ab1f94df5c4805b3924fdd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*kwrxXBTlU0v4CegYd11d-w.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">计算总误差方差的公式被阈值分割成两半<strong class="bd js"> t (1) </strong></figcaption></figure><p id="5201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，工作是找到误差方差最小的q1和q2。为了求最小误差E，让我们用微积分I对上述公式求导，求最小误差E的临界值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/80889f9c3ada44d0f5e60f98ee9f0d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*fqjxjqoi58_7Mg0PsM8i0g.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">总误差方差的导数，以找到E的临界值</figcaption></figure><p id="9d34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，将上面的公式设置为0，求解q1和q2(记住如何在极值点找到临界值)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/4abde528ab40bd7c6e25286ab304d741.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*inPA0oLoXq20yRGfGHnGaw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">求q1和q2误差E最小的公式(2)</figcaption></figure><blockquote class="lp lq lr"><p id="6ae4" class="if ig lh ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated">如果不记得微积分或线性代数，最好复习一下，因为微积分和线性代数在许多领域都非常重要，尤其是计算机视觉和机器学习(紧随其后的是情侣CV系列)。</p></blockquote><p id="7d88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是所有的数学和理论。接下来是我最喜欢的部分，编码和运行</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="5b48" class="jq jr hi bd js jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn bi translated">伪代码</h1><p id="c3ce" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">对于对应于图像直方图中颜色的每个给定阈值<strong class="ih hj"> <em class="lh"> t </em> </strong>，</p><ul class=""><li id="ba1f" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">基于公式(2)计算q1和q2，它们是两个段的峰值</li><li id="1168" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">基于公式(1)计算由每个给定阈值<em class="lh"> t </em>分离的两个片段的总方差</li><li id="b9dd" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">找到两个分段的总最小方差，以便找到最佳阈值<strong class="ih hj"> <em class="lh"> t </em> </strong></li></ul><p id="2154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于最优阈值分割图像<strong class="ih hj"> <em class="lh"> t </em> </strong></p><h1 id="2436" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">让我们编码</h1><p id="5e12" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">首先，我计算图像直方图，并用它来寻找最佳阈值。得到最佳阈值后，我将2个片段保存到2个图像中。</p><p id="bacb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到q1和q2，我声明了4个变量来保存q1和q2的分子和分母，如公式(2)所示。这样做是为了减少for循环期间每个阈值的计算工作。</p><p id="2d33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个计算的总误差方差，寻找总最小方差以找到最佳阈值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4391" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们结合一切！</p><pre class="je jf jg jh fd mj mk ml mm aw mn bi"><span id="2d74" class="mo jr hi mk b fi mp mq l mr ms">#read images<br/>img = cv2.imread(os.path.join(test_folder_path, img_name), 0)</span><span id="bc83" class="mo jr hi mk b fi mt mq l mr ms">#segment images front and back<br/>front_img, back_img = MoCV.segmentation.optimal_thresholding(img)</span><span id="b3b4" class="mo jr hi mk b fi mt mq l mr ms">#directory paths to save front and backgrounds<br/>front_img_path = os.path.join(test_folder_path, "front_segmented_img.png")back_img_path = os.path.join(test_folder_path, "back_segmented_img.png")</span><span id="f48e" class="mo jr hi mk b fi mt mq l mr ms">#write front and back images<br/>cv2.imwrite(front_img_path, front_img)cv2.imwrite(back_img_path, back_img)</span></pre><p id="0b9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到保存分割图像的目录进行查看。以下是分段示例。前面在左边；背景在右边。</p><h1 id="2d3d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结果</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mu"><img src="../Images/430e03589e9c3ed6c47a9bbbd8b7bae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*lRxcTSvHxYmDBE66NgSEiQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><strong class="bd js">原始图像</strong></figcaption></figure><div class="je jf jg jh fd ab cb"><figure class="mv ji mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><img src="../Images/0ace02cbd3f8a2ff484a2ef435936006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*EsFgA7ZxxHcEXwr_OFplIg.png"/></div></figure><figure class="mv ji mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><img src="../Images/b241c261a4a9530db5212edad86fe14c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*aUkfw7R7PSXGw-7yhW5FBQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx nb di nc nd translated"><strong class="bd js">前后接地</strong></figcaption></figure></div><p id="9d58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，这就是如何分割前景和背景的强度为基础的阈值分割。如你所见，按颜色分段不是最好的选择；基于边缘的更好算法。但是，我的目标仍然是向你们展示容易理解的算法。</p><p id="bb61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有源代码均可在此处获得:</p><div class="ne nf ez fb ng nh"><a href="https://github.com/quocdat32461997/MoCV" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">quocdat32461997/MoCV</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">计算机视觉算法列表:直方图-计算图像直方图直方图均衡-均衡图像…</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jj nh"/></div></div></a></div><h1 id="f607" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><ol class=""><li id="4835" class="kt ku hi ih b ii ko im kp iq nw iu nx iy ny jc nz kz la lb bi translated">图像分割，<a class="ae jp" href="https://www.ece.uvic.ca/~aalbu/computer%20vision%202009/Lecture%209.%20Segmentation-Thresholding.pdf" rel="noopener ugc nofollow" target="_blank">https://www . ECE . uvic . ca/~ aalbu/computer % 20 vision % 202009/Lecture % 209。% 20 segmentation-thresholding . pdf</a></li><li id="5c8b" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc nz kz la lb bi translated"><em class="lh"> Crystal Maung，Quantization </em>，<a class="ae jp" href="https://elearning.utdallas.edu/bbcswebdav/pid-3025155-dt-content-rid-79956708_1/courses/2202-UTDAL-CS-4391-SEC001-24310/Optimal-Thresholding.pdf" rel="noopener ugc nofollow" target="_blank">https://elearning . ut Dallas . edu/bbcswebdav/PID-3025155-dt-content-rid-79956708 _ 1/courses/2202-ut dal-CS-4391-sec 001-24310/Optimal-thresholding . pdf</a></li></ol></div></div>    
</body>
</html>