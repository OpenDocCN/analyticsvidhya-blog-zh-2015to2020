<html>
<head>
<title>Sparse Matrix-Vector Multiplication with CUDA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于CUDA的稀疏矩阵向量乘法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sparse-matrix-vector-multiplication-with-cuda-42d191878e8f?source=collection_archive---------1-----------------------#2019-11-16">https://medium.com/analytics-vidhya/sparse-matrix-vector-multiplication-with-cuda-42d191878e8f?source=collection_archive---------1-----------------------#2019-11-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5ca99b4afec0b6647cce11f0e38f87aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNG8u1JWQAUc20yncheeYw.png"/></div></div></figure><h1 id="2c95" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">简介</strong></h1><p id="db69" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">微分方程离散化的标准方法通常导致线性方程组。产生式系统的一般特征是每个方程中的条目数取决于离散化的局部拓扑特征。因此，这些系统生成的矩阵包含许多零(图1)。通过将矩阵存储在特殊的数据结构中，可以利用关于零的位置的知识。这些结构的抽象数据类型称为稀疏矩阵。当我阅读另一种矩阵格式时，我决定实现不同矩阵格式的性能比较。这篇文章回顾了基本稀疏矩阵数据结构在GPU上的稀疏矩阵向量乘法(SpMV)环境中的效率。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/b7ac8ce045b62d236ba49a876effab6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BN9FVKqtXLYVlWtYA90Y1w.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图1:一个简单的有限元网格模型</figcaption></figure><h1 id="5c62" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">稀疏矩阵的数据结构</strong></h1><p id="07ca" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一般来说，SpMV性能受到内存带宽的限制。用于稀疏矩阵的存储格式定义了SpMV算法。每种算法都有自己的粒度，这会影响性能。稀疏矩阵表示之间的主要区别是稀疏模式，或者非零项的结构，这是它们最适合的。然而，我将从一般的稀疏矩阵格式开始。</p><p id="79bf" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">为了评估SpMV在不同稀疏矩阵格式上的效率，我从Florida Sparse Matrix Collection收集了一般矩阵的性能数据。所有的实验都是在一个配有NVIDIA RTX 2080 GPU和英特尔酷睿i7–7700k CPU的系统上运行的。每个测量值是30次试验的平均值(算术平均值)。在测量性能之前，CPU和GPU频率都是固定的。<br/>通过将单线程CSR SpMV执行时间除以GPU来计算加速比。</p><h1 id="37d5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> CSR </strong></h1><p id="f583" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="la">压缩稀疏行</em> (CSR)格式是一种通用的稀疏矩阵格式。CSR格式由三个数组组成:<em class="la"> row_ptr </em>，非零的<em class="la">列</em>，矩阵<em class="la">值</em>(图2)。该行的非零值按顺序存储在一维<em class="la">值</em>数组中。<em class="la"> row_ptr </em>数组用于将值数组分成单独的行。它的大小等于n_rows + 1。row_ptr中的最后一个条目存储矩阵中的多个非零值(nnz)。这允许快速查询特定行中的非零数字<em class="la">(row _ ptr[row+1]—row _ ptr[row])</em>。对于每个非零值，列索引存储在列数组中。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/3d603616f282fd2ffe0a6c750f820ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fe_zlWwtypsgwF8PF2batQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图2:压缩稀疏行(CSR)矩阵格式示例</figcaption></figure><p id="75d9" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">为了简单起见，我们假设每个CUDA线程块中有四个线程。一般的CSR SpMV实现在每行线程的粒度上工作(图3)。因此，图2中的矩阵由三个线程块处理。这种实现通常被称为CSR-Scalar(列表。1).</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/43664dfdfe8ee5fde851d497496feeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MnuDkJJ7mUQq9eNLbUKrg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图3:CSR-标量工作分布</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/3aa962a90600d2ee2740be9aa9b37cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zD9HHFeTbKcXxQWEKM5Quw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单CSR标量稀疏矩阵格式的朴素SpMV核</figcaption></figure><p id="c31d" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">CSR SpMV算法在GPU上的实现通常被认为是非常低效的。低效率的原因是负载平衡、线程分歧和内存访问模式。如图<br/> 3所示，只有一半的块线程有非零线程要处理。因此，当所有其他内核空闲时，单个密集行可以任意延迟执行。此外，如图3所示，相邻线程以步进方式访问矩阵<br/>的值。当并发线程同时访问物理内存中相距甚远的内存地址时，硬件就没有机会组合这些访问。表1给出了简单CSR-Scalar实现的性能结果<br/>。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/38a6466ced7046350ad6ffd81966d257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouM6D4nm5lIRxc1TTfWFJg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表1:CSR-标量加速</figcaption></figure><p id="b9f7" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">加速分布如下图所示。为了回答这个问题，我将它与NVIDIA CUDA稀疏矩阵库(cuSPARSE)的CSR实现进行了比较。2)，平均加速比更好。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/89dbfe29099daa12ccc7c64250c92d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EH5KGAhyke9nz4TPdJ9tIg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表2: CSR (cuSPARSE)加速</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/0cd8f2e803ac5fd3fc991fdc34f318da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOuKQNUB6mQjgYEBWUPliw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图4(a):CSR-标量加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/e918d41f91fa4fef6437135f7cab717f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-FPKH4_cAzfdxdfc2uXYg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图4(b):CSR-标量加速(双倍)</figcaption></figure><p id="4a49" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">这些结果表明，中国南车SpMV公司还有优化的空间。第一个可能的优化是指定每行的经线，而不是线程。这个算法(列表。3)称为CSR-Vector。向量内核连续访问索引和数据(图4)，因此克服了<br/>标量方法的主要缺陷。与之前每个矩阵行使用一个线程的CSR实现不同，这种优化需要在同一warp中的线程之间进行协调。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/e3d49d34581223c031146178d0f08e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbaU6UMabSzdJYXrQeG04g.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">CSR cuSPARSE加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/0ee54ec733354bc2eb63fe4f59cc4bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XS3Rr4OhKEK-PIj6eWd8tw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">CSR cuSPARSE加速(双倍)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/03a4a0feda0dfe31a954e916018cf1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5pihObjoo7vgXmVZFO5RQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图4:CSR-向量工作分布</figcaption></figure><p id="758f" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">在CSR的情况下，向量减少可以使用扭曲级别的图元(列表。2).在这种情况下，数据交换在寄存器之间执行，比通过共享内存更有效，共享内存需要加载、存储和额外的寄存器来保存地址。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/335b35129c89ab1d745e10ab8bf3cd54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CI94iq8qUARyhLCehZwKgA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单2:扭曲减少</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/27b971b3b9b61aaaafff71bdebc58f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMCcSZLfqrZykwcfwnu21Q.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单CSR向量的SpMV内核</figcaption></figure><p id="791e" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">CSR-Vector具有更好的加速比(表。4)以及比CSR-Scalar(对于浮点和double矩阵)和cuSPARSE实现(对于浮点矩阵)更快的分布。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/2147859ded2e7189f0eb9a6cdae836e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMSPNe6biwynp0wD289pdA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表3: CSR矢量加速</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/985da9a062130bed3e6e20282a5b80b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBJO6y4EMfy-wEqQUY657A.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">CSR-矢量加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/843c7007b7c22990d3f06949d734091c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDaMXGGj2pK2Bd6MiM0DiA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">CSR-矢量加速(双倍)</figcaption></figure><p id="32a0" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">然而，在大约33%的下限为10000 nnz的浮点矩阵和40%的下限为100000 nnz的浮点矩阵上，CSR-Scalar优于CSR-Vector。在这些矩阵上，CSR显示平均加速比为8.57，而CSR-Vector仅为4.80。</p><p id="f4f8" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">为了发现CSR SpMV实施的进一步改进，我们需要考虑图2的第一个矩阵部分。在矩阵的前四行中，每行只有一个非零值。在这种情况下，除了第一根经纱外，所有经纱都是空闲的。在这种情况下，天真的CSR SpMV实现有可能胜过矢量实现。对于CSR矩阵格式，有一种不依赖于nnz/row比率的SpMV算法。CSR-Adaptive根据每行(列表)中的nnz改变其行为。4).在选择每个块的非零值之后，构建用于存储块的行的附加数组(行块)。如果一些行包含小的nnz，它们将被聚集到一个块中。然后CUDA线程块被分配给每个行块。一个行块中有多行的情况称为CSR-Stream。如果行块中只有一行，将调用CSR-Vector。如果该行超过<em class="la"> nnz_per_wg </em>，则将使用CSR-VectorL变量。CSR-Vector和CSR-VectorL的主要区别在于，CSR-VectorL允许在一行上执行多个CSR-VectorL，然后通过使用原子操作来减少结果。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/8e0fc579bd4fb2e494414b729c690030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cS4fUHBfpIUmfFBVTk0p-Q.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单CSR自适应稀疏矩阵格式的SpMV内核</figcaption></figure><p id="c1a5" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">CSR-Vector和CSR-VectorL部分非常相似，所以我不会在这里列出。图5说明了CSR流部分的存储器访问模式。它将部分和存储在GPU的共享内存中，然后将它们减少。图5中缓存的部分结果是用x填充1计算的。CSR-Stream的<br/>源代码如清单5所示。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/c8488df12309d835383f0285c2029aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2n8HXiJDEDfDZGSXSvOVzA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图5: CSR流内存访问模式</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/62a7557e1532fd0c58f748cf7b74e545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJPDWpdT7Lfk9z-VeWoXIw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单5: CSR流实现</figcaption></figure><p id="7f41" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">在讨论的矩阵集上，CSR优于CSR-Vector，CSR-Adaptive显示了更好的加速比。在这291个矩阵上，CSR-Adaptive优于CSR-Scalar。虽然CSR-Adaptive在一些长行矩阵上的性能可能优于CSR-Vector，但它平均具有更好的加速比。4).CSR-Adaptive的主要优点是，如果您的代码已经使用了CSR，您就不需要更改生成矩阵的代码。下面介绍的矩阵格式不具备这种品质。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/a0bfba693f7101c68e8620bd0cc6f591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gz1pj5JLDEHg2VPXk3mizg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表4: CSR自适应加速</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/c2250a5826d96f33025f3bc857f525ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0r9x1qLhLV7de_Dx4vRfQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">CSR-自适应加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/7e67e90bc318037cedacf608ab92580f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F95zSZXrWGbgyhEhgyCI_A.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">CSR-自适应加速(双倍)</figcaption></figure><h1 id="136c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">埃尔</strong></h1><p id="3966" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">CSR的非聚集存储器访问问题可以通过对稀疏矩阵数据应用数据填充和转置来解决(图6)。Ellpack-Itpack (ELL)稀疏矩阵格式假设每行最多包含rows中的元素，rows中的元素很少。所有行都以零填充到该值。与CSR不同，不需要行指针数组。当每行非零值的最大数量与平均值相差不大时，ELL效率最高。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/9df635e07acf8661e65cb1bf665cbecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yEY96IWgjfiktbjAiXkmQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图ELL矩阵格式示例</figcaption></figure><p id="6885" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">清单6给出了ELL矩阵格式的内核。使用ELL格式的元素填充，很容易通过简单地添加矩阵中的行数来获得下一行的元素位置。填充还会固定每个线程的迭代次数，因此扭曲中没有控制流分歧。控制流发散的消除和内存合并的启用使得ELL SpMV内核在许多矩阵上的性能优于CSR标量实现(表。5).</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/ccd5e0f9cbe8c2e97a765f1dc9965a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S07uZhDmBq1bPfTAqqZTgg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单6: ELL实现</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/8461d6726056c9beb707c30faab2ba9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uiimd67D30YHhwqxYLkFdg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表5: ELL加速</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/88a7d3be593b07d019c1c5f5cd28b704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vACOn27eL2G6yQN1PGs0xQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">ELL加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/0156efc0e39d1681d96edde8943cd9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHk3Nx2tAkri-QZHgd-wyQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">ELL加速(双倍)</figcaption></figure><p id="7e8b" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">ELL格式的明显缺点包括填充本身。在矩阵有几个长行的情况下，ELL格式将导致过多的填充元素。佛罗里达收集了许多矩阵，由于ELL的填充，这些矩阵无法放入我的8GB GPU中。在某些情况下，这会导致CSR-Scalar优于ELL实现的情况。为了消除这个问题，可以将长行的额外nnz从ELL矩阵中移除到不同的矩阵中。值得注意的是，提取的矩阵会有一个无序的方案。该方案中可能会缺少许多行，因此CSR的使用将是低效的。可以处理这种情况的格式之一是首席运营官。</p><h1 id="3184" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">首席运营官</strong></h1><p id="0d37" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">坐标(首席运营官)矩阵格式是最简单的一种。对于每个NZ，它存储它的列和行索引。因此，首席运营官不按行映射元素。这就引出了首席运营官内核中原子操作的必要性(清单7)。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/8f9c1740c874fc348ad9915429f86d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qherxny0c240mxB9LOAizg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单7:首席运营官实现</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/60d4596eaeb1e913c61efe8fea7be026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qMhuRNHe3oz1n1QI8mu9Q.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表6:首席运营官加速</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/4761c396d47fcec67d491b76b4c994a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*is6RdAwYJ38JQLjIf8ButA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">首席运营官加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/02e831b9f0c941abb963f8d2601e5277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hmj1V05cpfdmb_m-UsuO_Q.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">首席运营官加速(双倍)</figcaption></figure><p id="1b06" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">首席运营官SpMV实现在每个元素线程的粒度上工作(7)。对结果向量的原子更新会降低性能。首席运营官格式的行越宽，SpMV的序列化程度越高。这个事实可以在图7中看到。为了提高这种格式的性能，可以用适合共享内存的行数来分割矩阵信息块。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/7ef8bb49ddd76a3be29329927e677e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwwCBqovTRybhcCRuBEsqg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">图7:首席运营官加速对平均nnz的依赖</figcaption></figure><p id="73b6" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">在首席运营官SpMV使用共享内存来提高原子操作性能的矩阵格式被称为分片首席运营官(SCOO)。为了减少共享存储器组冲突，SCOO允许共享存储器中的多个通道用于更新单行的中间结果。减小切片大小会增加通道的大小，从而有更多的共享内存通道可用。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/2964a302146fa309dc4f0671ff7baf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BG1rZtNOzDkLji43dPywZA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表7: SCOO加速</figcaption></figure><h1 id="b9cc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">杂交</strong></h1><p id="a254" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">可以对矩阵的常规部分使用ELL矩阵格式，对从超长行中移除的元素使用首席运营官。该方案显著减少了ELL格式中填充元素的数量。这种<br/>方法通常被称为混合。将厄尔和首席运营官·SpMV的结果结合起来有不同的选择。在这篇文章中，我使用原子案例(列表。8).</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/15a428d4be5a8214e5886deb6d076496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ls83UAxKqMSJ0OpYHf3HxA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">清单8:混合实现</figcaption></figure><p id="dc29" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">尽管平均性能结果(表。8)非常接近CSR自适应SpMV，混合格式需要对分裂矩阵的额外操作，这可能需要重写矩阵计算代码库。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/be95a36201eb98cb1cac76b2ecf62efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQ669KZk5j81zyNssOfsDA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表8:混合加速</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/025769435f229b166bc3b8116903f2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZzYsOg6YbGhdEC0GBjxjuw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">混合加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/e23bb888aae440a7e867fe963d10a521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlKRFUQQkyYOlGlPl6Fyog.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">混合加速(双倍)</figcaption></figure><h1 id="352d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">结论</strong></h1><p id="7fd9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">最后，我想给你看一些误导性的结果。我选择了一些矩阵(表。9)为了表明不存在通用矩阵格式的明显事实。即使在数据类型改变后，引出线也会改变。在我的下一篇文章中，我将重点关注实际应用程序生成的块矩阵格式。这篇文章的源代码和pdf版本可以在<a class="ae mf" href="https://github.com/senior-zero/matrix_format_performance" rel="noopener ugc nofollow" target="_blank"> github </a>中找到。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/e95c673990f2ab086ec3e90899ffac00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3_o7pFGxvwYcp0h9IGCqA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">表9:选定矩阵的结构</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/6e4c1429713f5fa4664feaf877b4b0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJqV4jVSPz_b5Q7k89JcHg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">所选矩阵的加速(浮点)</figcaption></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/50e052e5a2bed556a733e37965a21be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6hToQ_FY1Y4yWUWYJAuvg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">所选矩阵的加速(双倍)</figcaption></figure></div></div>    
</body>
</html>