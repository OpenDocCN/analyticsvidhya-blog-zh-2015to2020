<html>
<head>
<title>Color Separation in an Image using KMeans Clustering using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python使用KMeans聚类在图像中进行颜色分离</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/color-separation-in-an-image-using-kmeans-clustering-using-python-f994fa398454?source=collection_archive---------1-----------------------#2020-05-21">https://medium.com/analytics-vidhya/color-separation-in-an-image-using-kmeans-clustering-using-python-f994fa398454?source=collection_archive---------1-----------------------#2020-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dc99b33022fb3f7155c2183d0d91827d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lGvIkAYHs8MSzt8Z.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用机器学习(KMeans聚类)在图像中分色</figcaption></figure><p id="bbc5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">图像中的颜色分离是分离图像中的颜色的过程。这个过程是通过KMeans聚类算法完成的。K-means聚类是最简单和最流行的无监督机器学习算法之一。K-means算法识别<em class="js"> k </em>个质心，然后将每个数据点分配到最近的聚类，同时保持质心尽可能小。K-means中的<em class="js">表示</em>是指数据的平均；也就是求质心。</p><h1 id="5f5d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">图像分色:-</h1><p id="062e" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">我们将对RGB图像的像素强度进行聚类。给定一个<em class="js"> MXN </em>大小的图像，我们因此有<em class="js"> MxN </em>个像素，每个像素由三个分量组成:分别是红色、绿色和蓝色。我们将把这些<em class="js"> MxN </em>像素作为我们的数据点，并使用k-means对它们进行聚类。属于给定聚类的像素在颜色上比属于单独聚类的像素更相似。k-means的一个注意事项是，我们需要提前 指定我们想要生成的<strong class="iw hj"> <em class="js">的聚类数。</em></strong></p><p id="f3d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我通过考虑下图来演示这种方法。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/a198a12a2c99baa7a0cbf4e8518f19e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0H0kimGTkqoeLQvbrDPpw.jpeg"/></div></div></figure><ol class=""><li id="3a83" class="lb lc hi iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated"><strong class="iw hj">导入库:- </strong></li></ol><p id="e295" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们需要从sklearn集群库和其他一些库中导入基本库，如NumPy、pandas、matplotlib、OpenCV和Kmeans模块。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="b6eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.<strong class="iw hj">加载图像:- </strong></p><p id="e3d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要加载图像，并使用OpenCV将图像转换成图像数组。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="5ea4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述代码的输出是如下所示的图像:-</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/999bf499ddd36f73b7159d74bc73d1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*-1S2a6UZgOZT9MLihM0eQg.png"/></div></div></figure><p id="2e3c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.<strong class="iw hj">从BGR转换到RGB:- </strong></p><p id="b505" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一般来说，当我们通过OpenCV读取图像时，它读取的是BGR格式。所以我们需要把它从BGR转换成RGB。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="bedd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图显示了BGR和转换后的RGB图像。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/ac38438627270e71a1e2e442df7ad28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*IWncNKAKr8bkus2n.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">左图是BGR格式的图像，右图是RGB格式的转换图像。</figcaption></figure><p id="248f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.<strong class="iw hj">重塑形象:- </strong></p><p id="0955" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要一个RGB像素强度来聚类。如果图像包含MXN像素，那么图像的形状是(M，N，3 ),所以我们将图像阵列整形为(M*N，3)形状。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1a73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">5.<strong class="iw hj">实现KMeans算法:- </strong></p><p id="de74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们可以确定聚类的数量，或者可以使用肘点来找到。为了简单起见，首先我们将聚类的数量固定为5，并拟合图像。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="8678" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">6.<strong class="iw hj">确定标签:- </strong></p><p id="0c06" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">训练过程结束了。现在我们需要确定每个RGB像素强度的标签。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="0a0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出是:-</p><pre class="kx ky kz la fd lo lp lq lr aw ls bi"><span id="8562" class="lt ju hi lp b fi lu lv l lw lx">array([2, 2, 2, ..., 2, 2, 2], dtype=int32)</span></pre><p id="9f33" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">7.<strong class="iw hj">确定群集的质心:- </strong></p><p id="abcb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要为RGB像素强度确定聚类的质心。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="9ea8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述代码的输出是</p><pre class="kx ky kz la fd lo lp lq lr aw ls bi"><span id="4317" class="lt ju hi lp b fi lu lv l lw lx">array([[  4.94156198, 194.05106194,   5.66103601],[  0.99513509,   1.17261867, 159.92115244],[  6.9601887 ,   4.80056827, 11.83784188],[162.89434822,   0.61579429,   0.99808952],[  0.9943044 ,  104.50070668,   1.50686636]])</span></pre><p id="648c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">8.<strong class="iw hj">计算百分比:- </strong></p><p id="f637" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要计算每个集群的百分比。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="bf04" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述代码的输出是:-</p><pre class="kx ky kz la fd lo lp lq lr aw ls bi"><span id="215a" class="lt ju hi lp b fi lu lv l lw lx">[0.11026111111111112,  0.2055537037037037,  0.42694444444444446,  0.12552592592592593,  0.1317148148148148]</span></pre><p id="9ac0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">9.<strong class="iw hj">绘制饼图:- </strong></p><p id="67a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们得到了图像中每种颜色的百分比。以下颜色以RGBA格式出现在形心列表中。一般来说，rgba值从0到1，所以我们需要将质心中的每个值除以255，并使用这些百分比和颜色绘制一个饼图。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="e0f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述代码的输出是下面生成的图像:-</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/708ac33d3056767bcd4bb7c54c4f9828.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*bVJ5ygJ2nSxiCz6Uy197PQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像中颜色的分离</figcaption></figure><p id="3a3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们使用KMeans聚类得到了图像中的颜色，这里我们修正了k值。通常为了简单起见，我们约束k，但是有一个通过找到肘点来找到最佳k的过程。</p><h2 id="7c7d" class="lt ju hi bd jv lz ma mb jz mc md me kd jf mf mg kh jj mh mi kl jn mj mk kp ml bi translated"><strong class="ak">肘击法:- </strong></h2><p id="1f78" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated"><strong class="iw hj">肘法</strong>是确定k的最佳值的最流行的方法之一</p><p id="6adf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在定义如下:-</p><p id="3781" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">惯性:</strong>它是样本到它们最近的聚类中心的平方距离之和。</p><p id="7c7f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们从1到n迭代k的值，计算每个k值的失真值，并计算给定范围内每个k值的失真和惯性。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="e064" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述代码的输出是从1到20的每个k值的惯性值。</p><pre class="kx ky kz la fd lo lp lq lr aw ls bi"><span id="5631" class="lt ju hi lp b fi lu lv l lw lx">[13107924711.978294,  8433820366.758524,  4507406394.104001,  1906016765.3226116,  1479036935.644275,  1167644004.3794537,  924556364.7463465,  677398333.8710563,  529621680.23856145,  424009662.682969,  359435146.0253957,  297634711.33955854,  252723281.89632946,  220941246.79365787,  193110661.4033114,  172814060.41467503,  155705229.97394535,  142992728.61409003,  131053276.08425024,  118995898.8872379]</span></pre><p id="2509" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将相对于每个k的惯性值绘制成图表。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="64ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出如下图所示</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/09d30c0bdc222813a159d87093d56e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*GABlqc-4W1hMj-DDz5-Ikg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">查找肘点的绘图</figcaption></figure><p id="3ba7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的图中，从k=4开始，惯性值没有显著变化。所以肘点是k=4。</p><p id="8107" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">考虑k=4的相同示例，并重复该过程。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="97a6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述代码的输出是如下所示的图像:-</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/d4a338dfe483aa07c5c882781fcddc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*DYEpdjbif9lgryxnjQV0sA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用肘形法分离图像中的颜色</figcaption></figure><p id="377f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从而提高了分色的准确性。这样，我们可以使用KMeans聚类来实现图像中颜色的分离。</p><p id="2dcd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是通过这种方法生成的一些示例</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/92c27b7ba09d443b131b1a0e5ce6c5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ePAM9zwv8uh8_xFXtQqYA.png"/></div></div></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/7303754e4048534ec4123aefd96827b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*JHOlXmPlyPrcOxM4sI4mYw.png"/></div></figure><p id="8206" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你喜欢这篇文章，请👏。</p><p id="1a56" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点击这里查看我关于使用Keras增强图像的文章</p><p id="1fff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae mp" rel="noopener" href="/analytics-vidhya/understanding-image-augmentation-using-keras-tensorflow-a6341669d9ca">https://medium . com/analytics-vid hya/understanding-image-augmentation-using-keras-tensor flow-a 6341669 d9ca</a></p><h2 id="46c2" class="lt ju hi bd jv lz ma mb jz mc md me kd jf mf mg kh jj mh mi kl jn mj mk kp ml bi translated">参考资料:-</h2><div class="mq mr ez fb ms mt"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">sk learn . cluster . k means-sci kit-learn 0 . 23 . 1文档</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">k-均值聚类。了解更多信息。参数n_clustersint，default=8要形成的簇的数量以及…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">scikit-learn.org</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh io mt"/></div></div></a></div></div></div>    
</body>
</html>