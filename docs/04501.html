<html>
<head>
<title>Goroutines unit testing (handling goroutines leaks)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Goroutines单元测试(处理goroutines泄漏)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/goroutines-unit-testing-handling-unexpected-goroutines-dd0003be193c?source=collection_archive---------6-----------------------#2020-03-22">https://medium.com/analytics-vidhya/goroutines-unit-testing-handling-unexpected-goroutines-dd0003be193c?source=collection_archive---------6-----------------------#2020-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="653d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将解释我们如何编写golang单元测试，并在测试完成后发现意外的错误。</p><p id="9e74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有这样一个场景，作为一个客户端，我们想要发出一个http请求，它在内部创建多个goroutines并异步发出多个http调用来获取数据并返回给客户端累积的http响应。如果任何http请求失败或返回错误响应，那么客户端需要得到一个错误响应。在这种情况下，如果任何http请求失败，那么我们不想等待其他http请求完成。一旦我得到一个错误，我需要发送错误响应给客户端。</p><p id="4435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是获取给定城市列表的天气详细信息的代码片段。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2ea1" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">package </strong>main<br/><br/><strong class="ji hj">import </strong>(<br/>   <strong class="ji hj">"errors"<br/>   "fmt"<br/>   "io/ioutil"<br/>   "net/http"<br/></strong>)<br/><br/><strong class="ji hj">type </strong>WeatherClient <strong class="ji hj">struct </strong>{<br/>   client  *http.Client<br/>   baseURL string<br/>}<br/><br/><strong class="ji hj">func </strong>NewWeatherClient(client *http.Client, baseURL string) *WeatherClient {<br/>   <strong class="ji hj">return </strong>&amp;WeatherClient{<br/>      client:  client,<br/>      baseURL: baseURL,<br/>   }<br/>}<br/><br/><strong class="ji hj">func </strong>(wc WeatherClient) FindWeatherForCities(cities []string) []string {<br/>   weatherData := make([]string, 0)<br/>   responseChan := make(<strong class="ji hj">chan </strong>string, 1)<br/>   errorChan := make(<strong class="ji hj">chan </strong>error, 1)<br/><br/>   <strong class="ji hj">for </strong>city := <strong class="ji hj">range </strong>cities {<br/>      cityWeatherURL := fmt.Sprintf(wc.baseURL+<strong class="ji hj">"?q=%s&amp;appid=weatherAPIApplicationId"</strong>, city)<br/>      <strong class="ji hj">go </strong>wc.GetWeatherForCity(cityWeatherURL, responseChan, errorChan)<br/>   }<br/><br/>   <strong class="ji hj">for </strong>{<br/>      <strong class="ji hj">select </strong>{<br/>      <strong class="ji hj">case </strong>&lt;-errorChan:<br/>         <strong class="ji hj">return </strong>weatherData[:0]<br/>      <strong class="ji hj">case </strong>resp := &lt;-responseChan:<br/>         weatherData = append(weatherData, resp)<br/>      <strong class="ji hj">default</strong>:<br/>      }<br/><br/>      <strong class="ji hj">if </strong>len(weatherData) == len(cities) {<br/>         <strong class="ji hj">return </strong>weatherData<br/>      }<br/>   }<br/>}<br/><br/><strong class="ji hj">func </strong>(wc WeatherClient) GetWeatherForCity(url string, responseChan <strong class="ji hj">chan </strong>string, errorChan <strong class="ji hj">chan </strong>error) {<br/>   <strong class="ji hj">defer func</strong>() {<br/>      <strong class="ji hj">if </strong>r := recover(); r != nil {<br/>         fmt.Println(<strong class="ji hj">"RECOVER"</strong>, r)<br/>         errorChan &lt;- errors.New(<strong class="ji hj">"error panic goroutine"</strong>)<br/>      }<br/>   }()<br/><br/>   resp, err := wc.client.Get(url)</span><span id="6dcf" class="jm jn hi ji b fi js jp l jq jr">   <strong class="ji hj">if </strong>resp.StatusCode == 200 {<br/>      bytes, err := ioutil.ReadAll(resp.Body)<br/>      <strong class="ji hj">if </strong>err != nil {<br/>         errorChan &lt;- err<br/>         <strong class="ji hj">return<br/>      </strong>}<br/>      responseChan &lt;- string(bytes)<br/>   } else {<br/>      errorChan &lt;- err<br/>   }<br/>}</span></pre><p id="e568" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用base URL“https://<a class="ae jt" href="http://samples.openweathermap.org/data/2.5/weather?q=London,uk&amp;appid=b6907d289e10d714a6e88b30761fae22" rel="noopener ugc nofollow" target="_blank">api.openweathermap.org/data/2.5/weather</a>”和“默认http客户端”创建一个新的WearherClient。</p><p id="1a6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将“<strong class="ih hj">weatherAPIApplicationId”</strong>替换为正确的应用Id，以获得城市列表的响应。</p><p id="5b2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果无法获得任何城市的数据，它将向客户端发送错误响应，因为我们不想显示部分数据。</p><p id="71e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">测试上面的代码</strong>。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7b07" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">package </strong>main<br/><br/><strong class="ji hj">import </strong>(<br/>   <strong class="ji hj">"github.com/stretchr/testify/assert"<br/>   "go.uber.org/goleak"<br/>   "net/http"<br/>   "net/http/httptest"<br/>   "strings"<br/>   "testing"<br/></strong>)<br/><br/><strong class="ji hj">func </strong>TestPrintWeatherForCities(t *testing.T) {<br/>   <strong class="ji hj">defer </strong>goleak.VerifyNone(t)<br/>   cities := []string{<strong class="ji hj">"city1"</strong>,<strong class="ji hj">"city2"</strong>, <strong class="ji hj">"city3"</strong>, <strong class="ji hj">"city4"</strong>, <strong class="ji hj">"city5"</strong>, <strong class="ji hj">"city6"</strong>, <strong class="ji hj">"city7"</strong>, <strong class="ji hj">"city8"</strong>}<br/><br/><br/>   server := httptest.NewServer(http.HandlerFunc(<strong class="ji hj">func</strong>(w http.ResponseWriter, r *http.Request) {<br/>      <strong class="ji hj">if </strong>strings.EqualFold(<strong class="ji hj">"q=%!s(int=0)&amp;appid=weatherAPIApplicationId"</strong>, r.URL.RawQuery) {<br/>         w.WriteHeader(500)<br/>         <strong class="ji hj">return<br/>      </strong>}<br/>      w.WriteHeader(200)<br/>      w.Write([]byte(<strong class="ji hj">"Passed"</strong>))<br/>   }))<br/><br/>   baseURL := server.URL<br/>   weatherClient := NewWeatherClient(server.Client(), baseURL)<br/>   weatherData := weatherClient.FindWeatherForCities(cities)<br/>   server.Close()<br/><br/>   assert.Equal(t, []string{}, weatherData)<br/>}</span></pre><p id="227a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我正在使用由<strong class="ih hj"> uber </strong>开发的名为<strong class="ih hj"> goleak" </strong>的包来捕获上述代码中的意外goroutines，所以测试将失败，并显示错误:“<strong class="ih hj">发现意外go routines</strong>”。并且如果注释行"<strong class="ih hj"> defer goleak。验证无(t) </strong>“测试将通过。但是这不是使它通过测试的正确方法，相反，应该使用适当的编程逻辑来修复它。</p><p id="02f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">怎么修？</strong></p><p id="1b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在代码片段中，我创建了两个大小为1的有界通道来收集来自goroutines的响应和错误。</p><p id="3b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果任何goroutine产生错误，上述程序将退出，但多个go routine仍将运行，这就是goleak verify将捕获的go routine。</p><p id="54cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理这个问题的一种方法是创建具有给定城市列表大小的频道。这将有助于处理运行中的goroutines响应/错误。</p><p id="bbad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以只要随着城市的长度改变响应的大小和误差通道的大小。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3db8" class="jm jn hi ji b fi jo jp l jq jr">responseChan := make(<strong class="ji hj">chan </strong>string, len(cities))<br/>errorChan := make(<strong class="ji hj">chan </strong>error, len(cities))</span></pre><p id="5b2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能有其他可能的解决方案来处理正在运行的goroutines，直到它正确地完成进程。</p><p id="4e92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想要解释“<strong class="ih hj">goleak</strong>的用法”并避免在所有goroutine完成之前通道关闭时出现恐慌情况。</p><p id="df37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎评论/反馈/建议。</p><p id="f89f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢了。</p></div></div>    
</body>
</html>