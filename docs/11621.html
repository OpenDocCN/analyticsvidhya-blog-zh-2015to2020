<html>
<head>
<title>Deep intuition and things behind the ROC Curve and Area Under ROC Curve(AUC)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ROC曲线和ROC曲线下面积(AUC)背后的深层直觉和事物</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-intuition-and-things-behind-the-roc-curve-and-area-under-roc-curve-auc-894337d96ed?source=collection_archive---------6-----------------------#2020-12-11">https://medium.com/analytics-vidhya/deep-intuition-and-things-behind-the-roc-curve-and-area-under-roc-curve-auc-894337d96ed?source=collection_archive---------6-----------------------#2020-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7ef7c069a72936b0526ece09f37a6021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*DxDTOQyPkSXy1_xQuPbG7Q.png"/></div></figure><p id="2a52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇博客是<a class="ae jk" rel="noopener" href="/analytics-vidhya/evaluating-metrics-for-classification-machine-learning-models-learners-at-medium-level-c956a8b8d889">这篇文章</a>的延续。</p><p id="c864" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我假设你知道混淆矩阵、准确度、精确度、回忆和F1分数。</p><p id="dbd5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我再次重申，在学习这些指标之前，您需要了解如何构建分类模型。</p><p id="9ff5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我将为您构建一个模型...</p><p id="4beb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们用同样的旧代码片段，</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="8812" class="ju jv hi jq b fi jw jx l jy jz">import pandas as pd<br/>from sklearn.datasets import make_classification<br/>from sklearn.model_selection import train_test_splitfrom sklearn.tree import DecisionTreeClassifier</span><span id="d92a" class="ju jv hi jq b fi ka jx l jy jz">X,y = make_classification(n_samples=200,n_features=10,random_state=20)</span><span id="402d" class="ju jv hi jq b fi ka jx l jy jz">X_train,X_test,y_train,y_test = <br/>sklearn.model_selection.train_test_split(X,y,random_state = 43)</span><span id="39f3" class="ju jv hi jq b fi ka jx l jy jz">model = DecisionTreeClassifier()<br/>model.fit(X_train,y_train)</span></pre><p id="4273" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，你有一个模型。</p><p id="dcc4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止，你所理解的是，<strong class="io hj">“如果你看到一个不平衡的数据集，那么你必须使用F1-Score(结合了精确度和召回率)的指标”</strong>。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="fb8c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意:- </strong>请浏览我以前关于分类标准的博客，以了解下面的事情…</p><p id="f751" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在深入研究ROC_AUC之前，我们需要了解一些东西，如真+ve率(TPR)、假+ve率(FPR)、假阴性率(FNR)、真-ve率(TNR)、灵敏度和特异性。</p><ol class=""><li id="5cc3" class="ki kj hi io b ip iq it iu ix kk jb kl jf km jj kn ko kp kq bi translated"><strong class="io hj">真阳性率(TPR) </strong> :-真+ve率与Recall相同，“它是预测的+ve值被正确预测为+ve样本的比率”</li></ol><p id="23dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> TPR = TP / (TP + FN) </strong></p><p id="1099" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">真阳性率也叫<strong class="io hj">灵敏度。</strong></p><p id="2ea2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果模型的灵敏度高，那么我们的模型可以有效地预测+ve样本。</p><p id="8e08" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">真阴性率:- </strong>真阴性率是预测ve值作为ve样本得到正确预测的比率。</p><p id="3134" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> TNR = TN / (TN + FP) </strong></p><p id="02dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">真阴性率也叫<strong class="io hj">特异性。</strong></p><p id="5287" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们的模型的特异性高，那么我们的模型可以有效地预测样本。</p><p id="6c4a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:-每当我们建立我们的模型时，我们需要以一种灵敏度和特异性非常高的方式来设计我们的模型。</p><p id="ebe5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">假阴性率(FNR):- </strong>假阴性率是阳性值被错误地预测为阴性样本的比率。</p><p id="d470" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> FNR = FN / (FN + TP) </strong></p><p id="80c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有，<strong class="io hj">(假-ve率)+(真+ve率)= 1 </strong></p><p id="7238" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">即<strong class="io hj"> FPR = (1-灵敏度)。</strong></p><p id="e33b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.<strong class="io hj">假阳性率(FPR):- </strong>假阳性率是阴性值被错误地预测为阳性样本的比率。</p><p id="1fca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> FPR = FP / (FP + TN) </strong></p><p id="a486" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有，<strong class="io hj">(假阳性率+真阴性率)= 1 </strong></p><p id="2eed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">即<strong class="io hj">FPR =(1-特异性)。</strong></p><p id="7dfb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，你知道什么是TPR，TNR，FPR和FNR。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="0551" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你是机器学习的初学者，那么你可以通过做这个来预测课程</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="febe" class="ju jv hi jq b fi jw jx l jy jz">y_pred = model.predict(X_test)</span></pre><p id="374f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们编译上面一行代码时，将会发生的是，</p><p id="8fd5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，模型将预测测试数据为正的概率。然后，通过与阈值0.5进行比较，即如果prediction_probability &gt; 0.5，则预测的测试样本将被称为+ve样本，否则为负。其实我们也可以做实际执行。</p><p id="a2d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请参见上面的实现示例:</p><p id="9484" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们来想一个测试样本，Predicted_probability = 0.68。然后，将这个概率与阈值= 0.5进行比较，即，在代码语言中，</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="0a6a" class="ju jv hi jq b fi jw jx l jy jz">if( Predicted_Probability &gt; 0.5) #0.5 is threshold <br/>{ <br/>    return 1;<br/>} <br/>else <br/>{ <br/>    return 0;<br/>}</span></pre><p id="6821" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1 -&gt;正</p><p id="d1af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">0-&gt;负</p><p id="c748" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，默认情况下，我们的模型将阈值视为(0.5)。因此，当预测概率&gt; 0.5时，如果预测概率&lt; 0.5, then the predicted test label will be 0. All these things will be automatically calculated by the model, and in y_pred, test labels will be appended.</p><p id="946a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">y_pred will be look like this[1, 0, 0, 1, 1, 1, 1, 0].</p><p id="26e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">All the metrics that were discussed in the previous blog will be calculated through the above procedure only. The below complete code represents the above explanation.</p><p id="d9df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Read again, if you didn’t understand…</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="8051" class="ju jv hi jq b fi jw jx l jy jz">import pandas as pd<br/>from sklearn.datasets import make_classification<br/>from sklearn.model_selection import train_test_splitfrom sklearn.tree import DecisionTreeClassifier</span><span id="36bf" class="ju jv hi jq b fi ka jx l jy jz">X,y = make_classification(n_samples=200,n_features=10,random_state=20)</span><span id="395f" class="ju jv hi jq b fi ka jx l jy jz">X_train,X_test,y_train,y_test = <br/>sklearn.model_selection.train_test_split(X,y,random_state = 43)</span><span id="9012" class="ju jv hi jq b fi ka jx l jy jz">model = DecisionTreeClassifier()<br/>model.fit(X_train,y_train)</span><span id="ab2f" class="ju jv hi jq b fi ka jx l jy jz">#this will be predicted with the threshold of 0.5 as explained above<br/>y_pred = model.predict(y_test)</span><span id="59b3" class="ju jv hi jq b fi ka jx l jy jz">#y_pred will be look like[1, 0, 0, 1, 1, 1, 1, 0]<br/>accuracy_score = sklearn.metrics.accuracy_score(y_true,y_pred)</span></pre><p id="9ee3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Now, we’ll see another type of prediction in order to understand the ROC_AUC…</p><p id="eae6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Till now, what you’ve studied is a type of prediction method which you won't use much in implementing real-time applications. Now, we’ll discuss a method of predicting, which will be used in real-world problem-solving.</p><p id="68fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">The method is simple. As we consider the default threshold as 0.5, manually we’ll predict the probabilities of test samples and then, we’ll consider a threshold in such a way that our metric will give high accuracy.</p><p id="ca38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Note:- From now, you should not use model.predict() function, see the below function and you should use it now.</p><p id="a45e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">the function is,</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="4a7c" class="ju jv hi jq b fi jw jx l jy jz">model.predict_proba(X_test)</span></pre><p id="1637" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">the above function will predict the probabilities of test samples to be positive. The higher the value, the higher the chance that the test sample to be +Ve.</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="f139" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> ROC_AUC得分:- </strong> ROC_AUC得分仅仅是ROC曲线的面积，则预测测试标签将为1，而ROC曲线将根据不同的阈值通过使用不同的TPR和FPR来构建。</p><p id="1d0d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们一步步深入ROC_AUC分数:-</p><ol class=""><li id="4376" class="ki kj hi io b ip iq it iu ix kk jb kl jf km jj kn ko kp kq bi translated">考虑一组阈值，比如说，[0.1，0.2，0.3，0.4，0.5，0.6，0.7，0.8，0.9，1.0]。</li></ol><p id="f6a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们将测试样本预测概率与每个阈值进行比较，并预测离散值，即0或1。</p><p id="3c89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据预测的离散值，可以计算出真+Ve率、假+Ve率。</p><p id="367b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请参见下面的上述要点实现…</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="2d1f" class="ju jv hi jq b fi jw jx l jy jz">model = sklearn.linear_model.LogisticRegression()   model.fit(X_train.values,y_train.values)</span><span id="ea63" class="ju jv hi jq b fi ka jx l jy jz">y_prob = model.predict_proba(X_test.values)             print(y_prob)</span><span id="d5a9" class="ju jv hi jq b fi ka jx l jy jz">tpr = []<br/>fpr = []</span><span id="01ed" class="ju jv hi jq b fi ka jx l jy jz">for i in threshold_list:<br/>   k = y_prob[:,1] &gt; i<br/>   j = []<br/>   for i in k:<br/>      j.append(int(i)<br/>   tp = true_positive(y_test,j)<br/>   fp = false_positive(y_test,j)<br/>   tn = true_negative(y_test,j)<br/>   fn = false_negative(y_test,j)<br/>   tpr.append(tp/(tp+fn))<br/>   fpr.append(fp/(fp+tn))</span><span id="3104" class="ju jv hi jq b fi ka jx l jy jz">data = list(zip(tpr,fpr))<br/>dataset = pandas.DataFrame(data,columns = ["tpr","fpr"])<br/>print(dataset.values)</span></pre><p id="dd2c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的代码将给出如下所示的输出</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/77f41f2fc42c16787002f8c5b7060c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4zuUzHAT9Zap2IEqS7dQQ.png"/></div></div></figure><p id="569e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在输出中，左边的值代表TPR，右边的值代表FPR</p><p id="5837" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我上面考虑的数据集只是用来显示FPR &amp; TPR将如何计算，不要为数据集而烦恼。只需关注FPR和TPR是如何计算的(你可以在这里看到数据集<a class="ae jk" href="https://github.com/vishnu2136/Datasets_for_Problem_Statements/blob/master/p3%20-%20loan%20prediction/modified.csv" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="53a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.现在，在TPRs和FPRs的帮助下，我们将绘制一个称为ROC曲线的图表，这是我们针对不同阈值计算的。</p><p id="d42d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参见下面的代码和输出，</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="0cd4" class="ju jv hi jq b fi jw jx l jy jz">plt.figure(figsize = (7,7))<br/>plt.fill_between(dataset.fpr.values,dataset.tpr.values, alpha=0.4)<br/>plt.plot(dataset.fpr.values,dataset.tpr.values,lw = 2)<br/>plt.title("ROC_AUC CURVE")<br/>plt.xlim(0,1.0)<br/>plt.ylim(0,1.0)<br/>plt.xlabel("fpr",fontsize = 16)<br/>plt.ylabel("tpr",fontsize = 16)<br/>plt.show()</span></pre><p id="53b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码的输出是一个ROC曲线，见下图</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kw"><img src="../Images/ee171de6c60da93b6af1d99331472140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xfkTLfOSPgDGfdJXPVMnA.png"/></div></div></figure><p id="cc26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不要为曲线而烦恼，只要专注于如何绘制ROC曲线。在建模之前，我没有对数据做太多预处理。所以，曲线不够好。</p><p id="ace6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.现在，我们需要找出图中蓝色区域的面积，这个面积叫做ROC  <strong class="io hj">曲线</strong>的<strong class="io hj">面积，也叫<strong class="io hj">曲线下面积(AUC)。</strong></strong></p><p id="1bbd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了计算曲线下的面积，我们可以进入线性代数、积分和许多数学框架。但是我们不需要深入研究它们。我们可以使用sklearn计算面积，这样会给出AUC(曲线下面积)。</p><p id="f885" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个AUC是机器学习中对于倾斜目标最流行的度量之一。</p><p id="1905" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看计算这个面积的代码(只有一行😉):-</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="8d81" class="ju jv hi jq b fi jw jx l jy jz">print(sklearn.metrics.roc_auc_score(y_test,y_prob[:,1]))</span></pre><p id="09db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将给出曲线下面积的输出，如下所示:-</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kx"><img src="../Images/880b79356e4dfafecf9b93450051c4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wi5m_C4IlGxlFPXwohodyQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">AUC分数</figcaption></figure><p id="81fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">AUC分数将在0和1之间。如果AUC分数接近1，那么我们开发的模型是可以为所考虑的数据集开发的最佳模型之一(也有可能过度拟合，对此要小心)。如果AUC评分接近0，那么我们的模型比随机猜测还要差。</p><p id="7bcc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们的模型给出的分数= 0.5，那么我们的模型就是幼稚模型。</p><p id="5d91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">大注:- </strong></p><p id="2f11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们也可以将ROC曲线用于另一个目的。从上面我们可以看到，不同的阈值，产生不同的离散预测，产生不同的TPR和FPR。但是，在开发工业应用时，特定的阈值值将由项目领域专业人员选择，以这种方式，无论他们想要高TPR还是低TPR，高FPR还是低FPR，根据这一点，阈值将被选择。仅在该阈值的帮助下，将根据预测的概率进行离散值预测。这些预测和指标将会得到应用。</p><p id="7fc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于我们是机器学习的初学者，我们将以TPR和FPR都达到平衡的方式来选择阈值。任何ROC曲线左上角的值将给出一个平衡的阈值。</p><p id="70ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我觉得这都是关于ROC_AUC评分的…</p><p id="cdbb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果有什么需要补充的，让我知道…</p><p id="8685" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">联系我这里:-<a class="ae jk" href="https://www.linkedin.com/in/vishnu-vardhan-varapalli-b6b454150/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/in/Vishnu-vard Han-vara palli-b6b 454150/</a></p><p id="b4fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">快乐的Learning✌！！</p></div></div>    
</body>
</html>