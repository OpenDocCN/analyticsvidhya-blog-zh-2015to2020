<html>
<head>
<title>Basics of Using Pre-trained GloVe Vectors in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用预训练手套向量的基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/basics-of-using-pre-trained-glove-vectors-in-python-d38905f356db?source=collection_archive---------0-----------------------#2019-09-07">https://medium.com/analytics-vidhya/basics-of-using-pre-trained-glove-vectors-in-python-d38905f356db?source=collection_archive---------0-----------------------#2019-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c85b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">下载、加载和使用预先训练的手套向量</h2></div><h1 id="1ce2" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">内容</h1><p id="5881" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">本文将涵盖:<br/> <strong class="jr hj"> <em class="kl"> * </em> </strong>下载并加载预先训练好的向量<strong class="jr hj"> <em class="kl"> <br/> * </em> </strong>寻找与给定向量相似的向量<strong class="jr hj"> <em class="kl"> <br/> * </em> </strong>【数学与文字】<strong class="jr hj"> <em class="kl"> <br/> * </em> </strong>可视化向量</p><p id="8dbd" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">进一步的阅读资源，包括原始的手套论文，在最后提供。</p><h1 id="af68" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">手套简介</h1><p id="e109" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj">Glo</strong>bal<strong class="jr hj">Ve</strong>ctors for Word re presentation，或GloVe，是一种"<a class="ae kr" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">无监督学习算法，用于获取单词的矢量表示。</a>“简单来说，GloVe可以让我们拿一个文本的语料库，直观地将那个语料库中的每一个单词转换成高维空间中的一个位置。这意味着相似的单词将被放在一起。</p><p id="c167" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果你想详细了解GloVe的工作原理，可以在最后找到相关链接。</p><h1 id="cde6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">下载预先训练的向量</h1><p id="13d0" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">前往https://nlp.stanford.edu/projects/glove/。然后在“下载预先训练的单词向量”下面，你可以为不同大小或训练数据集选择四个选项中的任何一个。</p><p id="9e29" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我选择了<em class="kl">维基百科2014 + Gigaword 5 </em>矢量。你可以在<a class="ae kr" href="http://nlp.stanford.edu/data/glove.6B.zip" rel="noopener ugc nofollow" target="_blank">http://nlp.stanford.edu/data/glove.6B.zip</a>T33】下载那些精确的矢量(警告:这是一个822 MB的下载)</p><p id="d808" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我不能保证下面使用的方法将与所有其他预先训练的向量一起工作，因为它们还没有经过测试。</p><h1 id="775e" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">进口</h1><p id="b4d6" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">对于这个项目，我们将需要使用、Numpy、Scipy、Matplotlib和Sklearn。<br/>如果您需要安装其中任何一个，您可以运行以下命令:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="677b" class="lb iy hi kx b fi lc ld l le lf">pip install numpy<br/>pip install scipy<br/>pip install matplotlib<br/>pip install sklearn</span></pre><p id="9697" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">根据您的Python版本，您可能需要用pip替换pip3。</p><p id="7504" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在，我们可以通过以下方式从这些模块中导入我们需要的零件:</p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="8f14" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">加载向量</h1><p id="4523" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在代码中加载向量之前，我们必须理解文本文件是如何格式化的。<br/>文本文件的每一行包含一个单词，后跟<em class="kl"> N个</em>数字。N个数字描述了单词位置的向量。<em class="kl"> N </em>可能会因你下载的矢量而异，对我来说，<em class="kl"> N </em>是50，因为我用的是<em class="kl"> glove.6B.50d. </em></p><p id="b8ac" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">以下是文本文件中的一行示例，缩短为前三个维度:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a4fe" class="lb iy hi kx b fi lc ld l le lf">business 0.023693 0.13316 0.023131 ...</span></pre><p id="f2eb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">为了加载预先训练好的向量，我们必须首先创建一个字典来保存单词之间的映射，以及这些单词的<a class="ae kr" href="https://en.wikipedia.org/wiki/Word_embedding" rel="noopener ugc nofollow" target="_blank">嵌入向量</a>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="732f" class="lb iy hi kx b fi lc ld l le lf">embeddings_dict = {}</span></pre><p id="1ea8" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">假设您的Python文件与GloVe vectors在同一个目录中，我们现在可以打开包含嵌入内容的文本文件:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="02f7" class="lb iy hi kx b fi lc ld l le lf">with open("glove.6B.50d.txt", 'r', encoding="utf-8") as f:</span></pre><p id="612c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">注意:你需要将<em class="kl">glove . 6b . 50d . tx</em>t<em class="kl">T5】替换为你为向量选择的文本文件的名称。</em></p><p id="1b62" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">一旦进入<em class="kl"> with </em>语句，我们需要遍历文件中的每一行，并按每个空格将该行拆分成它的每个组成部分。</p><p id="cdaf" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在拆分行之后，我们假设单词中没有任何空格，并将其设置为等于拆分行的第一个(或第零个)元素。</p><p id="c6eb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">然后我们可以把这一行的剩余部分，转换成一个<em class="kl"> Numpy </em>数组。这是单词位置的向量。</p><p id="8f81" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">最后，我们可以用新单词及其对应的向量来更新我们的字典。</p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="4866" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">作为我们加载向量的完整代码的回顾:</p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c0fd" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">请记住，如果您的矢量文本文件包含带有空格的单词，您可能需要编辑将单词从矢量<em class="kl">中分离出来的方法。</em></p><h1 id="ae41" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">寻找相似向量</h1><p id="1adf" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们可以用手套向量做的另一件事是找到与给定单词最相似的单词。我们可以通过如下奇特的一行函数来实现这一点:</p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="ca36" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这个很复杂，我们来分解一下。<br/> <em class="kl">排序</em>将一个iterable作为输入，并使用一个键对其进行排序。在这种情况下，我们传入的iterable是我们想要排序的所有可能的单词。我们可以通过调用<em class="kl"> embeddings_dict.keys()来获得这样的单词列表。</em></p><p id="7de6" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在，因为默认情况下Python会按字母顺序对列表进行排序，所以我们必须指定一个<em class="kl">键</em>来按照我们想要的方式对列表进行排序。<br/>在我们的例子中，<em class="kl">键</em>将是一个lambda函数，它将一个单词作为输入，并返回该单词的嵌入和我们给该函数的嵌入之间的距离。我们将使用欧几里得距离来度量两个嵌入之间的距离。</p><p id="adc6" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><em class="kl"> scipy </em>在其模块<em class="kl"> spatial </em>下有一个测量欧氏距离的函数，我们之前导入过。所以我们最后的排序键变成了:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d12b" class="lb iy hi kx b fi lc ld l le lf"><em class="kl">lambda</em> <em class="kl">word</em>: spatial.distance.euclidean(embeddings_dict[word], embedding)</span></pre><p id="1799" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在，如果我们想根据与给定单词的接近程度对所有单词进行排序，比如说“king”，我们可以使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0bef" class="lb iy hi kx b fi lc ld l le lf">find_closest_embeddings(embeddings_dict["king"])</span></pre><p id="82cd" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">然而，这将打印每个单词，所以如果我们想缩短它，我们可以在最后使用一个切片，最接近的，让我们说五个单词。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cbe0" class="lb iy hi kx b fi lc ld l le lf">find_closest_embeddings(embeddings_dict["king"])[:5]</span></pre><p id="1ea9" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">因为与给定单词最接近的单词总是那个单词，所以我们可以将我们的切片偏移1。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="153b" class="lb iy hi kx b fi lc ld l le lf">find_closest_embeddings(embeddings_dict["king"])[1:6]</span></pre><p id="d1e1" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">用我的向量glove.6B.50d，</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1c78" class="lb iy hi kx b fi lc ld l le lf">print(find_closest_embeddings(embeddings_dict["king"])[1:6])</span></pre><p id="067d" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">版画:<em class="kl"> ['王子'，'皇后'，'叔叔'，'二世'，'孙子'] </em></p><p id="17ea" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们直接采用嵌入，而不是将单词转换成嵌入的原因是，当我们添加和减去嵌入时，我们可以找到与嵌入最接近的近似单词，而不仅仅是单词。我们可以做到这一点，即使嵌入并不完全依赖于任何单词。</p><h1 id="5606" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">数学与文字</h1><p id="7453" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">既然我们可以把任何单词转换成向量，我们可以对向量和单词使用任何数学运算。</p><p id="6a42" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">比如我们可以把两个字加在一起，减在一起，就像数字一样。即<em class="kl">小树枝+手≈手指</em></p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="6e03" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">上面的代码打印了“<em class="kl">指甲</em>作为它的顶部结果，这在逻辑上是可以接受的。</p><h1 id="bce1" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">可视化矢量</h1><p id="4870" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">没有什么比可视化数据更有助于发现数据中的洞见。</p><p id="eddc" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">为了可视化向量，我们首先要使用一种称为t-分布式随机邻居嵌入的方法，也称为t-SNE。t-SNE将允许我们把数据的50维减少到2维。在我们这样做之后，就像使用<em class="kl"> matplotlib </em>散点图来绘制它一样简单。如果你想了解更多关于SNE霸王龙的知识，在文章的最后有一些链接。</p><p id="0de5" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">幸运的是，sklearn有一个<a class="ae kr" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html" rel="noopener ugc nofollow" target="_blank"> t-SNE类</a>，可以让我们的工作变得更容易管理。为了实例化它，我们可以使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="43ff" class="lb iy hi kx b fi lc ld l le lf">tsne = TSNE(<em class="kl">n_components</em>=2, <em class="kl">random_state</em>=0)</span></pre><p id="b642" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><em class="kl"> n_components </em>指定减少数据的维数。<br/> <em class="kl"> random_state </em>是我们可以用来获得一致结果的种子<em class="kl">。</em></p><p id="3250" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">初始化t-SNE类后，我们需要获得每个单词的列表，以及该单词的对应向量。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="30f6" class="lb iy hi kx b fi lc ld l le lf">words =  <em class="kl">list</em>(embeddings_dict.keys())<br/>vectors = [embeddings_dict[word] for word in words]</span></pre><p id="2478" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">第一行获取<em class="kl"> embeddings_dict </em>的所有键，并将其转换为一个列表。</p><p id="b9e9" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">第二行使用list comprehension来获取与我们选择的每个单词对应的<em class="kl"> embeddings_dict </em>中的值，并将其放入列表中。</p><p id="58da" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们也可以手动指定<em class="kl">单词</em>，这样它将只绘制单个单词。即<em class="kl">词=【“姐姐”、“哥哥”、“男人”、“女人”、“叔叔”、“阿姨”】</em></p><p id="6da8" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在得到我们想要使用的所有单词及其对应的向量后，我们现在需要在向量上拟合t-SNE类。<br/>我们可以使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7b47" class="lb iy hi kx b fi lc ld l le lf">Y = tsne.fit_transform(vectors[:1000])</span></pre><p id="ea52" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果你愿意，你可以移除或扩展<em class="kl">矢量</em>末端的切片，但是要注意；这可能需要一台强大的计算机。</p><p id="b3fb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在t-SNE类完成对向量的拟合后，我们可以使用<em class="kl"> matplotlib </em>散点图来绘制数据:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="de01" class="lb iy hi kx b fi lc ld l le lf">plt.scatter(Y[:, 0], Y[:, 1])</span></pre><p id="ffaa" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这本身不是很有用，因为它只是一堆点。为了改进它，我们可以通过使用标签循环遍历每个<em class="kl"> X Y </em>点并调用<em class="kl"> plt来注释图表，使用那些<em class="kl"> X Y </em>点和那个标签来注释</em>。该函数的其他输入用于重要的格式化。<a class="ae kr" href="https://matplotlib.org/users/annotations.html" rel="noopener ugc nofollow" target="_blank">Matplotlib中的注释</a></p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5494" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">最后，我们可以展示这个情节，</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="275d" class="lb iy hi kx b fi lc ld l le lf">plt.show()</span></pre><figure class="ks kt ku kv fd lg er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/67c5785cdb1ece562a05775c04085006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iieBWvJglyExr-vwojKYZw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">有点拥挤，但你仍然可以看到相关性。</figcaption></figure><figure class="ks kt ku kv fd lg er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/10e5a01585c7cfb8591f52a23a8ec500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXgxyEVatM3Bq_SWWciGrw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">放大</figcaption></figure><p id="c7bb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这在功能较弱的计算机上可能会滞后，所以你可以选择减少显示的字数，将<em class="kl"> vectors[:1000] </em>改为更像<em class="kl"> vectors[:250] </em>的东西，或者将<em class="kl"> words </em>改为你自己制作的列表。</p><figure class="ks kt ku kv fd lg er es paragraph-image"><div class="er es lu"><img src="../Images/70ea30eb5511a0a3d230ced347028488.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*kRD7PJ0xkdY_vbEZm-vsWA.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated"><em class="lv">单词= [“树枝”、“小枝”、“手指”、“手”] </em></figcaption></figure><p id="1b27" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">可视化矢量的完整代码:</p><figure class="ks kt ku kv fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="1c35" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">结论</h1><p id="bfba" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在我的GitHub <a class="ae kr" href="https://github.com/sebtheiler/tutorials/tree/main/using-pretrained-glove-vectors" rel="noopener ugc nofollow" target="_blank">这里</a>有Jupyter笔记本和Python文件格式的完整代码。</p><p id="ab43" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">使用预训练的手套向量只能做这么多。对于更高级的用法，我建议参考<a class="ae kr" href="https://github.com/stanfordnlp/GloVe/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">官方自述文件</a>来训练你自己的向量。</p><p id="1f47" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">上面没有提到的一个重要用途是在自然语言处理模型的开始加载一个嵌入层，使用这些向量。理论上，这将大大提高模型的准确性，并节省从头训练新嵌入的时间。</p><h1 id="154e" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">延伸阅读:</h1><p id="ded6" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj">论文:</strong> <br/>原手套论文:<a class="ae kr" href="https://nlp.stanford.edu/pubs/glove.pdf" rel="noopener ugc nofollow" target="_blank">https://nlp.stanford.edu/pubs/glove.pdf</a><br/>原t-SNE论文:<a class="ae kr" href="http://jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf" rel="noopener ugc nofollow" target="_blank">http://jmlr . org/Papers/volume 9/vandermaten 08 a/vandermaten 08 a . pdf</a></p><p id="ee9e" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><strong class="jr hj">更详细的手套解说:<br/></strong><strong class="jr hj"><em class="kl">*</em></strong><a class="ae kr" href="https://mlexplained.com/2018/04/29/paper-dissected-glove-global-vectors-for-word-representation-explained/" rel="noopener ugc nofollow" target="_blank">https://mlexplained . com/2018/04/29/paper-Manchester-GloVe-global-vectors-for-word-representation-explained/</a><br/><strong class="jr hj"><em class="kl">*</em></strong><a class="ae kr" href="https://blog.acolyer.org/2016/04/22/glove-global-vectors-for-word-representation/" rel="noopener ugc nofollow" target="_blank">https://blog . acolyer . org/2016/04/22/GloVe-global-vectors-for</a></p><p id="8f70" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><strong class="jr hj">更详细的t-SNE解说:<br/></strong><strong class="jr hj"><em class="kl">*</em></strong><a class="ae kr" href="https://mlexplained.com/2018/09/14/paper-dissected-visualizing-data-using-t-sne-explained/" rel="noopener ugc nofollow" target="_blank">https://mlexplained . com/2018/09/14/paper-解剖-可视化-数据-使用-t-SNE-解释/</a><br/><strong class="jr hj"><em class="kl">*</em></strong><a class="ae kr" href="https://distill.pub/2016/misread-tsne/" rel="noopener ugc nofollow" target="_blank">https://distill.pub/2016/misread-tsne/</a></p></div></div>    
</body>
</html>