<html>
<head>
<title>C++ Smart Pointers and References</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++智能指针和引用</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-smart-pointers-and-references-4b15ee5d14bf?source=collection_archive---------11-----------------------#2020-08-28">https://medium.com/analytics-vidhya/c-smart-pointers-and-references-4b15ee5d14bf?source=collection_archive---------11-----------------------#2020-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="bc8b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">共享指针</h1><p id="22bb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="kb">共享</em>指针是一种智能指针，允许数据的分布式所有权。每分配一次，一个<em class="kb">引用计数</em>就增加一个，表示数据多了一个所有者。当指针超出范围或所有者调用<code class="du kc kd ke kf b">reset</code>时，引用计数递减。当引用计数变为 0 时，指向的数据被释放。使用<code class="du kc kd ke kf b">make_shared</code>:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="cd36" class="ko ig hi kf b fi kp kq l kr ks">auto person = std::make_shared&lt;Person&gt;();<br/>if(person)<br/>{<br/>    cout &lt;&lt; "Person's address is " &lt;&lt; person-&gt;address;<br/>}</span></pre><p id="8f92" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">C++17 允许使用共享指针指向动态分配的数组。但是，<code class="du kc kd ke kf b">make_shared</code>不能用。下面是一个例子:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="33cc" class="ko ig hi kf b fi kp kq l kr ks">shared_ptr&lt;Person[]&gt; persons(new Person[10]);<br/>persons[0]._name = "Jack Sparrow";<br/>persons[0]._address = "Caribbean";<br/>cout &lt;&lt; "Address of first person "&lt;&lt;persons[0].address &lt;&lt; endl;</span></pre><p id="9da0" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">一个更好的解决方案是使用<code class="du kc kd ke kf b">std::vector</code>，因为它可以动态地增长和收缩。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="5436" class="ko ig hi kf b fi kp kq l kr ks">std::vector&lt;std::shared_ptr&lt;Person&gt;&gt; persons;<br/>auto person1 = std::make_shared&lt;Person&gt;("Jack Sparrow","Caribbean");<br/>auto person2 = std::make_shared&lt;Person&gt;("Hector Barbossa","Bahamas");<br/>persons.push_back(person1);<br/>persons.push_back(person2);</span><span id="52ed" class="ko ig hi kf b fi ky kq l kr ks">for (auto&amp; person : persons)<br/>{<br/>    std::cout &lt;&lt; "Person name is " &lt;&lt; person-&gt;_name &lt;&lt; " and address is " &lt;&lt; person-&gt;_address &lt;&lt; "\n";<br/>}</span></pre><h1 id="e76a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">常数</h1><p id="00ce" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kc kd ke kf b">const</code>的第一个用途是声明和定义一旦初始化就不能改变的值。这些宏取代了 c 语言中的<code class="du kc kd ke kf b">#define</code>宏常量。例如:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="3b9e" class="ko ig hi kf b fi kp kq l kr ks">const double PI = 3.14;<br/>const int NUMVALUES = 42;<br/>const std::string quote = "To be or not to be";</span></pre><h2 id="b63c" class="ko ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">参数常量</h2><p id="a696" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第二个可以使用的地方是确保参数不能被修改。例如，如果一个函数带有一个<code class="du kc kd ke kf b">int*</code>指针，那么用<code class="du kc kd ke kf b">const</code>传递指针可以确保函数不会改变值。示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="fd72" class="ko ig hi kf b fi kp kq l kr ks">int main()<br/>{<br/>    int num = 5;<br/>    int *val = &amp;num;<br/>    foo(val);<br/>}</span><span id="0c94" class="ko ig hi kf b fi ky kq l kr ks">void foo(const int* value)<br/>{<br/>    *value = 6; //will fail to  compile<br/>}</span></pre><h1 id="b95e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><p id="4f89" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">引用是现有变量的别名。示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="6f80" class="ko ig hi kf b fi kp kq l kr ks">double aDouble = 3.14<br/>double&amp; refToDouble = aDouble;</span></pre><p id="cbc6" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">引用的特殊之处在于，人们仍然像使用普通变量一样使用它们，但在幕后，它们是指向原始变量的“指针”。因此，修改引用与修改原始变量是一样的。上接示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="44e6" class="ko ig hi kf b fi kp kq l kr ks">refToDouble = 6.0;<br/>cout &lt;&lt; "Double value is " &lt;&lt; aDouble &lt;&lt; endl; //prints out 6.0</span></pre><h2 id="9b4e" class="ko ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">通过引用传递</h2><p id="e911" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当参数被传递给函数时，变量的一个<em class="kb">副本</em>被制作，该副本在函数内被修改。为了修改原始变量，C 习语将一个<em class="kb">指针</em>传递给变量。示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="6eb7" class="ko ig hi kf b fi kp kq l kr ks">int main()<br/>{<br/>    int x = 5;<br/>    int y = 3;<br/>    swap(&amp;x, &amp;y);<br/>    printf("x is %d and y is %d",x,y); //prints out 3 and 5<br/>}<br/>void swap(int *a , int *b)<br/>{<br/>    int temp;<br/>    temp = *a;<br/>    *a = *b;<br/>    *b = temp;<br/>}</span></pre><p id="152f" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">C++通过使用<em class="kb">引用传递</em>来避免使用指针。在 C++中，相同的交换函数实现如下:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="e368" class="ko ig hi kf b fi kp kq l kr ks">int main()<br/>{<br/>    int a = 2;<br/>    int b = 3;<br/>    swap(a,b);<br/>}<br/>void swap(int &amp;a , int &amp;b)<br/>{<br/>    int temp;<br/>    temp = a;<br/>    a = b;<br/>    b = temp;<br/>}</span></pre><p id="0f1f" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">注意，语法允许引用作为普通变量使用，但是原始变量被修改了。</p><p id="aa04" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">当返回一个大的结构或类对象时，传统的习语是传入一个对结构或对象的非常数引用，并让函数修改它。C++11 移动语义消除了这种需要。</p><p id="4862" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">通过<code class="du kc kd ke kf b">const</code>参考</p><p id="5bcc" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">当你需要有效地传递一个值给一个函数，但确保它不被修改时，使用 pass by <code class="du kc kd ke kf b">const</code>引用。示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="353f" class="ko ig hi kf b fi kp kq l kr ks">void foo(const int&amp; a)<br/>{ <br/>    int b = a * 2;<br/>    a++; //compiler will throw an error here as one attempts to modify a.<br/>}</span></pre><p id="c37a" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">当通过<code class="du kc kd ke kf b">const</code>引用传递<code class="du kc kd ke kf b">std::string</code>时，传入字符串文字有效。</p><h1 id="9be7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">类型推理</h1><p id="5b25" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">类型推断是编译器推断表达式类型的机制。两个关键字，<code class="du kc kd ke kf b">auto</code>和<code class="du kc kd ke kf b">decltype</code>在 C++中用于类型推断。<code class="du kc kd ke kf b">auto</code>用法如下:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="8361" class="ko ig hi kf b fi kp kq l kr ks">auto x = 2 + 3;</span></pre><p id="349c" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">当处理函数返回的复杂类型时，使用<code class="du kc kd ke kf b">auto</code>的优势变得很明显。注意，使用<code class="du kc kd ke kf b">auto</code>去掉了引用和常量引用限定符并进行复制，所以如果一个函数返回一个引用，一定要使用<code class="du kc kd ke kf b">auto&amp;</code>。类似地，使用<code class="du kc kd ke kf b">const auto&amp;</code>作为<code class="du kc kd ke kf b">const</code>参考。</p><p id="60ef" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="0366" class="ko ig hi kf b fi kp kq l kr ks">int&amp; bar()<br/>{ <br/>    int* dynInt = new int;<br/>    *dynInt = 5;<br/>    return *dynInt;<br/>}</span><span id="32b5" class="ko ig hi kf b fi ky kq l kr ks">auto retVal = bar(); //A copy is made here. Use auto&amp; instead.</span></pre><p id="f696" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><code class="du kc kd ke kf b">decltype</code>将表达式作为参数，并推断该表达式的类型。优点是引用和常量引用不会被剥离。示例:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="b2ae" class="ko ig hi kf b fi kp kq l kr ks">decltype(bar()) retVal = bar();</span></pre><h1 id="ccd6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">班级</h1><p id="ebc5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个类模拟真实世界和抽象对象，可以被看作是制作对象的蓝图。类是在头文件中声明的。h)文件及其定义位于. cpp 文件中。下面是一个类的示例:</p><p id="ff36" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><code class="du kc kd ke kf b">checkingaccount.h</code>:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="2189" class="ko ig hi kf b fi kp kq l kr ks">#ifndef BANKACCOUNT_H<br/>#define BANKACCOUNT_H<br/>#include &lt;string&gt;<br/>using std::string;<br/>class CheckingAccount <br/>{ <br/>    public:<br/>        CheckingAccount(string accountHolder, string accountNumber, double balance);<br/>        double getBalance() const;<br/>        string getAccountHolder() const;<br/>        string getAccountNumber() const;<br/>        void deposit(double amount);<br/>        string withdraw(double amount);<br/>        ~CheckingAccount();</span><span id="a740" class="ko ig hi kf b fi ky kq l kr ks">    private:<br/>        string mAccountHolder;<br/>        string mAccountNumber;<br/>        double mBalance;<br/>}<br/>#endif</span></pre><p id="3fb0" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><code class="du kc kd ke kf b">checkingaccount.cpp</code>:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="6e76" class="ko ig hi kf b fi kp kq l kr ks">#include "checkingaccount.h"</span><span id="2e4a" class="ko ig hi kf b fi ky kq l kr ks">CheckingAccount::CheckingAccount(string accountHolder, string accountNumber, double balance)<br/>{ <br/>    mAccountHolder = accountHolder;<br/>    mAccountNumber = accountNumber;<br/>    mBalance = balance;<br/>}</span><span id="795d" class="ko ig hi kf b fi ky kq l kr ks">double CheckingAccount::getBalance() const<br/>{<br/>    return mBalance;<br/>}</span><span id="fcd1" class="ko ig hi kf b fi ky kq l kr ks">string CheckingAccount::getAccountHolder() const<br/>{<br/>    return mAccountHolder;<br/>}</span><span id="ab29" class="ko ig hi kf b fi ky kq l kr ks">string CheckingAccount::getAccountNumber() const<br/>{<br/>    return mAccountNumber;<br/>}</span><span id="bbea" class="ko ig hi kf b fi ky kq l kr ks">void CheckingAccount::deposit(double amount)<br/>{<br/>    mBalance += amount;<br/>}</span><span id="8320" class="ko ig hi kf b fi ky kq l kr ks">string CheckingAccount::withdraw(double amount)<br/>{<br/>    if(mBalance - amount &lt;= 0.0)<br/>    {<br/>        return "Insufficient Funds";<br/>    }<br/>    mBalance -= amount;<br/>    return "Amount withdrawn successfully";<br/>}</span><span id="9f53" class="ko ig hi kf b fi ky kq l kr ks">CheckingAccount::~CheckingAccount()<br/>{<br/>    //no cleanup for this case<br/>}</span></pre><p id="e0e8" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj">构造函数</strong>是一个与没有返回类型的类同名的方法。当在堆栈或堆上初始化一个对象时调用它。当堆栈上的对象超出范围时，或者当在堆分配的对象上调用<code class="du kc kd ke kf b">delete</code>时，调用<strong class="jf hj">析构函数</strong>。构造函数负责初始化类，而析构函数负责清理，包括关闭文件句柄、释放对象分配的内存等等。这是标有<code class="du kc kd ke kf b">~</code>的功能。</p><p id="438c" class="pw-post-body-paragraph jd je hi jf b jg kt ji jj jk ku jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><strong class="jf hj">构造函数初始化器</strong>是首选的初始化方法。其语法如下:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="ef00" class="ko ig hi kf b fi kp kq l kr ks">CheckingAccount::CheckingAccount(string accountHolder, long accountNumber, double balance)<br/>    :mAccountHolder(accountHolder),<br/>     mAccountNumber(accountNumber),<br/>     mBalance(balance)<br/>{ <br/>}</span></pre><h2 id="0d48" class="ko ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">使用类</h2><p id="1910" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用类的示例如下:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="cea4" class="ko ig hi kf b fi kp kq l kr ks">#include "checkingaccount.h"<br/>#include &lt;memory&gt;<br/>using std::unique_ptr;<br/>using std::cout;<br/>using std::endl;</span><span id="f67c" class="ko ig hi kf b fi ky kq l kr ks">int main()<br/>{<br/>    CheckingAccount chkAcnt("Jack Sparrow","61723",10000); //allocated on the stack.<br/>    chkAcnt.deposit(100.0);<br/>    chkAcnt.withdraw(50.0);<br/>    auto chkAccntTwo = make_unique&lt;CheckingAccount&gt;("Hector Barbossa",61724,10000);<br/>    chkAccntTwo-&gt;deposit(1000.00);<br/>    chkAccntTwo-&gt;withdraw(5000.00);<br/>    cout &lt;&lt; chkAccountTwo.getAccountHolder() &lt;&lt;"'s balance is "&lt;&lt; chkAccntTwo-&gt;getBalance() &lt;&lt; endl;<br/>} //chkAcnt destructor is called here. chkAccntTwo destructor also called here as unique_ptr goes out of scope.</span></pre><h1 id="0aaa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考资料:</h1><p id="8b60" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">m .格雷瓜尔(2018)。<em class="kb">专业 C++ </em>。印第安纳州:约翰·威利&amp;之子。</p><div class="lm ln ez fb lo lp"><a href="https://codingadventures1.blogspot.com/2020/02/c-tour-part-iii.html" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">C++教程第三部分</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">共享指针是一种智能指针，允许数据的分布式所有权。每次它被赋值时，一个…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md me lp"/></div></div></a></div></div></div>    
</body>
</html>