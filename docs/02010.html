<html>
<head>
<title>Leaf Disease Detection (Using FR-CNN and UNet)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">叶部疾病检测(使用FR-CNN和UNet)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/leaf-disease-detection-using-frcnn-fff55a537634?source=collection_archive---------3-----------------------#2019-11-26">https://medium.com/analytics-vidhya/leaf-disease-detection-using-frcnn-fff55a537634?source=collection_archive---------3-----------------------#2019-11-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">农业生产率是经济高度依赖的东西。这是植物中的疾病检测在农业领域中起重要作用的原因之一，因为植物中有疾病是很自然的。如果在这方面没有采取适当的措施，就会对工厂造成严重的影响，从而影响相应的产品质量、数量或生产率。</p><p id="4c0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过一些自动技术检测植物疾病是有益的，因为它减少了大农场的大量监测工作，并且在非常早期阶段本身就检测疾病的症状，即当它们出现在植物叶子上时。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/434f36eab225ea24f632f9384eb82467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dTgACN60TJ3krYA7mZ8zg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">来源:谷歌图片</figcaption></figure><p id="a920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于这项任务，我们将使用一个数据集，其中包含带有标记疾病类型的各种叶片图像。</p><h1 id="c311" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用的方法:-</h1><p id="4ecc" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">(1)-更快的RCNN <br/> (2)- UNet</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h2 id="13a0" class="ld ju hi bd jv le lf lg jz lh li lj kd iq lk ll kh iu lm ln kl iy lo lp kp lq bi translated"><strong class="ak">数据集描述:</strong></h2><p id="43f3" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj">所以第一步是克隆存储库。</strong></p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="b06f" class="ld ju hi ls b fi lw lx l ly lz"><a class="ae ma" href="https://github.com/aldrin233/RiceDiseases-DataSet" rel="noopener ugc nofollow" target="_blank">https://github.com/aldrin233/RiceDiseases-DataSet</a>.git</span></pre><p id="88ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们首先分析我们正在处理哪种数据。<br/>克隆git repo后，我们剩下三个文件夹——白叶枯病、稻瘟病、褐斑病。</p><p id="9e39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目录的结构如下-</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="857e" class="ld ju hi ls b fi lw lx l ly lz">./Bacterial Leaf Blight<br/>   ./Orig<br/>   ./Rotated<br/>./Blast<br/>   ./Orig<br/>   ./Rotated<br/>./Brownspot<br/>   ./Orig<br/>   ./Rotated</span></pre><p id="e7c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，每个类别文件夹都有包含原始图像和旋转图像的子文件夹。</p><p id="b799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将疾病分为三类。让我们来看看每个类别中的几个例子，看看这些图片是什么样子的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/3d4d478cc31b78710e07c3ef426cd5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkBZv3FCOqiPNElveUX9RA.jpeg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/b80195cdee9ab8f24e8766d6abe72b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsivHa3JRuuUM3xZKQGd0g.jpeg"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/39a862ac69146abddc728f99d76f4b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXBh2S0EfQz8UfWxloAeyg.jpeg"/></div></div></figure><p id="7128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们可以观察到:-</p><p id="0f51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(a)-枯萎病类可以很容易地分类，因为它的标记分布在一个大的区域。</p><p id="8ae6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(b)-爆炸和褐色斑点可能很难区分，因为斑点很小，而且彼此非常相似。但是让我们深入研究一下。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/da86e8c6ac068b83740e1fff665e02f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*ck0NC_zgr7n6CIp8NFwudA.jpeg"/></div></figure><p id="fb20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(c)-与其他两个类别相比，这里的爆炸类别包含较少的图像。</p><p id="b30e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(d)-枯萎类的包围盒总数少于其他两类。所以我们必须在后期进行数据扩充。</p><p id="7dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等等，在git repo中，他们也为我们提供了xml文件，其中包含每个点的边界框。让我们调查一下。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/10867a316a4d26cc198a0206210504fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvB8c3E-oocIKZqUmzaDOw.jpeg"/></div></div></figure><p id="567b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们的目标是对每个点的类和包围盒进行分类。为了做到这一点，我们可能会想到使用CNN，但是一个典型的CNN只能告诉你物体的类别，而不能告诉你它们的位置。所以我们将使用一个特殊的类RCNN。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="eebc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">R-CNN家族中有不同的算法(R-CNN、快速R-CNN和更快R-CNN)。最新的是面具R-CNN。R-CNN使用选择性搜索从给定图像中提取一系列区域，然后检查这些框中是否包含物体。我们首先提取这些区域，对于每个区域，使用CNN提取特定的特征。最后，这些特征然后被用于检测物体。不幸的是，R-CNN变得相当慢，因为这一过程涉及多个步骤。另一方面，快速R-CNN将整个图像传递给生成感兴趣区域的ConvNet(而不是传递从图像中提取的区域)。此外，它不是使用三个不同的模型，而是使用单个模型，该模型从区域中提取特征，将它们分类到不同的类中，并返回边界框。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mg"><img src="../Images/86c03996ae1f93759a1584be7236a87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GP5lJ7Srbwckmi5BUxSrCA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">更快的R-CNN</figcaption></figure><p id="fec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更快的R-CNN通过用区域提议网络(RPN)代替它来解决选择性搜索的问题。我们首先使用ConvNet从输入图像中提取特征映射，然后将这些映射传递给RPN，RPN返回对象建议。最后，对这些图进行分类并预测包围盒。</p><p id="a92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想全面深入地了解它们，请点击此链接。</p><p id="8c7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速R-CNN算法检测图像中的对象所遵循的步骤:</p><ol class=""><li id="44b4" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">获取一个输入图像，并将其传递给ConvNet，后者返回该图像的特征映射</li><li id="12b7" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">在这些特征地图上应用区域提议网络(RPN)并获得对象提议</li><li id="d872" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">应用投资回报池层，将所有提案缩小到相同的大小</li><li id="cfcc" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">最后，将这些建议传递给完全连接的层，以便对图像的任何预测边界框进行分类。</li></ol><p id="c723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是地区提案网？</strong></p><p id="cedf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">区域提议网络(RPN)的输出是将由分类器和回归器检查的一堆框/提议，以最终检查对象的出现。更准确的说，RPN预测一个主播是背景还是前景的可能性，对主播进行提炼。换句话说，RPN接受所有的参考框(锚),并输出一组好的对象建议。它通过为每个锚点提供两个不同的输出来实现这一点。<br/>第一个是锚是物体的概率。如果你愿意，可以称之为“客观分数”。注意，RPN并不关心它是什么对象的<em class="mv">类</em>，只关心它实际上看起来像一个对象(而不是背景)。我们将使用这个客观性分数来过滤掉第二阶段的坏预测。第二个输出是边界框回归，用于调整锚点以更好地适应它预测的对象。</p><h2 id="2df6" class="ld ju hi bd jv le lf lg jz lh li lj kd iq lk ll kh iu lm ln kl iy lo lp kp lq bi translated"><strong class="ak">后处理</strong></h2><p id="e8f1" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj">非最大抑制</strong>因为锚点通常会重叠，所以提议最终也会重叠在同一个对象上。为了解决重复建议的问题，我们使用一种简单的算法方法，称为非最大抑制(NMS)。NMS采用按分数排序的提案列表，并在排序的列表上迭代，用具有更高分数的提案丢弃那些IoU大于某个预定义阈值的提案。</p><p id="b123" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">利息集中地区</strong></p><p id="5772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在RPN步骤之后，我们有一堆没有指定类的对象提议。我们下一个要解决的问题是如何把这些包围盒分类到我们想要的类别中。</p><p id="131d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的方法是接受每一个建议，对其进行裁剪，然后通过预先训练好的基础网络进行传递。然后，我们可以使用提取的特征作为普通图像分类器的输入。</p><h2 id="3e08" class="ld ju hi bd jv le lf lg jz lh li lj kd iq lk ll kh iu lm ln kl iy lo lp kp lq bi translated"><strong class="ak">基于区域的卷积神经网络</strong></h2><p id="0144" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">基于区域的卷积神经网络(R-CNN)是更快的R-CNN管道中的最后一步。从图像中获得卷积特征图后，使用它来获得具有RPN的对象提议，并最终为这些提议中的每一个提取特征(通过RoI Pooling)，我们最终需要使用这些特征进行分类。R-CNN试图模仿分类CNN的最后阶段，其中全连接层用于输出每个可能的对象类的分数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/d4ee9962c61580261a7b13a9e41398c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdFAE6k6AVEMklGv7nRo1Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae ma" href="https://tryolabs.com/blog/2018/01/18/faster-r-cnn-down-the-rabbit-hole-of-modern-object-detection/" rel="noopener ugc nofollow" target="_blank">https://tryo labs . com/blog/2018/01/18/faster-r-CNN-down-the-rabbit-hole-of-modern-object-detection/</a></figcaption></figure></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h2 id="88b4" class="ld ju hi bd jv le lf lg jz lh li lj kd iq lk ll kh iu lm ln kl iy lo lp kp lq bi translated">设置系统</h2><p id="8e2d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在我们真正进入模型构建阶段之前，我们需要确保已经安装了正确的库和框架。运行此项目需要以下库:</p><ul class=""><li id="133c" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mx mn mo mp bi translated">熊猫</li><li id="489d" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">matplotlib</li><li id="f744" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">张量流</li><li id="ab9e" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">keras — 2.0.3</li><li id="871c" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">numpy</li><li id="3ef1" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">opencv-python</li><li id="cc64" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">sklearn</li><li id="fa0b" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">h5py</li></ul><h2 id="6e51" class="ld ju hi bd jv le lf lg jz lh li lj kd iq lk ll kh iu lm ln kl iy lo lp kp lq bi translated">实施:-</h2><p id="49e2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">所以我们的第一步是克隆骨骼的官方存储库。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="81f7" class="ld ju hi ls b fi lw lx l ly lz">!git clone <a class="ae ma" href="https://github.com/kbardool/keras-frcnn.git" rel="noopener ugc nofollow" target="_blank">https://github.com/kbardool/keras-frcnn.git</a></span></pre><p id="9ac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据清理:- </strong></p><p id="31a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(一)-一些图像文件没有它们对应的。xml文件。所以它们被移除了。</p><p id="413f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(b)-一些图像具有一些疾病，但是没有出现分割框。xml文件(即它们是空的)也被删除。</p><p id="497b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据预处理:- </strong></p><p id="c439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">框架要求输入数据的格式应该是-</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="c85c" class="ld ju hi ls b fi lw lx l ly lz">filepath,x1,y1,x2,y2,class_name</span></pre><p id="b417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在哪里，</p><ul class=""><li id="d1a0" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mx mn mo mp bi translated"><em class="mv">文件路径</em>是训练图像的路径</li><li id="a802" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated"><em class="mv"> x1 </em>是包围盒的xmin坐标</li><li id="3efe" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated"><em class="mv"> y1 </em>是包围盒的ymin坐标</li><li id="c371" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated"><em class="mv"> x2 </em>是包围盒的xmax坐标</li><li id="bd6e" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated"><em class="mv"> y2 </em>是包围盒的ymax坐标</li><li id="d188" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated"><em class="mv"> class_name </em>是该边界框中的类的名称</li></ul><p id="04fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们准备数据集，并将所有文件拆分到train_images和test_images文件夹中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es my"><img src="../Images/f6a9308d4076166c371e32015d3cab43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6E1LUD0s8e3gZ8tfb3Rrw.jpeg"/></div></div></figure><p id="bc15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的输入数据终于准备好了。现在让我们根据需要更改一些参数。</p><p id="358c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据扩充:- </strong></p><p id="656f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(a)-没有必要进行垂直翻转，因为已经有每个图像的垂直旋转图像。</p><p id="c3af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(b)-以下扩充在data_augment.py中完成</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="fca5" class="ld ju hi ls b fi lw lx l ly lz">-&gt; Horizontal Flips<br/>-&gt; Rotate 90 degree Clockwise <br/>-&gt; Rotate 90 degree Anti-Clockwise<br/>-&gt; Brightness correction</span></pre><p id="87fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用基本网络resnet50训练我的模型。你可以选择VGG或者任何你想要的电视网。<br/> —首先，我在没有预训练权重的情况下训练我的网络resnet，然后用预训练的权重进行训练。最后，我用预训练的重量得到了更好的结果。</p><p id="070d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:-如果你没有任何GPU支持，请不要培训，因为这可能需要几个月才能完成。我为GPU 1050 Ti只跑了2天62/1000个纪元</strong></p><p id="545e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终我实现了95.21%的分类器准确率和0.4356的总损失。</p><p id="7499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你训练更多的纪元，你可以达到更好的准确度。</p><p id="662f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看我们的预测:-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/5c125c376bb5eccb513eeffb4d790563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKhmvs0YhDUpvR1oPexlZg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">爆炸级</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es na"><img src="../Images/3455f8666f9fe4098746cf58dc151263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwxQZHn-watFp9dTheAMIQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">类疫病</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/e1b4fa4b4ba6d72df581a80b7cd05ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2feEOW2h9lbJcUiMt5BqQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">类褐斑病</figcaption></figure><p id="5e1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们可以看到我们的模型做了很好的下降工作。通过更多的训练，成绩可以进一步提高。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="18d7" class="jt ju hi bd jv jw nc jy jz ka nd kc kd ke ne kg kh ki nf kk kl km ng ko kp kq bi translated">UNet</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/f898bd6af8459712d05995ea998e9f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRp8j2h8E98jiWtOy_LKkQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae ma" href="http://lmb.informatik.uni-freiburg.de/Publications/2015/RFB15a/" rel="noopener ugc nofollow" target="_blank">http://lmb . informatik . uni-freiburg . de/Publications/2015/rfb 15 a/</a></figcaption></figure><p id="b76f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">U-net是用于图像分割的编码器-解码器型网络架构。该架构的名称来自其独特的形状，其中来自下采样步骤中卷积部分的特征映射被馈送到上采样步骤中的上卷积部分。U-net已广泛用于生物医学应用，以检测癌症、肾脏病变和跟踪细胞等。在数据有限的情况下(在某些情况下少于50个训练样本)，U-net已被证明是非常强大的细分工具。使用U-net的另一个优点是它没有任何完全连接的层，因此对输入图像的大小没有限制。这个特征允许我们从不同大小的图像中提取特征，这是将深度学习应用于高保真生物医学成像数据的一个有吸引力的属性。U-net能够处理非常少的数据，并且对输入图像大小没有特殊要求，这使得它成为图像分割任务的强有力候选。</p><p id="6c09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将修改它，以用于叶部疾病检测。</p><p id="e956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">U-net的输入是调整了大小的256X256 3通道RGB图像，输出是预测的256X256 1通道掩码。</p><p id="3bcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据准备:- </strong></p><ul class=""><li id="1bae" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mx mn mo mp bi translated">这些图像保存在单独的<em class="mv"> train_images </em>文件夹中。</li><li id="96b8" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">来自的边界框。xml文件被转换成掩模图像并存储在<em class="mv"> train_masks </em>文件夹中。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ni"><img src="../Images/dba9fc7b1bc65483142c0bb10fa2fac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zW-iKHpRxoOMYRgq9ot4UQ.jpeg"/></div></div></figure><p id="9735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据扩充:- </strong></p><p id="9461" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进行了以下扩充:</p><ul class=""><li id="2186" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mx mn mo mp bi translated">翻转(垂直、水平、双向)</li><li id="780d" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">锐化图像</li><li id="b7ba" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">添加噪声</li></ul><p id="58b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还根据列车图像的增强来增强遮罩。</p><p id="89ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">培训:- </strong></p><div class="je jf jg jh fd ab cb"><figure class="nj ji nk nl nm nn no paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/7bc32834e8e2e9057be21aff200ae24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*RfgBCZt6troZYD23dmWKdg.jpeg"/></div></figure><figure class="nj ji np nl nm nn no paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/d51472de3b7949116efc4145500a8eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*Q02l0LvdqF68mNTGblWUog.jpeg"/></div></figure></div><p id="6bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模型在批量大小为4的GTX 1050 Ti上进行训练(由于ResourceExhaustError而无法走高)。它被训练了10个纪元。<br/>我们使用自定义指标作为ROI。我们在keras中定义了一个自定义目标函数来计算网络输出和目标掩码之间的近似交集(IoU)。对于涉及边界框的任务，IoU是一种流行的度量标准。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nq"><img src="../Images/999c43ac6c2c08c926804bd5701cf6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_k0tQETECk6fcxWaQl9dQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae ma" href="https://chatbotslife.com/small-u-net-for-vehicle-detection-9eec216f9fd6" rel="noopener ugc nofollow" target="_blank">https://chatbotslife . com/small-u-net-for-vehicle-detection-9 EEC 216 F9 FD 6</a></figcaption></figure><p id="12ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据测试数据，我们得到了大约0.916 IOU。</p><h1 id="c976" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结果:-</h1><div class="je jf jg jh fd ab cb"><figure class="nj ji nr nl nm nn no paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/a06ccc48bd02526dcc38c9abba2ff677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*6MzEyXEsOz8yS0Q5BvktzA.jpeg"/></div></figure><figure class="nj ji ns nl nm nn no paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/2599939622d6f24c76b8402bd7511047.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*rhprywGeSHD7hxAaxBaAQw.jpeg"/></div></figure></div><div class="ab cb"><figure class="nj ji nt nl nm nn no paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/8ad20be39cf4b6fd4aada862b6fc903b.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*Eh_JFq1mhe43bPS9A-RZLA.jpeg"/></div></figure><figure class="nj ji nu nl nm nn no paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/39edc59a81463004225bd20a8dc93873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*LXmCUrDo_WNyJK2BTcEZhQ.jpeg"/></div></figure></div><p id="802d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们观察到，我们的模型在分割图像方面比fast-RCNN做得更好。</p><ul class=""><li id="9e3b" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mx mn mo mp bi translated">注意UNet是用于像素到像素的分割，但是在我们的例子中，没有像素方式的输入遮罩，所以我们从提供给我们的边界框中创建遮罩。</li><li id="4834" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">我们不能相信IOU，因为我们的模型可能比预期的做得更好。</li><li id="3827" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">我们创建的遮罩包含不包含疾病部分的图像像素，并且一些遮罩甚至没有覆盖受疾病影响的整个像素。</li><li id="8e94" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">如果我们看看我们的预测，那么我们的模型主要分割了疾病影响的部分，也分割了一些不在地面真相框中的像素。</li><li id="38db" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">我们的模型做得非常好，因为它已经学会识别受疾病影响的部分。</li><li id="e385" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mx mn mo mp bi translated">我们可以通过为更多的时代训练它，增加更多的技术，如果可能的话，还可以获得一个更好的标记数据集，来进一步使它准确。</li></ul><p id="8ef6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进一步的实施细节请检查我的<a class="ae ma" href="https://github.com/Abhaya1998" rel="noopener ugc nofollow" target="_blank">库</a>。</p><h1 id="4f7e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结束注释</h1><p id="c65c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">R-CNN算法已经真正成为物体探测任务的游戏规则改变者。近年来，计算机视觉应用程序的数量突然激增，R-CNN是其中大多数的核心。</p><p id="720e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Unet证明了自己是一个优秀的图像分割架构。</p><p id="ea54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mv"> Keras_frcnn </em>被证明是一个优秀的对象检测库。</p></div></div>    
</body>
</html>