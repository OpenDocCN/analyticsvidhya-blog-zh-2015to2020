<html>
<head>
<title>Face Detection with Python using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV的Python人脸检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/face-detection-with-python-using-opencv-fb563e51e3c0?source=collection_archive---------10-----------------------#2020-09-22">https://medium.com/analytics-vidhya/face-detection-with-python-using-opencv-fb563e51e3c0?source=collection_archive---------10-----------------------#2020-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bd4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程将向您介绍使用OpenCV库在Python中进行对象检测的概念，以及如何利用它来执行面部检测等任务。</p><h1 id="5c05" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">介绍</h1><p id="819c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">人脸检测是一种计算机视觉技术，有助于在数字图像中定位/可视化人脸。该技术是<a class="ae kg" href="https://en.wikipedia.org/wiki/Object_detection" rel="noopener ugc nofollow" target="_blank">对象检测技术</a>的一个具体用例，该技术处理在数字图像和视频中检测某类语义对象(如人、建筑物或汽车)的实例。随着技术的发展，人脸检测变得越来越重要，尤其是在摄影、安全和营销等领域。</p><h1 id="084b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">先决条件</h1><p id="fc85" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在研究OpenCV的概念之前，Numpy和Matplotlib的实践知识是必不可少的。在安装OpenCV之前，请确保您已经安装并运行了以下软件包。</p><ul class=""><li id="aaf1" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae kg" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">巨蟒</a></li><li id="e635" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Numpy</li><li id="2e6f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Matplotlib</li></ul><h1 id="81ca" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">目录</h1><ol class=""><li id="8a03" class="kh ki hi ih b ii kb im kc iq kv iu kw iy kx jc ky kn ko kp bi translated"><a class="ae kg" href="https://www.datacamp.com/community/tutorials/face-detection-python-opencv#opencv-python" rel="noopener ugc nofollow" target="_blank"> OpenCV-Python </a></li></ol><ul class=""><li id="66ab" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">1.概观</li><li id="c462" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">2.装置</li></ul><p id="6a30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<a class="ae kg" href="https://www.datacamp.com/community/tutorials/face-detection-python-opencv#images-as-arrays" rel="noopener ugc nofollow" target="_blank">图像作为数组</a></p><ul class=""><li id="50e0" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">二进制映象</li><li id="a903" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">灰度图像</li><li id="164d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">彩色图像</li></ul><p id="5844" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://www.datacamp.com/community/tutorials/face-detection-python-opencv#images-and-opencv" rel="noopener ugc nofollow" target="_blank"> 3。图像和OpenCV </a></p><ul class=""><li id="b411" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">在OpenCV中导入图像</li><li id="a91f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">储蓄图像</li><li id="b658" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">对图像的基本操作</li></ul><p id="976d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://www.datacamp.com/community/tutorials/face-detection-python-opencv#face-detection" rel="noopener ugc nofollow" target="_blank"> 4。面部检测</a></p><ul class=""><li id="4d18" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">概观</li><li id="fad4" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">基于Haar特征的级联分类器</li><li id="37e0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">基于OpenCV-Python的人脸检测</li></ul><p id="5975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://www.datacamp.com/community/tutorials/face-detection-python-opencv#conclusion" rel="noopener ugc nofollow" target="_blank"> 5。结论</a></p><h1 id="20c8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.OpenCV-Python</h1><h1 id="2381" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">概观</h1><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es kz"><img src="../Images/66824190034a6e70c1002191365c319c.png" data-original-src="https://miro.medium.com/v2/resize:fit:208/format:webp/0*ddPhRMlXKEF0jszX.png"/></div></figure><p id="cac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>由<strong class="ih hj"> Gary Bradsky </strong>于1999年在英特尔创立。第一次发布是在2000年稍晚的时候。OpenCV本质上代表<strong class="ih hj">开源计算机视觉库</strong>。虽然它是用优化的C/C++编写的，但是它有Python和Java以及C++的接口。OpenCV在全世界拥有活跃的用户群，由于计算机视觉应用的激增，其使用日益增加。</p><p id="960c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV-Python是OpenCV的Python API。你可以把它看作是OpenCV的C++实现的python包装器。OpenCV-Python不仅速度快(因为后台包含用C/C++编写的代码)，而且易于编码和部署(因为前台有Python包装器)。这使得它成为执行计算密集型程序的最佳选择。</p><h1 id="652a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">装置</h1><p id="9e9b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">OpenCV-Python支持所有主流平台，如Mac OS、Linux和Windows。它可以通过以下任一方式安装:</p><p id="b44e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。从预构建的二进制文件和源代码</strong>:</p><p id="f57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参考详细文档<a class="ae kg" href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_setup/py_setup_in_windows/py_setup_in_windows.html" rel="noopener ugc nofollow" target="_blank">此处</a>为Windows，此处<a class="ae kg" href="https://www.pyimagesearch.com/2016/12/19/install-opencv-3-on-macos-with-homebrew-the-easy-way/" rel="noopener ugc nofollow" target="_blank">为Mac。</a></p><p id="b867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> 2。非官方</strong>为Python预建的OpenCV包</a>。</p><p id="b5a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标准桌面环境的软件包(Windows，macOS，几乎所有的GNU/Linux发行版)</p><ul class=""><li id="2638" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">如果只需要主模块，运行<code class="du lh li lj lk b">pip install opencv-python</code></li><li id="501f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">如果需要main和contrib模块，运行<code class="du lh li lj lk b">pip install opencv-contrib-python</code>(查看OpenCV文档<a class="ae kg" href="https://docs.opencv.org/master/" rel="noopener ugc nofollow" target="_blank">中的额外模块列表</a></li></ul><p id="d59e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用Jupyter笔记本或您选择的任何Python IDE来编写脚本。</p><h1 id="4084" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.图像作为数组</h1><p id="f257" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">图像只不过是包含数据点像素的标准Numpy数组。图像的像素越多，分辨率就越高。你可以认为像素是以二维网格形式排列的微小信息块，像素的深度是指其中存在的颜色信息。为了被计算机处理，图像需要被转换成二进制形式。图像的颜色可以计算如下:</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="4424" class="lp je hi lk b fi lq lr l ls lt">Number of colors/ shades = 2^bpp where bpp represents bits per pixel.</span></pre><p id="89e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自然，位数/像素数越多，图像中可能的颜色就越多。下表更清楚地显示了这种关系。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lu"><img src="../Images/6a548fd2fa18de24598a2b1e07710ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*Mrko0M5B6f5Q30Z5.png"/></div></figure><h1 id="8cd6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">现在让我们看看不同种类的图像的表示:</h1><h1 id="90e7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.二进制映象</h1><p id="448f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">二进制图像由1比特/像素组成，因此只能有两种可能的颜色，即黑色或白色。黑色由值0表示，而1表示白色。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lv"><img src="../Images/d68a7e4334eb8041bc2b0e806db3fe3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/0*ch7tzXHYzthPgh0j.png"/></div></figure><h1 id="6e5a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.灰度图像</h1><p id="2657" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">灰度图像由每像素8位组成。这意味着它可以有256种不同的色调，其中0像素代表黑色，而255代表白色。例如，下图显示了以数组形式表示的灰度图像。灰度图像只有一个通道，其中通道代表一个维度。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/d4ccae17feaac4cd7bcfbfd0b7cfa6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*Td1KxHmaEUWIyxGr.png"/></div></figure><h1 id="f2a2" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.彩色图像</h1><p id="566f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">彩色图像由红色、蓝色和绿色组合而成，所有其他颜色都可以通过将这些原色以正确的比例混合来实现。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lx"><img src="../Images/af947364490c3505eeab938f5b42b09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/0*zgHWLzb6t7eu69PG.png"/></div></figure><p id="8418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">彩色图像也由每像素8位组成。因此，256种不同色调的颜色可以用0表示黑色，255表示白色来表示。让我们看看著名的山魈彩色图像，它在许多图像处理例子中被引用。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ly"><img src="../Images/240110c75bfeecb0323b17a1c8faafd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/0*zLm4a3rPLeF4hCt4.png"/></div></figure><p id="c625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们检查上图的形状，我们会得到:</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="fc1f" class="lp je hi lk b fi lq lr l ls lt">Shape<br/>(288, 288, 3)<br/>288: Pixel width<br/>288: Pixel height<br/>3: color channel</span></pre><p id="a592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们可以用三维数组的形式来表示上面的图像。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lz"><img src="../Images/38dac5e7a62f74447bf7197d8195876e.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*vLw_mq6z_tVcnANj.png"/></div></figure><h1 id="f5cd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.图像和OpenCV</h1><p id="fffd" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在我们进入人脸检测过程之前，让我们学习一些关于使用OpenCV的基础知识。在本节中，我们将使用OpenCV对图像执行简单的操作，如打开图像、在图像上绘制简单的形状，以及通过回调与图像进行交互。这是必要的，以创建一个基础，然后我们再走向高级的东西。</p><h1 id="fc87" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在OpenCV中导入图像</h1><h1 id="ddde" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用Jupyter笔记本</h1><p id="0b3c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">步骤:</strong></p><ul class=""><li id="bef3" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">导入必要的库</strong></li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="939b" class="lp je hi lk b fi lq lr l ls lt">import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><ul class=""><li id="a9eb" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">使用<strong class="ih hj"> imread </strong>功能读入图像。我们将使用彩色的“山魈”图像进行演示。可以从<a class="ae kg" href="https://github.com/parulnith/Face-Detection-in-Python-using-OpenCV/blob/master/opening%20images%20with%20opencv/mandrill_colour.png" rel="noopener ugc nofollow" target="_blank">这里</a>下载</li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="ae61" class="lp je hi lk b fi lq lr l ls lt">img_raw = cv2.imread('image.jpg')</span></pre><ul class=""><li id="627c" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">阵列的类型和形状。</strong></li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="cb09" class="lp je hi lk b fi lq lr l ls lt">type(img_raw)<br/>numpy.ndarray</span><span id="256a" class="lp je hi lk b fi ma lr l ls lt">img_raw.shape<br/>(1300, 1950, 3)</span></pre><p id="4393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此。png图像被转换成一个形状为1300x1950的NumPy数组，有3个通道。</p><ul class=""><li id="e846" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">查看图像</strong></li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="cdf5" class="lp je hi lk b fi lq lr l ls lt">plt.imshow(img_raw)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mb"><img src="../Images/fe27bba8a744727fd531c8c99dfabf4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*J2a2_WozDVMPatJI.png"/></div></figure><p id="61d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于颜色，我们得到的输出有点不同。我们期望得到一个亮色的图像，但是我们得到的是一个略带蓝色的图像。这是因为OpenCV和matplotlib的原色顺序不同。OpenCV读取BGR格式的图像，而matplotlib遵循RGB的顺序。因此，当我们通过OpenCV读取一个文件时，我们就好像它包含蓝色、绿色和红色的通道一样。然而，当我们使用matplotlib显示图像时，红色和蓝色通道被交换，从而得到蓝色色调。为了避免这个问题，我们将使用<code class="du lh li lj lk b">cvtColor</code>函数将通道转换为matplotlib期望的方式。</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="361b" class="lp je hi lk b fi lq lr l ls lt">img = cv2.cvtColor(img_raw, cv2.COLOR_BGR2RGB)<br/>plt.imshow(img_rgb)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ly"><img src="../Images/a750e24f1ac597db48523a64c848347d.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/0*ZTf_0JQ-dWyUHbgQ.png"/></div></figure><h1 id="4c4c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用Python脚本</h1><p id="c8e9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Jupyter笔记本非常适合学习，但在处理复杂的图像和视频时，我们需要在自己单独的窗口中显示它们。在本节中，我们将把代码作为一个. py文件来执行。您可以使用Pycharm、Sublime或您选择的任何IDE来运行下面的脚本。</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="c3a7" class="lp je hi lk b fi lq lr l ls lt">import cv2<br/>img = cv2.imread('image.jpg')<br/>while True:<br/>    cv2.imshow('mandrill',img)</span><span id="8964" class="lp je hi lk b fi ma lr l ls lt">    if cv2.waitKey(1) &amp; 0xFF == 27:<br/>        break<br/></span><span id="9c48" class="lp je hi lk b fi ma lr l ls lt">cv2.destroyAllWindows()</span></pre><p id="7f5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这段代码中，我们有一个条件，只有当条件为真时，才会显示图像。此外，要打破这个循环，我们需要满足两个条件:</p><ul class=""><li id="6da5" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae kg" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" rel="noopener ugc nofollow" target="_blank"> cv2.waitKey() </a>是一个键盘绑定函数。它的参数是以毫秒为单位的时间。该函数为任何键盘事件等待指定的毫秒数。如果您在这段时间内按下任何键，程序将继续运行。</li><li id="628b" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">第二个条件与按下键盘上的Escape键有关。因此，如果已经过了1毫秒并按下了escape键，循环将会中断，程序将会停止。</li><li id="03d6" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae kg" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" rel="noopener ugc nofollow" target="_blank"> cv2.destroyAllWindows() </a>干脆把我们创建的所有窗口都毁掉。如果您想要销毁任何特定的窗口，请使用函数<strong class="ih hj"> cv2.destroyWindow() </strong>，在这里您可以将确切的窗口名称作为参数传递。</li></ul><h1 id="4cb1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">储蓄图像</h1><p id="58fa" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">图像可以保存在工作目录中，如下所示:</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="0286" class="lp je hi lk b fi lq lr l ls lt">cv2.imwrite('final_image.png',img)</span></pre><p id="04a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中，最终图像是要保存的图像的名称。</p><h1 id="9f29" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">对图像的基本操作</h1><p id="6a21" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这一节中，我们将学习如何在现有图像上绘制各种形状，以体验使用OpenCV的乐趣。</p><h1 id="f814" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在图像上绘图</h1><ul class=""><li id="8665" class="kh ki hi ih b ii kb im kc iq kv iu kw iy kx jc km kn ko kp bi translated">首先导入必要的库。</li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="3893" class="lp je hi lk b fi lq lr l ls lt">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>import cv2</span></pre><ul class=""><li id="3778" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">创建一个黑色图像作为模板。</li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="b139" class="lp je hi lk b fi lq lr l ls lt">image_blank = np.zeros(shape=(512,512,3),dtype=np.int16)</span></pre><ul class=""><li id="e2e5" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">显示黑色图像。</li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="b64d" class="lp je hi lk b fi lq lr l ls lt">plt.imshow(image_blank)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mc"><img src="../Images/8884ac749f0e5b758018d1d1c1f959cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/0*QAXYfCqWTyYqu6-4.png"/></div></figure><h1 id="8bca" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">功能和属性</h1><p id="7244" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在图像上绘制形状的通用函数是:</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="48d1" class="lp je hi lk b fi lq lr l ls lt">cv2.shape(line, rectangle etc)(image,Pt1,Pt2,color,thickness)</span></pre><p id="5506" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在函数中传递一些常见的参数，以便在图像上绘制形状:</p><ul class=""><li id="51dc" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">要在其上绘制形状的图像</li><li id="dbda" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">要从Pt1(左上)到Pt2(右下)绘制的形状的坐标</li><li id="ae72" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">颜色</strong>:要绘制的形状的颜色。它作为一个元组传递，例如:<code class="du lh li lj lk b">(255,0,0)</code>。对于灰度，它将是亮度的标度。</li><li id="51fa" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">几何图形的厚度。</li></ul><h2 id="de99" class="lp je hi bd jf md me mf jj mg mh mi jn iq mj mk jr iu ml mm jv iy mn mo jz mp bi translated">1.直线</h2><p id="fc82" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在图像上画一条直线需要指定直线要经过的点。</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="1193" class="lp je hi lk b fi lq lr l ls lt"># Draw a diagonal red line with thickness of 5 px<br/>line_red = cv2.line(img,(0,0),(511,511),(255,0,0),5)<br/>plt.imshow(line_red)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/38ec520458f4a7f23ff5f7a318387341.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*9vp235vby3dPBj9L.png"/></div></figure><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="d0c7" class="lp je hi lk b fi lq lr l ls lt"># Draw a diagonal green line with thickness of 5 px<br/>line_green = cv2.line(img,(0,0),(511,511),(0,255,0),5)<br/>plt.imshow(line_green)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mq"><img src="../Images/b5e0683982d12b85dfa6807aeff7ec00.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/0*jdFq03hwC3rqg17A.png"/></div></figure><h2 id="06ad" class="lp je hi bd jf md me mf jj mg mh mi jn iq mj mk jr iu ml mm jv iy mn mo jz mp bi translated">2.矩形</h2><p id="addc" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于矩形，我们需要指定左上角和右下角的坐标。</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="77ac" class="lp je hi lk b fi lq lr l ls lt">#Draw a blue rectangle with a thickness of 5 px</span><span id="ab09" class="lp je hi lk b fi ma lr l ls lt">rectangle= cv2.rectangle(img,(384,0),(510,128),(0,0,255),5)<br/>plt.imshow(rectangle)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mr"><img src="../Images/3d88f9ffb03724b5ce924f760a9aecf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/0*UX8hFAEwFPhY5_xf.png"/></div></figure><h2 id="e35a" class="lp je hi bd jf md me mf jj mg mh mi jn iq mj mk jr iu ml mm jv iy mn mo jz mp bi translated">3.圆</h2><p id="18ae" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于一个圆，我们需要传递它的圆心坐标和半径值。让我们在上面画的矩形里面画一个圆</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="5d40" class="lp je hi lk b fi lq lr l ls lt">img = cv2.circle(img,(447,63), 63, (0,0,255), -1) # -1 corresponds to a filled circle<br/> plt.imshow(circle)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/e9307af898489624c2eed6c5de01e664.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*nT54-hEswU2ZjB_E.png"/></div></figure><h1 id="70a4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在图像上书写</h1><p id="a66f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">向图像添加文本也类似于在图像上绘制形状。但是在这样做之前，您需要指定某些参数:</p><ul class=""><li id="c7fb" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">要编写的文本</li><li id="052a" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">文本的坐标。图像上的文本从左下方开始。</li><li id="fcc0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">字体类型和比例。</li><li id="dd38" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">其他属性，如颜色、粗细和线型。通常使用的线路类型是<code class="du lh li lj lk b">lineType = cv2.LINE_AA</code>。</li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="30c7" class="lp je hi lk b fi lq lr l ls lt">font = cv2.FONT_HERSHEY_SIMPLEX<br/>text = cv2.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv2.LINE_AA)<br/>plt.imshow(text)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ms"><img src="../Images/0b3c2b5e9be3a360e59b773fda1b5108.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/0*GOcJTXV3YhWA-Dmt.png"/></div></figure><p id="50f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是可以使用OpenCV在图像上完成的小操作。请随意试验形状和文本。</p><h1 id="6796" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4.人脸检测</h1><h1 id="8b45" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">概观</h1><p id="204b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">人脸检测是一种在数字图像中识别或定位人脸的技术。面部检测的一个典型例子发生在我们通过智能手机拍照时，它会立即检测到照片中的面部。人脸检测不同于人脸识别。面部检测仅仅检测图像中面部的存在，而面部识别包括识别这是谁的面部。在本文中，我们将只讨论前者。</p><p id="34fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用分类器来执行面部检测。分类器本质上是一种算法，它决定给定的图像是正面的(人脸)还是负面的(不是人脸)。一个分类器需要在数以千计的有和没有人脸的图像上进行训练。幸运的是，OpenCV已经有两个预训练的人脸检测分类器，可以很容易地在程序中使用。这两个分类器是:</p><ul class=""><li id="dce9" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">哈尔分类器和</li><li id="6046" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">局部二元模式(<a class="ae kg" href="https://en.wikipedia.org/wiki/Local_binary_patterns" rel="noopener ugc nofollow" target="_blank"> LBP </a>)分类器。</li></ul><p id="f831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在本文中，我们将只讨论Haar分类器。</p><h1 id="fcb0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">基于Haar特征的级联分类器</h1><p id="0501" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><a class="ae kg" href="https://en.wikipedia.org/wiki/Haar-like_feature" rel="noopener ugc nofollow" target="_blank"> Haar-like特征</a>是用于物体识别的数字图像特征。它们的名字源于它们与<a class="ae kg" href="https://en.wikipedia.org/wiki/Haar_wavelet" rel="noopener ugc nofollow" target="_blank"> Haar小波</a>的直觉相似性，并被用于第一个实时人脸检测器。<strong class="ih hj"> Paul Viola </strong>和<strong class="ih hj"> Michael Jones </strong>在他们题为<a class="ae kg" href="http://wearables.cc.gatech.edu/paper_of_week/viola01rapid.pdf" rel="noopener ugc nofollow" target="_blank">“使用简单特征增强级联的快速对象检测”</a>的论文中使用了基于Haar小波的Haar特征分类器的思想。这种分类器广泛用于计算机视觉行业中的人脸检测等任务。</p><p id="a117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Haar级联分类器采用机器学习方法进行视觉对象检测，能够非常快速地处理图像并实现高检测率。这可以归结为三个主要的<a class="ae kg" href="http://wearables.cc.gatech.edu/paper_of_week/viola01rapid.pdf" rel="noopener ugc nofollow" target="_blank">原因</a>:</p><ul class=""><li id="98a2" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">Haar分类器采用了<strong class="ih hj"> <em class="mt">【积分图像】</em> </strong>概念，这使得检测器所使用的特征可以非常快速地计算出来。</li><li id="aa70" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">学习算法基于<a class="ae kg" href="https://en.wikipedia.org/wiki/AdaBoost" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="mt">AdaBoost</em></strong></a>。它从大量的特征集中选择少量的重要特征，并给出高效的分类器。</li><li id="019b" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">更复杂的分类器被组合以形成“<strong class="ih hj"> <em class="mt">级联</em> </strong>”，其丢弃图像中的任何非人脸区域，从而在有希望的物体状区域上花费更多的计算。</li></ul><p id="a83e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在让我们试着逐步理解该算法如何作用于图像:</strong></p><h1 id="a49c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.哈尔特征提取</h1><p id="b745" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在将大量的训练数据(以图像的形式)输入系统后，分类器开始从每幅图像中提取Haar特征。Haar特征是一种卷积核，主要检测图像上是否存在合适的特征。以下是Haar特性的一些示例:</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mu"><img src="../Images/5dafde0c1ea50405e4ec5fdf04b35d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/0*R4pDoLE0haEw-HVv.png"/></div></figure><p id="a3d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="8faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些Haar特征就像窗口，被放置在图像上以计算单个特征。该特征本质上是通过减去白色区域下的像素和黑色区域下的像素的总和而获得的单个值。在下面的例子中可以很容易地看到这个过程。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mv"><img src="../Images/b31c0877f5dde01de165abcb849284b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/0*fGH-RiLGB29uLpGJ.png"/></div></figure><p id="08d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于演示的目的，假设我们只提取两个特征，因此这里只有两个窗口。第一个特征依赖于眼睛区域比相邻的脸颊和鼻子区域暗这一点。第二个特点是眼睛比鼻梁更黑。因此，当特征窗口在眼睛上移动时，它将计算单个值。然后，将该值与某个阈值进行比较，如果该值超过阈值，则推断这里存在边缘或某些积极特征。</p><h1 id="27b4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.整体图像概念</h1><p id="1c10" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Viola-Jones提出的算法使用24X24的基本窗口大小，这将导致在该窗口中计算超过180，000个特征。想象一下计算所有特征的像素差异？为这一计算密集型过程设计的解决方案是采用<strong class="ih hj">积分图像</strong>概念。积分图像意味着要找到任何矩形下所有像素的总和，我们只需要四个角的值。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mw"><img src="../Images/db8c60744f4126a2c9e1f46e86c42377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/0*PzR5-nxwUrBvss7G.png"/></div></figure><p id="e069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="48fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，要计算任何特征窗口中像素的总和，我们不需要单独对它们求和。我们所需要的是使用4个角值来计算积分图像。下面的例子将使这个过程变得透明。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es mx"><img src="../Images/4431e2cce56b2cd7a1289bcdb3ac4677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t_kcRuOboQLnl8Rw.png"/></div></div></figure><p id="e4cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://en.wikipedia.org/wiki/Summed-area_table" rel="noopener ugc nofollow" target="_blank">来源</a></p><h1 id="a538" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.“Adaboost”:提高分类器精度</h1><p id="a23f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如上所述，在24X24窗口内会产生超过180，000个特征值。然而，并不是所有的特征都对识别人脸有用。为了只从整个块中选择最好的特征，使用了一种叫做<strong class="ih hj"> Adaboost </strong>的机器学习算法。它本质上做的是只选择那些有助于提高分类器精度的特征。它通过构建一个强分类器来实现，该强分类器是多个弱分类器的线性组合。这将功能的数量从大约180，000个急剧减少到大约6000个。</p><h1 id="049b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4.使用“分类器级联”</h1><p id="96bb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Viola-Jones确保算法快速执行的另一种方式是采用分类器的<strong class="ih hj">级联。级联分类器基本上由多个级组成，其中每个级由一个强分类器组成。这是有益的，因为它消除了在一个窗口上一次应用所有特征的需要。相反，它将特征分组到单独的子窗口中，并且每个阶段的分类器确定子窗口是否是人脸。如果不是，则该子窗口与该窗口中的特征一起被丢弃。如果子窗口移过分类器，则它继续到下一阶段，在该阶段应用第二阶段的特征。借助下图可以理解这一过程。</strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es nc"><img src="../Images/1dc238e3eccd3964897e894348f3dfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gVDM08gz8jSRi8cQ.png"/></div></div></figure><p id="6bb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://www.researchgate.net/figure/Cascade-structure-for-Haar-classifiers_fig9_277929875" rel="noopener ugc nofollow" target="_blank">哈尔分类器的级联结构。</a></p><h1 id="9990" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">保罗-维奥拉算法可以被形象化如下:</h1><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es nd"><img src="../Images/79c32c0959c2ce7e0320feee27d5c3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/0*kzMaW3SYvzetbrO8.gif"/></div></figure><p id="3e16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://vimeo.com/12774628" rel="noopener ugc nofollow" target="_blank">来源</a></p><h1 id="6123" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">基于OpenCV-Python的人脸检测</h1><p id="bde7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们对人脸识别背后的直觉和过程有了一个公平的想法。现在让我们使用OpenCV库来检测图像中的人脸。</p><h1 id="2fac" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加载必要的库</h1><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="0081" class="lp je hi lk b fi lq lr l ls lt">import numpy as np<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><h1 id="06b1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加载待测图像的灰度</h1><p id="9220" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将使用下图:</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ne"><img src="../Images/ac314099fe19812b89842a10732c3401.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*fe6St9DWPkIQidte.png"/></div></figure><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="a7e9" class="lp je hi lk b fi lq lr l ls lt">#Loading the image to be tested<br/>test_image = cv2.imread('data/baby1.jpg')</span><span id="9248" class="lp je hi lk b fi ma lr l ls lt">#Converting to grayscale<br/>test_image_gray = cv2.cvtColor(test_image, cv2.COLOR_BGR2GRAY)</span><span id="c438" class="lp je hi lk b fi ma lr l ls lt"># Displaying the grayscale image<br/>plt.imshow(test_image_gray, cmap='gray')<br/>Since we know that OpenCV loads an image in BGR format, so we need to convert it into RBG format to be able to display its true colors. Let us write a small function for that.</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es nf"><img src="../Images/190f4fb9d826bfc2b11a969711d61689.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/0*WZ_wFj0nmD1Aedq9.png"/></div></figure><p id="0aa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们知道OpenCV以BGR格式加载图像，所以我们需要将它转换成RBG格式，以便能够显示它的真实颜色。让我们为此编写一个小函数。</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="5445" class="lp je hi lk b fi lq lr l ls lt">def convertToRGB(image):<br/>    return cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span></pre><h1 id="e0d1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">哈尔级联文件</h1><p id="9294" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">OpenCV附带了很多预先训练好的分类器。例如，有微笑、眼睛、脸等分类器。这些文件以XML文件的形式出现，位于<code class="du lh li lj lk b">opencv/data/haarcascades/</code>文件夹中。然而，为了简单起见，您也可以从这里的<a class="ae kg" href="https://github.com/parulnith/Face-Detection-in-Python-using-OpenCV/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank">访问它们。下载XML文件，并将它们放在与jupyter笔记本相同的工作目录下的data文件夹中。</a></p><h1 id="700c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加载正面人脸的分类器</h1><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="10f9" class="lp je hi lk b fi lq lr l ls lt">haar_cascade_face = cv2.CascadeClassifier('data/haarcascade/haarcascade_frontalface_default.xml')</span></pre><h1 id="de9f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">人脸检测</h1><p id="46fb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将使用分类器的<strong class="ih hj">检测多尺度</strong>模块。该函数将返回一个矩形，坐标为(x，y，w，h ),围绕检测到的人脸。该函数有两个重要参数，必须根据数据进行调整。</p><ul class=""><li id="8a4b" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">比例因子</strong>在集体照中，可能会有一些脸比其他人更靠近镜头。自然，这样的脸会比后面的脸显得更突出。这个因素弥补了这一点。</li><li id="22ce" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">邻居</strong>该参数指定了一个矩形被称为一个面的邻居的数量。你可以在这里了解更多信息。</li></ul><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="c46a" class="lp je hi lk b fi lq lr l ls lt">faces_rects = haar_cascade_face.detectMultiScale(test_image_gray, scaleFactor = 1.2, minNeighbors = 5);</span><span id="a9ac" class="lp je hi lk b fi ma lr l ls lt"># Let us print the no. of faces found<br/>print('Faces found: ', len(faces_rects))</span><span id="9536" class="lp je hi lk b fi ma lr l ls lt">Faces found:  1</span></pre><p id="0393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的下一步是循环遍历它返回的所有坐标，并使用Open CV在它们周围绘制矩形。我们将绘制一个厚度为2的绿色矩形</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="233c" class="lp je hi lk b fi lq lr l ls lt">for (x,y,w,h) in faces_rects:<br/>     cv2.rectangle(test_image, (x, y), (x+w, y+h), (0, 255, 0), 2)</span></pre><p id="47b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将显示彩色的原始图像，看看是否已经正确地检测到人脸。</p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="b0d5" class="lp je hi lk b fi lq lr l ls lt">#convert image to RGB and show image</span><span id="b2e6" class="lp je hi lk b fi ma lr l ls lt">plt.imshow(convertToRGB(test_image))</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ng"><img src="../Images/4036db5d39908e4c7e686a8103fcfd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*j2bxDcX-E_VqfZuL.png"/></div></figure><p id="e831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里。我们已经成功检测出照片中婴儿的脸部。现在让我们为整个人脸检测过程创建一个广义函数。</p><h1 id="3d08" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">广义函数的人脸检测</h1><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="1565" class="lp je hi lk b fi lq lr l ls lt">def detect_faces(cascade, test_image, scaleFactor = 1.1):<br/>    # create a copy of the image to prevent any changes to the original one.<br/>    image_copy = test_image.copy()</span><span id="e8c3" class="lp je hi lk b fi ma lr l ls lt">    #convert the test image to gray scale as opencv face detector expects gray images<br/>    gray_image = cv2.cvtColor(image_copy, cv2.COLOR_BGR2GRAY)</span><span id="d3d4" class="lp je hi lk b fi ma lr l ls lt">    # Applying the haar classifier to detect faces<br/>    faces_rect = cascade.detectMultiScale(gray_image, scaleFactor=scaleFactor, minNeighbors=5)</span><span id="c3b8" class="lp je hi lk b fi ma lr l ls lt">    for (x, y, w, h) in faces_rect:<br/>        cv2.rectangle(image_copy, (x, y), (x+w, y+h), (0, 255, 0), 15)</span><span id="5e6d" class="lp je hi lk b fi ma lr l ls lt">    return image_copy</span></pre><h1 id="2dba" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在新图像上测试功能</h1><p id="059c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这次的测试图像如下:</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ms"><img src="../Images/ef513d930a91a5edc41a7c437760df54.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/0*0cz9QIOfeIDo6rUm.png"/></div></figure><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="4115" class="lp je hi lk b fi lq lr l ls lt">#loading image<br/>  test_image2 = cv2.imread('baby2.jpg')</span><span id="2fdc" class="lp je hi lk b fi ma lr l ls lt">  # Converting to grayscale<br/>  test_image_gray = cv2.cvtColor(test_image, cv2.COLOR_BGR2GRAY)</span><span id="f8f7" class="lp je hi lk b fi ma lr l ls lt">  # Displaying grayscale image<br/>  plt.imshow(test_image_gray, cmap='gray')</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es nh"><img src="../Images/e89aa6aed1fb7192acbf8053d835b883.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*1zsQl0ygB5FJMiwb.png"/></div></figure><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="5aee" class="lp je hi lk b fi lq lr l ls lt">#call the function to detect faces<br/>faces = detect_faces(haar_face_cascade, test_image2)</span><span id="9b5c" class="lp je hi lk b fi ma lr l ls lt"> #convert to RGB and display image<br/> plt.imshow(convertToRGB(faces))</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ni"><img src="../Images/5beddf3fc5e1229e78c63f84c0a906d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*sxNOWOvhQ5yghjkN.png"/></div></figure><h1 id="7db4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在组图像上测试功能</h1><p id="5344" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在让我们看看这个函数在团体照片上是否工作良好。我们将使用下面的图片来达到我们的目的。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es nj"><img src="../Images/68132eb777d04f79b0074033f3775dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*MYjrD9sZ3zX4V-FS.png"/></div></figure><p id="191f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mt">图片:印度女子板球队。</em></p><pre class="la lb lc ld fd ll lk lm ln aw lo bi"><span id="fff7" class="lp je hi lk b fi lq lr l ls lt">#loading image<br/>test_image2 = cv2.imread('group.jpg')</span><span id="f2d1" class="lp je hi lk b fi ma lr l ls lt">#call the function to detect faces<br/>faces = detect_faces(haar_cascade_face, test_image2)</span><span id="1fc1" class="lp je hi lk b fi ma lr l ls lt">#convert to RGB and display image<br/>plt.imshow(convertToRGB(faces))</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es nk"><img src="../Images/fe84ba9b9ce1c85e8e6de474458e2596.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/0*OOD8IpUEUEjdYxHQ.png"/></div></div></figure><h1 id="5150" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="3f8b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在本教程中，我们学习了使用Haar cascade在Python中使用Open CV进行人脸检测的概念。除了人脸还有很多检测器，可以在库中找到。随意试验它们，为眼睛、车牌等创建探测器。</p></div></div>    
</body>
</html>