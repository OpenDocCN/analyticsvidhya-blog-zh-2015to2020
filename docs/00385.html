<html>
<head>
<title>Step-by-step guide for predicting Wine Preferences using Scikit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scikit-Learn预测葡萄酒偏好的分步指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/step-by-step-guide-for-predicting-wine-quality-using-scikit-learn-de5869f8f91a?source=collection_archive---------1-----------------------#2019-05-17">https://medium.com/analytics-vidhya/step-by-step-guide-for-predicting-wine-quality-using-scikit-learn-de5869f8f91a?source=collection_archive---------1-----------------------#2019-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/35b09b4ab663080fe91eb9a1c54437a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FqqFJcwgu8dQ4z7Qc5G8vQ.gif"/></div></div></figure><p id="cc0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，你是机器学习的新手，写机器学习项目令人毛骨悚然，只要通过这篇博文深入数据科学管道。这篇博文一步一步地讲述了Python中基本的机器学习过程。</p><p id="6b84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据科学管道的基本步骤:</strong></p><ol class=""><li id="e442" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">把问题框起来，看大局。</li><li id="43b7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">获取数据。</li><li id="3b31" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">探索数据以获得洞察力。</li><li id="6c4d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">准备数据以更好地将底层数据模式暴露给机器学习算法。</li><li id="7c94" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">探索许多不同的模型，并列出最佳模型。</li><li id="a313" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">微调您的模型，并将它们组合成一个伟大的解决方案。</li><li id="41ca" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">提出你的解决方案。</li><li id="0cc3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">启动、监控和维护您的系统。</li></ol><blockquote class="kd ke kf"><p id="a0da" class="iq ir jo is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">请随意根据您的需求调整此管道！</p></blockquote><h2 id="3c34" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">1.把问题框起来，看大局。</h2><p id="5351" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">首先，我们需要从商业角度定义目标。因为我们的工作是预测人类对葡萄酒的口味偏好，这些偏好基于认证阶段容易获得的分析测试。我们希望获得90%以上的准确率。预测值可用于设计新类型的葡萄酒，定义定价政策或支持咨询系统中的决策。</p><p id="edf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在问题框架期间，我们定义我们的系统将使用批量学习技术。如果我们收集更多的数据，并提供基于物理化学性质的葡萄酒排名控制研究，这将是一项昂贵且不必要的任务。</p><p id="d54c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，该系统将被培训，然后投入生产和运行，无需再学习。它只会应用它所学到的东西。这通常需要时间和计算资源。</p><p id="c968" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们可以尝试两种方法:</p><ul class=""><li id="652f" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lj jv jw jx bi translated">通过比较新数据点和已知数据点，构建基于实例的学习系统。</li><li id="01b8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lj jv jw jx bi translated">像科学家一样，通过检测训练数据中的模式来建立基于模型的学习系统，并建立预测模型。</li></ul><blockquote class="kd ke kf"><p id="294d" class="iq ir jo is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated"><strong class="is hj">让我们假设一下。</strong></p><p id="42d3" class="iq ir jo is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">零假设(<em class="hi"> H0 </em>)是指<em class="hi">没有一个</em>质量排名中的方差是由理化性质解释的。另一个假设(<em class="hi"> H1 </em>)是物理化学性质对质量等级差异的贡献，使葡萄酒“好”或反之“坏”。</p></blockquote></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="36e4" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">2.获取数据</h2><p id="849d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">我们将使用来自葡萄牙北部的红葡萄酒样本的真实数据集。该数据集可从https://archive.ics.uci.edu/ml/datasets/wine+quality.<a class="ae lr" href="https://archive.ics.uci.edu/ml/datasets/wine+quality." rel="noopener ugc nofollow" target="_blank">UCI机器学习库</a> <em class="jo"> </em>获得。该数据集可被视为分类或回归任务。</p><p id="9a06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">输入变量(基于理化试验):</em> </strong> <br/> <em class="jo"> 1固定酸度；<br/> 2挥发性酸度；<br/> 3柠檬酸；<br/> 4残糖；<br/> 5氯化物；<br/> 6游离二氧化硫；<br/> 7总二氧化硫；<br/> 8密度；<br/>9ph；<br/> 10硫酸盐；<br/> 11酒精。</em></p><p id="0922" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">输出变量(基于感官数据):</em> </strong> <em class="jo"> <br/> 12个质量(得分在0到10之间)。</em></p><p id="51e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们获取数据，并将它们转换成数据框的格式，以便更容易操作。数据调查是一项有趣且令人上瘾的任务。看看你的数据，检查它们的维度和类型。</p><p id="d315" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[1]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="c259" class="kj kk hi lx b fi mb mc l md me"># Load in the red wine data from the UCI ML website.<br/>df = pd.read_csv('http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv',sep=';')</span><span id="c2bb" class="kj kk hi lx b fi mf mc l md me"># Take a look<br/>print(df.head(10))<br/># Data dimensionality (rows, colums)<br/>print(df.shape)<br/># Data distributing<br/>df.info()</span></pre><p id="d89f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out [1]:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="a2b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在数据调查之前，你应该已经完成了最重要的步骤之一是<strong class="is hj">数据分割。</strong>数据被分成两组:训练集<em class="jo"> 80% </em>，测试集<em class="jo"> 20% </em>。训练集应该用于构建您的机器学习模型。测试集应该用于查看您的模型在看不见的数据上的表现。</p><p id="b6be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[2]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="e2c7" class="kj kk hi lx b fi mb mc l md me"># Now seperate the dataset as response variable and feature variabes<br/>X = df.drop('quality', axis=1)<br/>y = df['quality']</span><span id="83b2" class="kj kk hi lx b fi mf mc l md me"># Train and Test splitting of data<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=50)</span><span id="a7dc" class="kj kk hi lx b fi mf mc l md me"># Applying Standard scaling to get optimized result<br/>sc = StandardScaler()<br/>X_train = sc.fit_transform(X_train)<br/>X_test = sc.fit_transform(X_test)</span></pre><blockquote class="kd ke kf"><p id="5f93" class="iq ir jo is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">没有数据窥探！</p></blockquote></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="2fa8" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">3.探索数据以获得洞察力</h2><p id="620d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">到目前为止，我们只是快速浏览了一下数据，以便对我们正在处理的数据类型有一个大致的了解。现在我们将使用测试集来探索数据。</p><p id="e49e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看每个数字特征的基本统计特征会很有趣。count、mean、min和max行是不言自明的。标准行显示标准偏差(测量值的分散程度)。25%、50%和75%的行显示相应的百分位数。</p><p id="f64e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[3]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="a134" class="kj kk hi lx b fi mb mc l md me"># Statistical characteristics of each numerical feature<br/>print(df.describe())</span></pre><p id="0f44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out [3]:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="3d65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可视化数据对于识别模型中要利用的底层模式至关重要。当数据恰当地可视化时，就能清楚地看到趋势和模式，变量之间的相关性，因为我们的大脑非常善于在图片上发现模式。让我们尝试不同类型的数据可视化和参数，让模式脱颖而出。</p><p id="b7c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用下面的图，我们可以了解不同属性的数据分布；<strong class="is hj">例如，属性“酒精”的数据分布呈正态分布，而属性“<em class="jo">密度</em>”的数据呈正态分布。注意葡萄酒质量数据的分布。这是一个双峰分布，平均质量的葡萄酒比“好”或“差”质量的葡萄酒多。</strong></p><p id="e2d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[4]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="7beb" class="kj kk hi lx b fi mb mc l md me"># Histograms<br/>df.hist(bins=10,figsize=(6, 5))<br/>plt.show()</span><span id="be8d" class="kj kk hi lx b fi mf mc l md me"># Density<br/>df.plot(kind='density', subplots=True, layout=(4,3), sharex=False)<br/>plt.show()</span></pre><p id="9dd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out [4]:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/12d51c7af6f890d43221b2ce84d69cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnCsFbYSQep-Jrf5jBNXcQ.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">柱状图</figcaption></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/76246085bf73b169faad173925f93d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjwmwfjyY4I_MTRydFTJcA.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">密度</figcaption></figure><p id="b279" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">探索数据的另一种方式是一个非常方便的工具数据透视表。数据透视表是数据的汇总，打包在一个图表中，使您可以根据信息报告和探索趋势。如果您有很长的行或列来保存您需要跟踪总和并容易相互比较的值，则数据透视表特别有用。因此，我们的数据透视表描述了每个质量分数的每个特性的中间值。现在，我们可以跟踪趋势，例如，“硫酸盐”的最高值往往是最高的“质量”分数。但是我们不能根据相关性得出结论。</p><blockquote class="mo"><p id="ed33" class="mp mq hi bd mr ms mt mu mv mw mx jn dx translated">相关性不会导致因果关系。</p></blockquote><p id="ae5b" class="pw-post-body-paragraph iq ir hi is b it my iv iw ix mz iz ja jb na jd je jf nb jh ji jj nc jl jm jn hb bi translated">在[5]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="0d56" class="kj kk hi lx b fi mb mc l md me"># Create pivot_table<br/>colum_names = ['fixed acidity', 'volatile acidity', 'citric acid', 'residual sugar', 'chlorides', 'free sulfur dioxide', 'total sulfur dioxide', 'density', 'pH', 'sulphates', 'alcohol']<br/>df_pivot_table = df.pivot_table(colum_names,<br/>               ['quality'], aggfunc='median')<br/>print(df_pivot_table)</span></pre><p id="27f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out [5]:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="149c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了了解每个属性与葡萄酒质量分数的相关程度，请计算每对属性之间的标准相关系数(也称为皮尔逊相关系数)。</p><p id="2bf6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[6]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="19b4" class="kj kk hi lx b fi mb mc l md me">corr_matrix = df.corr()<br/>print(corr_matrix["quality"].sort_values(ascending=False))</span></pre><p id="7d03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out [5]:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="1573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相关系数范围从–1到1。当接近1时，说明有很强的正相关性；例如，<strong class="is hj">“质量”值往往会随着“酒精”的上升而上升</strong>。当系数接近–1时，说明有很强的负相关性；<strong class="is hj">你可以看到“挥发性酸度”和“质量”值</strong>之间存在微小的负相关性。最后，系数接近零意味着没有线性相关性。</p><p id="861a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用关联矩阵查看有关数据关联的更多详细信息。相关矩阵为我们提供了两个变量如何相互作用的信息，包括方向和大小。</p><p id="368f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[7]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="5c90" class="kj kk hi lx b fi mb mc l md me">colum_names = ['fixed acidity', 'volatile acidity', 'citric acid', 'residual sugar', 'chlorides', 'free sulfur dioxide', 'total sulfur dioxide', 'density', 'pH', 'sulphates', 'alcohol', 'quality']<br/># Correlation matrix<br/>correlations = df.corr()<br/># Plot figsize<br/>fig, ax = plt.subplots(figsize=(10, 10))<br/># Generate Color Map<br/>colormap = sns.diverging_palette(220, 10, as_cmap=True)<br/># Generate Heat Map, allow annotations and place floats in map<br/>sns.heatmap(correlations, cmap=colormap, annot=True, fmt=".2f")<br/>ax.set_xticklabels(<br/>    colum_names,<br/>    rotation=45,<br/>    horizontalalignment='right'<br/>);<br/>ax.set_yticklabels(colum_names);<br/>plt.show()</span></pre><p id="34b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out [7]:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/3add59f9248b2feff5edb4bf89a5842b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMwys0nXPQhg5ozVN8ZnwQ.png"/></div></div></figure><p id="4f3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以将散点图矩阵可视化，以便更好地理解一对变量之间的关系。它将每个数字属性与其他属性相对照。</p><p id="b66e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[8]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="dafc" class="kj kk hi lx b fi mb mc l md me"># Scatterplot Matrix<br/>sm = scatter_matrix(df, figsize=(6, 6), diagonal='kde')<br/>#Change label rotation<br/>[s.xaxis.label.set_rotation(40) for s in sm.reshape(-1)]<br/>[s.yaxis.label.set_rotation(0) for s in sm.reshape(-1)]<br/>#May need to offset label when rotating to prevent overlap of figure<br/>[s.get_yaxis().set_label_coords(-0.6,0.5) for s in sm.reshape(-1)]<br/>#Hide all ticks<br/>[s.set_xticks(()) for s in sm.reshape(-1)]<br/>[s.set_yticks(()) for s in sm.reshape(-1)]<br/>plt.show()</span></pre><p id="d36a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out[8]:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/db174ca42b813139ab912da914d14e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHEo9XT7pLunU0KKfbbA0w.png"/></div></div></figure><p id="fab2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意属性“固定酸度”和“密度”之间的相关性。它们的相关系数是0.67(您可以在相关矩阵中找到值)，查看对应的散点图，我们可以看到属性之间的正线性相关。您还可以清楚地看到上升趋势，这些点在这些属性之间并不太分散。这样，您就可以分析其他属性。</p><blockquote class="kd ke kf"><p id="f11b" class="iq ir jo is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">在为机器学习算法实际准备数据之前，您可能想要做的最后一件事是尝试各种属性组合。</p></blockquote></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="6eab" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">4.准备数据以更好地将底层数据模式暴露给机器学习算法</h2><p id="52b8" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">是时候为我们的机器学习算法准备数据了。在我们的数据集中，没有任何缺失值、异常值和对任务没有任何有用信息的属性。因此，我们可以得出结论，我们的数据集非常干净。因此，我们不会做任何艰苦的数据准备，但有些事情是需要做的。人类对葡萄酒的偏好得分从3到8不等，因此很容易将答案分为葡萄酒质量“差”或“好”。这允许我们在例如决策树算法上练习超参数调整。可视化每个类别的数值的图表，我们可以看到坏的答案远远多于好的答案。当然，机器学习算法操作数字值，所以我们为分类指定相应的离散值0或1。</p><p id="6f72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[9]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="9902" class="kj kk hi lx b fi mb mc l md me"># Dividing wine as good and bad by giving the limit for the quality<br/>bins = (2, 6, 8)<br/>group_names = ['bad', 'good']<br/>df['quality'] = pd.cut(df['quality'], bins = bins, labels = group_names)</span><span id="da0a" class="kj kk hi lx b fi mf mc l md me"># Now lets assign a labels to our quality variable<br/>label_quality = LabelEncoder()<br/># Bad becomes 0 and good becomes 1<br/>df['quality'] = label_quality.fit_transform(df['quality'])<br/>print(df['quality'].value_counts())</span><span id="31b0" class="kj kk hi lx b fi mf mc l md me">sns.countplot(df['quality'])<br/>plt.show()</span></pre><p id="8ce5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out[9]:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/9b5b1626a6e6f7d6724bb2d6ab10e218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9IPdJlEszRF4IGH0BeSgKA.png"/></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="54d3" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">5.探索许多不同的模式，并列出最好的</h2><p id="6d98" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">评估机器学习模型可能非常棘手。通常基于误差度量对性能进行建模评估。然而，这种方法并不十分可靠，因为一个测试集所获得的精度可能与另一个测试集所获得的精度相差很大。</p><p id="1c65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，比较了8种不同的算法:</p><ol class=""><li id="1fb1" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">支持向量分类器</li><li id="3368" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">随机梯度下降分类器</li><li id="c808" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">随机森林分类器</li><li id="6849" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">决策树分类器</li><li id="8de7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">高斯朴素贝叶斯</li><li id="2783" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">k近邻分类器</li><li id="1c80" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">Ada Boost分类器</li><li id="bee9" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">逻辑回归</li></ol><p id="bf9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">公平比较机器学习算法的关键是确保每个算法在相同的数据上以相同的方式进行评估。<em class="jo"> K-fold交叉验证(CV) </em>通过将数据划分为多个折叠，并确保每个折叠在某个点被用作测试集，为这个问题提供了一个解决方案。</p><p id="04b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[10]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="536e" class="kj kk hi lx b fi mb mc l md me"># prepare configuration for cross validation test harness<br/>seed = 7<br/># prepare models<br/>models = []<br/>models.append(('SupportVectorClassifier', SVC()))<br/>models.append(('StochasticGradientDecentC', SGDClassifier()))<br/>models.append(('RandomForestClassifier', RandomForestClassifier()))<br/>models.append(('DecisionTreeClassifier', DecisionTreeClassifier()))<br/>models.append(('GaussianNB', GaussianNB()))<br/>models.append(('KNeighborsClassifier', KNeighborsClassifier()))<br/>models.append(('AdaBoostClassifier', AdaBoostClassifier()))<br/>models.append(('LogisticRegression', LogisticRegression()))</span><span id="8f14" class="kj kk hi lx b fi mf mc l md me"># evaluate each model in turn<br/>results = []<br/>names = []<br/>scoring = 'accuracy'<br/>for name, model in models:<br/>   kfold = model_selection.KFold(n_splits=10, random_state=seed)<br/>   cv_results = model_selection.cross_val_score(model, X_train, y_train, cv=kfold, scoring=scoring)<br/>   results.append(cv_results)<br/>   names.append(name)<br/>   msg = "%s: %f (%f)" % (name, cv_results.mean(), cv_results.std())<br/>   print(msg)<br/># boxplot algorithm comparison<br/>fig = plt.figure()<br/>fig.suptitle('Algorithm Comparison')<br/>ax = fig.add_subplot(111)<br/>plt.boxplot(results)<br/>ax.set_xticklabels(names)<br/>plt.show()</span></pre><p id="3948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out[10]:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/bcc13df8b9d74d93c7507a60787e3ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZbUrOLrRLmX2S7IMJN2iQ.png"/></div></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="a6cf" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">6.微调您的模型，并将它们组合成一个伟大的解决方案</h2><p id="4d6f" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">有几个因素可以帮助您确定哪种算法执行得最好。其中一个因素是交叉验证集的性能，另一个因素是算法参数的选择。</p><p id="64d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来微调一些机器学习算法。我们训练和评估的第一个算法是支持向量分类器，模型预测的平均值等于<em class="jo"> 0.873364 </em>。为您的模型选择超参数的最和谐方式是什么？它试图猜测或循环遍历参数，然后运行所有的参数组合？使用网格搜索CV还有一个更有利的方法。</p><p id="8bba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[11]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="b530" class="kj kk hi lx b fi mb mc l md me">def svc_param_selection(X, y, nfolds):<br/>    param = {<br/>        'C': [0.1, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4],<br/>        'kernel': ['linear', 'rbf'],<br/>        'gamma': [0.1, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4]<br/>    }<br/>    grid_search = GridSearchCV(svc, param_grid=param, scoring='accuracy', cv=nfolds)<br/>    grid_search.fit(X,  y)<br/>    return grid_search.best_params_</span><span id="4348" class="kj kk hi lx b fi mf mc l md me">print(svc_param_selection(X_train, y_train,10))</span></pre><p id="7013" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out[11]:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6926" class="kj kk hi lx b fi mb mc l md me">{'C': 1.3, 'gamma': 1.3, 'kernel': 'rbf'}</span></pre><p id="222d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用最佳参数再次运行SVC。</p><p id="7e04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[12]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6b28" class="kj kk hi lx b fi mb mc l md me">svc = SVC(C = 1.3, gamma =  1.3, kernel= 'rbf')<br/>svc.fit(X_train, y_train)<br/>pred_svc = svc.predict(X_test)<br/>print('Confusion matrix')<br/>print(confusion_matrix(y_test, pred_svc))print('Classification report')<br/>print(classification_report(y_test, pred_svc2))<br/>print('Accuracy score',accuracy_score(y_test, pred_svc2))</span></pre><p id="8f44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out[12]:</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="20ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在为算法选择参数后，预测葡萄酒偏好的准确率为93%。</p><p id="f51a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们尝试微调另一个算法AdaBoost，使用交叉验证，准确率达到86%。</p><p id="0121" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在[13]中:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="dbfa" class="kj kk hi lx b fi mb mc l md me">ada_classifier = AdaBoostClassifier(n_estimators=100)<br/>ada_classifier.fit(X_train, y_train)<br/>pred_ada = ada_classifier.predict(X_test)<br/><br/># Cross-validation<br/>scores = cross_val_score(ada_classifier,X_test,y_test, cv=5)<br/>print('Accuracy score',scores.mean())</span></pre><p id="afd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Out[13]:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="3e4c" class="kj kk hi lx b fi mb mc l md me">Accuracy score 0.903</span></pre><p id="239c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以分析的另一个吸引人的事情是机器学习算法的特征重要性。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="a8e6" class="kj kk hi lx b fi mb mc l md me">importance=ada_classifier.feature_importances_<br/><br/>std = np.std([tree.feature_importances_ for tree in ada_classifier.estimators_],<br/>             axis=0)<br/>indices = np.argsort(importance)<br/><br/># Plot the feature importances of the forest<br/>plt.figure()<br/>plt.title("Feature importances")<br/>plt.barh(range(X.shape[1]), importance[indices],<br/>       color="b",  align="center")<br/><br/>plt.yticks(range(X.shape[1]), colum_names)<br/>plt.ylim([0, X.shape[1]])<br/>plt.show()</span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/1c191f3c271b3cbcaec5a1168a80a10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*idiuaRj7vjs4HjD67NoLXw.png"/></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="406f" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">7.展示您的解决方案</h2><p id="3c6d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">让我们根据已经完成的管道得出一些结论。我们的数据集非常干净，具有代表性。我们将目标值分为离散值，对应于葡萄酒的“好”或“坏”质量。</p><p id="6223" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在数据集中，我们发现了“酒精”和“葡萄酒质量”、“固定酸度”和“密度”以及另一个特征之间有趣的相关性。在分析了机器学习算法的特征重要性后，我们可以得出结论，调整像“酒精”、“硫酸盐”和“pH”这样的特征可能会使葡萄酒的分数更高或更低。基于这一信息，改变你的调子，改变葡萄酒的物理化学特性，将是有益的。因为它会影响人类的偏好。</p><p id="7c64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过我们提供的对比分析，我们可以突出机器学习算法，如<em class="jo">支持向量分类器</em>和<em class="jo">随机森林分类器。</em>那些算法的精度分布的箱线图相当对称，没有异常值。相邻的盒图值靠得很近，这对应于高密度的准确度得分。</p><p id="f0a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺便说一下，如果不调整机器学习算法，我们就无法实现预测葡萄酒偏好的平均准确率超过90 %。我们使用<em class="jo">网格搜索CV </em>对<em class="jo">支持向量分类器</em>进行了微调，达到了<strong class="is hj">93%的准确率。</strong>目标已经达到。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="b08c" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">8.启动、监控和维护您的系统</h2><p id="cd00" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">现在，您的解决方案可以投入生产了！该系统采用批量学习技术，不会对新数据进行训练。因此，随着时间的推移，数据不会“腐烂”。但是，如果您的模型定期使用新数据进行训练，您需要编写监控代码，定期检查系统的实时性能，并在性能下降时触发警报。在这种情况下，您不仅会遇到突然损坏，还会遇到性能下降。</p><blockquote class="mo"><p id="de8e" class="mp mq hi bd mr ms mt mu mv mw mx jn dx translated"><em class="nh">一个完整的Jupyter笔记本的项目代码可以在</em> <a class="ae lr" href="https://gist.github.com/NataliiaRastoropova/1d861775c47516d99e8dcb444eaa7049" rel="noopener ugc nofollow" target="_blank"> <em class="nh">这里</em> </a> <em class="nh">找到。</em></p></blockquote><blockquote class="kd ke kf"><p id="f3ad" class="iq ir jo is b it my iv iw ix mz iz ja kg na jd je kh nb jh ji ki nc jl jm jn hb bi translated">感谢您的阅读！我希望这篇文章让您对数据科学管道有了基本的了解。如果你有任何问题或发现错误，随时评论或写信给我shkarupa.nataliia@gmail.com。</p></blockquote></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="11d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">参考文献:</em></p><p id="4ebc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lr" href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1491962291/ref=sr_1_4" rel="noopener ugc nofollow" target="_blank">“用Scikit-Learn和Tensorflow实践机器学习</a></p><div class="ni nj ez fb nk nl"><a href="https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">红酒质量</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">用于回归或分类建模的简单明了的实践数据集</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">www.kaggle.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz io nl"/></div></div></a></div><div class="ni nj ez fb nk nl"><a href="https://dictionary.cambridge.org/ru/%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%B0%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9/absorbing?topic=exciting-and-interesting" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">吸收кембриджском的языка</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">吸收:吸收的东西非常有趣，可以吸引你的注意力。Узнать…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">dictionary.cambridge.org</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz io nl"/></div></div></a></div><div class="ni nj ez fb nk nl"><a rel="noopener follow" target="_blank" href="/datadriveninvestor/k-fold-cross-validation-6b8518070833"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">k倍交叉验证</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">评估机器学习模型可能非常棘手。通常，我们将数据集分成训练集和测试集…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">medium.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz io nl"/></div></div></a></div><div class="ni nj ez fb nk nl"><a href="https://machinelearningmastery.com/compare-machine-learning-algorithms-python-scikit-learn/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">如何比较Python中的机器学习算法和scikit-learn</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">始终如一地比较多种不同机器学习算法的性能非常重要。在这篇文章中…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">machinelearningmastery.com</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz io nl"/></div></div></a></div></div></div>    
</body>
</html>