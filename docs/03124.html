<html>
<head>
<title>Understanding Recursion with Factorial and an English Ruler Drawing.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用阶乘和英国尺规图理解递归。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-recursion-with-factorial-and-an-english-ruler-drawing-7d1f8244a13a?source=collection_archive---------3-----------------------#2020-01-17">https://medium.com/analytics-vidhya/understanding-recursion-with-factorial-and-an-english-ruler-drawing-7d1f8244a13a?source=collection_archive---------3-----------------------#2020-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8b29dfb3f5aca47d23af268cf0c6f818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*__jhoWXEa_INM44V5jx30w.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">递归—来自AlgoDaily的图像</figcaption></figure><p id="47c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">递归是数据结构和算法研究中的一项重要技术，它是一种函数在执行过程中对自身进行一次或多次调用的技术。它也可以定义为当数据结构在其表示中依赖于完全相同类型的结构的较小实例时。</p><p id="0c34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么递归如此重要？为了解决计算中的一些问题，递归算法可以帮助生成更容易理解的代码，并且它是需要显式管理堆栈数据结构的迭代算法的替代方法。递归可以用来很容易地解决一些有趣的问题，如汉诺塔，树遍历等。你熟悉头巾娃娃或嵌套娃娃吗？每个娃娃都是由实木制成的，有一个洞可以容纳另一个娃娃，它们通常被称为俄罗斯套娃，艺术直觉是递归的一个例子。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/3c3e16c558514efab9d4668574daca67.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*YR_MDxuZNH72cVhgk2x3cA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">俄罗斯套娃</figcaption></figure><p id="2c98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算中有许多递归的例子。在本文中，我们将只关注两个，即:阶乘运算和英语统治者模式。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="da53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">阶乘运算</strong></p><p id="5a24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算一组不同物体的可能排列，例如，五个人坐在五把固定的椅子上排成一排，有多少种不同的座位排列是可能的？为了计算这些排列，我们使用阶乘。</p><p id="ad76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果没有限制，将n个不同的物体按顺序排列的方式有n种！(n阶乘)。</strong></p><p id="5e76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决上面的例子，5！= 5* (4*3*2*1) = 120.递归定义可以表示如下</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/a9b6205728f28b4944644abd89a66989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*Nx1DI0q9bp4M82yNg1SwHg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">阶乘的数学表达式</figcaption></figure><p id="66fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">阶乘运算的简单Python实现</strong></p><pre class="jp jq jr js fd kb kc kd ke aw kf bi"><span id="a8a1" class="kg kh hi kc b fi ki kj l kk kl">def factorial (n):<br/>    if n == 0:<br/>        return 1<br/>    else:<br/>        return n * factorial(n-1)</span></pre><p id="f1c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在代码中调用factorial函数可以防止使用显式循环，每次调用该函数时，它的参数都会减少1，直到它达到基本情况，并且递归调用终止。</p><p id="0846" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用英语尺子分形结构检查下面一个更复杂的例子。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="3477" class="km kh hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">画一把英国尺子</strong></h1><p id="6f83" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">递归背后的直觉可以用来画出典型的英国尺子的记号。英制尺子是一块长而平的塑料或金属直尺，通常以英寸或厘米为单位。与上面的阶乘运算相比，这是递归应用的一个复杂例子。</p><p id="8261" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们深入英国统治者的递归世界</p><p id="2865" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">英制尺子标记</strong></p><p id="17ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以英寸为单位取英制尺子(下图)的一小部分，对于每一英寸，我们放置一个带有数值(标签)的勾号(也称为破折号)。代表整个英寸的破折号的长度被表示为<strong class="is hj">主要刻度长度(</strong>例如，英寸‘0’是主要刻度，英寸‘1’和英寸‘2’也是主要刻度)，因为它们显示了英寸的实际整数表示。整英寸之间的短划线以英寸、英寸等间隔放置。关系是，当间隔的大小减少一半时，破折号减少一。(例如，主要长度-英寸“1”带5个破折号，在英寸“1/2”处减少为4个破折号)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/8ab6a208a0446a93861ee6aa61e10ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/format:webp/1*j5Aah1ldRtdF7a1_QRs_rQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">英国统治者标记的一部分</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="c1a2" class="km kh hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">递归方法</strong></h1><p id="68ca" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">仔细观察英寸“0”和英寸“1”之间的模式，您可以发现产生刻度的序列。让我们称英寸“1/2”为中心刻度(4个破折号)，观察在这个中心刻度的上面和下面有两个相似的刻度图案，还有另一个3个破折号的中心刻度，如此继续下去。为了在python中实现递归方法，我们将编写一类助手方法和一个递归方法。该实现接受两个输入，即:总英寸数和代表主要英寸的破折号数。从上面的图像，英寸' 1 '是总英寸数，我们有5破折号。结果将是一个英国统治者的实际绘图。对具有递归的面向对象程序的理解将用于获得预期的结果。</p><p id="be99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">代码实现</strong></p><p id="6731" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">英语尺子类</strong></p><p id="269c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从一个类开始，我们创建了英语尺子实现的抽象。记住，我们需要使用init方法创建一个EnglishRuler的实例。每当我们需要EnglishRuler的实例时，就会调用这个结构。</p><pre class="jp jq jr js fd kb kc kd ke aw kf bi"><span id="80bb" class="kg kh hi kc b fi ki kj l kk kl">class EnglishRuler:<br/>    def __init__(self, num_inches, major_length):<br/>        self.__num_inches = num_inches<br/>        self.__major_length = major_length</span></pre><p id="a279" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">论据</strong></p><p id="df6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">self——调用任何类方法的实例引用。</p><p id="ab1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">num _ inches局部变量-总英寸数</p><p id="90e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">major _ length局部变量-破折号的数量</p><p id="04f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将上面的局部变量设置为实例变量</p><p id="a9e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">画线方法</strong></p><p id="4e77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">draw_line方法用指定数量的破折号和可选的整数英寸字符串标签绘制一个刻度。该函数执行一个主要绘制破折号的代码行和一个将刻度标签(整数)附加到所绘制的线的条件语句。这是一个非递归方法，是helper方法之一。</p><pre class="jp jq jr js fd kb kc kd ke aw kf bi"><span id="cdaf" class="kg kh hi kc b fi ki kj l kk kl">def draw_line(self, tick_length, tick_label=''):<br/>        line ='-'*tick_length<br/>        if tick_label:<br/>            line += ''+tick_label<br/>        print(line)</span></pre><p id="bdac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">绘制区间方法</strong></p><p id="13e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的工作是通过这种递归方法完成的。它在某个区间内绘制一系列小破折号，并参考该区间的中心刻度长度。绘制间隔的点将在绘制标尺方法中解释(下一节)。通常，中心分笔成交点长度CL&gt;0的区间由以下部分组成:</p><p id="b351" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中心刻度长度为CL-1的区间</p><p id="0de6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，使用参数CL-1调用draw_interval，这将在主要英寸范围内构造破折号。</p><p id="6219" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">长度为L的单个刻度</p><p id="760a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，使用参数CL调用draw_line，并生成中心长度。</p><p id="8d8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中心刻度长度为CL — 1的区间</p><p id="740c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，使用相同的CL-1参数调用另一个draw_interval，以在间隔内构造下一个破折号。</p><pre class="jp jq jr js fd kb kc kd ke aw kf bi"><span id="4366" class="kg kh hi kc b fi ki kj l kk kl">def draw_interval(self, center_length):<br/>        if center_length&gt;0:<br/>            self.draw_interval(center_length - 1)<br/>            self.draw_line(center_length)<br/>            self.draw_interval(center_length - 1)</span></pre><p id="f4a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">画尺子的方法</strong></p><p id="4337" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法用于通过获取总英寸数和主要刻度长度来构造整个标尺。在我们使用for循环绘制其他英寸的线条之前，首先绘制英寸“0”。迭代范围从1开始，因为我们之前已经构建了一条英寸“0”线。该循环不断调用draw_line方法来绘制线条。就在draw_line方法之前，我们需要调用draw_interval方法，它表示在draw_ruler构造中绘制区间的点。这个方法接受一个主长度小于1的参数(记住英语标尺标记部分中的关系)。</p><pre class="jp jq jr js fd kb kc kd ke aw kf bi"><span id="89c4" class="kg kh hi kc b fi ki kj l kk kl">def draw_ruler(self):<br/>        self.draw_line(self.__major_length, '0')<br/>        for j in range(1, 1+self.__num_inches):<br/>            self.draw_interval(self.__major_length- 1)<br/>            self.draw_line(self.__major_length, str(j))</span></pre><p id="30fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">画尺子</strong></p><p id="6e30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，为了生成一个4英寸的标尺，我们将英寸数参数设置为4和5个破折号。</p><pre class="jp jq jr js fd kb kc kd ke aw kf bi"><span id="e9bb" class="kg kh hi kc b fi ki kj l kk kl">if __name__ == '__main__':<br/>    ruler = EnglishRuler(4,5)<br/>    ruler.draw_ruler()</span></pre><p id="2577" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结果——4英寸英制尺子的一部分(水平窗格)</strong></p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/0b515e45e9242ed61f95b2d9c53a4268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*sB2pbU_TjxnPojh5837RVw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">英国尺子的一部分</figcaption></figure><p id="884a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">总结</strong></p><p id="bd57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">递归算法和迭代程序具有相同的解决问题的能力，它们可以互相替换。递归算法的优点是它提供了一种简洁而简单的编写代码的方法，但是它可能需要大量的空间和时间管理，因为所有的函数都将保留在堆栈中，直到它在基本情况下终止。</p><p id="8f53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，递归可以帮助您将复杂的代码转换成几行简单的代码。</p><p id="3bf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击查看完整代码<a class="ae lq" href="https://github.com/bleso-a/Recursion-with-Factorial-operation-and-English-Ruler-Drawing" rel="noopener ugc nofollow" target="_blank"/></p><p id="ce81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献</strong></p><p id="f9a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迈克尔·t·古德里奇、罗伯托·塔玛西亚和迈克尔·h·戈德瓦瑟。2013.Python中的数据结构和算法(第1版。由…编辑).威利出版公司</p><p id="a9e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">布拉德利·米勒和大卫·拉纳姆。2011.使用Python解决算法和数据结构的问题。由…编辑).美国富兰克林比德尔联合公司。</p><p id="df08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阿巴斯的递归算法</p></div></div>    
</body>
</html>