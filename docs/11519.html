<html>
<head>
<title>Signature Recognition Using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV进行签名识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/signature-recognition-using-opencv-2c99d878c66d?source=collection_archive---------0-----------------------#2020-12-07">https://medium.com/analytics-vidhya/signature-recognition-using-opencv-2c99d878c66d?source=collection_archive---------0-----------------------#2020-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3e35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">你是否曾梦想过在一家公司工作，而你的职责是向下滚动到20-50页，并验证最后一页的签名。看起来很简单，对吧？。但是想想看，你每天要做500，1000，2000个pdf。我相信任何人都会感到无聊和疲惫。</p><p id="bef5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将看到一个简单的技术解决方案，它可以使用基本的计算机视觉技术来验证签名。本文分为五个部分。第一部分是关于将pdf转换为图像，在第二和第三部分，我们将看到如何使用轮廓识别签名并将其框起来，在最后一部分，我们将向前迈出一步，了解提取签名闭合区域的形态学操作，并使用结构相似性指数(SSIM)验证签名</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="c10c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> PDF到图像的转换</strong></h1><p id="5b9b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了将pdf转换成图像，我们将使用pdf2image库。</p><p id="352f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">安装pdf2image的步骤:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f73f" class="lf ju hi lb b fi lg lh l li lj">pip install pdf2image</span></pre><p id="e3d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你使用的是Windows，那么从这个<a class="ae lk" href="https://github.com/oschwartz10612/poppler-windows/releases/" rel="noopener ugc nofollow" target="_blank">链接</a>下载弹出器，并解压文件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e31c" class="lf ju hi lb b fi lg lh l li lj">from pdf2image import convert_from_path<br/>import numpy as np</span><span id="a825" class="lf ju hi lb b fi ll lh l li lj">images = convert_from_path('Hospital Discharge Summary.pdf',               poppler_path='C:/Users/Ramji/Downloads/softwares/poppler/poppler-20.12.0/bin')</span><span id="a5be" class="lf ju hi lb b fi ll lh l li lj">#Visulaize the converted image<br/>for img in images:<br/>    img = np.array(img)<br/>    #resize the image to height of 500 and keep the same aspect ratio<br/>    ratio = img.shape[0]/500.0<br/>    plt.imshow(imutils.resize(img,height=1000))</span></pre><figure class="kw kx ky kz fd ln er es paragraph-image"><div class="er es lm"><img src="../Images/ea10a36681f710208aafbd80a62c5232.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*wfMlSpszkheCXN2uEVEwgA.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">原象</figcaption></figure></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><h1 id="1c8e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">轮廓检测</h1><p id="a25b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了从图像中识别签名的位置，我们需要首先识别轮廓。在这里，我将使用约翰·f·坎尼开发的<a class="ae lk" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank">坎尼边缘检测算法</a>来勾画轮廓，并找到围绕签名位置的轮廓。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1d70" class="lf ju hi lb b fi lg lh l li lj">img = np.array(images[-1])<br/>original = img.copy()<br/>ratio = img.shape[0]/500.0<br/>img = imutils.resize(img,height=500)<br/>orig = img.copy()</span><span id="a3be" class="lf ju hi lb b fi ll lh l li lj">#converting to grayscale image<br/>gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<br/>gray = cv2.GaussianBlur(gray,(5,5),0)</span><span id="7d38" class="lf ju hi lb b fi ll lh l li lj">plt.imshow(gray,'gray')<br/>edged = cv2.Canny(gray,80,200)<br/>plt.imshow(edged,'gray')</span></pre><div class="kw kx ky kz fd ab cb"><figure class="lu ln lv lw lx ly lz paragraph-image"><img src="../Images/077bdc616c3db6e93c714225555b0b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*zdDmm7l_6ZdFeLhp-tXI1g.png"/></figure><figure class="lu ln lv lw lx ly lz paragraph-image"><img src="../Images/92ec921ba5595cc00670221509a4b858.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*WTHDZwSPLNeXt6pOGu5h1w.png"/><figcaption class="lq lr et er es ls lt bd b be z dx ma di mb mc translated">灰度和边缘图像</figcaption></figure></div><p id="f40a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抓住正确的轮廓是一项任务，我们可以通过看到矩形来完成。圈出标志的等高线的面积应大于其他等高线。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="29f9" class="lf ju hi lb b fi lg lh l li lj">cnts = cv2.findContours(edged.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)<br/>cnts = imutils.grab_contours(cnts)<br/>cnts = sorted(cnts, key= cv2.contourArea, reverse=True)[:1]<br/>for c in cnts:<br/> peri = cv2.arcLength(c,True)<br/> apprx = cv2.approxPolyDP(c, 0.2*peri, True)<br/> x,y,w,h = cv2.boundingRect(apprx)<br/> cv2.rectangle(orig,(x,y),(x+w,y+h),(255,0,0),2)<br/>plt.imshow(orig)</span></pre><figure class="kw kx ky kz fd ln er es paragraph-image"><div class="er es lm"><img src="../Images/7559e41c044325f80ea1261a620a997f.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*nr14AbqkhoOMYDwpCm5U6g.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">检测到的签名</figcaption></figure><p id="fe4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的示例图像中，您可以看到签名已正确加框，但仍有一些白色区域。我们如何去除那些多余的空白呢？这是我们可以应用形态学运算的地方。我将在下一篇文章中讨论这个问题。感谢阅读！！！明天会见面:-)</p><p id="5903" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lk" href="https://ramji-b.medium.com/signature-recognition-using-opencv-part-2-62685586d566" rel="noopener">此处提供第2部分</a></p></div></div>    
</body>
</html>