<html>
<head>
<title>Segmentation of Products Using OpenCV- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV进行产品细分-第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/segmentation-of-products-using-opencv-part-1-4d5829679849?source=collection_archive---------17-----------------------#2020-12-10">https://medium.com/analytics-vidhya/segmentation-of-products-using-opencv-part-1-4d5829679849?source=collection_archive---------17-----------------------#2020-12-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="703e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分割可以定义为在任何空间中突出感兴趣的区域。它可以是从一本书上找到一个好句子，道路上的坑洼，x光片上的异常区域，商店里腐烂的水果或零售店货架上的任何产品。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/15f850d62631d50aef494394dd67aca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I84-PCI-kCuSkd7vDt_luQ.png"/></div></div></figure><p id="aa0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将使用OpenCV体验基本分割问题如何与基本简单编码一起工作。因此，我拍摄了一张包含5种产品(Lays、Kurkure、Top Yumm和Pepsi)的图片，并尝试分割其中一种产品。为了分割区域，我们必须遵循几个步骤。首先使用轮廓和边缘检测从图像中检测产品，正如我们在我的<a class="ae jp" href="https://ramji-b.medium.com/signature-recognition-using-opencv-2c99d878c66d" rel="noopener">上一篇文章</a>中看到的，然后分割仅覆盖区域并遮蔽其他产品。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="b53b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">边缘检测</strong></h1><p id="15a5" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在步骤1中，我们只是读取图像，并使用Canny边缘检测器可视化检测到的边缘。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="88e0" class="lf jy hi lb b fi lg lh l li lj">import cv2<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>image = cv2.cvtColor(cv2.imread(‘sample image.jpg’), cv2.COLOR_BGR2RGB)<br/>plt.figure(figsize=(15,5))<br/>plt.subplot(131)<br/>plt.imshow(image)<br/>plt.axis(‘off’)<br/>plt.title(‘Original Image’)<br/># plt.show()<br/>#converting to grayscale image<br/>gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br/>plt.subplot(132)<br/>plt.imshow(gray,’gray’)<br/>plt.axis(‘off’)<br/>plt.title(‘Gray Scale Image’)<br/># plt.show()<br/>gray = cv2.GaussianBlur(gray,(3,3),0)<br/>plt.subplot(133)<br/>plt.imshow(gray,’gray’)<br/>plt.axis(‘off’)<br/>plt.title(‘After Adding Gaussian Noise’)<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/07e26cfb6f610466d72e7a30a9ebda30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtPvw1ZZKPycdaJe37I7Nw.png"/></div></div></figure><p id="8355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拍摄照片时，由于外部因素，图像中可能会添加任何类型的噪声。这就是在预处理中向图像添加噪声的原因，这样，现有的噪声将处于相同的高斯分布中，并且使生活更容易。</p><p id="ef15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我试图在Canny检测器中使用各种阈值，但无法观察到图像上的任何边缘。换句话说，我可以说边缘检测器的输出不够清晰，无法找到产品的轮廓区域。我们现在必须换一种方式思考！！！</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="57e6" class="lf jy hi lb b fi lg lh l li lj">fig=plt.figure(figsize=(15,10))<br/>for idx,i in enumerate(range(10,150,25)):<br/> edged = cv2.Canny(gray,10,200)<br/> fig.add_subplot(2,3,idx+1)<br/> plt.imshow(edged,’gray’)<br/> plt.axis(‘off’)<br/> plt.title(‘Canny Edge Detector with Threshold: ‘ +str(i))<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/a2f8c0332524ed6b6f4a335250629fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oYCJsoSOA2DfQdyWFnmqA.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">具有不同阈值的Canny边缘检测器</figcaption></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="8b52" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">彩色图案</h1><p id="363b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">如果你仔细观察原始图像，我们可以看到背景大部分被较暗的一面(棕色)覆盖，因此想到查看图像的直方图来了解颜色的分布情况。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="5d0f" class="lf jy hi lb b fi lg lh l li lj">plt.figure(figsize=(15,5))<br/>plt.subplot(131)<br/>plt.imshow(image)<br/>plt.axis(‘off’)<br/>plt.title(‘Original Image’)<br/>plt.subplot(132)<br/>plt.hist(image.ravel(),25,[0,256])<br/>plt.title(“Histogram of colors”)<br/>plt.subplot(133)<br/>color = (‘b’,’g’,’r’)<br/>for i,col in enumerate(color):<br/> histr = cv2.calcHist([image],[i],None,[256],[0,256])<br/> plt.plot(histr,color = col)<br/> plt.xlim([0,256])<br/>plt.title(“histogram of colors”)<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/26b24d466ad5c743a53981f2c0863c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a94l8BF67hB1hNYyQSGICg.png"/></div></div></figure><p id="ccc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，查看直方图显示，蓝色波段的分布与红色和绿色波段略有不同。因此，使用不同的波段检测边缘可能会给出清晰的图像。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="542b" class="lf jy hi lb b fi lg lh l li lj">fig = plt.figure(figsize=(15,5))<br/>for idx,v in enumerate([‘R’,’G’,’B’]):<br/> fig.add_subplot(1,3,idx%3+1)<br/> plt.imshow(image[:,:,idx])<br/> plt.axis(‘off’)<br/> plt.title(v)<br/>plt.show()<br/>fig = plt.figure(figsize=(15,5))<br/>for idx,v in enumerate([‘R’,’G’,’B’]):<br/> fig.add_subplot(1,3,idx%3+1)<br/> img = image[:,:,idx]<br/> img = cv2.Canny(img,60,200)<br/> plt.imshow(img)<br/> plt.axis(‘off’)<br/> plt.title(v+’ Canny’)<br/>plt.show()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/bc6665f18cf8a18fcab119852ae428d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2DuFtzGL4aXP5z54I2wpw.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/6c433994fd0a029ccb7181ae12544472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLw0LBpXgFovwtleWy5Z2A.png"/></div></div></figure><p id="e03c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">耶！！！现在我们可以区分每个产品的边缘。在下一篇文章中，我们将看到如何分别在边缘产品上绘制轮廓，并使用不同的颜色将其分割出来。</p></div></div>    
</body>
</html>