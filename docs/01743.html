<html>
<head>
<title>A Custom Imputer — Why and How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义估算器—为什么和如何</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-custom-imputer-why-and-how-8076773a23ba?source=collection_archive---------22-----------------------#2019-11-11">https://medium.com/analytics-vidhya/a-custom-imputer-why-and-how-8076773a23ba?source=collection_archive---------22-----------------------#2019-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a475b888cc1700ca85490c78c1b35009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tv75L5xsIOhxCH0bcHWvew.jpeg"/></div></div></figure><p id="993b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今年早些时候，我们的三人数据科学团队聚集在一个小会议室，查看描述新模型特征行为的图表。我们在考虑生产一个新的模型，对我们来说，这个过程中的一个关键步骤就是戳戳这个模型，看看它是如何工作的。在这种情况下，这意味着为每个特性绘制部分依赖图，并检查每个特性的行为有多明智。</p><p id="8bee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">盯着这些图，有一件事很快变得很明显:某些分类特征表现得很奇怪。一些标签编码的分类特征在其估算值处具有很强的模型响应，导致其PDP图中出现奇怪的起伏。在聊了一下这些意味着什么以及该怎么做之后，我们决定通过修改我们的插补策略来研究这些特征到底是怎么回事。我们不是对每个特征进行均值或中值估算，而是对所有分类特征进行-1值估算，看看新的部分相关图是什么样的。我们认为，如果强模型响应随着估算值的变化而变化，这将是一个明确的信号，表明模型依赖于缺失值的存在，而不是直觉地与特征值有关系。</p><p id="509e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，我们结束了会议。现在是时候回到笔记本电脑上，开始编写一个自定义的估算器来处理这些分类变量了！</p><p id="a109" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想做的第一件事是看看Sci-kit Learn的<code class="du jo jp jq jr b">SimpleImputer</code>背后的代码。我对两件事很好奇:他们如何存储计算出的值，以备将来插补？他们在输入时如何应用这些存储的值？</p><p id="aff7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是时候深入一些SimpleImputer的源代码了。通读<a class="ae js" href="https://github.com/scikit-learn/scikit-learn/blob/1495f6924/sklearn/impute/_base.py#L84" rel="noopener ugc nofollow" target="_blank">的源代码</a>，我能够回答我脑海中的两个问题。估算值作为numpy数组存储在<code class="du jo jp jq jr b">statistics</code>属性中，并通过布尔掩码应用于空值。</p><p id="ec16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这一点，我们想到了一个快速实现估算器的设计。我们需要一种方法来识别分类特征，并将这些特征的存储估算值更改为-1。</p><p id="f3fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们看看我们能做些什么来识别分类特征。这对于自动化来说有点困难，但是分类特征背后的主要思想是存在一定数量的可能值来填充该特征。如果我们假设有一个大型数据集，我们可以做一些事情，比如检查由唯一值组成的要素数据的百分比。编程到Python中，该函数看起来会像这样(<a class="ae js" href="https://github.com/StatesTitle/ds-blog/blob/master/custom_imputer/dtype_imputer.py" rel="noopener ugc nofollow" target="_blank"> source here </a>):</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="4ba6" class="kb kc hi jr b fi kd ke l kf kg">def is_categorical(array, percent_unique_cutoff = 0.1):<br/>    test_array = array[~np.isnan(array)]<br/>    not_int = (test_array.astype(int) != test_array).sum()<br/>    if not_int:<br/>        return False<br/>    percent_unique = len(np.unique(test_array)) / len(array)<br/>    return percent_unique &lt; percent_unique_cutoff</span></pre><p id="5c96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们有了一种识别分类特征的方法，我们需要一种将它集成到估算器中的方法。正如我们之前提到的，在拟合估算值时，估算值作为numpy数组存储在<code class="du jo jp jq jr b">statistics</code>属性中。最容易实现的是修改<code class="du jo jp jq jr b">statistics</code>数组，并将识别的分类特征的估算值更改为我们想要的值-1。具体来说，我们将创建一个从<code class="du jo jp jq jr b">SimpleImputer</code>继承的新类，并修改<code class="du jo jp jq jr b">__init__</code>和<code class="du jo jp jq jr b">fit</code>方法来包含这个新功能。</p><p id="1f6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在代码中是什么样子的:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="545a" class="kb kc hi jr b fi kd ke l kf kg">import numpy as np<br/>from sklearn.impute._base import _get_mask<br/>from sklearn.impute import SimpleImputer</span><span id="ce09" class="kb kc hi jr b fi kh ke l kf kg">class DTypeImputer(SimpleImputer):</span><span id="2132" class="kb kc hi jr b fi kh ke l kf kg">def __init__(self, missing_values=np.nan, strategy="mean",<br/>                 fill_value=None, verbose=0, copy=True, add_indicator=False,<br/>                categorical_fill_value = -1):<br/>        self.missing_values = missing_values<br/>        self.strategy = strategy<br/>        self.fill_value = fill_value<br/>        self.verbose = verbose<br/>        self.copy = copy<br/>        self.add_indicator = add_indicator<br/>        self.categorical_fill_value = categorical_fill_value<br/>    <br/>    def fit(self, X, y=None):<br/>        """Fit the imputer on X.<br/>        Parameters<br/>        ----------<br/>        X : {array-like, sparse matrix}, shape (n_samples, n_features)<br/>            Input data, where ``n_samples`` is the number of samples and<br/>            ``n_features`` is the number of features.<br/>        Returns<br/>        -------<br/>        self : SimpleImputer<br/>        """<br/>        X = self._validate_input(X)</span><span id="5b98" class="kb kc hi jr b fi kh ke l kf kg"># default fill_value is 0 for numerical input and "missing_value"<br/>        # otherwise<br/>        if self.fill_value is None:<br/>            if X.dtype.kind in ("i", "u", "f"):<br/>                fill_value = 0<br/>            else:<br/>                fill_value = "missing_value"<br/>        else:<br/>            fill_value = self.fill_value</span><span id="9643" class="kb kc hi jr b fi kh ke l kf kg"># fill_value should be numerical in case of numerical input<br/>        if (self.strategy == "constant" and<br/>                X.dtype.kind in ("i", "u", "f") and<br/>                not isinstance(fill_value, numbers.Real)):<br/>            raise ValueError("'fill_value'={0} is invalid. Expected a "<br/>                             "numerical value when imputing numerical "<br/>                             "data".format(fill_value))</span><span id="a70f" class="kb kc hi jr b fi kh ke l kf kg">if sparse.issparse(X):<br/>            # missing_values = 0 not allowed with sparse data as it would<br/>            # force densification<br/>            if self.missing_values == 0:<br/>                raise ValueError("Imputation not possible when missing_values "<br/>                                 "== 0 and input is sparse. Provide a dense "<br/>                                 "array instead.")<br/>            else:<br/>                self.statistics_ = self._sparse_fit(X,<br/>                                                    self.strategy,<br/>                                                    self.missing_values,<br/>                                                    fill_value)<br/>        else:<br/>            self.statistics_ = self._dense_fit(X,<br/>                                               self.strategy,<br/>                                               self.missing_values,<br/>                                               fill_value)</span><span id="fd5f" class="kb kc hi jr b fi kh ke l kf kg">if self.add_indicator:<br/>            self.indicator_ = MissingIndicator(<br/>                missing_values=self.missing_values)<br/>            self.indicator_.fit(X)<br/>        else:<br/>            self.indicator_ = None<br/>            <br/>        mask = _get_mask(X, np.nan)<br/>        masked_X = np.ma.masked_array(X, mask=mask)<br/>        categorical_mask = np.apply_along_axis(is_categorical, 0, masked_X)<br/>        self.statistics_[categorical_mask] = self.categorical_fill_value<br/>        <br/>        return self</span></pre><p id="f387" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码实现后，我们使用这个新的估算器来生成另一组部分依赖图。通过观察这些数据，我们发现，模型的强烈响应是随着估算值的变化而变化的，这告诉我们，无论该特征是否有缺失数据，模型都具有预测能力。在某些情况下，最强有力的信号是我们是否有数据！</p><h1 id="30bc" class="ki kc hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">附言</h1><p id="1343" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">回顾我一年前写的代码，我惊讶于我从中学到了多少，以及它是多么的不必要。如果我更聪明，我会手动识别分类特征，并使用Sci-kit Learn的ColumnTransformer对连续和分类特征进行单独插补。</p><p id="79f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，与此同时，我不会像今天这样熟悉归罪。总而言之，这是我很高兴经历的一次锻炼。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="c787" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">最初发表于</em><a class="ae js" href="https://gist.github.com/b9ab868d8d378ad64f5261c836fef5e6" rel="noopener ugc nofollow" target="_blank"><em class="lr">http://github.com</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>