# PyTest 夹具的乐趣和利润

> 原文：<https://medium.com/analytics-vidhya/pytest-fixtures-for-fun-and-profit-9109d5ac2895?source=collection_archive---------23----------------------->

![](img/6734c09967f2ebdfc605ae92afce4a11.png)

克里斯里德在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在[我的上一篇文章](/analytics-vidhya/3-ways-to-test-any-application-effectively-with-pytest-35f2e99b2a1a)中，我谈到了为什么 PyTest 是对任何应用程序进行功能测试的伟大工具，以及将它集成到您的开发环境中的不同方法。现在，我将更深入地研究 PyTest 中对于编写好的功能测试至关重要的一个方面:fixtures。Fixtures 是用于建立和拆除测试环境的模块化工具，正确使用它们将允许您更好地构建测试代码，并使用更少的代码进行更多的测试。

**使用夹具安装和拆卸**

作为一个具体的例子，我将使用一个用 Go 编写的(非常)简单的应用程序，它启动一个 HTTP 服务器进程。我使用 Go 的原因是为了展示 PyTest 如何用于测试用任何语言编写的应用程序，而不仅仅是 Python。

一个超级基本的 HTTP 服务器，用 Go 写的

现在，我将使用 PyTest 为这个应用程序编写一个测试。应用程序的运行时状态封装在一个类中，该类公开 start()和 stop()方法。单个测试用例启动应用程序，发出 HTTP 请求，断言响应的状态和内容，然后停止应用程序。

测试我们应用的起点

从表面上看，这段代码可能看起来完全合理，但它实际上有一个严重的问题。如果我改变我的应用程序，返回一个不同的文本，打破第 49 行的断言，会发生什么？嗯，测试当然会失败——这是我们希望发生的。但这还不是全部:由于断言失败，测试用例的其余部分将不会执行，这意味着我们的应用程序的 stop()代码永远不会运行。如果您自己尝试，您会看到应用程序进程仍然在运行，即使 python 进程已经退出。

```
ps -ef | grep '\./app'
  501  1656     1   0 12:54pm ttys001    0:00.01 ./app
```

即使测试失败，它们也不应该泄漏资源，如进程、线程、文件句柄或套接字。它们不仅浪费您的系统资源，泄漏的资源还会通过交互以意想不到的方式导致后续测试失败。例如，如果我测试的应用程序总是在同一个端口上侦听，在测试结束时未能正确停止应用程序将意味着重新运行测试将总是失败，因为端口仍在使用中。

为了确保`stop()`总是被调用，你可以将测试用例断言包装在一个`try...finally`块中，或者你可以将 App 类放入一个[上下文管理器](https://alysivji.github.io/managing-resources-with-context-managers-pythonic.html)中，或者使用老式的[安装和拆卸函数](https://docs.pytest.org/en/latest/xunit_setup.html)来达到同样的效果。然而，有一个更好的方法:夹具。

将应用程序设置分解到一个设备中

注意`app`夹具如何使用`yield`关键字将启动的`App`对象传递到测试函数中。测试用例完成后，不管它是通过还是失败，app fixture 都将恢复并终止 app 进程。通过将应用程序的安装和拆卸代码放在同一个函数中，可以很容易地看到拆卸代码是如何对应于用单独的安装和拆卸方法无法获得的安装内容的。在我们的测试函数中使用 fixture 所要做的就是将 fixture 名称作为测试函数的参数，因此我们的测试函数中的代码只需要处理正在进行的实际的*测试*。

**更进一步:夹具范围**

夹具是可重用的，所以当你开发你的应用程序时，你可以继续添加更多依赖于同一个应用程序夹具的测试。然而，当你这样做的时候，你需要记住夹具的范围。默认情况下，fixture 有“function”作用域，这意味着 fixture 的一个新实例将被建立，然后为每个使用它的函数而被拆除。我上面的示例应用程序应该为任何 HTTP 方法返回完全相同的响应，所以我将为 PUT 和 POST 方法添加几个测试。当我运行测试并用`-s`标志禁用 stdout 捕获时，我可以看到我的应用程序启动和停止了 3 次:

```
test_app.py::test_app Starting app
PASSEDStopping apptest_app.py::test_app_put Starting app
PASSEDStopping apptest_app.py::test_app_post Starting app
PASSEDStopping app
```

保持 fixture 范围较小有一个好处——通过为每个测试创建一个新实例，您可以防止其他测试对应用程序的副作用影响后续测试。然而，缺点是当您添加更多的测试用例时，您的测试将需要更长的时间来运行。我们可以通过将 fixture 的范围改为“模块”来加快我们的测试:

在测试函数之间共享相同的应用程序实例

现在，该模块中依赖于 app fixture 的所有测试都将使用一个共享实例。PyTest 将启动应用程序进程，对它运行我们所有的测试，然后停止应用程序。Fixture 作用域也可以设置为“class”、“package”或“session ”,分别应用于同一类、包或测试会话中的所有测试。对于您应该使用哪个作用域，并没有严格的规则，但是作为一般的经验法则，您应该使用最低级别的作用域，它允许您的测试在合理的时间长度内完成。因为我们的应用程序启动非常快，而且我们现在只有三个测试，所以在我们的小例子中使用函数作用域 fixture 是很好的，但是对于一个实际复杂的应用程序以及数十或数百个测试用例，至少在模块作用域共享应用程序实例是有意义的。如果您的 fixture 设置非常昂贵，例如，如果您的测试需要在单独的 docker 容器中运行大量服务(看一看 [pytest-docker](https://github.com/avast/pytest-docker) )，您可能会希望将 fixture 留在会话范围内。请记住，您需要特别小心，以避免在使用共享 fixture 实例的测试之间出现意外的副作用。

**用参数化增加你的测试**

参数化是一种非常有用的增加测试覆盖率的技术。您可能知道，参数化可以应用于测试函数，以从单个模板生成多个测试。例如，我可以使用参数化简化我之前对各种 HTTP 方法的测试。

这还不是全部:您还可以参数化 fixture 函数，从单个模板生成多个不同的 fixture。对于夹具的每个参数化，所有使用参数化夹具的测试将运行一次。参数化夹具函数的方式与测试函数略有不同，但效果是相同的。

参数化我们的夹具和测试

**灯具可以依赖其他灯具**

夹具是模块化的，这意味着夹具功能可以依赖于其他夹具，而其他夹具又可以依赖于其他夹具等。Fixture 模块化证明是非常强大的，因为它允许您将多个相互依赖的应用程序和服务编排到一个测试环境中。一个简单而常见的例子是当您需要使用一个客户端来连接到您的被测服务器进程时。通过将测试客户机包装在依赖于服务器夹具的夹具中，客户机可以(例如)提取服务器的监听地址以允许它连接，而不依赖于硬编码的端口。

回到我们前面的例子，我们可以创建一个 AppClient 类来存储应用程序地址，并使访问服务器上的 URL 稍微简单一些。请注意，我不再需要使`app` fixture 成为`test_app`函数的显式依赖项，因为它现在通过`app_client`间接依赖。还要注意`app_client` fixture 是如何具有“function”作用域的，因此将为每个测试创建一个新实例——这很好，因为初始化客户机的成本很低。`app` fixture 仍然是“模块”范围的，所以只启动了一个应用程序实例。

添加 app_client 设备

**总之**

我们已经讨论了如何在 PyTest 中使用 fixtures 将安装和拆卸从测试代码中分离出来。除此之外，我们还通过一个例子展示了如何使用 fixture 来管理运行在独立进程中的应用程序，fixture 作用域的重要性，以及如何使用参数化和模块化 fixture 来用更少的代码进行更多的测试。