<html>
<head>
<title>Python: Under the hood [Memory Allocation &amp; Management]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python:Under the hood[内存分配和管理]</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-under-the-hood-draft-2-7191d4da48aa?source=collection_archive---------17-----------------------#2020-05-02">https://medium.com/analytics-vidhya/python-under-the-hood-draft-2-7191d4da48aa?source=collection_archive---------17-----------------------#2020-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fd12349ec89f2f97846532ff3c6fed11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEe9IbjHWD496KHqDVKuCg.jpeg"/></div></div></figure><p id="4338" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗨，在本文中，我们将学习python的一些核心概念，但不涉及编码。</p><p id="9f03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，你可能会问，为什么我们会关心那些本来应该“藏在引擎盖下”的东西，对吗？嗯，作为一名开发人员，了解编程语言是如何工作的是很有用的。因为它可以揭开发生在你不知道的背景中的神奇事物的秘密。</p><p id="ff3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于某种原因，如果你的意识告诉你，这将是具有挑战性的。相信我，不是的。这些都是相对简单的概念，就像Python语言本身一样。</p><p id="653b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们将在本系列文章中涉及的主题列表。</p><ol class=""><li id="70bb" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Python中的内存分配和管理</li><li id="b5c4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">碎片帐集</li><li id="cd1f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">GIL(全局解释器锁)</li></ol></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="2e75" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">Python中的内存分配和管理</h2><p id="81f2" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">了解内存管理可能有助于您编写高效的代码。即使您可能无法控制内存分配，但是您可以优化您的程序来更好地分配它。</p><p id="7b64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们深入挖掘之前，请记住:</p><blockquote class="lj lk ll"><p id="622f" class="iq ir lm is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated">在python中，一切都是对象。</p></blockquote><p id="b4d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像C、C++或Java这样的语言将值存储在内存中，有一个变量指向那个内存位置。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/46df2556ae435b1b39ea2f07b0160370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOHcGNwodrw6YxLvog9NdA.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">C语言中的内存分配</figcaption></figure><p id="25cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而在python中，整个对象存储在内存中(堆内存)；对象可以是整数、字符串或列表，变量指向一个对象。令人困惑。对吗？</p><p id="a1f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了有意义，让我们理解python对象包含什么！</p><p id="01b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内存中的对象保存</p><ol class=""><li id="ae84" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><em class="lm">类型:整型、字符串型、浮点型等</em></li><li id="5e23" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><em class="lm">引用计数:绑定到该对象的引用数量</em></li><li id="3fc8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><em class="lm">价值:价值/数据/信息</em></li></ol><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/8e8b8fea21f740053d7bd05132cdf3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7jFdcJNRiP43MYExh-VDw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">对象(a=200)</figcaption></figure><p id="e132" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，每当你创建一个变量，比如说<strong class="is hj"> <em class="lm"> a = 200 </em> </strong>，在内存中创建一个新的PyObject，它的ref count设置为1，变量“<strong class="is hj"><em class="lm">a”</em></strong>指向它。</p><p id="4fe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧。<strong class="is hj">但是什么是ref count呢？</strong></p><p id="7323" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们举个例子来了解一下。</p><p id="900f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个值为200的整型变量"<strong class="is hj"> <em class="lm">"一个"</em> </strong>"假设我需要另一个名为“<strong class="is hj"><em class="lm">b”</em></strong>的整型变量，其值为200。</p><p id="b365" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你已经创建了两个这样的变量。</p><blockquote class="ma"><p id="a003" class="mb mc hi bd md me mf mg mh mi mj jn dx translated">a=200</p><p id="bc18" class="mb mc hi bd md me mf mg mh mi mj jn dx translated">b=200</p></blockquote><p id="c298" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hb bi translated">现在，你可能会猜测；内存中必须有两个对象为变量"<strong class="is hj"> <em class="lm"> a" </em> </strong>和"<strong class="is hj"> <em class="lm"> b" </em> </strong>。但事实并非如此。<strong class="is hj"><em class="lm">a</em></strong>和<strong class="is hj"><em class="lm">b</em></strong>都指向同一个对象。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/7a52cedd3ff75595bb187f46ed97f1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgyDkzIVMNJeGIi93ueYAw.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">变量a和b引用同一个对象</figcaption></figure><p id="1308" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过代码验证这一点。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/f68cc49645cb74d5cd469c8c81e94ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVtUGjIengkVj41xT-kgYQ.png"/></div></div></figure><p id="1647" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以看到，变量"<strong class="is hj"><em class="lm">【a】</em></strong>和"<strong class="is hj"><em class="lm">【b】</em></strong>具有相同的id(内存位置)因此，表示相同的对象，而c具有不同的id值。因此，目前在内存中，有两个python对象。</p><p id="acb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，如果我们给"<strong class="is hj"><em class="lm"/></strong>赋值一个新值，即<strong class="is hj"> <em class="lm"> a = 3 </em> </strong>，会发生什么呢？</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/b0fd8107aec8a693fd5c16d5a1166a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QCy0R6hKAMP8smI8APUAA.png"/></div></div></figure><p id="89d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lm"/></strong>“a”现在指向一个新的对象，但是“<strong class="is hj"><em class="lm">”b“</em></strong>仍然指向同一个对象。</p><p id="ca85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是让我们考虑这个例子。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/37d0c9e2cbf4c611c3af61daa8b94d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWgepWPa8Twz5zfhrXC1aw.png"/></div></div></figure><p id="a6e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，<strong class="is hj"> <em class="lm"> a =1 </em> </strong>但是“<strong class="is hj"><em class="lm">b”</em></strong>的值为“<strong class="is hj"><em class="lm">a”</em></strong>。当我们改变"<strong class="is hj"> <em class="lm"> a" </em> </strong>的值时，是否也会影响"<strong class="is hj"> <em class="lm"> b" </em> </strong>？让我们看看。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/b6786fd2ebe57d28a486509eca868fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZuCSIe795W51YWn--UliQ.png"/></div></div></figure><p id="943e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lm">【a】</em></strong>现在指向一个新的对象，但是<strong class="is hj"><em class="lm">【b】</em></strong>仍然指向较老的对象。相当令人惊讶。<strong class="is hj">但是为什么？</strong></p><p id="9aae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为"<strong class="is hj"><em class="lm">【b】</em></strong>并不直接指向变量"<strong class="is hj"><em class="lm">【a】</em></strong>而是变量"<strong class="is hj"><em class="lm"/></strong>的对象。这就是裁判计数的作用。它跟踪指向它的变量的数量。</p><p id="2f19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个有趣的问题是，<strong class="is hj">如果一个对象的引用计数变为零会发生什么？</strong></p><p id="03b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此之前，让我们看看如何删除对一个对象的引用。</p><ol class=""><li id="fc96" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">德尔</strong></li></ol><p id="04e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python内置的del关键字帮助我们删除这些指向对象的引用。其实有人认为del是把对象从记忆中移除了，事实并非如此。</p><p id="d4d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，你可以像这样使用del来删除一个引用。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/5cc9e90855b1d73c7b944e2985aec6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjF_bv2hk9DnM813pHOe5g.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">删除对对象的引用</figcaption></figure><p id="6f8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hj">超出范围</strong></p><p id="014b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对对象的引用一旦超出范围就会被自动删除。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/2053d813e2349fa3ed7c1a0681e4309f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBXwADWmqpM3eQsB8cfccQ.png"/></div></div></figure><p id="a07f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以上面的代码为例，变量“<strong class="is hj"><em class="lm">【x】</em></strong>的对象在scope()函数内部会有+1的ref count，但是随着解释器离开这个函数作用域，PyObject的ref count减少到-1，因为“<strong class="is hj"><em class="lm">【x】</em></strong>是一个局部变量，只对它的函数有作用域。</p><p id="4983" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也是python不鼓励使用全局变量的原因之一，因为全局范围内的变量会影响整个程序。</p><p id="d66c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。将新对象赋给变量。</strong></p><p id="e23a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当把一个新对象赋给一个已经存在的变量时，前一个对象的引用计数减少到-1。</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/1a1124b1a4b3e5ceaefe67e0bd4d920f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5Mp2XnSuLqIaCYUIWgDfQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">通过分配新对象来减少对象的引用计数</figcaption></figure><p id="de01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在回到上一个问题，<strong class="is hj"> <em class="lm">当一个对象的引用计数为0时会发生什么？它会留在记忆里吗？</em>T3】</strong></p><p id="d538" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案是否定的。</p><blockquote class="ma"><p id="be0e" class="mb mc hi bd md me mf mg mh mi mj jn dx translated">一旦对象的引用计数变为0。它被垃圾收集器从内存中清除。你可以把垃圾收集器想象成一个清洁工，它清理所有的剩菜和将来不会被使用的废物，这种技术被称为“垃圾收集”。</p></blockquote><p id="730b" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hb bi translated">我们将在下一篇文章中更详细地讨论python中的垃圾收集。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="9375" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lm">注:如果你有任何疑问或建议，我很乐意在评论中回复，我也需要这些可爱的掌声来激励自己写更多的文章，所以请务必这样做。</em></p></div></div>    
</body>
</html>