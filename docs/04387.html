<html>
<head>
<title>Computer Vision — Harris Corner Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉—哈里斯角点检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/computer-vision-harris-corner-detection-30d63a6e793d?source=collection_archive---------14-----------------------#2020-03-17">https://medium.com/analytics-vidhya/computer-vision-harris-corner-detection-30d63a6e793d?source=collection_archive---------14-----------------------#2020-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Chris Harris和Mike Stephens提出了一种算法，这种算法非常强大，能够检测出图像中的角点，这是一种非常有用的功能。要定义一个角，就从图像处理技术方面来说吧。拐角可以被认为是两个边缘的接合处，其中边缘是像素亮度或强度的突然变化，并且构成梯度。角点很重要，因为它们被认为是对平移、旋转和光照不变的特征点，但不幸的是，它们不是尺度不变的。我们将在后面的文章中讨论这个问题。</p><p id="5555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使事情变得简单，该算法基本上找到了所有方向的位移(u，v)的像素强度的差异。然后，当在图像中的像素上滑动窗口时，我们找到移动前后像素值的平方差之和(SSD ),以确定强度变化。函数E(u，v)定义为所有平方差之和的和。Ix和Iy是x和y方向上的图像导数，也可以被认为是像素的强度值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fe7dacbee4aa3ed15ccc92ccaf9a2d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*JuCVwwIsIS19BhvdtiR5Hw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">所有平方差之和(SSD)</figcaption></figure><p id="f282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了求解这个方程，我们将不得不通过应用泰勒展开式来最大化这个方程，特别是第二项。我们得到这样一个等式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/26acd7155635a68da6cb2ff0a44672db.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*yOPkwLAPDEdhiFAH-GN53w.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">膨胀后</figcaption></figure><p id="e440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式的这一部分可以总结为以下步骤:</p><ol class=""><li id="a1fd" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">应用Sobel算子找出图像在x和y方向上的导数。</li><li id="5818" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">乘以窗口意味着灰度(我们通常将图像转换为灰度以进行图像处理)图像中的每个像素，我们在图像上滑动窗口以找到哈里斯值r。</li><li id="390c" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">设置一个阈值，对于超过该阈值的像素，考虑该窗口中的局部极值，并且该区域包含一个角点！</li><li id="0401" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">当然，我们可以在这里继续计算特征描述符。</li></ol><p id="34de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且函数E(u，v)变成:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/a56f8531e05dfc9105afd779ccb0e303.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*yShYUikPfB1gmhgLjE_Rag.png"/></div></figure><p id="23b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，为了找出图像中的点是否是特征点，E(u，v)的值必须很大。意思是，如果有一个角，E(u，v)会是一个很大的值。为了计算，我们可以求解M的特征向量，以确定SSD最大和最小增加的方向。基本上，他们提出了这样的条件:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kf"><img src="../Images/b75604fd1065fe379d722120f28d1d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*zNwlHOkkWd3PfT3xTWkLLw.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kg"><img src="../Images/b9dd5fac305a8ad1d26f192b009a1bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*45iDhnABIlpkZ_E2NoBqqQ.png"/></div></figure><p id="4e68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过求解R，我们可以通过以下条件知道在图像中的该点处是否存在拐角:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kh"><img src="../Images/a81d94d87d0a48f05123876eb20dc217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Py0EYWRiww1VgJ8wveyZ6g.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es km"><img src="../Images/72e36e8f5327277bdfd9033959673623.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*GBekTbxkNpeTw0o8.jpg"/></div></figure><p id="c938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，这就是哈里斯角检测背后的数学原理！要查看实际情况，您可以尝试OpenCV中的<em class="kn"> cornerHarris() </em>函数，该函数返回一个Harris分数R，它需要阈值来给出角点。</p></div></div>    
</body>
</html>