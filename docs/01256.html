<html>
<head>
<title>How To Write Validating and Mutating Admission Controller Webhooks in Python for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python为Kubernetes编写验证和变更准入控制器Webhooks</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-write-validating-and-mutating-admission-controller-webhooks-in-python-for-kubernetes-1e27862cb798?source=collection_archive---------1-----------------------#2019-10-11">https://medium.com/analytics-vidhya/how-to-write-validating-and-mutating-admission-controller-webhooks-in-python-for-kubernetes-1e27862cb798?source=collection_archive---------1-----------------------#2019-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/688c2ee376dee92147104fc99c34a4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8d0BzJEBzEGF9Xbs47X-A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Mattia Serrani 在<a class="ae iu" href="https://unsplash.com/search/photos/gate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="65d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">准入控制器Webhooks是控制部署到Kubernetes集群的一个很好的方法。在这个故事中，我们将介绍如何使用Python web framework Flask来编写这两者。假设读者对Kubernetes中资源如何工作以及如何将Flask应用程序部署到Kubernetes集群有一些基本的了解。</p><h2 id="8fab" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">准入控制员Webhook是做什么的？</strong></h2><p id="192f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">创建、修改或删除Kubernetes资源时，会触发准入控制器Webhook。本质上，一个HTTP请求被发送到一个名称空间中指定的Kubernetes服务，该服务返回一个JSON响应。根据该响应，采取行动。</p><p id="574b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两类准入控制器，验证和变异。验证接纳控制器验证传入的请求，并基于自定义逻辑返回二进制响应“是”或“否”。例如，如果Pod资源没有特定的标签，请求将被拒绝，并显示一条消息说明原因。变异准入控制器基于定制逻辑修改传入请求。一个例子是，如果入口资源没有正确的注释，将添加正确的注释，并且该资源将被接纳。</p><p id="6e71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上述场景中，准入控制器非常强大，可以非常精确地控制Kubernetes集群的进出。现在让我们开始吧。</p><p id="c9b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kt">注意:下面显示的代码示例已经在Kubernetes版本</em> <strong class="ix hj"> <em class="kt"> 1.14.2中测试过。</em> </strong> <em class="kt">请阅读文档获取最新版本。</em></p><p id="46d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">编写验证准入控制器Webhook </strong></p><p id="08f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始之前，让我们创建一个规范:</p><ul class=""><li id="35a3" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated">我们将验证一个部署资源，以检查它是否有标签。如果标签不存在，那么我们拒绝该请求。</li><li id="b880" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">当创建新部署时，会发生上述情况。</li></ul><p id="43e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kt">validating _ admission _ controller . py</em></p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="73a5" class="jt ju hi ln b fi lr ls l lt lu">from flask import Flask, request, jsonify</span><span id="8ee1" class="jt ju hi ln b fi lv ls l lt lu">admission_controller = Flask(__name__)</span><span id="6816" class="jt ju hi ln b fi lv ls l lt lu"><a class="ae iu" href="http://twitter.com/admission_controller" rel="noopener ugc nofollow" target="_blank">@admission_controller</a>.route('/validate/deployments', methods=['POST'])<br/>def deployment_webhook():<br/>    request_info = request.get_json()</span><span id="b412" class="jt ju hi ln b fi lv ls l lt lu">    if request_info["request"]["object"]["metadata"]["labels"].get("allow"):<br/>        return admission_response(True, "Allow label exists")</span><span id="ce77" class="jt ju hi ln b fi lv ls l lt lu">    return admission_response(False, "Not allowed without allow label")</span><span id="629a" class="jt ju hi ln b fi lv ls l lt lu">def admission_response(allowed, message):<br/>    return jsonify({"response": {"allowed": allowed, "status": {"message": message}}})</span><span id="e8ff" class="jt ju hi ln b fi lv ls l lt lu">if __name__ == '__main__':<br/>    admission_controller.run(host='0.0.0.0', port=443, ssl_context=("/server.crt", "/server.key"))</span></pre><p id="9818" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面，我们编写了一个函数，它执行以下操作:</p><ul class=""><li id="51c9" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated">获取传入的请求对象。在我们的例子中，当我们注册下面的验证控制器时，我们可以假设该对象将始终是一个部署资源。</li><li id="3df3" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">检查“允许”标签是否存在。返回一个JSON HTTP响应，如果存在的话，将允许的布尔值设置为True，并显示一条消息。</li><li id="34db" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">如果不满足上述条件，我们将始终拒绝创建任何部署资源。</li></ul><p id="b352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在可以部署上述内容。我们不会深入讨论如何部署上述内容的细节，但我会快速列出要点:</p><ul class=""><li id="ac85" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated">从安装了Flask的<em class="kt"> admission_controller.py </em>创建一个Docker映像。</li><li id="9adc" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">生成自签名CA，生成csr和证书，然后基于此证书创建一个秘密。</li><li id="7446" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">从名称空间中创建的Docker映像创建部署。该服务必须通过SSL进行保护。将上一步中创建的机密作为卷安装到部署中。</li><li id="4b5c" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">在与部署相同的名称空间中创建指向正确端口的服务。</li></ul><p id="af42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要注册我们的验证控制器，我们需要应用以下配置:</p><p id="f2d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kt">validating _ admission _ web hook . YAML</em></p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="9858" class="jt ju hi ln b fi lr ls l lt lu">apiVersion: admissionregistration.k8s.io/v1beta1<br/>kind: ValidatingWebhookConfiguration<br/>metadata:<br/>  name: validating-webhook<br/>  namespace: test<br/>webhooks:<br/>  - name: test.example.com<br/>    failurePolicy: Fail<br/>    clientConfig:<br/>      service:<br/>        name: test-validations<br/>        namespace: test<br/>        path: /validate/deployments<br/>      caBundle: &lt;redacted&gt; # a base64 encoded self signed ca cert is needed because all Admission Webhooks need to be on SSL<br/>    rules:<br/>      - apiGroups: ["apps"]<br/>        resources:<br/>          - "deployments"<br/>        apiVersions:<br/>          - "*"<br/>        operations:<br/>          - CREATE</span></pre><p id="003a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们可以看到我们只对部署感兴趣，因为我们缩小了web钩子将执行的资源。CN(在我们的例子中)deployment-test.test.svc需要一个自签名的SSL证书。</p><p id="b8b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过运行以下命令来应用上述内容:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="5cde" class="jt ju hi ln b fi lr ls l lt lu">kubectl apply -f validating_admission_webhook.yaml</span></pre><p id="ee87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要进行验证，请在元数据部分创建一个带有“allow”标签的新部署，可以使用任何值，这样就应该创建了。比如我们可以尝试部署nginx。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="4566" class="jt ju hi ln b fi lr ls l lt lu">apiVersion: apps/v1beta2<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: nginx<br/>  name: nginx<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx<br/>    spec:<br/>      containers:<br/>      - name: nginx<br/>        image: nginx:1<br/>        ports:<br/>        - name: http<br/>          containerPort: 80</span></pre><p id="c495" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述操作将失败，并显示以下消息:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="7691" class="jt ju hi ln b fi lr ls l lt lu">Error from server: error when creating "nginx.yaml": admission webhook "test.example.com" denied the request: Not allowed without allow label</span></pre><p id="0332" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尝试添加允许标签，看看它是否通过。如果你需要帮助，请在评论区联系我们。</p><p id="c71d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">编写一个变异准入控制器Webhook </strong></p><p id="0f82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始之前，让我们创建一个规范:</p><ul class=""><li id="095c" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated">我们将改变一个部署资源和一个标签。</li><li id="f92c" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">当创建新部署时，会发生上述情况。</li></ul><p id="442a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kt">变异_准入_控制器. py </em></p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="42a0" class="jt ju hi ln b fi lr ls l lt lu">from flask import Flask, request, jsonify<br/>import base64<br/>import jsonpatch</span><span id="c8b2" class="jt ju hi ln b fi lv ls l lt lu">admission_controller = Flask(__name__)</span><span id="8373" class="jt ju hi ln b fi lv ls l lt lu"><a class="ae iu" href="http://twitter.com/admission_controller" rel="noopener ugc nofollow" target="_blank">@admission_controller</a>.route('/mutate/deployments', methods=['POST'])<br/>def deployment_webhook_mutate():<br/>    request_info = request.get_json()<br/>    return admission_response_patch(True, "Adding allow label", json_patch = jsonpatch.JsonPatch([{"op": "add", "path": "/metadata/labels/allow", "value": "yes"}]))</span><span id="e4f6" class="jt ju hi ln b fi lv ls l lt lu">def admission_response_patch(allowed, message, json_patch):<br/>    base64_patch = base64.b64encode(json_patch.to_string().encode("utf-8")).decode("utf-8")<br/>    return jsonify({"response": {"allowed": allowed,<br/>                                 "status": {"message": message},<br/>                                 "patchType": "JSONPatch",<br/>                                 "patch": base64_patch}})<br/>if __name__ == '__main__':<br/>    admission_controller.run(host='0.0.0.0', port=443, ssl_context=("/server.crt", "/server.key"))</span></pre><p id="5253" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面，我们编写了一个函数，它执行以下操作:</p><ul class=""><li id="eee0" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated">获取传入的请求对象。在我们的例子中，我们可以假设当我们注册下面的变异控制器时，该对象将始终是一个部署资源。</li><li id="25dd" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">添加一个值为“yes”的allow标签，并在响应中返回base64编码的JSONPatch。</li></ul><p id="4864" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署细节类似于验证准入控制器，请参考上一节。要注册我们的变异控制器，我们需要创建以下内容。</p><p id="8f24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kt">mutating _ admission _ web hook . YAML</em></p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="753a" class="jt ju hi ln b fi lr ls l lt lu">apiVersion: admissionregistration.k8s.io/v1beta1<br/>kind: MutatingWebhookConfiguration<br/>metadata:<br/>  name: mutating-webhook<br/>  namespace: test<br/>  labels:<br/>    component: mutating-controller<br/>webhooks:<br/>  - name: test.example.com<br/>    failurePolicy: Fail<br/>    clientConfig:<br/>      service:<br/>        name: test-mutations<br/>        namespace: test<br/>        path: /mutate/deployments<br/>      caBundle: &lt;redacted&gt; # a base64 encoded self signed ca cert is needed because all Admission Webhooks need to be on SSL<br/>    rules:<br/>      - apiGroups: ["apps"]<br/>        resources:<br/>          - "deployments"<br/>        apiVersions:<br/>          - "*"<br/>        operations:<br/>          - CREATE</span></pre><p id="b014" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们可以再次看到，我们只对部署感兴趣。CN(在我们的例子中)test-mutations.test.svc需要一个自签名的SSL证书。</p><p id="7c36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过运行以下命令来应用上述内容:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="29f0" class="jt ju hi ln b fi lr ls l lt lu">kubectl apply -f mutating_admission_webhook.yaml</span></pre><p id="3bbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要进行验证，请创建一个新部署，允许标签将添加到新部署中:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="2f16" class="jt ju hi ln b fi lr ls l lt lu">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  ...<br/>  labels:<br/>    <strong class="ln hj">allow: "yes"</strong><br/>    app: nginx<br/>  name: nginx<br/>  ...</span></pre><p id="3b3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，我希望这是有用的。如果你遇到任何问题，请在评论区回复。</p></div></div>    
</body>
</html>