<html>
<head>
<title>Class Composition Vs Inheritance in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的类组合与继承</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/class-composition-vs-inheritance-in-python-2fb4a788b330?source=collection_archive---------15-----------------------#2020-07-31">https://medium.com/analytics-vidhya/class-composition-vs-inheritance-in-python-2fb4a788b330?source=collection_archive---------15-----------------------#2020-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/b480fd9fa636631a62e7abebe2f9f592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*iRaGXfGwiuOtaz65sWKU3Q.jpeg"/></div></figure><div class=""/><h1 id="c570" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="39ef" class="pw-post-body-paragraph jk jl hp jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">类组合是 python 中的一个特性，可以用来代替继承。它比继承有用得多，因为它使我们的代码更简单，可读性更好。看看这段代码:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="332f" class="kr in hp kn b fi ks kt l ku kv">class Box:<br/>    <br/>    def __init__(self, quantity):<br/>        self.quantity = quantity<br/><br/>    def __str__(self):<br/>        return f"The box contains {self.quantity} pens."<br/><br/>box = Box(5)<br/><br/>class Pen(Box):<br/><br/>    def __init__(self, name, quantity):<br/>        super().__init__(quantity)<br/>        self.name = name<br/><br/>    def __str__(self):<br/>        return f"This is a {self.name}"<br/><br/>pen = Box("Ball pen", 5)<br/>print(pen)</span></pre><h1 id="9902" class="im in hp bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">让我们分析一下方法</h1><p id="8b55" class="pw-post-body-paragraph jk jl hp jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这没有多大意义，因为在这段代码中，类“Pen”继承了类“Box”。这个想法是，一个盒子里装着钢笔。这里我们需要在 pen 类中使用 __str__ 方法，这样就可以避免打印“盒子里有 5 支钢笔”，而在打印 Pen 类的对象时打印“这是一支圆珠笔”。这或许可行，但不是一个好方法，原因有二</p><p id="b52c" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated"><strong class="jm hq">概念上的问题</strong> —概念上的问题是，当我们做继承的时候，我们认为这是一种进化的继承。这意味着钢笔是一个盒子，而不仅仅是一个东西。盒子仍然可以单独使用。当我们谈论盒子和钢笔时，这是行不通的，因为与盒子相比，钢笔是一个完全不同的物体。一个盒子里可能有许多支钢笔，但其中一支不是另一支。</p><p id="3738" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated"><strong class="jm hq">技术问题</strong> —技术问题，为什么这不工作是因为我们有这个继承自 box 的 pen 类，但是我们并没有真正在里面使用 box 类中的任何东西。在这里，我们完全覆盖了 __str__ 方法，因为我们不想在这里使用 box。我们实际上根本不需要这些，因为如果我们不打算在方法中使用它，设置数量是没有意义的。</p><p id="2be1" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">所以概念上的原因是笔不是盒子，技术上的原因是如果我们不用它来继承任何东西，就没有理由使用继承。这就是作文的用武之地。</p><p id="a237" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">我们可以使用构造函数来接收一些笔，而不是在框中输入数量。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3982" class="kr in hp kn b fi ks kt l ku kv">class Box:</span><span id="3fb4" class="kr in hp kn b fi lb kt l ku kv">     def __init__(self, *pens):</span><span id="c6f5" class="kr in hp kn b fi lb kt l ku kv">	 self.pens = pens</span><span id="4fa7" class="kr in hp kn b fi lb kt l ku kv">     def __str__(self):</span><span id="06ef" class="kr in hp kn b fi lb kt l ku kv">	 return f"This box contains {len(self.pens)} pens."<br/></span><span id="a583" class="kr in hp kn b fi lb kt l ku kv">class Pen(Box):</span><span id="a5a0" class="kr in hp kn b fi lb kt l ku kv">    def __init__(self, name):</span><span id="7f0f" class="kr in hp kn b fi lb kt l ku kv">	self.name = name</span><span id="4c5f" class="kr in hp kn b fi lb kt l ku kv">    def __str__(self):</span><span id="268d" class="kr in hp kn b fi lb kt l ku kv">	return f"This is a {self.name}"<br/></span><span id="d0d7" class="kr in hp kn b fi lb kt l ku kv">pen1 =  Pen("Ball Pen")</span><span id="05d3" class="kr in hp kn b fi lb kt l ku kv">pen2 =  Pen("Gel pen")</span><span id="5fca" class="kr in hp kn b fi lb kt l ku kv">print(pen1)</span><span id="76b1" class="kr in hp kn b fi lb kt l ku kv">box = Box(pen1, pen2)</span><span id="bca6" class="kr in hp kn b fi lb kt l ku kv">print(box)</span></pre><p id="d0c6" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated"><strong class="jm hq">输出</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="066d" class="kr in hp kn b fi ks kt l ku kv">This is a Ball Pen<br/>This box contains 2 pens.</span></pre><p id="9fdb" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">这里，super 方法和 quantity 参数已经被删除。更新了 Box 类中的 __str__ 方法，以查找 pens 元组(*self.pens)的长度，该元组可以包含任意数量的笔。我们可以使用任意数量的参数。创建了一个名为“box”的 Box 类对象。我们传入了 pens，打印它将返回 Box 类中的 __str__ 方法。看看它看起来有多简单、干净，我们可以在盒子里放几支笔。</p><p id="1029" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated"><strong class="jm hq">总结</strong></p><p id="ba5b" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">这个例子中的继承意味着笔是一个盒子，而组合意味着一个盒子可以包含许多笔。明智地选择。</p><p id="aa17" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">在 Linkedin 上看到这篇文章:<a class="ae lc" href="https://www.linkedin.com/pulse/class-composition-python-shivam-thaman/?published=t" rel="noopener ugc nofollow" target="_blank">https://www . Linkedin . com/pulse/class-composition-python-shivam-thaman/？发布=t </a></p><p id="df35" class="pw-post-body-paragraph jk jl hp jm b jn kw jp jq jr kx jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">在 LinkedIn 上联系我:<a class="ae lc" href="https://www.linkedin.com/in/shivam-thaman-1167a8147/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/shivam-thaman-1167a8147/</a></p></div></div>    
</body>
</html>