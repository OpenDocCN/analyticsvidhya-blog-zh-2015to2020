<html>
<head>
<title>Live - Earthquake Tracking System Using Dash and Plotly.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dash和Plotly的实时地震跟踪系统。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/live-earthquake-tracking-system-using-dash-and-plotly-858fa4fffe03?source=collection_archive---------11-----------------------#2019-10-08">https://medium.com/analytics-vidhya/live-earthquake-tracking-system-using-dash-and-plotly-858fa4fffe03?source=collection_archive---------11-----------------------#2019-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="974d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用USGS数据源的实时地震跟踪系统，并在Dash应用程序中显示发生的事件。</p><h2 id="27a4" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">USGS的微妙介绍</h2><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es jy"><img src="../Images/ef2a730de65140acc551e426413ea586.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*JfGOOBfNB7D_kND7HgVUDA.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">USGS(改变世界的科学)-徽标</figcaption></figure><p id="f24d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">美国地质调查局(USGS)是地质学家和科学家研究地球科学的科学机构。这包括景观、自然资源和自然灾害等。美国地质调查局的<strong class="ih hj">地震灾害计划</strong>实时收集地震数据，每分钟更新<a class="ae kk" href="https://earthquake.usgs.gov/earthquakes/feed/v1.0/csv.php" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="c9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用这些实时数据，我开发了一个用户友好的dash应用程序，它可以跟踪地震，并让您查看特定地区发生的特定震级的地震。</p><h2 id="bb1e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">程序</h2><p id="8e73" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">通过“熊猫read_csv()”函数读取CSV数据。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="9b25" class="jd je hi ky b fi lc ld l le lf">import pandas as pd</span><span id="e99e" class="jd je hi ky b fi lg ld l le lf">def GrabOccurrenceData(past_occurrence, mag_value):</span><span id="2c7c" class="jd je hi ky b fi lg ld l le lf"> url = '<a class="ae kk" href="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/'" rel="noopener ugc nofollow" target="_blank">https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/'</a> + str(past_occurrence) + '.csv'</span><span id="10c1" class="jd je hi ky b fi lg ld l le lf"> qdf = pd.read_csv(url)<br/> qdf = qdf[qdf['mag'] &gt; int(mag_value)]</span><span id="3620" class="jd je hi ky b fi lg ld l le lf"> return qdf</span></pre><p id="ccb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将返回一个由大于“<em class="lh">地震值”的地震组成的数据框。</em></p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="19b5" class="jd je hi ky b fi lc ld l le lf">&gt;&gt;&gt; qdf = GrabOccurrenceData("all_hour", 1)<br/>&gt;&gt;&gt; qdf.columns<br/>Index(['time', 'latitude', 'longitude', 'depth', 'mag', 'magType', 'nst', 'gap', 'dmin', 'rms', 'net', 'id', 'updated', <strong class="ky hj">'place'</strong>, 'type', 'horizontalError', 'depthError', 'magError', 'magNst', 'status', 'locationSource', 'magSource'], dtype='object')</span><span id="4ef2" class="jd je hi ky b fi lg ld l le lf">&gt;&gt;&gt; qdf['place'].to_list()<br/>['13km E of Little Lake, CA',<br/> '24km E of Waukomis, Oklahoma',<br/> '16km SW of La Quinta, CA',<br/> '9km NNW of Borrego Springs, CA',<br/> '24km WNW of Warm Springs, Nevada',<br/> 'South Shetland Islands']</span></pre><p id="12ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们注意到<em class="lh">“place”</em>列，我们会看到它有<em class="lh">“some _ value，region”。</em>我们对<em class="lh">“区域”</em>更感兴趣，因为当选择并只显示那些已经发生的地震时，我们可以根据区域来分离地震的总数。</p><p id="a77b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将使用以下函数。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="951c" class="jd je hi ky b fi lc ld l le lf">def GrabSpecificArea(past_occurrence, mag_value):<br/> qdf = GrabOccurrenceData(past_occurrence, mag_value)<br/> places = qdf['place'].to_list()</span><span id="5d26" class="jd je hi ky b fi lg ld l le lf"> specific_areas = []<br/> for place in places:<br/>  area = place.split(', ')<br/>  if len(area) == 2:<br/>   specific_areas.append(area[1])<br/>  if len(area) &lt; 2:<br/>   specific_areas.append(area[0])</span><span id="95ae" class="jd je hi ky b fi lg ld l le lf"> area_counts = []<br/> for area in specific_areas:<br/>  area_counts.append(area+' - '+str(specific_areas.count(area)))</span><span id="7ec7" class="jd je hi ky b fi lg ld l le lf"> specific_areas = list(set(area_counts))<br/> <br/> return specific_areas</span></pre><p id="a62e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上述函数可以获得以下结果。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="9972" class="jd je hi ky b fi lc ld l le lf">&gt;&gt;&gt; area_list = GrabSpecificArea("all_hour", 1)<br/>&gt;&gt;&gt; area_list<br/>['CA - 3', <br/> 'Oklahoma - 1', <br/> 'Nevada - 1', <br/> 'South Shetland Islands - 1']</span></pre><p id="7f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经知道了地震发生的具体区域，我们可以在MapBox地图上显示出来。</p><p id="a7ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了可视化地图上的区域，我们需要<em class="lh">“纬度”</em>和<em class="lh">“经度”。</em>为了实时可视化，我们必须定义一个时间间隔。因为数据每1分钟更新一次。我们可以设置3分钟的时间间隔，以便正确捕获更新的数据。</p><p id="d07c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将导入所需的包。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="8451" class="jd je hi ky b fi lc ld l le lf">import dash<br/>import dash_core_components as dcc<br/>import dash_html_components as html<br/>from dash.dependencies import (Input, Output)</span></pre><p id="9fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将创建一个dash对象，并为应用程序创建布局。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="d743" class="jd je hi ky b fi lc ld l le lf">external_scripts = ['<a class="ae kk" href="https://www.google-analytics.com/analytics.js'" rel="noopener ugc nofollow" target="_blank">https://www.google-analytics.com/analytics.js'</a>]<br/>external_stylesheets = ['<a class="ae kk" href="https://codepen.io/chriddyp/pen/bWLwgP.css'" rel="noopener ugc nofollow" target="_blank">https://codepen.io/chriddyp/pen/bWLwgP.css'</a>]</span><span id="969c" class="jd je hi ky b fi lg ld l le lf">app = dash.Dash(__name__,<br/> external_scripts=external_scripts,<br/> external_stylesheets=external_stylesheets)<br/>app.config['suppress_callback_exceptions'] = True</span><span id="c500" class="jd je hi ky b fi lg ld l le lf">app.layout = html.Div([<br/> html.Div([<br/>  dcc.RadioItems(<br/>   id='map-type',<br/>   options=[{'label':s, 'value':s} for s in ['Density Map','Scatter Map']],<br/>   value='Density Map',<br/>   labelStyle={'display': 'inline-block'}<br/>  )<br/> ],style={'margin-left':20,'margin-top':20,'margin-bottom':10}<br/> ),<br/> <strong class="ky hj">html.Div([dcc.Interval(id='output-update', interval=180*1000)])</strong>,<br/> <strong class="ky hj">html.Div(id='map-quakes')</strong>,<br/> html.Div([<br/>  html.Div([<br/>   <strong class="ky hj">html.Div(id='pie-quake-type')</strong><br/>  ], className='five columns'),<br/>  html.Div([<br/>   <strong class="ky hj">html.Div(id='area-count-plot')</strong><br/>  ], className='seven columns')<br/> ], className='row', style={'margin-left' : 20, 'margin-top' : 30}), <br/>html.Div([])<br/>], style={'margin-top' : 20, 'margin-bottom' : 20})</span></pre><p id="5784" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为数据可视化创建一些辅助函数。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="8c5b" class="jd je hi ky b fi lc ld l le lf">import plotly.graph_objs as go</span><span id="702c" class="jd je hi ky b fi lg ld l le lf">#&lt;DensityMap&gt;<br/>def PlotDensityMap(lat, lon, z, radius, colorscale):<br/> density_map_trace = go.Densitymapbox(<br/>   lat=lat,<br/>   lon=lon,<br/>   z=z,<br/>   radius=radius,<br/>   colorscale=colorscale,<br/> )<br/> return density_map_trace</span><span id="7d45" class="jd je hi ky b fi lg ld l le lf">def LayoutDensity(height, width, mapbox_style, c_lat, c_lon, zoom):<br/> layout_density_map = go.Layout(<br/>  height=height,<br/>   width=width,<br/>   autosize=True,<br/>   showlegend=False,<br/>   hovermode='closest',<br/>   margin=dict(l=0, r=0, t=0, b=0),<br/>   mapbox_style=mapbox_style,<br/>   mapbox_center_lat=c_lat,<br/>   mapbox_center_lon=c_lon,<br/>   mapbox=dict(<br/>    zoom=zoom<br/>   )<br/> )<br/> return layout_density_map<br/>#&lt;/DensityMap&gt;</span><span id="bc5b" class="jd je hi ky b fi lg ld l le lf">#&lt;ScatterMap&gt;<br/>def PlotScatterMap(lat, lon, size, color, colorscale, text):<br/> scatter_map_trace = go.Scattermapbox(<br/>  lat=lat,<br/>  lon=lon,<br/>  mode='markers',<br/>  marker=dict(<br/>   size=size, color=color, opacity=1,<br/>   colorscale=colorscale,<br/>  ),<br/>  text=text, hoverinfo='text', showlegend=True<br/> )<br/> return scatter_map_trace</span><span id="9cb5" class="jd je hi ky b fi lg ld l le lf">def LayoutScatter(height, width, mapbox_style, c_lat, c_lon, zoom):<br/> layout_scatter_map = go.Layout(<br/>   height=height,<br/>   width=width,<br/>   autosize=True,<br/>   showlegend=False,<br/>   hovermode='closest',<br/>   margin=dict(l=0, r=0, t=0, b=0),<br/>   mapbox_style=mapbox_style,<br/>   mapbox=dict(<br/>     center=dict(<br/>       lat=c_lat,<br/>       lon=c_lon<br/>     ),<br/>     zoom=zoom<br/>   )<br/> )<br/> return layout_scatter_map<br/>#&lt;/ScatterMap&gt;</span></pre><p id="009d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个回调装饰器，通过包装来扩展函数的行为。这用于在输入值发生变化时自动触发变化。</p><p id="f70c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>我在开发这个应用时使用了几个回调函数。在某些情况下，我只使用其中的一部分。然而，要熟悉这里是回调图。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/3271db5a2bb206a95835e3b9529f78ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6ukFSfEcQyoEd2-TFjSeg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">回调图表</figcaption></figure><p id="dddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MapBox显示地震位置的输出地图。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="159f" class="jd je hi ky b fi lc ld l le lf">import plotly.graph_objs as go</span><span id="6360" class="jd je hi ky b fi lg ld l le lf">#&lt;density_scatter_mapbox&gt;<br/><a class="ae kk" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(<br/> Output('map-quakes', 'children'),<br/> [Input('past-occurrence', 'value'), Input('magnitude-range', 'value'), Input('map-type', 'value'), Input('area-list', 'value'), <br/>  Input('output-update', 'n_intervals')],<br/>)<br/>def visualize_quakes(past_occurrence, mag_value, map_type, specific_area, n_intervals):<br/> try:<br/>  eqdf = GrabOccurrenceData(past_occurrence, mag_value)<br/>  eqdf = eqdf[eqdf['place'].str.contains(str(specific_area.split(' - ')[0]))]<br/>  zoom = 3<br/>  radius = 15<br/>  latitudes = eqdf['latitude'].to_list()<br/>  longitudes = eqdf['longitude'].to_list()<br/>  magnitudes = eqdf['mag'].to_list()<br/>  mags = [float(i)*radius_multiplier['outer'] for i in magnitudes]<br/>  mags_info = ['Magnitude : ' + str(m) for m in magnitudes]<br/>  depths = eqdf['depth'].to_list()<br/>  deps_info = ['Depth : ' + str(d) for d in depths]<br/>  places = eqdf['place'].to_list()</span><span id="f768" class="jd je hi ky b fi lg ld l le lf">  center_lat = eqdf[eqdf['mag'] == eqdf['mag'].max()['latitude'].to_list()[0]<br/>  center_lon = eqdf[eqdf['mag'] == eqdf['mag'].max()]['longitude'].to_list()[0]</span><span id="3fe2" class="jd je hi ky b fi lg ld l le lf">  if (map_type == 'Density Map'):<br/>   map_trace = PlotDensityMap(latitudes, longitudes, magnitudes, radius, 'Electric')<br/>   layout_map = LayoutDensity(600, 980, 'stamen-terrain', center_lat, center_lon, zoom)<br/>   visualization = html.Div([<br/>    dcc.Graph(<br/>     id='density-map',<br/>     figure={'data' : [map_trace], 'layout' : layout_map}<br/>    ),<br/>   ])<br/>   return visualization</span><span id="44ea" class="jd je hi ky b fi lg ld l le lf">  if (map_type == 'Scatter Map'):<br/>   quake_info = [places[i] + '&lt;br&gt;' + mags_info[i] + '&lt;br&gt;' + deps_info[i] for i in range(eqdf.shape[0])]<br/>   map_trace = PlotScatterMap(latitudes, longitudes, mags, magnitudes, default_colorscale, quake_info)<br/>   layout_map = LayoutScatter(600, 980, 'stamen-terrain', center_lat, center_lon, zoom)<br/>   visualization = html.Div([<br/>    dcc.Graph(<br/>     id='scatter-map',<br/>     figure={'data' : [map_trace], 'layout' : layout_map}<br/>    ),<br/>   ])<br/>   return visualization<br/> except Exception as e:<br/>  return html.Div([<br/>   html.H6('Please select valid magnitude / region ...')<br/>  ], style={'margin-top' : 150, 'margin-bottom' : 150, 'margin-left' : 200})<br/>#&lt;/density_scatter_mapbox&gt;</span></pre><p id="f878" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的回调将地图上的地震可视化。密度地图框是地震的一个很好的表现，但是我也包括了散点图框。</p><p id="81d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进一步可视化，我们可以使用饼图显示<em class="lh">【类型】</em>栏，使用条形图显示每个区域的地震总数。</p><p id="f0bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于显示“灾难类型”的饼图。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="1c34" class="jd je hi ky b fi lc ld l le lf">#&lt;earthquake_type_pie&gt;<br/><a class="ae kk" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(<br/> Output('pie-quake-type', 'children'), <br/> [Input('past-occurrence', 'value'), Input('magnitude-range', 'value'), Input('output-update', 'n_intervals')]<br/>)<br/>def category_pie_chart(past_occurrence, mag_value, n_intervals):<br/> eqdf = GrabOccurrenceData(past_occurrence, mag_value)<br/> qtype = eqdf['type'].value_counts().to_frame()<br/> qtype.reset_index(inplace=True)<br/> qtype.columns = ['type', 'count']<br/> labels = qtype['type'].to_list()<br/> values = qtype['count'].to_list()</span><span id="d593" class="jd je hi ky b fi lg ld l le lf"> pie_type = go.Pie(labels=labels, values=values, hole=0.3, pull=0.03, textposition='outside', rotation=100)<br/> pie_layout = go.Layout(title='Disaster type')</span><span id="8880" class="jd je hi ky b fi lg ld l le lf"> pie_chart_type = html.Div([<br/>  dcc.Graph(id='disaster-type', figure={'data' : [pie_type], 'layout' : pie_layout})<br/> ])<br/> return pie_chart_type<br/>#&lt;/earthquake_type_pie&gt;</span></pre><p id="6824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显示“面积计数”的条形图。</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="8bc7" class="jd je hi ky b fi lc ld l le lf">#&lt;count_area_bar&gt;<br/><a class="ae kk" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(<br/> Output('area-count-plot', 'children'),<br/> [Input('past-occurrence', 'value'), Input('magnitude-range', 'value'), Input('output-update', 'n_intervals')]<br/>)<br/>def count_area_plot(past_occurrence, mag_value, n_intervals):<br/> counts_area = GrabSpecificArea(past_occurrence, mag_value)</span><span id="051f" class="jd je hi ky b fi lg ld l le lf"> areas_alone = []; count_vals = []<br/> for area in counts_area:<br/>  area = area.split(' - ')<br/>  areas_alone.append(area[0])<br/>  count_vals.append(int(area[1]))</span><span id="31e4" class="jd je hi ky b fi lg ld l le lf"> area_counter = go.Bar(x=areas_alone, y=count_vals)<br/> repeat_layout = go.Layout(title='Worldwide - ' + str(past_occurrence))</span><span id="2fe2" class="jd je hi ky b fi lg ld l le lf"> repetitive_areas = html.Div([<br/>  dcc.Graph(id='area-repeat-list', figure={'data':[area_counter], 'layout' : repeat_layout})<br/> ])<br/> difficult_message = html.Div([<br/>  html.P('Quite difficult to load the graph ...')<br/> ], style={'margin-top' : 150, 'margin-bottom' : 50, 'textAlign' : 'center'})</span><span id="c0c5" class="jd je hi ky b fi lg ld l le lf"> if past_occurrence == 'all_week' and mag_value &lt; 3:<br/>  return difficult_message<br/> if past_occurrence == 'all_week' and mag_value &gt;= 3:<br/>  return repetitive_areas<br/> return repetitive_areas<br/>#&lt;/count_area_plot&gt;</span></pre><p id="606f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后运行我们使用的应用程序</p><pre class="jz ka kb kc fd kx ky kz la aw lb bi"><span id="78f5" class="jd je hi ky b fi lc ld l le lf">if __name__ == '__main__':<br/> app.run_server(debug=True, dev_tools_props_check=False, dev_tools_ui=False)</span></pre><h2 id="e479" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">结果</h2><p id="a271" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">密度图是表现地震的好方法。下面的结果显示了发生在<strong class="ih hj">【昨天】</strong>的世界各地的地震。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/5d02c9a262ba07d08bad31047b1d1d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioSGwzySP_lkCwU5Vqp98Q.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">密度图结果</figcaption></figure><p id="7ec3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，特定区域(“印度尼西亚”)的散点图结果如下所示。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lo"><img src="../Images/5ed1211b064f917676652d88ecf0592b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9FY0q9XAGc7WKgUJ71NpQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">印度尼西亚地震—过去24小时</figcaption></figure><p id="49e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了显示灾难类型，我们使用了饼图。为此我考虑了<strong class="ih hj">“上周”</strong>的数据。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lp"><img src="../Images/ec34853ef81228ca16e7c27e6bc4ff3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbGMlq2kzKn1BwCSeITA_Q.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">显示事件类型的饼图</figcaption></figure><p id="7738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了显示面积计数图，我考虑了<strong class="ih hj">“昨天”</strong>的数据。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lp"><img src="../Images/6d4ddeb13e0b7ef0671b3e15b1ce0adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5eVvEYelPYXi_lkL0LuiA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">面积计数图</figcaption></figure><p id="5eaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面可以看到实时地震报告生成的更有效和更新的结果。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="lq lr l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">地震实时追踪— dash应用程序</figcaption></figure><p id="3843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，这个应用程序是一个实时跟踪应用程序，每3分钟自动更新一次。我们不需要刷新页面就能注意到变化。这是Dash专长，有助于开发动态web应用程序。</p><h2 id="0596" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">结论</h2><ol class=""><li id="9380" class="ls lt hi ih b ii ks im kt iq lu iu lv iy lw jc lx ly lz ma bi translated">在开发这个应用程序的过程中，我学到了很多东西(数据可视化、数据操作和设计等)。</li><li id="b3a8" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">我也将尝试通过开发机器学习模型来增强这个项目，并预测下一次发生的情况(序列挖掘和时间序列分析)。</li><li id="5345" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">总的来说，开发这个很有趣。谢谢大家。</li></ol></div></div>    
</body>
</html>