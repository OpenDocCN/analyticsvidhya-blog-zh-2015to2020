<html>
<head>
<title>Viterbi algorithm for prediction with HMM — Part 3 of the HMM series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HMM预测的Viterbi算法——HMM系列之三</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/viterbi-algorithm-for-prediction-with-hmm-part-3-of-the-hmm-series-6466ce2f5dc6?source=collection_archive---------1-----------------------#2019-07-21">https://medium.com/analytics-vidhya/viterbi-algorithm-for-prediction-with-hmm-part-3-of-the-hmm-series-6466ce2f5dc6?source=collection_archive---------1-----------------------#2019-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5d83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如何从所有可能的途径中获得最佳隐藏状态链？</em></p><p id="c6e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">免责声明:这是我在过去的几天里了解到的关于HMM的内容，我认为这更容易理解，这绝对不是一本教科书能提供给你的系统化的方式。教科书永远是我们的朋友，它提供了一个完整的、结构化的学习方法，材料也不失一般性，但我希望我的文章能帮助你克服旅途中的一些瓶颈。祝你好运！</em></p><p id="ce58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一部分:<a class="ae je" rel="noopener" href="/@rmwkwok/hidden-markov-model-part-1-of-the-hmm-series-3f7fea28a08">隐马尔可夫模型的体系结构</a> <br/>第二部分:<a class="ae je" rel="noopener" href="/@rmwkwok/baum-welch-algorithm-for-training-a-hidden-markov-model-part-2-of-the-hmm-series-d0e393b4fb86">训练HMM的算法:Baum-Welch算法</a> <br/>第三部分:<a class="ae je" rel="noopener" href="/@rmwkwok/viterbi-algorithm-for-prediction-with-hmm-part-3-of-the-hmm-series-6466ce2f5dc6">用训练好的HMM进行预测的算法:Viterbi算法</a></p><p id="14e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae je" rel="noopener" href="/@rmwkwok/hidden-markov-model-part-1-of-the-hmm-series-3f7fea28a08">第一篇文章</a>中，我谈到了隐马尔可夫模型(HMM)的架构和参数化，以及我将在这里使用的变量的含义。<a class="ae je" rel="noopener" href="/@rmwkwok/baum-welch-algorithm-for-training-a-hidden-markov-model-part-2-of-the-hmm-series-d0e393b4fb86">在第二篇文章</a>中，是关于HMM的训练算法。在这一次，重点将放在预测算法，这是所谓的维特比算法。</p><p id="e37d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像我们的训练算法Baum-Welch算法一样，Viterbi算法也是一种动态规划方法。提醒一下，动态编程是一种可以在下一次计算中重用计算结果的方法，而且重用可以节省时间！更重要的是，它确实是HMM的自然选择，以简单的HMM为例，其中任何状态都依赖于它的第一个先前状态。然而这个说法并不是说从其余的前一个状态到当前状态完全没有影响，而是它们的影响都被吸收到第一个前一个状态中，这个第一个前一个状态就成为你过渡到下一个状态时唯一需要考虑的因素。</p><p id="2497" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，你也可以说，在一个简单的HMM中，任何状态通过第一个先前状态依赖于所有先前状态，我说动态编程在这里是一个自然的选择，因为它也是一种捕获过去的一切并在未来重用的手段。</p><h1 id="50b6" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">维特比算法</h1><p id="4aaf" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">维特比算法的目的是基于训练的模型和一些观察到的数据进行推断。它通过提出一个问题来工作:给定训练的参数矩阵和数据，选择什么状态使得联合概率达到最大？换句话说，给定数据和训练好的模型，最有可能的选择是什么？这个说法可以形象化为下面的公式，显然，答案取决于数据！</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/5744a9f2d7901fb7fe4657e55138635c.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*dSf0hcUP901Ib9tdOlBdkQ.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">这意味着找到给定数据的条件概率最大的状态。</figcaption></figure><p id="a1d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到最佳状态集，使用下面的递归公式。我推荐<a class="ae je" href="https://www.youtube.com/watch?v=RwwfUICZLsA" rel="noopener ugc nofollow" target="_blank">这个YouTube视频</a>和<a class="ae je" href="https://www.youtube.com/watch?v=t3JIk3Jgifs" rel="noopener ugc nofollow" target="_blank">这个YouTube视频</a>的偏差。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ku"><img src="../Images/00c4d152b060a3f0bbe83e925504d2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*ykKAmf2zICp8vR-l9gsvuQ.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">mu函数。这取决于它的前一步，转换和发射矩阵。</figcaption></figure><p id="0de3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们代入<em class="jd"> k </em> =1，2，3，这样我们可以很容易地理解这个递归。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es kv"><img src="../Images/4015f8a13f13515fd6b28b03627d1f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*Mx91_hjmyv5AU15chTesjw.png"/></div></figure><p id="bd6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个公式是起始<em class="jd"> mu </em>函数，并导致在给定初始观察数据的情况下看到不同初始状态的概率分布。在这里，我们不把自己约束到这些初始状态中的任何一个，而是在下一个公式中确定。</p><p id="7686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个公式选取最佳初始状态，使右边各项的乘积最大化，并将第一个状态作为自由参数留在第三个公式中确定。类似地，第三个公式选择最佳的第一个状态，然后将第二个状态留给第四个公式。</p><p id="da4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把这些重复的过程用一个叫做格子图的图来形象化。在图中，我们可以看到每个状态是如何根据概率最大化规则选择的，为了保持图小，我假设在每个时间步只有三个可能的状态可供我们选择。当然，同样的想法适用于任何数量的州。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es kw"><img src="../Images/0d729e3c4caadc868a4193ed8f4b1081.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*0l1mCKnezv08kOh7kCnBEA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">步骤0。列出了时间为0时的初始状态的所有三种可能状态。为了便于下面的讨论，相应的概率被假设为一些实际的数字。</figcaption></figure><p id="1d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤0只是列出时间0时所有可能的状态，以及它们相应的概率值，我们并不决定在这个阶段选择哪个状态。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/be368d2e06603cca7b1202164cdabb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWFWAiLAyNr8IDF13ERMYw.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">步骤1–1。对于每个可能的第一状态，选择最佳的可能初始状态。我们发现初始状态= 2最有可能导致第一状态= 1。</figcaption></figure><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lc"><img src="../Images/0f58380e43533c51bd789b4216e48c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3ke8gSzHAVPzKPD-AF-CQ.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">步骤1–2。这里我们发现初始状态= 3最有可能导致第一状态= 2。</figcaption></figure><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ld"><img src="../Images/e835c8eea4499fae54830ff4bff12467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*PuvC-GTcD_aodi8d9Atl6Q.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">步骤1–3。我们通过找到最有可能导致第一个状态的初始状态，并记住它们的概率值来结束步骤1，这些概率值将在下一步中重复使用。</figcaption></figure><p id="2cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在步骤1中，我们遍历所有可能的第一状态(时间= 1时的状态)，并找出它们对应的最佳初始状态(时间= 0时的状态)，如上图所示。然后，我们重复相同的过程，完成步骤2。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/e85d85fae725bd9c201508bd884a6886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCLuLPaXE_9nD8uurewBGw.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">第二步。重复从步骤0到步骤1的过程，以从步骤1得到步骤2。</figcaption></figure><p id="2534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们开始看到一些路径。例如，如果我们在步骤2结束推理，那么最可能的结束状态将是state = 1，其余的先前状态可以通过箭头回溯，它们是时间0时的状态2、时间1时的状态1和时间2时的状态1。第二个可能的路径是3–2–3，最不可能的路径是2–1–2。该路径不太可能从状态1开始。</p><h1 id="0c2a" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">摘要</h1><p id="7542" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">给定模型参数被优化，并且给定观察数据，维特比算法是对隐藏状态进行推断或预测的有效方式。最好通过网格来直观地了解如何选择从一个时间步长到下一个时间步长的路径。这就结束了对隐马尔可夫模型系列的介绍。</p></div></div>    
</body>
</html>