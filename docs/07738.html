<html>
<head>
<title>Multi-Touch Attribution Marketing Model - The Shapley value approach -part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多接触归因营销模型Shapley价值方法——第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-shapley-value-approach-to-multi-touch-attribution-marketing-model-e345b35f3359?source=collection_archive---------1-----------------------#2020-07-06">https://medium.com/analytics-vidhya/the-shapley-value-approach-to-multi-touch-attribution-marketing-model-e345b35f3359?source=collection_archive---------1-----------------------#2020-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/79904f3d5a98409bd3c552d404e914c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftV8NIEJu_AcHERYLsJZFg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">哪一款适合您的业务？</figcaption></figure><h1 id="1496" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="9e17" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在网络广告领域，媒体效果评估是决策过程中的重要一环。由于一个广告的成本是基于点击或印象的数量，所以了解每个行动的媒体效果是非常重要的。由于每个渠道的性质不同，需要了解每个渠道的营销效果。因此，为了理解在线营销活动的影响，必须考虑多渠道归因模型。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/2e91929732ef5e0248486a8b7569c355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGtfQ602yzD_K8vmNgniXw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">顾客之旅</figcaption></figure><h1 id="044f" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">基于规则的模型</h1><p id="df6a" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">常见的归因分析模型包括:</p><ul class=""><li id="60ff" class="kv kw hi ju b jv kx jz ky kd kz kh la kl lb kp lc ld le lf bi translated">最后一次点击:用户购买所有贡献值之前的最后一个接触点</li><li id="4f9d" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated">第一次点击:用户访问路径上的第一个接触点获得所有贡献值</li><li id="7ed2" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated">线性模型:用户访问路径上的所有接触点均分贡献值</li><li id="3ccf" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated">时间衰减模型:用户访问路径上越早的接触点获得的贡献值越大</li></ul><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/4d8ee8f877bc96620ca80b3af9283d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5GYePKd1s49jj_L7c-OZQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">基于规则的模型</figcaption></figure><h1 id="28d8" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">基于规则与算法</h1><p id="920a" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">多接触归因是数字营销中非常流行的营销科学技术。传统的基于规则的模型，如最后一次触摸(点击)模型或基于位置的模型，具有根深蒂固的偏见，使它们无效。</p><p id="1afa" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">营销渠道越多，客户行为路径越复杂，就越需要有洞察力的归因模型来帮助确定渠道价值、优化渠道组合和资源分配。一个细微的渠道差异，或许能帮助企业在市场竞争中胜出。</p><p id="7589" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">那么，多触点归因营销模式是怎么回事呢？幸运的是，数据驱动的归因模型可以检测通道变化并调整通道权重值，因此在大多数情况下会更准确。</p><p id="91d3" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated"><strong class="ju hj">基于不同的数学理论提出了几种数据驱动模型:</strong> <a class="ae lp" href="https://en.wikipedia.org/wiki/Markov_model#:~:text=In%20probability%20theory%2C%20a%20Markov,it%20assumes%20the%20Markov%20property)." rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">马尔可夫模型</strong> </a> <strong class="ju hj">，</strong> <a class="ae lp" href="https://en.wikipedia.org/wiki/Game_theory" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">博弈论</strong> </a> <strong class="ju hj">模型，生存分析模型等。</strong>在本帖中，我们将只讨论博弈论模型和Shapley值。Shapley值也被用作谷歌分析数据驱动的归因模型的一种方法。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="f3d6" class="iu iv hi bd iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn mb jp jq jr bi translated">合作博弈与沙普利值</h1><blockquote class="mc md me"><p id="f84d" class="js jt mf ju b jv kx jx jy jz ky kb kc mg lm kf kg mh ln kj kk mi lo kn ko kp hb bi translated">沙普利值是由诺贝尔经济学奖获得者罗伊德·S·沙普利提出的，作为一种在团队成员中公平分配团队产出的方法。</p><p id="3d42" class="js jt mf ju b jv kx jx jy jz ky kb kc mg lm kf kg mh ln kj kk mi lo kn ko kp hb bi translated">在<strong class="ju hj">博弈论</strong>中，<strong class="ju hj">沙普利值</strong>是一个解决方案的概念，将收益和成本公平地分配给联盟中的几个参与者。<strong class="ju hj">沙普利值</strong>主要适用于每个参与者的贡献不相等，但他们相互合作以获得回报的情况。</p></blockquote><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/6375b9293ce543e0b7286fbeabe0b93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*uOfbMROq_GLHeFHvR1tRkg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">安妮·尼加德摄影</figcaption></figure><p id="b898" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">营销渠道是合作游戏中的参与者，他们中的每一个都可以被认为是为了推动转化而一起工作。换句话说，这种方法公平地分配了每个接触点对转化的贡献。</p><p id="536d" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">在我们开始之前，我想介绍几个我们将在后面的计算中使用的关键概念。请注意，我将特征函数简单地定义为联盟生成的转换的总和。</p><ul class=""><li id="925b" class="kv kw hi ju b jv kx jz ky kd kz kh la kl lb kp lc ld le lf bi translated">N =渠道{室内广告、脸书、电子邮件、谷歌等。}是一组玩家</li><li id="ff11" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated"><strong class="ju hj"> S =联盟，玩家的子集，渠道在形成联盟的地方一起工作。</strong></li><li id="e0a6" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated"><strong class="ju hj"> |𝑆|是联合𝑆的基数，并且该和延伸到不包含信道I的n的所有子集𝑆上。</strong></li><li id="0bb9" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated"><strong class="ju hj">N = N的数量</strong></li><li id="0b46" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated"><strong class="ju hj"> v(S) =一个实值函数v，称为特征函数。S的贡献表示N(通道)的联合。就是计算后每个通道的权重。</strong></li><li id="fc9f" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated"><strong class="ju hj"> Weight = |S|！(n-|S|-1)！/n！</strong></li><li id="4ae2" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp lc ld le lf bi translated"><strong class="ju hj">边际贡献= v(S U {i})-v(S) </strong>增量加权和减去没有v(S)的联盟</li></ul><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/6fa9a9fdadc4e02bd47874f8e2dcfb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQQsb_4u4AoG7vtG9AX1TQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Shapley值可以使用以下公式计算</figcaption></figure><blockquote class="ml"><p id="90b7" class="mm mn hi bd mo mp mq mr ms mt mu kp dx translated">作为这篇文章的目的，我不会让你困惑于解释整体方法论来证明这一点。见<a class="ae lp" href="https://www.math.ucla.edu/~tom/Game_Theory/coal.pdf" rel="noopener ugc nofollow" target="_blank">此处</a>求证。但你需要知道Shapley值方法的基本思想是，它对每个渠道的所有可能联盟的边际贡献进行加权平均。</p></blockquote></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="29b9" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">我们将使用来自<a class="ae lp" href="https://www.kaggle.com/kavitabhagwani/marketing-campaign" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的样本营销数据集。</p><p id="fc46" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">下载完数据后，我们需要做一些操作。这里我们只需要四个变量:<strong class="ju hj"> user_id，date，channel，conversion </strong>。请将转换标记为1，否则标记为0。并删除空数据。</p><p id="9c2c" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">下面是Python代码，供大家参考。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/a2a2f20374a6be41c19e68d3649bd671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*_S98s-17bP4tqKgbqzIM2A.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">应该会得到类似这样的结果。</figcaption></figure><p id="6ae5" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">下一步，我们想得到渠道子集，S，联盟和他们的转换的总和。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es my"><img src="../Images/888bb49e0d30db4f716ac82234f99471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*92C4jRaMtVxQxwTo-aLrgg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出可能看起来像这样</figcaption></figure><p id="7b35" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">供参考的MySQL代码</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="2cd0" class="ne iv hi na b fi nf ng l nh ni">SELECT channels_subset, sum(b.conversion) as conversion_sum<br/>FROM(<br/>SELECT user_id, GROUP_CONCAT(DISTINCT(channel)) as channels_subset, max(conversion) as conversion<br/>FROM(<br/>SELECT user_id,channel,conversion<br/>FROM demo.simulated_data<br/>ORDER BY user_id,channel<br/>) a<br/>GROUP BY user_id)<br/>b<br/>GROUP BY channels_subset;</span></pre><p id="7b93" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">然后我们会用Python计算权重和边际贡献。</p><p id="01e4" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">首先，我们需要导入Python中的模块</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="c80c" class="ne iv hi na b fi nf ng l nh ni">import pandas as pd<br/>import itertools<br/>from collections import defaultdict<br/>from itertools import permutations,combinations<br/>import numpy as np</span></pre><p id="33dc" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">创建一个函数，返回所有可能的通道组合</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="cba0" class="ne iv hi na b fi nf ng l nh ni">def power_set(List):<br/>    PS = [list(j) for i in range(len(List)) for j in itertools.combinations(List, i+1)]<br/>    return PS</span></pre><p id="baed" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">返回一组频道的所有可能子集</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="4ea7" class="ne iv hi na b fi nf ng l nh ni">def subsets(s):<br/>    '''<br/>    This function returns all the possible subsets of a set of channels.<br/>    input :<br/>            - s: a set of channels.<br/>    '''<br/>    if len(s)==1:<br/>        return s<br/>    else:<br/>        sub_channels=[]<br/>        for i in range(1,len(s)+1):<br/>            sub_channels.extend(map(list,itertools.combinations(s, i)))<br/>    return list(map(",".join,map(sorted,sub_channels)))</span></pre><p id="6d6e" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">计算每个联盟的价值。</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="d009" class="ne iv hi na b fi nf ng l nh ni">def v_function(A,C_values):<br/>    '''<br/>    This function computes the worth of each coalition.<br/>    inputs:<br/>            - A : a coalition of channels.<br/>            - C_values : A dictionnary containing the number of conversions that each subset of channels has yielded.<br/>    '''<br/>    subsets_of_A = subsets(A)<br/>    #print(subsets_of_A)<br/>    #exit()<br/>    worth_of_A=0<br/>    for subset in subsets_of_A:<br/>        #print("subset:", subset)<br/>        if subset in C_values:<br/>            #print("subset:", subset, "; Value:", C_values[subset])<br/>            worth_of_A += C_values[subset]<br/>    return worth_of_A</span></pre><p id="2435" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">计算一个数(非负整数)的阶乘</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="baa5" class="ne iv hi na b fi nf ng l nh ni">def factorial(n):<br/>    if n == 0:<br/>        return 1<br/>    else:<br/>        return n * factorial(n-1)</span></pre><p id="04ad" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">这里是最终代码</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="7c8d" class="ne iv hi na b fi nf ng l nh ni">def calculate_shapley(df, col_name):<br/>    '''<br/>    This function returns the shapley values<br/>            - df: A dataframe with the two columns: ['channels_subset', 'conversion_sum'].<br/>            The channel_subset column is the channel(s) associated with the conversion and the count is the sum of the conversions. <br/>            - col_name: A string that is the name of the column with conversions<br/>            **Make sure that that each value in channel_subset is in alphabetical order. Email,PPC and PPC,Email are the same <br/>            in regards to this analysis and should be combined under Email,PPC.<br/>            ***Be careful with the distinct number of channels because this can signifcantly slow the perfomance of this function.<br/>            Remember the total possible combinations of channels is 2^(n) where n is the number of channels. If you have 30 channels<br/>            this is 1,073,741,824 combinations. <br/>            <br/>    '''<br/>    c_values = df.set_index("channels_subset").to_dict()[col_name]<br/>    df['channels'] = df['channels_subset'].apply(lambda x: x if len(x.split(",")) == 1 else np.nan)<br/>    channels = list(df['channels'].dropna().unique())<br/>    <br/>    v_values = {}<br/>    for A in power_set(channels):<br/>        v_values[','.join(sorted(A))] = v_function(A,c_values)<br/>    #print(v_values)<br/>    n=len(channels)<br/>    shapley_values = defaultdict(int)</span><span id="5f76" class="ne iv hi na b fi nj ng l nh ni">for channel in channels:<br/>        for A in v_values.keys():<br/>            #print(A)<br/>            if channel not in A.split(","):<br/>                #print(channel)<br/>                cardinal_A=len(A.split(","))<br/>                A_with_channel = A.split(",")<br/>                A_with_channel.append(channel)            <br/>                A_with_channel=",".join(sorted(A_with_channel))<br/>                # Weight = |S|!(n-|S|-1)!/n!<br/>                weight = (factorial(cardinal_A)*factorial(n-cardinal_A-1)/factorial(n))<br/>                # Marginal contribution = v(S U {i})-v(S)<br/>                contrib = (v_values[A_with_channel]-v_values[A]) <br/>                shapley_values[channel] += weight * contrib<br/>        # Add the term corresponding to the empty set<br/>        shapley_values[channel]+= v_values[channel]/n <br/>        <br/>    return shapley_values</span></pre><p id="5ec0" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">我们在这篇文章中使用的样本数据，我们得到了下面的结果</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="1eb7" class="ne iv hi na b fi nf ng l nh ni">defaultdict(int,<br/>            {'Facebook': 198.50000000000003,<br/>             'Instagram': 168.0,<br/>             'House Ads': 427.83333333333337,<br/>             'Push': 74.16666666666669,<br/>             'Email': 146.5})</span></pre><p id="5aab" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">我们终于可以想象它了。</p><pre class="kr ks kt ku fd mz na nb nc aw nd bi"><span id="b9eb" class="ne iv hi na b fi nf ng l nh ni">#visualizations<br/>import matplotlib.pyplot as plt<br/>from pandas.plotting import scatter_matrix<br/>%matplotlib inline<br/>import seaborn as sns</span><span id="6957" class="ne iv hi na b fi nj ng l nh ni">result = DataFrame(list(dict(calculate_shapley(data, "conversion_sum")).items()),columns = ['Channel','Contributions'])</span><span id="f9a3" class="ne iv hi na b fi nj ng l nh ni"># Visualization<br/>plt.subplots(figsize=(18, 6))<br/>sns.barplot(x='Channel', y='Contributions', data=result)<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/462b0c7df20ee4b633bb2efb7af96710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYvvaJrc-6PTs_QPs-Xc2A.png"/></div></div></figure><p id="2bb8" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">自己试试吧！</p><h1 id="d4ad" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="0a47" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在本帖中，我们将介绍如何使用原始数据来创建数据驱动的归因模型。真实世界的数据甚至更复杂，但至少你知道它是如何工作的。</p><p id="56b4" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">我还打算用R和Python写另一篇关于多触点归因模型的马尔可夫链方法的文章。敬请期待！</p><p id="9425" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated">好吧，让我知道你的想法。如果你喜欢这篇文章，请点击下面的<strong class="ju hj">按钮</strong>，别忘了<strong class="ju hj">把它分享到社交媒体</strong>。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="9b74" class="pw-post-body-paragraph js jt hi ju b jv kx jx jy jz ky kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp hb bi translated"><strong class="ju hj"> <em class="mf">参考:</em> </strong></p><ol class=""><li id="5276" class="kv kw hi ju b jv kx jz ky kd kz kh la kl lb kp nl ld le lf bi translated"><a class="ae lp" href="https://www.youtube.com/watch?v=w9O0fkfMkx0" rel="noopener ugc nofollow" target="_blank">合作博弈与沙普利值</a> <a class="ae lp" href="https://www.youtube.com/channel/UCJoZNbN4ziZBIfzC1zjuHYA" rel="noopener ugc nofollow" target="_blank">文森特·奈特</a></li><li id="cf23" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp nl ld le lf bi translated"><a class="ae lp" href="https://towardsdatascience.com/data-driven-marketing-attribution-1a28d2e613a0" rel="noopener" target="_blank">数据驱动的营销归因</a> <a class="ae lp" href="https://towardsdatascience.com/@jameskinley?source=post_page-----1a28d2e613a0----------------------" rel="noopener" target="_blank">詹姆斯·金利</a></li><li id="a342" class="kv kw hi ju b jv lg jz lh kd li kh lj kl lk kp nl ld le lf bi translated"><a class="ae lp" href="https://arxiv.org/pdf/1804.05327.pdf" rel="noopener ugc nofollow" target="_blank">基于收入的归因建模</a> — arXiv</li></ol></div></div>    
</body>
</html>