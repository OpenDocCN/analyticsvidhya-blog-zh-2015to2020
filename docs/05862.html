<html>
<head>
<title>Retaining and passing information states of variables in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中保留和传递变量的信息状态</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/retaining-and-passing-information-states-of-variables-in-python-7b39802d1362?source=collection_archive---------9-----------------------#2020-05-04">https://medium.com/analytics-vidhya/retaining-and-passing-information-states-of-variables-in-python-7b39802d1362?source=collection_archive---------9-----------------------#2020-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fb589ec4bd57b600f1f23bfebccefc91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Db-ojYJICoQujth-_DJ-4A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/photos/YeUVDKZWSZ4" rel="noopener ugc nofollow" target="_blank">Rene b hmer拍摄</a></figcaption></figure><p id="582f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">状态信息在许多现实世界的程序中起着至关重要的作用。状态决定了实体(函数、类、对象..等等)。实体-属性关系是其使用的关键因素。</p><p id="8ae6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在尝试解决一个真实世界的程序时，我遇到了这样一个问题，在这个程序中，我希望实体保存系统的状态，以便以后使用。在这个过程中，我发现有多种方法可以做到这一点，我试图简化这些方法，以便对其他人有所帮助。</p><p id="e899" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看一个简单的问题，通过这个问题我们可以理解程序中状态的保持。问题陈述是实现一个程序，根据函数的初始状态来计算调用函数的次数。</p><p id="6920" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">….<strong class="ix hj">第一次尝试</strong>🤔</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1d75" class="kc kd hi jy b fi ke kf l kg kh">count = 0</span><span id="99c2" class="kc kd hi jy b fi ki kf l kg kh">def stateful(init_state):<br/>    global count<br/>    count = init_state      # intialize the state to global variable<br/>    def inner():<br/>        global count        # Acess global variable and increment<br/>        count += 1<br/>        return "This is a sample program", count, init_state<br/>    return inner</span><span id="030b" class="kc kd hi jy b fi ki kf l kg kh">ret = stateful(0)<br/>ret()<br/>ret()<br/>ret()<br/>print(ret())               # first</span><span id="7647" class="kc kd hi jy b fi ki kf l kg kh">ret2 = stateful(10)<br/>print(ret2())              # Second<br/>print(ret())               # Third</span></pre><p id="d222" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码打印出以下输出</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7331" class="kc kd hi jy b fi ke kf l kg kh">('This is a sample program', 4, 0)<br/>('This is a sample program', 11, 10)<br/>('This is a sample program', 12, 0)</span></pre><p id="a378" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们使用了一个全局变量<code class="du kj kk kl jy b">count</code>来跟踪对<code class="du kj kk kl jy b">stateful()</code>的调用次数的状态。由于对<code class="du kj kk kl jy b">stateful()</code>的调用没有保存<code class="du kj kk kl jy b">count</code>变量的状态，我们正在访问全局<code class="du kj kk kl jy b">count</code>变量，并将函数的初始状态<code class="du kj kk kl jy b">init_state</code>赋给<code class="du kj kk kl jy b">count</code>，最后为每个调用递增变量。虽然这确实部分解决了我们的问题，但是我们仍然需要保留发送到<code class="du kj kk kl jy b">stateful()</code>的初始状态。</p><p id="ab5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数的<code class="du kj kk kl jy b">first</code>调用将<code class="du kj kk kl jy b">count</code>记为<code class="du kj kk kl jy b">4</code>。</p><p id="b8c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数的<code class="du kj kk kl jy b">second</code>调用将全局变量count重新初始化为<code class="du kj kk kl jy b">10</code>，这<code class="du kj kk kl jy b">count</code>被视为<code class="du kj kk kl jy b">11</code>。</p><p id="1919" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数的<code class="du kj kk kl jy b">third</code>调用仍然使用先前的初始化状态，并将先前的<code class="du kj kk kl jy b">count</code>值增加到<code class="du kj kk kl jy b">12</code></p><p id="4bb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们看到上面的代码有两个问题。太多重复的代码行(我讨厌这一点)其次，我想隔离新的对象初始化和独立的行为。所以，我一直在寻找更多的答案。</p><p id="fe6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">….<strong class="ix hj">第二次尝试</strong>🤔</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9386" class="kc kd hi jy b fi ke kf l kg kh">def stateful(init_state):<br/>    count = init_state<br/>    def inner():<br/>        nonlocal count<br/>        count += 1<br/>        return "This is a sample program", count, init_state</span><span id="54df" class="kc kd hi jy b fi ki kf l kg kh">    return inner<br/></span><span id="eca3" class="kc kd hi jy b fi ki kf l kg kh">ret = stateful(0)             # init state 0<br/>ret()<br/>ret()<br/>ret()<br/>print(ret())                  # first<br/></span><span id="ba21" class="kc kd hi jy b fi ki kf l kg kh">ret2 = stateful(10)            # init state 10<br/>print(ret2())                  # second<br/>print(ret())                  # third</span></pre><p id="ed3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码输出如下</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4711" class="kc kd hi jy b fi ke kf l kg kh">('This is a sample program', 4, 0)<br/>('This is a sample program', 11, 10)<br/>('This is a sample program', 5, 0)</span></pre><p id="bce4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们使用了语句<code class="du kj kk kl jy b">nonlocal</code>，这样我们不仅可以在后面的阶段使用变量<code class="du kj kk kl jy b">count</code>作为参考，还可以通过调用访问和修改变量<code class="du kj kk kl jy b">count</code>的状态。</p><p id="4934" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">first</code>调用将<code class="du kj kk kl jy b">count</code>作为<code class="du kj kk kl jy b">4</code>。</p><p id="d47d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">second</code>调用将<code class="du kj kk kl jy b">count</code>作为<code class="du kj kk kl jy b">11</code>。</p><p id="704d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">third</code>调用给出的计数为<code class="du kj kk kl jy b">5</code>。</p><p id="aee2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="km">注意</em> </strong>:注意<code class="du kj kk kl jy b">ret</code>和<code class="du kj kk kl jy b">ret2</code>的对象是如何被<code class="du kj kk kl jy b">init_state</code>保留的。对函数<code class="du kj kk kl jy b">ret</code>的注释行<code class="du kj kk kl jy b">third</code>调用是对该函数的第五次调用，因此计数增加到<code class="du kj kk kl jy b">5</code>。当对象<code class="du kj kk kl jy b">ret2</code>用不同的<code class="du kj kk kl jy b">init state</code>即<code class="du kj kk kl jy b">10</code>初始化时，它使用它的一个状态来跟踪变量<code class="du kj kk kl jy b">count</code>，该变量增加到<code class="du kj kk kl jy b">11</code>。</p><p id="9153" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在这个解决方案让我很高兴，因为它给出了问题陈述的答案，但我想知道是否有更多的解决方案给我更多的灵活性来改变状态变量。</p><p id="3237" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">… <strong class="ix hj">第三次尝试</strong>🤔</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3e39" class="kc kd hi jy b fi ke kf l kg kh">def stateful(init_state):<br/>    def inner():<br/>        inner.count += 1<br/>        return "This is a sample program", inner.count, init_state<br/>    inner.count = init_state<br/>    return inner<br/></span><span id="87f9" class="kc kd hi jy b fi ki kf l kg kh">ret = stateful(0)              # init state 0<br/>ret()<br/>ret()<br/>ret()<br/>print(ret())                   # first<br/></span><span id="ed94" class="kc kd hi jy b fi ki kf l kg kh">ret2 = stateful(10)            # init state 10<br/>print(ret2())                  # second<br/>print(ret())                   # third</span><span id="c783" class="kc kd hi jy b fi ki kf l kg kh">print(ret.count, ret2.count)<br/>ret2.count = 20                # change in entity's init state <br/>print(ret2())                  # fourth</span></pre><p id="9964" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码输出如下</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f0f1" class="kc kd hi jy b fi ke kf l kg kh">('This is a sample program', 4, 0)<br/>('This is a sample program', 11, 10)<br/>('This is a sample program', 5, 0)<br/>5 11<br/>('This is a sample program', 21, 10)</span></pre><p id="1e26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们使用了函数属性来跟踪<code class="du kj kk kl jy b">count</code>调用的状态。由于函数<code class="du kj kk kl jy b">inner</code>已经定义，我们可以在返回函数对象之前创建一个使用函数名创建的函数属性<code class="du kj kk kl jy b">inner.count</code>。对象<code class="du kj kk kl jy b">ret</code>和<code class="du kj kk kl jy b">ret2</code>具有它们相应的功能属性，这些属性保留了状态信息。</p><p id="ccc6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">first</code>调用给出了<code class="du kj kk kl jy b">count</code> 4</p><p id="659d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">second</code>调用将<code class="du kj kk kl jy b">count</code>作为<code class="du kj kk kl jy b">11</code>给出。</p><p id="25d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">third</code>调用给出的计数为<code class="du kj kk kl jy b">5</code>。</p><p id="dd16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">fourth</code>调用给出的计数为<code class="du kj kk kl jy b">21</code>。这是因为我们已经使用功能属性<code class="du kj kk kl jy b">inner.count</code>将<code class="du kj kk kl jy b">init_state</code>修改为新状态。</p><p id="2f82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="km">注:</em> </strong>注意我们如何能够直接访问变量并打印它们相应的值。我们也使用函数属性<code class="du kj kk kl jy b">inner.count</code>改变了状态，但是，我们不能修改嵌入到对象中的值<code class="du kj kk kl jy b">init_state</code>，因此我们在输出行<code class="du kj kk kl jy b">(‘This is a sample program’, 21, 10)</code>中看到值<code class="du kj kk kl jy b">10</code>。</p><p id="f019" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这个解决方案给了我更好的改变状态的灵活性，但是它也打开了状态被另一个模块改变的可能性，这可能导致意想不到的结果。</p><p id="1394" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">… <strong class="ix hj">第四次尝试</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="f23a" class="kc kd hi jy b fi ke kf l kg kh">class stateful:<br/>    def __init__(self,init_state):<br/>        self.count = init_state<br/>        self.init_state = init_state</span><span id="6e80" class="kc kd hi jy b fi ki kf l kg kh">def inner(self):<br/>        self.count +=1<br/>        return "This is a sample program", self.count, self.init_state<br/></span><span id="77e3" class="kc kd hi jy b fi ki kf l kg kh">ret = stateful(0)                    # init state 0<br/>ret.inner()<br/>ret.inner()<br/>ret.inner()<br/>print(ret.inner())                   # first<br/></span><span id="d875" class="kc kd hi jy b fi ki kf l kg kh">ret2 = stateful(10)                  # init state 10<br/>print(ret2.inner())                  # second<br/>print(ret.inner())                   # third</span><span id="71f2" class="kc kd hi jy b fi ki kf l kg kh">print(ret.count, ret2.count)<br/>ret2.count = 20                      # change in entity's init state<br/>print(ret2.inner()).                 # fourth</span></pre><p id="0558" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码输出如下</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b976" class="kc kd hi jy b fi ke kf l kg kh">('This is a sample program', 4, 0)<br/>('This is a sample program', 11, 10)<br/>('This is a sample program', 5, 0)<br/>5 11<br/>('This is a sample program', 21, 10)</span></pre><p id="7227" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们使用了class属性来保留状态信息。我们已经用类对象<code class="du kj kk kl jy b">ret</code>和<code class="du kj kk kl jy b">ret2</code>来调用类方法。</p><p id="2f74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">first</code>调用给出了<code class="du kj kk kl jy b">count</code> 4</p><p id="a9e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">second</code>调用将<code class="du kj kk kl jy b">count</code>作为<code class="du kj kk kl jy b">11</code>给出。</p><p id="009b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">third</code>调用给出的计数为<code class="du kj kk kl jy b">5</code>。</p><p id="8382" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">fourth</code>调用给出的计数为<code class="du kj kk kl jy b">21</code>。这是因为我们已经使用类别属性<code class="du kj kk kl jy b">count</code>将状态修改为新的状态。</p><p id="8455" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="km">注意:</em> </strong>我们已经对类方法进行了显式调用。</p><p id="c01b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以修改这个解决方案，使它成为一个可调用的，这是我最后的选择。</p><p id="21c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">… <strong class="ix hj">第五次尝试🤔</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4b42" class="kc kd hi jy b fi ke kf l kg kh">class stateful:<br/>    def __init__(self,init_state):<br/>        self.count = init_state<br/>        self.init_state = init_state<br/>    def __call__(self, *args, **kwargs):<br/>        self.count +=1<br/>        return "This is a sample program", self.count, self.init_state<br/></span><span id="ee1d" class="kc kd hi jy b fi ki kf l kg kh">ret = stateful(0)              # init state 0<br/>ret()<br/>ret()<br/>ret()<br/>print(ret())                   # first<br/></span><span id="7190" class="kc kd hi jy b fi ki kf l kg kh">ret2 = stateful(10)            # init state 10<br/>print(ret2())                  # second<br/>print(ret())                   # third</span><span id="128e" class="kc kd hi jy b fi ki kf l kg kh">print(ret.count, ret2.count)<br/>ret2.count = 20                # change in entity's init state<br/>print(ret2())                  # fourth</span></pre><p id="9234" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码输出如下</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2de2" class="kc kd hi jy b fi ke kf l kg kh">('This is a sample program', 4, 0)<br/>('This is a sample program', 11, 10)<br/>('This is a sample program', 5, 0)<br/>5 11<br/>('This is a sample program', 21, 10)</span></pre><p id="5bce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们使用了class属性来保留<code class="du kj kk kl jy b">count</code>的状态。</p><p id="1ded" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">first</code>调用给出了<code class="du kj kk kl jy b">count</code> 4</p><p id="7541" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">second</code>调用将<code class="du kj kk kl jy b">count</code>作为<code class="du kj kk kl jy b">11</code>。</p><p id="45fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret()</code>的<code class="du kj kk kl jy b">third</code>调用给出的计数为<code class="du kj kk kl jy b">5</code>。</p><p id="6393" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对函数<code class="du kj kk kl jy b">ret2()</code>的<code class="du kj kk kl jy b">fourth</code>调用给出的计数为<code class="du kj kk kl jy b">21</code>。这是因为我们已经使用类属性<code class="du kj kk kl jy b">count</code>将状态修改为一个新的状态。</p><p id="8dfb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="km">注意:</em> </strong>注意我们是如何使用Python的dunder方法使对象可调用的。</p><h1 id="d2e8" class="kn kd hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="c187" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">我试图解释解决问题的不同方法。虽然这些解决方案使我们能够跨程序传递状态信息，但我们没有考虑每种方案的利弊。处理状态信息时最重要的因素，跨程序传递状态信息(性能)的成本甚至没有被考虑。</p><p id="0017" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许我会再写一篇文章来讨论每种方法的优缺点。</p></div></div>    
</body>
</html>