<html>
<head>
<title>Pandas Masterclass — Your Foundation To Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫大师班——你的数据科学基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-2-e0abda580cc3?source=collection_archive---------15-----------------------#2020-01-12">https://medium.com/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-2-e0abda580cc3?source=collection_archive---------15-----------------------#2020-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b9c6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第2部分:特殊文件格式的数据帧操作</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e83fd8df934251affb9e947083116e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMN7XGhKnNt-eQzS35bRVg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片来源:走向数据科学</figcaption></figure><p id="2737" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">欢迎回来！在上一篇文章中，我们已经简要介绍了Pandas，以及如何使用Pandas库来读取各种文件类型并从数据帧中提取数据。</p><p id="1ad9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本文中，我们将讨论如何将数据帧内容写入文件，如何读取数据库、JSON数据和二进制数据等特殊数据类型，然后再对数据进行排序、过滤和分组。</p><p id="17eb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 1。从数据库中读取数据<br/> </strong>在了解如何使用Pandas函数操作和充分利用数据之前，我们首先必须熟悉Python中处理数据库的过程。我们将使用sqlite db来探索这个过程，SQLite db是一个基本的内存数据库，预安装在Mac OS和Linux OS上，并且是一个非常轻的软件包，可以安装在Windows OS上。涉及的各种基本步骤如下。</p><p id="21cd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">I)导入帮助我们执行命令的包<br/>每个数据库都有各自的包，包中有各种预定义的函数，帮助我们处理数据库中的数据。下面是导入sqlite包的语法</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="1e43" class="ko kp hi kk b fi kq kr l ks kt">import sqlite3</span></pre><p id="8949" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">ii)创建与数据库的连接<br/>然后我们建立与数据库的连接。在单个程序中，我们可以通过每次使用一个新的连接变量名来建立任意多的数据库连接。要遵循的语法是</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="a7d4" class="ko kp hi kk b fi kq kr l ks kt">db = sqlite3.connect("myDb1.sqlite")</span></pre><p id="ccec" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这实际上试图连接到数据库<code class="du ku kv kw kk b">myDb</code>，如果它存在，否则它创建一个新的数据库<code class="du ku kv kw kk b">myDb1</code>。</p><p id="4d63" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">iii)执行查询<br/>一旦我们成功连接到数据库，我们就可以使用<code class="du ku kv kw kk b">execute</code>或<code class="du ku kv kw kk b">executemany</code>函数在数据库上执行任意数量的查询。这可以用例子来最好地解释。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="7fd3" class="ko kp hi kk b fi kq kr l ks kt">#Creating a new table in the database<br/>db.execute("CREATE TABLE test (name VARCHAR(50), age INTEGER)")<br/>db.commit()</span></pre><p id="d5dc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们正在执行一个表创建查询，然后将更改提交给数据库。这将创建一个名为<code class="du ku kv kw kk b">test</code>的新表，表中的列<code class="du ku kv kw kk b">name</code>包含长度为50的可变字符类型字段和整数<code class="du ku kv kw kk b">age</code>。</p><p id="588b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以使用同一个execute函数从<code class="du ku kv kw kk b">test</code>表中插入和检索数据。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="6cab" class="ko kp hi kk b fi kq kr l ks kt">db.execute("INSERT INTO test values(?, ?)", ("Raghu", 34))</span></pre><p id="e7ea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里我们必须记住的是，只有在Python中，表才以元组的形式存储和检索值。当我们传递参数时，它只能作为一个元组传递，就像上面的例子中给出的那样，这个例子基本上是在表的第一行插入值<code class="du ku kv kw kk b">"Raghu"</code>和<code class="du ku kv kw kk b">34</code>。</p><p id="94c8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于保存在列表或嵌套元组中的大型数据集，我们可以简单地执行如下的For循环</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="0d59" class="ko kp hi kk b fi kq kr l ks kt">list1 = [("Divya", 28), ("Dad", 69), ("Mom", 63)]</span><span id="8c00" class="ko kp hi kk b fi kx kr l ks kt">for entry in list1:<br/>    db.execute("INSERT INTO test values(?, ?)", entry)<br/>db.commit()</span></pre><p id="1727" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以上代码行将从列表<code class="du ku kv kw kk b">list1</code>中顺序读取每个元组，然后对每组值执行<code class="du ku kv kw kk b">insert</code>语句。</p><p id="88d1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">或者，我们可以使用更有用的<code class="du ku kv kw kk b">executemany</code>函数，如下所示</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="e512" class="ko kp hi kk b fi kq kr l ks kt">list1 = [("Divya", 28), ("Dad", 69), ("Mom", 63)]<br/>db.executemany("INSERT INTO test values(?, ?), list1)<br/>db.commit()</span></pre><p id="60da" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从数据库中选择内容有点不同。一旦我们执行了查询，它将结果存储到一个cursor对象中，然后这个对象要么被转换成一个可以迭代的列表，要么使用<code class="du ku kv kw kk b">fetchall()</code>函数来完成相同的工作。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="e5b5" class="ko kp hi kk b fi kq kr l ks kt">results = db.execute("SELECT * FROM test ORDER BY age DESC")<br/>print(type(results)) #showing type of result object<br/>rows = results.fetchall()<br/>print(rows)</span></pre><p id="4080" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">或者</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="2c7d" class="ko kp hi kk b fi kq kr l ks kt">results = db.execute("SELECT * FROM test ORDER BY age DESC")<br/>print(type(results)) #showing type of result object<br/>rows = list(results)<br/>print(rows)</span></pre><p id="d16e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">两者都将创建一个名为<code class="du ku kv kw kk b">rows</code>的列表，存储<code class="du ku kv kw kk b">test</code>表的全部内容，其中每一行都作为一个元组存储，如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/384d926c0fbf345c10b14f30a9e7d571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*yGByBkc3gdWEL8Zdzmzobg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">结果类型是光标。将select查询的输出打印为元组列表。</figcaption></figure><p id="0235" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我们能够从一个表中提取数据并将其存储在一个列表中，我们实际上就可以将它转换成一个数据帧，以便进一步处理数据。</p><p id="77e9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第一步是使用<code class="du ku kv kw kk b">description</code>属性读取列标签。属性的第一个元素存储列名。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="971e" class="ko kp hi kk b fi kq kr l ks kt">print(results.description)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kz"><img src="../Images/d638fd038e0b2a57b05ea0c7ef01dcb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*xx11QM9Ug022ipIuHIsE-g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">每个元组的第一个元素具有列名</figcaption></figure><p id="df19" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，我们使用Pandas的<code class="du ku kv kw kk b">DataFrame</code>函数将<code class="du ku kv kw kk b">test</code>表内容存储转换为<code class="du ku kv kw kk b">rows</code>变量中的列表，然后从<code class="du ku kv kw kk b">results.description</code>变量分配列标签。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="e12f" class="ko kp hi kk b fi kq kr l ks kt">pdResults = pd.DataFrame(rows, columns=[x[0] for x in results.description])<br/>print(pdResults)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/cf3823f5f29ec4a268de897b34bcffa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*vGdmQMsj-dCp1RzemQqiag.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">显示列表内容的数据框</figcaption></figure><p id="1f10" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 2。读取JSON数据</strong> <br/>最近，大多数使用web APIs的通信都是以JSON格式传输数据，因此掌握必要的技能来解析JSON数据并以数据帧的形式从中提取信息是非常必要的。</p><p id="e03f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们从一个简单的JSON数据开始。请注意，只有当数据作为字符串传递时，Python的JSON包才能使用默认函数解析JSON数据。考虑以下字符串格式的JSON数据。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="bfe5" class="ko kp hi kk b fi kq kr l ks kt">obj = """{"name":"Wes",<br/>       "places_lived":["United States", "Spain", "Germany"],<br/>       "pet":"null",<br/>       "siblings": [{"name":"Scott", "age":30, "pets":["Zeus", "Zuko"]},<br/>                    {"name":"Katie", "age":38, "pets":["Sixes", "Stache", "Cisco"]}]<br/>       }"""</span><span id="cb8a" class="ko kp hi kk b fi kx kr l ks kt">#we use """ to take the JSON data as string</span></pre><p id="b50f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当我们检查<code class="du ku kv kw kk b">obj</code>变量数据类型时，它也显示为<code class="du ku kv kw kk b">str</code>。</p><p id="583e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在导入<code class="du ku kv kw kk b">json</code>包之后，我们将JSON数据加载到一个变量中。JSON数据加载到的变量将采用<code class="du ku kv kw kk b">dict</code>的形式。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="f3ab" class="ko kp hi kk b fi kq kr l ks kt">import json</span><span id="fece" class="ko kp hi kk b fi kx kr l ks kt">results = json.loads(obj)</span><span id="5fd8" class="ko kp hi kk b fi kx kr l ks kt">print(type(results)) #this prints out &lt;class 'dict'&gt;</span></pre><p id="99bb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以使用在线免费的JSON可视化查看器来可视化地浏览JSON数据。你可以利用的一个网站是JsonViewer 。上面的<code class="du ku kv kw kk b">obj</code> JSON数据会显示如下。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lc"><img src="../Images/d585926e9c7e0c1a3a47e1741557592d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*e7JqwWs6tNRiCctneRBK7g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">存储JSON数据的obj变量的可视化表示</figcaption></figure><p id="66fe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可以使用<code class="du ku kv kw kk b">dumps()</code>函数将JSON数据从<code class="du ku kv kw kk b">dict</code>格式恢复到<code class="du ku kv kw kk b">str</code>格式。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="d176" class="ko kp hi kk b fi kq kr l ks kt">dumpResults = json.dumps(results)<br/>print(type(dumpResults)) #this prints out &lt;class 'str'&gt;</span></pre><p id="110b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">通过调用dict的<code class="du ku kv kw kk b">key</code>来读取特定的JSON数据，该dict输出与<code class="du ku kv kw kk b">key</code>相关联的<code class="du ku kv kw kk b">value</code>。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="f14d" class="ko kp hi kk b fi kq kr l ks kt">print(results["siblings"]) #prints all values of key 'siblings'<br/>print(results["siblings"][0]) #prints the first value of key 'siblings'<br/>print(results["siblings"][0]["name"]) #prints value of 'name' key in first value of 'siblings' key value.</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/e0852582ccc5de15f819bf71c811d3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*AYuxTqQAi__BEOkCeGMIjQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">以上三个打印报表的输出</figcaption></figure><p id="4a54" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我们能够有选择地调用JSON数据，我们就可以将它转换成DataFrame，只要所选键的<code class="du ku kv kw kk b">key</code>中的所有<code class="du ku kv kw kk b">values</code>长度相等。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="cfa8" class="ko kp hi kk b fi kq kr l ks kt">dfResults = pd.DataFrame(results["siblings"], columns = ["name", "age", "pets"])<br/>print(dfResults)</span></pre><p id="9100" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上面的代码调用<code class="du ku kv kw kk b">'siblings'</code>键来检索它的<code class="du ku kv kw kk b">values</code>，然后指定我们想要提取所有列，我们也可以省略<code class="du ku kv kw kk b">columns</code>属性，因为默认情况下它检索所有列的数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/603b7c6de8899bf2615d9f8b54d30cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*UlCUpzCIlxKZmqhm_O3XBw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">JSON数据到数据帧输出</figcaption></figure><p id="14d4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要获得JSON数据中所有键的列表，我们可以使用dictionary数据类型的<code class="du ku kv kw kk b">key()</code>函数。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="8a5c" class="ko kp hi kk b fi kq kr l ks kt">print(results.keys()) #JSON data keys<br/>print(dfResults.keys()) #DataFrame keys</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/c0494e74baa53f75c631adf2298270f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*76XxQlQZ6macu-gW0IaYww.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">打印JSON数据的密钥和部分加载JSON数据的数据帧</figcaption></figure><p id="a43c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 3。从web API中读取数据<br/> </strong>正如我们刚刚讨论的将JSON数据加载到DataFrame中一样，现在让我们看另一个JSON例子，但是是从Web API中读取JSON数据。读取web API数据由python中的<code class="du ku kv kw kk b">requests</code>包处理。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="668a" class="ko kp hi kk b fi kq kr l ks kt">import requests</span><span id="a935" class="ko kp hi kk b fi kx kr l ks kt">url = "<a class="ae lb" href="http://api.github.com/repos/pandas-dev/pandas/issues" rel="noopener ugc nofollow" target="_blank">http://api.github.com/repos/pandas-dev/pandas/issues</a>"<br/>webData = requests.get(url)<br/>print(type(webData))</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es la"><img src="../Images/5cee8791309803d81b117f81139a8da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*MslrLnL7GsrFGjGsCVcF7Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">get函数的结果返回一个响应对象</figcaption></figure><p id="6a4a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">函数<code class="du ku kv kw kk b">get()</code>用存储在另一个变量<code class="du ku kv kw kk b">webData</code>中的响应对象进行响应。然后，我们使用<code class="du ku kv kw kk b">json()</code>函数读取作为web URL响应接收的JSON数据。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="4813" class="ko kp hi kk b fi kq kr l ks kt">jsonData = webData.json()</span></pre><p id="db99" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，变量<code class="du ku kv kw kk b">jsonData</code>存储了JSON数据，如前所述，可以使用任何在线JSON数据可视化器直观地看到这些数据。我们可以将部分JSON数据提取到一个DataFrame中，就像前面讨论JSON数据类型一样。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="eb7f" class="ko kp hi kk b fi kq kr l ks kt">dfData = pd.DataFrame(jsonData, columns=['url', 'repository_url', 'labels_url', 'comments_url', 'events_url', 'html_url'])<br/>print(dfData.iloc[1])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/0747a9816dd612c5ef7f30af04251d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*1C-vWLdc3ANu9VUh8m7YvA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">dfData数据框中的示例行</figcaption></figure><p id="46dc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> 4。读取和操作二进制数据。<br/> </strong>机器学习中使用最多的二进制文件格式是Pickle文件格式和HDF5文件格式。由于大多数函数非常相似，我们将只举一个简单的读取和写入二进制数据Pickle文件格式的例子。</p><p id="aaea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了将存储在数据帧中的内容写入Pickle文件格式，我们使用具有以下语法的<code class="du ku kv kw kk b">to_pickle()</code>函数</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="ce00" class="ko kp hi kk b fi kq kr l ks kt">results = pd.read_csv("stock_px.csv") #reading a csv file into a dataframe<br/>results.to_pickle("pickleStocks") #stores in a pickle file format with name of the file as 'pickleStocks'</span></pre><p id="72a0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这将创建一个文件名为<code class="du ku kv kw kk b">pickleStocks</code>的pickle文件，并将数据帧<code class="du ku kv kw kk b">results</code>中的数据存储到其中。</p><p id="fcaa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了从pickle文件中读取数据，我们使用如下的<code class="du ku kv kw kk b">read_pickle()</code>函数，将数据存储到数据帧中</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="b726" class="ko kp hi kk b fi kq kr l ks kt">pickleDf = pd.read_pickle("pickleStocks")</span></pre><p id="a3d9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一旦我们知道了如何读写pickle格式的数据，接下来的操作就很简单了。</p><p id="2248" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我们几乎完成了使用Pandas从各种类型的文件中读取内容，并部分介绍了使用<code class="du ku kv kw kk b">iloc</code>和<code class="du ku kv kw kk b">loc</code>函数选择性地显示DataFrame数据。在本系列接下来的部分中，我们将探索将JSON数据存储到文件中，对数据进行排序、过滤和分组。</p><p id="a324" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">系列各部分:</strong><br/><a class="ae lb" rel="noopener" href="/analytics-vidhya/pandas-masterclass-your-foundation-to-data-science-part-1-136474104d57">Pandas master class——你的数据科学基础(第一部分:基本数据帧操作)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-2-e0abda580cc3">Pandas master class——你的数据科学基础(第二部分:特殊文件格式的数据帧操作)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-3-220cd683540e">Pandas master class——你的数据科学基础(第三部分:排序、 过滤和分组数据帧数据并写入文件)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-4-736a233b0b70">Pandas master class—您的数据科学基础(第4部分:Pandas函数)</a><br/><a class="ae lb" rel="noopener" href="/@raghupro/pandas-masterclass-your-foundation-to-data-science-part-5-5e86b812f6c3">Pandas master class—您的数据科学基础(第5部分:多索引数据帧、处理na值和组合数据帧)</a></p></div></div>    
</body>
</html>