<html>
<head>
<title>Feature Engineering for Images: A Valuable Introduction to the HOG Feature Descriptor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像特征工程:HOG特征描述符的有价值的介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/feature-engineering-for-images-a-valuable-introduction-to-the-hog-feature-descriptor-9f27512e5361?source=collection_archive---------15-----------------------#2019-09-04">https://medium.com/analytics-vidhya/feature-engineering-for-images-a-valuable-introduction-to-the-hog-feature-descriptor-9f27512e5361?source=collection_archive---------15-----------------------#2019-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="7dda" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><ul class=""><li id="3e60" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">了解HOG特征描述符背后的内部工作原理和数学原理</li><li id="a0f8" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">HOG特征描述子在计算机视觉中广泛用于目标检测</li><li id="2e3d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">对所有计算机视觉爱好者有价值的特征工程指南</li></ul><h1 id="738b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="a0a2" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">特征工程是机器学习算法领域的游戏规则改变者。这实际上是我作为数据科学家最喜欢的方面之一！这是我们进行实验最多的地方——从现有的功能中设计新的功能，并提高我们模型的性能。</p><p id="f4f8" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">世界上一些顶尖的数据科学家依靠特征工程来提高他们在黑客马拉松中的排行榜分数。我相信您甚至会在结构化数据上使用各种特征工程技术。</p><p id="6688" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们能否将这种技术扩展到非结构化数据，比如图像？对于计算机视觉爱好者来说，这是一个有趣的谜题，也是我们将在本文中解决的问题。准备好以特征提取的形式对图像数据执行特征工程！</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/2260b74be4a98b2e695c5446776e7a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*umzdyTf1ryDVcJwo.jpg"/></div></div></figure><p id="fee6" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated"><em class="lh">实际上有多种特征提取技术。我在上一篇文章中提到了三个基本问题，您应该在继续之前阅读一下:</em></p><p id="8e05" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">在本文中，我将向您介绍一种流行的图像特征提取技术——梯度方向直方图，或俗称的HOG。我们将了解什么是HOG特征描述符，它是如何工作的(算法背后的完整数学)，最后，用Python实现它。</p><h1 id="66d7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="79da" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq li js jt ju bi translated">什么是特征描述符？</li><li id="cf5a" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">HOG特征描述符介绍</li><li id="a2be" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">计算HOG <br/>的过程3.1预处理数据<br/> 3.2计算梯度<br/> 3.3计算幅度&amp;方向</li><li id="7286" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">使用梯度和方向创建直方图的方法</li><li id="6878" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">计算HOG的过程<br/> 5.1计算梯度直方图<br/> 5.2归一化梯度<br/> 5.3完整图像的特征</li><li id="5046" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq li js jt ju bi translated">在Python中实现HOG特征描述符</li></ol><h1 id="7b66" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是特征描述符？</h1><p id="8917" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">你可能看过标题后就有这个疑问了。所以，在我们进入文章的猪部分之前，让我们先弄清楚这一点。</p><p id="33f7" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">看看下面的两张图片。你能区分图像中的物体吗？</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lj"><img src="../Images/34cc82a2da0ac2a41e902a0fc5756a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G_D1BovNvTcjaW7i.png"/></div></div></figure><p id="f712" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们可以清楚地看到，这里的右图有一只狗，左图有一辆车。现在，让我把这个任务变得稍微复杂一点——识别下图中显示的对象:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lk"><img src="../Images/aee26a454749034c0d66cc5f99370fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KaKdycunfZJ-CorO.png"/></div></div></figure><p id="5ade" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">还是很简单，对吧？你能猜出第一个和第二个案例有什么不同吗？第一对图像包含了很多信息，比如物体的形状、颜色、边缘、背景等等。</p><p id="c510" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">另一方面，第二对图像的信息要少得多(只有形状和边缘)，但仍足以区分两幅图像。</p><p id="d4e0" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">你明白我的意思了吗？在第二种情况下，我们能够很容易地区分物体，因为它有我们识别物体所需的必要信息。这正是特征描述符的作用:</p><blockquote class="ll lm ln"><p id="2b14" class="ka kb lh jf b jg kp kc kd ji kq ke kf lo kr kh ki lp ks kk kl lq kt kn ko jq hb bi translated">它是图像的简化表示，仅包含关于图像的最重要信息。</p></blockquote><p id="ed4d" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">有许多特性描述符。以下是几个最受欢迎的:</p><ul class=""><li id="58ab" class="jd je hi jf b jg kp ji kq jk lr jm ls jo lt jq jr js jt ju bi translated">HOG:方向梯度直方图</li><li id="35d7" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">SIFT:尺度不变特征变换</li><li id="6fd4" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">SURF:加速的健壮特性</li></ul><p id="e907" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">在本文中，我们将重点介绍HOG特征描述符及其工作原理。我们开始吧！</p><h1 id="8fce" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">HOG特征描述符介绍</h1><p id="038c" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">HOG或方向梯度直方图是一种特征描述符，通常用于从图像数据中提取特征。它广泛应用于<a class="ae ku" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2/?utm_source=blog&amp;utm_medium=understand-math-HOG-feature-descriptor" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>任务中进行<a class="ae ku" href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=understand-math-HOG-feature-descriptor" rel="noopener ugc nofollow" target="_blank">物体检测</a>。</p><p id="ccb9" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">让我们来看看HOG与其他特性描述符不同的一些重要方面:</p><ul class=""><li id="771a" class="jd je hi jf b jg kp ji kq jk lr jm ls jo lt jq jr js jt ju bi translated">HOG描述符侧重于对象的结构或形状。现在你可能会问，这与我们为图像提取的边缘特征有什么不同？在边缘特征的情况下，我们只识别像素是否是边缘。HOG也能够提供边缘方向。这是通过提取边缘的<strong class="jf hj">梯度和方向</strong>(或者你可以说幅度和方向)来完成的</li><li id="082e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">此外，这些方位在<strong class="jf hj">“局部化”部分</strong>中进行计算。这意味着完整的图像被分解成更小的区域，并且对于每个区域，计算梯度和方向。我们将在接下来的章节中更详细地讨论这一点</li><li id="4823" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">最后，HOG将分别为这些区域中的每一个生成一个直方图<strong class="jf hj">。直方图是使用像素值的梯度和方向创建的，因此被命名为“梯度方向直方图”</strong></li></ul><p id="1b45" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">给它下一个正式的定义:</p><blockquote class="ll lm ln"><p id="1a49" class="ka kb lh jf b jg kp kc kd ji kq ke kf lo kr kh ki lp ks kk kl lq kt kn ko jq hb bi translated"><em class="hi">HOG特征描述符统计图像局部梯度方向的出现次数。</em></p></blockquote><p id="2856" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">使用OpenCV之类的工具实现HOG非常简单。这只是几行代码，因为我们在<strong class="jf hj"> <em class="lh"> skimage.feature </em> </strong>库中有一个名为<strong class="jf hj"> <em class="lh"> hog </em> </strong>的预定义函数。然而，在本文中，我们关注的是这些特性实际上是如何计算的。</p><h1 id="d1eb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">计算方向梯度直方图(HOG)的过程</h1><p id="1240" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">我们现在应该对什么是HOG特征描述符有了一个基本的概念。是时候深入探究这篇文章背后的核心思想了。我们来讨论一下计算HOG的一步一步的过程。</p><p id="a8e1" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">考虑下图的尺寸(180 x 280)。让我们详细看看如何为该图像创建HOG特征:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lu"><img src="../Images/9cfa40b8d729ba78036ae401343ed46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/0*Sqg3qGpnDxcOEb_Z.jpeg"/></div></figure><h1 id="65bc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">步骤1:预处理数据(64 x 128)</h1><p id="6c4f" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">这是你们大多数人都很熟悉的一步。在任何机器学习项目中，预处理数据都是至关重要的一步，在处理图像时也是如此。</p><p id="fd61" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们需要对图像进行预处理，将宽高比降低到1:2。图像大小最好是64 x 128。这是因为我们将把图像分成8*8和16*16的小块来提取特征。具有指定的大小(64 x 128)将使我们所有的计算非常简单。其实这就是<a class="ae ku" href="http://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf" rel="noopener ugc nofollow" target="_blank">原论文</a>中使用的确切数值。</p><p id="1637" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">回到我们的例子，让我们把64 x 128的尺寸作为现在的标准图像尺寸。这是调整后的图像:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lv"><img src="../Images/ff3a95e3959b7d5a0216250c08a54070.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*tinUWyrUBJ2AEwia.png"/></div></figure><h1 id="69b1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">步骤2:计算梯度(x和y方向)</h1><p id="d38a" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">下一步是计算图像中每个像素的梯度。<strong class="jf hj">渐变是x和y方向的微小变化。</strong>在这里，我将从图像中提取一小块，并计算其梯度:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lv"><img src="../Images/c9c8f49f90b85fcd3d77b6bc8470015f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*l85r_E2DYa10HIW1.png"/></div></figure><p id="8da2" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们将得到这个补丁的像素值。假设我们为给定的补丁生成下面的像素矩阵<em class="lh">(此处显示的矩阵仅用作示例，这些不是给定补丁的原始像素值)</em>:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lw"><img src="../Images/f487da101330e00ba9a4cd385046382e.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*hM1_Qun6P0fypasO.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">来源:<a class="ae ku" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional/?utm_source=blog&amp;utm_medium=understand-math-HOG-feature-descriptor" rel="noopener ugc nofollow" target="_blank">应用机器学习课程</a></figcaption></figure><p id="1c91" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我已经突出显示了像素值85。现在，为了确定x方向的梯度(或变化)，我们需要从右边的像素值中减去左边的值。类似地，为了计算y方向的梯度，我们将从所选像素上方的像素值中减去下方的像素值。</p><p id="7e1a" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">因此，该像素在x和y方向上的合成梯度为:</p><ul class=""><li id="8e10" class="jd je hi jf b jg kp ji kq jk lr jm ls jo lt jq jr js jt ju bi translated">X方向的变化(Gx)= 89–78 = 11</li><li id="e190" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">Y方向的变化(Gy)= 68–56 = 8</li></ul><p id="9b24" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这个过程将为我们提供两个新矩阵，一个存储x方向的梯度，另一个存储y方向的梯度。这类似于使用大小为1的Sobel核。当强度发生急剧变化时，例如在边缘附近，震级会更高。</p><p id="e01f" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们已经分别计算了x和y方向的梯度。对图像中的所有像素重复相同的过程。下一步将是使用这些值找到震级和方位。</p><h1 id="05d2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">第三步:计算震级和方位</h1><p id="84ca" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">使用我们在上一步中计算的梯度，我们现在将确定每个像素值的大小和方向。对于这一步，我们将使用毕达哥拉斯定理(是的，就是你在学校学过的那一个！).</p><p id="807e" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">请看下图:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lv"><img src="../Images/8485227aa0d046dad2597ca3647bfae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*PLAuSJiM0JgtUFEq.png"/></div></figure><p id="bd76" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">梯度基本上是底部和垂直的。在前面的例子中，Gx和Gy分别为11和8。让我们应用毕达哥拉斯定理来计算总梯度幅度:</p><p id="1174" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">总梯度幅度= √[(11) 2+(8) 2] = 13.6</p><p id="b997" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">接下来，计算同一像素的方向。我们知道可以为角度写tan:</p><p id="27d9" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">tan(φ)= Gy/Gx</p><p id="3d17" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">因此，角度值为:</p><p id="2312" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">φ= atan(Gy/Gx)</p><p id="1190" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">当我们插入这些值时，方向是36。所以现在，对于每个像素值，我们有总梯度(幅度)和方向(方向)。我们需要使用这些梯度和方向来生成直方图。</p><p id="0a90" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">但是等一下——在我们开始研究如何在HOG特征描述符中创建直方图之前，我们需要稍微休息一下。这是整个过程中的一小步。首先，我们将讨论一些使用两个值(梯度和方向)创建直方图的简单方法。</p><h1 id="865d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用梯度和方向创建直方图的不同方法</h1><p id="3ee5" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated"><strong class="jf hj">直方图是显示一组连续数据的频率分布的图。</strong>我们在x轴上有变量(以箱的形式),在y轴上有频率。这里，我们在x轴上取角度或方向，在y轴上取频率。</p><h1 id="b8d1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">方法1:</h1><p id="a17d" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">让我们从生成直方图的最简单的方法开始。我们将获取每个像素值，找到像素的方向并更新频率表。</p><p id="ca81" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">下面是高亮像素(85)的处理过程。由于此像素的方向为36，我们将在角度值36处添加一个数字，表示频率:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mb"><img src="../Images/6c645c799aac7a1f76c9fc7ee659fe44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WTXE_wNXj524tqnh.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated"><a class="ae ku" href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2019/08/article-image-10.png" rel="noopener ugc nofollow" target="_blank">来源:</a> <a class="ae ku" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional" rel="noopener ugc nofollow" target="_blank">应用机器学习课程</a></figcaption></figure><p id="f2e8" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">对所有像素值重复相同的过程，我们最终得到一个频率表，它表示图像中的角度和这些角度的出现。该频率表可用于生成直方图，x轴为角度值，y轴为频率。</p><p id="40c1" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这是创建直方图的一种方法。注意，这里直方图的柱值是1。因此，我们得到大约180个不同的桶，每个桶代表一个方向值。另一种方法是为较高的bin值创建直方图特征。</p><h2 id="e21a" class="mc ig hi bd ih md me mf il mg mh mi ip jk mj mk it jm ml mm ix jo mn mo jb mp bi translated">方法二:</h2><p id="1d23" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">这个方法类似于前面的方法，除了这里我们有一个大小为20的容器。所以，我们在这里得到的桶数是9。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mq"><img src="../Images/a07e2c2a18c36cace2a25799f365f70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/0*b-suFrF70PkvVZ6Y.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated"><a class="ae ku" href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2019/08/article-image-10.png" rel="noopener ugc nofollow" target="_blank">来源:</a> <a class="ae ku" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional" rel="noopener ugc nofollow" target="_blank">应用机器学习课程</a></figcaption></figure><p id="6a50" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">同样，对于每个像素，我们将检查方向，并以9 x 1矩阵的形式存储方向值的频率。绘制这个图会给出直方图:</p><h2 id="e43c" class="mc ig hi bd ih md me mf il mg mh mi ip jk mj mk it jm ml mm ix jo mn mo jb mp bi translated">方法三:</h2><p id="347a" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">上述两种方法仅使用方向值来生成直方图，而不考虑梯度值。这里是我们生成直方图的另一种方法— <strong class="jf hj">不使用频率，我们可以使用梯度幅度来填充矩阵中的值。</strong>下面是一个例子:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mr"><img src="../Images/3a13555d963a7be823c5a42184da1313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*PtbiTasHMC8Sivxb.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated"><a class="ae ku" href="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2019/08/article-image-10.png" rel="noopener ugc nofollow" target="_blank">来源:</a> <a class="ae ku" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional" rel="noopener ugc nofollow" target="_blank">应用机器学习课程</a></figcaption></figure><p id="9dcd" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">您可能已经注意到，我们使用的方向值为30，并且只更新bin 20。此外，我们还应该给另一个箱子一些权重。</p><h1 id="31e4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">方法4:</h1><p id="e90b" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">让我们对上面的方法做一个小小的修改。这里，我们将像素梯度的贡献添加到像素梯度任一侧的箱中。请记住，越靠近方向的面元值贡献越大。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ms"><img src="../Images/31145b8fdd7904c34b4198ea17d44857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*zdVKaoPv5TNmcHAT.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">来源:<a class="ae ku" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional" rel="noopener ugc nofollow" target="_blank">应用机器学习课程</a></figcaption></figure><p id="8f83" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这正是在HOG特征描述符中创建直方图的方式。</p><h1 id="cd5c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">步骤4:计算8×8单元(9×1)的梯度直方图</h1><p id="6255" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">在HOG特征描述符中创建的直方图不是为整个图像生成的。相反，图像被分成8×8个单元，并且为每个单元计算方向梯度的直方图。你认为为什么会发生这种情况？</p><p id="5354" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">通过这样做，我们得到了代表整个图像的小块的特征(或直方图)。我们当然可以将此处的值从8 x 8更改为16 x 16或32 x 32。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mt"><img src="../Images/9dca9e3adfd063d3a9a3176ec57e2e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/0*g2l8-jdf3NdWOJF0.png"/></div></figure><p id="efb2" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">如果我们将图像分成8×8个单元并生成直方图，我们将为每个单元得到一个9×1的矩阵。这个矩阵是使用我们在上一节中讨论的方法4生成的。</p><p id="3f9f" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">一旦我们为图像中的8×8小块生成了HOG，下一步就是归一化直方图。</p><h1 id="e164" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">步骤5:归一化16×16单元格(36×1)中的梯度</h1><p id="5eaa" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">在我们理解这是如何做到的之前，首先理解为什么这样做是很重要的。</p><p id="a560" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">虽然我们已经为图像的8×8单元创建了HOG特征，但是图像的梯度对整体照明很敏感。这意味着对于特定的图片，图像的某些部分与其他部分相比会非常亮。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mu"><img src="../Images/93164a31cc6be3a258f6010960d87dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*i7vYFGsthbtGQ24_.png"/></div></figure><p id="7121" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们不能从图像中完全消除这一点。但是，我们可以通过采用16×16块来归一化梯度，从而减少这种光照变化。以下示例可以解释16×16块是如何创建的:</p><p id="9314" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这里，我们将组合四个8×8单元来创建一个16×16块。我们已经知道，每个8×8的单元都有一个9×1的直方图矩阵。因此，我们将有四个9×1矩阵或一个36×1矩阵。为了规范化这个矩阵，我们将把这些值除以这些值的平方和的平方根。数学上，对于给定的矢量V:</p><p id="5d8c" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">V = [a1，a2，a3，….a36]</p><p id="10b1" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们计算平方和的平方根:</p><p id="7a7b" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">k = √(a1)2+ (a2)2+ (a3)2+ …。(a36)2</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lv"><img src="../Images/7fe6252202756fd839e08a096fc58517.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*YKAmLEvogZ7MG96Y.png"/></div></figure><p id="8259" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">并将向量V中的所有值除以这个值k:</p><p id="3855" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">结果将是大小为36×1的归一化向量。</p><h1 id="0e60" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">步骤6:完整图像的特征</h1><p id="25df" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">我们现在处于为图像生成HOG特征的最后一步。到目前为止，我们已经为图像的16×16块创建了特征。现在，我们将结合所有这些来获得最终图像的特征。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mv"><img src="../Images/fd3d74faf8dd695f7ef0fdc5f840a38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/0*9bQInXxPGYsrSEqE.png"/></div></figure><p id="9332" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">你能猜出给定图像的特征总数是多少吗？我们首先需要找出对于单个64×128的图像，我们将得到多少个这样的16×16的块:</p><p id="d9f8" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们将有105 (7×15)个16×16的块。这105个块中的每一个都具有36×1的向量作为特征。因此，图像的总特征将是105×36×1 = 3780个特征。</p><p id="9947" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们现在将为单个图像生成HOG特征，并验证我们最终是否获得相同数量的特征。</p><h1 id="4697" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在Python中实现HOG特征描述符</h1><p id="f0df" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">是时候启动Python了！我相信，这是本文最令人期待的部分。所以让我们开始吧。</p><p id="99e5" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们将了解如何在单个图像上生成HOG特征，以及是否可以在更大的数据集上应用同样的方法。我们将首先加载所需的库和映像，我们将为其创建HOG特性:</p><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="8f90" class="mc ig hi mx b fi nb nc l nd ne">#importing required libraries                       <br/>from skimage.io import imread, imshow                       <br/>from skimage.transform import resize                       <br/>from skimage.feature import hog                       <br/>from skimage import exposure                       <br/>import matplotlib.pyplot as plt                       <br/>%matplotlib inline<br/>                                                                       #reading the image                       <br/>img = imread('puppy.jpeg')                       <br/>imshow(img)                       <br/>print(img.shape)</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es nf"><img src="../Images/34a86921a6f01d609328eabf372cd715.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/0*PvwwZGhBryl5iyhd.png"/></div></figure><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="d8ee" class="mc ig hi mx b fi nb nc l nd ne">(663, 459, 3)</span></pre><p id="eaf2" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">我们可以看到图像的形状是663 x 459。我们将不得不把这张图片的尺寸调整为64 x 128。注意，我们使用的是<em class="lh"> skimage </em>，它将输入作为高度x宽度。</p><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="1199" class="mc ig hi mx b fi nb nc l nd ne">#resizing image                        <br/>resized_img = resize(img, (128,64))  <br/>                      <br/>imshow(resized_img)                        print(resized_img.shape)</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ng"><img src="../Images/30b3ed96bfd6ab9b2269b84210330150.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/0*RjM4F19L3NPsh2y8.png"/></div></figure><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="e60d" class="mc ig hi mx b fi nb nc l nd ne">(128, 64, 3)</span></pre><p id="a2c8" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">这里，我将直接使用<em class="lh"> skimage.features </em>中的hog函数。所以我们不必单独计算梯度、幅度(总梯度)和方向。hog函数将在内部计算它并返回特征矩阵。</p><p id="2564" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">此外，如果您设置参数' visualize = True '，它将返回猪的图像。</p><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="bc3f" class="mc ig hi mx b fi nb nc l nd ne">#creating hog features                        <br/>fd, hog_image = hog(resized_img, orientations=9,    pixels_per_cell=(8, 8), cells_per_block=(2, 2), visualize=True, multichannel=True)</span></pre><p id="6b36" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">在继续之前，让我给你一个这些超参数代表什么的基本概念。或者，你可以在这里查看来自官方文件<a class="ae ku" href="https://scikit-image.org/docs/dev/api/skimage.feature.html#skimage.feature.hog" rel="noopener ugc nofollow" target="_blank">的定义。</a></p><ul class=""><li id="2d89" class="jd je hi jf b jg kp ji kq jk lr jm ls jo lt jq jr js jt ju bi translated"><em class="lh">方向</em>是我们想要创建的桶的数量。因为我想有一个9 x 1的矩阵，我将设置方向为9</li><li id="f439" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><em class="lh"> pixels_per_cell </em>定义我们为其创建直方图的单元格的大小。在本文的示例中，我们使用了8 x 8个单元格，这里我将设置相同的值。如前所述，您可以选择更改该值</li><li id="5c0d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">我们有另一个超参数<em class="lh"> cells_per_block </em>，它是我们归一化直方图的块的大小。这里，我们提到的是每块的单元数，而不是像素数。因此，这里我们将使用2 x 2，而不是16 x 16</li></ul><p id="2c5e" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">来自函数的特征矩阵存储在变量<em class="lh"> fd </em>中，图像存储在<em class="lh"> hog_image </em>中。让我们检查特征矩阵的形状:</p><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="8ebe" class="mc ig hi mx b fi nb nc l nd ne">fd.shape</span><span id="4bbf" class="mc ig hi mx b fi nh nc l nd ne">(3780,)</span></pre><p id="67d6" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">正如预期的那样，我们有3，780个图像特征，这验证了我们之前在步骤7中所做的计算。您可以选择改变超参数的值，这将为您提供不同大小的特征矩阵。</p><p id="feef" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">让我们最后看看猪的形象:</p><pre class="kw kx ky kz fd mw mx my mz aw na bi"><span id="66c3" class="mc ig hi mx b fi nb nc l nd ne">fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8), sharex=True, sharey=True)                                                </span><span id="b5d8" class="mc ig hi mx b fi nh nc l nd ne">ax1.imshow(resized_img, cmap=plt.cm.gray)                        ax1.set_title('Input image')                                                </span><span id="90dc" class="mc ig hi mx b fi nh nc l nd ne"># Rescale histogram for better display                        hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(0, 10))                                                </span><span id="65fd" class="mc ig hi mx b fi nh nc l nd ne">ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)                        ax2.set_title('Histogram of Oriented Gradients')                                               plt.show()</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ni"><img src="../Images/756a133463b9c66b3cb301163f62f5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vBEi8ZCxszuDXjLZ.png"/></div></div></figure><h1 id="23dd" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="ec85" class="pw-post-body-paragraph ka kb hi jf b jg jh kc kd ji jj ke kf jk kg kh ki jm kj kk kl jo km kn ko jq hb bi translated">本文的目的是让您了解HOG特征描述符背后实际发生了什么，以及这些特征是如何计算的。整个过程分为7个简单的步骤。</p><p id="7b01" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated">下一步，我会鼓励你在一个简单的<a class="ae ku" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2/?utm_source=blog&amp;utm_medium=understand-math-HOG-feature-descriptor" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>问题上尝试使用HOG特性，看看模型性能是否有所提高。请在评论区分享你的结果！</p></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><p id="4e93" class="pw-post-body-paragraph ka kb hi jf b jg kp kc kd ji kq ke kf jk kr kh ki jm ks kk kl jo kt kn ko jq hb bi translated"><em class="lh">原载于2019年9月4日</em><a class="ae ku" href="https://www.analyticsvidhya.com/blog/2019/09/feature-engineering-images-introduction-hog-feature-descriptor/" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://www.analyticsvidhya.com</em></a>T22。</p></div></div>    
</body>
</html>