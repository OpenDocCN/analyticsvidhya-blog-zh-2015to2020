<html>
<head>
<title>Boolean Retrieval Model Using Inverted Index and Positional Index</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用倒排索引和位置索引的布尔检索模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/boolean-retrieval-model-using-inverted-index-and-positional-index-2a9782bcec99?source=collection_archive---------3-----------------------#2020-04-02">https://medium.com/analytics-vidhya/boolean-retrieval-model-using-inverted-index-and-positional-index-2a9782bcec99?source=collection_archive---------3-----------------------#2020-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3afd5c9f80500dafbe56eecd5a98a6f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bVIw7n9ZEKJEHvNDJLEwg.png"/></div></div></figure><p id="cbe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di"> I </span> <strong class="is hj">信息检索</strong> ( <strong class="is hj"> IR </strong>)是从这些资源的集合中获取与信息需求相关的<a class="ae jx" href="https://en.wikipedia.org/wiki/Information_system" rel="noopener ugc nofollow" target="_blank">信息系统资源的活动。搜索可以基于</a><a class="ae jx" href="https://en.wikipedia.org/wiki/Full-text_search" rel="noopener ugc nofollow" target="_blank">全文</a>或其他基于内容的索引。信息检索是在文档中搜索信息、搜索文档本身以及搜索描述数据的元数据和文本、图像或声音数据库的科学。[1]</p><p id="4dfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(标准)<strong class="is hj">布尔信息检索(BIR) </strong>模型是一个经典的<a class="ae jx" href="https://en.wikipedia.org/wiki/Information_retrieval" rel="noopener ugc nofollow" target="_blank">信息检索</a> (IR)模型，同时也是第一个和最常用的模型。直到今天，许多红外系统都在使用它。<strong class="is hj"> BIR </strong>基于<a class="ae jx" href="https://en.wikipedia.org/wiki/Boolean_logic" rel="noopener ugc nofollow" target="_blank">布尔逻辑</a>和经典<a class="ae jx" href="https://en.wikipedia.org/wiki/Set_theory" rel="noopener ugc nofollow" target="_blank">集合论</a>，因为要搜索的文档和用户的查询都被视为术语集。检索基于文档是否包含查询术语。[2]</p><p id="7da6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将分享我所面临的困难，以及我实现的布尔信息检索模型的一些概念。</p><p id="19f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了对文档进行索引、处理查询和显示查询结果，本文包含以下步骤。</p><h1 id="7c6c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">布尔模型的Python实现！</h1><h1 id="daa9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> 1。收集数据集:</strong></h1><p id="c8cc" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">该模型是在唐纳德·特朗普(Donald Trump)的<a class="ae jx" href="https://data.world/data-society/major-speeches-by-donald-trump" rel="noopener ugc nofollow" target="_blank"> 56场主要演讲(2015年6月—2016年11月)</a>数据集上开发的。</p><h1 id="aec8" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.<strong class="ak">导入库:</strong></h1><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="e7ee" class="lk jz hi lg b fi ll lm l ln lo">import numpy as np<br/>import pandas as pd<br/>from flask import Flask, render_template,request<br/>import time<br/>import re<br/>from collections import defaultdict<br/>from nltk.stem import PorterStemmer</span><span id="0df6" class="lk jz hi lg b fi lp lm l ln lo">stop_words = []<br/>with open ("Stopword-List.txt",'r') as file:<br/>    s=file.read().replace('\n',' ')<br/>stop_words = s.split()</span><span id="ea1f" class="lk jz hi lg b fi lp lm l ln lo">ps = PorterStemmer()</span></pre><p id="432a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所述，我只使用了NLTK库中的波特斯特梅尔模块，而其他预处理和标记化都是手动完成的。这里的Flask用于在服务器上部署我们的模型。</p><h1 id="48aa" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.<strong class="ak">制作倒排索引:</strong></h1><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="e79e" class="lk jz hi lg b fi ll lm l ln lo">def inverted_index(stop_words):<br/> dictionary = {}<br/> documents = {}<br/> <br/> for i in range(0,56):<br/> doc_no = i<br/> with open (“Trump Speechs\Trump Speechs\speech_” + str(doc_no) + “.txt”,’r’) as file:<br/> next(file)<br/> s=file.read().replace(‘\n’,’ ‘)<br/> <br/> #cleaning documents<br/> s = re.sub(‘ ‘, ‘ ‘, s)<br/> s = re.sub(r”won’t”, “will not”, s)<br/> s = re.sub(r”can\’t”, “can not”, s)<br/> s = re.sub(r”n\’t”, “ not”, s)<br/> s = re.sub(r”\’re”, “ are”, s)<br/> s = re.sub(r”\’s”, “ is”, s)<br/> s = re.sub(r”\’d”, “ would”, s)<br/> s = re.sub(r”\’ll”, “ will”, s)<br/> s = re.sub(r”\’t”, “ not”, s)<br/> s = re.sub(r”\’ve”, “ have”, s)<br/> s = re.sub(r”\’m”, “ am”, s)<br/> s = re.sub(r’[0–9]+’, ‘’, s)<br/> s=re.sub(r’[^\w\s]’,’ ‘, s)<br/> key = ‘speech_’ + str(doc_no)<br/> <br/> documents.setdefault(key,[])<br/> documents[key].append(s)<br/> <br/> #removing stopwords and lowercase<br/> s = s.lower()<br/> s = [words if words not in stop_words else ‘’ for words in s.split(‘ ‘)]<br/> doc = []<br/> doc = list(filter(None, s)) <br/> stemmed = []<br/> <br/> #stemming<br/> for i in doc:<br/> stemmed.append(ps.stem(i))<br/> <br/> #creating posting list<br/> for x in stemmed:<br/> key = x<br/> dictionary.setdefault(key, [])<br/> dictionary[key].append(doc_no)<br/> <br/> #removing duplicates<br/> dictionary = {a:list(set(b)) for a, b in dictionary.items()}<br/> <br/> return dictionary,documents</span></pre><p id="ad65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的函数中，每个语音文件都被显式地读取、清理、标记化和词干化。为了制作倒排索引词典，将每个单词作为关键字，关键字的值就是文档id。我们的字典值中有许多重复值，因为一个单词可能在同一文档中出现多次。倒排索引只能用于布尔查询和合取布尔查询。因此，对于短语查询和邻近查询，我们使用位置索引。</p><h1 id="145c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.<strong class="ak">制作位置索引:</strong></h1><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="37b8" class="lk jz hi lg b fi ll lm l ln lo">def positional_index(stop_words):<br/> <br/> dictionary = {}<br/> documents = {}<br/> for i in range(0,56):<br/> doc_no = i<br/> with open (“Trump Speechs\Trump Speechs\speech_” + str(doc_no) + “.txt”,’r’) as file:<br/> s=file.read().replace(‘\n’,’ ‘)[1:]<br/> <br/> #cleaning documents<br/> s = re.sub(‘ ‘, ‘ ‘, s)<br/> s = re.sub(r”won’t”, “will not”, s)<br/> s = re.sub(r”can\’t”, “can not”, s)<br/> s = re.sub(r”n\’t”, “ not”, s)<br/> s = re.sub(r”\’re”, “ are”, s)<br/> s = re.sub(r”\’s”, “ is”, s)<br/> s = re.sub(r”\’d”, “ would”, s)<br/> s = re.sub(r”\’ll”, “ will”, s)<br/> s = re.sub(r”\’t”, “ not”, s)<br/> s = re.sub(r”\’ve”, “ have”, s)<br/> s = re.sub(r”\’m”, “ am”, s)<br/> s=re.sub(r’[^\w\s]’,’ ‘, s)<br/> <br/> key = ‘speech_’ + str(doc_no)<br/> documents.setdefault(key,[])<br/> documents[key].append(s)<br/> <br/> s = s.lower()<br/> s = s.split(‘ ‘)<br/> doc = []<br/> doc = list(filter(None, s)) <br/> temp_dict = {}<br/> stemmed = []<br/> <br/> #stemming<br/> for i in doc:<br/> stemmed.append(ps.stem(i))<br/> <br/> #creating positional index posting lists<br/> a = 0<br/> for x in stemmed:<br/> key = x<br/> temp_dict.setdefault(key, [])<br/> temp_dict[key].append(a)<br/> a += 1<br/> for x in temp_dict:<br/> if dictionary.get(x):<br/> dictionary[x][doc_no] = temp_dict.get(x)<br/> else:<br/> key = x<br/> dictionary.setdefault(key, [])<br/> dictionary[key] = {}<br/> dictionary[x][doc_no] = temp_dict.get(x)<br/> <br/> return dictionary,documents</span></pre><p id="3e51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数几乎类似于倒排索引。在这个函数中，我使用了dict of dict来存储与文档id相对应的单词的位置。在这种情况下，我们不必删除重复项，因为它将被视为该单词在文档中的位置。</p><h1 id="7eb5" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.<strong class="ak">查询处理:</strong></h1><ul class=""><li id="2169" class="lq lr hi is b it kw ix kx jb ls jf lt jj lu jn lv lw lx ly bi translated"><strong class="is hj">布尔查询处理:</strong></li></ul><p id="ddbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">布尔查询属于包含布尔运算符(AND、OR和NOT)的类型。简单布尔查询示例:</p><p id="e418" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">X和Y:表示同时包含X和Y的文档</p><p id="d54c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">X或Y:表示包含X或Y的单据</p><p id="dc23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非X:表示不含X的单据</p><p id="020e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">合取布尔查询示例:</p><p id="a6e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(X和Y)或(Y和Z):表示既包含X和Y又包含Y和Z文档</p><p id="2937" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(X和Y)或不包含Z:表示包含X和Y的文档或不包含Z的文档</p><p id="567e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，用户查询被转换成后缀表达式，以满足简单查询和连接查询。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="aede" class="lk jz hi lg b fi ll lm l ln lo">def postfix(infix_tokens):<br/> <br/> #precendence initialization<br/> precedence = {}<br/> precedence[‘NOT’] = 3<br/> precedence[‘AND’] = 2<br/> precedence[‘OR’] = 1<br/> precedence[‘(‘] = 0<br/> precedence[‘)’] = 0</span><span id="b410" class="lk jz hi lg b fi lp lm l ln lo">output = []<br/> operator_stack = []<br/> <br/> #creating postfix expression<br/> for token in infix_tokens:<br/> if (token == ‘(‘):<br/> operator_stack.append(token)</span><span id="45fe" class="lk jz hi lg b fi lp lm l ln lo">elif (token == ‘)’):<br/> operator = operator_stack.pop()<br/> while operator != ‘(‘:<br/> output.append(operator)<br/> operator = operator_stack.pop()<br/> <br/> elif (token in precedence):<br/> if (operator_stack):<br/> current_operator = operator_stack[-1]<br/> while (operator_stack and precedence[current_operator] &gt; precedence[token]):<br/> output.append(operator_stack.pop())<br/> if (operator_stack):<br/> current_operator = operator_stack[-1]</span><span id="75c9" class="lk jz hi lg b fi lp lm l ln lo">operator_stack.append(token)</span><span id="a21a" class="lk jz hi lg b fi lp lm l ln lo">else:<br/> output.append(token.lower())<br/> <br/> #while staack is not empty appending<br/> while (operator_stack):<br/> output.append(operator_stack.pop())<br/> return output</span></pre><p id="6b6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出被发送到process_query函数以计算后缀表达式。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8b06" class="lk jz hi lg b fi ll lm l ln lo">def process_query(q,dictionary_inverted):</span><span id="6a2b" class="lk jz hi lg b fi lp lm l ln lo">q = q.replace(‘(‘, ‘( ‘)<br/> q = q.replace(‘)’, ‘ )’)<br/> q = q.split(‘ ‘)<br/> query = []</span><span id="7f6b" class="lk jz hi lg b fi lp lm l ln lo">for i in q:<br/> query.append(ps.stem(i))<br/> for i in range(0,len(query)):<br/> if ( query[i]== ‘and’ or query[i]== ‘or’ or query[i]== ‘not’):<br/> query[i] = query[i].upper()<br/> results_stack = []<br/> postfix_queue = postfix(query)</span><span id="a49c" class="lk jz hi lg b fi lp lm l ln lo">#evaluating postfix query expression<br/> for i in postfix_queue:<br/> if ( i!= ‘AND’ and i!= ‘OR’ and i!= ‘NOT’):<br/> i = i.replace(‘(‘, ‘ ‘)<br/> i = i.replace(‘)’, ‘ ‘)<br/> i = i.lower()<br/> i = dictionary_inverted.get(i)<br/> results_stack.append(i)<br/> elif (i==’AND’):<br/> a = results_stack.pop()<br/> b = results_stack.pop()<br/> results_stack.append(AND_op(a,b))<br/> elif (i==’OR’):<br/> a = results_stack.pop()<br/> b = results_stack.pop()<br/> results_stack.append(OR_op(a,b))<br/> elif (i == ‘NOT’):<br/> a = results_stack.pop()<br/> print(a)<br/> results_stack.append(NOT_op(a))<br/> <br/> return results_stack.pop()</span></pre><p id="4dc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与、或与非运算功能如下:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4405" class="lk jz hi lg b fi ll lm l ln lo">#AND two posting lists<br/>def AND_op(word1,word2):<br/> if ((word1) and (word2)):<br/> return set(word1).intersection(word2)<br/> else:<br/> return set()<br/> <br/>#OR two posting lists<br/>def OR_op(word1,word2):<br/> return set(word1).union(word2)<br/> <br/>#NOT two posting lists<br/>def NOT_op(a):<br/>tot_docs = list(range(0,56))<br/>return set(tot_docs).symmetric_difference(a)</span></pre><p id="c346" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经实现了布尔查询处理，我们将转向邻近处理。</p><ul class=""><li id="e7cf" class="lq lr hi is b it iu ix iy jb lz jf ma jj mb jn lv lw lx ly bi translated"><strong class="is hj">邻近查询处理:</strong></li></ul><p id="88b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">X和Y /3或X Y /2类型的查询称为邻近查询。表达式意味着检索分别包含X和Y以及3个单词或2个单词的文档。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="fe5c" class="lk jz hi lg b fi ll lm l ln lo">def proximity_query(q,dictionary_positional):<br/> <br/> q = re.sub(r”AND”, “”, q)<br/> q = re.sub(r” “, “ “, q)<br/> q = q.split(‘ ‘)<br/> query = []<br/> <br/> for i in q:<br/> query.append(ps.stem(i))<br/> <br/> word1 = dictionary_positional.get(query[0])<br/> word2 = dictionary_positional.get(query[1])<br/> anding = set(word1).intersection(word2)<br/> <br/> query[2] = re.sub(r”/”, “”, query[2])<br/> answer = []<br/> skip = int(query[2]) + 1<br/> for i in anding:<br/> pp1 = dictionary_positional.get(query[0])[i]<br/> pp2 = dictionary_positional.get(query[1])[i]<br/> plen1 = len(pp1)<br/> plen2 = len(pp2)<br/> ii = jj = 0 <br/> while ii != plen1:<br/> while jj != plen2:<br/> if (abs(pp1[ii] — pp2[jj]) == skip):<br/> answer.append(i)<br/> elif pp2[jj] &gt; pp1[ii]:<br/> break <br/> jj+=1<br/> ii+=1<br/> answer = list(dict.fromkeys(answer))<br/> return answer</span></pre><p id="cd36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的函数中，首先提取单词和跳转号，并获得两个单词的列表。然后对这两个列表进行and运算，得到包含这两个单词的文档。然后，迭代两个列表的交集，以检查用户查询中提供的两个单词是否分开。</p><h1 id="62c0" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.结果:</h1><p id="bf41" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">当布尔模型部署在本地服务器上时，会获得以下结果。</p><p id="6957" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">登录页面:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/b9111700a91d89d8dcc1a996b753e891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnidathfUdZlQy9d2YxdXg.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated">主页</figcaption></figure><p id="4976" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输入查询时:未运行</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/9b15ed65485bb286576c7f120e7f41a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOPMQ9qZOCLrAP8cbtSWFQ.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated">查询结果:未运行</figcaption></figure><p id="ef60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询输入时间:年后/1</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/2ccb54285efb53b30d692db055313089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFslDp_isQH1d6k2pxrK-g.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated">查询结果:年后/1</figcaption></figure><p id="ab24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询输入时间:过期或(人员和政策)</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/a554afcb15b122542ea693c7c9d50e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuzpJA_jZdLfsB2Nq7yRRw.png"/></div></div><figcaption class="md me et er es mf mg bd b be z dx translated">查询结果:过时或(人员和政策)</figcaption></figure><h1 id="5e90" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">参考文献:</strong></h1><p id="024a" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">[1]:<a class="ae jx" href="https://en.wikipedia.org/wiki/Information_retrieval" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Information_retrieval</a></p><p id="c3d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2]:<a class="ae jx" href="https://en.wikipedia.org/wiki/Boolean_model_of_information_retrieval" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Boolean _ model _ of _ information _ retrieval</a></p><p id="6ba0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其他参考:</p><div class="mk ml ez fb mm mn"><a href="https://nlp.stanford.edu/IR-book/html/htmledition/irbook.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">信息检索导论</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">我的书</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">nlp.stanford.edu</p></div></div></div></a></div><div class="mk ml ez fb mm mn"><a href="https://www.geeksforgeeks.org/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">极客论坛|极客的计算机科学门户</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">极客的计算机科学门户。它包含写得很好，很好的思想和很好的解释计算机科学和…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mw l"><div class="mx l my mz na mw nb io mn"/></div></div></a></div><div class="mk ml ez fb mm mn"><a href="https://stackoverflow.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">堆栈溢出-开发者学习、分享和建立职业生涯的地方</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">我们开发产品，增强开发人员的能力，并为他们提供解决方案，帮助他们提高生产力、促进发展和…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">stackoverflow.com</p></div></div><div class="mw l"><div class="nc l my mz na mw nb io mn"/></div></div></a></div><p id="eec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">完整代码可以在我的</strong> <a class="ae jx" href="https://github.com/mtk12/IR-Boolean-retrieval-model" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> github </strong> </a> <strong class="is hj">资源库找到。</strong></p><p id="8196" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果这篇文章对你有帮助，请点赞并与他人分享。欢迎在下面的评论中写下你的建议！</strong></p><p id="88fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">谢谢！！！</strong></p></div></div>    
</body>
</html>