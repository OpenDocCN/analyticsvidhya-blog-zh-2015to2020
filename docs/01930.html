<html>
<head>
<title>Are you ready for solving the traveling salesman problem?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你准备好解决旅行推销员问题了吗？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/are-you-read-for-solving-the-traveling-salesman-problem-80e3c4ea45fc?source=collection_archive---------0-----------------------#2019-11-22">https://medium.com/analytics-vidhya/are-you-read-for-solving-the-traveling-salesman-problem-80e3c4ea45fc?source=collection_archive---------0-----------------------#2019-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="62ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近在leetcode: 943上遇到一个旅行商问题(TSP)。找到最短的超弦。你可以在这里找到问题。</p><p id="d8ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://leetcode.com/problems/find-the-shortest-superstring" rel="noopener ugc nofollow" target="_blank"> 943。找到最短的超弦</a></p><p id="34a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TSP是一个著名的NP问题。简单解的复杂度是O(n！).DP(动态规划)版本算法(贝尔曼-霍尔德-卡普算法)将具有O(2^n * n的复杂度。通过把复杂度从阶乘降低到指数，如果n的大小比较小，问题是可以解的。</p><p id="0209" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对这个问题感兴趣，正如我对DP问题感兴趣一样。大多数动态规划问题通过避免子问题的重复计算，将时间复杂度从指数降低到多项式。这个问题是DP的一个例子，它可以将时间复杂度从阶乘降低到指数级。</p><p id="cc66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于为什么天真解复杂度为O(n！)和DP一个是O(2^n*n)，从这里有一个超级好看清晰的视频。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="1c68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，根据上面的视频有一个不错的帖子。我喜欢这个视频清晰的解释，我也从下面的帖子中发现这个问题的可视化非常好。</p><div class="jl jm ez fb jn jo"><a rel="noopener follow" target="_blank" href="/basecs/speeding-up-the-traveling-salesman-using-dynamic-programming-b76d7552e8dd"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">用动态规划加速旅行推销员</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">让计算机科学变得困难的很大一部分原因是，在解决问题时，很难知道从哪里开始…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc kd jo"/></div></div></a></div><p id="0923" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果你仔细对比一下讲解视频和leetcode问题，我们会发现在描述TSP问题上有些细微的差别。我们将有两个案例。我将用一个婴儿的例子来说明这些算法的细节。这个婴儿示例包含A、B、C、D四个城市，如图1所示。为了简单起见，我们正在生成一个对称的<em class="ke"> TSP </em>，两个城市之间的距离在每个相反的方向上都是相同的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kf"><img src="../Images/8353b31f2836eb8cd8036c2935a8b06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*WG9lvtclY3lp2r5LNNZyfQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">图一。TSP的一个小例子</figcaption></figure><ol class=""><li id="3788" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">每个城市参观一次，回到第一个参观的城市。ABCDA将是这个婴儿例子的解决方案。</li><li id="e6bf" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">每个城市只参观一次。ADCB将是解决办法。</li></ol><p id="4bca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将根据这两个案例进行逐步分析。</p><p id="d4c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例1:每个城市访问一次，回到第一个访问的城市(ABCDA)</p><p id="7b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤1:为什么朴素解具有O(n！)</p><p id="8516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个完整的搜索方法将给我们(N-1)！可能性。为什么？我们可以通过使用图1来可视化可能的选择。如果我们有n个城市，第一步和最后一步将是其中一个城市，那么所有可能的路径将是其余n-1个城市的排列。所以复杂度会是(n-1)！，复杂度将为O(n！).</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/b3932c0791472491ec2d34ea9386f222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8HLI-FS28VQ3azBp782kA.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">图2:当我们只有ABCD 4个城市可访问时，“案例1每个城市访问一次，回到第一个访问的城市”的所有可能路径。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/79fe7cfacb4ac0ad99bd040115f27db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C52WGJJsA6-GQa2rMCju0A.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">图3:在图2中提供路径开销，并找到最佳路径。</figcaption></figure><p id="3f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果考虑路径成本，最佳路径将是ABCDA或ADCBA。实际上，这两条路径与我们正在分析的对称<em class="ke"> TSP是同一条路径。</em></p><p id="72a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2:能不能加快速度？</p><p id="fae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/7744f656e55746196678c3743daa1f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TiLreaz0lPAjoNwSlzmZw.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">图4:这两条未阻塞路径的前4项都包含ABCD，并以d结束。可以删除开销较大的路径。</figcaption></figure><p id="1821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图4中，我们看到我们可以修剪一些过于昂贵的分支。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/2e497eacc8d155b72aecc459c4057306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCC01F8V4o4C5m_dIMLqHw.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">图5:这里显示了可以修剪的分支。</figcaption></figure><p id="dd25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图5显示了当生成的路径已经包含{A，B，C，D}并且想要扩展路径以连接A时，3个被修剪的分支。从该图中，我们看不到显著的修剪，但是，如果我们引入更多的城市，修剪将大大提高效率。</p><p id="7230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程正是贝尔曼-赫尔德-卡普动态规划算法的关键部分。视频中解释的复杂度是O(n *2^n).它比阶乘快得多。</p><p id="3928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我实现了一个简单的贝尔曼-赫尔德-卡普算法。大意是这样的:<br/>如果我们有A，B，C，D <br/>所有路径包含4个元素并且以D结尾可以写成:<br/> {A，B，C，D}以D结尾<br/>它可以由<br/> {A，B，C}以A + AD <br/>结尾{A，B，C}以B + BD <br/>结尾{A，B，C}以C+ CD <br/>然后就有了下面这个解。我使用(A，B，C) + (A，)，用A编码{A，B，C}结尾</p><p id="a48c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案1简单明了的贝尔曼-赫尔德-卡普算法(844毫秒)</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lf jk l"/></div></figure><p id="bf00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">讨论leetcode的几个解决方案可以用来解决这个TSP问题。</p><p id="7049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案2(Bellman-hold-Karp算法)(运行时间936 ms)它基于DP TSP解决方案。</p><p id="a129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此解决方案的引用:</p><p id="4be5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://leetcode.com/problems/find-the-shortest-superstring/discuss/195077/Clean-python-DP-with-explanations" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/find-the shortest-superstring/discuse/195077/Clean-python-DP-with-explanations</a></p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="1dcf" class="ll lm hi lh b fi ln lo l lp lq">class Solution:<br/>    def shortestSuperstring(self, A: List[str]) -&gt; str:<br/>        ''' TSP: DP '''<br/>        n, N = len(A), 1 &lt;&lt; len(A)<br/>        w = [[0] * n for _ in range(n)]<br/>        for i in range(n):<br/>            for j in range(n):<br/>                for k in range(min(len(A[i]), len(A[j])), 0, -1):<br/>                    if A[j].startswith(A[i][-k:]):<br/>                        w[i][j] = k<br/>                        break<br/>        f = [[None] * n for _ in range(N)]<br/>        for i in range(N):<br/>            for k in (t for t in range(n) if (1 &lt;&lt; t) &amp; i):<br/>                i1 = i ^ (1 &lt;&lt; k)<br/>                f[i][k] = min([f[i1][j] + A[k][w[j][k] :] <br/>                               for j in filter(lambda x: (1 &lt;&lt; x) &amp; i1, range(n))],<br/>                               key=len, default=A[k])                              <br/>        return min(filter(None, f[-1]), key=len)</span></pre><p id="bb29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案2(50毫秒)</p><p id="6588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我仍在研究代码，在我完全理解这一点后会有一些解释。</p><p id="4fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考:</p><p id="b6dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://leetcode.com/problems/find-the-shortest-superstring/discuss/221181/A*-search-python-implementation-64ms-pass" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/find-the shortest-superstring/discuse/221181/A *-search-python-implementation-64 ms-pass</a></p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="8ada" class="ll lm hi lh b fi ln lo l lp lq">from heapq import heappush, heappop</span><span id="8570" class="ll lm hi lh b fi lr lo l lp lq">def dist(v, w, eq):<br/>    if eq:<br/>        return 10000<br/>    else:<br/>        for i in range(1, len(w)):<br/>            if v.endswith(w[:-i]):<br/>                return i<br/>        return len(w)</span><span id="4779" class="ll lm hi lh b fi lr lo l lp lq">def construct_seq(s, d, w):<br/>    t = w[s[0]]<br/>    for i in range(1, len(s)):<br/>        t = t + w[s[i]][-d[s[i-1]][s[i]]:]<br/>    return t</span><span id="3509" class="ll lm hi lh b fi lr lo l lp lq">def heuristic(x, mdj):<br/>    return sum(mdj[i] for i in range(len(x)) if x[i] == 0)</span><span id="ef32" class="ll lm hi lh b fi lr lo l lp lq">def adjacent_nodes(x):<br/>    ret = []<br/>    for i in range(len(x)):<br/>        if x[i] == 0:<br/>            y = list(x)<br/>            y[i] = 1<br/>            ret.append((i, tuple(y)))<br/>    return ret<br/>    <br/>class Solution(object):<br/>    def shortestSuperstring(self, A):<br/>        n = len(A)<br/>        <br/>        # special case<br/>        if n == 1:<br/>            return A[0]<br/>        # assert n &gt; 1<br/>        <br/>        # distance between words<br/>        # dij := the cost in addition to add j after i<br/>        dij = [[dist(A[i], A[j], i == j) for j in range(n)] for i in range(n)]<br/>        <br/>        # minimum cost to add j<br/>        mdj = [min(dij[i][j] for i in range(n)) for j in range(n)]<br/>        <br/>        # A* search<br/>        # init<br/>        q = []          # priority queue with estimated cost<br/>        for i in range(n):<br/>            x = tuple(1 if j == i else 0 for j in range(n))<br/>            g = len(A[i])            # actual cost from start<br/>            h = heuristic(x, mdj)    # lower bound of cost till the goal<br/>            heappush(q, (g + h, g, h, x, [i]))<br/>            <br/>        best_f = None<br/>        best_p = None<br/>        while len(q) &gt; 0:<br/>            # f, g, h, node, path<br/>            f, g, h, x, p = heappop(q)<br/>            <br/>            if best_f is not None and f &gt;= best_f:<br/>                break<br/>                <br/>            for j, y in adjacent_nodes(x):<br/>                gy = g + dij[p[-1]][j]<br/>                py = p + [j]<br/>                <br/>                if sum(y) == n:     # is goal<br/>                    if best_f is None or gy &lt; best_f:<br/>                        best_f = gy<br/>                        best_p = py<br/>                else:<br/>                    hy = heuristic(y, mdj)<br/>                    heappush(q, (gy + hy, gy, hy, y, py))<br/>                    <br/>        return construct_seq(best_p, dij, A)</span></pre><p id="52a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案3(不清楚的方法，但40毫秒)这个代码是从一个最快的提交收集。我不清楚谁是原作者。此外，我不明白的解决方案，但它是超级快速和短暂的。等我完全理解了以后再解释。</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="0c34" class="ll lm hi lh b fi ln lo l lp lq">class Solution:<br/>    def shortestSuperstring(self, words: List[str]) -&gt; str:<br/>        def concat(s, t, mink):<br/>            for k in range(min(len(s), len(t)) - 1, 0, -1):<br/>                if k &lt;= mink: break<br/>                if s[-k:] == t[:k]: return k, s + t[k:]<br/>                if t[-k:] == s[:k]: return k, t + s[k:]<br/>            return 0, s + t<br/>        <br/>        if not words: return ''<br/>        while len(words) &gt; 1:<br/>            sharedsize = a = b = -1<br/>            concatstr = ''<br/>            for j in range(len(words)):<br/>                for i in range(j):<br/>                    k, s = concat(words[i], words[j], sharedsize)<br/>                    if k &gt; sharedsize:<br/>                        sharedsize, concatstr = k, s<br/>                        a, b = i, j<br/>            if sharedsize &gt; 0:<br/>                words[b] = concatstr<br/>                words[a] = words[-1]<br/>            else:<br/>                words[0] += words[-1]<br/>            words.pop()<br/>        return words[0]</span></pre><h1 id="eecf" class="ls lm hi bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">847.访问所有节点的最短路径</h1><div class="jl jm ez fb jn jo"><a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">访问所有节点的最短路径- LeetCode</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">N个节点(标记为0，1，2，...N-1)以图表形式给出。graph.length = N和j！=我…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">leetcode.com</p></div></div><div class="jx l"><div class="mp l jz ka kb jx kc kd jo"/></div></div></a></div><p id="d0f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题类似于TSP，但是它不是TSP，因为我们被允许多次访问一个节点。虽然这不是一个TSP问题，但我们可以使用解决TSP问题的方法来删除不需要的状态。</p><p id="e39a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不修剪(TLE)</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="c365" class="ll lm hi lh b fi ln lo l lp lq">class Solution:<br/>    def shortestPathLength(self, graph: List[List[int]]) -&gt; int:<br/>        if any(len(g)==0 for g in graph):return 0<br/>        N = len(graph)<br/>        def bfs():<br/>            from collections import deque<br/>            Q = deque([(i, 0, {i}) for i in range(N)])<br/>            while Q:<br/>                i, d, seen = Q.popleft()<br/>                if len(seen)==N:return d<br/>                for j in graph[i]:<br/>                    this_seen = seen | {j}<br/>                    Q.append((j, d+1, this_seen))<br/>        return bfs()</span></pre><p id="aa0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带修剪(AC 348 ms)</p><pre class="je jf jg jh fd lg lh li lj aw lk bi"><span id="4e76" class="ll lm hi lh b fi ln lo l lp lq">class Solution:<br/>    def shortestPathLength(self, graph: List[List[int]]) -&gt; int:<br/>        if any(len(g)==0 for g in graph):return 0<br/>        N = len(graph)<br/>        def bfs():<br/>            from collections import deque<br/>            Q = deque([(i, 0, {i}) for i in range(N)])<br/>            pruning = collections.defaultdict(lambda : float('inf'))<br/>            while Q:<br/>                i, d, seen = Q.popleft()<br/>                #pruning[tuple(sorted(seen))+(i,)]=d<br/>                if len(seen)==N:return d<br/>                for j in graph[i]:<br/>                    this_seen = seen | {j}<br/>                    this_key = tuple(sorted(this_seen))+(j,)<br/>                    if pruning[this_key]&gt;d+1:<br/>                        pruning[this_key] = d+1<br/>                        Q.append((j, d+1, this_seen))<br/>        return bfs()</span></pre></div></div>    
</body>
</html>