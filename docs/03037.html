<html>
<head>
<title>Introduction to Dask: A library to play with a large volume of data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dask简介:处理大量数据的库</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-dask-a-library-to-play-with-a-large-volume-of-data-37ed0472d198?source=collection_archive---------14-----------------------#2020-01-13">https://medium.com/analytics-vidhya/introduction-to-dask-a-library-to-play-with-a-large-volume-of-data-37ed0472d198?source=collection_archive---------14-----------------------#2020-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9cb68f583cec4d1b873168ad34347999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSw6_dChDn95nAYm0FKX5A.jpeg"/></div></div></figure><p id="343f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> Dask是Python中一个灵活的并行计算库。它在大于内存的数据集上提供多核执行。</em></p><h1 id="d48c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">概述</strong></h1><p id="5e00" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在这篇文章中，我将解释dask如何在你的本地机器上计算一个非常大的数据集。Dask首先将程序分成许多中等大小的任务或计算单元。这些任务被表示为图中的节点，节点之间的边表示该任务依赖于另一个任务产生的数据。Dask然后调用任务调度程序以利用并行性的方式执行该图，允许多个独立的任务可以同时运行。</p><p id="e342" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我使用了<a class="ae ks" href="https://data.cityofnewyork.us/Transportation/2017-Yellow-Taxi-Trip-Data/biws-g3hs" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> 2017黄色出租车出行数据</em> </a> <em class="jo"> </em>进行分析，其大小为9.8GB，具有113，496，874行和17列。让我们看看如何使用dask处理如此庞大的数据</p><h1 id="d643" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">创建调度程序</strong></h1><p id="2a95" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">默认的<a class="ae ks" href="https://docs.dask.org/en/latest/scheduling.html" rel="noopener ugc nofollow" target="_blank"> Dask调度器</a>通过使用线程或进程在单个机器上提供并行性。这是Dask使用的默认选择，因为它不需要设置。Dask提供了四种调度程序:</p><ol class=""><li id="0da7" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><strong class="is hj">线程</strong>:在同一进程中使用多个线程。这是<code class="du lc ld le lf b">dask.array</code>、<code class="du lc ld le lf b">dask.dataframe</code>和<code class="du lc ld le lf b">dask.delayed</code>的默认调度程序</li><li id="f3c8" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">进程</strong>:将数据发送给不同的进程进行处理。这是<code class="du lc ld le lf b">dask.bag</code>的默认调度程序，有时对<code class="du lc ld le lf b">dask.dataframe</code>很有用</li><li id="ef6a" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">单线程:</strong>在单线程中执行计算。该选项不提供并行性，但在调试或分析时很有用。</li><li id="3620" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">分布式:</strong>一个<strong class="is hj"> </strong>分布式调度器，用于在同一台机器或多台机器的多个工作机上执行图形。它还提供了一个诊断仪表板，可以提供关于性能和进度的宝贵见解</li></ol><p id="9392" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在本地机器上使用了分布式调度程序进行分析。</p><blockquote class="ll lm ln"><p id="d140" class="iq ir jo is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">从dask.distributed导入客户端<br/> client = Client()</p></blockquote><p id="1bc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导航到<a class="ae ks" href="http://localhost:8787/status" rel="noopener ugc nofollow" target="_blank">http://localhost:8787/status</a>查看诊断仪表板</p><h1 id="831c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">数据分析</strong></h1><p id="b797" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先，使用dask dataframe加载csv数据</p><blockquote class="ll lm ln"><p id="bb8d" class="iq ir jo is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">导入dask.dataframe为DD<br/>data = DD . read _ CSV(" 2017 _ Yellow _ Taxi _ Trip _ data . CSV ")<br/>data . head()</p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/7c0eb0443571075db8366c05b5a1becb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRirQX3mmEDqXnjGPcVjMA.jpeg"/></div></div></figure><p id="bb33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们尝试使用这个大型数据集来回答几个问题</p><ol class=""><li id="4523" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><strong class="is hj">哪些地区的接送人数最多？</strong></li></ol><p id="371e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了找出最多的接送位置，我根据接送位置id和接送位置id对数据集进行了分组，然后统计了这些id在数据集中的出现次数。Dask的<code class="du lc ld le lf b">.compute()</code>方法用于将dask集合转换为具体值。</p><blockquote class="ll lm ln"><p id="eb6b" class="iq ir jo is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">pick up _ loc = data . group by(' PULocationID ')[' PULocationID ']。计数()。compute() <br/>拾音= pd。data frame({ ' location id ':pick up _ loc . index，' pick up _ count ':pick up _ loc . values })<br/>pick up . sort _ values([' pick up _ count ']，ascending=False，in place = True)<br/>pick up . head(10)</p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/d67b415a28242c0663b712e670f876ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*xy2KvWlTVKuX9w7WwUIqWg.jpeg"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">热门提货地点及其数量</figcaption></figure><p id="1531" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以使用列名<code class="du lc ld le lf b">DOLocationID</code>对卸货地点重复相同的代码，以获得最上面的卸货地点</p><p id="f1f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。绘制出租车接站数随时间的分布图</strong></p><p id="97bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用<code class="du lc ld le lf b">tpep_pickup_datetime</code>列来绘制出租车载客率随时间的分布图。我已经根据该列对数据集进行了分组，并计算了groupby对象中每次的计数。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/db5a69b39615a8e48af1c8a0ecd730ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pu9js-QxuZ_C-sbh-PaY4g.jpeg"/></div></div></figure><p id="c2eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从图中，我们可以看到最大接站发生在下午6:50左右，最小接站发生在上午5:05左右。</p><p id="e8f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。哪种支付方式最常用于出租车</strong></p><p id="9b67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用列<code class="du lc ld le lf b">payment_type</code>来获得所使用的每种支付方式的计数。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/cb5cd99316731d418df62eef48e0b053.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*vtEJvs6uOzsIj64RKo8vyg.jpeg"/></div></figure><p id="be35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从柱状图中，我们可以看到信用卡是最常见的支付方式。</p><h1 id="0400" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">统计数据</h1><p id="1907" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们看看dask在如此大的数据集上计算groupby操作需要多少时间</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/406bfd196a2faa472959152a79ba9c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKI3u4xnjGk1wQehn1zaAQ.jpeg"/></div></div></figure><p id="3199" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算groupby和aggregation方法仅用了4分32秒。让我们来看看为什么在如此庞大的数据集上计算所需的时间要少得多。我通过访问<a class="ae ks" href="http://localhost:8787/status" rel="noopener ugc nofollow" target="_blank">http://localhost:8787/status</a>截取了诊断仪表板的截图(如下所示)。我们可以看到操作是在工人之间进行的。所以操作是并行发生的。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/27ee4f736ab1994ecf181eb7d7bca1fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhC9023bbdi50MSktIRrDQ.jpeg"/></div></div></figure><p id="76ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">代码链接:</strong><a class="ae ks" href="https://github.com/pradeep1920/Data-Analysis-through-Dask" rel="noopener ugc nofollow" target="_blank">https://github.com/pradeep1920/Data-Analysis-through-Dask</a></p><h1 id="a84f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">资源/进一步阅读</h1><ol class=""><li id="397c" class="kt ku hi is b it kn ix ko jb mf jf mg jj mh jn ky kz la lb bi translated"><a class="ae ks" href="https://docs.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank">https://docs.dask.org/en/latest/</a></li><li id="6a06" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><a class="ae ks" href="https://data.cityofnewyork.us/Transportation/2017-Yellow-Taxi-Trip-Data/biws-g3hs" rel="noopener ugc nofollow" target="_blank">https://Data . city of new York . us/Transportation/2017-Yellow-Taxi-Trip-Data/biws-g3hs</a></li><li id="54a6" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><a class="ae ks" href="https://towardsdatascience.com/speeding-up-your-algorithms-part-4-dask-7c6ed79994ef" rel="noopener" target="_blank">https://towards data science . com/speeding-up-your-algorithms-part-4-dask-7c6ed 79994 ef</a></li><li id="cda3" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">https://chih-ling-hsu.github.io/2018/05/14/NYC<a class="ae ks" href="https://chih-ling-hsu.github.io/2018/05/14/NYC" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>