<html>
<head>
<title>Bulk RDBMS Upserts with Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大容量 RDBMS 通过 Spring 进行升级</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bulk-rdbms-upserts-with-spring-506edc9cea19?source=collection_archive---------2-----------------------#2020-08-28">https://medium.com/analytics-vidhya/bulk-rdbms-upserts-with-spring-506edc9cea19?source=collection_archive---------2-----------------------#2020-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/188e54a69d2943052f459671005b40e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTwZq7ceSHClNuAconBNig.jpeg"/></div></div></figure><p id="4134" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Upsert 在数据库中是一个相当常见的术语，意思是如果记录存在，则<strong class="is hj"> <em class="jo"> Up </em> </strong> date，或者在<strong class="is hj"> <em class="jo">中插入</em> </strong>新记录。在带有新信息的简单对象保存请求的情况下，Upserts 更有意义。</p><h1 id="e83b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么散装？</h1><p id="bc77" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果我们谈论任何<strong class="is hj"> <em class="jo">数据同步</em> </strong>、<strong class="is hj"> <em class="jo">数据迁移</em> </strong>或<strong class="is hj"> <em class="jo">批量数据更新作业</em> </strong>，我们必然会有一个批量更新场景来更新我们在数据库中的所有内容并插入所有新行。</p><h1 id="5e58" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决方法</h1><p id="99b2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将讨论 Spring Boot 环境中的解决方案以及我们从中得出的结论。</p><p id="3e9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于测试，我将使用 MS SQL Server 作为数据库，并且仅限于它的功能，但是概念是相当通用的。</p><h2 id="855b" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">使用 Spring JPA 的#1 标准“saveAll()”解决方案</h2><p id="14d2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">假设我们有一个带有复合唯一键/约束的<code class="du lg lh li lj b">price</code>表，具有 like with 结构:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/8828b277a5c8b68f28214d3a2ae9674d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAhF3sDKiEo8tZqZ_5VkDA.png"/></div></div></figure><p id="bd0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们实体的复合主键和实体类看起来像这样:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/2f041bf830f51d5334f2222bf6ae635f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEx6e5V_4Hy9Dq7lAtGR9Q.png"/></div></div></figure><p id="8710" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们正在消耗一个记录批次流来进行追加插入。为了模拟这一点，我们有一个供应商来生成大小为 1000 的随机<code class="du lg lh li lj b">Price1</code>对象批次。摄入代码:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/2aabc931efefeb6f06a8244c841518d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4lDrZepN3aEoA2JOh1CFA.png"/></div></div></figure><p id="66a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看结果:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/55ab9588578510e532380a287a7fff69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TM0vPLHqxsFiiCkwekmufA.png"/></div></div></figure><p id="5eed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，仔细观察一下，随着表被填满，保存每一批所花费的时间都在增加！这是什么？</p><p id="1d6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">罪魁祸首是<code class="du lg lh li lj b">SimpleJPARepository</code>类的<code class="du lg lh li lj b">.save()</code>方法:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/448e950d5c993fce6612138bd8502dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wa-CB925OwTJtnbpPxQAaw.png"/></div></div></figure><p id="eb25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为存储执行插入和更新操作，所以它必须检查实体是否是“新的”。为此，它必须检查持久性上下文或查询数据库，随着表的填满，这将变得很复杂。</p><h2 id="5362" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">#2 批量保存优化</h2><p id="239e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在以前的方法中，我们的瓶颈是从数据库中连续读取主键组合，以检查是否执行<code class="du lg lh li lj b">.persist()</code> / insert 或<code class="du lg lh li lj b">.merge()</code> / update。</p><p id="3f66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了避免对表<code class="du lg lh li lj b">.isNew()</code>的额外查询，我们可以有另一个独立于业务逻辑的自动生成的唯一字段(行)。因此，每个新对象都将有一个唯一的 id，并且总是为它们执行<code class="du lg lh li lj b">.persist()</code>。</p><p id="e478" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在一个全新的表上进行修改(保持业务列不变)，增加一个自动递增的“标识”列:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/5526179e8bcc4ec619fea92a84979c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xW-IXit0NUpStjsRbC56Bw.png"/></div></div></figure><p id="c6e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们的实体:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/2ef03fd9e0b90587c3c3e0774ee7f6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-_LZt_TYUkivGn5ViKKBw.png"/></div></div></figure><p id="f329" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试类似的摄取代码将产生如下结果:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/bc73c34a6d9c2aa217d8049a44ee1b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WtKO4AMfIi9nK0Olh-HtA.png"/></div></div></figure><p id="d2ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">万岁，恒定的时间和更快的插入！但是等等，</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/11aa8dd3b6f9bbe616040305565121b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bDAsDu9qJhecCz0NLcyMw.png"/></div></div></figure><p id="1103" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在有带有<code class="du lg lh li lj b">upc, store_id</code>组合的重复行</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/c1827a265da544be003a2b8b4dfac4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjW5H6mqO8anN95d8I7Jfw.png"/></div></div></figure><p id="1cd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是可以理解的，因为我们没有更新。</p><h2 id="52f6" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">#3 普通插页然后合并</h2><p id="d87b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">以上两个实验鼓励我们保持插入模型，以便更快地插入，并在以后以某种方式合并(进行更新)。</p><p id="a9d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，我们可以有一个“stage”表，它有一个惟一的自动生成的插入 id，与我们的目标主表分开。和一个 pos-摄取作业，用于在消除重复后合并记录。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/e27d5f38303229399903c2ec0b0f2cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnq1-uR0W5hDaNEjlvyxlw.png"/></div></div></figure><p id="fa82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">普通插入可以像上面那样进行，我们现在将尝试编写一个“合并”步骤。由于以下原因，该步骤很可能是数据库存储过程:</p><ol class=""><li id="693b" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">以避免移动数据，并在数据驻留的地方处理批量数据。</li><li id="23ef" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">数据库特定的优化是内置的。</li></ol><p id="9a33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个简单的 MS SQL 合并存储过程实现的例子，类似的合并查询特性出现在大多数主流数据库中。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/62404332d0112a4efe5db43619dcc8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qA9C1Oo2T4pHOqPS78iaoA.png"/></div></div></figure><p id="770a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行这个不到一秒钟！</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/e16edda7afdcabbc6c74e037eed6e2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*Ck-xzwu6sKaeKfFGkrPk_A.png"/></div></figure><p id="1ddf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">重要提示:</strong>上面的存储过程实现是一种非常幼稚的方法，仅仅是为了演示并忽略了生产环境中需要注意的许多方面，比如:</p><ul class=""><li id="27e9" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mn md me mf bi translated">由于 merge 语句中的数据量巨大，导致事务日志大小被过度利用，这里可以实现 id 范围为 的<strong class="is hj"> <em class="jo">批量合并。</em></strong></li><li id="48c1" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mn md me mf bi translated">监控和记录程序故障，可以使用基于 TRY-CATCH 的程序，在<strong class="is hj"> <em class="jo">程序-审计记录表</em> </strong>中记录故障。</li><li id="ebe2" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mn md me mf bi translated">成功合并的批处理范围删除，而不是截断阶段表。</li></ul><h2 id="a308" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">#Extra:进一步改进批量插入</h2><p id="8809" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果我们尝试记录 hibernate 为我们的<code class="du lg lh li lj b">.saveAll()</code>操作生成的 SQL 语句，我们将得到类似这样的结果:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/300e6b160f371f6d12a3ee7b66152920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4Uor_n-ssZOd5Knzv7WYQ.png"/></div></div></figure><p id="0e3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们使用单个 insert 语句来插入值，每个语句都通过网络传输。</p><p id="639c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里可以做一些改进:</p><ol class=""><li id="e65e" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">批处理查询并通过网络调用数据库。</li><li id="a5e3" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">将单个查询重写为单个多行查询的形式。</li></ol><p id="99c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们可以利用 hibernate 的属性:</p><pre class="ll lm ln lo fd mp lj mq mr aw ms bi"><span id="d54f" class="ks jq hi lj b fi mt mu l mv mw">spring.jpa.properties.hibernate.jdbc.batch_size=1000</span><span id="8f52" class="ks jq hi lj b fi mx mu l mv mw">spring.jpa.properties.hibernate.order_inserts=true</span></pre><p id="d064" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其次，在大多数主流数据库解决方案(Postgres、MySQL、Oracle)中都有批量(多行)插入查询选项。语法如下:</p><pre class="ll lm ln lo fd mp lj mq mr aw ms bi"><span id="829d" class="ks jq hi lj b fi mt mu l mv mw">insert into myschema.my_table (col1, col2, col3) <br/>values<br/>(val11, val12, val13),<br/>(val21, val22, val23),<br/>....<br/>(valn1, valn2, valn3);</span></pre><p id="0a03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而 Postgres 和 MySQL 确实借助 JDBC 标志支持这个特性:<strong class="is hj"><em class="jo">reWriteBatchedInserts = true</em></strong></p><p id="82da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但遗憾的是，根据<a class="ae my" href="https://docs.microsoft.com/en-us/sql/connect/jdbc/use-bulk-copy-api-batch-insert-operation?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">这个资源</a>，ms-sql JDBC 驱动不支持查询的多行重写。因此，如果我们想要这样做，我们必须手动编写插入查询。</p><p id="b1c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">手动创建插入查询可能如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/4433ab65d9eb3480a4202df6e7323d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KniRb0UL9QZV2swv1TG9mA.png"/></div></div></figure><p id="7dc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">摄取代码将使用<code class="du lg lh li lj b">entityManager.createNativeQuery()</code>方法:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/9178b395b8bace892017a6e604792d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uipYQIloPkK2kcXtPUebQg.png"/></div></div></figure><p id="e21c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来测试一下:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/f2027803687f45b708930a2d60f34e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wW3Tp9XjkOPjdrSYJDvmw.png"/></div></div></figure><p id="1116" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哇！！那些 1000 条记录的批次用时不到一秒，现在让我们看看毫秒:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/bb2d3c7994e2bb9a88fc4bef4ac76bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RugMAxqQfFcdvlImRaCtWw.png"/></div></div></figure><h1 id="2ce0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="8457" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们可以从上面的实验中有把握地推断出:</p><ol class=""><li id="9e13" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">在关系数据库中实现批量插入非常复杂。</li><li id="41ad" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">Spring JPA 和 Hibernate 提供的开箱即用的保存方法不能适应巨大的负载。</li><li id="cc5e" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">(从业务列/字段)分离的独立主键将有助于提高插入的插入性能，但最终会插入重复的记录。</li><li id="0137" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">将仅插入表和读取(实际)表分开可以提高接收性能。</li><li id="d6b2" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">可以使用后插入、合并策略来消除插入记录的重复。存储过程在这种情况下工作得很好。</li><li id="47d1" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">原生 SQL 查询将提供最高性能的结果，在性能至关重要的情况下，使用尽可能接近数据库的解决方案。</li></ol><h2 id="52f8" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">测试环境:</h2><ul class=""><li id="5780" class="lx ly hi is b it kn ix ko jb nd jf ne jj nf jn mn md me mf bi translated">Macbook Pro 2016 型号 15 英寸，16 GB 内存。</li><li id="16dc" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mn md me mf bi translated">应用程序使用 Java 1.8 和 Spring Boot 2.3.3。</li><li id="2767" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mn md me mf bi translated">Docker 容器中的 MS SQL server 2017 数据库。</li></ul><p id="b235" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读:)</p></div></div>    
</body>
</html>