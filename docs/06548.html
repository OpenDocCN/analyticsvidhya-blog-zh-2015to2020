<html>
<head>
<title>Learning Pandas.Series(Part-6)(.iloc explored |.iloc vs .loc)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习熊猫。系列(第六部分)。iloc探索了|。iloc与loc)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/learning-pandas-part-6-series-iloc-explored-iloc-vs-loc-8204825b3a42?source=collection_archive---------33-----------------------#2020-05-25">https://medium.com/analytics-vidhya/learning-pandas-part-6-series-iloc-explored-iloc-vs-loc-8204825b3a42?source=collection_archive---------33-----------------------#2020-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="0a6c" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在学习熊猫的第6部分中，我们将在<code class="du jh ji jj jk b"><strong class="il hj">Pandas.Series</strong></code>中探索用于索引和切片的<code class="du jh ji jj jk b"><strong class="il hj">iloc</strong></code>索引器。如果你直接跳到这里，你可以查看<code class="du jh ji jj jk b"><a class="ae jl" rel="noopener" href="/@milankmr/learning-pandas-part-4-series-why-we-need-separate-indexers-loc-iloc-c081047f3a79"><strong class="il hj">Part-4</strong></a></code>来了解为什么我们需要索引器和<code class="du jh ji jj jk b"><a class="ae jl" rel="noopener" href="/@milankmr/learning-pandas-part-5-series-loc-explored-for-indexing-and-slicing-6447c5d7298c"><strong class="il hj">Part-5</strong></a></code>用于<code class="du jh ji jj jk b">.<strong class="il hj">loc</strong></code>索引器:</p></blockquote><p id="fa2e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">一边学习。iloc，我们也会<code class="du jh ji jj jk b">compare the same with .loc along the way</code>，所以，不如过一遍系列的<code class="du jh ji jj jk b"><a class="ae jl" rel="noopener" href="/@milankmr/learning-pandas-part-5-series-loc-explored-for-indexing-and-slicing-6447c5d7298c"><strong class="il hj">Part-5</strong></a></code>。</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jp"><img src="../Images/30ad96259ef2ab044fbf2ec21fa8ba4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7DGUfMP1BDlI0iYY"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">马库斯·斯皮斯克在<a class="ae jl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="if ig ih"><p id="e673" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj"><em class="hi">.iloc</em></strong></code> <strong class="il hj"> <em class="hi">属性是指</em> </strong> <code class="du jh ji jj jk b"><strong class="il hj"><em class="hi">implicit position indexes</em></strong></code> <strong class="il hj"> <em class="hi">进行索引和切片，意思是基于数据元素的位置而不是索引标签。</em>T25】</strong></p></blockquote><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="d6d4" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd</span><span id="d651" class="kj kk hi jk b fi kp km l kn ko">series1 = pd.Series([10,12,19,44,15,60],<br/>                    index=[3,4,2,1,5,6],<br/>                    name='series_name1')</span><span id="f06c" class="kj kk hi jk b fi kp km l kn ko">print("iloc works on position of element:",series1.iloc[4])<br/>print("loc works on index label:",series1.loc[4])</span><span id="c6cb" class="kj kk hi jk b fi kp km l kn ko">Output:<br/><strong class="jk hj">iloc works on position of element: 15</strong> <br/><strong class="jk hj">loc works on index label: 12</strong></span></pre><blockquote class="if ig ih"><p id="5b11" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj">series1.iloc[4]</strong></code>，4为<code class="du jh ji jj jk b">position of the element</code>，位置从0开始，到len-1结束，与数组相同。</p><p id="a614" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj">series1.loc[4]</strong></code>，4是系列的<code class="du jh ji jj jk b">index label </code>。</p></blockquote><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kq"><img src="../Images/fa99f5e1000697f638a1851a70486e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtU5T4jO1FbrZCQIyEpltw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">iloc系列处理元素的位置</figcaption></figure><blockquote class="if ig ih"><p id="00bf" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">如果我们试图访问大于len-1的位置/索引，我们将得到</em> IndexError:单位置索引器越界</strong></p></blockquote><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="89e1" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=[3,4,2,1,5,6],<br/>          name='series_name1')</span><span id="f3f0" class="kj kk hi jk b fi kp km l kn ko">series1.iloc[6]</span><span id="11c0" class="kj kk hi jk b fi kp km l kn ko">Output:<br/><strong class="jk hj">IndexError: single positional indexer is out-of-bounds</strong></span></pre><p id="7a56" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">上例中有<code class="du jh ji jj jk b">total 6 elements and implicit position index exist from 0 to 5</code>。我们试图访问不存在的索引6，因此出现索引错误(越界)。</p><p id="f238" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi kr translated"><span class="l ks kt ku bm kv kw kx ky kz di"> Q </span>问题<strong class="il hj"> </strong> :-在哪个场景中<code class="du jh ji jj jk b"><strong class="il hj">output of loc and iloc will be same ?</strong></code>它是非常直的，只要在滚动答案之前思考一下。</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es la"><img src="../Images/f856cd0e96a9a176e78fb68c0d3f5ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3NkSfXkel3Aoff0T"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">尼基塔·卡恰诺夫斯基<a class="ae jl" href="https://unsplash.com/@nkachanovskyyy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae jl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4957" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi kr translated">答:是的，你说得对！！如果我们不提供显式索引，而用两者创建一个系列输出。loc和。系列的iloc将是相同的<strong class="il hj">，因为隐式索引总是从0到len-1出现。</strong></p><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="c124" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          name='series_name1')</span><span id="7f6e" class="kj kk hi jk b fi kp km l kn ko">print("Output with iloc:",series1.iloc[3])<br/>print("Output with loc:",series1.loc[3])</span><span id="157d" class="kj kk hi jk b fi kp km l kn ko"><strong class="jk hj">Output with iloc</strong>: 44 <br/><strong class="jk hj">Output with loc</strong>: 44</span></pre><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lb"><img src="../Images/04c1d2142f0dc7843ffa244b9f565b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8N4xbG3AulqFg6S1pOriw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">如果未定义显式索引，loc和iloc会为一个系列生成相同的输出</figcaption></figure><blockquote class="if ig ih"><p id="a038" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj"><em class="hi">Fancy Indexing with .iloc</em></strong></code></p></blockquote><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="cdd7" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=[3,4,2,1,5,6],<br/>          name='series_name1')</span><span id="f555" class="kj kk hi jk b fi kp km l kn ko"><strong class="jk hj"><em class="ik">series1.iloc[[1,4,2]]</em></strong></span><span id="1d19" class="kj kk hi jk b fi kp km l kn ko">1    12 <br/>4    15 <br/>2    19 <br/>Name: series_name1, dtype: int64</span></pre><p id="dc8b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj"><em class="ik">Note:- Keep in mind that with iloc 1,4 and 2 are position indexes not label indexes</em></strong></code></p><p id="707a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi kr translated"><span class="l ks kt ku bm kv kw kx ky kz di"> B </span>使用布尔数组作为iloc系列的索引器:-我们可以使用布尔数组作为索引器，将选择数组中值为真的索引。</p><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="0718" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=[3,4,2,1,5,6],<br/>          name='series_name1')</span><span id="581d" class="kj kk hi jk b fi kp km l kn ko">print("======Output With iloc=======")<br/>print(series1.iloc[[True,False,True,False,True,False]])</span><span id="2b1f" class="kj kk hi jk b fi kp km l kn ko">print("======Output With loc========")<br/>print(series1.loc[[True,False,True,False,True,False]])</span><span id="1e2f" class="kj kk hi jk b fi kp km l kn ko">======<strong class="jk hj">Output With iloc</strong>=======<br/><strong class="jk hj">3    10 <br/>2    19 <br/>5    15</strong> <br/>Name: series_name1, dtype: int64</span><span id="c5ae" class="kj kk hi jk b fi kp km l kn ko">======<strong class="jk hj">Output With loc</strong>========<br/><strong class="jk hj">3    10 <br/>2    19 <br/>5    15</strong> <br/>Name: series_name1, dtype: int64</span></pre><p id="e0af" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">因此，它与的相同。作为索引器的布尔数组的loc属性，你猜对了:<code class="du jh ji jj jk b"><strong class="il hj">output of both .loc and .iloc with boolean array will be same .</strong></code></p><blockquote class="if ig ih"><p id="c51c" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">这个</strong>是带<code class="du jh ji jj jk b"><strong class="il hj">.iloc</strong></code>属性的系列索引的开端，让我们开始了解<code class="du jh ji jj jk b"><strong class="il hj">slicing using .iloc attribute</strong></code></p></blockquote></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="ce53" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">→ <strong class="il hj">切片</strong> :-切片是一种机制，我们可以从不同的数据结构(如序列、数据帧等)中提取基于范围的子集。</p><blockquote class="if ig ih"><p id="f2a8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi"> S </em> <strong class="il hj"> <em class="hi">李慈同。iloc属性是指序列中的</em> </strong> <code class="du jh ji jj jk b"><strong class="il hj"><em class="hi">implicit position indexes</em></strong></code> <strong class="il hj"> <em class="hi">，而不是标记的指标:</em> </strong></p></blockquote><p id="a755" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated"><strong class="il hj">切片格式→</strong>[开始]:[结束][:步长] →开始、结束和步长为整数，方括号表示可选值。</p><p id="785c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated"><strong class="il hj">使用时有两个主要区别。iloc与相比。位置:</strong></p><ol class=""><li id="d734" class="lj lk hi il b im in iq ir jm ll jn lm jo ln jg lo lp lq lr bi translated">。iloc使用隐式位置索引，其中as。loc使用显式标签索引。</li><li id="a128" class="lj lk hi il b im ls iq lt jm lu jn lv jo lw jg lo lp lq lr bi translated">另一个主要区别是在<code class="du jh ji jj jk b"><strong class="il hj">.iloc [end] is exclusive</strong></code>而<code class="du jh ji jj jk b"><strong class="il hj">[end] is inclusive in case of .loc</strong></code>正如我们在上一篇<a class="ae jl" rel="noopener" href="/@milankmr/learning-pandas-part-5-series-loc-explored-for-indexing-and-slicing-6447c5d7298c"> <strong class="il hj">第5部分</strong> </a>中讨论的</li></ol><p id="9e5c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">让我们看看下面的例子:</p><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="7bb3" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=['0','1','2','3','4','5'],<br/>          name='series_name1')</span><span id="f564" class="kj kk hi jk b fi kp km l kn ko">print("=== .iloc refers to implicit position indexes and End is Exclusive while slicing with iloc ===")<br/>print(series1.iloc[0:2])<br/>print("\n")<br/>print("=== .loc refers to explicit labeled indexes and  End is Inclusive while slicing with iloc ===")<br/>print(series1.loc['0':'2'])</span></pre><p id="e2c9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">输出:-因此，如上面的代码所示，对于。我们从位置<code class="du jh ji jj jk b"><strong class="il hj">index 0 to 1 because [end] →2 is exclusive for .iloc</strong></code>出发，前往。loc我们从<code class="du jh ji jj jk b"><strong class="il hj">‘0’ to ‘2’ becasue [end] →’2' is inclusive for .loc</strong></code>移动到<strong class="il hj">。</strong></p><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="ad4a" class="kj kk hi jk b fi kl km l kn ko">=== .iloc refers to implicit position indexes and End is Exclusive while slicing with iloc === <br/>0    10 <br/>1    12 <br/>Name: series_name1, dtype: int64   </span><span id="d368" class="kj kk hi jk b fi kp km l kn ko">=== .loc refers to explicit labeled indexes and  End is Inclusive while slicing with iloc === <br/>0    10 <br/>1    12 <br/>2    19 <br/>Name: series_name1, dtype: int64</span></pre><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lx"><img src="../Images/ced4ba12a3dc5e4ed112deb7a0b15802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NC4Dd2EHkKMspMpbS4SPg.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">[end]包含。锁定并独占。iloc</figcaption></figure><p id="7098" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi kr translated"><span class="l ks kt ku bm kv kw kx ky kz di"> O </span></p><p id="4769" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj">If we don’t provide any value for start , it start with the first index</strong></code>和</p><p id="940d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated"><code class="du jh ji jj jk b"><strong class="il hj">if we don’t provide end , it will consider last index as end</strong></code>。</p><pre class="jq jr js jt fd kf jk kg kh aw ki bi"><span id="7efc" class="kj kk hi jk b fi kl km l kn ko">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=['a','c','d','e','b','f'],<br/>          name='series_name1')</span><span id="b104" class="kj kk hi jk b fi kp km l kn ko">print(series1.iloc[:4]) <strong class="jk hj">#will stop at index 3 coz 4 is exclusive</strong><br/>print(series1.iloc[3:]) <strong class="jk hj">#will start from index 3 coz 3 is inclusive</strong></span><span id="ff83" class="kj kk hi jk b fi kp km l kn ko">Output:<br/><strong class="jk hj">a    10 <br/>c    12 <br/>d    19 <br/>e    44</strong> <br/>Name: series_name1, dtype: int64 </span><span id="9ea4" class="kj kk hi jk b fi kp km l kn ko"><strong class="jk hj">e    44 <br/>b    15 <br/>f    60 </strong><br/>Name: series_name1, dtype: int64</span></pre><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ly"><img src="../Images/1418bd3c9adb4d4ec0eeba5a4c33aecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Z8dfkWnq5SRumxfPI1qvw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">切片时的默认开始和结束索引。iloc</figcaption></figure><p id="d51f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">所以这是一个开端。在本系列的下一部分，我们将探讨更多的系列属性，并将涵盖一些重要的系列方法！！</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="e450" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jm iv iw ix jn iz ja jb jo jd je jf jg hb bi translated">希望你喜欢这篇文章，今天学到了一些新东西。不断探索，不断学习！！！</p></div></div>    
</body>
</html>