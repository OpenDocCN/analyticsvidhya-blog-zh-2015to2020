<html>
<head>
<title>“Perceptron training algorithm” easy Python implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“感知器训练算法”简单的Python实现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/perceptron-training-algorithm-easy-python-implementation-e96192a709b1?source=collection_archive---------23-----------------------#2020-03-26">https://medium.com/analytics-vidhya/perceptron-training-algorithm-easy-python-implementation-e96192a709b1?source=collection_archive---------23-----------------------#2020-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="a8d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我给大家分享一个叫“感知器”的基础训练算法的代码，逐行讲解。</p><p id="781d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码如下:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="46b8" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">class</strong> <strong class="jp hj">Perceptron</strong>:<br/>    <strong class="jp hj">def</strong> __init__(self, X):<br/>        self.weights = np.zeros(shape=len(X[0])+1)<br/>    <br/>    <strong class="jp hj">def</strong> fit(self, X, y, iters=10):</span><span id="1689" class="jt ju hi jp b fi jz jw l jx jy">        <strong class="jp hj">while</strong> iters&gt;0:<br/>            <strong class="jp hj">for</strong> i, x <strong class="jp hj">in</strong> enumerate(X):<br/>                <strong class="jp hj">if</strong> self.predict(x, self.weights)!=y[i]:<br/>                    x = np.insert(x, 0, 1)<br/>                    self.weights = self.weights + y[i]*x<br/>            iters -= 1<br/>        <strong class="jp hj">return</strong> self.weights<br/>        <br/>    <strong class="jp hj">def</strong> predict(self, x, w):<br/>        <strong class="jp hj">return</strong> np.sign(np.dot(np.transpose(w[1:]),x) + w[0])</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="ae26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们必须定义一个名为<strong class="io hj">感知器</strong>的类，并对其进行必要的初始化。它需要一些预先随机初始化的权重(在我的例子中它们都是0)。<strong class="io hj"> X </strong>是一个训练模型，根据这个模型我们将向量<strong class="io hj">的形状自权重</strong>设置为<strong class="io hj"> X +1 </strong>的特征个数:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="1a64" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">class</strong> <strong class="jp hj">Perceptron</strong>:<br/>    <strong class="jp hj">def</strong> __init__(self, X):<br/>        self.weights = np.zeros(shape=len(X[0])+1)</span></pre><p id="7e79" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们实现“<strong class="io hj">拟合</strong>函数。它包含<strong class="io hj"> while </strong>循环，也可以使用错误定义来实现。您可以设置自己的计数器，让循环迭代任意多次(<strong class="io hj"> iters </strong>)。在<strong class="io hj"> while </strong>循环中，我们为循环创建<strong class="io hj">，为此我们<strong class="io hj">枚举X </strong>来访问每一行<strong class="io hj"> X </strong>对应的<strong class="io hj"> y </strong>。如果预测函数在给定的迭代中返回一个不等于<strong class="io hj"> y </strong>的数(0或1 ),那么我们必须通过向<strong class="io hj"> X </strong>的每一行插入1并将其与<strong class="io hj"> y </strong>的乘积加到先前的<strong class="io hj">自权重上来更新<strong class="io hj">自权重</strong>。如果它等于，那么我们什么都不做，自权重保持不变。最后，在我们完成所有迭代之后，我们返回这些<strong class="io hj">自重</strong>。</strong></strong></p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6341" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">   def</strong> fit(self, X, y, iters=10):</span><span id="59d7" class="jt ju hi jp b fi jz jw l jx jy"><strong class="jp hj">        while</strong> iters&gt;0:<br/>            <strong class="jp hj">for</strong> i, x <strong class="jp hj">in</strong> enumerate(X):<br/>                <strong class="jp hj">if</strong> self.predict(x, self.weights)!=y[i]:<br/>                    x = np.insert(x, 0, 1)<br/>                    self.weights = self.weights + y[i]*x<br/>            iters -= 1<br/>        <strong class="jp hj">return</strong> self.weights</span></pre><p id="882a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">“预测”功能来了。它的作用是找到一个相应的<strong class="io hj"> y </strong>(称之为预测的y) <strong class="io hj"> </strong>，这是从训练我们的模型中找到的。我们返回<strong class="io hj">自重</strong>去掉第一个元素和X(<strong class="io hj">X</strong>的某一行)和<strong class="io hj">自重</strong>的第一个元素的点积之和的符号(0或1)。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="da9a" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">def</strong> predict(self, x, w):<br/>    <strong class="jp hj">return</strong> np.sign(np.dot(np.transpose(w[1:]),x) + w[0])</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="4fbf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读！！！</p></div></div>    
</body>
</html>