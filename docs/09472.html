<html>
<head>
<title>Unsupervised Image Retrieval using Convolutional Auto-encoder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用卷积自动编码器的无监督图像检索</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/unsupervised-image-retrieval-using-convolutional-auto-encoder-9d9d6db880e5?source=collection_archive---------15-----------------------#2020-09-07">https://medium.com/analytics-vidhya/unsupervised-image-retrieval-using-convolutional-auto-encoder-9d9d6db880e5?source=collection_archive---------15-----------------------#2020-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fd1026bb264c4f10a29354725605732c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OAF-HGJU5DqinERtPJQIw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="http://slideplayer.com/slide/3415344/12/images/6/Content-based+Image+Retrieval.jpg" rel="noopener ugc nofollow" target="_blank">http://slide player . com/slide/3415344/12/images/6/Content-based+Image+retrieval . jpg</a></figcaption></figure><p id="44b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/ManojKesani/image_retrieval" rel="noopener ugc nofollow" target="_blank">链接到我的包含代码</a>的 Github repo</p><h2 id="3348" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">图像检索</h2><ol class=""><li id="af86" class="ko kp hi ix b iy kq jc kr jg ks jk kt jo ku js kv kw kx ky bi translated"><em class="kz">加载数据</em></li><li id="ca85" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">创建卷积自动编码器</em></li><li id="2f64" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">训练模型</em></li><li id="b4f9" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">保存模型</em></li><li id="4987" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">可视化自动编码器的输出</em></li><li id="a3a4" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">K 的聚类和优化</em></li><li id="6500" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">用 6 个簇训练 k means</em></li><li id="58f0" class="ko kp hi ix b iy la jc lb jg lc jk ld jo le js kv kw kx ky bi translated"><em class="kz">预测</em></li></ol><h2 id="3067" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><em class="lf">装载数据</em></h2><p id="278d" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">让我们创建一个定制的数据加载器。这个类是一个 Keras.utils.sequence 类型。它接受数据集和批处理大小的路径列表。以 0.5 的随机概率输出带有成批和翻转图像的 numpy 数组。这种类型的数据扩充有助于训练。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/020bcd02468065fd587d28fb4716019a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*BIVUQpY26Kq5bCKQgp0oxg.png"/></div></figure><h2 id="f7e8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><em class="lf">创建卷积自动编码器</em></h2><p id="2593" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">我们从编码器模块开始，它获取输入图像，并将其卷积成尺寸更小的图像。然后使用具有 512 个节点的密集连接的神经网络。此时的输出表示 512 暗潜像空间中的原始图像。</p><p id="d1d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们建立解码器，采用这个 512 暗矢量，并试图重建原始图像。这可以通过上采样或 Conv2D 转置来实现。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/cc101f9056d626778f7985a14ba24472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*pJOZ27ayixq6wEvr.jpg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.researchgate.net/publication/305722375_Prognostics_of_Combustion_Instabilities_from_Hi-speed_Flame_Video_using_A_Deep_Convolutional_Selective_Autoencoder" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="d21d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">训练模型</h2><p id="0d19" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">现在我们有了数据加载器和模型，我们将看到培训是如何工作的。在下图中，橙色线是培训损失，蓝色线是验证损失。</p><p id="2636" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着我们训练，训练损失不断减少，而验证损失跟随训练损失一段时间，但随后又回升。验证损失的最低点是我们可以通过这种架构实现的最大压缩率。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/474397912a15d557af97ac9926926b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*rT95ZBQEYzL9L15X4xnl8A.png"/></div></figure><p id="56cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是 50 epoch 的数据增强训练。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/a223e3c3a9ece64fbfa000a81dbf6351.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*SAygJSFP5Xfh9j4mhRF42g.png"/></div></figure><h2 id="6423" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">保存模型</h2><p id="87e1" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">model.save('Conv_AE.h5 ')保存模型到当前工作目录。</p><h2 id="b137" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">可视化自动编码器的输出</h2><p id="9d2d" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">我们可以想象解码器的最终输出。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/aeb59fb599ca3eae3e8e9a53c78a2a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*wgkICJhRTcN-E40XjcpyHw.png"/></div></figure><h2 id="f61f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">K 的聚类和优化</h2><p id="2536" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">在<a class="ae iu" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">聚类分析</a>中，<strong class="ix hj">肘方法</strong>是一种<a class="ae iu" href="https://en.wikipedia.org/wiki/Heuristic" rel="noopener ugc nofollow" target="_blank">启发式</a>，用于<a class="ae iu" href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set" rel="noopener ugc nofollow" target="_blank">确定数据集</a>中的聚类数。该方法包括将<a class="ae iu" href="https://en.wikipedia.org/wiki/Explained_variation" rel="noopener ugc nofollow" target="_blank">解释的变化</a>绘制为聚类数的函数，并选取曲线的<a class="ae iu" href="https://en.wikipedia.org/wiki/Elbow_of_the_curve" rel="noopener ugc nofollow" target="_blank">弯头作为要使用的聚类数。同样的方法也可以用来选择其他数据驱动模型中的参数个数，比如描述一个数据集的</a><a class="ae iu" href="https://en.wikipedia.org/wiki/Principal_component" rel="noopener ugc nofollow" target="_blank">主成分</a>的个数。-维基百科</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/b9553f3bd846545568b9887cf0ef8f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*YbJEduxGYqor_h0ZVqypTg.png"/></div></figure><h2 id="3573" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">预言</h2><p id="bf4d" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">用 K 作为 6，我们训练一个 K 均值模型来聚类图像。我们获取查询图像并通过编码器。然后，512 Dim 向量的输出通过 Kmeans 模型，并预测其所属的聚类数。然后，我们可以查询该图像与其所属的聚类中的所有图像的相似性。</p><h2 id="442c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">丰富</h2><p id="9079" class="pw-post-body-paragraph iv iw hi ix b iy kq ja jb jc kr je jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">我们可以使用像 Efficientnet 模型这样的预训练模型作为特征提取器，一些监督标记可以帮助建立三重丢失模型。</p><p id="8c62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">资源</strong></p><p id="ad86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">监督结构的良好资源</p><p id="41a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://neptune.ai/blog/content-based-image-retrieval-with-siamese-networks" rel="noopener ugc nofollow" target="_blank">https://Neptune . ai/blog/content-based-image-retrieval-with-siamese-networks</a></p></div></div>    
</body>
</html>