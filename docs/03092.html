<html>
<head>
<title>Being Iterable &amp; Creating Generators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可迭代&amp;用Python创建生成器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/being-iterable-creating-generators-in-python-20de0dc649a1?source=collection_archive---------18-----------------------#2020-01-15">https://medium.com/analytics-vidhya/being-iterable-creating-generators-in-python-20de0dc649a1?source=collection_archive---------18-----------------------#2020-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a0519da657cffac2b0d12f9efe42fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GsgNMVti8pW4QzWj"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">奥斯卡·伊尔迪兹在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3616" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们可以从一个对象中得到一个迭代器，那么这个对象就叫做<strong class="ix hj"> iterable </strong>。</p><p id="1fa6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python中的<strong class="ix hj">迭代器</strong>只是一个可以被迭代的对象，也就是说，简单地说，它意味着——“<em class="jt">对象将返回数据，一次一个元素”</em>。</p><p id="65a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python迭代器对象必须实现两个方法，<strong class="ix hj"> __iter__() </strong>和<strong class="ix hj"> __next__() </strong>，其中__iter__()返回迭代器，__next__()返回下一个元素。</p><p id="cf81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从Python的内置数据结构开始，比如列表、字符串、字典——这些都是可迭代的。</p><p id="8216" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将逐一举例来理解这些。</p><h1 id="a8d9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">列表迭代器</h1><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f4d8" class="lb jv hi kx b fi lc ld l le lf"><em class="jt"># Creating a list</em><br/><strong class="kx hj">alist = [23, 13, 67, 79]</strong></span><span id="4ef6" class="lb jv hi kx b fi lg ld l le lf"><em class="jt"># iter() [ it internally calls __iter__() to return an iterator]</em><br/><strong class="kx hj">iterator = iter(alist)</strong></span><span id="880b" class="lb jv hi kx b fi lg ld l le lf"><em class="jt"># Check type of iterator</em><br/><strong class="kx hj">print(type(iterator))<br/></strong>Output: &lt;class 'list_iterator'&gt;</span></pre><p id="4134" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当所有元素都被提取出来后，就会产生StopIteration异常。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e458" class="lb jv hi kx b fi lc ld l le lf"><em class="jt"># Lets iterate through it and extract elements using next()</em></span><span id="37a5" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">while True:<br/>    try:<br/>        print(next(iterator))<br/>    except StopIteration:<br/>        break</strong></span><span id="b0ed" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">Output:</strong><br/>23<br/>13<br/>67<br/>7</span></pre><h1 id="3742" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">字典迭代器</h1><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fd75" class="lb jv hi kx b fi lc ld l le lf"><em class="jt"># create a dictionary</em></span><span id="58df" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">adict = {1:'One', 2:'Two', 3:'Three'}</strong></span><span id="05a0" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">iterator = iter(adict)</strong></span><span id="e2cb" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">print(type(iterator))<br/>Output:</strong>&lt;class 'dict_keyiterator'&gt;</span></pre><p id="a92b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用dictionary_keyiterator，我们可以遍历字典中的键</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0b99" class="lb jv hi kx b fi lc ld l le lf"><strong class="kx hj">while True:<br/>    try:<br/>        k = next(iterator)<br/>        print(f"{k} = {adict[k]}")<br/>    except StopIteration:<br/>        break</strong></span><span id="159c" class="lb jv hi kx b fi lg ld l le lf">Output:<br/>1 = One<br/>2 = Two<br/>3 = Three</span></pre><h1 id="5726" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用Python构建我们自己的迭代器</h1><p id="4a37" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">我们只需要实现两个方法<code class="du lm ln lo kx b">__iter__()</code>和<code class="du lm ln lo kx b">__next__()</code>。</p><p id="2db8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lm ln lo kx b">__iter__()</code>方法返回迭代器对象本身。如果需要，可以执行一些初始化。</p><p id="7d79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lm ln lo kx b">__next__()</code>方法必须返回序列中的下一项。在到达终点时，以及在随后的调用中，它必须引发<code class="du lm ln lo kx b">StopIteration</code>。</p><h2 id="a568" class="lb jv hi bd jw lp lq lr ka ls lt lu ke jg lv lw ki jk lx ly km jo lz ma kq mb bi translated">让我们构建几个迭代器</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fe9d" class="lb jv hi kx b fi lc ld l le lf"><strong class="kx hj">class M_Raise_N:<br/>    '''<br/>    returns no. m to the power k where k=0 to n<br/>    '''<br/>    def __init__(self, m, n):<br/>        self.m = m<br/>        self.n = n<br/>        <br/>    def __iter__(self):<br/>        self.counter = 1<br/>        return self<br/>    <br/>    def __next__(self):<br/>        if self.counter &gt; self.n:<br/>            raise StopIteration<br/>        else:<br/>            result = self.m ** self.counter<br/>            self.counter += 1<br/>            return result</strong></span><span id="53ed" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">for element in M_Raise_N(3,5):<br/>    print(element)</strong></span><span id="8373" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">Output:</strong><br/>3<br/>9<br/>27<br/>81<br/>243</span></pre><h2 id="5e0b" class="lb jv hi bd jw lp lq lr ka ls lt lu ke jg lv lw ki jk lx ly km jo lz ma kq mb bi translated">让我们创建另一个迭代器来生成斐波那契数列</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2c1c" class="lb jv hi kx b fi lc ld l le lf"><strong class="kx hj">class fibo:<br/>    '''generate fibonacci numbers<br/>    '''<br/>    def __init__(self, n):<br/>        self.a=0<br/>        self.b=1<br/>        self.n=n<br/>        <br/>    def __iter__(self):<br/>        self.counter = 1<br/>        return self<br/>    <br/>    def __next__(self):<br/>        if self.counter &gt; self.n:<br/>            raise StopIteration<br/>        else:<br/>            x = self.a<br/>            self.a = self.b<br/>            self.b = x + self.b<br/>            self.counter += 1<br/>            return self.b</strong></span><span id="df45" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">for element in fibo(7):<br/>    print(element)</strong></span><span id="3fa8" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">Output:</strong><br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21</span></pre><h1 id="b4d0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">发电机</h1><p id="205b" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">正如我们在上面看到的，创建迭代器涉及到创建一个类的开销，实现像__iter__()、__next__()、引发StopIteration异常这样的方法，生成器提供了一个创建迭代器的选项，而没有这些开销。</p><p id="1fb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，生成器是一个返回对象(迭代器)的函数，我们可以迭代这个对象(一次一个值)。</p><h1 id="14f0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何用Python创建生成器？</h1><p id="19c6" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">这就像用yield语句创建函数一样简单。如果一个函数至少包含一个yield语句，它就成为一个生成函数。</p><p id="1276" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试一些例子</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f15d" class="lb jv hi kx b fi lc ld l le lf"><strong class="kx hj">def m_raise_n(m, n):<br/>    '''to generate numbers m to power k where k=0 to n<br/>    '''<br/>    for i in range(1,n+1):<br/>        yield m ** i</strong></span><span id="a9c5" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">g = m_raise_n(2, 7)</strong></span><span id="c20a" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">type(g)</strong><br/>generator</span><span id="1492" class="lb jv hi kx b fi lg ld l le lf"># Lets iterate and generate numbers <strong class="kx hj"><br/>while True:<br/>    try:<br/>        print(next(g))<br/>    except StopIteration:<br/>        break</strong></span><span id="5bf4" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">Output:<br/></strong>4 8 16 32 64 128</span></pre><p id="c44b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种方法是使用for循环从生成器函数中生成数字</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b050" class="lb jv hi kx b fi lc ld l le lf"><strong class="kx hj">for item in m_raise_n(2,7):<br/>    print(item)</strong></span><span id="c825" class="lb jv hi kx b fi lg ld l le lf">Output:<br/>2<br/>4<br/>8<br/>16<br/>32<br/>64<br/>128</span></pre><h2 id="eadc" class="lb jv hi bd jw lp lq lr ka ls lt lu ke jg lv lw ki jk lx ly km jo lz ma kq mb bi translated">让我们创建另一个生成器函数</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7f1e" class="lb jv hi kx b fi lc ld l le lf"><strong class="kx hj"># Generator function</strong><br/><strong class="kx hj">def nextN(x, n):<br/>    '''to generate next n successors of item x<br/>    '''<br/>    for  i in range(1, n+1):<br/>        yield x + i</strong></span><span id="3cf0" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">for element in nextN(13, 7):<br/>    print(element)</strong></span><span id="6919" class="lb jv hi kx b fi lg ld l le lf"><strong class="kx hj">Output:</strong></span><span id="2450" class="lb jv hi kx b fi lg ld l le lf">14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20</span></pre></div></div>    
</body>
</html>