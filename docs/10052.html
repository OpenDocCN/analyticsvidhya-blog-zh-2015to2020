<html>
<head>
<title>All about Heaps — Day 9(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于堆的一切—第 9 天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/all-about-heaps-day-9-python-da23d50d0e44?source=collection_archive---------6-----------------------#2020-10-02">https://medium.com/analytics-vidhya/all-about-heaps-day-9-python-da23d50d0e44?source=collection_archive---------6-----------------------#2020-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7f2ca4b88e031c8e803bb674db0dbd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sS6eLKlHa8IoCjCP"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@patwhelen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕特·惠伦</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1133" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我们将回顾堆数据结构。</p><p id="5203" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆是基于树的数据结构，这表明堆将有一个根节点和一些子节点。我们通常使用二进制堆。二进制有一个左子和一个右子。下图是堆数据结构的一个示例。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/b71accf10eceb8a0e520cccee7e807f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*TT0sUMegL4_F0HfdabCTxQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Heap_(data_structure)" rel="noopener ugc nofollow" target="_blank">堆数据结构</a>。</figcaption></figure><p id="e40d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了将节点插入堆中，我们使用 push 函数，为了从堆中移除根，我们使用 pop 函数。当需要插入一个新节点时，它被插入到堆结构的末尾。当我们从堆结构中弹出时，根元素从堆结构中移除。一旦根被删除，重构是必要的，以保留堆的结构。</p><p id="dd83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想以数组的形式表示我们的堆，索引'<strong class="ix hj"> k </strong>'将保存根节点，然后它的左子节点存储在索引'<strong class="ix hj"> 2k + 1' </strong>，它的右子节点存储在索引'<strong class="ix hj"> 2k + 2 '。</strong></p><p id="f1a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述堆将表示如下:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/84b0c0c3b56f4a94d2a75480a879a26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*jLzgbzolJVJP3kA6fUwWFw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">堆的数组表示</figcaption></figure><p id="b296" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据我们的需求，我们可以有一个最小堆或者最大堆。</p><p id="6b99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最小堆和最大堆有什么区别？</p><p id="e2fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最小堆中，根节点将小于子节点。</p><p id="7c63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最小堆的一个例子如下:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/554a45313c8ab460560b90b1efb353bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*EExmAfyWJHRIaG0oj-0mrQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.geeksforgeeks.org/binary-heap/" rel="noopener ugc nofollow" target="_blank">最小堆</a></figcaption></figure><p id="4c17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最大堆中，根节点将大于子节点。</p><p id="3d80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最大堆的一个例子如下:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/673fea4b0330a1de5a0835b6d9467b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*MSd-SSWBUJpu4wUEpH4qVA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="http://www.cse.hut.fi/en/research/SVG/TRAKLA2/tutorials/heap_tutorial/taulukkona.html" rel="noopener ugc nofollow" target="_blank">最大堆量</a></figcaption></figure><p id="6a02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么我们需要最小堆或最大堆？</p><p id="fe5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">排序是堆的应用之一。当我们创建一个最小堆或最大堆时，我们很容易按照升序或降序排列我们的元素。</p><p id="e3f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆的其他应用是什么？</p><ol class=""><li id="3e24" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">我们可以使用堆创建一个优先级队列。在优先级队列中，每个元素都有一个与之相关联的优先级。基于这个优先级，我们可以确定元素在队列中的位置。</li><li id="259c" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">我们可以得到数组中第 k 个最大/最小的元素。</li></ol></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="4425" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始分类。</p><p id="5eb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要执行堆排序，我们需要遵循 2 个步骤。</p><ol class=""><li id="3856" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">构建堆—构建堆是一种通过未排序的输入数组创建树状数据结构的方法。</li><li id="9f09" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">Heapify —它类似于构建堆，但是假设树是部分排序的。</li></ol><p id="6dfd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">算法:</p><ol class=""><li id="4e0d" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">我们的第一步是构建堆，调用 heapify，并跟踪当前的根。</li><li id="407c" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">根的左侧子节点是 2*i+1，其中 I 是根索引，根的右侧子节点是 2*i+2。</li><li id="4b43" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">既然我们在构建 max heap，我们的根应该大于子。如果根比子节点小，则与根交换子节点的位置。</li><li id="72c3" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">一旦构建了 max-heap，就删除根节点并将其放在数组的末尾。</li><li id="7bc8" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">对数组中的其余元素运行上述步骤。</li><li id="0a67" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">一旦我们遍历了整个数组，我们的结果就是排序后的数组。</li></ol><p id="bbd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码如下:</p><pre class="ju jv jw jx fd kw kx ky kz aw la bi"><span id="44d8" class="lb lc hi kx b fi ld le l lf lg">class heapSortExample:<br/>   def heapify(self, arr, n, root_index):<br/>        largest = root_index<br/>        left = 2*root_index + 1<br/>        right = 2*root_index + 2<br/>        <br/>        <br/>        if left &lt; n and arr[left] &gt; arr[largest]:<br/>            largest = left<br/>        if right &lt; n and arr[right] &gt; arr[largest]:<br/>            largest = right<br/>        <br/>        if largest != root_index:<br/>            arr[root_index], arr[largest] = arr[largest], arr[root_index]<br/>            self.heapify(arr, n, largest)</span><span id="df00" class="lb lc hi kx b fi lh le l lf lg">   def heapSort(self, arr):<br/>        n = len(arr)<br/>        k = 2<br/>        for i in range(int(n*0.5-1), -1, -1):<br/>            self.heapify(arr, n, i)<br/>        # One by one extract elements <br/>        for i in range(n-1, 0, -1): <br/>            arr[i], arr[0] = arr[0], arr[i] # swap <br/>            if i == (n-k): <br/>                print(arr[i])<br/>                break<br/>            self.heapify(arr, i, 0) <br/>            <br/>        return arr</span><span id="05c6" class="lb lc hi kx b fi lh le l lf lg">if __name__ == "__main__":<br/>    <br/>    arr = [4, 0, 5, 1, 6, 2, 8]<br/>    s = heapSortExample()<br/>    arr1 = s.heapSort(arr)<br/>    print(arr1)</span></pre><p id="f03a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性</p><p id="5a3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="1ece" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆化所需的时间是 O(logN)，但是我们需要遍历整个数组来得到一个排序后的数组。遍历整个数组需要 O(N)的时间。整体而言，heapsort 的时间复杂度为 O(NlogN)。</p><p id="60cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="6ac5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们没有使用额外的空间来执行排序，所以空间复杂度是 O(1)。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="5618" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 python 中，我们可以使用 heapq 库来创建优先级队列。除了创建堆，我们还可以通过这个库找到第 k 个最大/最小的元素。你可以通过这个<a class="ae iu" href="https://docs.python.org/3.0/library/heapq.html" rel="noopener ugc nofollow" target="_blank">链接</a>了解本库的不同功能。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="2593" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果对这篇文章有任何反馈或建议，请务必告诉我。</p></div></div>    
</body>
</html>