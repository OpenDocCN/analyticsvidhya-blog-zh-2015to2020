<html>
<head>
<title>C++ Advanced Classes and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++高级类和对象</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-advanced-classes-and-objects-4455a84898db?source=collection_archive---------18-----------------------#2020-08-31">https://medium.com/analytics-vidhya/c-advanced-classes-and-objects-4455a84898db?source=collection_archive---------18-----------------------#2020-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c0d042e5ff3a96986918df90d6462c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3gIWl-Omv9Hi8EnuyGkhQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">麦克斯韦·纳尔逊</a>在<a class="ae iu" href="https://unsplash.com/s/photos/c%2B%2B?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="eaad" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">老友记</h1><p id="afd6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">类可以将其他类、其他类的成员函数等声明为<em class="kr">友元</em>，并且可以访问<code class="du ks kt ku kv b">protected</code>和<code class="du ks kt ku kv b">private</code>数据成员和方法。例如，给定两个类<code class="du ks kt ku kv b">A</code>和<code class="du ks kt ku kv b">B</code>，<br/>，你可以说<code class="du ks kt ku kv b">B</code>是<code class="du ks kt ku kv b">A</code>的朋友，如下所示:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="32bb" class="le iw hi kv b fi lf lg l lh li">class A<br/>{<br/>    friend class B;<br/>}</span></pre><p id="ecb6" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">现在<code class="du ks kt ku kv b">B</code>的所有方法都可以访问<code class="du ks kt ku kv b">private</code>和<code class="du ks kt ku kv b">protected</code>的数据成员和<code class="du ks kt ku kv b">A</code>的方法。</p><h1 id="53aa" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">对象中的动态内存分配</h1><p id="8777" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果事先不知道需要多少内存，对象可以动态分配内存。假设上一篇文章中的<code class="du ks kt ku kv b">CheckingAccount</code>类更新如下，以包含帐号:<br/> <code class="du ks kt ku kv b">checkingaccount.h</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="8b1f" class="le iw hi kv b fi lf lg l lh li">#ifndef CHECKING_H<br/>#define CHECKING_H<br/>#include &lt;string&gt;<br/>using std::string;<br/>class CheckingAccount<br/>{<br/>    public:<br/>        CheckingAccount(std::string accountNumber, double balance);<br/>        ~CheckingAccount();<br/>        void deposit(double amount);<br/>        bool withdraw(double amount);<br/>        double getBalance() const;<br/>        string getAccountNumber();<br/>    private:<br/>        std::string mAccountNumber;<br/>        double mBalance;<br/>} <br/>#endif</span></pre><p id="f8c8" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">checkingaccount.cpp</code>:注意<code class="du ks kt ku kv b">::</code>操作符是<em class="kr">范围解析操作符</em>。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d5d0" class="le iw hi kv b fi lf lg l lh li">string CheckingAccount::getAccountNumber()<br/>{<br/>    return mAccountNumber;<br/>}<br/>CheckingAccount::CheckingAccount(string accountNumber, double balance) //constructor<br/>{<br/>    mBalance = balance;<br/>    mAccountNumber = accountNumber;<br/>}</span><span id="ebf6" class="le iw hi kv b fi lo lg l lh li">void CheckingAccount::deposit(double amount)<br/>{<br/>    mBalance += amount;<br/>}</span><span id="0edd" class="le iw hi kv b fi lo lg l lh li">bool CheckingAccount::withdraw(double amount)<br/>{<br/>    if((mBalance - amount) &gt; 0)<br/>    {<br/>        mBalance -= amount;<br/>        return true;<br/>    }<br/>    return false;<br/>}</span><span id="b444" class="le iw hi kv b fi lo lg l lh li">double getBalance() const<br/>{<br/>    return mBalance;<br/>}<br/>//Destructor not implemented yet as there is no dynamic memory allocated.</span></pre><p id="80b4" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">那么一个简单的<code class="du ks kt ku kv b">Bank</code>类就可以被看作是一个<code class="du ks kt ku kv b">CheckingAccount</code>的集合。</p><p id="c6c5" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">bank.h</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="2574" class="le iw hi kv b fi lf lg l lh li">#ifndef BANK_H<br/>#define BANK_H<br/>#include &lt;string&gt;<br/>#include "checkingaccount.h"<br/>using std::string;<br/>class Bank<br/>{<br/>    public:<br/>        Bank(string name, int numAccounts);<br/>        void depositIntoCheckingAccount(string accountNumber, double depositAmount);<br/>        void withdrawFromCheckingAccount(string accountNumber, double withdrawAmount);<br/>        CheckingAccount&amp; getCheckingAccount(string accountNumber);<br/>        string getName();<br/>        int getNumAccounts();<br/>    private:<br/>        string mName;<br/>        int mNumAccounts;<br/>        CheckingAccount* mCheckingAccounts = nullptr; //in modern C++ will use vector&lt;CheckingAccount&gt;<br/>}<br/>#endif</span></pre><p id="e1f0" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">bank.cpp</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="f31a" class="le iw hi kv b fi lf lg l lh li">Bank::Bank(string name, int numAccounts) : mName(name), mNumAccounts(numAccounts)<br/>{ <br/>    mCheckingAccounts = new CheckingAccount[numAccounts];<br/>}</span></pre><p id="d9eb" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">该记忆可以如下可视化:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/31498cf0e46910d67dfc1fee2b70866c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*wt5WZif-NwQlNcsG.png"/></div></figure><p id="6458" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">getCheckingAccount</code>、<code class="du ks kt ku kv b">depositIntoCheckingAccount</code>、<code class="du ks kt ku kv b">withdrawFromCheckingAccount</code>的实现如下:</p><p id="0735" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">bank.cpp</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="c827" class="le iw hi kv b fi lf lg l lh li">CheckingAccount&amp; Bank::getCheckingAccount(string accountNumber)<br/>{<br/>    CheckingAccount* checkingAccount = new CheckingAccount("",0.0);<br/>    for(int i = 0; i &lt; numAccounts; i++)<br/>    {<br/>        if(mCheckingAccounts[i].getAccountNumber == accountNumber)<br/>        {<br/>            return mCheckingAccounts[i];<br/>        }<br/>    }<br/>    return *checkingAccount;<br/>}</span><span id="743b" class="le iw hi kv b fi lo lg l lh li">void Bank::depositIntoCheckingAccount(string accountNumber, double depositAmount)<br/>{<br/>    CheckingAccount&amp; account = getCheckingAccount(accountNumber);<br/>    if(account.accountNumber != "")<br/>    { <br/>        account.deposit(depositAmount);<br/>    }<br/>    else<br/>    {<br/>        cout &lt;&lt; "Couldn't retrieve account with number "&lt;&lt; accountNumber;<br/>        //handle error condition here.<br/>    }<br/>}</span><span id="845f" class="le iw hi kv b fi lo lg l lh li">void Bank::withdrawFromCheckingAccount(string accountNumber, double depositAmount)<br/>{<br/>    CheckingAccount&amp; account = getCheckingAccount(accountNumber);<br/>    if(account.accountNumber != "")<br/>    { <br/>        account.withdraw(depositAmount);<br/>    }<br/>    else<br/>    {<br/>        cout &lt;&lt; "Couldn't retrieve account with number "&lt;&lt; accountNumber;<br/>        //handle error condition here.<br/>    }<br/>}</span></pre><h1 id="2797" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用析构函数释放内存</h1><p id="23eb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">释放对象动态分配的内存的地方是<em class="kr">析构函数</em>。下面是<code class="du ks kt ku kv b">Bank</code>类的析构函数:</p><p id="d71e" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">bank.cpp</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="ba0f" class="le iw hi kv b fi lf lg l lh li">Bank::~Bank()<br/>{<br/>    delete[] mCheckingAccounts;<br/>}</span></pre><h1 id="3a9f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">复制构造函数和赋值运算符</h1><p id="7ddd" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">编译器生成的复制构造函数和赋值运算符只提供浅层副本。使用默认复制构造函数时，浅复制的问题如下:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="03c5" class="le iw hi kv b fi lf lg l lh li">Bank b1("123",5);<br/>printBankInfo(b1);</span><span id="fe30" class="le iw hi kv b fi lo lg l lh li">void printBankInfo(Bank b)<br/>{<br/>    //code to print bank information<br/>}</span></pre><p id="9baf" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">当<code class="du ks kt ku kv b">b1</code>被传递给<code class="du ks kt ku kv b">printBankInfo</code>时，对象的一个浅层副本就产生了，所以内存看起来如下:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/fb4b7c1b018716286f0e3f27fb27af8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*dS36j0PBszdK1bk5.png"/></div></figure><p id="08fb" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">当<code class="du ks kt ku kv b">printBankInfo</code>存在时，<code class="du ks kt ku kv b">b1</code>的副本被销毁，所以<code class="du ks kt ku kv b">b1</code>现在指向被释放的内存。这就是所谓的悬空指针问题。使用赋值操作符，还有一个额外的问题，即被覆盖对象持有的原始内存被孤立，并导致<em class="kr">内存泄漏</em>。</p><p id="d442" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">因此，最好提供自己的复制构造函数和重载赋值运算符，如下所示:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="1530" class="le iw hi kv b fi lf lg l lh li">Bank::Bank(const Bank&amp; src) : Bank(src.mName, src.mNumAccounts)<br/>{ <br/>    for(int k = 0 ; k &lt; mNumAccounts; k++;)<br/>    { <br/>        mCheckingAccounts[k] = src.mCheckingAccounts[k];<br/>    }<br/>}</span></pre><p id="1755" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><em class="kr">复制交换</em>习语用于以异常安全的方式实现赋值操作符。一个非成员<code class="du ks kt ku kv b">swap()</code>函数被实现为<code class="du ks kt ku kv b">Bank</code>类的朋友:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="c33b" class="le iw hi kv b fi lf lg l lh li">class Bank<br/>{<br/>    public:<br/>        Bank&amp; operator=(const Bank&amp; rhs);<br/>        friend void swap(Bank&amp; first, Bank&amp; second) noexcept;<br/>}</span></pre><p id="6d27" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><code class="du ks kt ku kv b">swap</code>使用<code class="du ks kt ku kv b">&lt;utility&gt;</code>头文件中的<code class="du ks kt ku kv b">std::swap</code>函数交换每个数据成员:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="66f8" class="le iw hi kv b fi lf lg l lh li">void swap(Bank&amp; first, Bank&amp; second) noexcept<br/>{<br/>    using std::swap;<br/>    swap(first.mAccountNumber, second.mAcccountNumber);<br/>    swap(first.mNumAccounts, second.mNumAccounts);<br/>    swap(first.mCheckingAccounts, second.mCheckingAccounts);<br/>}</span></pre><p id="a05e" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">那么赋值运算符如下:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6215" class="le iw hi kv b fi lf lg l lh li">Bank&amp; Bank::operator=(const Bank&amp; rhs)<br/>{<br/>    if(this == &amp;rhs)<br/>    {<br/>        return *this;<br/>    }<br/>    Bank temp(rhs);<br/>    swap(*this,temp);<br/>    return *this;</span><span id="141e" class="le iw hi kv b fi lo lg l lh li">}</span></pre><h1 id="db41" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">不允许赋值和按值传递</h1><p id="d9db" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">通过使用<code class="du ks kt ku kv b">delete</code>标记复制构造函数和赋值操作符，可以禁止使用赋值和按值传递，如下所示:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="ac32" class="le iw hi kv b fi lf lg l lh li">class Bank<br/>{<br/>    public: <br/>        //...<br/>        Bank(const Bank&amp; src) = delete;<br/>        Bank&amp; operator=(const Bank&amp; rhs) = delete;<br/>}</span></pre><h1 id="0cf8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">移动语义介绍</h1><p id="7b43" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">通过<em class="kr">移动语义</em>，程序员提供了<em class="kr">移动构造函数</em>和<em class="kr">移动赋值操作符</em>。当源对象是可以在操作完成后销毁的临时对象时，可以使用这些方法。move构造函数和赋值运算符将数据成员从源对象“移动”到目标对象，使源对象处于不确定状态。该过程将所有权转移到目标对象。本质上，浅拷贝完成了，分配的内存和其他资源的所有权被切换到目标，以防止悬空指针和内存泄漏。</p><h1 id="88bc" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">右值和右值引用</h1><p id="d5dd" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">左值是你可以获取地址的东西，例如一个命名的变量。左值出现在赋值的左边。一个<em class="kr">右值</em>是任何不是左值的东西，比如一个文字或者一个临时对象或者值。通常右值在赋值的右边。</p><p id="dd1c" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">右值引用是对右值的引用，特别是当右值是临时对象时。右值引用允许在涉及临时对象时调用特定的函数。结果是，不是复制大值，而是复制指向这些值的指针，然后销毁临时对象。</p><p id="0a72" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">通过使用<code class="du ks kt ku kv b">&amp;&amp;</code>作为参数列表的一部分，函数可以指定一个右值引用参数。通常，一个临时对象是一个<code class="du ks kt ku kv b">const type&amp;</code>，但是当函数被一个右值引用重载时，一个临时对象可以被解析为那个重载。示例:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="f1c9" class="le iw hi kv b fi lf lg l lh li">void foo(string&amp; message)<br/>{<br/>    cout &lt;&lt; "Message with lvalue reference" &lt;&lt; endl;<br/>}</span><span id="0cdf" class="le iw hi kv b fi lo lg l lh li">void foo(string&amp;&amp; message)<br/>{<br/>    cout &lt;&lt; "Message with rvalue reference" &lt;&lt; endl;<br/>}</span></pre><p id="d661" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">在这个例子中，<code class="du ks kt ku kv b">foo()</code>接受左值被称为:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="489b" class="le iw hi kv b fi lf lg l lh li">string a = "hello";<br/>string t = "world";<br/>foo(a);</span></pre><p id="a1a5" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">如果表达式作为参数给出，则调用右值版本</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="8ddd" class="le iw hi kv b fi lf lg l lh li">foo(a + t);</span></pre><p id="5e3c" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">文字也会触发右值版本的调用。如果左值版本被删除，执行类似于<code class="du ks kt ku kv b">foo(a)</code>的操作将会导致错误，因为右值引用不能绑定到左值。要将左值转换为右值，请使用<code class="du ks kt ku kv b">std::move</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="30d6" class="le iw hi kv b fi lf lg l lh li">foo(std::move(a))</span></pre><p id="4569" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">注意，一旦一个右值在一个函数中，它就变成了左值，因为它被命名为。要将它传递给需要右值的函数，需要使用<code class="du ks kt ku kv b">std::move()</code>。</p><h1 id="e81a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">实现移动语义</h1><p id="c989" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">移动语义是通过使用右值引用来实现的。需要实现一个<em class="kr">移动构造函数</em>和<em class="kr">移动赋值操作符</em>。应该用<code class="du ks kt ku kv b">noexcept</code>限定符来标记它们，以表明它们不会抛出异常。使用<code class="du ks kt ku kv b">Bank</code>类的例子:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="417a" class="le iw hi kv b fi lf lg l lh li">class Bank<br/>{<br/>    public: <br/>        Bank(Bank&amp;&amp; src) noexcept; //move constructor<br/>        Bank&amp; operator=(Bank&amp;&amp; rhs) noexcept; //move assignment operator</span><span id="6d3a" class="le iw hi kv b fi lo lg l lh li">    private:<br/>        void cleanup() noexcept;<br/>        void moveFrom(Bank &amp;src) noexcept;<br/>}</span></pre><p id="dc48" class="pw-post-body-paragraph jt ju hi jv b jw lj jy jz ka lk kc kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><em class="kr">未完待续</em></p><h1 id="eba2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">参考资料:</h1><p id="d561" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">m .格雷瓜尔(2018)。<em class="kr">专业C++ </em>。印第安纳州，约翰·威利的儿子们。</p><div class="lr ls ez fb lt lu"><a href="https://codingadventures1.blogspot.com/2020/02/advanced-classes-and-objects-part-i.html" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hj fi z dy lz ea eb ma ed ef hh bi translated">高级类和对象第一部分</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">类可以将其他类、其他类的成员函数等声明为朋友，并且可以访问受保护的和私有的…</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi io lu"/></div></div></a></div></div></div>    
</body>
</html>