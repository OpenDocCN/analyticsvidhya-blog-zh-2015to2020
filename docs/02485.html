<html>
<head>
<title>Classification with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Keras分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/classification-with-keras-8d9d0f315d08?source=collection_archive---------1-----------------------#2019-12-19">https://medium.com/analytics-vidhya/classification-with-keras-8d9d0f315d08?source=collection_archive---------1-----------------------#2019-12-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d617" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用CNN神经网络模型</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/f167593e676de91b261b31f79188859d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/0*mk2_Qm-FHrXMFyeQ.png"/></div></figure><p id="3f81" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你好，在我今天的文章中，我将评论一个使用其他辅助库的简单应用程序，尤其是可以在Tensorflow上工作的Keras库。作为一个IDE，我将使用运行在localhost上的Jupyter IDE。我强烈推荐你使用。先说一点信息吧。</p><p id="60ae" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">什么是Keras？</strong></p><p id="a510" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉Keras是用Python编写的开源神经网络库，可以在CPU和GPU上流畅运行。今天我要在后台使用Tensorflow。然而，像Theano和CNTK后端引擎可用。你想用什么都可以。现在，让我们导入库。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="7ce4" class="kg kh hi kc b fi ki kj l kk kl">import numpy as np<br/>import pandas as pd <br/>from keras.preprocessing.image import ImageDataGenerator, load_img<br/>from keras.utils import to_categorical<br/>from sklearn.model_selection import train_test_split<br/>import matplotlib.pyplot as plt<br/>import random<br/>import os</span></pre><p id="6a1d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉这样，我们强调了教育所需的图书馆。当我们运行代码时，可以看到反馈必须返回。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es km"><img src="../Images/9507e19e429489eaf6119b9fea456fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*zZHgmX9ohT4pPdwIAt4E9g.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">预期反馈</figcaption></figure><p id="b71e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉然后，在工作目录中，我们可以列出要与os.listdir()一起使用的训练和测试数据。我们可以用这个命令看到目录中包含哪些数据。</p><p id="9674" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">检查数据集</strong></p><p id="95d3" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">可以从Kaggle中的<a class="ae kr" href="https://www.kaggle.com/c/dogs-vs-cats" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hj">猫狗</strong> </a>数据集免费下载。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="efc1" class="kg kh hi kc b fi ki kj l kk kl">print(os.listdir("../Data/"))</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ks"><img src="../Images/1a9fca3d63d76a648dea1ef0d042ccf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/0*kryiEmehkartTHxe.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">目录中的文件夹</figcaption></figure><p id="0b94" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">顺便说一下，这个项目使用多层类别图像的深度学习进行分类。我们将在图像中使用狗和猫的标签。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="e39f" class="kg kh hi kc b fi ki kj l kk kl">filenames = os.listdir(“Data/train”)<br/>categories = []<br/>for filename in filenames:<br/> category = filename.split(‘.’)[0]<br/> if category == ‘dog’:<br/>   categories.append(1)<br/> else:<br/>   categories.append(0)</span></pre><p id="1024" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉它在训练数据中改变为1或0标签、狗和猫标签。狗和猫的标签变成了1或0。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="1609" class="kg kh hi kc b fi ki kj l kk kl">df = pd.DataFrame({<br/>    'filename': filenames,<br/>    'category': categories<br/>})</span></pre><p id="1c6a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉我们可以用熊猫图书馆读写数据。我们可以将文件名和类别关联为数据帧中的文件名和类别。category变量指定图像是猫还是狗。之后，在该数据帧中，使用head()命令作为缺省值来检索前5个数据。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="7250" class="kg kh hi kc b fi ki kj l kk kl">df.head( )</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kt"><img src="../Images/548901370776c17ec0efbf25d6f697d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/0*vqwTyUd4JabAfR4s.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">前5个数据检索</figcaption></figure><p id="6653" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉首先，猫和狗进行处理转换为0或1。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ku"><img src="../Images/915afeb2607a8ed827dec0d08f3d472e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*ugGv5XhDB8XqnsTD.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">控制20000张图像</figcaption></figure><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="9e2e" class="kg kh hi kc b fi ki kj l kk kl">test_df[‘category’]=test_df[‘category’].replace({‘dog’: 1, ‘cat’: 0 })</span></pre><p id="421d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉为了以后用作最新操作，在测试过程中，1和0标签被重新转换为猫和狗类别。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="4868" class="kg kh hi kc b fi ki kj l kk kl">df[‘category’].value_counts().plot.bar()</span></pre><p id="e761" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉通过用value_counts()对上面数据集中的category类中带有0和1标签的数据进行计数，根据matplotlib用bar()函数提取条形图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kv"><img src="../Images/6ac1a5558e53f3d3abc883f315f79aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*XoadWsEs5ADWrA0ZNH5xBQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">如预测10000只猫和狗的图像</figcaption></figure><p id="1335" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">从数据集检索随机图像</strong></p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="69e3" class="kg kh hi kc b fi ki kj l kk kl">sample = random.choice(filenames)<br/>image = load_img(“Data/train/”+sample)<br/>plt.imshow(image)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kw"><img src="../Images/84cc48b74ad8e28c0d8c34917b485229.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/0*wZ4lFI5LfIMO4nXZ.png"/></div></figure><p id="e8a2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们在总共20000幅图像上执行数据集的分离，则有12000个训练和8000个测试数据。这个项目中60%的数据集用于教育，40%用于测试数据集。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kx"><img src="../Images/43e2a6fe32f0f6607ce9478e0c0b5acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/0*y2GXz8STMZqSCMcd.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">12000个训练集值的图形化</figcaption></figure><p id="7486" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">❗️CNN是一种神经网络模型，用于通过对图像进行各种层的处理来对图像进行分类。CNN根据图像中感兴趣的不同区域对该区域中物体的存在进行分类。</p><p id="402b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">❗️For:我们将使用CNN神经网络模型，这是必要的，以了解结构提供给我们的层次，并设计好模型。我将展示在这个项目中使用的神经网络架构。CNN模型由卷积层、池层和全连接组成。通常，通过各种正则化方法(辍学、提前停止等)来防止过度学习。)以防止过度拟合。我在这项研究中没有使用任何正则化方法，你可以使用它来获得更好的结果。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/d8ea6abf8de61790c107fbb0a3d143ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/0*ThT38AK8T9E5-aMw.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">CNN层架构</figcaption></figure><p id="c2e6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉该项目使用一个卷积层，RELU函数作为激活函数，卷积神经网络由池层和全连接层组成。</p><p id="a801" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">层模型的结构</strong></p><p id="e52e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">出于分类的目的，它具有这样的架构，即卷积网络是[输入-conv-RELU-池-FC]。第一个结构INPUT包含要使用的图像数据。选择数据集中的20000张猫狗图片作为输入图像。选择CNN神经网络模型对这些图像进行分类。</p><p id="07c0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉首先，用一定数量的内核(kernel_size可以任意选择)创建了称为卷积的卷积层。利用这个卷积核，应用滤波器来提取图像的属性。这一层是CNN模型的构建块。你可以把它想象成图像处理中的逐像素应用，比如均值、高斯、拉普拉斯、索贝尔滤波器。我的图片尺寸是64 x 64，IMAGE_CHANNEL是3。下面显示了选择为RGB的颜色通道在图像像素上的表现。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ld"><img src="../Images/20b4dfa65433b64b614405277d9eb98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*Lil-2zIT3h_catAb.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">对RGB通道应用卷积滤镜</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es le"><img src="../Images/f52b3b79040686ab0059388ebad4f19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/0*wGUnG4hdtoNR1uey.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">卷积层特征提取</figcaption></figure><p id="c021" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">🤗通过这个卷积层，对图像进行特征提取，称为特征检测。这些特征的例子有猫眼、狗尾巴。这样，图像就加深了。然后将激活函数RELU应用于特征图上。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lf"><img src="../Images/071d89643e50e6c3c3173b6336c536c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/0*DI1exJrwJjYoJwOP.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">ReLU函数</figcaption></figure><p id="ebe7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉多层神经网络中的激活是密集的，这意味着它需要大量的处理。网络中的一些神经元是活跃的，并且激活是稀疏的，因此期望获得高效的计算负载。使用ReLU，计算负载比其他激活函数更有效。</p><p id="b329" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉在来自卷积层的图像和属性上，称为池化的池化层有发言权。有了这一层，在不降低性能的情况下，通过减少参数的数量来降低模型的复杂性。它会对图像中的每一项进行识别，以避免影响分类。同时，这个过程也防止了被称为过拟合的过度学习过程。MaxPooling用作池结构。这样，取最大数量的内核大小。通过这个过程，包含足够信息的较小输出被用于神经网络的正确决策。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/4be8e3e8652c98f7749337b1e1f1b0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/0*_7YdlQ2MpPa9Kl3j.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">最大池化的可视化</figcaption></figure><p id="8f74" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉对于架构的最后一层和<strong class="jh hj">完全连接的</strong>层，数据将被转换成具有getting内核的单个输入矩阵。全连接层中的神经网络是完全互连的。每个神经元都有一个单独的权重值。这里要创建的网络将仅由这些层组成。这是通过<strong class="jh hj">展平()</strong>完成的。然后，该数据通过密度过滤器与<strong class="jh hj">密度</strong>相一致。在这一层，在输入端接收的输入数据准备用于全连接层。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kt"><img src="../Images/99fbb62d8f8260f2bc86035eb6e10f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/0*ddMoLjSaqv3bgEnR.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">获取单一输入数据</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lh"><img src="../Images/5c350f20d8a5f2d07a48d193cbba909e.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/0*24mUNUo1fXEfxDWt.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">添加致密层</figcaption></figure><p id="25a0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">用Python代码创建CNN架构</strong></p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="16dc" class="kg kh hi kc b fi ki kj l kk kl">from keras.models import Sequential<br/>from keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense, Activation, BatchNormalizationmodel </span><span id="0c45" class="kg kh hi kc b fi li kj l kk kl">model = Sequential()</span><span id="6d00" class="kg kh hi kc b fi li kj l kk kl">model.add(Conv2D(64, (3, 3), activation='relu',use_bias=True, input_shape=(IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_CHANNELS)))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))</span><span id="c3d7" class="kg kh hi kc b fi li kj l kk kl">model.add(Flatten())<br/>model.add(Dense(512, activation = 'relu',use_bias=True))<br/>model.add(Dense(2, activation = 'relu',use_bias=True))</span><span id="5dc9" class="kg kh hi kc b fi li kj l kk kl">model.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])<br/>model.summary()</span></pre><p id="41a3" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉在卷积层，我有64个滤镜和kernel_size (3，3)。在第一个Conv层中，必须输入图像的宽度和高度值。将根据这些值进行过滤。其中的激活函数已经被指定为relu。如果你愿意，你可以在密集层使用softmax。在人工神经网络中的权重更新期间计算的Z信号的公式中还必须包括偏差值。因为本文中也使用了偏置值，所以我指定use_bias = True。在池层，我创建了一个pool_size (2.2)并减少了数据。由于在我的神经网络结构中有2个隐藏层，我根据完全连接进行交易。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lj"><img src="../Images/d2713b88d425a757cf9fb658ec15520d.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/0*RlU4TN3wd_OiNMgT.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">人工神经网络的结构</figcaption></figure><p id="e032" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">❗️As:你知道，在人工神经网络中有一个成本计算。在这次计算中，我们希望成本最小。因此，计算损失值对我们来说非常重要。</p><p id="fcd5" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉为了编译我们创建的模型，必须选择要使用的损耗参数。对于这一点，Keras中关于<a class="ae kr" href="https://keras.io/losses/" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hj">使用loss </strong> </a>有很好的解释。我使用<strong class="jh hj">categorial _ cross entropy</strong>是因为我做了两个类别的分类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/4ae870b5faacc51301aaeedeea332f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/0*vB1g8JaqDMffIONZ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">模型摘要</figcaption></figure><p id="b155" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉项目中使用的batch_size变量已被均衡为100。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="be63" class="kg kh hi kc b fi ki kj l kk kl">batch_size=100</span></pre><p id="41b2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉然后，为了增加数据，我们切换到数据扩充过程。通过指定切割和旋转间隔，应用数据增量方法，如缩放、缩放、旋转、水平旋转。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="d7f9" class="kg kh hi kc b fi ki kj l kk kl">train_datagen = ImageDataGenerator(<br/>    rotation_range=15,<br/>    rescale=1./255,<br/>    shear_range=0.1,<br/>    zoom_range=0.2,<br/>    horizontal_flip=True,<br/>    width_shift_range=0.1,<br/>    height_shift_range=0.1<br/>)</span><span id="b1b6" class="kg kh hi kc b fi li kj l kk kl">#Data augmentation<br/>train_generator = train_datagen.flow_from_dataframe(<br/>    train_df, <br/>    "Data/train/",<br/>    x_col='filename',<br/>    y_col='category',<br/>    target_size=IMAGE_SIZE,<br/>    class_mode='categorical',<br/>    batch_size=batch_size<br/>)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/4d707fdcde0ae27b0e55573db8343891.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/0*fxBZMq4RbFJdwq14.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">2个类别的验证训练集</figcaption></figure><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="2267" class="kg kh hi kc b fi ki kj l kk kl">plt.figure(figsize=(12, 12))<br/>for i in range(0, 9):<br/> plt.subplot(5, 3, i+1)<br/> for X_batch, Y_batch in example_generator:<br/> image = X_batch[0]<br/> plt.imshow(image)<br/> break<br/>plt.tight_layout()<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lm"><img src="../Images/3ad406edb15c4cc64f6aefc4c1714d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/0*1Kf1slwZtPyIaeLk.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">数据扩充结果的图形化</figcaption></figure><p id="7472" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉随后，分别使用100、500和1000个时期来训练数据。在这些值之后，由于损失值，精度值开始降低。100次迭代的过程如下所示。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="5308" class="kg kh hi kc b fi ki kj l kk kl">epochs=1 if FAST_RUN else 100 <br/>history = model.fit_generator(<br/>    train_generator, <br/>    epochs=epochs,<br/>    validation_data=validation_generator,<br/>    validation_steps=total_validate//batch_size,<br/>    steps_per_epoch=total_train//batch_size,<br/>)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ln"><img src="../Images/be26913b2e334fb4db8ef99ec2e569b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I8pt4LCARWamXWQc.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">100个历元的损失和精度结果</figcaption></figure><p id="23d6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉对于损失值和准确度值的变化图，通过运行以下代码段来创建图形。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="c650" class="kg kh hi kc b fi ki kj l kk kl">fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 12))<br/>ax1.plot(history.history['loss'], color='b', label="Training loss")<br/>ax1.plot(history.history['val_loss'], color='r', label="validation loss")<br/>ax1.set_xticks(np.arange(1, epochs, 1))<br/>ax1.set_yticks(np.arange(0, 1, 0.1))</span><span id="0f67" class="kg kh hi kc b fi li kj l kk kl">ax2.plot(history.history['acc'], color='b', label="Training accuracy")<br/>ax2.plot(history.history['val_acc'], color='r',label="Validation accuracy")<br/>ax2.set_xticks(np.arange(1, epochs, 1))</span><span id="9500" class="kg kh hi kc b fi li kj l kk kl">legend = plt.legend(loc='best', shadow=True)<br/>plt.tight_layout()<br/>plt.show()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lo"><img src="../Images/b39accc712e18ccb678c493c2dbdbb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-_RT_8fprDPp4oBr.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">损失和准确度变化图</figcaption></figure><p id="96a8" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉然后，评估阶段通过，文件夹中的测试图像被提交到机器。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="4c5a" class="kg kh hi kc b fi ki kj l kk kl">test_filenames = os.listdir("Data/test1")<br/>test_df = pd.DataFrame({<br/>    'filename': test_filenames<br/>})<br/>nb_samples = test_df.shape[0]</span></pre><p id="40f0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">❗️还对测试图像进行数据扩充。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="c578" class="kg kh hi kc b fi ki kj l kk kl">test_gen = ImageDataGenerator(rescale=1./255)<br/>test_generator = test_gen.flow_from_dataframe(<br/>    test_df, <br/>    "Data/test1/", <br/>    x_col='filename',<br/>    y_col=None,<br/>    class_mode=None,<br/>    target_size=IMAGE_SIZE,<br/>    batch_size=batch_size,<br/>    shuffle=False<br/>)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/d2788ac9ba8db65243a8b9ec1d63e090.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/0*d3geZDGHRfP1vX02.png"/></div></figure><p id="32a4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉该模型是通过predict方法预测的，在上面的类别中创建的标签表示1: dog 0: cat，但是现在下面修改了这个标签。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="e571" class="kg kh hi kc b fi ki kj l kk kl">predict = model.predict_generator(test_generator, steps=np.ceil(nb_samples/batch_size))</span><span id="6d25" class="kg kh hi kc b fi li kj l kk kl">test_df['category'] = np.argmax(predict, axis=-1)<br/>label_map = dict((v,k) for k,v in train_generator.class_indices.items())<br/>test_df['category'] = test_df['category'].replace(label_map)<br/>test_df['category'] = test_df['category'].replace({ 'dog': 1, 'cat': 0 })</span></pre><p id="1c7e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉然后，通过标记CSV文件来打印预测结果。</p><pre class="iy iz ja jb fd kb kc kd ke aw kf bi"><span id="b27b" class="kg kh hi kc b fi ki kj l kk kl">submission_df = test_df.copy()<br/>submission_df[‘id’] =submission_df[‘filename’].str.split(‘.’).str[0]<br/>submission_df[‘label’] =submission_df[‘category’]<br/>submission_df.drop([‘filename’, ‘category’], axis=1, inplace=True)<br/>submission_df.to_csv(‘Test_submission.csv’, index=False)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lq"><img src="../Images/73635a24c29353ad3f97df88cf7c2154.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/0*IoHIjr8NxOsGi3N4.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">生成的CSV文件</figcaption></figure><p id="7ece" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了确保对生成的CSV文件的控制，首先考虑id为1085和1079的图像。图像显示的是猫。在CSV文件中，类别被指定为0和1。通过控制它，该信息也在文件夹中提供。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lr"><img src="../Images/f905a9e67895e4aa6bee4952624bc3a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/0*b3r7IaYHoOUc8Q-C.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">预测控制</figcaption></figure><p id="0325" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">👉包含测试数据的CSV文件的视图；</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ls"><img src="../Images/759e086840237c5b914fb2f895cf1900.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/0*iuxpmNf7gVM847W4.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">CSV文件中的标签</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lt"><img src="../Images/d41ef46511ac76cfbd04ea6b4b52dd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/0*QSbb3qam-hHymNzD.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">图片6136:猫</figcaption></figure><p id="d1cd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我希望我告诉你的可能对你有用。祝大家编码好，日安<a class="ae kr" href="https://emojipedia.org/smiling-face-with-halo/" rel="noopener ugc nofollow" target="_blank">😇</a></p></div></div>    
</body>
</html>