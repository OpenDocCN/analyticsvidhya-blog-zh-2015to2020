<html>
<head>
<title>Handling Imbalanced Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理不平衡数据集</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/handling-imbalanced-dataset-522dfcae4a3c?source=collection_archive---------8-----------------------#2020-12-09">https://medium.com/analytics-vidhya/handling-imbalanced-dataset-522dfcae4a3c?source=collection_archive---------8-----------------------#2020-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cdccfbc032d8ece4eb387ff13c594fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9VmAtcYUVpOeWXJQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.google.com/search?q=imbalanced&amp;sxsrf=ALeKk02krvOkQrfpgAhAN0Z5Ppiw5fqn9w:1607501135495&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwi7yaCxuMDtAhWOcn0KHblVBpkQ_AUoAXoECBUQAw&amp;biw=1366&amp;bih=625#imgrc=hwwH_S5W511I-M" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="7bbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么是不平衡数据集？</p><p id="cf82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它最常见于医疗部门相关数据集、欺诈数据集等。假设阿波罗医院建立了一个糖尿病体检人群的数据集，该数据集由二进制输出组成，即一个人是否患有糖尿病。</p><p id="6415" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设在<strong class="ix hj">的1000个</strong>记录中<strong class="ix hj">有100个人</strong>患有糖尿病，其余的人正常，那么根据输出，我们的数据集被分成两部分。</p><p id="9be6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">糖尿病患者=100，非糖尿病患者=900 </strong>此处，大量数据集倾向于特定类别(负类别)，因此导致形成不平衡的数据集。</p><p id="d200" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个博客中，我们将讨论平衡不平衡数据集的各种技术。让我们开始吧……</p><h2 id="a16a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">1.欠采样:</h2><p id="ea62" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在欠采样中，我们减少多数类，使其等于少数类。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/61ed356d08ac9591f47a32db5ec8a8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOPVrND7_UBaBBHpGUSC1g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1</figcaption></figure><p id="83b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据之前的图1，我们有一个不平衡的数据集，在多数类中有<strong class="ix hj"> 900个数据点，在少数</strong>类中有<strong class="ix hj"> 100个数据点。通过进行下采样，我们已经将多数类的数据点减少为等于少数类的数据点。</strong></p><p id="d122" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">缺点:</strong></p><p id="d128" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从多数类中减少数据点可能会导致有用信息的丢失，不会给出更好的结果。</p><p id="5c46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了便于编程理解，我采用了<a class="ae iu" href="https://www.kaggle.com/mlg-ulb/creditcardfraud?select=creditcard.csv" rel="noopener ugc nofollow" target="_blank">信用卡欺诈检测数据集</a>。</p><p id="4d7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">步骤1:检查数据集是平衡的还是不平衡的</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="f33a" class="jt ju hi kz b fi ld le l lf lg">sns.countplot(df["Class"],orient="V")<br/>plt.show()<br/>--------------------------------------------------------------------<br/>fraud=df[df["Class"]==1]  <br/>normal=df[df["Class"]==0]<br/>print(fraud.shape)  #printing shape of class  1<br/>print(normal.shape) #Printing shape of class 0</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/c0ada0f4aec0862703edb0b2f5fb88b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*2EbwuLVRJCRqiKMmyvcO0Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">出局1</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/13819d1d179801d58879dab5b75aaeba.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*gDsEDr3M9krEMyaLTeN3Cw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">out 2</figcaption></figure><p id="97d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第二步:执行操作</strong></p><p id="4269" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所见，与第1类<strong class="ix hj">相比，第0类</strong>中存在大量数据。因此我们可以说数据是不平衡的。现在，我们将使用库imblearn来平衡数据集。这个库可能没有预安装到jupyter笔记本中，因此您需要首先通过<strong class="ix hj"> pip install imblearn来安装它。</strong></p><p id="9c55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有<strong class="ix hj">类1=492(少数类)</strong>和<strong class="ix hj">类0=284315(多数类)</strong>通过使用欠采样，我们将减少多数类的计数，就像减少少数类的计数一样。</p><p id="3960" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在欠采样之后，我们将得到类<strong class="ix hj"> 1=492 </strong>和类<strong class="ix hj">0 = 492的数值。</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a085" class="jt ju hi kz b fi ld le l lf lg">x=df.iloc[:,:-1] #creating inependent variable<br/>y=df.iloc[:,-1]  #creating target variable<br/>#code for undersampling<br/>from imblearn.under_sampling import NearMiss<br/>nm=NearMiss()<br/>#Resampling of data of independent variable xand target variable y x_res,y_res=nm.fit_sample(x,y)<br/>print(x_res.shape)<br/>print(y_res.shape)</span><span id="e2f1" class="jt ju hi kz b fi lj le l lf lg">[out]&gt;&gt; (984, 30)<br/>         (984,)</span></pre><p id="6580" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">绘制计数图以查看数据集是否已经平衡</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d453" class="jt ju hi kz b fi ld le l lf lg">df1=pd.DataFrame(x_res)<br/>df1["Class"]=y_res<br/>sns.countplot(df1["Class"])</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/daa88febdbc07d466f787b141f292593.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*IF0mJb0FZEF24KKDUFApyw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">平衡数据集的输出计数图</figcaption></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="aa98" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">2.过采样:</h2><p id="3567" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在过采样中，我们在少数类中添加越来越多的数据点，并使其数据点等于多数类。这是机器学习中最常用的平衡技术，在平衡数据集时不会丢失信息。我们可以使用各种过采样技术来平衡多数类和少数类。当我们进行上采样时，我们总是会有过拟合的机会。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/6cef11d7ed0b1282eff76c281807de30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JPKgNzOqnYmEFAg05uaag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2</figcaption></figure><p id="50cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">方法1:类别权重</strong></p><p id="7bc6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您有900个类别1的数据点和100个类别0的数据集。</p><p id="ca49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第一步:计算两个类中数据点的比率</strong></p><p id="3951" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">比率= 100÷ 900 = 1÷ 9 = &gt; 1:9 </strong></p><p id="7bdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多数类的权重将与少数类的每个数据点相乘，少数类的权重将与多数类的每个数据点相乘，这将产生平衡数据集。</p><p id="874d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第二步:</strong></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/3472fd3ef92c99bcc3e5a4509fe7e62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*jsoTzS9CKeB26WEVKYHD9g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">叉乘法</figcaption></figure><p id="b72d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们的少数阶级将等于多数阶级，因此数据现在是平衡的。</p><p id="229f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">方法2 :-人工或合成点方法</strong></p><p id="a607" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用外推技术，我们在少数类中创建了越来越多的合成点，直到它等于多数类中存在的点。</p><p id="9466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Python实现:- </strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e7c0" class="jt ju hi kz b fi ld le l lf lg">-------------------------------------------------------------------<br/>from imblearn.combine import SMOTETomek<br/>st=SMOTETomek()<br/>x_res,y_res=st.fit_sample(x,y)<br/>print(x_res.shape)<br/>print(y_res.shape)</span><span id="df3d" class="jt ju hi kz b fi lj le l lf lg">[out]&gt;&gt; (567542, 30)<br/>        (567542,)<br/>--------------------------------------------------------------------<br/>from collections import Counter<br/>print("Shape of y before undersampling",Counter(y))<br/>print("Shape of y after undersampling",Counter(y_res))</span><span id="52e7" class="jt ju hi kz b fi lj le l lf lg">[out]&gt;&gt; Shape of y before undersampling Counter({0: 284315, 1: 492})<br/>Shape of y after undersampling Counter({0: 283771, 1: 283771})<br/>--------------------------------------------------------------------</span></pre><p id="e6ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以通过另一种方法来实现过采样技术，即:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c458" class="jt ju hi kz b fi ld le l lf lg">from imblearn.over)sampling import RandomOverSample<br/>rsp=RandomOverSample()<br/>x_rsp,y_rsp=rsp.fit_sample(x,y)<br/>print(x_rsp.shape)<br/>print(y_rsp.shape)</span><span id="70fa" class="jt ju hi kz b fi lj le l lf lg">[out] &gt;&gt; (568630, 30)<br/>         (568630,)</span></pre><p id="65f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可视化我们是否能够平衡数据集</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="53ad" class="jt ju hi kz b fi ld le l lf lg">df2=pd.DataFrame(x_rsp)<br/>df2["Class"]=y_rsp<br/>sns.countplot(df2["Class"])</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/95c4644ad5133db486876faa5a75c698.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*m_04VI9MzHcX28wZ1ueGvQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">平衡数据集的可视化</figcaption></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="21d4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论:</h2><p id="4481" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这都是从我这边来的，如果你觉得这个博客很有趣，坚持住，我会带来更多有趣的东西。请在评论框中提出您的宝贵建议。<strong class="ix hj">不断学习不断探索………… </strong></p></div></div>    
</body>
</html>