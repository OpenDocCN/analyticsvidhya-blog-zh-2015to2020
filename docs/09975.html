<html>
<head>
<title>Cellular Traffic Prediction using Deep Neural Network.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于深度神经网络的蜂窝网络流量预测。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cellular-traffic-prediction-using-deep-neural-network-6ac309ad7039?source=collection_archive---------15-----------------------#2020-09-28">https://medium.com/analytics-vidhya/cellular-traffic-prediction-using-deep-neural-network-6ac309ad7039?source=collection_archive---------15-----------------------#2020-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/620a3a856bfccb62a18c0c8dbe52e23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-ga0GkDe4TBMnyRC6x2mfw.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片提供:<a class="ae iq" href="https://www.warrenentsch.com.au/" rel="noopener ugc nofollow" target="_blank">https://www.warrenentsch.com.au/</a></figcaption></figure><p id="5a64" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这篇博客中，我们将学习使用深度神经网络来预测蜂窝网络流量。特别是，我们将使用长短期记忆(LSTM)。</p><p id="1353" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">作为我们的时间序列数据，我们将使用真实世界的呼叫数据记录(CDR)来预测网络流量。几乎所有的网络服务提供商都维护 cdr 来跟踪他们的操作。</p><p id="4516" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">事实上，本博客中获得的知识可以用于大多数其他时间序列预测场景。</p><p id="e4cb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们将使用的 CDR 由意大利电信公开，作为其 2014 年大数据挑战的一部分。在我之前的<a class="ae iq" rel="noopener" href="/analytics-vidhya/data-cleansing-using-pandas-in-python-33204242d3b2">博客</a>中，我已经使用了相同的 CDR 来展示数据清理和准备步骤。在这篇博客中，我将使用前一篇博客中准备的数据，但为了数据大小的利益做了一些调整。数据可以从我的<a class="ae iq" href="https://github.com/SRJaffry/Network_traffic_Prediction" rel="noopener ugc nofollow" target="_blank"> Github </a>下载。</p><p id="d737" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们摇滚起来！</p><h1 id="504b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">导入必要的包</strong></h1><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e321" class="kw jq hi ks b fi kx ky l kz la"><strong class="ks hj">import</strong> <strong class="ks hj">numpy</strong> <strong class="ks hj">as</strong> <strong class="ks hj">np</strong><br/><strong class="ks hj">import</strong> <strong class="ks hj">tensorflow</strong> <strong class="ks hj">as</strong> <strong class="ks hj">tf </strong><br/><strong class="ks hj">import</strong> <strong class="ks hj">matplotlib</strong><br/><strong class="ks hj">import</strong> <strong class="ks hj">matplotlib.pyplot</strong> <strong class="ks hj">as</strong> <strong class="ks hj">plt</strong><br/><strong class="ks hj">import</strong> <strong class="ks hj">pandas</strong> <strong class="ks hj">as</strong> <strong class="ks hj">pd</strong><br/><strong class="ks hj">from</strong> <strong class="ks hj">pandas</strong> <strong class="ks hj">import</strong> DataFrame<br/><strong class="ks hj">from</strong> <strong class="ks hj">keras.models</strong> <strong class="ks hj">import</strong> Sequential<br/><strong class="ks hj">from</strong> <strong class="ks hj">keras.layers</strong> <strong class="ks hj">import</strong> Dense<br/><strong class="ks hj">from</strong> <strong class="ks hj">sklearn.metrics</strong> <strong class="ks hj">import</strong> mean_squared_error</span></pre><h1 id="c06d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">导入数据集</h1><p id="b390" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">记得先从我的<a class="ae iq" href="https://github.com/SRJaffry/Network_traffic_Prediction" rel="noopener ugc nofollow" target="_blank"> Github </a>下载数据集。将数据集保存在与可执行代码相同的文件夹中。尝试以下方法:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e126" class="kw jq hi ks b fi kx ky l kz la">DS = pd.read_csv('Filtered_Grid_01.txt')<br/><br/><em class="lg"># Consider only the column 'Internet_Activity' from dataframe DS</em><br/>dataset = DS['Internet_Activity']<br/><br/><em class="lg"># Change pandas series into numpy arrays</em><br/>series = dataset.values<br/>series = series.reshape([len(series), 1])<br/>DS.head(5)</span></pre><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/c0f2bc5a525bd73d9a98945ea7a2adfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*PMDqJmDR2FIZjVpez_oFgQ.png"/></div></figure><p id="aa57" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们将只在当前的博客中使用互联网活动。因此，我们在上面的代码中选择了该特定列的值。我们已经将互联网活动转换为 Numpy 数组。</p><h1 id="bcbe" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">数据分割</h1><p id="432c" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">我们现在将把数据分成训练集、验证集和测试集。在 ML 中，训练/验证/测试集的 80/20/20 分割比率非常常见。因此，我们也坚持以下观点:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="162c" class="kw jq hi ks b fi kx ky l kz la">#Data split<br/>size_train_main = int(np.floor(len(series)*.8))<br/>size_val_main = int((len(series) — size_train_main)/2)<br/>size_test_main = int((len(series) — size_train_main)/2)</span><span id="f6df" class="kw jq hi ks b fi li ky l kz la">## Split data<br/>train_set_main = series[:size_train_main]<br/>valid_set_main = series[size_train_main:-size_val_main]<br/>test_set_main = series[size_train_main+size_val_main:]</span></pre><h1 id="f154" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">时间序列的数据准备</h1><p id="1037" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">互联网活动构成了我们的特征向量，但我们没有针对特征元素的任何标签。因此，我们将在下面制作带标签的数据。</p><p id="e7ec" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于时间序列预测，任何特征元素的标签只是同一向量的一步移动元素(在时间上一步传播的情况下)。</p><p id="13ef" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">数学上，对于一步传播，如果<em class="lg"> x(t) </em>是在时间“<em class="lg">t”</em>的特征元素，那么<em class="lg"> x(t+1) </em>将是该元素的标签。对于特征元素<em class="lg"> x(t+1) </em>，标签将为<em class="lg"> x(t+2) </em>，以此类推…</p><p id="7714" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">(对于 n 步传播，特征元素<em class="lg"> x(t) </em>的标签应为<em class="lg"> x(t+n) </em>)</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d437" class="kw jq hi ks b fi kx ky l kz la"><em class="lg"># Make x and y labels</em><br/>X_train = pd.DataFrame(train_set_main)<br/>y_train = X_train.shift(-1)<br/><br/>X_val = pd.DataFrame(valid_set_main)<br/>y_val = X_val.shift(-1)<br/><br/>X_test = pd.DataFrame(test_set_main)<br/>y_test = X_test.shift(-1)<br/><br/><em class="lg"># Drop the last element of X_* as we will not have any label for it.</em><br/>X_train.drop(X_train.tail(1), inplace = <strong class="ks hj">True</strong>)<br/>X_val.drop(X_test.tail(1), inplace = <strong class="ks hj">True</strong>)<br/>X_test.drop(X_test.tail(1), inplace = <strong class="ks hj">True</strong>)<br/><br/><em class="lg">#Last element of y_* would have NaN, hence drop it.</em><br/>y_train.dropna(inplace = <strong class="ks hj">True</strong>)<br/>y_val.dropna(inplace = <strong class="ks hj">True</strong>)<br/>y_test.dropna(inplace = <strong class="ks hj">True</strong>)</span></pre><h1 id="a58c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型准备和培训</h1><p id="892a" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">LSTM 模型的输入向量必须观察特定的形状。在下面，我们将重新排列我们的向量到那个形状，并把它们提供给 LSTM 模型。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="5740" class="kw jq hi ks b fi kx ky l kz la"><em class="lg"># Convert all the data frames to numpy arrays again.</em><br/><br/>X_train = X_train.values<br/>y_train = y_train.values<br/>X_val = X_val.values<br/>y_val = y_val.values<br/>X_test = X_test.values <br/><br/><em class="lg"># How many steps do we want to proceed in the time series</em><br/>n_steps = 1 <br/><br/><em class="lg"># How many features do we have in the time series</em><br/>n_features = 1<br/><br/><em class="lg"># reshape input to be 3D [samples, timesteps, features]</em><br/>X_train = X_train.reshape((X_train.shape[0], n_steps, n_features))<br/>X_val = X_val.reshape((X_val.shape[0], n_steps, n_features))<br/>X_test = X_test.reshape((X_test.shape[0], n_steps, n_features))</span></pre><p id="5fd6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们在下面定义了 50 个 LSTM 隐藏层的模型。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="0bce" class="kw jq hi ks b fi kx ky l kz la">model_LSTM = Sequential()<br/>model_LSTM.add(LSTM(50, activation = 'relu', input_shape=(n_steps, <br/>               n_features)))<br/>model_LSTM.add(Dense(1))</span></pre><p id="1a87" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">该模型被编译和训练(拟合)如下。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f32c" class="kw jq hi ks b fi kx ky l kz la">model_LSTM.compile(loss='mae', optimizer = 'adam')<br/><br/>history_LSTM = model_LSTM.fit(X_train, y_train, epochs=20, <br/>               batch_size=64, validation_data=(X_val, y_val), <br/>               verbose=0, shuffle=<strong class="ks hj">False</strong>)</span></pre><p id="c411" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在训练期间，模型将调整隐藏单元的权重值，以最小化预测值和真实值之间的误差。除了训练误差，验证误差也应该保持较低。在下文中，我们将展示这些错误。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6d59" class="kw jq hi ks b fi kx ky l kz la"><em class="lg"># Plotting the error in training and validation</em><br/>plt.plot(history_FF.history['loss'], "b+-", label='training', <br/>        color = "red")<br/>plt.plot(history_FF.history['val_loss'], "b+-", label='validation', <br/>        color = "blue")<br/>plt.legend(fontsize=14) <br/>plt.title('Feed Forward')<br/>plt.grid()<br/>plt.xlabel('Training Epochs', fontsize=16)<br/>plt.ylabel('Mean Absolute error', fontsize=16)<br/>plt.xlim(0, 20)<br/>plt.show()</span></pre><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/712f1a9656475f7e571fc313ab735c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*QWypIZs3c0_SK_B51PEosg.png"/></div></figure><h1 id="1863" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">最终预测</strong></h1><p id="0295" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">最后，让我们看看我们训练好的模型能够多好地预测蜂窝网络上的互联网流量。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="be70" class="kw jq hi ks b fi kx ky l kz la">y_pred_FF = model_FF.predict(X_test.reshape(X_test.shape[0],1))<br/><br/>plt.plot(y_test, "b-+", label='Ground truth', color = "red")<br/>plt.plot(y_pred_FF, "b-", label='Feed Forward prediction', color = "blue")<br/>plt.legend()<br/>plt.ylim(4,18)<br/>plt.xlim(0, 200)<br/>plt.xlabel('Time instannces', fontsize=16)<br/>plt.ylabel('Activity', fontsize=16)<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/7acda59c8f2371592ef631d1066dfee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*JTaO3_1D_DBGKyYM_O-jnA.png"/></div></figure><p id="9819" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">哇…它准确地预测了真实值…万岁:)</p><p id="4ad9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我离开之前，让我分享一下我在这个项目中使用的库的版本:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/65c8aed77abea56f5405301e766e5120.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*F3VLFXfXX-6AE0t7IwJc5w.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">使用的软件和库的版本</figcaption></figure><p id="4f64" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这里，我承认我从<a class="ae iq" href="https://machinelearningmastery.com/" rel="noopener ugc nofollow" target="_blank">机器学习大师</a>的杰森·布朗利写的博客中学到了很多深度学习。这个特别的交通预测模型是受他的博客<a class="ae iq" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">的启发。</a></p><p id="d051" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">享受编码。如果有任何问题，请让我知道。</p><p id="e414" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">完整的代码和数据集可以在我的 Github 页面<a class="ae iq" href="https://github.com/SRJaffry/Network_traffic_Prediction" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>