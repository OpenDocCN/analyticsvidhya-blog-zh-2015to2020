<html>
<head>
<title>Data class in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的数据类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-class-in-kotlin-32bf038729a1?source=collection_archive---------8-----------------------#2020-07-11">https://medium.com/analytics-vidhya/data-class-in-kotlin-32bf038729a1?source=collection_archive---------8-----------------------#2020-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="424e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不仅仅是平等。</h2></div><p id="3b29" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让面试官知道你为什么喜欢科特林的一门数据课，这是面试过程中常见的问题。正确答案似乎是免费平等。尽管这是一个非常棒的特性，但data class还有更多这样的特性。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/5f1a27ab49759f2392da2c4ae25f04bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toDXW-R1Gl3pyqKR1XTrag.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated"><a class="ae kj" href="https://www.pexels.com/photo/woman-touching-a-mirror-3881965/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/woman-touching-a-mirror-3881965/</a></figcaption></figure><h1 id="eb5c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">数据类</h1><p id="2031" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">一个简单的关键词变成了编程游戏的改变者——数据。数据类用于描述传输对象。编程就是获取输入数据，处理它们并返回输出数据。下面是数据类的帮助。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="6740" class="lm kl hi li b fi ln lo l lp lq">data class Man(<br/>    val name: String,<br/>    val surname: String,<br/>    val bDate: String? = null<br/>)</span></pre><h2 id="4ee7" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">平等</h2><p id="1e03" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我承认当我跳入Kotlin时，我停止了重写<em class="me">等于</em>和<em class="me">哈希码</em>方法。大多数情况下都有一个内置功能。尽管是两个不同的实例，但当所有构造函数参数都相等时，两个精确的对象是相等的。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="a7a5" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `equality of two objects`() {<br/>    val man1 = Man("Ken", "Mattel", "01/01/1961")<br/>    val man2 = Man("Ken", "Mattel", "01/01/1961")<br/><br/>    assertTrue(<strong class="li hj">man1 == man2</strong>)<br/>    assertFalse(<strong class="li hj">man1 === man2</strong>)<br/>}</span></pre><h2 id="bb95" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">散列码</h2><p id="98ce" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在，每当我重写<em class="me">等于</em>时，我不需要记得重写<em class="me"> hashCode </em>方法。数据类替我做了。我可以使用数据类对象作为哈希映射中的键！</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="d27c" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `hashcode of two objects`() {<br/>    val man1 = Man("Ken", "Mattel", "01/01/1961")<br/>    val man2 = Man("Ken", "Mattel", "01/01/1961")<br/>    val message = "I'm here already!"<br/><br/>    val map = <em class="me">hashMapOf</em>(<strong class="li hj">man1 <em class="me">to </em>message</strong>)<br/><br/>    assertTrue(man1.hashCode() == man2.hashCode())<br/>    assertEquals(<strong class="li hj">message, map[man2]</strong>)<br/>}</span></pre><h2 id="2c45" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">可读性</h2><p id="000d" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我知道这不是一个数据类特性，但是Kotlin给了我们一个极大的工具，极大地改进了代码审查。我说的是命名参数。我不再需要用描述性名称来定义局部值。现在，我知道肯是一个真实的名字还是只是一个品牌。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="0622" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `readability for reviewer`() {<br/>    val name = "Ken"<br/>    val surname = "Mattel"<br/>    val bDate = "01/01/1961"<br/>    val man1 = Man(name, surname, bDate)<br/>    val man2 = Man(<br/><strong class="li hj">        name = </strong>"Ken",<br/><strong class="li hj">        surname = </strong>"Mattel",<br/><strong class="li hj">        bDate = </strong>"01/01/1961"<br/>    )<br/><br/>    assertEquals(man1.name, man2.name)<br/>    assertEquals(man1.surname, man2.surname)<br/>    assertEquals(man1.bDate, man2.bDate)<br/>}</span></pre><h2 id="b713" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">内置生成器</h2><p id="08f9" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">默认值和命名参数一起给了我们一个生成器设计模式的能力。我可以改变数据类声明中参数的顺序，这不会影响我的代码。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="fad1" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `built-in builder design pattern`() {<br/>    val man = Man(<br/>        surname = "Mattel",<br/>        name = "Ken"<br/>    )<br/><br/>    assertNull(man.bDate)<br/>}</span></pre><h2 id="e052" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">内置原型</h2><p id="bcf1" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">命名参数对于<em class="me">复制</em>方法非常有用。“复制”使用“原始”的值克隆对象，但有一个选项可以覆盖它们。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="bde9" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `built-in prototype pattern`() {<br/>    val bDate = "01/01/1961"<br/>    val man = Man(<br/>        name = "Ken",<br/>        surname = "Mattel"<br/>    )<br/><br/>    val manWithBirthDate = man.copy(bDate = bDate)<br/><br/>    assertEquals(man.name, manWithBirthDate.name)<br/>    assertEquals(man.surname, manWithBirthDate.surname)<br/>    assertEquals(bDate, manWithBirthDate.bDate)<br/>}</span></pre><h2 id="b920" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">打印信息</h2><p id="536a" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">不再需要覆盖<em class="me"> toString </em>方法。这是免费赠送的。这对于调试或日志记录非常有用。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="d17e" class="lm kl hi li b fi ln lo l lp lq">val man = Man("Ken", "Mattel", "01/01/1961")<br/>print(man) // prints Man(name=Ken, surname=Mattel, bDate=01/01/1961)</span></pre><h2 id="68e3" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">破坏组件</h2><p id="f1a9" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">数据类可以被提取成组件。我非常喜欢这个功能，尤其是在地图条目中，我可以像这样打开一个键和值:</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="d2f5" class="lm kl hi li b fi ln lo l lp lq">val (key, value) = mapOf(1 to "one").entries.first()<br/>print(key) // prints 1<br/>print(value) // prints one</span></pre><p id="081c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样的方式，我可以提取数据类。当然，对于大数据类，它不会像对于小数据束那样有用。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="8205" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `components of data class`() {<br/>    val man = Man("Ken", "Mattel", "01/01/1961")<br/>    val (name, _, bDate) = man<br/><br/>    assertEquals(name, man.name)<br/>    assertEquals(bDate, man.bDate)<br/>}</span></pre><h1 id="84f9" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">需要注意什么</h1><p id="1c54" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">总会有一个平衡。就像阴阳一样，为好而存在的东西也可以被用来做坏事。我这里的例子很简单，因为关于Ken的数据是不可变的。男人从不改变自己的名字、姓氏或出生日期。另一方面，女人有。我可以这样定义这种情况:</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="4473" class="lm kl hi li b fi ln lo l lp lq">data class Woman(<br/>    val name: String,<br/>    <strong class="li hj">var surname: String,</strong><br/>    val bDate: String? = null<br/>)</span></pre><p id="5f3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当芭比最终嫁给肯时，她会跟他姓。构造函数中的这个变量保留了数据类的所有特性，但是它也为错误提供了空间。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="48fc" class="lm kl hi li b fi ln lo l lp lq">@Test<br/>fun `caveat of using var`() {<br/>    val woman = Woman("Barbie", "Girl", "31/12/1959")<br/>    val map = <em class="me">hashMapOf</em>(woman <em class="me">to </em>"I'm here!")<br/><br/>    woman.surname = "Mattel"<br/><br/>    assertNull(map[woman])<br/>    <em class="me">print</em>(map) // prints {Woman(name=Barbie, surname=Mattel, bDate=31/12/1959)=I'm here!}<br/>}</span></pre><p id="55a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的密钥不再是唯一的。哈希代码已更改，哈希映射打印精确的对象，我无法检索。那是一个很难发现的漏洞。芭比刚刚被留在真空中，肯将独自行走并试图找到她——永远…</p><p id="542e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">…永远。</p><h2 id="6166" class="lm kl hi bd km lr ls lt kq lu lv lw ku jg lx ly kw jk lz ma ky jo mb mc la md bi translated">固定</h2><p id="4fdd" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在数据类中使用var有一个更好的方法。如果我只是从构造函数中取出var，equal和hashCode会忽略这个属性。当然，这意味着现在任何出生于1959年1月1日的芭比都是同一个芭比——这是要付出的代价。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="084d" class="lm kl hi li b fi ln lo l lp lq">data class Woman(<br/>    val name: String,<br/>    val bDate: String? = null<br/>) {<br/>    <strong class="li hj">var surname: String = ""</strong><br/>}</span><span id="1e30" class="lm kl hi li b fi mf lo l lp lq">@Test<br/>fun `fix for using var`() {<br/>    val woman = Woman("Barbie", "31/12/1959")<br/>        .<em class="me">apply </em><strong class="li hj">{ </strong>surname = "Girl" <strong class="li hj">}<br/>    </strong>val map = <em class="me">hashMapOf</em>(woman <em class="me">to </em>"I'm here!")<br/><br/>    woman.surname = "Mattel"<br/><br/>    assertNotNull(map[woman])<br/>}</span></pre><h1 id="092a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">摘要</h1><p id="928c" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">数据类是一个非常强大的工具。了解它的优点和缺点有助于找到特定情况下的最佳解决方案。如果我确定我的数据类不会被用作一个映射的键，或者在一个有序集合中使用，那么我看不出为什么我不应该在数据类构造函数中使用var。但我能永远确定吗？至少它应该打开我脑袋里的一盏黄灯。</p></div></div>    
</body>
</html>