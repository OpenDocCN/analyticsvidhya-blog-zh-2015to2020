<html>
<head>
<title>Binarization of Image using NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 NumPy 的图像二值化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/binarization-of-image-using-numpy-65df2b82e189?source=collection_archive---------1-----------------------#2020-12-03">https://medium.com/analytics-vidhya/binarization-of-image-using-numpy-65df2b82e189?source=collection_archive---------1-----------------------#2020-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4c846b9bcffe26c795f89991442575fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4vaLRhoyhNnAe6Bd"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安杰尔·桑多斯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1479" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将学习如何使用 NumPy 将图像二值化，当然，我们将使用 OpenCV 读取灰度和 RGB 图像。</p><p id="2db6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解二进制是什么，二进制是由两种东西组成的。在计算机术语中，二进制只是<strong class="ix hj">T5【0】T6</strong>和<strong class="ix hj">T9】1T11】。如果我们把这些图像联系起来，就像黑白图像一样</strong></p><ul class=""><li id="6a4d" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><strong class="ix hj"> <em class="jt"> 0 </em> </strong>表示<strong class="ix hj">黑色</strong></li><li id="ef1a" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="ix hj"> <em class="jt"> 1 </em> </strong>表示<strong class="ix hj">白色</strong>。</li></ul><p id="9b99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在学习图像处理的初级阶段，我们常常把一幅灰度图像想象成一幅<strong class="ix hj">二值图像</strong>。虽然不是。但是当我们慢慢提起这个话题时，我们意识到我们错了。因此，接下来，我们将学习如何在使用库和不使用库的情况下将图像二值化(NumPy 用于矩阵运算，只是为了避免在使用常规<strong class="ix hj">进行循环</strong>时程序变慢)。除此之外，我们还将使用 Matplotlib 来绘制结果。</p><h1 id="4030" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">RGB 和灰度概述</h1><p id="fc2a" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">二元运算对灰度图像非常有效。彩色(RGB)图像的问题是，每个像素是一个向量，代表 3 个唯一的值，一个代表红色，一个代表绿色，一个代表蓝色。</p><p id="10c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个典型的灰度图像的矩阵看起来像—</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="da07" class="lu kj hi lq b fi lv lw l lx ly">array([[162, 162, 162, ..., 170, 155, 128],<br/>       [162, 162, 162, ..., 170, 155, 128],<br/>       [162, 162, 162, ..., 170, 155, 128],<br/>       ...,<br/>       [ 43,  43,  50, ..., 104, 100,  98],<br/>       [ 44,  44,  55, ..., 104, 105, 108],<br/>       [ 44,  44,  55, ..., 104, 105, 108]], dtype=uint8)</span></pre><p id="eb80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个典型的 RGB 图像矩阵看起来像这样—</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="9c25" class="lu kj hi lq b fi lv lw l lx ly">array([[[226, 137, 125], ..., [200,  99,  90]],<br/>       [[226, 137, 125], ..., [200,  99,  90]],<br/>       [[226, 137, 125], ..., [200,  99,  90]],<br/>       ...,<br/>       [[ 84,  18,  60], ..., [177,  62,  79]],<br/>       [[ 82,  22,  57], ..., [185,  74,  81]],<br/>       [[ 82,  22,  57], ..., [185,  74,  81]]], dtype=uint8)</span></pre><p id="4dae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们从上面的矩阵中分离出 R、G 和 B 像素。我们得到了。</p><p id="7eac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> R 矩阵</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="5858" class="lu kj hi lq b fi lv lw l lx ly">array([[226, 226, 223, ..., 230, 221, 200],<br/>       [226, 226, 223, ..., 230, 221, 200],<br/>       [226, 226, 223, ..., 230, 221, 200],<br/>       ...,<br/>       [ 84,  84,  92, ..., 173, 172, 177],<br/>       [ 82,  82,  96, ..., 179, 181, 185],<br/>       [ 82,  82,  96, ..., 179, 181, 185]], dtype=uint8)</span></pre><p id="1299" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> G 矩阵</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="bb9e" class="lu kj hi lq b fi lv lw l lx ly">array([[137, 137, 137, ..., 148, 130,  99],<br/>       [137, 137, 137, ..., 148, 130,  99],<br/>       [137, 137, 137, ..., 148, 130,  99],<br/>       ...,<br/>       [ 18,  18,  27, ...,  73,  68,  62],<br/>       [ 22,  22,  32, ...,  70,  71,  74],<br/>       [ 22,  22,  32, ...,  70,  71,  74]], dtype=uint8)</span></pre><p id="8778" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> B 矩阵</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="5191" class="lu kj hi lq b fi lv lw l lx ly">array([[125, 125, 133, ..., 122, 110,  90],<br/>       [125, 125, 133, ..., 122, 110,  90],<br/>       [125, 125, 133, ..., 122, 110,  90],<br/>       ...,<br/>       [ 60,  60,  58, ...,  84,  76,  79],<br/>       [ 57,  57,  62, ...,  79,  81,  81],<br/>       [ 57,  57,  62, ...,  79,  81,  81]], dtype=uint8)</span></pre><p id="5610" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论我们对灰度图像进行什么运算，我们都需要对 RGB 图像进行同样的运算，但是要对 R、G 和 B 像素进行 3 次分离，最后将它们合并为一个正确的 RGB 图像。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="8a1d" class="ki kj hi bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf bi translated">编码时间到了</h1><p id="b767" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们主要使用的包是—</p><ul class=""><li id="c13f" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated">NumPy</li><li id="5237" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">Matplotlib</li><li id="9ec6" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">OpenCV</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/18305c130ac5255d7e7a39a385ec518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Nm7Ec_i9OjDnCPM59Nkdg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><h2 id="13b1" class="lu kj hi bd kk mm mn mo ko mp mq mr ks jg ms mt kw jk mu mv la jo mw mx le my bi translated">导入包</h2><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="2706" class="lu kj hi bd kk mm mn mo ko mp mq mr ks jg ms mt kw jk mu mv la jo mw mx le my bi translated">阅读图像</h2><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="d955" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述函数读取灰度或 RGB 图像，并返回图像矩阵。</p><h2 id="4d62" class="lu kj hi bd kk mm mn mo ko mp mq mr ks jg ms mt kw jk mu mv la jo mw mx le my bi translated">用库实现代码</h2><p id="5159" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">为了将图像转换成二值图像，我们可以简单地使用<strong class="ix hj"> <em class="jt"> cv2 </em> </strong>库中的<strong class="ix hj"> <em class="jt"> threshold() </em> </strong>方法。这种方法，不管图像是什么(灰度或 RGB)都转换成二进制。它使用了 4 个参数。</p><ul class=""><li id="91e7" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><strong class="ix hj"> src </strong> →基本就是图像矩阵。</li><li id="2517" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="ix hj"> thresh </strong> →这是一个阈值，基于该阈值像素被赋予一个新值。如果像素小于这个值，我们会将这些像素重新赋值为<strong class="ix hj"> <em class="jt"> 255 </em> </strong>。否则，像素将被重估为<strong class="ix hj"> <em class="jt"> 0 </em> </strong>。</li><li id="2b73" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="ix hj"> maxval </strong> →这是典型图像可以包含的最大像素值(255)。</li><li id="c47f" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="ix hj">类型→ </strong>它基本上是给定的阈值类型，并基于该类型计算操作。手术有几种类型。</li></ul><p id="8a58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此之后，我们将绘制结果，以查看变化，因此下面的函数。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="648a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们测试一下上面的函数—</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/ecd94d9fc3928675e9cb0184dfea15e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*PgDFSMMCUi77pkErLQSe9g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/27b9d476cbb8ed2bcd106ce1be8a4b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*kd097f77QAoRTmuIvu-oUQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="bbd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经看到了原始图像和二进制图像的结果，显然库代码对两者都有效。是时候让我们的手脏起来，从头开始编写相同的代码了。</p><h2 id="9961" class="lu kj hi bd kk mm mn mo ko mp mq mr ks jg ms mt kw jk mu mv la jo mw mx le my bi translated">从头开始代码实现</h2><p id="d92f" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">首先，我们将编写一个函数，将小于指定阈值的像素值重新赋值给<strong class="ix hj"> <em class="jt"> 255 </em> </strong>。</p><p id="7465" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过这样做，我们将会看到类似下面的东西—</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="975e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将通过分离 R、G 和 B 值来调用上述函数三次，并最终将其合并以获得二值化图像。一旦这样做了，我们就可以像以前那样画出结果。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="54be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经通过使用 NumPy 生成了二进制代码。让我们同样测试一下—</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/ecd94d9fc3928675e9cb0184dfea15e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*PgDFSMMCUi77pkErLQSe9g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/27b9d476cbb8ed2bcd106ce1be8a4b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*kd097f77QAoRTmuIvu-oUQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="7b8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是了。无论我们想完成什么，我们都已经完成了。结果与我们使用库代码得到的结果非常相似。</p><p id="7b26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这就结束了本文的目的。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="f3f1" class="ki kj hi bd kk kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf bi translated">其他类似文章</h1><ol class=""><li id="dc4b" class="ju jv hi ix b iy lg jc lh jg nc jk nd jo ne js nf ka kb kc bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/image-flipping-and-mirroring-with-numpy-and-opencv-aecc08558679">图像翻转和镜像</a></li><li id="4115" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js nf ka kb kc bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/image-equalization-contrast-enhancing-in-python-82600d3b371c">图像均衡</a></li><li id="1d08" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js nf ka kb kc bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/image-convolution-from-scratch-d99bf639c32a">图像卷积</a></li></ol><p id="5086" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请务必阅读…</p></div></div>    
</body>
</html>