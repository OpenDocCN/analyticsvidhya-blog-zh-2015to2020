<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recursion-made-simple-ba1349f1a542?source=collection_archive---------21-----------------------#2020-08-04">https://medium.com/analytics-vidhya/recursion-made-simple-ba1349f1a542?source=collection_archive---------21-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><ol class=""><li id="ee86" class="hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy bi translated">递归变得简单</li></ol><p id="2215" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">任何阅读数据结构和算法的人都会遇到一个叫做“递归”的话题。这是理解递归的最好方法。这样读‘n’遍，直到你的理解变成<strong class="hj io">“真”</strong>。哈哈！！这就是递归有多简单。</p><p id="d2dc" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">递归可以在任何语言中实现，结果是一样的。在这里，我将展示几个关于 python 中递归的主题和关键概念🐍。是的，你没看错一个对 python❤.的爱</p><h1 id="dd55" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">简介:</h1><p id="28c2" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">一个函数调用它自己直到一个条件被设置为真或假被称为递归函数。下图显示了一个名为“recursive_fun”的简单函数，它自称“n”次。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/9ac83316b1eade17a308621d4766f66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMkZcDUGfxFi_1XhKCYkog.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">递归的一个简单例子</figcaption></figure><p id="4702" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">递归的输出可以用一个叫做跟踪的概念来理解，跟踪是用来跟踪递归函数的输出。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ki"><img src="../Images/8e72ba9af13b2dc06b8ce27c455d723d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*vA_PmWAqux4OJaYI9iOxUA.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">递归的追踪树(前进阶段)</figcaption></figure><p id="5802" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">上面的追踪树解释了很多关于重复的函数调用是如何获得想要的输出的。这里 recursive_fun 被调用了 3+1 次，在这 3 次调用中，它都输出‘n ’,但是在最后一次调用中，它不满足条件，返回 0。因此，在任何递归中，函数调用都要进行 n+1 次。另外，仔细观察跟踪树，我们看到 recursive_fun 在调用自己之前执行 print 语句，这就是所谓的前向阶段。递归的反向阶段是函数在执行任何语句之前调用自己，也就是说，执行所有其他语句，直到不再有函数调用。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es kj"><img src="../Images/8d2ddc50967ec5addbe2d5264ea3f165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9AZoHgssjiqXelFnNopUA.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">反向相位递归</figcaption></figure><p id="8b3c" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">上图清楚地显示了在反相阶段输出如何从<strong class="hj io">3 ^ 2 ^ 1</strong>变化到<strong class="hj io">1 ^ 2 ^ 3</strong>。这是因为函数调用发生在 print 语句之前，而 print 语句是在 returning 或 backward 阶段执行的，或者换句话说，当 recursive_fun(0)超出范围时，recursive_fun(1)的 print 语句被执行，然后超出范围。这一直持续到所有的函数调用都超出范围。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kk"><img src="../Images/bf65c8340845d76cceac8a89721a4a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*l2Z5xhzZOVSJW4e5UEgTCA.jpeg"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">追溯树对于后向阶段递归，print 语句如箭头所示执行</figcaption></figure><h1 id="564e" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">递归的时间复杂度；</h1><p id="4ad6" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">一般来说，任何函数的时间复杂度都取决于该函数所执行的操作。为了给递归的时间复杂度一个概念，我们将对前面的例子进行计算。这里我们使用追踪树来简化每次调用的计算，如下所示。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es kl"><img src="../Images/83ef4f3c7b33a9fb0c12109fc1779b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R21Ht4vJcZ2kuATpKRC5Jg.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">使用追踪树计算时间复杂度</figcaption></figure><p id="7a0f" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">因此，从上面 n =3 的图中可以看出；t(n) = O(1)+O(1)+O(1)+O(1) = O(4)。对于 n = 3，我们可以得出 O(3+1)的结论，即对于 n，时间复杂度是 O(n)。</p><h1 id="eaab" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">循环和递归的区别:</h1><p id="9a86" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">循环和递归的主要区别在于，循环只有前向阶段，也就是说，它为每次迭代执行一条语句。而递归函数具有前向和后向阶段，如前所述。</p><p id="af68" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">除此之外，递归函数的内存利用率比循环更高。每次调用递归函数都会创建一个新的激活记录，因此可能会导致堆栈溢出。然而，循环只有一个在运行时执行时创建的激活记录。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es km"><img src="../Images/1cab5a8868ed24cf61e523a866d7cefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*_vvLtd4ofXJe0md76oD7Kg.jpeg"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">循环上递归函数的栈利用</figcaption></figure><p id="f596" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">如图所示，对于 n =3，创建了 4 个激活记录，即，对于每个调用，利用比“for”或“while”循环更多的存储器来创建堆栈中的新激活记录。</p><h1 id="0d1d" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">递归的类型:</h1><p id="c887" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">递归可以根据函数内部函数调用的方式来分类。所以这里有一些可以帮助你更好地理解它。</p><h2 id="38b2" class="kn iq hi bd ir ko kp kq iv kr ks kt iz ho ku kv jd hq kw kx jh hs ky kz jl la bi translated">尾部递归:</h2><p id="a294" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">在调用自身之前执行所有操作或语句的递归函数称为尾递归。这里定义了一个函数，使得一些输入输出语句的操作或执行在调用自身之前完成，或者对自身的函数调用是代码流中的最后一个操作。在尾部递归中，我们观察递归的前向阶段。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lb"><img src="../Images/707c00e6e67de8728c76eba8b9e32c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFQ55hEGJ4M9RXv3a1OzUg.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">尾部递归</figcaption></figure><h2 id="4e29" class="kn iq hi bd ir ko kp kq iv kr ks kt iz ho ku kv jd hq kw kx jh hs ky kz jl la bi translated">头部递归:</h2><p id="4205" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">头递归与尾递归完全相反，这里对自身的函数调用通常是执行的第一条语句，随后是其他操作或输入输出语句。在 head 递归中，我们观察递归的反向阶段。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lc"><img src="../Images/38ade4fd127ccf35e56c4c54fa1b1057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaB4f1A2MkEg8sAKlP19BA.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">头部递归</figcaption></figure><h2 id="2dc3" class="kn iq hi bd ir ko kp kq iv kr ks kt iz ho ku kv jd hq kw kx jh hs ky kz jl la bi translated">树递归:</h2><p id="68c9" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">树递归是指函数多次调用自身。这里我们观察正向和反向阶段，当第一个函数调用被设置为真时，第二个函数调用在返回或反向阶段被调用。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ld"><img src="../Images/0539e187f0dc7a789a86ce4135759048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkKJhD8RXyB3P3KI_JmWWA.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">树递归</figcaption></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es le"><img src="../Images/258a474c4b76f116d3f3f128ac786209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msEy3FzkKhtjGY82szDL7A.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">树递归的追踪树</figcaption></figure><p id="19ad" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">其中 n =3 的树递归函数的跟踪树图像解释了输出“3 2 1 1 2 1 1”是如何实现的。</p><h2 id="a41f" class="kn iq hi bd ir ko kp kq iv kr ks kt iz ho ku kv jd hq kw kx jh hs ky kz jl la bi translated">间接递归:</h2><p id="e540" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">当两个函数“付娜”和“funB”相互调用，直到一个条件失败或设置为真/假，这就是间接递归。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lf"><img src="../Images/d5ff1d1985fc1a59ed793149ba7e0445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx7bDjU1F4TWPmlgIFB_Ww.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">间接递归</figcaption></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ki"><img src="../Images/27170bd806469e6cfad7d1d171e38ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*18s_9yeXxT5w5v1qyf7wBw.jpeg"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">间接递归追踪树</figcaption></figure><p id="93a8" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">上面的例子分别有两个函数“recursive_fun()”和“recursive_fun1()”,它们相互调用导致间接递归。注意“n”的值只是传递给一个函数。</p><h2 id="dd04" class="kn iq hi bd ir ko kp kq iv kr ks kt iz ho ku kv jd hq kw kx jh hs ky kz jl la bi translated">嵌套递归:</h2><p id="b0d9" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">当一个函数调用作为参数传递给它自己时，这样的函数被称为嵌套递归。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lg"><img src="../Images/5b54d4911fc80ebfe92700ce95501329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7Q2qBAYTPQpx82mrBB5Zg.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">嵌套递归</figcaption></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lh"><img src="../Images/1f8a3eb1bc996f5d0140d6a6c5ba2c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbHYtQpu5rs0tmsdjr7O8g.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">嵌套递归的跟踪树</figcaption></figure><p id="1a76" class="pw-post-body-paragraph hz ia hi hj b hk hl ib ic hm hn id ie ho if ig ih hq ii ij ik hs il im in hu hb bi translated">在上面的例子中，它显示了函数调用的返回如何成为它自己的函数调用的参数或自变量，以获得期望的输出。这种递归操作被称为嵌套递归。</p><h1 id="0bcb" class="ip iq hi bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论:</h1><p id="e5aa" class="pw-post-body-paragraph hz ia hi hj b hk jn ib ic hm jo id ie ho jp ig ih hq jq ij ik hs jr im in hu hb bi translated">递归可以用来解决许多复杂的问题，从“汉诺塔”到最简单的“阶乘问题”。现在我只能说，当条件设置不正确时，递归可能非常有用，也可能非常具有破坏性。我希望我简化递归的真诚尝试已经帮助你理解并使用了它。</p></div></div>    
</body>
</html>