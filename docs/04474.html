<html>
<head>
<title>Implementing a Graph bipartite checker in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现图的二分检查器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementing-a-graph-bipartition-checker-in-python-364b619a3d29?source=collection_archive---------5-----------------------#2020-03-21">https://medium.com/analytics-vidhya/implementing-a-graph-bipartition-checker-in-python-364b619a3d29?source=collection_archive---------5-----------------------#2020-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aeebe346e65b7cc216bf467c6b7a2ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bfDv-jAMeso4QBsI"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">艾莉娜·格鲁布尼亚克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="03dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名软件开发人员，我试着制定一个例行程序，其中包括练习我解决数学/算法问题的技能。几天前，我发现了一个名为Code Jam的Google年度代码竞赛，我看到的第一个问题就让我迷惑不解(我会谈到它)。经过一些研究，我能够通过图二分检查算法来解决它，并决定写下我得出解决方案的路径。<br/>我们开始吧。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="51f5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">图表</h1><p id="1275" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">图是数学中众所周知的非线性抽象数据结构。它们用于通过节点(或简称为<em class="ld">“点”</em>)和边(也称为<em class="ld">“链接”</em>或<em class="ld">“线”</em>，连接两个节点<em class="ld">)</em>【1】【2】)的结构/概念对对象之间的成对关系进行建模。对图形及其性质的研究被称为图论，是由一位才华横溢的数学家于1936年开发的，他写了第一本关于图论的书。图形用于模拟现实世界中发生的许多情况，如从x到y的最有效的飞机路径或城市两点之间的最短距离(GPS算法)，等等。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f29a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题是</h1><p id="b9de" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">2014年研究生考试-练习赛。</p><p id="50a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">坏马问题<br/>T17】作为邪恶联盟的首领，坏马有很多问题要处理。最近，联盟中有太多的争论和太多的暗箭伤人，以至于“坏马”决定将联盟分成两个部门，以便将麻烦的成员分开。作为罪恶的纯种马，坏马不会把他宝贵的时间花在自己想办法分裂团员上。这就是他让你——他忠诚的亲信——做的事。</strong></p><blockquote class="le lf lg"><p id="0b45" class="iv iw ld ix b iy iz ja jb jc jd je jf lh jh ji jj li jl jm jn lj jp jq jr js hb bi translated"><a class="ae iu" href="https://code.google.com/codejam/contest/2933486/dashboard" rel="noopener ugc nofollow" target="_blank">https://code.google.com/codejam/contest/2933486/dashboard</a></p></blockquote><h1 id="0d2d" class="ka kb hi bd kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx bi translated"><strong class="ak">解决方案</strong></h1><p id="69d3" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">读完描述后，在开始编写可能的解决方案之前，我想到了一些想法。</p><p id="29ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我将不得不<strong class="ix hj">存储一对的名字</strong>和以某种方式<strong class="ix hj">代表然后</strong>之间的关系。此外，我必须能够检查将配对分成2组的可能性——没有配对应该在同一个组中。通过更多的搜索，我发现这是<strong class="ix hj">图二分图</strong>的经典问题。</p><blockquote class="le lf lg"><p id="2255" class="iv iw ld ix b iy iz ja jb jc jd je jf lh jh ji jj li jl jm jn lj jp jq jr js hb bi translated">我已经意识到这是开始用超级黑客风格编码前的重要一步。分析它，进入问题的头脑。</p></blockquote><h1 id="7669" class="ka kb hi bd kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx bi translated">偶图</h1><p id="3711" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">二部图是这样一种图，它的所有节点可以分成两组，使得一组中的每个元素只与另一组中的元素相关。它也被称为双色图(每个组代表一种颜色，所以图中的每个元素只与另一个颜色元素相关)。它们在Petri网(并发系统资源模拟)和其他真实世界情况中非常常用[4]。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/1cbf0ba053ee17660767a9204d66165c.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*N_9gwjfzOsKrblWmhzqvhg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">二分图示例</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="66d6" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">算法</h1><p id="8c64" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">检查图二分的算法可以非常类似于树数据结构中的DFS(深度优先搜索)。DFS算法它被用来寻找树的深度，通过选择根元素并深入到它们的邻居，直到没有元素的子元素或叶子。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/c3c23d24e151b6f23a3c9da198baa86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/1*SE0iNV24-6hkUCZ-9-inFA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">DFS算法如何工作</figcaption></figure><blockquote class="le lf lg"><p id="6236" class="iv iw ld ix b iy iz ja jb jc jd je jf lh jh ji jj li jl jm jn lj jp jq jr js hb bi translated">奇怪的事实:每棵树都是一个二分图</p></blockquote><p id="4454" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了增加二分检查的功能，我们需要启动另一个结构来存储每个元素的组(或颜色)信息。除此之外，在给定相邻组的情况下，还需要检查属于每个图节点的组</p><p id="9878" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解，伪代码分析将分为两部分。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="8ef0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">伪代码—控制器</h1><p id="070f" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们来检查一下伪算法。</p><p id="b135" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一部分将作为一个初始化或“控制器”,确保程序将为图中的所有节点执行。</p><blockquote class="le lf lg"><p id="55fa" class="iv iw ld ix b iy iz ja jb jc jd je jf lh jh ji jj li jl jm jn lj jp jq jr js hb bi translated">为了解释伪代码，我将假设以下常量</p><p id="2762" class="iv iw ld ix b iy iz ja jb jc jd je jf lh jh ji jj li jl jm jn lj jp jq jr js hb bi translated">V =图形节点<br/> C1 =第01组值<br/>图形=代码表示的数据结构<br/> C2 =第02组值</p></blockquote><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="cff5" class="ma kb hi lw b fi mb mc l md me">FOR each graph node V<br/>    Initialize V group value C = C1<br/>end FOR</span><span id="8417" class="ma kb hi lw b fi mf mc l md me">FOR every graph node V<br/>    IF group C is C1:<br/>        IF NOT SET_GROUP_VALUE(graph, V, C1)<br/>            return FALSE<br/>        end IF<br/>    end IF<br/>end FOR</span><span id="b8cb" class="ma kb hi lw b fi mf mc l md me">return TRUE</span></pre><p id="8241" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一次循环中，我们将用group 01值初始化所有节点。在第二次循环中，对于每个具有group 01值的节点，我们将检查它的邻居，如果可能的话，为它设置一个不同的组值。</p><h1 id="d319" class="ka kb hi bd kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt lo kv kw kx bi translated">伪代码—递归搜索</h1><p id="adf8" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">第二部分是递归算法，它包含检查一个节点是否属于与其邻居不同的组的逻辑</p><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="25a5" class="ma kb hi lw b fi mb mc l md me">-- Start a routine SET_GROUP_VALUE(graph, V, C) -- Ignore this line</span><span id="fc1f" class="ma kb hi lw b fi mf mc l md me">SET the group of V as C</span><span id="ee01" class="ma kb hi lw b fi mf mc l md me">FOR every neighbors W of V<br/>    IF group value C of W is neutral<br/>        IF NOT SET_GROUP_VALUE(graph, W, C2)<br/>            return FALSE<br/>        end IF<br/>    ELSE<br/>        IF group value of W is C<br/>            return FALSE<br/>        end IF<br/>    end ELSE<br/>end FOR</span><span id="83a6" class="ma kb hi lw b fi mf mc l md me">return TRUE</span></pre><p id="c20e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个循环开始深入V个节点的子集(根在V中的子树)。如果V的邻居W具有组01值，那么算法将检查是否有可能给出组02值。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="bc19" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">履行</h1><p id="26ff" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如问题中所述，我们的目标是执行文件中描述的<strong class="ix hj"> M </strong>元素对的<strong class="ix hj"> T </strong>测试用例。该文件的第一行将包含<strong class="ix hj"> T </strong>值，后跟<strong class="ix hj"> M </strong>对的数量，因此，接下来的<strong class="ix hj"> M </strong>行将包含<strong class="ix hj"> M </strong>对信息。输出也将是一个文件，描述测试用例编号，以及是否可以将一组<strong class="ix hj"> M </strong>对名称分成两组，或者，是否可以将一组对表示为一个二分图。</p><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="4533" class="ma kb hi lw b fi mb mc l md me">-- Input file example -- Ignore this line</span><span id="55ac" class="ma kb hi lw b fi mf mc l md me">2<br/>1<br/>Dead_Bowie Fake_Thomas_Jefferson<br/>3<br/>Dead_Bowie Fake_Thomas_Jefferson<br/>Fake_Thomas_Jefferson Fury_Leika<br/>Fury_Leika Dead_Bowie</span><span id="88a3" class="ma kb hi lw b fi mf mc l md me">-- Output file example -- Ignore this line</span><span id="0850" class="ma kb hi lw b fi mf mc l md me">Case #1: Yes<br/>Case #2: No</span></pre><p id="f16c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在代码[5]中有一些表示图的方法，其中一种是邻接矩阵，这就是它在本文中的表示方式，但是做一些小的修改，这个解决方案也可以工作。在这里，我将把它表示为一个python字典:键是节点，键的值是所有邻居的列表。这里有一个例子</p><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="ded4" class="ma kb hi lw b fi mb mc l md me">g = { <br/>    “a” : [“d”],<br/>    “b” : [“c”],<br/>    “c” : [“b”, “c”, “d”, “e”],<br/>    “d” : [“a”, “c”],<br/>    “e” : [“c”],<br/>    “f” : []<br/>}</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e607" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">密码</h1><p id="1277" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">让我们检查一下我的伪代码实现。</p><blockquote class="le lf lg"><p id="6f8d" class="iv iw ld ix b iy iz ja jb jc jd je jf lh jh ji jj li jl jm jn lj jp jq jr js hb bi translated">OBS:颜色=组值</p></blockquote><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="fdf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从第1行到第27行实现了我们之前在伪代码中看到的算法。在第31行，我从输入文件(在这个代码的同一个目录中)中得到将要完成的测试的数量。</p><p id="343e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从第35行到文件末尾，我们将:</p><ul class=""><li id="0d82" class="mi mj hi ix b iy iz jc jd jg mk jk ml jo mm js mn mo mp mq bi translated">对于每个测试用例(<strong class="ix hj"> iTestCase </strong>)，检索将要被分析的对的数量(<strong class="ix hj">n对</strong>)。</li><li id="e322" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">对于每一对，我们将得到描述的名字。</li><li id="f0d1" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">从第40行到第50行，它将根据文件中描述的pair连接来构造字典。</li></ul><p id="6ab5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出告诉我们哪个测试用例是否代表二分图</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="75e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我是巴西的一名初级软件开发人员，我对技术和编程非常着迷。</p><p id="1a0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以请，任何疑问，提示或评论都非常欢迎！</p><p id="e6c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" href="https://github.com/IranNeto" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae iu" href="https://twitter.com/IranMacedo3" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae iu" href="https://www.linkedin.com/in/iran-macedo-bezerra-neto/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>中关注我</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="9858" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">参考</h1><p id="dab2" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">[1]https://mathworld.wolfram.com/Graph.html<br/>[2]https://en.wikipedia.org/wiki/Graph_theory<br/>[3]https://pt.wikipedia.org/wiki/D%C3%A9nes_K%C3%B6nig<br/>[4]https://pt.wikipedia.org/wiki/Grafo_bipartido<br/>[5]https://www . geeks forgeeks . org/graph-and-its-representations/</p></div></div>    
</body>
</html>