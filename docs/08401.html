<html>
<head>
<title>Encrypted Computations, Implementation Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密计算、实现技巧</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/encrypted-computations-implementation-tricks-fd78d6c140ad?source=collection_archive---------9-----------------------#2020-07-28">https://medium.com/analytics-vidhya/encrypted-computations-implementation-tricks-fd78d6c140ad?source=collection_archive---------9-----------------------#2020-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db020974acff2466a25312f8a37ca11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*s48kLwNL2TOMsYg2qTDvHQ.jpeg"/></div></div></figure><p id="bb35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个帮助软件开发人员和数据科学家构建解决方案的指南，这些解决方案使用全同态加密(FHE)对加密数据执行一些计算。</p><p id="3488" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">全同态加密有许多应用。例如，它允许对搜索引擎进行私人查询，它可以对私人数据进行数据分析，提高选举的透明度。</p><p id="f0f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FHE有几个很棒的模式和实现，在本指南中，我将使用微软海豹突击队库和BFV FHE模式。我准备了笔记本在Google Colab中运行测试，但是你也可以在你的PC上、Docker容器中或者云中使用常规的python IDE。</p><p id="558b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我之前的<a class="ae jo" rel="noopener" href="/@alextmn1/encrypted-computations-using-google-colab-beca92c45f7c">帖子</a>中，我解释了如何在Google Colab上设置海豹突击队-Python并运行几个基本示例，但是设置非常简单，可以在Colab笔记本中用几行代码组合起来。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7c98" class="jy jz hi ju b fi ka kb l kc kd">!git clone -b 3.3.2 https://github.com/Huelse/SEAL-Python</span><span id="55bd" class="jy jz hi ju b fi ke kb l kc kd">!cd SEAL-Python/SEAL/native/src;cmake .;make</span><span id="d16f" class="jy jz hi ju b fi ke kb l kc kd">!pip3 install -r SEAL-Python/requirements.txt</span><span id="7f64" class="jy jz hi ju b fi ke kb l kc kd">!cd SEAL-Python;python3 setup.py install</span></pre><h1 id="735b" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">基本用法</h1><p id="0c39" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">首先，我们需要指定初始化参数:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a1e7" class="jy jz hi ju b fi ka kb l kc kd">from seal import *</span><span id="5fc4" class="jy jz hi ju b fi ke kb l kc kd">poly_modulus_degree = 4096</span><span id="7ea8" class="jy jz hi ju b fi ke kb l kc kd">parms.set_poly_modulus_degree(poly_modulus_degree)</span><span id="47bf" class="jy jz hi ju b fi ke kb l kc kd">parms.set_coeff_modulus(CoeffModulus.BFVDefault(poly_modulus_degree))</span></pre><p id="677a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lh"> poly_modulus_degree </em>的值确定加密方案中的下划线多项式次数，更大的<em class="lh"> poly_modulus_degree </em>使得密文更大，所有操作更慢，但是能够进行更复杂的加密计算。推荐值为1024、2048、4096、8192、16384、32768，但也有可能超出此范围。</p><p id="f90f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们需要设置模数参数。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a874" class="jy jz hi ju b fi ka kb l kc kd">parms.set_plain_modulus(256)</span></pre><p id="00ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">明文模数可以是任何正整数，它决定了明文数据类型的大小和乘法中噪声预算的消耗。为了获得最佳性能，尽量使明文数据类型尽可能小是很重要的。</p><p id="da63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在BFV模式中，每个加密值都有一个噪声预算。在密码文本操作期间，噪声预算被消耗。一旦密文的噪声预算达到零，它就变得太坏而不能被解密。</p><p id="ecac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们定义密钥，加密器和解密器</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b3f0" class="jy jz hi ju b fi ka kb l kc kd">context = SEALContext.Create(parms)</span><span id="2b96" class="jy jz hi ju b fi ke kb l kc kd">keygen = KeyGenerator(context)</span><span id="e6d3" class="jy jz hi ju b fi ke kb l kc kd">public_key = keygen.public_key()</span><span id="7547" class="jy jz hi ju b fi ke kb l kc kd">secret_key = keygen.secret_key()</span><span id="dfc7" class="jy jz hi ju b fi ke kb l kc kd">encryptor = Encryptor(context, public_key)</span><span id="69d8" class="jy jz hi ju b fi ke kb l kc kd">evaluator = Evaluator(context)</span><span id="5fd6" class="jy jz hi ju b fi ke kb l kc kd">decryptor = Decryptor(context, secret_key)</span></pre><p id="72da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">公钥用于加密，它是完全开放的(公开的)，因此任何人都可以加密，而私钥是私有的，因为它用于解密数据。</p><h1 id="f079" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">加密计算</h1><p id="f470" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我们首先需要加密数据。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="49ba" class="jy jz hi ju b fi ka kb l kc kd">enc1 = Ciphertext()<br/>enc2 = Ciphertext()<br/>enc3 = Ciphertext()</span><span id="f364" class="jy jz hi ju b fi ke kb l kc kd"># hex numbers<br/>encryptor.encrypt(Plaintext("A1"), enc1)<br/>encryptor.encrypt(Plaintext("2E"), enc2)<br/>encryptor.encrypt(Plaintext("3E"), enc3)</span></pre><p id="903a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，我们有3个加密的十六进制值0xA1、0x2E、0x3E。让我们做一个加法和一个乘法。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1f66" class="jy jz hi ju b fi ka kb l kc kd">evaluator.add_inplace(enc1, enc2)<br/>evaluator.multiply_inplace(enc3, enc2)</span></pre><p id="1937" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FHE只支持乘法加法和子结构，所以如果你需要除以一个数，你必须先把它反过来，然后再用乘法。此外，不要忘记所有的计算都是在我们定义的纯文本模数256或0x100(十六进制)内执行的，因此实际结果看起来像这样:</p><p id="bfff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">#(0xa 1+0x2E)mod 0x 100 = 0x cf<br/>#(0x2E * 0x3E)mod 0x 100 = 0x 24(在mod操作之前为0xB24)</p><h1 id="a245" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">重新线性化</h1><p id="d097" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">这是一种在相乘后将密文的大小减小到初始大小的操作。您还需要为它创建一个特殊的密钥。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="c5ac" class="jy jz hi ju b fi ka kb l kc kd">relin_keys = keygen.relin_keys()</span><span id="bb22" class="jy jz hi ju b fi ke kb l kc kd">print(“size of enc3 value before Relinearization: “ + str(enc3.size()))</span><span id="1589" class="jy jz hi ju b fi ke kb l kc kd">evaluator.relinearize_inplace(enc3, relin_keys)</span><span id="7206" class="jy jz hi ju b fi ke kb l kc kd">print(“size of enc3 value after Relinearization: “ + str(enc3.size()))</span><span id="1a7a" class="jy jz hi ju b fi ke kb l kc kd">&gt;&gt; size of enc3 value before Relinearization: 3 <br/>&gt;&gt; size of enc3 value after Relinearization: 2</span></pre><h1 id="4d3f" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">提高加密计算的速度</h1><p id="9fb6" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">您可以在两个大型阵列上并行应用FHE运算。这被称为<strong class="is hj"> <em class="lh">批处理</em> </strong>，它极大地提高了性能。在批处理中，使用两个向量或值数组，而不是一个值对。</p><p id="0ead" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">批处理是计算加密数字的推荐方式。</p><p id="e5fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你必须为此使用一个特殊的编码器，叫做<em class="lh">分批编码器</em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b100" class="jy jz hi ju b fi ka kb l kc kd">parms = EncryptionParameters(scheme_type.BFV)</span><span id="be15" class="jy jz hi ju b fi ke kb l kc kd">poly_modulus_degree = 8192</span><span id="7b43" class="jy jz hi ju b fi ke kb l kc kd">parms.set_poly_modulus_degree(poly_modulus_degree)</span><span id="a432" class="jy jz hi ju b fi ke kb l kc kd">parms.set_coeff_modulus(CoeffModulus.BFVDefault(poly_modulus_degree))</span><span id="0d6a" class="jy jz hi ju b fi ke kb l kc kd">batch_encoder = BatchEncoder(context)</span><span id="c0fa" class="jy jz hi ju b fi ke kb l kc kd">slot_count = batch_encoder.slot_count()</span></pre><p id="8be3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">固定大小向量的槽数等于<em class="lh">poly _ modulus _ degree</em>(8192)。您必须在两个向量中设置加密值，然后调用<strong class="is hj">加法</strong>或<strong class="is hj">乘法</strong>操作，该操作将一次性并行执行。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="aff1" class="jy jz hi ju b fi ka kb l kc kd">#encrypt vec #1 ( each number is 7 )<br/>plain_vec1 = <strong class="ju hj">uIntVector( [7] * slot_count )</strong><br/>plain_text1 = Plaintext()</span><span id="5450" class="jy jz hi ju b fi ke kb l kc kd"># encode python matrix in Plaintext<br/>batch_encoder.encode(plain_vec1, plain_text1)</span><span id="1ca0" class="jy jz hi ju b fi ke kb l kc kd"># and encrypt<br/>encrypted1 = Ciphertext()<br/>encryptor.encrypt(plain_text1, encrypted1)<br/></span><span id="e5ed" class="jy jz hi ju b fi ke kb l kc kd">#encrypt vec #2 (  each number is 3 )<br/>plain_vec2 = <strong class="ju hj">uIntVector( [3] * slot_count )</strong><br/>plain_text2 = Plaintext()<br/>batch_encoder.encode(plain_vec2, plain_text2)</span><span id="2639" class="jy jz hi ju b fi ke kb l kc kd">encrypted2 = Ciphertext()<br/>encryptor.encrypt(plain_text2, encrypted2)</span><span id="ebed" class="jy jz hi ju b fi ke kb l kc kd">#  multiply encrypted vectors in parallel<br/><strong class="ju hj"><em class="lh">evaluator.multiply_inplace(encrypted1, encrypted2);</em></strong></span><span id="93d0" class="jy jz hi ju b fi ke kb l kc kd"># decrypt<br/>plain_result = Plaintext()<br/>decryptor.decrypt(encrypted1, plain_result);<br/>pod_result = uIntVector()</span><span id="d6a9" class="jy jz hi ju b fi ke kb l kc kd">batch_encoder.decode(plain_result, pod_result);</span><span id="982c" class="jy jz hi ju b fi ke kb l kc kd"><strong class="ju hj"><em class="lh"># The result should be: 8192 x 7 x 3 = 172032<br/></em></strong>print( f"{pod_result[:3]}...f{pod_result[-3:]} sum: {sum(pod_result)} ")</span><span id="c98b" class="jy jz hi ju b fi ke kb l kc kd">&gt;&gt;&gt; <em class="lh">uIntVector[21, 21, 21]...fuIntVector[21, 21, 21] sum: 172032</em><br/>&gt;&gt;&gt; completed in 0:00:00.112214</span></pre><h1 id="28c4" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">其他技巧</h1><ol class=""><li id="b05b" class="li lj hi is b it lc ix ld jb lk jf ll jj lm jn ln lo lp lq bi translated">比较两个数字</li></ol><p id="b649" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BFV没有提供这样的功能。因此，您必须要求解密加密值，以便进行比较。但是，您可以通过添加一个随机数来对密钥所有者隐藏结果。该协议可能如下:</p><p id="a877" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你有2个加密值:A，B. <br/>生成一个新的随机数N并加密它EN <br/>计算:A-B+EN并请求解密结果= &gt; R <br/>取解密结果并子构造R- N <br/> if (R- N) &gt; 0然后A &gt; B</p><p id="2490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.实现庞大的计算，如数据库FHE搜索</p><p id="b0f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使使用批处理，这样的任务也是一个挑战，因为数据库中可能有数百万条记录，您可能需要对加密数据执行完整扫描，这会影响性能。</p><p id="de7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以做的是使用一些哈希函数来定义一些记录数量较少的桶。如果这些桶仍然太大，你可能想看看cuckoo散列法，它使用两种不同的散列函数来解决冲突。</p><h1 id="bfd0" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">在加密数据上实现私有计算的其他方法</h1><p id="a771" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">FHE是一种非常优雅和安全的方式，即使对于后量子世界来说也是如此。但是FHE的数学很复杂，只限于加法、减法和乘法。</p><p id="0649" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现这种计算的另一种方法可能是软件保护扩展(SGX)，这是一种内置于一些现代英特尔中央处理器(CPU)中的技术。</p><p id="dd9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内存中有一些私有区域，称为enclave，其内容受到保护，不能被enclave本身之外的任何进程读取或保存。CPU有一个由英特尔在制造过程中融合的根对称密钥。</p><p id="b116" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在enclave内部运行的应用程序使用唯一的对称密钥来保护其数据，该对称密钥是使用运行的应用程序的散列作为派生参数从CPU的根对称密钥派生的。</p><p id="6c47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果您更改应用程序，哈希将会不同，应用程序将无法再访问其数据，因为密钥将会不同。</p><p id="2663" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法允许应用程序对操作系统、BIOS或硬件所有者屏蔽数据，并使这些数据仅在enclave内可用，从而实现私有加密计算。</p><p id="a097" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文的Colab笔记本在这里或者我在T2的GitHub库中。</p></div></div>    
</body>
</html>