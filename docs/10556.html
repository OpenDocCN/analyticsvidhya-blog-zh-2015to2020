<html>
<head>
<title>PyTorch LSTMs for time series forecasting of Indian Stocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch LSTMs 用于印度股票的时间序列预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pytorch-lstms-for-time-series-forecasting-of-indian-stocks-8a49157da8b9?source=collection_archive---------0-----------------------#2020-10-24">https://medium.com/analytics-vidhya/pytorch-lstms-for-time-series-forecasting-of-indian-stocks-8a49157da8b9?source=collection_archive---------0-----------------------#2020-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3d0d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用深度学习交互式预测股票轨迹</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ff659cd027c9ca998aef64c6c6737c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKwqs19IIcNLKu_gmNtJcA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由来自<a class="ae jn" href="https://www.pexels.com/photo/black-and-white-business-chart-computer-241544/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae jn" href="https://www.pexels.com/@lorenzocafaro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Lorenzo </a>拍摄</figcaption></figure><p id="b46b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这篇文章的目录如下，点击任何一个项目符号就可以切换到相应的部分</p><ul class=""><li id="1c5f" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><a class="ae jn" href="#5730" rel="noopener ugc nofollow">简介</a></li><li id="fbfd" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#a42b" rel="noopener ugc nofollow">使用 nsepy 提取股票历史数据</a></li><li id="0e3f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#b052" rel="noopener ugc nofollow">管理数据，将其传递给 LSTM 模型</a></li><li id="fda1" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#da88" rel="noopener ugc nofollow">定义 LSTM 模型架构</a></li><li id="9664" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#20f8" rel="noopener ugc nofollow">训练模型</a></li><li id="27e7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#4f34" rel="noopener ugc nofollow">对看不见的数据进行预测</a></li><li id="bb6f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#dc4d" rel="noopener ugc nofollow">结论</a></li><li id="0a2b" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><a class="ae jn" href="#85f9" rel="noopener ugc nofollow">参考文献</a></li></ul></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="5730" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">介绍</h1><p id="57ce" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">时间序列数据已经存在了很长一段时间，许多人对它们进行了研究，并提出了分析数据的方法，以找到有意义的见解，并随后使用它来对该序列在未来将如何发展做出可靠的预测。股票市场投资者利用这些信息来衡量股票的表现，从而做出明智的投资决策。传统的时间序列算法，如 ARIMA，萨里玛，霍尔特-温特的方法等。做好时间序列的建模工作；然而，最近，随着深度学习的出现，递归神经网络在建模序列数据方面越来越受欢迎。</p><p id="22e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于时间序列基本上是一个序列，rnn(特别是 LSTMs)已被证明是有用的建模。在本帖中，我们将使用 streamlit 构建一个仪表板，使用 PyTorch 中的 LSTMs 分析印度股票市场的股票。股票数据将使用 nsepy——一个由 T21 开发和维护的开源 python 库。</p><p id="ba80" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事不宜迟，让我们直入主题吧。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="a42b" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">使用 nsepy 提取股票历史数据</h1><p id="04bb" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">截至目前，印度股市(股票)由 1655 只上市股票组成，该数据可从这里获得<a class="ae jn" href="https://www1.nseindia.com/corporates/content/securities_info.htm" rel="noopener ugc nofollow" target="_blank">。借助于从该站点提取的 csv 文件中的 ticker 列，我们可以使用 nsepy 获得任何上市股票的历史信息，方法是使用包中预定义的<code class="du me mf mg mh b">get_history</code>函数。可以这样做。</a></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="9508" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用户只需提供股票代码信息，以及他们需要该代码的历史数据的起始日期和截止日期。提取的数据是作为 pandas dataframe 获得的，为了便于我们的分析，我们对其中的 date 和 close 列感兴趣。</p><p id="28b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">默认情况下，该函数返回股票历史数据，您也可以通过传递期权类型、执行价格和合同到期日来获得相应股票的期权数据。或者您可以将 futures 参数传递给 true，并传递到期日期来获取期货数据。</p><blockquote class="mk ml mm"><p id="d250" class="jo jp mn jq b jr js ij jt ju jv im jw mo jy jz ka mp kc kd ke mq kg kh ki kj hb bi translated">nsepy 库是一个方便的库，具有编写良好的函数，对任何想要对股票数据进行分析的人都有帮助。这里有更多关于<a class="ae jn" href="https://nsepy.xyz" rel="noopener ugc nofollow" target="_blank">的信息</a>。</p></blockquote></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="b052" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">管理数据并将其传递给 LSTM 模型</h1><p id="064b" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">一旦我们从网站上获得数据，它看起来就像这样。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/dc7321a024edbf0f8fc00693f5c5c521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIguyxq_789bMEQFWJzacw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">SBI 股票数据</figcaption></figure><p id="bcfb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将使用上表中的日期和收盘字段，即我们将建立一个 LSTM 模型，该模型预测给定前 n 天的收盘值，当天的收盘值是多少。我们过去所看到的级数通常被称为滞后数或简称为滞后数。我们将把它作为用户的输入，这样他们就可以用它做实验，自己去看。</p><p id="31af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您需要遵循一系列步骤来将这些数据转换成可以在 pytorch 模型中加载的格式。这是按时间顺序排列的。</p><ul class=""><li id="7535" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">从上面显示的数据帧中提取感兴趣的列。(关闭和日期列)。</li><li id="2f38" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">将数据帧下移滞后次数，并删除第一批滞后行。这将为我们提供列格式的输入输出对。然后，可以将它转换为输入的元组列表和股票价格输出值的浮点数列表。其逻辑在下面的函数中定义。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><ul class=""><li id="e2c0" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">为了向 pytorch 中的模型提供数据，我们需要创建一个 dataloader，它可以生成成批的输入和输出。Pytorch 支持构建我们自己的定制数据类，并在其上包装一个数据加载器，以便按照我们的意愿向模型提供数据。<br/>因此，我们将扩展 Dataset 类并定义我们自己的类，如下所示。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><ul class=""><li id="3359" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">上面的关键函数是 get item 函数，它提供输入和输出。因为 pytorch 模型只接受数据类型为 pytorch 张量的数据，所以我们将它们从列表中包装成 torch 张量。由于价格是十进制数字，我们小心翼翼地将数据包装成浮点张量。</li></ul><blockquote class="mk ml mm"><p id="5ddc" class="jo jp mn jq b jr js ij jt ju jv im jw mo jy jz ka mp kc kd ke mq kg kh ki kj hb bi translated">在任何机器学习算法中，在以前看不见的数据上验证我们的数据集是很重要的，以确保我们建立的模型没有记住训练数据，这将导致我们错误地认为我们的模型表现得非常好，而事实上它并不是这样(过度拟合)。</p></blockquote><ul class=""><li id="7fd6" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">为了解决上述事实，我们使用训练集中的 70%数据和验证集中的 30%数据来执行训练验证分割。</li><li id="1bcd" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">另一个非常重要的方面，尤其是从深度学习的角度来看，是避免协变量的变化。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/980efc1a5dc11c67f8140ab235864b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*pa9qn90eEzmhQfenngErEA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片由 Vinayak 提供</figcaption></figure><p id="7c9d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们在一个预测模型中有一个以上的特征时，可能或者更确切地说，大多数情况下，它们具有不同的分布，并且处于完全不同的尺度上。正因为如此，随着损失分布趋于不均匀，神经网络试图优化的成本函数变得更加困难。相反，如果我们将这两个分布带到一个均匀的尺度，误差分布变得均匀，这有助于神经网络更好地优化成本函数。实现这一点的一种方法是输入数据的标准化，原则上，将所有输入参数转换为平均值为 0，标准偏差为 1。在网络的不同层内部，使用批量标准化来避免协变量移位问题。因此，以下功能根据输入(即列车分布)对数据进行标准化。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><ul class=""><li id="c62d" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">在将数据分成训练和验证数据集并随后对其进行标准化之后，我们将创建 pytorch 数据加载器，以便加载数据并在稍后将其提供给 pytorch 模型。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="2c66" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经以必要的格式准备好了所有的数据，我们将切换到定义一个预测股票价格的 LSTM 模型。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="da88" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">定义 LSTM 模型架构</h1><p id="021d" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">LSTM 或长期短期记忆的缩写是一种递归神经网络，用于模拟涉及序列的问题。序列问题可能有几种输入输出用例，如一对一(单词翻译)、一对多(图像字幕生成)、多对多(语言翻译)；但是我们的情况是多对一的，即给定一个输入列表，我们预测一个输出。</p><p id="9c2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于长度相当短的序列(每条记录少于 15-20 个单位)，LSTMs 在解码相关性并捕获它们以建立一个稳健的模型方面做得很好，但是由于消失梯度问题，它们不能捕获长期相关性；当我们回顾模型预测时，我们将再次讨论这个问题。</p><p id="7c22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们专注于创建一个 LSTM pytorch 模型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="300e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们看到的，我们的模型由一个 LSTM 层和两个完全连接的线性层组成。</p><p id="0995" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">LSTM 层需要一个三维输入的形式</p><pre class="iy iz ja jb fd mt mh mu mv aw mw bi"><span id="10ee" class="mx lg hi mh b fi my mz l na nb"><em class="mn">(seq_len, batch, input_size)</em></span></pre><p id="2c72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">批处理大小是一个可以在训练时设置的训练超参数，seq_len 和输入大小是我们需要从数据加载器中了解的两个参数。因为我们要查看 n_lags 历史股票价格，我们的 seq_len 是 3，我们只查看一个特征，即股票价格，所以我们的 input_features 只有 1。</p><p id="d51c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的隐藏和单元状态也被定义为全零(它们也可以在训练开始时被定义为随机数)。</p><p id="01fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">forward 方法包含通过网络向前传播的逻辑。我们通过 LSTM 层传递输入，然后通过完全连接的层；随后是一个批量标准化层，以防止内部协变量偏移和非线性 ReLU 激活层。最后，我们将它传递给输出估计层，它给出了预测的股票价格。</p><p id="f92a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">predict 方法只是实现了正向传递，但由于我们只需要预测，而不想进行任何反向传播，因此关闭了梯度跟踪功能。</p><p id="6234" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这只是一个基本的架构，可以根据问题的需要进行调整和修改。随意添加或减去完全连接的层，改变隐藏的尺寸和 LSTM 层内隐藏层的数量，并使用更多你认为合适的脱落层。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="20f8" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">训练模型</h1><p id="4bd2" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">我们现在已经到了训练模型的关键部分。在开始训练之前，我们必须定义许多超参数，在这里，我们将使用 streamlit 来允许用户交互式地定义这些超参数。其中一些是批量大小、学习速率、优化器、隐藏层的数量、隐藏层中的神经元等。</p><p id="abae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦选择了这些，您就可以点击提交按钮来查看运行中的模型火车。这里有一个这样的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/52e4f853064b69acbd6aac0a5504b7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qdgas4Mb4q3lFeeLujVjyA.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">运行中的简化应用</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="04d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将训练生成器中的数据循环 n _ epochs 次来训练模型。</p><p id="f420" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在每个时代，</p><ul class=""><li id="5610" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">我们在上面创建的训练生成器中循环数据，并使用均方误差(MSE 损失函数)来优化模型，以适当地预测股票价格。</li><li id="8fb7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">我们循环验证生成器，以评估到目前为止训练的模型的性能，并计算其损失。</li><li id="0434" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">我们存储损失，以便稍后向用户显示，并用于内部审计目的。</li><li id="a941" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">每次向前传递后，都会计算损耗，当优化器向最小值方向迈出一步时，损耗会通过网络反向传播。在新批次的损失反向传播之前，我们必须谨慎地将梯度覆盖为零，然后计算该批次的平均损失。简而言之，这是大部分 pytorch 网络遵循的训练循环，这里或那里有一些变化。</li></ul></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="4f34" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">根据看不见的数据做出预测</h1><p id="18bf" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">一旦我们有了一个训练好的模型，我们现在就可以对以前未见过的数据执行预测，这些数据是我们在训练开始时作为验证数据保留的。我们将这样做，并绘制它来分析该模型的性能。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/3bffec043260658980f0a61874ea1d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A22VqyZ0xLW314pMOKVXkA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ACC 股票的时间序列预测</figcaption></figure><p id="bfcb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个模型的结果，该模型的数据对应于从 2020 年 1 月 1 日到 2020 年 10 月 15 日的 ACC 股票，滞后为 8，隐藏层为 100，使用 2 个隐藏 LSTM 层训练 100 个时期。我们可以看到，该模型已经获得了股票价格的整体趋势，但它非常不稳定，即它大大高估了价格的变化。此外，如果你很敏锐，你可以观察到，在某些情况下，预测滞后于实际事件，即如果今天有一个突然的跳跃，预测将显示明天的跳跃，等等。</p><p id="479e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">蓝线分隔了训练和验证数据集；线的左侧是训练数据及其预测，线的右侧是验证数据及其各自的预测。我们可以看到，验证和训练预测在行为上非常相似，这是一个好迹象，因为它在可见和不可见数据的预测模式中是一致的。</p><p id="14e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这需要大量的超参数调整，人们可以通过强力/有组织的方式来查看哪种参数配置最适合哪种股票行情自动收录器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/0cc736bf49eeb5bd1ff5a43f95d59af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnJmuLCwuXyS4Hex1tKuiA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">股票预测应用程序的仪表板</figcaption></figure><p id="86e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是我使用<a class="ae jn" href="https://www.streamlit.io/" rel="noopener ugc nofollow" target="_blank"> streamlit </a>构建交互式仪表盘的原因。它们为使用滑块、下拉菜单等构建交互式仪表盘提供了强大的支持。；所有这些都不需要知道任何 HTML，CSS 和 JavaScript，这是非常可怕的。点击这里查看他们的<a class="ae jn" href="https://medium.com/streamlit" rel="noopener">媒体出版物，了解更多令人惊叹的可视化内容。</a></p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="dc4d" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">结论</h1><p id="4008" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">所以，这个帖子到此为止。在这篇文章中，我们学会了</p><ul class=""><li id="a1df" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">使用 nsepy 提取与印度股票相关的股票代码信息。</li><li id="bb77" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">在 pytorch 中创建一个 LSTM，并使用它构建一个包含一个变量的基本预测模型。</li><li id="037b" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">使用 streamlit 以交互方式试验模型的超参数，以使其变得更好。</li></ul><p id="688d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望你喜欢这篇文章，并从中学到一些东西。如果你想更深入地研究，请参阅参考资料部分，获取更多关于本文主题的文章。这篇文章的所有代码也可以在参考资料部分找到。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="85f9" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">参考</h1><ol class=""><li id="d959" class="kk kl hi jq b jr lx ju ly jx nf kb ng kf nh kj ni kq kr ks bi translated"><a class="ae jn" href="https://blog.floydhub.com/long-short-term-memory-from-zero-to-hero-with-pytorch/" rel="noopener ugc nofollow" target="_blank">LSTMs——零到英雄由 FloydHub </a></li><li id="99d3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj ni kq kr ks bi translated"><a class="ae jn" href="https://nsepy.xyz/" rel="noopener ugc nofollow" target="_blank"> nsepy 官方文档</a></li><li id="aa0a" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj ni kq kr ks bi translated"><a class="ae jn" href="https://github.com/ElisonSherton/TimeSeriesForecastingNN" rel="noopener ugc nofollow" target="_blank">该帖子的 Github 代码</a></li><li id="aeef" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj ni kq kr ks bi translated"><a class="ae jn" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">如何通过机器学习掌握开发用于时间序列预测的 LSTM</a></li></ol></div></div>    
</body>
</html>