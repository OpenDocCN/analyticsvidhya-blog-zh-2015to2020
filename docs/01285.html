<html>
<head>
<title>Playing with Scala — Implementing Filters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scala——实现过滤器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/playing-with-scala-implementing-filters-c1ec5ccd6528?source=collection_archive---------12-----------------------#2019-10-12">https://medium.com/analytics-vidhya/playing-with-scala-implementing-filters-c1ec5ccd6528?source=collection_archive---------12-----------------------#2019-10-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f8b9969c716fd0db7e0c59661975c43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j9Q-A48Mg7MT3hxh"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément H </a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="d8d0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很长一段时间我远离<strong class="ix hz"> Scala，</strong>仅仅是因为我从使用Scala的人那里听到了很多恐怖的故事，以及为什么Java更好。显然，我是根据封面来判断这本书的。Java和Scala是截然不同的两个世界，如果我们试图把它们混在一起，那么产生的代码肯定是令人恐惧的。</p><p id="7f0e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近我开始学习Scala(为了工作),我已经开始喜欢上它了。我尝试了多种实现过滤功能的方法，找到了一些。</p><p id="fa55" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么是<code class="du jt ju jv jw b"><strong class="ix hz">filter</strong></code>？–它根据给定的条件过滤集合。</p><p id="c4f4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它接受一个谓词，该谓词是一个计算结果为<code class="du jt ju jv jw b">true</code>或<code class="du jt ju jv jw b"><strong class="ix hz">false</strong></code>的函数，然后返回给定谓词为真的所有项的集合。</p><p id="612b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于所有的方法，我都使用相同的函数签名。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="ad03" class="kf kg hy jw b fi kh ki l kj kk">def filter[T](predicate: T =&gt; Boolean) (seq: Seq[T]) : Seq[T] = {<br/>  .....<br/>}</span></pre><p id="2798" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">靠近点</strong>看看函数签名。</p><ol class=""><li id="da2f" class="kl km hy ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">它应用于给定的类型<code class="du jt ju jv jw b">T</code>。</li><li id="b3cc" class="kl km hy ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">它接受一个谓词，该谓词是一个接受T类型输入并返回<code class="du jt ju jv jw b">true</code>或<code class="du jt ju jv jw b">false</code>的函数。</li><li id="c8be" class="kl km hy ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">它需要一个类型为<code class="du jt ju jv jw b">T</code>的<code class="du jt ju jv jw b">Sequence</code>，在其上应用过滤器。</li><li id="0a4c" class="kl km hy ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">最后，filter返回类型为<code class="du jt ju jv jw b">T</code>的过滤后的<code class="du jt ju jv jw b">Sequence</code></li></ol><p id="7876" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">方法1: </strong>这在一个<code class="du jt ju jv jw b">Seq</code>上使用标准的<code class="du jt ju jv jw b">collect</code>函数，它只收集那些<code class="du jt ju jv jw b">predicate</code>函数返回<code class="du jt ju jv jw b">true</code>的项目。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="8ed1" class="kf kg hy jw b fi kh ki l kj kk">def filterV1[T](predicate: T =&gt; Boolean) (seq: Seq[T]) : Seq[T] = {<br/>     seq.collect({<br/>       case item if predicate(item) =&gt; item<br/>     })<br/>}</span></pre><p id="f8b2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">方法2: </strong>这种方法对给定序列使用模式匹配，并递归地累加支持给定谓词函数<code class="du jt ju jv jw b">true</code>的项目。为了优化递归，它被设计成尾部递归方式。<code class="du jt ju jv jw b">@tailrec</code>注释用于验证尾部递归行为。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f0f0" class="kf kg hy jw b fi kh ki l kj kk"><strong class="jw hz">def </strong>filterV2[T](predicate: T =&gt; Boolean)(seq: Seq[T]): Seq[T] = {<br/>  @tailrec<br/>  <strong class="jw hz">def </strong>filterInner(acc: Seq[T], originalSeq: Seq[T]): Seq[T] = {<br/>    originalSeq <strong class="jw hz">match </strong>{<br/>      <strong class="jw hz">case </strong><em class="kz">Nil </em>=&gt; acc<br/>      <strong class="jw hz">case </strong>first :: last =&gt; <br/>        <strong class="jw hz">if </strong>(predicate(first)) filterInner(acc :+ first, last) <br/>        <strong class="jw hz">else </strong>filterInner(acc, last)<br/>    }<br/>  }</span><span id="34e0" class="kf kg hy jw b fi la ki l kj kk">  filterInner(<em class="kz">Nil</em>, seq)<br/>}</span></pre><p id="4529" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">方法3: </strong>这里我们在序列上使用了一个名为<code class="du jt ju jv jw b">foldLeft</code>的函数，它采用一个函数来执行折叠操作。只有当谓词为真时，它才会将该项追加到累加器中。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="2de4" class="kf kg hy jw b fi kh ki l kj kk"><strong class="jw hz">def </strong>filterV3[T](predicate: T =&gt; Boolean)(seq: Seq[T]): Seq[T] = {<br/>  seq.foldLeft(<em class="kz">Seq</em>[T]()) {<br/>    (acc, item) =&gt; <strong class="jw hz">if </strong>(predicate(item)) acc :+ item <strong class="jw hz">else </strong>acc<br/>  }<br/>}</span></pre><p id="5bde" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">方法4: </strong>这种方法与方法3非常相似，只是方式相反。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="c07a" class="kf kg hy jw b fi kh ki l kj kk"><strong class="jw hz">def </strong>filterV4[T](predicate: T =&gt; Boolean)(seq: Seq[T]): Seq[T] = {<br/>  seq.foldRight(<em class="kz">Seq</em>[T]()) {<br/>    (item, acc) =&gt; <strong class="jw hz">if </strong>(predicate(item)) acc :+ item <strong class="jw hz">else </strong>acc<br/>  }<br/>}</span></pre><p id="54bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比较这些方法的性能。</p><p id="7ba5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我生成了一个由<strong class="ix hz"> 100k个数字</strong>组成的随机列表，并对每种方法应用了<code class="du jt ju jv jw b">isEven</code>谓词。</p><figure class="jx jy jz ka fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/f24413a58991100b2d642e05f948785d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYnBHiL04lnmnOHpSmzGwQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">性能表</figcaption></figure><p id="9df9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不足为奇的是，标准的<code class="du jt ju jv jw b"><strong class="ix hz">filter</strong></code>函数是最快的，只需要<code class="du jt ju jv jw b"><strong class="ix hz">9ms</strong></code>，但是使用起来并不有趣</p><p id="ec04" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论如何，这是一个有趣的练习。你知道做这件事的更多方法吗？请分享。</p><p id="7e75" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">感谢阅读</strong>，</p><p id="9da6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凯瓦利亚</p></div></div>    
</body>
</html>