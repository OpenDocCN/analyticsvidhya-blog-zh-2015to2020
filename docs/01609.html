<html>
<head>
<title>Models are Root of Django..!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模型是Django的根..！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/models-are-root-of-django-a0c16ea5673a?source=collection_archive---------13-----------------------#2019-11-03">https://medium.com/analytics-vidhya/models-are-root-of-django-a0c16ea5673a?source=collection_archive---------13-----------------------#2019-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/68e6d58b6f87f42520d3ae4dbb9fa1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2YOhpWBI78gqZmckdZoYQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:网络征稿</figcaption></figure><p id="0fe1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在薄弱的基础上，你不可能建造伟大的建筑。戈登·b·欣克利</p><p id="d012" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">模型是ORM的基础。使用Django，您可以将效率提高10倍！就复杂性和及时性而言。但是首先，您必须了解Django是如何处理数据库的！</p><p id="726f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在写模型的时候，我们经常犯错误，因为我们不知道做同一件事情的不同方法，可能是正确的方法。有时，由于糟糕的模型设计，也会导致性能障碍。解决这种障碍是很困难的，因为它需要结构上的改变，我们最终要做大量的迁移来建立和运行东西。</p><p id="12bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我将分享我在Django中创建模型的一些见解。</p><h2 id="2495" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">为正确的事情建立正确的关系！</h2><p id="0055" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated"><em class="js">当第一个表中的一条记录只对应相关表中的一条记录时，使用<em class="js"> </em>一对一字段关系</em>。例如，餐馆只有一个地方供应膳食。对不对…？</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="5222" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而且餐厅不止一个服务员。在这种情况下，我们使用ForeignKey，这是一对多关系的例子！</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a4ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">当一个表中的多条记录与另一个表中的多条记录相关联时，就会出现多对多关系</em>。例如，一个比萨饼可以有许多配料。许多披萨上都有浇头。这是使用<code class="du kz la lb lc b">ManyToManyField</code>的好地方。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="5489" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">索引模型！</h2><p id="af93" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">Django将在任何外键上自动创建一个B树索引。它们将在<em class="js"> where子句</em>中使用。</p><pre class="kt ku kv kw fd ld lc le lf aw lg bi"><span id="67ca" class="jt ju hi lc b fi lh li l lj lk">Asset.objects.filter(id=1)  # filtering on primary key properties<br/>Asset.objects.filter(project__id=1)  # filtering on foreign key properties with where clause</span></pre><p id="8bbb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通常用于搜索和显示的模型，在这种情况下，我们可以使用索引。例如，产品名称(CharField)字段需要对其名称字段进行索引。</p><p id="e1cf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个例子就是<code class="du kz la lb lc b"> models.TextField(db_index = True)</code></p><p id="4364" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将用于<strong class="iw hj">对列属性的过滤:</strong> <code class="du kz la lb lc b">Project.objects.filter(name__contains="Foo")</code></p><p id="4ae9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对外键属性进行过滤的<strong class="iw hj">也是如此:</strong></p><p id="a4d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kz la lb lc b">Asset.objects.filter(project__name__contains="Foo")</code></p><p id="3c31" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个好的规则是，如果你要排序或过滤，它应该被索引。然而，永远记住，在数据库中使用索引是有代价的，所以要明智地使用它。</p><h2 id="6347" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">UniqueConstraint和CheckConstraint</h2><p id="3ba6" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">这两个约束用于模型级别的验证，在模型级别进行验证是最佳实践之一。</p><p id="4c7e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看一个例子，<code class="du kz la lb lc b"><strong class="iw hj">UniqueConstraint(fields=['room', 'date'])</strong></code>它确保每个房间在每个日期只能被预订一次；这个解决方案很贴切！</p><p id="6374" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CheckConstraint顾名思义，它会在保存之前检查值。</p><h2 id="9f10" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">预取相关和选择相关</h2><p id="7a22" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated"><code class="du kz la lb lc b">prefetch_related</code>用于从<em class="js">多对多</em> &amp; <em class="js">多对一</em>关系中预取数据，并从<em class="js">一对一</em>关系等单值关系中选择数据。我们有<code class="du kz la lb lc b">select_related.</code></p><p id="36bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，您构建了一个模型和一个与其他模型有关系的模型。当有请求时，您也会收到对其相关数据的查询。姜戈有优秀的👌从关系中访问数据的机制，如<code class="du kz la lb lc b"><strong class="iw hj">book.author.name</strong></code></p><p id="f832" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是如果不使用<code class="du kz la lb lc b">prefetchd_related</code>和<code class="du kz la lb lc b">selected_related,</code>，Django会为每个关系数据创建一个对数据库的请求。这会导致性能障碍😞。为了克服这些困难，我们有了<code class="du kz la lb lc b">prefetchd_related</code>和<code class="du kz la lb lc b">selected_related </code>的概念😎。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="0283" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">经验法则👍</h2><ol class=""><li id="eabc" class="ll lm hi iw b ix ko jb kp jf ln jj lo jn lp jr lq lr ls lt bi translated">总是在模型级别验证字段</li><li id="de21" class="ll lm hi iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">查询不应该在循环中</li><li id="9388" class="ll lm hi iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">了解查询集的工作原理</li><li id="8c80" class="ll lm hi iw b ix lu jb lv jf lw jj lx jn ly jr lq lr ls lt bi translated">恰当的做法是制作模型方法。这些模型实例将可以访问它所有方法。</li></ol><p id="3c78" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例子:<code class="du kz la lb lc b">get_absolute_url(), __str__(), publish(), get_cost() get_info() calculate_total()</code></p><p id="5172" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">仅此而已。你认为会有其他可能的解决方案吗？请在下面的评论中告诉我。</p><blockquote class="lz ma mb"><p id="eae4" class="iu iv js iw b ix iy iz ja jb jc jd je mc jg jh ji md jk jl jm me jo jp jq jr hb bi translated">Django是一个很好的网络框架，但是我认为，让它成为一个ORM人的好框架😍</p></blockquote><h1 id="7401" class="mf ju hi bd jv mg mh mi jz mj mk ml kd mm mn mo kg mp mq mr kj ms mt mu km mv bi translated">结论</h1><p id="2205" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">我的结论很简单！没有一个坚实的基础，任何有价值的东西你都会遇到困难。模型是钥匙的基础。首先，聪明地工作，最终把它做好。</p><p id="0f1e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你喜欢这篇文章，那就鼓掌吧👏…!</p><p id="fb54" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">回头见，继续编码，玩得开心❤ <br/>贾米勒。</p></div></div>    
</body>
</html>