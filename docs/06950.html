<html>
<head>
<title>COVID-19 Dashboard in Python using Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Streamlit的Python中的新冠肺炎仪表盘</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/covid-19-dashboard-in-python-using-streamlit-aa58581e5a7f?source=collection_archive---------7-----------------------#2020-06-08">https://medium.com/analytics-vidhya/covid-19-dashboard-in-python-using-streamlit-aa58581e5a7f?source=collection_archive---------7-----------------------#2020-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="64c8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Python创建你自己的新冠肺炎跟踪器(如果像我一样，你总是希望用户界面看起来干净美观，还需要一点HTML-CSS)</h2></div><p id="a419" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">冠状病毒的爆发让整个世界陷入了停滞。这为我们提供了一个机会，去做我们一直想做却因为没有时间而不能做的事情。由于我对计算机的兴趣，我一直想创造一些在现实生活中真正有用的东西，并能产生影响。因此，在这个封锁期，当我学习数据分析和机器学习时，我想把我的技能付诸实践，开发一个仪表板，可以帮助人们提高意识，帮助他们了解疫情的强度，并激励他们呆在家里，帮助世界走出这个悲惨的时代。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/4928b2aa42017013ada07de4e8ac3f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDjosx8aCRHAUPFAM0EX0g.png"/></div></div></figure><p id="e168" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我将带您浏览我在创建仪表板时遵循的完整过程。</p><p id="54f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要在进入流程之前查看最终结果，请查看下面的链接:</p><div class="kf kg ez fb kh ki"><a href="https://covid19dashboard-hetavdesai.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">新冠肺炎-仪表板-赫塔夫-德赛</h2><div class="kp l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">covid19dashboard-hetavdesai.herokuapp.com</p></div></div></div></a></div></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="e2c0" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">步伐</h1><ol class=""><li id="2cb1" class="lp lq hi iz b ja lr jd ls jg lt jk lu jo lv js lw lx ly lz bi translated">收集数据。使用可靠且经常更新最新数据的数据源。</li><li id="d90b" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">处理数据。根据分析需要组织数据。</li><li id="b50b" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">清理数据。删除不必要的、重复的和离群的数据。基本上任何种类的数据都有可能在分析中产生错误。</li><li id="cb12" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">分析数据。从数据中创建有意义的可视化。</li><li id="549e" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">以易于阅读和理解的方式呈现分析的解释。</li></ol><h1 id="077b" class="kx ky hi bd kz la mf lc ld le mg lg lh io mh ip lj ir mi is ll iu mj iv ln lo bi translated">使用的包</h1><ol class=""><li id="74f8" class="lp lq hi iz b ja lr jd ls jg lt jk lu jo lv js lw lx ly lz bi translated">熊猫——分析和处理数据</li><li id="a431" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">NumPy —使用数组并执行基本的数学运算</li><li id="d3da" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">创造视觉效果</li><li id="3ab6" class="lp lq hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">Streamlit —增加交互性，并以仪表板格式呈现可视化效果</li></ol><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="9c5b" class="mp ky hi ml b fi mq mr l ms mt">import pandas as pd<br/>import numpy as np<br/>import plotly.graph_objects as go<br/>import streamlit as st</span></pre><h1 id="205e" class="kx ky hi bd kz la mf lc ld le mg lg lh io mh ip lj ir mi is ll iu mj iv ln lo bi translated">数据收集</h1><p id="fb5d" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">我在他们定期更新的GIT存储库上使用了约翰·霍普斯金大学CSSE发布的数据集。下面是<a class="ae mx" href="https://github.com/CSSEGISandData/COVID-19" rel="noopener ugc nofollow" target="_blank">环节</a>。</p><p id="4a11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">pandas库中的<code class="du my mz na ml b">read_csv()</code>函数用于将<code class="du my mz na ml b">.csv</code>数据读入数据帧。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="56e2" class="mp ky hi ml b fi mq mr l ms mt">death_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv')</span><span id="29e3" class="mp ky hi ml b fi nb mr l ms mt">confirmed_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv')</span><span id="dc9c" class="mp ky hi ml b fi nb mr l ms mt">recovered_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv')</span><span id="7209" class="mp ky hi ml b fi nb mr l ms mt">country_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/web-data/data/cases_country.csv')</span><span id="ac1d" class="mp ky hi ml b fi nb mr l ms mt">delta_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/web-data/data/cases_time.csv', parse_dates=['Last_Update'])</span></pre><p id="a795" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看这些数据帧的结构。<code class="du my mz na ml b">confirmed_df.head()</code>给出以下输出。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nc"><img src="../Images/58cab86862e77ef82f1e0d988dbf0322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KN1006mlUTEcWlbquoBAaA.png"/></div></div></figure><p id="94b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据框由从1月22日到当前日期的列组成。其他三个数据帧的结构与此类似。</p><h1 id="4f42" class="kx ky hi bd kz la mf lc ld le mg lg lh io mh ip lj ir mi is ll iu mj iv ln lo bi translated">数据处理和清理</h1><p id="f720" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">让我们把所有的列名都转换成小写，这样更容易访问它们。此外，我们将把<code class="du my mz na ml b">Province/State</code>转换为<code class="du my mz na ml b">state</code>，把<code class="du my mz na ml b">Country/Region</code>转换为<code class="du my mz na ml b">country</code>，以获得更好的可访问性。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="daf0" class="mp ky hi ml b fi mq mr l ms mt">country_df.columns = map(str.lower, country_df.columns)</span><span id="5514" class="mp ky hi ml b fi nb mr l ms mt">confirmed_df.columns = map(str.lower, confirmed_df.columns)</span><span id="83c5" class="mp ky hi ml b fi nb mr l ms mt">death_df.columns = map(str.lower, death_df.columns)</span><span id="1434" class="mp ky hi ml b fi nb mr l ms mt">recovered_df.columns = map(str.lower, recovered_df.columns)</span><span id="f9a4" class="mp ky hi ml b fi nb mr l ms mt">delta_df.columns = map(str.lower, delta_df.columns)</span><span id="db30" class="mp ky hi ml b fi nb mr l ms mt">confirmed_df = confirmed_df.rename(columns={'province/state': 'state', 'country/region': 'country', 'lat': 'lat', 'long': 'lon'})</span><span id="d9f4" class="mp ky hi ml b fi nb mr l ms mt">recovered_df = recovered_df.rename(columns={'province/state': 'state', 'country/region': 'country'})</span><span id="1c56" class="mp ky hi ml b fi nb mr l ms mt">death_df = death_df.rename(columns={'province/state': 'state', 'country/region': 'country'})</span><span id="8104" class="mp ky hi ml b fi nb mr l ms mt">country_df = country_df.rename(columns={'country_region': 'country'})</span><span id="20d6" class="mp ky hi ml b fi nb mr l ms mt">delta_df = delta_df.rename(columns={'last_update': 'date', 'country_region': 'country_name'})</span></pre><h1 id="407e" class="kx ky hi bd kz la mf lc ld le mg lg lh io mh ip lj ir mi is ll iu mj iv ln lo bi translated">数据分析</h1><p id="b70f" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">既然我们已经从可靠的来源获得了频繁更新的数据，并将其转换为易于访问的格式，那么让我们开始分析这些数据。</p><h2 id="0c27" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">计算全球确诊、死亡和康复病例总数</h2><p id="4b59" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated"><code class="du my mz na ml b">country_df</code>列有每个国家的确诊、死亡和康复病例。对每个国家的各个案例求和(即各个列中的值求和)，得出全球各个案例的总数。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="2e7a" class="mp ky hi ml b fi mq mr l ms mt">confirmed_total = int(country_df['confirmed'].sum())<br/>deaths_total = int(country_df['deaths'].sum())<br/>recovered_total = int(country_df['recovered'].sum())</span></pre><h2 id="f653" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">在各种情况下计算当天的增加/减少</h2><p id="e8a9" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated"><code class="du my mz na ml b">confirmed_df</code>、<code class="du my mz na ml b">death_df</code>和<code class="du my mz na ml b">recovered_df</code>最后一列中的值之和给出了当天相应病例的总数。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="6898" class="mp ky hi ml b fi mq mr l ms mt">confirmed_df[confirmed_df.columns[-1]].sum()<br/>death_df[death_df.columns[-1]].sum()<br/>recovered_df[recovered_df.columns[-1]].sum()</span></pre><p id="e592" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且，<code class="du my mz na ml b">confirmed_df</code>、<code class="du my mz na ml b">death_df</code>和<code class="du my mz na ml b">recovered_df</code>的倒数第二列中的值之和给出了前一天相应病例的总数。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="9e46" class="mp ky hi ml b fi mq mr l ms mt">confirmed_df[confirmed_df.columns[-2]].sum()<br/>death_df[death_df.columns[-2]].sum()<br/>recovered_df[recovered_df.columns[-2]].sum()</span></pre><p id="1e7f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将各种情况下的这两个值相减，得到各种情况下美国当天的增加或减少。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="56e5" class="mp ky hi ml b fi mq mr l ms mt">confirmed_today = int(confirmed_df[confirmed_df.columns[-1]].sum() - confirmed_df[confirmed_df.columns[-2]].sum())</span><span id="434e" class="mp ky hi ml b fi nb mr l ms mt">death_today = int(death_df[death_df.columns[-1]].sum() - death_df[death_df.columns[-2]].sum())</span><span id="023d" class="mp ky hi ml b fi nb mr l ms mt">recovered_today = int(recovered_df[recovered_df.columns[-1]].sum() - recovered_df[recovered_df.columns[-2]].sum())</span></pre><h2 id="11e2" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">显示病例数最多的20个国家的表格</h2><p id="bcf2" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">我们将在表格中显示国家名称、最后更新时间、确诊病例、死亡病例和必需病例。<code class="du my mz na ml b">country_df</code>具有将在表格中显示的所需数据。让我们从中提取所需的数据。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="6e13" class="mp ky hi ml b fi mq mr l ms mt">country_stats_df = <br/>country_df[[‘country’, ‘last_update’,’confirmed’, ‘deaths’, ‘recovered’]].sort_values('confirmed', ascending=False)<br/>             .reset_index(drop=True)<br/>             .head(20)</span></pre><p id="c51d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将从<code class="du my mz na ml b">country_df</code>中提取所需的列，按照已确认病例的降序对表格进行排序，并将前20行返回到名为<code class="du my mz na ml b">country_stats_df</code>的新数据框中</p><p id="8086" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经有了需要在表中显示的确切数据，我们将为它添加一些样式，使它更具可读性和更容易解释。我们将把死亡病例列的字体颜色改为红色，恢复病例列的字体颜色改为绿色。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="c09a" class="mp ky hi ml b fi mq mr l ms mt">def highlight_col(x):<br/>  red = 'color: #e73631'<br/>  black = 'color: #000'<br/>  green = 'color: #70a82c'<br/>  df1 = pd.DataFrame('', index=x.index, columns=x.columns)<br/>  df1.iloc[:, 2] = black<br/>  df1.iloc[:, 3] = red<br/>  df1.iloc[:, 4] = green<br/>  return df1</span></pre><p id="41ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将数据帧<code class="du my mz na ml b">x</code>传递给函数，并将其复制到<code class="du my mz na ml b">df1</code>。函数中定义了三种颜色。<code class="du my mz na ml b">iloc</code>功能用于选择数据框中的行和列。第一个参数用于选择行，第二个参数用于选择列。使用<code class="du my mz na ml b">:</code>作为参数表示所有的行/列都被选中。</p><p id="24ab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的函数中，为索引为2、3和4的列的所有行分配各自的颜色。</p><p id="16d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们将这种样式应用到我们的数据框，并将其传递给Streamlit库的<code class="du my mz na ml b">st.table()</code>函数，以显示表格。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="a19c" class="mp ky hi ml b fi mq mr l ms mt">st.table(country_stats_df.style.apply(highlight_col, axis=None).set_properties(**{‘text-align’: ‘left’, ‘font-size’: ‘15px’}))</span></pre><h2 id="5184" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">为病例数最多的10个国家创建条形图竞赛</h2><p id="4c97" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">一个名为“繁荣工作室”的在线工具让创建条形图竞赛变得非常容易。我们需要做的就是将一个<code class="du my mz na ml b">.csv</code>文件加载到工具中，并选择哪一列用作Y轴上的标签，哪一列用作X轴上的值。下面这段代码可以用来将数据导出到名为<code class="du my mz na ml b">latest_confirmed.csv</code>的<code class="du my mz na ml b">.csv</code>文件中，这是fluorescent Studio所要求的。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="f74f" class="mp ky hi ml b fi mq mr l ms mt">latest_confirmed = confirmed_df.groupby(['Country/Region']).sum()<br/>latest_confirmed.to_csv('latest_confirmed.csv')</span></pre><p id="cb6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae mx" href="https://app.flourish.studio/" rel="noopener ugc nofollow" target="_blank">链接到兴旺工作室。</a></p><h1 id="b9ab" class="kx ky hi bd kz la mf lc ld le mg lg lh io mh ip lj ir mi is ll iu mj iv ln lo bi translated">特定国家的统计数据</h1><h2 id="dfa4" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">为国家选择创建下拉列表</h2><p id="5fa4" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated"><code class="du my mz na ml b">list_all_countries = list(confirmed_df[‘country’].unique())</code>创建我们拥有数据的所有国家的列表。</p><p id="300f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du my mz na ml b">country_name = st.selectbox(‘’, list_all_countries, 71)</code>用于创建下拉列表。从下拉列表中选择的任何值都被分配给<code class="du my mz na ml b">country_name</code>。</p><p id="7fb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du my mz na ml b">st.selectbox()</code>接受3个参数。下拉列表的标签、下拉列表的值列表和默认值的索引。我将71作为默认值指数，因为它是印度的指数值。</p><h2 id="45ad" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">计算选定国家的确诊、死亡和康复病例总数</h2><p id="eb33" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">首先，我们从<code class="du my mz na ml b">confirmed_df</code>、<code class="du my mz na ml b">death_df</code>和<code class="du my mz na ml b">recovered_df</code>创建三个新的数据帧，其中仅包含特定国家的数据。</p><p id="b7e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们计算所有三种情况下的当天总计、前一天总计及其当天变化的差异(与之前对世界数据所做的完全一样)。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="nq nr l"/></div></figure><h2 id="ecfd" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">绘制选定国家的确诊、死亡和康复病例趋势图</h2><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="33a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将选定的国家作为参数传递到函数中。标签、颜色、标记尺寸和线条尺寸根据每种情况进行定义。</p><p id="2c6b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">X轴的标签是日期，即从index=4开始的列，Y轴上绘制的值是这些列中所选国家值的总和。</p><p id="b6dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们在<code class="du my mz na ml b">df_list</code>中有3个数据帧，for循环对所有3个数据帧运行，在每次迭代结束时绘制相应情况的图形。</p><h2 id="bd62" class="mp ky hi bd kz nd ne nf ld ng nh ni lh jg nj nk lj jk nl nm ll jo nn no ln np bi translated">绘制选定国家确诊病例数的每日增长图</h2><p id="5f34" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">我们将使用<code class="du my mz na ml b">delta_df</code>来绘制每日确诊病例数的增加情况。</p><p id="eac4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先从<code class="du my mz na ml b">delta_df</code>中提取所需的列:</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="2a11" class="mp ky hi ml b fi mq mr l ms mt">delta_df = delta_df[['Country_Region', 'Delta_Confirmed', 'Last_Update']]</span></pre><p id="1e11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du my mz na ml b">delta_df</code>目前的结构如下图所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ns"><img src="../Images/7312e0ced710e40305c480730e2f66e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*h0lSkJSKD--KBMKBdpF5zA.png"/></div><figcaption class="nt nu et er es nv nw bd b be z dx translated">delta_df的结构</figcaption></figure><p id="1f4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种结构对创造任何情节都毫无用处。我们要么需要日期作为列，要么需要日期作为索引，反之亦然。因此，我们将根据需要旋转桌子。我们将日期设置为索引，国家名称设置为列。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="efee" class="mp ky hi ml b fi mq mr l ms mt">delta_pivoted_df = delta_df.pivot_table(index='date', columns='country_name', values='delta_confirmed', aggfunc=np.sum)</span><span id="7a2b" class="mp ky hi ml b fi nb mr l ms mt">delta_pivoted_df.reset_index(level=0, inplace=True)</span></pre><p id="1e24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du my mz na ml b">delta_df</code>重组后，如下图所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es nx"><img src="../Images/f57c2118adabfbc77eaa5a11ee23db99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*BE2zvvET3RYaIwzpE7O-nA.png"/></div><figcaption class="nt nu et er es nv nw bd b be z dx translated">改变了delta_df的结构</figcaption></figure><p id="48ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们添加了一个名为“世界”的新列，其中包含所有国家的确诊病例总数。</p><pre class="ju jv jw jx fd mk ml mm mn aw mo bi"><span id="c8ee" class="mp ky hi ml b fi mq mr l ms mt">delta_world_df['World'] = delta_pivoted_df[delta_pivoted_df.columns].sum(axis=1)</span></pre><p id="7751" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以使用此数据框绘制一个条形图，其中日期列中的值构成X轴，所选国家/地区列中的值构成Y轴。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="nq nr l"/></div></figure></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="a791" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">结论</h1><p id="6561" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg mu ji jj jk mv jm jn jo mw jq jr js hb bi translated">为了让它简单易懂，我把重点放在了项目的数据科学方面。使用HTML和CSS (Bootstrap)的设计部分不在本博客讨论。你可以在这里查看<a class="ae mx" href="https://github.com/desaihetav/Streamlit-COVID-19-Dashboard/blob/master/app.py" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><p id="311f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非常感谢您阅读这篇文章，如果您发现它有用，请与您的朋友或任何可能从中受益的人分享。</p><p id="3786" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ny">在</em> <a class="ae mx" href="https://www.twitter.com/desaihetav" rel="noopener ugc nofollow" target="_blank"> <em class="ny"> Twitter </em> </a> <em class="ny">，</em><a class="ae mx" href="https://www.linkedin.com/in/desaihetav/" rel="noopener ugc nofollow" target="_blank"><em class="ny">LinkedIn</em></a><em class="ny">或</em><a class="ae mx" href="https://www.instagram.com/desaihetav/" rel="noopener ugc nofollow" target="_blank"><em class="ny">insta gram</em></a><em class="ny">上与我取得联系。</em></p></div></div>    
</body>
</html>