<html>
<head>
<title>Deep Learning Neural Network: Complex vs. Simple Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习神经网络:复杂与简单模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-learning-neural-network-complex-vs-simple-model-88f6dcf88eaa?source=collection_archive---------12-----------------------#2020-10-11">https://medium.com/analytics-vidhya/deep-learning-neural-network-complex-vs-simple-model-88f6dcf88eaa?source=collection_archive---------12-----------------------#2020-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0d68b733e8d609da0b44bd894d7097ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvU4UwoSNCoZ_4h6CEN0wA.png"/></div></div></figure><div class=""/><p id="6202" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近，我写了一篇名为“使用深度学习神经网络从 X 射线图像中检测肺炎”的博客，其中我展示了我从 15 个不同的模型架构中选择的最佳架构的结果，我创建了这些架构来解决一个二元分类问题。对于不熟悉这一点的读者来说，这意味着我的模型将只预测“0”或“1”。“0”对应正常或无肺炎，“1”对应肺炎。</p><p id="2db3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我继续之前，不要担心，如果你没有看过我以前的博客，你不需要它来理解这一个，因为这将有所有必要的信息进行比较，如标题所示，一个复杂的简单模型。</p><p id="5771" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我以前的博客中，我描述了我如何从一个简单的 2 层卷积神经网络(CNN)模型开始，使用最小的参数来解决过拟合问题，并以一个由 5 个卷积块组成的更复杂的架构结束，每个卷积块都有两层，并使用一些超参数来调整模型。</p><p id="fa0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一个模型我称之为 Model_15，它的验证和测试准确率分别为 94.83%和 90.84%。非常好的精度值，但正如我在以前的博客中解释的那样，如果您正在处理每个类中不相等数量的观察值(不平衡)，或者如果您的数据集中有两个以上的类，并且如果您阅读了我的上一篇博客，您已经知道 X 射线数据集非常不平衡，因此，我还应该关注“精度”和“召回”。</p><p id="19a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我只是简要描述了这两个指标，但没有使用任何方程，数学背景，或解释它们在试图解决这个特定的健康相关问题时的重要性。我现在要做的是准备一个带有一些基本理论的上下文，这样读者就可以理解我是如何用更多的时间使用“混淆矩阵”来测试我的不同模型，并且发现我的一个最简单的架构胜过了 Model_15 的复杂性。</p><p id="ab5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，需要理解的是，一般来说，在这两个指标(精度和召回率)之间，精度往往比召回率更重要。为什么？因为更高的精度意味着一个算法返回的相关结果比不相关的结果多，高召回率意味着一个算法返回大部分相关结果(不管是否也返回不相关的)。但这可能会有所不同，取决于你想如何使用这些变量，这种情况下的 X 射线图像分类是其中一个例外，回忆将更加重要，但我会在稍后解释这一点。暂时让我们先试着理解什么是混淆矩阵。</p><p id="9b9e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">混淆矩阵是一种总结分类算法性能的技术，它让您更好地了解什么模型是正确的，什么类型的错误是错误的，换句话说，它显示了您的分类模型在进行预测时是如何被混淆的(图 1)。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es jp"><img src="../Images/b54d1716e3750d92e7f4c79d7090373f.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*POwljSFbI8FFA8cxnzliEg.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图一。一个二类问题的混淆矩阵</figcaption></figure><p id="1791" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图 1 是一个两类问题混淆矩阵的基本例子，其中数字“1”代表阳性(有疾病)，数字“0”代表阴性(没有疾病)。让我们来解读这个简单的矩阵:</p><ul class=""><li id="5cee" class="jy jz ht is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">目标变量有两个值:正值或负值</li><li id="7f78" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">这些行代表实际值</li><li id="1a6e" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">列代表预测值</li></ul><p id="1288" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其实并不太复杂，但现在是矩阵的关键部分，即理解以下四个概念:</p><ul class=""><li id="5c86" class="jy jz ht is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">真正值(TP):预测值与实际值匹配，这意味着实际值为正值，而模型预测值为正值。</li><li id="c779" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">真负值(TN):预测值与实际值匹配，这意味着实际值为负值，而模型预测值为负值</li><li id="5dcc" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">假阳性(FP):预测值被错误预测，这意味着实际值为负，但模型预测值为正。</li><li id="5909" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">假阴性(FN):预测值被错误预测，这意味着实际值为正值，但模型预测值为负值。</li></ul><p id="ce6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在这一点上你不理解前面的概念，没关系，我已经添加了图 2，试图让他们更清楚，所以希望有了这个和这个博客将要讨论的案例，应该足够了。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es km"><img src="../Images/c8df56693e2c9f1be8ad34b9c4d58bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gErtws13_yrSV10M2Le4-A.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图二。混淆矩阵用生病与否来解释</figcaption></figure><p id="21af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们知道了混淆矩阵告诉我们什么，让我们转到双重概念<em class="kn">精度</em>和<em class="kn">召回</em>以及它们为什么重要，但是让我们通过一个例子来做，在这个例子中我们假设图 3 中的值:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es jp"><img src="../Images/3b021fbd0ac58742d7d684cebefc323d.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*7R-89R9Z40n_t0gbYu0HKQ.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 3。非平衡分布运动的假设值混淆矩阵</figcaption></figure><p id="6ffb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们开始之前，看一下数据分布，以及这个数据集的不平衡程度，总磷和总氮的比例为 20:1。考虑到这一点，让我们计算精确度并讨论结果:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ko"><img src="../Images/fd372ab7d22613d7b6398a7272f58b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*h5E3Csl1fyIRe78Djqabxw.gif"/></div></figure><p id="813d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还不错，准确率 94.46%。但是这个数字到底告诉我们什么呢？它是在告诉我们，当有人生病时，模型可以预测 94.46%的时间吗？还是在告诉我们，在病人没有生病的情况下，它可以预测 94.46%的时间？事实是，你不能真正使用这个指标，因为数据是不平衡的，因此容易被误解，因此，我们需要看看<em class="kn">精度</em>和<em class="kn">召回。</em></p><p id="7a2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kn">精度</em>将告诉我们有多少正确预测的病例实际上是阳性的:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kp"><img src="../Images/db5f417b82c7bbf22ac4a142a7a2e3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/1*DrDSY8CweF7Czy8RAcW2dg.gif"/></div></figure><p id="e66c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kn">回忆</em>，告诉我们有多少实际阳性病例我们能够用我们的模型正确预测:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kq"><img src="../Images/f365de344daa7012920c28d2bdcd5deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*6HN5ctREWzGwW5Dzlv9yrg.gif"/></div></figure><p id="656f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kn">精度</em>和<em class="kn">召回</em>分别以 97.09%和 99.01%的值结束了甚至更好的准确性。</p><p id="feed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们停一会儿，记住我之前关于<em class="kn">精度</em>与<em class="kn">召回</em>的评论，我提到过当你想用更少的 FP 来换取更多的 FN 时，精度<em class="kn">比召回<em class="kn">更重要。意思是，获得一个 FP 是非常昂贵的，而一个 FN 就不那么贵了。但是，在医学领域，<em class="kn">回忆</em>更重要，因为你不关心 FP，因为你想击中每一个阳性病例。</em></em></p><p id="5e25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理解这种说法的最简单方法是通过分析如何使用混淆矩阵计算召回率(图 3)。简单地说，回忆基本上是模型预测病人生病的情况和病人确实生病的情况之间的关系，加上模型出错和预测病人健康但实际上病人生病的情况的相同值。如果你想一想，你作为一名医生想要一个高召回率，即使这意味着你会提出一个错误的警报，因为实际的阳性病例不应该未被发现，如果医生告诉你你生病了，但你没有，而不是被告知你没有生病，但事实证明你生病了，你作为一名患者会更高兴。因此，当谈到健康时，<em class="kn">回忆</em>超过<em class="kn">精确。</em></p><p id="f2a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在这一点上，你有希望得到我的观点，所以让我们比较两个模型架构(图 4 和图 5 ),看看它们的度量</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kr"><img src="../Images/acf7effd5e2d3ef526b8ce444f679040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*xlsSjElBJO4rP6tI5OV9HQ.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 4。Model_15 的体系结构，每个块有两个卷积层，连接层上有脱落</figcaption></figure><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ks"><img src="../Images/3e82d352736744fab7a7788938647a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*wGfdUWuasm79tidFGAJIVA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 5。Model_5 架构，每个块有一个卷积层</figcaption></figure><p id="d415" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图 4 和图 5 所示，这两个模型实际上都不是什么奇特的模型，它们都使用基本参数，不同之处在于 Model_15 的处理时间大约是 Model_5 的三倍，这主要是由于 5 个卷积块中的每一个都有两个卷积层，而 Model_5 的每个卷积块只有一个卷积层。此外，Model_15 在完全连接的层上有一个压降，以解决可能导致更多处理延迟的过拟合问题。</p><p id="4936" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们比较一下这两个模型的混淆矩阵(图 6 和图 7)，然后看看我们感兴趣的指标(<em class="kn">精度</em>和<em class="kn">召回</em>)来对它们的性能进行公平的比较。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kt"><img src="../Images/8352852b0f699ebe249bf671a5fba12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*rXV-6hKTc7VYMP3FhMMLtA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 6。模型 _15 混淆矩阵</figcaption></figure><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ku"><img src="../Images/a1c58b5749da036c166ff1882acf6509.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*rrHtQQCxayvBrTXvsewJaA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 7。模型 5 混淆矩阵</figcaption></figure><p id="7021" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在没有计算任何指标的情况下，让我们关注两个矩阵的 TP 和 FN。对于 Model_15(图 6)，TP = 289，FN = 51，而对于 Model_5(图 7)，TP = 333，FN = 7。这告诉我们的是，Model_15 会通过告诉他们没有生病来错误地预测 51 名患者，而实际上他们生病了，Model_5 只会对 7 名患者这样做。同时，模型 _15 将准确预测 289 名患者患病，而模型 _5 预测 333 名患者患病。</p><p id="e195" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们将这些数字放入我们的等式，我们将获得图 8 中的指标。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kv"><img src="../Images/3d61d3ce755de5d56948ead5d5586385.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*-awMzXZ3nvdNG_HJt48E3w.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 8。Model _ 15 和 Model_5 指标</figcaption></figure><p id="d5e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些指标表明，Model_15 值的一致性更高，但同样，这是一个具有不平衡数据集的医疗/健康问题，因此，召回是我们最重要的指标，这意味着这表明 Model_5 的表现优于 Model_15，即使 Model_15 的精确度和准确度更高。</p><p id="ab9f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们只看训练、验证和测试准确性以及图中的分数，我们可能看不到这一点。在图 9 和图 10 中查看它们，并查看具有相同历元数(50)的两个训练模型之间的相似性。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/56f124da3a19a86eae95038eeee951ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*oLayyUczNrX6Wo3AHNjkAQ.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 9。Model_15 的训练和验证准确度和分数图适合 50 个时期</figcaption></figure><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/a7939f2b312db5df933ad33dfd1cd7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*VJL4n-jz6rbxmYJoHlGgiA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 10。模型 5 拟合 50 个时期的训练和验证精度和损失</figcaption></figure><p id="fa74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，两个模型的训练和验证准确性和损失非常相似，因此使用这些工具根据它们的性能选择模型并不是一件容易的事情，但是在精度和召回指标的帮助下，我们发现 Model_5 是解决这个特定问题的更好选择。</p><p id="a4e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于那些读过我之前博客的人来说，你可能还记得，由于时间限制，我没有用相同数量的历元来训练我的所有模型。我平均运行 10 个时期，如果验证分数大于 75%，那么我根据模型的复杂性将时期增加到 30 和/或 50。Model_5 是这一紧迫期限的受害者，我只用 10 个纪元来训练它。有了更多的时间，我回去做了更长时间的训练，这就是我如何意识到我应该仔细检查这个特定的模型。为了便于比较，您可以在图 11 中看到每个模型的第 50 个历元的精度和损失。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es kx"><img src="../Images/2824ebf1b3fbd1fbfb0e74c77e92f439.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*WIo7LK3a4YMysx8geGtTmA.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">图 11。Model_15 和 5 的第 50 个纪元的输出指标</figcaption></figure><p id="9459" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将所有这些放在一起，很容易得出结论，Model_5 更适合分类用于肺炎检测的 X 射线图像，因为它的召回率相当高(97.9%)。</p><p id="b70c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我结束这篇博客之前，我想分享三个可能听起来显而易见，但可能会让我在保留哪种模式方面做出不同选择的教训:</p><ul class=""><li id="4b22" class="jy jz ht is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">在过程的早期，检查数据的分布，以便在训练模型后可以正确地解释模型。一个不平衡的数据集不能仅通过准确性来进行评估，还需要其他指标，如精确度和召回率。混淆矩阵非常有用</li><li id="7414" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">不要使模型的架构过于复杂，因为它不一定会转化为更好的表现。从简单开始，并随着您的进展添加层</li><li id="6375" class="jy jz ht is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">不要把自己局限在一种模式上。尝试不同的选项，以便比较结果并减少不确定性</li></ul><p id="4d36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，我的结论并不是说最初的模型是错误的，而是说对于这种类型的问题，Model_5 更适合</p><p id="a717" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你已经做到了这一步，我感谢你阅读我的博客，如果你有任何评论或反馈，请不要犹豫，通过我的<a class="ae jo" href="http://www.linkedin.com/in/jaherbas-geophysicist" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我，如果你想了解这个项目的所有其他进展，请随时访问我的<a class="ae jo" href="https://github.com/JaHerbas/CNN_Xray_Classsification" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div></div>    
</body>
</html>