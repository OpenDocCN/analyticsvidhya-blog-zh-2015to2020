<html>
<head>
<title>Climbing the Fibonacci Sequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">攀登斐波纳契数列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/climbing-the-fibonacci-sequence-d2066b0b20aa?source=collection_archive---------7-----------------------#2020-04-02">https://medium.com/analytics-vidhya/climbing-the-fibonacci-sequence-d2066b0b20aa?source=collection_archive---------7-----------------------#2020-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f8e0c2fdb93eb2a24e9a94b3c6eeee66.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*lxLHk0rEzZrmwweyt11ezg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">爬楼梯问题</figcaption></figure><p id="6415" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di"> T </span> <strong class="is hj">何故事从一个问题开始</strong> <br/>昨天我在解一个很有名的DP问题，<a class="ae jx" href="https://leetcode.com/problems/climbing-stairs/" rel="noopener ugc nofollow" target="_blank">爬楼梯</a>。<br/>问题相当简单。你正在爬楼梯。需要n步才能到达顶端。每次你可以爬1或2级台阶。有多少种不同的方式可以让你爬上顶峰？</p><p id="770b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解决方案</strong> <br/>解决方案也很简单。<br/>假设我们已经爬上了一些台阶，我们还剩下一些<strong class="is hj"> i </strong>台阶到达顶端。假设，<strong class="is hj"> NoOfWays(i) </strong>是一个函数，它返回到达顶端的第<strong class="is hj"> i </strong>步的攀登路径数。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jz"><img src="../Images/7dea656c134458131edd1f674fd12e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbDfLx4d40NtV5CzfaXU5A.png"/></div></div></figure><p id="3eda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们向上爬一步，那么我们就剩下(i-1)步了。利用上面的公式，攀登的方式数(i -1)步= NoOfWays(i-1)。类似地，如果我们爬了两步，那么我们剩下(i-2)步，使用公式，爬(i -2)步的方法数= NoOfWays(i-2)。<br/>因为我们只能用两种方式中的一种来攀爬，所以攀爬的方式如下</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es ki"><img src="../Images/b3dd32dce8d73b13e6ea8da27ef1488c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giW_Nhs5goUAgfCMAjhdrg.png"/></div></div></figure><p id="4abb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于基本情况，我们知道NoOfWays(1) = 1和NoOfWays(2) = 2，因此我们可以说</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kj"><img src="../Images/c55e1c8c5212a31b8edb96b4074578a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBIxj2YW7t3hpR9fN0UJkQ.png"/></div></div></figure><p id="3c44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个递推关系，我们就可以确定爬<strong class="is hj"> n步</strong>到达顶端的路数。这正式解决了问题。</p><p id="da8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">现在解决了，一切都好了，但是这个问题有什么特别的呢？</strong>T29】答案是<strong class="is hj">结果是</strong>。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/8cc05f36bf08a38b0246fc22bd86cf45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*ICRHBnyzTjHk-uOw3lcV2A.png"/></div></figure><p id="1e90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">颠倒上述等式，我们可以说</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kl"><img src="../Images/3395fedd2550afde817a8fd8d1866cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZv8X2Ko3OIDZB5nN7Bvbw.png"/></div></div></figure><blockquote class="km"><p id="0ba0" class="kn ko hi bd kp kq kr ks kt ku kv jn dx translated">使用上述斐波纳契数列的表示，我们可以证明与斐波纳契数列相关的各种恒等式和规则。</p></blockquote><p id="00a1" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">比方说，Fib(n)代表nᵗʰ斐波纳契数。</p><p id="0f47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">卷积定理</strong></p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lb"><img src="../Images/762ecd58c74b01a700d1d0c1c48608a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SNH3KjMJfr48N9hICgm1g.png"/></div></div></figure><p id="8a57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，等式的左边代表了爬(n + k)级楼梯的方式的数量。<br/>爬(n + k)级楼梯的任务也可以用两种方式中的一种来完成。</p><ul class=""><li id="c1c3" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">案例1:如果我们每次攀登都踏上第n级台阶</li><li id="690b" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">情况2:如果我们每次都跳过第n步</li></ul><p id="c0b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第一种情况下，</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/e273f41e8cb96fb2cb8df79ba5437df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*XSqv8eIGscruY_0ClwAokA.png"/></div></figure><p id="b348" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自从我们踏上nᵗʰ台阶。那么我们一定已经以无止境的方式爬了n步，还剩下k步可以爬得更远。攀登的路线数=无路线数(n) *无路线数(k)</p><p id="d6b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第二种情况下，</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/b31d64d4221cfc206ea844884cd7c0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*MnUcQAadIXYo4y2b66oAzg.png"/></div></figure><p id="51af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们跳过了nᵗʰ这一步。那我们一定是爬到了(n-1)ᵗʰ)台阶，跳到了(n + 1)ᵗʰ)台阶。因此，攀登的方式数=无向度(n-1) *无向度(k-1)</p><p id="191d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面讨论的情况是相互排斥的(即不可能有一条路径同时存在于两种情况中)并且穷尽了可能性的空间(即爬上整个楼梯的方式的总数)</p><p id="81e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以这么说，</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es ls"><img src="../Images/75588e2a2b32c07d7da048cad4eb5509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtRxphD-E_u4-v7QZgtzdg.png"/></div></div></figure><p id="255f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于NoOfWays(n) = Fib(n)，因此</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lb"><img src="../Images/762ecd58c74b01a700d1d0c1c48608a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SNH3KjMJfr48N9hICgm1g.png"/></div></div></figure><p id="b8ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就证明了斐波那契数的卷积定理。</p><p id="73ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">进一步洞察</strong> <br/>将k = n，k = n +1代入上式</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lt"><img src="../Images/496b6b2a85c3d818071c70c57caea156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oE0Zy7vIp6hHXpnajXa4Qw.png"/></div></div></figure><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/c1abeecadaf2959d4f9e3dc4cc3b2110.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*_EFDR2OdqSemQLUcCKXxoA.png"/></div></figure><p id="6ad6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">T(n) = 2*T(n/2) + O(1)当N是偶数时<br/> T(n) = 3*T(n/2) + O(1)当N是奇数时<br/>利用上面的结果我们可以计算出<strong class="is hj"> O(log N)中的第N个斐波那契数。</strong></p><p id="0345" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，我们可以用这种表示方法推导出斐波那契数列的如下求和(我假设的，我还没想到)</p><ul class=""><li id="10ac" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">Running Sum，Fib(n)+Fib(n-1)+Fib(n-2)…+Fib(0)= Fib(n+2)-1<br/>(更新:此处 有我对这个公式的解释的链接<a class="ae jx" rel="noopener" href="/@sci.agarg/fibonacci-sequence-running-sum-b6f441741cdc">)</a></li><li id="8421" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">偶数项之和，Fib(0) + Fib(2) + Fib(4) …+ Fib(2n) = Fib(2n+1)</li></ul><p id="e971" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我发现其他一些有用的表述</p><ul class=""><li id="5395" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">Fib(n) =仅使用1和2得到总和(= n)的方法的数量。</li><li id="926e" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">Fib(n) =使用<strong class="is hj"> 1 x 1 </strong>正方形和<strong class="is hj"> 2 x 1 </strong>多米诺骨牌平铺<strong class="is hj"> n x 1 </strong>棋盘的方法数量(另一个DP问题)</li></ul><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lv"><img src="../Images/e19bcb2715975604aaecd914463f3a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCknSWsH8GC5zPtqkzG3_Q.png"/></div></div></figure><p id="4d1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">快结束时… <br/> </strong>所有这些都让我想到了一个问题，这个问题很简单，我已经知道了逻辑和解决方法，但是，直到那时我还没有反过来看。然后，我在谷歌上查找了一些受欢迎的属性，并在它们身上进行了尝试，结果很好。<br/>这个想法不是唯一的，可能有一些更好的序列表示，这肯定已经在之前讨论过了。但是我觉得很酷，就分享给你了。我还相信，像这样的表示有助于解决复杂修改的类似问题，这些问题很难只用数学方程来解码。我希望你喜欢这个主意。</p><p id="e31c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是我的部分</p></div></div>    
</body>
</html>