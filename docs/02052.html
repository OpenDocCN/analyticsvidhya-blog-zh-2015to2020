<html>
<head>
<title>Question and Answer for Long Passages Using BERT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BERT进行长文章的问答</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/question-and-answer-for-long-passages-using-bert-dfc4fe08f17f?source=collection_archive---------15-----------------------#2019-11-27">https://medium.com/analytics-vidhya/question-and-answer-for-long-passages-using-bert-dfc4fe08f17f?source=collection_archive---------15-----------------------#2019-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9385fe0f19d9a6c5ec98b98a15771485.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*BJkaG5hU2EEj1NmZJpAX6Q.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://d827xgdhgqbnd.cloudfront.net/wp-content/uploads/2019/04/09110726/Bert-Head.png" rel="noopener ugc nofollow" target="_blank">https://d 827 xgdhgqbnd . cloudfront . net/WP-content/uploads/2019/04/09110726/Bert-head . png</a></figcaption></figure><p id="172f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">BERT，即来自变压器的双向编码器表示，是一种预训练语言表示的新方法，它在各种自然语言处理(NLP)任务上获得了最先进的结果。可以肯定地说，它正在席卷NLP世界。BERT是由谷歌开发的，Nvidia已经创建了一个使用TensorRT的优化版本。(【https://github.com/google-research/bert】T2和<a class="ae iq" href="https://devblogs.nvidia.com/nlu-with-tensorrt-bert/" rel="noopener ugc nofollow" target="_blank">https://devblogs.nvidia.com/nlu-with-tensorrt-bert/</a>)</p><p id="7934" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">BERT的一个缺点是在执行问答时只能查询短文。当文章达到一定长度后，就找不到正确答案了。要运行问答查询，您必须提供要查询的文章以及您试图从文章中回答的问题。</p><p id="6ae3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我已经创建了一个脚本，允许您查询较长的段落并获得正确的答案。我取一个输入段落，并将其分成由\n分隔的段落。然后查询每个段落以试图找到答案。所有返回的答案都放在一个列表中。然后对列表进行分析，找出概率最高的答案。这将作为最终答案返回。当您运行该脚本时，您将需要更改路径以符合您的设置。脚本可以在https://github.com/pacejohn/BERT-Long-Passages的GitHub上找到。</p><h1 id="0820" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置</h1><p id="542d" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">为了正确运行脚本，您需要确保创建了Docker容器。在运行查询之前，请确保启动TensorRT引擎。以下是英伟达说要做的和我正在做的步骤。</p><p id="ab8e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">从主目录中，运行以下命令。这需要一段时间。</p><p id="0f6d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">克隆TensorRT存储库并导航到BERT演示目录<br/> <em class="ks"> git克隆—递归</em><a class="ae iq" href="https://github.com/NVIDIA/TensorRT" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://github.com/NVIDIA/TensorRT</em></a><em class="ks">&amp;&amp;CD TensorRT/demo/BERT</em></p><p id="212f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">创建并启动docker映像<br/><em class="ks">sh python/Create _ docker _ container . sh</em></p><p id="188c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">构建插件并下载微调后的模型<br/><em class="ks">CD TensorRT/demo/BERT&amp;&amp;sh python/Build _ examples . sh base fp16 384</em></p><p id="ead4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">构建TensorRT运行时引擎并启动它。如果你不做这件事，你就不能做其他任何事。<br/><em class="ks">nohup python python/Bert _ builder . py-m/workspace/models/fine-tuned/Bert _ TF _ v2 _ base _ fp16 _ 384 _ v2/model . ckpt-8144-o Bert _ base _ 384 . engine-B1-s 384-c/workspace/models/fine-tuned/Bert _ TF _ v2 _ base _ fp16 _ 384 _ v2&gt;tensorrt . out&amp;</em></p><p id="a46e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">启动引擎后，您可以在脚本<br/><em class="ks">python/Bert _ inference _ loop . py</em>中运行问答查询</p><p id="9d59" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一个警告是，TensorRT引擎将在一段时间后终止。在执行查询之前，请确保它正在运行。</p><h1 id="223c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我用于查询的文件</h1><p id="f605" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">我可以用3个文件作为输入段落。请随意用你自己的文章来试一试。</p><p id="f5db" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">22532_Full_Document.txt —这是我使用的完整文档。如果你问一个关于第一部分的问题，它会返回正确的答案。如果你问一个关于后面部分的问题，它不会找到答案。</p><p id="1711" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">22532 _ Short _ Document _ With _ answers . txt—这是一个简短的段落，包含了对查询的回答。如果你使用和我一样的查询，它会找到2个答案。概率较大的是正确答案。</p><p id="76cb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">22532 _ Short _ Document _ Without _ answers . txt—这是一段简短的短文，其中没有问题的答案。如果你使用和我一样的查询，它将找不到任何答案。</p><p id="10bf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">提出的问题是<em class="ks">“有多少患者在12岁时经历了复发？”</em>随意实验。</p><p id="5b34" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">欢迎大家的反馈和建议。请务必在Twitter @pacejohn上关注我，并查看我在https://www.ironmanjohn.com/的博客。</p></div></div>    
</body>
</html>