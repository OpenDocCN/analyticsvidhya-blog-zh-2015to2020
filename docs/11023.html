<html>
<head>
<title>Python Multi-Processing vs Multi-Threading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python多处理与多线程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-multi-processing-vs-multi-threading-7cb2e26d90f3?source=collection_archive---------3-----------------------#2020-11-14">https://medium.com/analytics-vidhya/python-multi-processing-vs-multi-threading-7cb2e26d90f3?source=collection_archive---------3-----------------------#2020-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e36a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直在努力加速我的程序，以便更快地执行任务，并且我开始了解Pythons的多处理和多线程。起初，他们都希望完成相同的任务，但在现实中，他们确实有相似之处，但我要说，他们更多的是不同于相同。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="2685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">多线程- </strong> <br/>考虑一下你去一家只有一个厨师的餐馆。当你点餐时，厨师会开始准备你点的菜，当另一位顾客来时，他会开始准备他点的菜，直到你点的菜准备好。他可能不能保证你的菜会在第二个顾客之前先准备好。因为这取决于厨师决定的优先顺序。</p><p id="254b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">多处理- <br/> </strong>现在我们假设你去了一家有两个厨师的餐厅。当你和第二位顾客点餐时，你们很可能会同时准备好食物，因为一位厨师正在准备你的食物，而另一位厨师正在准备第二位顾客的食物。这就是多重处理。其中两个任务并行运行，而不像多线程那样是并发的。</p><p id="8e4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个多处理池的基本例子</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f478" class="jt ju hi jp b fi jv jw l jx jy">import time<br/>import multiprocessing<br/>def multi_process(val):<br/>    time.sleep(5)<br/>    return val</span><span id="2e69" class="jt ju hi jp b fi jz jw l jx jy">alphabets = ['a','b','c','d','e']<br/>with Pool() as pool:<br/>    pool = multiprocessing.Pool(processes=5)<br/>    start = time.time()<br/>    output = pool.map(multi_process, alphabets)<br/>    stop = time.time()<br/>    pool.close()<br/>    print('Execution Time :',stop-start)</span><span id="4bb2" class="jt ju hi jp b fi jz jw l jx jy">==========================================================<br/>processes = 5 :Execution Time : 5.009518384933472<br/>processes = 1 :Execution Time : 25.030145168304443</span></pre><p id="0c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上面的代码，所有的字母被同时传递给多进程函数，总时间是5秒。如果没有多重处理，常规for循环的时间将是5*5 = 25秒</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="7aa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为在多处理中，如果我们想像在for循环中那样增加计数器的值，所有的进程都会同时运行</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="3dd8" class="jt ju hi jp b fi jv jw l jx jy">counter = 0<br/>for i in range(10):<br/>    counter += 1</span><span id="636f" class="jt ju hi jp b fi jz jw l jx jy">=======================================================<br/>Output - counter = 10</span></pre><p id="31f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用多处理或线程，上述过程将无法复制。必须进行一些更改，以确保计数器增加到10，而不只是任何低于10的值。下面我们来看一个例子。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="1adf" class="jt ju hi jp b fi jv jw l jx jy">import time<br/>import multiprocessing<br/>from multiprocessing import Pool, cpu_count,Value</span><span id="6c38" class="jt ju hi jp b fi jz jw l jx jy">def init(counter):<br/>    global counter1<br/>    counter1 = counter</span><span id="8e60" class="jt ju hi jp b fi jz jw l jx jy">def multi_process(val):<br/>    time.sleep(5))<br/>    counter1.value = counter1.value + 1<br/>    return val</span><span id="81bd" class="jt ju hi jp b fi jz jw l jx jy">if __name__ == '__main__':<br/>    alphabets = ['a','b','c','d','e']<br/>    counter = multiprocessing.Value('i',0)<br/>    with Pool() as pool:<br/>        pool = multiprocessing.Pool(processes=5, initializer=init, initargs=(counter,))<br/>        start = time.time()<br/>        output = pool.map(multi_process, alphabets)<br/>        stop = time.time()<br/>        pool.close()<br/>        print('Execution Time :',stop-start)<br/>    print(counter.value)</span><span id="c011" class="jt ju hi jp b fi jz jw l jx jy">=======================================================<br/>Expected Output - counter = 5 (counter should increment to 5 for 5 items in list)<br/>Got Ouptut Random numbers - 5,4,2,1,3 etc.</span></pre><p id="1824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种行为的原因是因为多处理多个进程可以同时访问变量，这使得很难将计数器递增5。为了克服这个问题，多处理模块具有解决上述问题的锁定特征</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="1a04" class="jt ju hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">锁</h2><p id="f932" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">当一个进程想要访问一个共享变量时，它首先获取一个锁，然后增加变量并释放锁。这样做可以确保循环像在for循环中一样递增。如果锁被获取，而另一个进程必须获取该锁，那么它就等待，直到现有的锁被拥有该锁的当前进程释放。下面给出了上述问题的解决方案</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f511" class="jt ju hi jp b fi jv jw l jx jy">import time<br/>import multiprocessing<br/>from multiprocessing import Pool, cpu_count,Value</span><span id="1f9d" class="jt ju hi jp b fi jz jw l jx jy">def init(lock,counter):<br/>    global glock,counter1<br/>    glock = lock<br/>    counter1 = counter</span><span id="b4f3" class="jt ju hi jp b fi jz jw l jx jy">def multi_process(val):<br/>    time.sleep(1)<br/>    glock.acquire()<br/>    counter1.value = counter1.value + 1<br/>    glock.release()<br/>    return val</span><span id="9195" class="jt ju hi jp b fi jz jw l jx jy">if __name__ == '__main__':<br/>    alphabets = ['a','b','c','d','e']<br/>    counter = multiprocessing.Value('i',0)<br/>    lock = multiprocessing.Manager().Lock()<br/>    with Pool() as pool:<br/>        pool = multiprocessing.Pool(processes=5, initializer=init, initargs=(lock,counter,))<br/>        start = time.time()<br/>        output = pool.map(multi_process, alphabets)<br/>        stop = time.time()<br/>        pool.close()<br/>        print('Execution Time :',stop-start)<br/>    print(counter.value)</span><span id="4d5f" class="jt ju hi jp b fi jz jw l jx jy">=============================================================<br/>Output - counter = 5 (No matter how many times we run the above code the output will of counter will be 5 )</span></pre><blockquote class="ky kz la"><p id="dab9" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">有时间的话，我会不断更新内容。谢谢</p></blockquote></div></div>    
</body>
</html>