<html>
<head>
<title>Serve a machine learning model using Sklearn, FastAPI, and Docker.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sklearn、FastAPI和Docker服务一个机器学习模型。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/serve-a-machine-learning-model-using-sklearn-fastapi-and-docker-85aabf96729b?source=collection_archive---------3-----------------------#2020-07-06">https://medium.com/analytics-vidhya/serve-a-machine-learning-model-using-sklearn-fastapi-and-docker-85aabf96729b?source=collection_archive---------3-----------------------#2020-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f60dfe63cb2915eb033be7c076fba59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJ6N6mQncyG_MCVMhpqHbw.png"/></div></div></figure><p id="fb0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，你将学会如何:</p><p id="1d92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">*使用Sckit-learn训练并保存机器学习模型<br/> *创建一个可以接受传入预测请求的API<br/>*使用Docker <br/>运行您的API *使用Locust测试您的API性能</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="73ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">机器学习是数据科学中最热门的话题之一；有许多关于如何训练模型的资源，从数据清理、特征选择，到在许多候选对象之间进行选择并对其进行微调。</p><p id="58db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上，你的电脑上的一切都很正常。然而，当涉及到部署您的模型以便其他用户或系统可以使用它时，它带来了几个挑战，例如预测速度、基础设施兼容性和服务可伸缩性。</p><p id="c3d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看如何实现这一点；我们的项目结构如下:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="2b7a" class="ke kf hi ka b fi kg kh l ki kj">iris-api/<br/>│<br/>├── models/<br/>│   ├── ml/<br/>│   │    ├── classifier.py<br/>│   │    └──traing.py<br/>│   │    └── <!-- -->iris_dt_v1.joblib<br/>│   └── Iris.py<br/>│<br/>├── tests/<br/>│   ├── load_test.py<br/>├── app.py<br/>├── Dockerfile<br/>├── LICENSE<br/>├── README.md<br/>├── requirements.txt<br/>└── .gitignore</span></pre><p id="4f39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们把它分成几部分。</p><h1 id="140c" class="kk kf hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak"> 1。训练模型</strong></h1><p id="60e0" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">Sckit-learn，它可能是python中最流行的经典机器学习框架；它有一个易于使用的API，支持最常见的模型。</p><p id="d1a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据集:</strong></p><p id="9a8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个项目中，我们将使用Iris数据集来训练一个分类模型。</p><p id="2dc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虹膜数据集有四个特征:</p><ul class=""><li id="d45b" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">萼片长度，单位为厘米</li><li id="5982" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">萼片宽度，单位为厘米</li><li id="abbf" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">花瓣长度(厘米)</li><li id="4b94" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">花瓣宽度(厘米)</li></ul><p id="a41e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些特征用于将每个观察结果分为三类:刚毛鸢尾、杂色鸢尾和海滨鸢尾。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/9387181036f5f62d70cbb2645ab8853b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bnLKsChXq94QjtAiRn40w.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">虹膜样本</figcaption></figure><p id="c0af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们设置出train.py，导入方法和iris数据，将特性设置为一个名为X的NumPy ndarray，将预测类别设置为变量y。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="b7f6" class="ke kf hi ka b fi kg kh l ki kj">from joblib import dump<br/>from sklearn import datasets<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.preprocessing import MinMaxScaler<br/>from sklearn.tree import DecisionTreeClassifier<br/><br/><br/>iris = datasets.load_iris(return_X_y=True)<br/>X = iris[0]<br/>y = iris[1]</span></pre><p id="deb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们创建一个简单的模型，记住这篇文章的主题不是模型训练，所以我们会尽可能简单。</p><p id="3686" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为预处理步骤，让我们缩放我们的变量，并使用一个带有默认参数的决策树分类器进行模型训练。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="af5a" class="ke kf hi ka b fi kg kh l ki kj">clf_pipeline = [('scaling', MinMaxScaler()), <br/>                ('clf', DecisionTreeClassifier(random_state=42))]<br/>pipeline = Pipeline(clf_pipeline)<br/><br/>pipeline.fit(X, y)</span></pre><p id="0e39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步，让我们保存训练好的模型，这样我们就可以在API中使用它来进行预测</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="8b18" class="ke kf hi ka b fi kg kh l ki kj">dump(pipeline, './iris_dt_v1.joblib')</span></pre><h1 id="3b12" class="kk kf hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">2.创建API</h1><p id="f10e" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">根据FastAPI作者的说法:</p><blockquote class="mf mg mh"><p id="529a" class="iq ir mi is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">FastAPI是一个现代、快速(高性能)的web框架，用于基于标准Python类型提示用Python 3.6+构建API。</p><p id="f9cf" class="iq ir mi is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">非常高的性能，与<strong class="is hj"> NodeJS </strong>和<strong class="is hj"> Go </strong>不相上下(感谢Starlette和Pydantic)。<a class="ae mm" href="https://fastapi.tiangolo.com/#performance" rel="noopener ugc nofollow" target="_blank">目前最快的Python框架之一</a>。</p></blockquote><p id="f2a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将允许我们服务于我们的机器学习模型。</p><p id="e3b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在创建predict方法端点之前，我们将定义我们的Iris模型，因此我们让FastAPI知道我们期望什么作为请求数据；在我们的iris.py文件中，写入</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="0751" class="ke kf hi ka b fi kg kh l ki kj">from pydantic import BaseModel, conlist<br/>from typing import List<br/><br/><br/>class Iris(BaseModel):<br/>    data: List[conlist(float, min_items=4, max_items=4)]</span></pre><p id="d915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这段代码，我们将确保获得一个(或几个)包含模型进行预测所需的四个变量的列表。</p><p id="38a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在classifier.py上，使用</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="cc3b" class="ke kf hi ka b fi kg kh l ki kj">clf = None</span></pre><p id="585d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">clf将作为一个占位符，所以我们可以导入和重用我们的模型</p><p id="2871" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建一个端点来发送预测请求；首先，我们需要导入我们刚刚在app.py中创建的主FastAPI方法、占位符和iris模型</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="29bc" class="ke kf hi ka b fi kg kh l ki kj">import models.ml.classifier as clf<br/>from fastapi import FastAPI, Body<br/>from joblib import load<br/>from models.iris import Iris<br/><br/>app = FastAPI(title="Iris ML API", description="API for iris dataset ml model", version="1.0")</span></pre><p id="946f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们需要得到我们训练过的模型；我们将确保FastAPI仅在应用程序启动时导入模型，而不是在每个请求中导入，因为这可能会在我们的预测中增加额外的时间，这是我们想要避免的，在其他情况下，您必须小心，在内存中保存模型可能是一个错误的决定。在这种情况下，由于我们想要进行实时预测，并且使用这样一个小模型，我们是可以的。</p><p id="059b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们来读一下模型，然后赋值。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ef90" class="ke kf hi ka b fi kg kh l ki kj">@app.on_event('startup')<br/>async def load_model():<br/>    clf.model = load('models/ml/iris_dt_v1.joblib')</span></pre><p id="5cbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们定义接受我们请求的路由；这将是一个后方法来预测。</p><p id="1776" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法将采用我们的Iris模型来确保请求数据格式是正确的，并将返回我们的类预测和每个类的对数概率。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="7c8d" class="ke kf hi ka b fi kg kh l ki kj">@app.post('/predict', tags=["predictions"])<br/>async def get_prediction(iris: Iris):<br/>    data = dict(iris)['data']<br/>    prediction = clf.model.predict(data).tolist()<br/>    log_proba = clf.model.predict_proba(data).tolist()<br/>    return {"prediction": prediction,<br/>            "log_proba": log_proba}</span></pre><p id="ac31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>我们的函数是异步的；FastAPI支持现成的异步方法。</p><p id="2235" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的基础API已经准备好了！现在，app.py文件如下所示</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="d5b2" class="ke kf hi ka b fi kg kh l ki kj">import models.ml.classifier as clf<br/>from fastapi import FastAPI<br/>from joblib import load<br/>from models.iris import Iris<br/><br/>app = FastAPI(title="Iris ML API", description="API for iris dataset ml model", version="1.0")<br/><br/><br/>@app.on_event('startup')<br/>def load_model():<br/>    clf.model = load('models/ml/iris_dt_v1.joblib')<br/><br/><br/>@app.post('/predict', tags=["predictions"])<br/>async def get_prediction(iris: Iris):<br/>    data = dict(iris)['data']<br/>    prediction = clf.model.predict(data).tolist()<br/>    log_proba = clf.model.predict_log_proba(data).tolist()<br/>    return {"prediction": prediction,<br/>            "log_proba": log_proba}</span></pre><p id="c531" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从运行以下命令开始:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="f5a2" class="ke kf hi ka b fi kg kh l ki kj">uvicorn app:app --port 5000</span></pre><p id="0390" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在转到:<a class="ae mm" href="http://127.0.0.1:5000/docs" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/docs</a>，你的屏幕应该是这样的:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/b8d682492ea65e542c6af48bdf615992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buYCWgCU4QvlIQuXbOPWTg.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">开放API</figcaption></figure><p id="3727" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们的API已经启动并运行了，我们可以轻松地记录和测试我们的API，这是FastAPI的另一个优秀特性。</p><p id="9081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们转到我们预测的终点，点击“尝试一下”;我们会发送两份观察报告。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/e63782052108371d7907395086752836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKZeIeQYXqDSYwilRuAVag.png"/></div></div></figure><p id="0fa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您也可以尝试从您的终端或任何其他客户端作为邮递员</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="d713" class="ke kf hi ka b fi kg kh l ki kj">curl -X POST "http://127.0.0.1:5000/predict" -H\<br/> "accept: application/json"\<br/> -H "Content-Type: application/json"\<br/> -d "{\"data\":[[4.8,3,1.4,0.3],[2,1,3.2,1.1]]}"</span></pre><p id="9f45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们的回应。它告诉我们，第一个数据点的预测类是0类，对应于鸢尾，第二个点是鸢尾杂色，它还为我们提供了每个类别的对数概率，您可以在响应中添加更多有用的信息</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/5273fbdd27b5bce98e78f1ecf5634a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqPFXAsfRmIuQRpsDUCArA.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">Iris API响应示例</figcaption></figure><p id="3dac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以尝试向请求发送四个变量中的三个，并查看FastAPI如何处理验证(您可以在这里添加一个状态代码)</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/161df241b9fcc012456e24b31cab5dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5GZmi96t_bRStY_f_euosQ.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">错误请求的例子。</figcaption></figure><h1 id="8c56" class="kk kf hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">3.与Docker一起运行</h1><p id="ff79" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在这一点上，一切可能都在我们的电脑上工作。尽管如此，当你将它部署到你最喜欢的应用程序主机时，并不能保证系统会有我们运行API所需的所有依赖，所以Docker来帮助我们克服这一点。</p><p id="c10d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来自Docker官方页面</p><blockquote class="mf mg mh"><p id="4bb8" class="iq ir mi is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">如今开发应用程序需要的不仅仅是编写代码。在生命周期的每个阶段，多种语言、框架、架构和工具间不连续的接口造成了巨大的复杂性。Docker简化并加速了您的工作流程，同时让开发人员可以自由地为每个项目选择工具、应用程序堆栈和部署环境。</p></blockquote><p id="385b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以从Docker的官方<a class="ae mm" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">网站</a>获得。</p><p id="b777" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们创建我们的requirements.txt这将使我们所有的python包要求使用相同的包版本。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="11de" class="ke kf hi ka b fi kg kh l ki kj">fastapi==0.57.0<br/>uvicorn==0.11.5<br/>pydantic==1.5.1<br/>starlette==0.13.4<br/>python-multipart==0.0.5<br/>requests==2.24.0<br/>scikit-learn==0.23.1<br/>joblib==0.16.0</span></pre><p id="cbca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是文档</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="5a38" class="ke kf hi ka b fi kg kh l ki kj">FROM tiangolo/uvicorn-gunicorn:python3.8-slim <br/><br/>WORKDIR /app </span><span id="0f2a" class="ke kf hi ka b fi mr kh l ki kj">ENV DEBIAN_FRONTEND=noninteractive<br/>ENV MODULE_NAME=app </span><span id="6ee3" class="ke kf hi ka b fi mr kh l ki kj">ADD requirements.txt . </span><span id="de1c" class="ke kf hi ka b fi mr kh l ki kj">RUN pip install -r requirements.txt \    <br/>    &amp;&amp; rm -rf /root/.cache <br/>COPY . .</span></pre><p id="81ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这几行，我们告诉Docker从docker hub获取一个python 3.8图像，顺便说一下，这是由FastAPI的同一作者创建的图像。它被优化用于这个框架；然后，我们创建一个新文件夹，放入所有的应用程序代码并安装我们需要的python包。</p><p id="8a1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建docker映像并运行容器。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="13fc" class="ke kf hi ka b fi kg kh l ki kj">docker build -t iris-ml-build .<br/>docker run -d -p 80:80 --name iris-api iris-ml-build</span></pre><p id="051e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在进入<a class="ae mm" href="http://127.0.0.1/docs" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1/docs </a></p><p id="2802" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您应该看到和以前一样，但是现在它运行在docker容器中；您可以将这个docker映像带到任何云提供商，它应该保持不变。</p><h1 id="d288" class="kk kf hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">恭喜你！现在你的应用已经启动并运行了</h1><p id="e0e6" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">您可以从我的GitHub获得完整的代码，并获得更多的功能:</p><p id="87b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae mm" href="https://github.com/rodrigo-arenas/fast-ml-deploy" rel="noopener ugc nofollow" target="_blank">T3【https://github.com/rodrigo-arenas/fast-ml-deploy】T5</a></p><h1 id="deb1" class="kk kf hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">4.额外收获:负载测试</h1><p id="7ed8" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">正如开头提到的，如果我们期望进行实时预测，我们的API的响应时间可能是至关重要的；我们希望我们的API能在几毫秒内做出响应。</p><p id="b6e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用蝗虫来测试我们能得到多少。</p><blockquote class="mf mg mh"><p id="cd43" class="iq ir mi is b it iu iv iw ix iy iz ja mj jc jd je mk jg jh ji ml jk jl jm jn hb bi translated">Locust支持运行分布在多台机器上的负载测试，因此可以用来模拟数百万个并发用户。</p></blockquote><p id="cc46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用pip install Locust安装它；根据你的OS；你可能需要额外的要求:<a class="ae mm" href="https://docs.locust.io/en/stable/installation.html" rel="noopener ugc nofollow" target="_blank">https://docs.locust.io/en/stable/installation.html</a></p><p id="3ea2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建load_test.py文件，并将其放在tests文件夹中；它将帮助我们向我们的API发送数百个请求。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9a9b" class="ke kf hi ka b fi kg kh l ki kj">from locust import HttpUser, TaskSet, task, between<br/><br/>class IrisPredict(TaskSet):<br/>    @task<br/>    def predict(self):<br/>        request_body = {"data": [[4.8, 3, 1.4, 0.3]]}<br/>        self.client.post('/predict', json=request_body)<br/><br/><br/><br/>class IrisLoadTest(HttpUser):<br/>    tasks = [IrisPredict]<br/>    host = 'http://127.0.0.1'<br/>    stop_timeout = 20<br/>    wait_time = between(1, 5)</span></pre><p id="269c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行蝗虫使用</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="a9b9" class="ke kf hi ka b fi kg kh l ki kj">locust -f ./tests/load_test.py</span></pre><p id="1362" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在蝗虫运行在<a class="ae mm" href="http://localhost:8089/" rel="noopener ugc nofollow" target="_blank">http://localhost:8089/</a>；我们可以试试我们的API我们将每秒发送100个用户，直到1000个请求。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/2e8eeccc960a011823531c508b54a04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZoz2aLo_M9JtCeO-YwRUA.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">蝗虫设置</figcaption></figure><p id="f0ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在酷睿i7笔记本电脑、8 Gb内存和四个内核上运行，我们得到的是:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/23726f32151b466de0aa14233c5bcc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AHKDI5yGm6I6gPQsser9w.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">负载测试结果</figcaption></figure><p id="393e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在Locust报告中看到的，我们发送了5415个请求，平均响应时间为6毫秒，这意味着我们能够在测试结束时每秒处理330个请求，并且没有失败。</p><p id="df75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我们的实现来说相当不错！</p></div></div>    
</body>
</html>