<html>
<head>
<title>Intermediate Docker: Storage and Volumes (2/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中级码头工人:存储和卷(2/2)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/intermediate-docker-storage-and-volumes-2-2-1e4e1223295d?source=collection_archive---------23-----------------------#2020-04-18">https://medium.com/analytics-vidhya/intermediate-docker-storage-and-volumes-2-2-1e4e1223295d?source=collection_archive---------23-----------------------#2020-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你回来真是太好了。我们现在可以继续讨论Docker Volumes。</p><p id="0f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，让我们回顾一下。<strong class="ih hj"> Docker卷</strong>被认为是将持久数据存储到Docker的首选方式。</p><p id="164f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您记得执行<strong class="ih hj">绑定挂载</strong>实践依赖于主机的目录结构，与卷的最大区别是这些卷完全由Docker管理，这具有巨大的优势，因为它保证可以在任何地方工作，与存储驱动程序安全共享(稍后解释),最重要的是，可以为容器预先填充，这是自动化的功劳。</p><p id="798c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个用法的例子</p><p id="c05e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">docker run -d --name devtest --mount source=david-vol,target=/app nginx</code></p><p id="2947" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者一个非常简单的方法是借助于<code class="du jd je jf jg b">-v</code>标志</p><p id="25c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工作示例</p><p id="94c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">docker volume ls</code>(列出创建的卷)</p><p id="8853" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">docker volume inspect web-vol | more</code>(一卷完整的详细信息)</p><p id="ddb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以检查卷，在inspect命令的帮助下检查卷部分，如<code class="du jd je jf jg b">docker container inspect [TAG]</code></p><p id="efa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<strong class="ih hj"> Docker Volumes </strong>还有一点需要拯救，那就是可以将相同的数据共享给其他有能力使用它的容器。</p><h1 id="6eb7" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">回到存储问题:存储驱动因素</h1><p id="7cca" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">在hood下有很多事情在进行，但是官方文档规定，当你与一个容器交互时，你实际上并没有写入容器的可写区域，而是使用了Docker卷。</p><p id="fe3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我引用一下，“有些工作负载要求您写入容器可写区域”，为此，您将需要一个存储驱动程序。</p><p id="9198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这还不够清楚，那么<strong class="ih hj">存储驱动</strong>就是允许你写入容器可写层的方式，就像这样，但是你可以在这里找到更多信息<a class="ae kk" href="https://docs.docker.com/storage/storagedriver/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="819a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种类型的存储驱动程序，默认选择的<code class="du jd je jf jg b">overlay2</code>和<code class="du jd je jf jg b">devicemapper</code>(稍后解释)设置为<code class="du jd je jf jg b">overlay2</code>存储驱动程序的替代。</p><p id="9b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">扩展一下，<code class="du jd je jf jg b">devicemapper</code>使用基于块的存储，这意味着它可以访问Docker专用的块设备，并且直接在块级而不是文件级工作。另一方面，Docker可以管理直接连接到主机的物理存储。</p><p id="e2e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我只提到了<code class="du jd je jf jg b">overlay2</code>和<code class="du jd je jf jg b">devicemapper</code>，但是根据你的操作系统风格，还有更多选项。但是，当您更改实例的存储驱动程序时，任何映像和容器都将变得不可访问，这是因为它们的层不能被新的存储驱动程序使用，因此在Docker设置的起点做出决定至关重要。</p><p id="b3b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据文档和一些互联网资源，这里有一个如何更改默认值的快速概述。</p><ol class=""><li id="8aa0" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">首先，我们需要停止服务:<code class="du jd je jf jg b">sudo systemctl stop docker</code></li><li id="f9be" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">将备份文件生成到临时目的地(安全练习)，如下:<code class="du jd je jf jg b">cp -au /var/lib/docker /var/lib/docker.bk</code></li><li id="d892" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">更改存储驱动选项(如果找到的话)，或者将其添加到位于<code class="du jd je jf jg b">vi /etc/docker/deamon.json</code>的配置守护程序文件中</li><li id="65e5" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">毕竟:开始你的服务。<code class="du jd je jf jg b">sudo systemctl start docker</code></li></ol><h2 id="a541" class="kz ji hi bd jj la lb lc jn ld le lf jr iq lg lh jv iu li lj jz iy lk ll kd lm bi translated">设备映射器</h2><p id="f932" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">经过上面的快速解释。设备映射器驱动程序仅支持RHEL、CentOS和Oracle Linux上的Docker EE以及其他Linux版本。</p><p id="1fa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我之前说的，改变存储驱动会导致可用性的损失，为了“保证”功能和避免丢失应用程序数据，盲目地推荐保存你的容器。</p><p id="b65f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为该驱动程序配置的另一件事是用于生产的<code class="du jd je jf jg b">direct-lvm</code>模式，这与设置磁盘分区和逻辑卷的配置相关，以便配置连接到Docker主机的块设备。</p><p id="ad88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深入解释的最佳资源是官方Docker文档。放轻松，这是一个中高级概念。</p><h2 id="8a70" class="kz ji hi bd jj la lb lc jn ld le lf jr iq lg lh jv iu li lj jz iy lk ll kd lm bi translated">簇</h2><p id="7c37" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">Docker集群存储和机器之间的数据共享之间存在直接关系，正如您所看到的，您应该记住，对于任何东西(即使是集群)，卷都是最推荐的结构，应该分布在主机上，这就是数据共享的优势所在。</p><p id="fceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个背景。</p><p id="7def" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具有多个副本的应用程序需要访问一个唯一的或某个相同的文件，以保证所有节点上的信息。</p><p id="0fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过云提供商或卷驱动程序来实现，作为开发人员，您可以编写应用程序或将一些API端点暴露给外部存储解决方案。但是也有很多插件用于不同的服务和协议(甚至是授权)。</p><p id="e968" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，这总是取决于您的设置、特性和软件所包含的功能。</p><p id="c94c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这都是为了这个。这个小系列只是想让您对Docker中的卷和存储是如何工作的以及如何实现有一个直接而简单的了解。这都是我的经验之谈，如果你发现有什么不对的地方，请随时分享并改正。</p><p id="a2b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码:)</p></div></div>    
</body>
</html>