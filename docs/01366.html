<html>
<head>
<title>Applications of Boolean Satisfiability (SAT)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">布尔可满足性的应用</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/application-of-boolean-satisfiability-sat-87f41fb0e5ed?source=collection_archive---------6-----------------------#2019-10-17">https://medium.com/analytics-vidhya/application-of-boolean-satisfiability-sat-87f41fb0e5ed?source=collection_archive---------6-----------------------#2019-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e17345b732a6394ffc37fbf69f50b594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TpbkpowX-ThextKK"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@jamesponddotco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·庞德</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><blockquote class="iv iw ix"><p id="6cb5" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">一个命题是<a class="ae iu" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hj">可满足的</strong> </a> <strong class="jb hj"> </strong>如果有一个赋值给它的变量使它为真；这组输入值就是问题的解决方案。</p></blockquote><p id="417d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们将使用命题可满足性来建模一些问题，包括数独谜题，然后使用基于Python的<a class="ae iu" href="https://pypi.org/project/pycosat/" rel="noopener ugc nofollow" target="_blank"> <em class="ja"> Pycosat </em> </a> SAT求解器包来解决它们。SAT问题需要用<strong class="jb hj">合取范式</strong> ( <strong class="jb hj"> CNF </strong>)建模。在CNF，如果它是一个或多个子句的合取，其中每个子句是文字的析取，则是一个问题；简单地说，它是or的AND。</p><p id="f954" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们看一个简单的例子。</p><h2 id="25ce" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">设p = (x₁ ∧ ( x₁ ∨ x₂) ∧ x₃).p可满足吗？</h2><p id="b07b" class="pw-post-body-paragraph iy iz hi jb b jc kv je jf jg kw ji jj jx kx jm jn jy ky jq jr jz kz ju jv jw hb bi translated">这个命题已经是合取范式；它有三个由连词连接的析取从句。</p><p id="e720" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在Python中，命题被表示为列表的列表，其中每个析取子句被表示为整数的列表。符号对应于布尔值(+代表真，-代表假)，绝对值对应于第I个变量。例如，-1对应x₁ =假，2对应x₂ =真，依此类推。</p><p id="1453" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们的问题可以用Python写成如下:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4bc6" class="ka kb hi lf b fi lj lk l ll lm">&gt;&gt;&gt; p = [[1], [-1, 2], [3]]<br/>&gt;&gt;&gt; print(pycosat.solve(p))<br/>[1, 2, 3]</span></pre><p id="6477" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这个解翻译过来:<em class="ja"> p对于x₁ = x₂ = x₃ =真</em>是可满足的。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="8faa" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们再来看另一个问题。</p><h2 id="9db8" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">给定一个大小为4的列表，其中包含一些值，找出一组介于1-4之间的唯一数字，使得每个数字在列表中只出现一次。</h2><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/b44684455732de5d5896e5b83c6c4d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*f-oUAnkApMI3KqOuk08ZUg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">样本问题</figcaption></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/46df4a148712313b844d52b02e821fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*CuMyU7ZKD_Swp638hyZ4NA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">可能的解决方案</figcaption></figure><p id="3aa5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">设p(i，n)是一个命题，当数字n在单元格I中时为真</em> <strong class="jb hj"> </strong>因为我们有4个单元格，每个单元格可以有4个可能的值，所以我们有16个不同的变量。例如，p(1，2) = True意味着单元格1的值为2。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/aa3d5572898ceee0721a9c4d28b7203e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*hpIXZwijKQu8k0MbmZ_UBg.png"/></div></figure><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4103" class="ka kb hi lf b fi lj lk l ll lm">def p(i, n):<br/>  # returns variable number for a given cell / value combination<br/>  return 4 * (i-1) + n</span></pre><p id="3738" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们可以将我们的问题建模如下</p><ol class=""><li id="d05a" class="lx ly hi jb b jc jd jg jh jx lz jy ma jz mb jw mc md me mf bi translated">对于每个已知值的单元格，我们断言<em class="ja"> p(i，n) = true </em>。</li></ol><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="9ef3" class="ka kb hi lf b fi lj lk l ll lm">sample_input = [0, 3, 0, 1]</span><span id="7a46" class="ka kb hi lf b fi mg lk l ll lm">clauses = []<br/>for i in range(1, 5):<br/>  # lists in python are 0-indexed<br/>  digit = sample_input[i - 1]<br/>  if digit:<br/>    clauses.append([p(i, digit)])<br/>print(clauses)<br/>...<br/>Out: [[7], [13]]</span></pre><p id="31a3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">此输出转换为(x₇ ∧ x₁₃),其中:</p><ul class=""><li id="59aa" class="lx ly hi jb b jc jd jg jh jx lz jy ma jz mb jw mh md me mf bi translated"><em class="ja"> x₇ </em> ≡ <em class="ja"> p(2，3)单元格2的值是3 </em></li><li id="3ed8" class="lx ly hi jb b jc mi jg mj jx mk jy ml jz mm jw mh md me mf bi translated"><em class="ja"> x₁₃ </em> ≡ <em class="ja"> p(4，1)单元格4的值为1。</em></li></ul><p id="7aeb" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">2.断言<em class="ja">列表包含每个数字</em>。</p><p id="e308" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们将逐步构建这个复合命题。我们来构建一个命题"<strong class="jb hj"> q(n) = </strong> <strong class="jb hj">列表包含数<em class="ja"> n </em> " </strong> : <strong class="jb hj"> p(1，n) ∨ p(2，n) ∨ p(3，n) ∨ p(4，n) </strong>。这可以简化为<strong class="jb hj"> q(n) = ∨⁴ᵢ₌₁p(i，n) </strong>。</p><p id="0508" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们现在可以建立一个命题<strong class="jb hj">“列表包含每个数”</strong>:<strong class="jb hj">q(1)∧q(2)∧q(3)∧q(4)</strong>。这可以简化为<strong class="jb hj"> ∧⁴ₙ₌₁∨⁴ᵢ₌₁p(i，n) </strong>。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="389d" class="ka kb hi lf b fi lj lk l ll lm">for n in range(1, 5):<br/>  # q(n) = list contains number n<br/>  q = []<br/>  for i in range(1, 5):<br/>    q.append(p(i, n))<br/>  clauses.append(q)<br/>print(clauses)<br/>...<br/>[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]</span></pre><p id="71ec" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">3.通过对所有的n，n '和I取合取来断言没有一个单元格包含一个以上的数，其中每个变量的范围从1到4，n≠n '为</p><p id="64a0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj"> p(i，n) → p(i，n `)≡p(I，n) ∨ p(i，n`) </strong></p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="c526" class="ka kb hi lf b fi lj lk l ll lm">for i in range(1, 5):<br/>  for n in range(1, 5):<br/>    for n_not in range(1, 5):<br/>      if n == n_not:<br/>        continue<br/>      clauses.append([-p(i, n), -p(i, n_not)])<br/>print(clauses)<br/>...<br/>[-1, -2], [-1, -3], [-1, -4], [-2, -1], [-2, -3], [-2, -4], [-3, -1], [-3, -2], [-3, -4], [-4, -1], [-4, -2], [-4, -3], [-5, -6], [-5, -7], [-5, -8], [-6, -5], [-6, -7], [-6, -8], [-7, -5], [-7, -6], [-7, -8], [-8, -5], [-8, -6], [-8, -7], [-9, -10], [-9, -11], [-9, -12], [-10, -9], [-10, -11], [-10, -12], [-11, -9], [-11, -10], [-11, -12], [-12, -9], [-12, -10], [-12, -11], [-13, -14], [-13, -15], [-13, -16], [-14, -13], [-14, -15], [-14, -16], [-15, -13], [-15, -14], [-15, -16], [-16, -13], [-16, -14], [-16, -15]</span></pre><p id="a604" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们现在可以使用SAT求解器来解决这个问题。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="bc5d" class="ka kb hi lf b fi lj lk l ll lm">for sol in pycosat.itersolve(clauses):<br/>  print(sol)<br/>...<br/>[-1, -2, -3, 4, -5, -6, 7, -8, -9, 10, -11, -12, 13, -14, -15, -16]  [-1, 2, -3, -4, -5, -6, 7, -8, -9, -10, -11, 12, 13, -14, -15, -16]</span></pre><p id="4731" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这两种解决方案是:</p><ul class=""><li id="81fa" class="lx ly hi jb b jc jd jg jh jx lz jy ma jz mb jw mh md me mf bi translated">x₄x₇x₁₀x₁₃</li><li id="fec3" class="lx ly hi jb b jc mi jg mj jx mk jy ml jz mm jw mh md me mf bi translated">x₂x₇x₁₂x₁₃</li></ul></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="d0df" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">最后，让我们<strong class="jb hj">将数独难题建模为可满足性问题</strong>。数独问题与前一个问题非常相似，所以我们不会对一些断言进行过多的描述。</p><p id="367c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><em class="ja">设p(i，j，n)是一个当数字n在第I行第j列的单元格中时为真的命题。我们有9行9列，每个单元格有9个可能的值；因此，我们有729个不同的变量。例如，p(1，2，5) = True意味着单元格(1，2)的值为5。</em></p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="0a60" class="ka kb hi lf b fi lj lk l ll lm">def p(i, j, n):<br/>  # return variable number for cell i,j with value n<br/>  return 81 * (i-1) + 9 * (j-1) + n</span></pre><p id="cbe8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们可以将我们的问题建模如下</p><ol class=""><li id="6e96" class="lx ly hi jb b jc jd jg jh jx lz jy ma jz mb jw mc md me mf bi translated">对于每个已知值的单元格，我们断言<em class="ja"> p(i，j，n) = true </em>。</li></ol><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="dc13" class="ka kb hi lf b fi lj lk l ll lm">for i in range(1, 10):<br/>  for j in range(1, 10):<br/>    digit = puzzle[9 * (i-1) + j - 1]<br/>    if digit:<br/>      clauses.append([p(i, j, digit)])</span></pre><p id="4b40" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">2.断言每一行包含每一个数字<strong class="jb hj"> ∧⁹ᵢ₌₁∧⁹ₙ₌₁∨⁹ⱼ₌₁p(i，j，n) </strong>。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="91a7" class="ka kb hi lf b fi lj lk l ll lm">for i in range(1, 10):<br/>  for n in range(1, 10):<br/>    q = []<br/>    for j in range(1, 10):<br/>      q.append(p(i, j, n))<br/>    clauses.append(q)</span></pre><p id="3dd7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">3.断言每一列都包含每个数字<strong class="jb hj"> ∧⁹ⱼ₌₁∧⁹ₙ₌₁∨⁹ᵢ₌₁p(i，j，n) </strong>。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="0aec" class="ka kb hi lf b fi lj lk l ll lm">for j in range(1, 10):<br/>  for n in range(1, 10):<br/>    q = []<br/>    for i in range(1, 10):<br/>      q.append(p(i, j, n))<br/>    clauses.append(q)</span></pre><p id="9a1a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">4.断言每个3x3块包含每个数<strong class="jb hj">∧ᵣ₌₀∧ₛ₌₀∧⁹ₙ₌₁∨ᵢ₌₁∨ⱼ₌₁p(3r+i，3s+j，n) </strong>。数独有九个3x3的方块。变量r和s允许我们迭代这九个块中的每一个。然后我们用I和j在块内移动。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="f982" class="ka kb hi lf b fi lj lk l ll lm">for r in range(3):<br/>  for s in range(3):<br/>    for n in range(1, 10):<br/>      q = []<br/>      for i in range(1, 4):<br/>        for j in range(1, 4):<br/>          q.append(p(3 * r + i, 3 * s + j, n))<br/>      clauses.append(q)</span></pre><p id="44f0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">5.通过对所有的n，n`, i和j取合取来断言没有一个单元格包含一个以上的数字，其中每个变量的范围从1到9，n≠n `为</p><p id="58a1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj"> p(i，I，n) → p(i，j，n `)≡</strong>T36】p(I，j，n) ∨ p(i，j，n`) </p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="362b" class="ka kb hi lf b fi lj lk l ll lm">for i in range(1, 10):<br/>  for j in range(1, 10):<br/>    for n in range(1, 10):<br/>      for n_not in range(1, 10):<br/>        if n == n_not:<br/>          continue<br/>        clauses.append([-p(i, j, n), -p(i, j, n_not)])</span></pre><p id="7d43" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们现在可以使用SAT求解器来解决这个问题。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="001b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj">本文的代码可以在</strong> <a class="ae iu" href="https://nbviewer.jupyter.org/gist/rummanwaqar/4985fb5b5eebacf18ce5b0e0949fb1e8" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hj">这里找到</strong> </a> <strong class="jb hj">。</strong></p><p id="2caa" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">请注意，这篇文章只是我在学习SAT求解器时的经验总结；我绝不是这方面的专家。如果你发现任何错误，请让我知道。</p><p id="b1b5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">数独求解器的布尔方程取自Rosen K. <em class="ja">离散数学及其应用</em>。第7版。；2011.</p></div></div>    
</body>
</html>