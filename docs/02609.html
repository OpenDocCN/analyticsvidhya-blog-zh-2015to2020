<html>
<head>
<title>Reactive programming using RxJava in spring-boot: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在spring-boot中使用RxJava进行反应式编程:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/reactive-programming-using-rxjava-in-spring-boot-part-1-b33834bed8ea?source=collection_archive---------4-----------------------#2019-12-25">https://medium.com/analytics-vidhya/reactive-programming-using-rxjava-in-spring-boot-part-1-b33834bed8ea?source=collection_archive---------4-----------------------#2019-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9ea475700b4a6e164a661c3ca1e32181.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*fISlWdojUX_cTmjy66_2lA.png"/></div></figure><p id="d36d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">欢迎朋友，很高兴见到你。读完这篇文章后，我可以确定你可以马上开始写代码。</p><p id="4c1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了reactive，你就有了数据流，你必须观察它们，并在值发出时做出反应。</p><p id="a9c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，您需要传感器数据、HTTP请求、通知、流数据、连续位置等数据流，这些数据可以异步处理。</p><p id="9ce6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">大多数web应用程序都是命令式的，操作本质上是顺序的，你有一个调用堆栈，一个操作被另一个操作阻塞，直到它完成，然后只有另一个操作执行。</p><p id="18d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<strong class="io hj">事件驱动应用</strong>的情况下，每个事件单独运行。基本上它保持并发性。这种方法的问题是，我们将有大量的回调。在这里，反应式编程开始发挥作用。</p><p id="39d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想了解更多关于反应式编程的知识，你可以点击这个链接<a class="ae jk" href="https://dzone.com/articles/5-things-to-know-about-reactive-programming" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/5-things-to-know-about-reactive-programming</a></p><p id="96c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以直接进入Rxjava库</p><p id="cb56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您正在使用Gradle、maven或任何其他构建系统，您可以检查此链接，并在您的构建系统中包含您需要的所有依赖项</p><div class="jl jm ez fb jn jo"><a href="https://github.com/ReactiveX/RxJava/wiki/Getting-Started" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">react vex/rx Java</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">这是一个库，用于使用…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">github.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc ik jo"/></div></div></a></div><p id="2c04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可观察接口是Rxjava库的基本组件</p><p id="397b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可观察的接口传递三种类型的事件。</p><ol class=""><li id="99bc" class="kd ke hi io b ip iq it iu ix kf jb kg jf kh jj ki kj kk kl bi translated"><strong class="io hj"> onNext </strong>:传递数据(发射)给观察者实例。</li><li id="d487" class="kd ke hi io b ip km it kn ix ko jb kp jf kq jj ki kj kk kl bi translated">onComplete :当观察者完成所有发射时调用</li><li id="3019" class="kd ke hi io b ip km it kn ix ko jb kp jf kq jj ki kj kk kl bi translated"><strong class="io hj"> onError </strong>:发生异常或错误时调用。</li></ol><p id="c6aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是我们如何创造可观察的</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="b427" class="la lb hi kw b fi lc ld l le lf"><br/>   Observable&lt;Object&gt; source= Observable.create(emmiter-&gt;{<br/>          try{<br/>          <br/>               emmiter.onNext("first");<br/>               emmiter.onNext("second");<br/>               emmiter.onNext("third");<br/>               emmiter.onComplete();</span><span id="2230" class="la lb hi kw b fi lg ld l le lf">            }catch(Exception ex){<br/>               emmiter.onError(ex);<br/>            }<br/>           });</span><span id="7778" class="la lb hi kw b fi lg ld l le lf">   }</span></pre><p id="2605" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在onNext函数中，我们发出三个字符串值，一旦发出完成，我们就调用onComplete来通知发出完成。</p><p id="72ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们有了数据流，我们必须观察它。为此，我们需要Observer类来订阅Observable类并实现所有三个功能。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8bf0" class="la lb hi kw b fi lc ld l le lf">Observer&lt;String&gt; observer = new Observer&lt;String&gt;(){</span><span id="0103" class="la lb hi kw b fi lg ld l le lf"> @Override<br/> public void onComplete() {<br/>  System.out.println("Emission completed ..");<br/> }<br/> <br/> @Override<br/> public void onError(Throwable arg0) {<br/>  System.out.println("Error occurred: "+arg0.getLocalizedMessage());<br/> }</span><span id="e9e0" class="la lb hi kw b fi lg ld l le lf"> @Override<br/> public void onNext(String arg0) {<br/>  System.out.println("Data is .. "+arg0);<br/> }<br/>};</span></pre><p id="deb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们需要给观察者订阅可观察的，我们可以通过</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7f4e" class="la lb hi kw b fi lc ld l le lf">source.subscribe(observer);</span></pre><p id="e620" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们运行上面的代码时，我们将得到输出。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2e5b" class="la lb hi kw b fi lc ld l le lf">Data is .. first<br/>Data is .. second<br/>Data is .. third<br/>Emission completed ..</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="c83c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有其他一些方法来创造可观的，如</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c74d" class="la lb hi kw b fi lc ld l le lf">Observable&lt;Object&gt; source= Observable.just("first", "second", "third", "four");</span></pre><p id="9cb8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们使用just函数来传递排放数据。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3eb8" class="la lb hi kw b fi lc ld l le lf">List&lt;String&gt; countryList = Arrays.asList("first", "second", "third");</span><span id="5fd6" class="la lb hi kw b fi lg ld l le lf">Observable&lt;String&gt; source = Observable.fromIterable(countryList);</span></pre><p id="d4e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从列表中，我们也可以创建可观的。</p><p id="b661" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">可观测量中的一些基本算子</strong></p><ol class=""><li id="0754" class="kd ke hi io b ip iq it iu ix kf jb kg jf kh jj ki kj kk kl bi translated"><strong class="io hj">映射和过滤</strong></li></ol><p id="3c0c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Map操作符应用于源可观察对象发出的每个项目，并返回发出这些函数应用结果的可观察对象。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2568" class="la lb hi kw b fi lc ld l le lf">Observable&lt;String&gt; source= Observable.just("map operator ","source observer returns in upper case","using map we are returning in upper case","using map operator"); <br/>        source.map(String::toUpperCase).subscribe(System.out::println);</span></pre><p id="f960" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">过滤器-根据条件过滤可观测的发射。它只返回那些符合条件的排放</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ff2f" class="la lb hi kw b fi lc ld l le lf">Observable&lt;Integer&gt; source = Observable.range(0,10); </span><span id="ce9c" class="la lb hi kw b fi lg ld l le lf">source.filter(i-&gt; i%2==0).map(i-&gt; i*i).subscribe(System.out::println);</span></pre><p id="98f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。开始、重复、缩小、扫描</strong></p><p id="cb71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lo lp lq kw b">startWith()</code>将给定元素附加到发射的开始</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5e58" class="la lb hi kw b fi lc ld l le lf">Observable&lt;String&gt; source = Observable.just("Rx", "Java", " Operators", " Tutorial");<br/>       <br/>source.startWith("We are discussing here about ").subscribe(System.out::print);</span></pre><p id="effa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lo lp lq kw b">reduce()</code>它将下一个值添加到先前添加的值中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ab00" class="la lb hi kw b fi lc ld l le lf">Observable&lt;Integer&gt; source = Observable.range(1, 5);</span><span id="5af3" class="la lb hi kw b fi lg ld l le lf">source.reduce((integer, integer2) -&gt; integer + integer2).subscribe(System.out::println);</span><span id="a742" class="la lb hi kw b fi lg ld l le lf">//Output<br/>1<br/>3<br/>and so on. </span></pre><p id="17fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">repeat()重复发射两次</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e330" class="la lb hi kw b fi lc ld l le lf">Observable.just("Java", "Nodejs", "Python")                 .repeat(2).subscribe(System.out::println);</span><span id="6ab1" class="la lb hi kw b fi lg ld l le lf">//Output<br/>Java<br/>Nodejs<br/>Python<br/>Java<br/>Nodejs<br/>Python</span></pre><p id="aca7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3。排序</strong>对元素进行排序</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="05cf" class="la lb hi kw b fi lc ld l le lf">Observable&lt;String&gt; source = Observable.just(1,3,4,2,8,6,7)                 source.sorted.subscribe(System.out::println);</span></pre><p id="be4f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">合并相关运算符</strong></p><p id="9a0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们需要合并两个可观测的。我们需要对第一个可观测值的发射进行一些操作，并返回一个新的可观测值。</p><p id="9518" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设一个网络调用以编码的形式返回数据流，现在你解码它，然后返回一个新的可观察值，然后一些用户可以使用这些数据。</p><p id="ef48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一些算子用来合并多个可观测量。</p><ol class=""><li id="c5e3" class="kd ke hi io b ip iq it iu ix kf jb kg jf kh jj ki kj kk kl bi translated"><strong class="io hj">平面图</strong></li></ol><p id="4252" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">平面图将一个可观测物发出的项目转换成新的可观测物。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ef39" class="la lb hi kw b fi lc ld l le lf">Observable&lt;String&gt; source1= Observable.just("abcdef", "123456", "ABCDEF");</span><span id="3b46" class="la lb hi kw b fi lg ld l le lf">source1.flatMap(emission-&gt; Observable.fromArray(emission.split(""))).subscribe(System.out::println);</span><span id="2095" class="la lb hi kw b fi lg ld l le lf">// Output</span><span id="cdb1" class="la lb hi kw b fi lg ld l le lf">a<br/>b<br/>c<br/>d<br/>e<br/>f<br/>...</span></pre><p id="dd13" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Second observable逐个获取元素，然后打印该元素的每个字符</p><p id="9215" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.<strong class="io hj">串联图</strong></p><p id="3101" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它类似于平面地图，只是后者不维持秩序。因此，如果您需要在发射中排序，请使用concatMap。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><blockquote class="lr ls lt"><p id="a431" class="im in lu io b ip iq ir is it iu iv iw lv iy iz ja lw jc jd je lx jg jh ji jj hb bi translated"><strong class="io hj">一个使用Rxjava的样例用例项目</strong></p></blockquote><p id="93dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">您可以在</strong>中找到完整的项目代码</p><div class="jl jm ez fb jn jo"><a href="https://github.com/kshivam213/demo_rxjava/tree/master/src/main/java/com/rxjava/news" rel="noopener  ugc nofollow" target="_blank"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">kshivam213/demo_rxjava</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">github.com</p></div></div><div class="jx l"><div class="ly l jz ka kb jx kc ik jo"/></div></div></a></div><p id="4fa5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">要求</strong></p><ol class=""><li id="63c9" class="kd ke hi io b ip iq it iu ix kf jb kg jf kh jj ki kj kk kl bi translated">与https://newsapi.org/<a class="ae jk" href="https://newsapi.org/" rel="noopener ugc nofollow" target="_blank">整合</a></li><li id="a653" class="kd ke hi io b ip km it kn ix ko jb kp jf kq jj ki kj kk kl bi translated">每天我们必须获取最新的新闻，并使用cronJob存储在数据库中。这里我们要用Rxjava调用API，并存储在DB中。</li><li id="44a7" class="kd ke hi io b ip km it kn ix ko jb kp jf kq jj ki kj kk kl bi translated">公开根据国家、语言和类别等条件返回最新新闻的端点。</li></ol><p id="d2bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更多细节请参考上面GitHub链接上的项目代码。</p><p id="dd0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">包装</strong></p><p id="2c0c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望你喜欢这个教程，在下一部分，我将讨论可流动，反压力，反压力策略，分片，重试机制和缓存。</p><p id="fbda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">有用资源</strong></p><ol class=""><li id="bda2" class="kd ke hi io b ip iq it iu ix kf jb kg jf kh jj ki kj kk kl bi translated"><a class="ae jk" href="https://www.baeldung.com/rxjava-tutorial" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/rxjava-tutorial</a></li></ol></div></div>    
</body>
</html>