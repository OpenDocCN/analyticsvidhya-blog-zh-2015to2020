<html>
<head>
<title>Efficient Data Structures for Permutations Grouping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于排列分组的高效数据结构</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/efficient-data-structures-for-permutations-grouping-e9d37d41e8c3?source=collection_archive---------13-----------------------#2020-07-07">https://medium.com/analytics-vidhya/efficient-data-structures-for-permutations-grouping-e9d37d41e8c3?source=collection_archive---------13-----------------------#2020-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/65088699ba5d48a2922830ccaa702a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NnWp1_q1ZsPckM5q2KOtoQ.png"/></div></div></figure><div class=""/><p id="dc49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你有一个单词列表，我们如何找到它们之间的排列？</p><p id="5e9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这似乎是一个理论问题…的确如此！然而，解决这个问题帮助我赢得了一份周报的谜语奖:)</p><h2 id="9d8a" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">蛮力，机智的蛮力</h2><p id="89e4" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">给定一个单词，简单、麻烦的强力方法是生成它的所有排列，并对给定列表中出现的所有排列进行分组。</p><p id="e449" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于种种原因，这种方法是不好的，所以让我们继续寻找一个更可行的解决方案；</p><p id="fe3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个更好的强力解决方案是检查所有单词，将每个单词的字母排序并分组；</p><p id="b59f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即</p><p id="9417" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单词listen和silent在同一个单词组eilnst中</p><figure class="ko kp kq kr fd hk"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="c54d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对每个单词的字母进行排序效率不高，尤其是在设计一个可以处理长单词的通用数据结构时，所以让我们尝试另一种方法…</p><h2 id="879a" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">柱状图</h2><p id="0a8e" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">你可能已经想到，排列只是字母之间的交换——所以每个字母的总数保持不变。因此，当给出两个单词的直方图时，我们可以立即确定它们是否属于同一家族。</p><p id="6532" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将字典关键字设置为每个单词的字母直方图:</p><figure class="ko kp kq kr fd hk"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="eb20" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行基准测试时，它甚至比排序方法花费更多的时间。</p><p id="46b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将_get_item_key函数分成两部分[ _get_item_key_to_histogram，_get_item_key_to_hashable ]并运行cProfile进行分析:</p><pre class="ko kp kq kr fd ku kv kw kx aw ky bi"><span id="8244" class="jo jp ht kv b fi kz la l lb lc">ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>   466551    1.561    0.000    1.807    0.000 permutations_grouping.py:44(_get_item_key_to_histogram)<br/>   466551    0.474    0.000    0.474    0.000 permutations_grouping.py:50(_get_item_key_to_hashable)</span></pre><p id="f618" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们看到构建直方图花费了一秒多的时间，然后将结果转换成可散列的形式花费了将近半秒。</p><p id="7570" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们能想出一个更好的解决方案吗？</p><h2 id="86d0" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">数论对我们有帮助</h2><p id="acff" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">让我们把问题转到数论领域；</p><p id="bc26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">字母将是数字，我们正在寻找一个序列是否等价于另一个序列，而不考虑顺序的重要性——因此乘法运算符对我们有好处，因为它具有交换性质。</p><p id="3fd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果我们给字母随机分配不同的数字，我们很可能会以冲突结束:</p><p id="5b30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即</p><p id="7928" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于赋值{ a : 3，b : 5，r : 15 }我们可能认为‘ab’= 3 * 5 = 15和‘r’= 15是一样的。</p><p id="8ab9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当用于表示不同单词排列族的键的数字具有相同的除数时，问题就出现了。</p><p id="481a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，分配的数字必须是质数！</p><p id="3d89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">质数没有公约数，这最适合于识别不同的字母——这样我们可以避免冲突。</p><p id="4e82" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">急切地，让我们将理论见解转换成代码；</p><figure class="ko kp kq kr fd hk"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="64cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们运行分析:</p><pre class="ko kp kq kr fd ku kv kw kx aw ky bi"><span id="4b8b" class="jo jp ht kv b fi kz la l lb lc">ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>   466551    1.017    0.000    1.262    0.000 permutations_grouping.py:71(_get_item_key)</span></pre><p id="b9c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将总的密钥创建时间减少到了一秒——还不错:)</p><h2 id="ba61" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">频率分析</h2><p id="e00d" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">现在作为质数乘法计算的一些密钥会产生很大的数字，这也会影响性能。</p><p id="2326" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可以通过单词域中的频率分析来减轻；不同的字母以不同的概率出现——这是阿拉伯学者Al-Kindi在9世纪首次描述的；有人建议，对《古兰经》进行仔细的文本研究，首先发现阿拉伯语有一个特征性的字母频率。</p><p id="be49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以让我们给最频繁出现的字母分配较低的质数；</p><figure class="ko kp kq kr fd hk"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="3405" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们运行分析器，我们可以看到，对于466，551个项目，当前生成密钥的总时间不到半秒钟！</p><pre class="ko kp kq kr fd ku kv kw kx aw ky bi"><span id="9232" class="jo jp ht kv b fi kz la l lb lc">ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>   466551    0.466    0.000    0.466    0.000 permutations_grouping.py:71(_get_item_key)</span></pre><p id="6e8a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="le">喜欢这篇文章吗？随意长按👏下面的按钮😀</em>T5】</strong></p></div></div>    
</body>
</html>