<html>
<head>
<title>Design a simple neural network with NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NumPy设计一个简单的神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/design-a-simple-neural-network-with-numpy-d7f500cc1b51?source=collection_archive---------26-----------------------#2020-06-13">https://medium.com/analytics-vidhya/design-a-simple-neural-network-with-numpy-d7f500cc1b51?source=collection_archive---------26-----------------------#2020-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="a3c0" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">"告诉我，我会忘记；教我，我会记住；让我参与，我会学习."—本杰明·富兰克林</p></blockquote><p id="24a8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">经常听身边的人说，神经网络是一个很难把握和猜测的概念！在我弄脏手一头扎进NN世界之前我也是这么想的！所以这里有一篇文章，我希望它能帮助你理解什么是神经网络。快乐阅读！</p><p id="9dd4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这是我在学习神经网络时尝试过的最好的事情之一，这帮助我更好地理解了深度神经网络。我非常兴奋能和大家分享整个过程。所以，事不宜迟，让我们开始吧！！</p><p id="a536" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">首先，我想介绍一些基本术语，我们需要使用这些术语:</p><p id="0ec2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">神经网络</strong>:广义地说，神经网络是一套算法，大致模仿人脑，旨在识别模式。他们通过一种机器感知、标记或聚类原始输入来解释感官数据。所以我想如果我说如果我们反复做一件事很多次，我们就能做得更好，我不会错，不是吗？在你完善食物中的盐量之前，你尝试过多少次？</p><p id="957e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj"> Numpy </strong> : Numpy是python中编码和执行科学操作的基础包。在设计简单的神经网络时，我们将从这个包中得到很多帮助。要将NumPy导入到您的Python笔记本中(我更喜欢使用Jupyter notebook，您可以使用Google Colab，通过它您可以利用Google最先进的云服务器以及它们的CPU、GPU和TPU。)下面是Colab笔记本的链接:</p><p id="3642" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><a class="ae jk" href="http://colab.research.google.com" rel="noopener ugc nofollow" target="_blank"> GoogleColab </a>笔记本</p><p id="de3d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">输入</strong>:这些将是我们提供给模型训练的数据。在本练习中，我们将从NumPy的均匀分布中选择输入，在给定初始值和最终值的情况下，NumPy将为您创建一个数组，其中每个元素从指定间隔中被选中的概率相等。这可以是任何其他分布，并且是绝对随机的，读者可以自己尝试正态分布。</p><p id="19c2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">目标</strong>:这些是每个输入的期望值。在这里，我们将采用一个随机等式，并自己手动生成目标。然而，现实生活中的<strong class="il hj">不会是这样的</strong>。选择这个例子只是为了演示神经网络是如何工作的。这些由tᵢ.表示</p><p id="9d00" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">输出</strong>:这些是机器根据输入预测的值。稍后在编码部分，目标和输出之间的差异将由变量<strong class="il hj"> deltas </strong>表示。这些由yᵢ.表示</p><p id="ec94" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">损失函数</strong>:有时也称为成本函数。我们的目标是尽量减少损失。我们上下文中的损失函数评估关于目标的输出的准确性。在这个例子中，我们将使用L2-诺姆损失函数。它由下式给出:</p><p id="24bc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">L(y，t) = ∑(yᵢ-tᵢ)</p><p id="9685" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">优化算法</strong>:该算法由机制组成，通过该机制我们可以改变参数(权重和偏差)来优化损失函数。这里我们将使用n参数梯度下降。不用深入研究数学，</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/01d254896d5f6b27fe4c99123847d801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tL_AC0RmJPKd3gd7HrQlcg.png"/></div></div></figure><p id="4eef" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">其中，wᵢ代表权重，bᵢ代表每个输入变量的偏差，η是模型的学习速率。</p><p id="e1f0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果读到这里的任何人对矩阵乘法感到不舒服，我建议你读一下<a class="ae jk" href="https://en.wikipedia.org/wiki/Matrix_multiplication#:~:text=In%20mathematics%2C%20matrix%20multiplication%20is,rows%20in%20the%20second%20matrix." rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="4d02" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">现在让我们动手开始编码吧！！</p><p id="99dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们需要的唯一的库是NumPy。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jx"><img src="../Images/eaa00d52a9fdbccedeb48c8b6a60dd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFiZCSePovwvv_rbdSK5bA.png"/></div></div></figure><p id="77ab" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我称变量为x和z。正如我在输入部分所说的，我将从NumPy随机均匀分布生成输入。我还将使用NumPy列堆栈方法将它们放入矩阵形式。这个输入矩阵的维数是(1000 X 2)，其中1000是观察值的数目，2是输入变量的数目。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jy"><img src="../Images/8927b40298881d0e97113937acb3d90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9l9joo_KEbYTpabOKXt5Yg.png"/></div></div></figure><p id="06b1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">现在我将生成目标。目标将由下面代码中的随机等式生成。我们模型的主要目的是确定权重(系数)和偏差(常数)。为了使我们的数据随机化一点，我将在其中添加噪声。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jz"><img src="../Images/2acdc42962bfbe929c386b0eb4c2a156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qX8sQthljcbBmtwd5ShYMg.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">注意:不要添加非常高的噪声，因为这会破坏数据的潜在趋势。</figcaption></figure><p id="4e15" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这样，我生成了一个假数据，我们将使用它来填充我们的模型。我唯一剩下的就是初始化权重和偏差。同样，我将使用NumPy随机均匀分布。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es ke"><img src="../Images/f5c1d15e383b763a468cd5f9daf923a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*5aypd-p8HcnMK5vdUe4CGg.png"/></div></figure><p id="24d4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">现在是棘手的部分，我将设计网络。</p><p id="276f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">为了训练网络，我将使用100次迭代。这里我设置η(learning_rate)为0.01。我们不希望这个值太高。对于这一部分，您将需要非常基本的python编码技能。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kf"><img src="../Images/ef0238531159af5430968b210d8c863f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0dxxFqBqrMTvsB8a7jTwA.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">在图中代码单元的输出部分，按降序打印的值是每次迭代后的损失函数值。你会发现损失在逐渐减少。</figcaption></figure><p id="bad6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">有趣的是。如果你一次又一次地运行这个单元，你会发现损失函数值是递减的，直到一段时间后，这些值不再变化。机器已经学习了，它不能进一步改进它的学习。我将这段代码运行了三次，得出了以下权重和偏差。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kg"><img src="../Images/28f902240e7e3b895f38c998df665887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZZGNmlYNSst_8-9Od9MUg.png"/></div></div></figure><p id="24f0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果您使用matplotlib绘制输出和目标，您会看到类似这样的内容。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kh"><img src="../Images/83147d3292adf021a75053192fb479f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIoKKzm7dwSj_VsXR1g4nw.png"/></div></div></figure><p id="b82e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">没错。你看到的是一条与x轴几乎成45ᵒ的直线。这类似于公式y=x，并且我们确信我们的模型已经预测了权重和偏差，使得输出非常接近目标。</p><p id="260c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这是最简单的例子。神经网络的深度为零，甚至数据都是手动生成的。但是我觉得这是在使用其他艺术软件包之前学习NNs的第一步。</p><p id="2090" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">恭喜你用NumPy创建了你的第一个神经网络！</p></div></div>    
</body>
</html>