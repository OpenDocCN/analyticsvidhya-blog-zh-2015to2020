<html>
<head>
<title>Model Diagnostics and Selection — 9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模型诊断和选择— 9</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/model-diagnostics-and-selection-9-7a79c4d70a24?source=collection_archive---------9-----------------------#2019-12-12">https://medium.com/analytics-vidhya/model-diagnostics-and-selection-9-7a79c4d70a24?source=collection_archive---------9-----------------------#2019-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="d688" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi">如果您还没有阅读R数据分析系列的第8部分，请仔细阅读下面的文章，其中我们讨论了</em> <a class="ae jh" rel="noopener" href="/@viveksrinivasan/multiple-linear-regression-2f28ad463e68">多元线性回归— 8 <em class="hi">。</em> </a></p><p id="7863" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这篇文章的内容是我在IIM-B时代得到的几本书的要点。</p><p id="f85a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi">人人为我——贾里德·p·兰德</em></p><p id="e01a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi">实用数据科学与R — Nina Zumel &amp;约翰·芒特</em></p><p id="081c" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi">文中讨论的所有代码块都以R markdown的形式出现在</em> <a class="ae jh" href="https://github.com/viveksrinivasanss/Data_Science_Using_R" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Github链接</em> </a> <em class="hi">中。</em></p><p id="6502" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi">要看我写的所有文章请使用链接，</em><a class="ae jh" rel="noopener" href="/@viveksrinivasan"><em class="hi">Vivek Srinivasan</em></a><em class="hi">。</em></p></blockquote><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/d361e4dcf7137cc6b6d66d379f07ce9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFKoC_Xd0dMzmYZ2sSfJig.png"/></div></div></figure><p id="25c0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi jx translated"><span class="l jy jz ka bm kb kc kd ke kf di"> B </span>建立一个模型可能是一个永无止境的过程，在这个过程中，我们不断地通过添加交互、去掉变量、进行转换等等来改进模型。然而，在某些时候，我们需要确认我们有当时最好的模型，甚至是一个好模型。这就引出了一个问题:我们如何判断一个模型的<code class="du kg kh ki kj b">quality </code>？</p><p id="ed8c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">几乎在所有情况下，答案都是:与其他模式相关。这可以是对<code class="du kg kh ki kj b">residuals</code>、一个<code class="du kg kh ki kj b">ANOVA </code>测试的结果、<code class="du kg kh ki kj b">Wald </code>测试、<code class="du kg kh ki kj b">drop-in deviance</code>、<code class="du kg kh ki kj b">AIC </code>或<code class="du kg kh ki kj b">BIC </code>分数、<code class="du kg kh ki kj b">cross-validation</code>错误或<code class="du kg kh ki kj b">bootstrapping</code>的分析。</p><h2 id="b9ef" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">残差</h2><p id="f8f9" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">评估模型质量的第一种方法是对<code class="du kg kh ki kj b">residuals</code>进行分析，T9是实际响应和拟合值(模型预测值)之间的差异。这是我们上一篇文章中讨论的公式的直接结果，其中误差类似于残差，是<code class="du kg kh ki kj b">normally </code>分布的。基本思想是，如果模型适当地适合数据，残差也应该是正态分布的。为了看到这一点，我们从拟合回归的住房数据开始，并用系数图可视化。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="219d" class="kk kl hi kj b fi lo lp l lq lr">housing &lt;- read.table("../data/housing.csv",sep = ",", header = TRUE,stringsAsFactors = FALSE)<br/>names(housing) &lt;- c("Neighborhood", "Class", "Units", "YearBuilt","SqFt", "Income", "IncomePerSqFt", "Expense",<br/>                    "ExpensePerSqFt", "NetIncome", "Value","ValuePerSqFt", "Boro")<br/>housing &lt;- housing[housing$Units &lt;   1000, ]<br/>house1 &lt;- lm(ValuePerSqFt ~ Units + SqFt + Boro, data=housing)<br/>summary(house1)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ls"><img src="../Images/b5ac434c3fb35f345d47e48eef76cfdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQOcux9L-PtdjGxmS2Dkwg.png"/></div></div></figure><p id="e8de" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">从模型中获取系数的一个快速方法是使用<code class="du kg kh ki kj b">coef </code>函数，或者在模型对象上使用<code class="du kg kh ki kj b">$</code>操作符从模型中获取系数，正如我们在上一篇文章中所讨论的。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="631c" class="kk kl hi kj b fi lo lp l lq lr">library(coefplot)<br/>coefplot(house1)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lt"><img src="../Images/3c5d137aa01f71082511572271258954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjiWJ2I1jO5MpPWx02e5qA.png"/></div></div></figure><p id="81b2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">对于线性回归，三个重要的残差图是<code class="du kg kh ki kj b">fitted values against residuals</code>、<code class="du kg kh ki kj b">Q-Q plots</code>和<code class="du kg kh ki kj b">histogram of residuals.</code>，第一个很容易用ggplot2得到。幸运的是，ggplot2有一个对付<code class="du kg kh ki kj b">lm </code>模型的简便招数。我们可以使用模型作为数据源，ggplot2“强化”它，创建新的列，以便于绘图。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="27be" class="kk kl hi kj b fi lo lp l lq lr">library(ggplot2)<br/># see what a fortified lm model looks like<br/>head(fortify(house1))</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lu"><img src="../Images/1ad2cae8b138342877bd63dbae447e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eftA5YmgRMnUfWGXZHXDAQ.png"/></div></div></figure><p id="8e1a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">下图所示的<code class="du kg kh ki kj b">residuals </code>对<code class="du kg kh ki kj b">fitted values</code>的曲线乍一看令人不安，因为残差中的模式显示它们并不像期望的那样随机分散。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="bc00" class="kk kl hi kj b fi lo lp l lq lr">ggplot(aes(x=.fitted, y=.resid), data = house1) +<br/>  geom_point() +<br/>  geom_hline(yintercept = 0) +<br/>  geom_smooth(se = FALSE) +<br/>  labs(x="Fitted Values", y="Residuals")</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lv"><img src="../Images/bd180fd009aa488bbad899b2fea989cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ly_wYh82-BYBYYDDbWWb3w.png"/></div></div></figure><p id="f62b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">然而，进一步的调查显示，这是由于结构的<code class="du kg kh ki kj b">Boro </code>给数据的模式，它会很好。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="844c" class="kk kl hi kj b fi lo lp l lq lr">ggplot(aes(x=.fitted, y=.resid), data = house1) +<br/>  geom_point() +<br/>  geom_hline(yintercept = 0) +<br/>  geom_smooth(se = FALSE) +<br/>  labs(x="Fitted Values", y="Residuals") +<br/>  geom_point(aes(color=Boro))</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lw"><img src="../Images/7e3a87d639bc85d4705970b22836d8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwZNycSAt-aUO0cRtEwUTA.png"/></div></div></figure><p id="e1b0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">接下来是<code class="du kg kh ki kj b">Q-Q plot</code>。如果模型非常适合，则当绘制正态分布的理论分位数时，标准化残差应该都落在一条直线上。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="9186" class="kk kl hi kj b fi lo lp l lq lr">ggplot(house1, aes(sample=.stdresid)) + stat_qq() + geom_abline()</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lx"><img src="../Images/a01e79d5e69b0673288216a8a7d1815d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9T0cFjg7n0lydrxgnEq3Og.png"/></div></div></figure><p id="18bf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">Q-Q plot</code>用于house1。尾部偏离理想的理论线，表明我们没有最好的拟合。</p><p id="78a2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">另一个诊断是<code class="du kg kh ki kj b">residuals</code>的<code class="du kg kh ki kj b">histogram </code>。直方图不是正态分布的，这意味着我们的模型不是完全正确的规格。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="1c9e" class="kk kl hi kj b fi lo lp l lq lr">ggplot(house1, aes(x=.resid)) + geom_histogram()</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ly"><img src="../Images/b3a2e5b1191ec932d0c9efa32073b8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYc0VjX8X6c6JyaOOLOnLw.png"/></div></div></figure><h2 id="8c57" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">型号选择</h2><p id="7033" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">所有这些模型拟合的度量只有在比较多个模型时才有意义，因为所有这些度量都是相对的。因此，我们将拟合一些模型，以便相互比较。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="cdf1" class="kk kl hi kj b fi lo lp l lq lr">house2 &lt;- lm(ValuePerSqFt ~ Units * SqFt + Boro, data=housing)<br/>house3 &lt;- lm(ValuePerSqFt ~ Units + SqFt * Boro + Class,data=housing)<br/>house4 &lt;- lm(ValuePerSqFt ~ Units + SqFt * Boro + SqFt*Class,data=housing)<br/>house5 &lt;- lm(ValuePerSqFt ~ Boro + Class, data=housing)</span></pre><p id="aa2c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">像往常一样，我们的第一步是使用<code class="du kg kh ki kj b">coefplot </code>包中的<code class="du kg kh ki kj b">multiplot </code>一起可视化模型。结果显示<code class="du kg kh ki kj b">Boro </code>是唯一对<code class="du kg kh ki kj b">ValuePerSqFt </code>有显著影响的变量，某些<code class="du kg kh ki kj b">condominium </code>类型也是如此。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="8496" class="kk kl hi kj b fi lo lp l lq lr">multiplot(house1, house2, house3, house4, house5, pointSize=2)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lz"><img src="../Images/775f669cb284991b6b158e47af22e6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ss_3hqU4UjCWRXhzVcpfaw.png"/></div></div></figure><h2 id="4d43" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">模型选择的方差分析</h2><p id="38ba" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">虽然我们不提倡使用<code class="du kg kh ki kj b">ANOVA </code>进行多样本测试，但我们相信它在测试不同模型的相对优点时是有用的。简单地将多个模型对象传递给<code class="du kg kh ki kj b">anova </code>将返回一个结果表，其中包括残差平方和<code class="du kg kh ki kj b">(RSS)</code>，残差平方和是对误差的度量，越低越好。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="d778" class="kk kl hi kj b fi lo lp l lq lr">anova(house1, house2, house3, house4, house5)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ma"><img src="../Images/6ff539bd601ba13e5c888df94189bc09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pM3lMTn6TlZ7oF7WIvdDMg.png"/></div></div></figure><p id="8b00" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">这表明第四个模型<code class="du kg kh ki kj b">house4</code>具有最低的<code class="du kg kh ki kj b">RSS</code>，这意味着它是该组中最好的模型。<code class="du kg kh ki kj b">RSS </code>的问题在于，当一个额外的变量被添加到模型中时，它总是会得到改善。这可能导致模型过于复杂和过度拟合。</p><h2 id="ff6e" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">AIC和BIC</h2><p id="681a" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">另一个惩罚模型复杂性的度量是<code class="du kg kh ki kj b">Akaike Information Criterion (AIC)</code>。与<code class="du kg kh ki kj b">RSS</code>一样，具有最低<code class="du kg kh ki kj b">AIC </code>——甚至负值——的模型被认为是最优的。<code class="du kg kh ki kj b"> BIC (Bayesian Information Criterion)</code>是一个类似的指标，同样，越低越好。AIC的公式是</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mb"><img src="../Images/0dc52b04699deefb6ea99b570943b293.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*adEfI29QAqsbUp_g-3jbzA.png"/></div></figure><p id="cc30" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">其中<code class="du kg kh ki kj b">ln(L)</code>是最大化的对数似然，而<code class="du kg kh ki kj b">p</code>是模型中系数的数量。随着模型的改进，对数似然变得更大，并且因为该项被取消了，所以<code class="du kg kh ki kj b">AIC</code>变得更低。然而，增加系数会增加AIC；这不利于模型的复杂性。<code class="du kg kh ki kj b">BIC </code>的公式与此类似，只是它不是将系数乘以2，而是乘以行数的自然对数。这见于</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mc"><img src="../Images/fb0f6e58b7a2de6e6712f5de981f8beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*QelzZH-M-D_cAnpQHxlhEg.png"/></div></figure><p id="5d4b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">我们模型的<code class="du kg kh ki kj b">AIC </code>和<code class="du kg kh ki kj b">BIC </code>分别使用<code class="du kg kh ki kj b">AIC </code>和<code class="du kg kh ki kj b">BIC </code>函数计算。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="576a" class="kk kl hi kj b fi lo lp l lq lr">AIC(house1, house2, house3, house4, house5)<br/>BIC(house1, house2, house3, house4, house5)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es md"><img src="../Images/c8de5cc624bc38918b6b9b1738185927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3EHhMxpAg4M3wLa4Rd1q-w.png"/></div></div></figure><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es me"><img src="../Images/54812d79eee6af4018b9c4fdff4a117d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sz66KrXnsxGFpbjLh-2IWw.png"/></div></div></figure><p id="1f98" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">同样，从上表可以看出，型号<code class="du kg kh ki kj b">house4 </code>比其他型号更好，因为它的<code class="du kg kh ki kj b">AIC </code>和<code class="du kg kh ki kj b">BIC </code>得分最低。</p><h2 id="bf12" class="kk kl hi bd km kn ko kp kq kr ks kt ku ju kv kw kx jv ky kz la jw lb lc ld le bi translated">交叉验证</h2><p id="186b" class="pw-post-body-paragraph ii ij hi il b im lf io ip iq lg is it ju lh iw ix jv li ja jb jw lj je jf jg hb bi translated">残差诊断和模型测试，如<code class="du kg kh ki kj b">ANOVA </code>和<code class="du kg kh ki kj b">AIC </code>有点过时，是在现代计算能力之前出现的。评估模型质量的首选方法——至少对大多数数据科学家来说——是交叉验证，有时称为<code class="du kg kh ki kj b"> k-fold cross-validation</code>。数据被分成k个(通常是五个或十个)不重叠的部分。然后，对数据的<code class="du kg kh ki kj b"> k − 1</code>部分拟合一个模型，然后使用该模型根据<code class="du kg kh ki kj b">kth</code>部分进行预测。</p><p id="00ed" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">重复<code class="du kg kh ki kj b">k</code>次，直到每个部分都被测试一次并包含在模型拟合<code class="du kg kh ki kj b"> k − 1</code>次中。交叉验证提供了对模型预测准确性的一种度量，这在很大程度上被认为是评估模型质量的一种好方法。</p><p id="3e56" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">有许多帮助执行<code class="du kg kh ki kj b">cross-validation</code>的包和函数。每一个都有它自己的局限性或怪癖，所以我们没有仔细研究许多不完整的函数，而是展示了一个适用于<code class="du kg kh ki kj b">generalized linear models</code>(包括线性回归)的函数，然后构建了一个通用的框架，可以通用于任意的模型类型。</p><p id="b268" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">Brian Ripley的引导包有用于执行<code class="du kg kh ki kj b">cross-validation </code>的<code class="du kg kh ki kj b">cv.glm</code>。顾名思义，它只适用于一般的线性模型，这将满足许多情况。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="1412" class="kk kl hi kj b fi lo lp l lq lr">library(boot)<br/>#refit house1 using glm instead of lm<br/>houseG1 &lt;- glm(ValuePerSqFt ~ Units + SqFt + Boro,data=housing, family=gaussian(link="identity"))</span><span id="485f" class="kk kl hi kj b fi mf lp l lq lr"># ensure it gives the same results as lm<br/>identical(coef(house1), coef(houseG1))</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lu"><img src="../Images/a74ed2293d05796ee6c43135fc7fd10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HhrXpkyrxqQyT9LBz8_mw.png"/></div></div></figure><p id="344e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">来自<code class="du kg kh ki kj b">cv.glm</code>的结果包括delta，它有两个数字，基于所有折叠的成本函数的原始<code class="du kg kh ki kj b">cross-validation error</code>(在这种情况下是均方差，这是对估计器正确性的度量)和<code class="du kg kh ki kj b">adjusted cross-validation error</code>。第二个数字补偿了没有使用留一交叉验证，这类似于<code class="du kg kh ki kj b">k-fold cross-validation</code>，除了每个折叠都是除了一个点之外的所有数据点。这非常准确，但是计算量很大。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="3e7d" class="kk kl hi kj b fi lo lp l lq lr">houseCV1 &lt;- cv.glm(housing, houseG1, K=5)<br/>houseCV1$delta</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mg"><img src="../Images/5ee244db83794027a48bc887f95d0602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJo2GJDOXqvm6DzRwcBsiA.png"/></div></div></figure><p id="f36a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">虽然我们得到了一个不错的错误数字，但只有当我们可以将其与其他模型进行比较时，它才会对我们有所帮助，因此我们对我们构建的其他模型运行相同的过程，首先用<code class="du kg kh ki kj b">glm</code>重新构建它们。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="366f" class="kk kl hi kj b fi lo lp l lq lr"># Building multiple models<br/>houseG2 &lt;- glm(ValuePerSqFt ~ Units * SqFt + Boro, data=housing)<br/>houseG3 &lt;- glm(ValuePerSqFt ~ Units + SqFt * Boro + Class,data=housing)<br/>houseG4 &lt;- glm(ValuePerSqFt ~ Units + SqFt * Boro + SqFt*Class,data=housing)<br/>houseG5 &lt;- glm(ValuePerSqFt ~ Boro + Class, data=housing)</span><span id="11ca" class="kk kl hi kj b fi mf lp l lq lr"># run cross-validation<br/>houseCV2 &lt;- cv.glm(housing, houseG2, K=5)<br/>houseCV3 &lt;- cv.glm(housing, houseG3, K=5)<br/>houseCV4 &lt;- cv.glm(housing, houseG4, K=5)<br/>houseCV5 &lt;- cv.glm(housing, houseG5, K=5)</span><span id="0aad" class="kk kl hi kj b fi mf lp l lq lr">## Creating a dataframe of model Error values and adding model name<br/>cvResults &lt;- as.data.frame(rbind(houseCV1$delta, houseCV2$delta, houseCV3$delta, houseCV4$delta,houseCV5$delta))<br/>names(cvResults) &lt;- c("Error", "Adjusted.Error")<br/>cvResults$Model &lt;- sprintf("houseG%s", 1:5)</span><span id="3618" class="kk kl hi kj b fi mf lp l lq lr">cvResults</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mh"><img src="../Images/3e11cd11becf575664e7b4603e4f7c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_DieTMjshKSlOD8Npv6pQ.png"/></div></div></figure><p id="1e34" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">再次，第四个型号，<code class="du kg kh ki kj b">houseG4</code>，是上级型号。让我们想象一下<code class="du kg kh ki kj b">ANOVA</code>、<code class="du kg kh ki kj b">AIC </code>和<code class="du kg kh ki kj b">cross-validation</code>对不同模型的相对优点有多认同。比例各不相同，但图的形状是一样的。</p><pre class="jj jk jl jm fd lk kj ll lm aw ln bi"><span id="beff" class="kk kl hi kj b fi lo lp l lq lr"># measure with ANOVA<br/>cvANOVA &lt;-anova(houseG1, houseG2, houseG3, houseG4, houseG5)<br/>cvResults$ANOVA &lt;- cvANOVA$`Resid. Dev`</span><span id="9dbb" class="kk kl hi kj b fi mf lp l lq lr"># measure with AIC<br/>cvResults$AIC &lt;- AIC(houseG1, houseG2, houseG3, houseG4, houseG5)$AIC</span><span id="1164" class="kk kl hi kj b fi mf lp l lq lr"># make the data.frame suitable for plotting<br/>library(reshape2)<br/>cvMelt &lt;- melt(cvResults, id.vars="Model", variable.name="Measure",value.name="Value")</span><span id="c83d" class="kk kl hi kj b fi mf lp l lq lr"># Plotting Results<br/>ggplot(cvMelt, aes(x=Model, y=Value)) +<br/>  geom_line(aes(group=Measure, color=Measure)) +<br/>  facet_wrap(~Measure, scales="free_y") +<br/>  theme(axis.text.x=element_text(angle=90, vjust=.5)) +<br/>  guides(color=FALSE)</span></pre><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lv"><img src="../Images/21250b9d58db7e9091ad13bb473ad01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rl33kXZT1bG4pb4_FXLPhg.png"/></div></div></figure><p id="20d7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated"><code class="du kg kh ki kj b">cross-validation error</code>(原始和调整后)、<code class="du kg kh ki kj b">ANOVA </code>和<code class="du kg kh ki kj b">AIC </code>用于房屋模型的绘图。比例不同，这是应该的，但形状相同，这表明<code class="du kg kh ki kj b">houseG4 </code>确实是最好的模型。</p><p id="1981" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">确定模型的质量是模型构建过程中的一个重要步骤。这可以采取传统的适合度测试的形式，如<code class="du kg kh ki kj b">ANOVA </code>或更现代的技术，如<code class="du kg kh ki kj b">cross-validation</code>。<code class="du kg kh ki kj b">bootstrap </code>是确定模型不确定性的另一种方法，特别是对于置信区间无法计算的模型。在本文中，我们没有讨论bootstrap技术。我们将在看到<code class="du kg kh ki kj b">Random Forest</code>和<code class="du kg kh ki kj b">Gradient Boosting</code>算法时讨论它。这些都可以通过帮助选择模型中包括哪些变量和排除哪些变量来形成。</p><blockquote class="if ig ih"><p id="5f12" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">使用R-10的逻辑回归将很快发表</p><p id="ef45" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">一定要通过评论和分享文章来分享你的想法和支持。</p></blockquote></div></div>    
</body>
</html>