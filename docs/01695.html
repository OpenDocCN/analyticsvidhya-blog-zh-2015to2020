<html>
<head>
<title>Demystifying Data Structures: Linked Lists Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开数据结构的神秘面纱:链表第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/demystifying-linked-lists-part-1-eb12c3e282d3?source=collection_archive---------8-----------------------#2019-11-09">https://medium.com/analytics-vidhya/demystifying-linked-lists-part-1-eb12c3e282d3?source=collection_archive---------8-----------------------#2019-11-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/01d3e4d246cc0eb77698af7322a1938f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDkic3l6DfJm0vY6RfBZqw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来源:丹尼斯·奇克在<a class="ae hv" href="https://unsplash.com/s/photos/train?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="e3d2" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">Python中执行的单链表的基本操作。</h2></div><p id="bba6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">链表是数据元素的线性集合。与将元素存储在连续物理位置的数组等数据结构不同，链表是面向序列的。把链表想象成一列火车，一节车厢跟在另一节车厢后面，它们都由引擎引领。链表中的引擎称为头节点。</p><p id="ac51" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">链表中的元素称为节点。一个节点通常由两部分组成:</p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es kj"><img src="../Images/6e4dc01f42fc3afa16748fe39ba3fb1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*vlfestj_XHRdxJn-HdvyUA.jpeg"/></div></figure><ul class=""><li id="a48e" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki kt ku kv kw bi translated">数据或该节点的内容。</li><li id="50cb" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">链接，或者指向下一个节点的指针。</li></ul><p id="7ebb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面是一个链接列表的例子:</p><p id="f6a7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们从创建一个类节点开始。这个类将允许创建节点，这将形成链表。我们用一个数据项和一个设置为None的指针初始化每个新节点。</p><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="29aa" class="lh li hy ld b fi lj lk l ll lm">class Node:<br/>    def __init__(self, data): <br/>        self.data = data  <br/>        self.next = None</span></pre><p id="5625" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果您创建一个新节点，它看起来会是这样:</p><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="03d3" class="lh li hy ld b fi lj lk l ll lm">new_node = Node(10)</span></pre><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es ln"><img src="../Images/29ced0f3f4a3edbd7c07f434eba5e954.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*5xMq-O4U3wIazNrKN6fo2Q.jpeg"/></div></figure><p id="2048" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们有了节点创建者类，让我们开始构建链表吧！</p><p id="412a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们首先定义一个类，如下所示:</p><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="0dcf" class="lh li hy ld b fi lj lk l ll lm">class LinkedList: <br/>    <br/>    def __init__(self):  <br/>        self.head = None</span></pre><p id="e5e8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有许多操作可以在链表上执行，就像在任何其他数据结构上一样。我们可以根据它们的基本功能将它们分为:</p><ul class=""><li id="0e47" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki kt ku kv kw bi translated">插入</li><li id="5c08" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">删除</li><li id="7fb4" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">横越</li></ul><h1 id="0d37" class="lo li hy bd lp lq lr ls lt lu lv lw lx je ly jf lz jh ma ji mb jk mc jl md me bi translated">插入</h1><p id="a781" class="pw-post-body-paragraph jn jo hy jp b jq mf iz js jt mg jc jv jw mh jy jz ka mi kc kd ke mj kg kh ki hb bi translated">可以通过以下方式将元素插入链表:</p><ol class=""><li id="bc23" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki mk ku kv kw bi translated"><strong class="jp hz">从列表的开头插入</strong></li></ol><p id="8b51" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就像在堆栈中一样，我们称这个操作为<em class="ml">推送。把这想象成在列车的起点增加一节新车厢。我们必须把引擎从第一辆教练车上拆下来，然后把它安装到我们的新教练上，或者在我们的列表中，新教练就是新的引擎。</em></p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/3c0160b8d7e034f51301966303ace8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*eF8SrQtoT7TBCe6D0KXQGQ.jpeg"/></div></figure><p id="a46d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">1.获取一个新节点。<br/> 2。将此节点指针设置为指向当前头。<br/> 3。使该节点成为新的头部。</p><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="6014" class="lh li hy ld b fi lj lk l ll lm">def push(self, item):<br/>        node = Node(item)<br/>        <br/>        node.next = self.head<br/>        self.head = node</span></pre><p id="8da3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> 2。从列表末尾插入</strong></p><p id="f587" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们称这个操作为<em class="ml">追加。</em>这是因为我们从链表的末尾添加元素。这是通过设置最后一个节点的指针指向我们的新节点来实现的。</p><p id="1610" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们的列表没有元素，那么头部将是None。这意味着新节点现在是我们的引擎。</p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/231e07252c9edf27d525a8267d82589d.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*e0DDYH9r2oxk0g8qK_LyHA.jpeg"/></div></figure><ol class=""><li id="6cfe" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki mk ku kv kw bi translated">获取新节点。</li><li id="e004" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">如果列表为空，将该节点作为头节点。</li><li id="1e39" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">如果列表中有元素，遍历它们直到找到最后一个节点。</li><li id="773d" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">将最后一个节点的指针设置为指向新节点。</li></ol><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="d587" class="lh li hy ld b fi lj lk l ll lm">def append(self, item):<br/>        node = Node(item)<br/>        <br/>        if self.head is None: <br/>            self.head = node <br/>            return<br/>    <br/>        last = self.head<br/>        while last.next:<br/>            last = last.next<br/>            <br/>        last.next = node</span></pre><p id="6fa4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">还有其他插入节点的方法，如在元素后插入或在中间插入。我们将在以后的博客文章中讨论这个问题。现在，让我们继续删除。</p><h1 id="595f" class="lo li hy bd lp lq lr ls lt lu lv lw lx je ly jf lz jh ma ji mb jk mc jl md me bi translated"><strong class="ak">删除</strong></h1><p id="35d9" class="pw-post-body-paragraph jn jo hy jp b jq mf iz js jt mg jc jv jw mh jy jz ka mi kc kd ke mj kg kh ki hb bi translated">正如在插入节点中所讨论的，删除也可以从列表的开头或结尾进行。</p><ol class=""><li id="26f9" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki mk ku kv kw bi translated"><strong class="jp hz">从列表的开头删除</strong></li></ol><p id="0ffc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个操作被称为<em class="ml">弹出</em>，因为它类似于堆栈的弹出操作。</p><p id="6f0b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从一开始就删除一个元素可以想象为从火车上移除一个引擎，并使紧随其后的车厢成为新的引擎。我知道你在想什么。你不能把任何教练变成一个引擎。但这就是链表的美妙之处，如果你知道怎么做，你可以把任何节点变成头节点。</p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/d8206cbe2103eb0c4953fe49e77cd1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*-wJBdR5FX78kh3a08A4JEg.jpeg"/></div></figure><ol class=""><li id="9b1e" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki mk ku kv kw bi translated">如果列表为空，则没有要删除的内容。</li><li id="a2cb" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">如果只有一个元素，删除它。换句话说，将head设置为None。</li><li id="8427" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">如果存在列表:</li></ol><ul class=""><li id="7ff1" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki kt ku kv kw bi translated">设置一个临时节点，temp指向头后的节点。</li><li id="8b94" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">将新的头部设置为节点温度。</li></ul><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="de86" class="lh li hy ld b fi lj lk l ll lm">def pop(self):<br/>        #If the list is empty, do nothing<br/>        if self.head is None:<br/>            return<br/>        <br/>        #If there is only one element in the list, delete it<br/>        if temp.next == None:<br/>            self.head = None<br/>            return</span><span id="9602" class="lh li hy ld b fi mo lk l ll lm">        #If there are elements, start with the head  <br/>        temp = self.head.next<br/>        self.head = temp</span><span id="08fc" class="lh li hy ld b fi mo lk l ll lm">        return</span></pre><p id="8fcf" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> 2。从列表末尾删除</strong></p><p id="c1c1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从链表的末尾删除就像从最后一节车厢开始删除一列火车的车厢。为此，我们找到最后两个元素，并将last之前的元素的指针设置为None。</p><figure class="kk kl km kn fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/4a3fdeecc1f4497543a763ec7555e1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*CcRzChgxt6k-rozDdogp6Q.jpeg"/></div></figure><ol class=""><li id="e5ae" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki mk ku kv kw bi translated">如果列表为空，则什么也不做。</li><li id="7aa9" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">如果列表只有一个元素，则删除标题。</li><li id="d45d" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki mk ku kv kw bi translated">如果列表有多个元素:</li></ol><ul class=""><li id="57b9" class="ko kp hy jp b jq jr jt ju jw kq ka kr ke ks ki kt ku kv kw bi translated">将变量cur (current)设置为当前头节点，将prev (previous)设置为None。</li><li id="a727" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">现在，将prev设置为cur元素，并使cur指向下一个元素。</li><li id="ccea" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">通过这样做，我们基本上是一次找到两个元素，直到到达列表的末尾。</li><li id="cd2c" class="ko kp hy jp b jq kx jt ky jw kz ka la ke lb ki kt ku kv kw bi translated">当cur后面没有元素时，我们停止这样做。这意味着我们已经到达了最后一个元素。</li></ul><p id="dced" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">4.将prev的指针设置为None。这将断开列表中最后一个元素的连接。现在，prev是列表的最后一个元素。</p><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="cfb5" class="lh li hy ld b fi lj lk l ll lm">def delete(self):<br/>        cur = self.head<br/>        <br/>        #If the list is empty<br/>        if self.head is None:<br/>            return<br/>        <br/>        #If there is only one element in the list<br/>        if cur.next == None:<br/>            self.head = None<br/>            return<br/>        <br/>        while cur.next != None:<br/>            prev = cur<br/>            cur = cur.next<br/>            <br/>        prev.next = None<br/>        return</span></pre><h1 id="1501" class="lo li hy bd lp lq lr ls lt lu lv lw lx je ly jf lz jh ma ji mb jk mc jl md me bi translated">遍历列表</h1><p id="42e3" class="pw-post-body-paragraph jn jo hy jp b jq mf iz js jt mg jc jv jw mh jy jz ka mi kc kd ke mj kg kh ki hb bi translated">遍历是从头到尾遍历列表的每个元素。这就像通过按顺序进入每个教练，从发动机走到最后一个教练。当我们遍历一个链表时，我们打印它的元素。</p><p id="a927" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了遍历列表，我们在列表的开头设置一个变量temp并开始打印。我们增加temp来指向下一个元素，直到它到达列表的末尾。</p><pre class="kk kl km kn fd lc ld le lf aw lg bi"><span id="fd13" class="lh li hy ld b fi lj lk l ll lm">def printList(self):<br/>        if self.head is None:<br/>            print('EMPTY LIST')<br/>        <br/>        temp = self.head <br/>        while temp: <br/>            print(temp.data, '\t') <br/>            temp = temp.next</span></pre><p id="d518" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就是这样！我们已经讨论了链表最基本的操作。这里是Python的完整代码。</p><figure class="kk kl km kn fd hk"><div class="bz dy l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>