<html>
<head>
<title>Python from expressions — The ANTLR series (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自表达式的 python—ANTLR 系列(第 2 部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-2-5436ef00bcf?source=collection_archive---------10-----------------------#2020-09-23">https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-2-5436ef00bcf?source=collection_archive---------10-----------------------#2020-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="79e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前一部分中，我创建了两个 ANTLR 语法文件，用于将基本布尔表达式转换为 python 表达式并生成一个 python 文件。对于上下文，如果您还不知道的话，可以看一下前面的部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/ed3134218d852a0d43a9b9a07a6a9b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/1*XyQdS0-D5Eci8agLu0VwTQ.gif"/></div></figure><div class="jl jm ez fb jn jo"><a rel="noopener follow" target="_blank" href="/@hrajpal96/python-from-expressions-the-antlr-series-part-1-3d7696c3a01c"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">来自表达式的 python-ANTLR 系列(第 1 部分)</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">所以，在最后一个故事中，我在 ANTLR(或它的树，双关语)上走了一小段路，概述了它…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc jj jo"/></div></div></a></div><p id="0266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了继续，现在让我们生成解析器文件。这一次，我将使用 maven 配置和用于 VS 代码的 ANTLR 插件来生成这些文件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="f6f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个标签定义了 ANTLR 在生成解析器类时应该使用的目录，或者需要或不需要生成的文件。例如，listener 和 visitor 标签都是这样定义的，它们对应的 java 类/接口是基于它们的布尔值生成的。</p><p id="9c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目标语言解析器文件集如下:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kf"><img src="../Images/a5bb4fc268c2a54113dc88efcb8fd751.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*D8STXvTxPmRJvplSc7LokQ.png"/></div></figure></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="4cb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更深入地研究一下<strong class="ih hj">监听器 vs 访问者遍历模式</strong>，并探索一下<strong class="ih hj">BooleanExprParserBaseListener</strong>(这是一个很长的名字，我知道)<strong class="ih hj"> </strong>类是做什么的。</p><h1 id="7b6d" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">警告！！！</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ll"><img src="../Images/2dfa3471552efe818139219c26b153fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*tzy3nr32bJG0Bep-pvqyng.png"/></div></figure><h2 id="7ce1" class="lm ko hi bd kp ln lo lp kt lq lr ls kx iq lt lu lb iu lv lw lf iy lx ly lj lz bi translated">遍历模式？它们是什么？差异？如何？用哪个？</h2><p id="c764" class="pw-post-body-paragraph if ig hi ih b ii ma ik il im mb io ip iq mc is it iu md iw ix iy me ja jb jc hb bi translated">ANTLR4 提供了两种遍历语法树的方法:</p><ul class=""><li id="36b5" class="mf mg hi ih b ii ij im in iq mh iu mi iy mj jc mk ml mm mn bi translated">Listener(默认):listener 模式是一种事件驱动的方法，用于遍历每种解析器规则类型的语法树。为每个分析器规则提供一个包含进入和退出事件方法的接口。</li><li id="6f7d" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">访问者:这使得解析树的遍历也可以由用户控制。使用提供的访问方法显式地遍历或访问解析树中的节点(针对解析器规则)。</li></ul><p id="521e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">侦听器和访问者模式都有各自的优点和缺点，这取决于使用它们的环境。</p><h2 id="5de6" class="lm ko hi bd kp ln lo lp kt lq lr ls kx iq lt lu lb iu lv lw lf iy lx ly lj lz bi translated">什么保持不变？</h2><ul class=""><li id="d911" class="mf mg hi ih b ii ma im mb iq mt iu mu iy mv jc mk ml mm mn bi translated">对于两种实现，规则的语法规则保持完全相同。</li><li id="3f6d" class="mf mg hi ih b ii mo im mp iq mq iu mr iy ms jc mk ml mm mn bi translated">两种实现的解析器输出也是相同的。</li></ul><h2 id="e6d4" class="lm ko hi bd kp ln lo lp kt lq lr ls kx iq lt lu lb iu lv lw lf iy lx ly lj lz bi translated">有什么不同？</h2><ul class=""><li id="f653" class="mf mg hi ih b ii ma im mb iq mt iu mu iy mv jc mk ml mm mn bi translated">因为访问者模式依赖于用户来定义它的遍历序列，所以它使用调用堆栈来管理这些遍历。这意味着大量的输入可能会导致溢出，而在分配的堆上使用堆栈的侦听器却不会遇到这样的问题。</li></ul><blockquote class="mw mx my"><p id="babc" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">侦听器和访问者机制之间的最大区别是<strong class="ih hj">侦听器方法由 ANTLR 提供的 walker 对象</strong>独立调用，而<strong class="ih hj">访问者方法必须通过显式访问调用</strong>来遍历其子方法。忘记在节点的子节点上调用 visitor 方法，意味着这些子树不会被访问。</p><p id="8ecb" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated"><a class="ae nd" href="http://media.pragprog.com/titles/tpantlr2/listener.pdf" rel="noopener ugc nofollow" target="_blank">参考<strong class="ih hj">参考</strong>参考</a></p></blockquote><h2 id="a74f" class="lm ko hi bd kp ln lo lp kt lq lr ls kx iq lt lu lb iu lv lw lf iy lx ly lj lz bi translated"><strong class="ak">跳回我们生成的监听器</strong></h2><div class="je jf jg jh fd ab cb"><figure class="ne ji nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><img src="../Images/1db2935bc6da9110ec0ffe676185afb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*jmpv6lKuineCDhOUo4PmJw.png"/></div></figure><figure class="ne ji no ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><img src="../Images/36f9324ed3a622d100e81254b26622fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*dmhqKlJfwXTFNB9f0KvG8w.png"/></div><figcaption class="np nq et er es nr ns bd b be z dx nt di nu nv translated">监听器实现和监听器接口</figcaption></figure></div><p id="6f5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口类的实现只特定于某些语言，通常，实现类/模块是在目标语言中定义的。请注意在接口和实现中定义的根(或解析)节点侦听器方法。所有的方法都有相应的上下文对象，由生成的解析器类提供。这允许在遍历解析树时操作该规则的上下文。</p><p id="6f0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建与解析器的第一个交互，并生成一个简单表达式的输出:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="7460" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们已经在语法文件中添加了将基本操作符翻译成 python 对应操作符的动作，所以解析器的输出表达式已经是解析形式了。例如，一个简单的比较表达式，比如<code class="du nw nx ny nz b">a eq b</code>，将被转换成 pythonic 表达式<code class="du nw nx ny nz b">a == b</code>。</p><p id="44bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经转换了表达式，我们可以使用侦听器文件中的某些更改将它转换为函数，并使用模板将该表达式替换为占位符函数文本，用于多个这样的表达式，如:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="c04f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析后的表达式可以很容易地替换成上面的表达式。不要担心替换部分，我们稍后会讲到。现在，为了从每个表达式中提取参数列表，我们将添加一个列表，以便在每次触发标识符类型的(解析器规则)条目事件侦听器方法时捕获每个标识符名称。</p><p id="31d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将一个字符串列表定义为一个实例变量，在一个无参数的构造函数中初始化它，定义它的 getter 方法，并添加一个方法来清除这个列表，这样它就可以在每次表达式解析和替换完成时被清除。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="50bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将上下文的<strong class="ih hj"> getText </strong>方法中的标识符名称追加到我们每次为 identifierExpression 触发 enter 事件时创建的列表中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><h1 id="5bce" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">最后，</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es oa"><img src="../Images/040652edd458262ca85ec134a7185cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*7KhncsizJe5vRQI9WqWrlA.gif"/></div></figure><p id="4008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi ob translated"><span class="l oc od oe bm of og oh oi oj di">我们</span>需要遍历树来触发这些事件，以收集表达式的所有参数。ANTLR 正好为此提供了一个类，ParseTreeWalker。顾名思义，这允许在遍历解析树时同时使用侦听器和访问者实现类。让我们使用监听器遍历上面定义的解析树:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="f59f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意这里的<strong class="ih hj"> walk </strong> <strong class="ih hj">方法</strong>使用监听器监听事件触发器，同时遍历传递的解析树。接下来，我们使用 getter 方法获取解析表达式时获取的所有标识符名称的列表。</p><p id="0f2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一部分中，我将使用这个解析的表达式创建一个 python 函数，它使用一个模板文件(我们可以在其中替换这些表达式和我们的参数列表)，看起来像这样:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kd ke l"/></div></figure><div class="jl jm ez fb jn jo"><a rel="noopener follow" target="_blank" href="/@hrajpal96/python-from-expressions-the-antlr-series-part-3-7ac541a1d08c"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">来自表达式的 python—ANTLR 系列(第 3 部分)</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">到目前为止，这个过程的要点是什么</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="ok l jz ka kb jx kc jj jo"/></div></div></a></div></div></div>    
</body>
</html>