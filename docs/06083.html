<html>
<head>
<title>ROCK PAPER SCISSOR(CNN)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">石头剪刀布(CNN)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/rock-paper-scissor-cnn-670f5ffec767?source=collection_archive---------9-----------------------#2020-05-11">https://medium.com/analytics-vidhya/rock-paper-scissor-cnn-670f5ffec767?source=collection_archive---------9-----------------------#2020-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="538d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">石头剪刀手的图像分类</p><p id="e3a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将设置一个简单的CNN来分类玩石头、布、剪刀游戏的手的图像。该数据集将从tensorflow_datasets模块加载</p><p id="715e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您尚未安装此模块，请使用pip安装tensorflow-datasets。</p><h2 id="f09f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">了解数据集</h2><p id="bc3a" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">数据集包含人们玩石头、剪子游戏的图像，如下图所示。它由2，892幅图像组成，仅具有训练和测试分裂。每个图像都有一个[300，300，3]的形状，有3个输出类(即石头、剪刀、布</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/f96f09c6077bbb151463d4a4e3f7d89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qfBFdBOLH0JeuYNa.png"/></div></div></figure><h2 id="ccf2" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">加载数据集</h2><p id="7f5d" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">为了加载数据集，我们需要做的第一件事是导入必要的库。然后，我们将使用tfds.load()加载(下载，然后第一次加载)我们的数据集，同时将with _info和as_supervised设置为True。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="652f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着检查一些可能不清楚的代码部分</p><ul class=""><li id="2cfa" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">在第8行使用tfds.load()时，设置with_info = True将返回关于我们的数据集的信息，然后将这些信息存储在我们声明的变量中(即info)。</li><li id="6b79" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">as_supervised = True将我们的数据集加载为(图像，标签)元组结构。</li></ul><h2 id="05af" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">预处理数据</h2><p id="2f29" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">请记住，我们刚刚进行了培训和测试分割，我们需要进行验证分割。我们将使用10%的训练数据作为我们的验证分割。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="b6c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在把我们的数据输入CNN之前，它必须经过某种形式的预处理。</p><p id="175a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的数据集中图像的每个像素范围从0到255，我们将借助一个小函数将其缩放到0到1之间</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><ul class=""><li id="496c" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">我们将可用的分割分配给它们各自的变量。</li><li id="a59a" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">创建了一个函数来缩放图像的像素</li><li id="3541" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">tf.cast确保我们的图像是float32类型</li><li id="811e" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">潜水255。以浮点格式将我们的像素缩放到0到1之间</li><li id="9f99" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">对每个数据使用map()方法会将我们的预处理函数应用于每个数据</li></ul><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="b163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码负责从训练数据中获取验证数据</p><ul class=""><li id="300f" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">有效训练数据以1000的缓冲区大小被混洗</li><li id="7305" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">有效数据包含10%的训练数据</li><li id="a626" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">train_data包含剩余的90%</li><li id="655c" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">设置测试数据的批量大小，这与使用测试数据总数作为批量大小是一样的，因为数据集很小</li></ul><h2 id="8ca1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">格式化</h2><p id="ee44" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在我们准备好之前，只剩下一点格式化了。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><ul class=""><li id="84ec" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">每个数据都是批处理的，通过使用prefetch(1 ),我们的数据集将总是领先一批</li><li id="9b21" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">iter()遍历数据来分离图像和标签，记住我们设置为_supervise = True</li><li id="e3d7" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">next()移动到下一批</li><li id="51d3" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">这些图像的尺寸从(300×300)调整到(150×150)</li><li id="3fe1" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">train_images.shape返回TensorShape([32，150，150，3])。第一项是我们的batch_size，而数据集中图像的形状是[150，150，3]，即我们的input_shape</li></ul><h2 id="2118" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">数据扩充</h2><p id="6390" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我们正在处理小数据集，因此数据扩充将对我们有很大帮助</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><ul class=""><li id="9525" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">imagedatagenerator有一些你可以设置的参数，比如宽度移动，水平翻转等等。</li><li id="9bf1" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">datagen以32的批量检查列车图像和列车标签</li><li id="0964" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">注意:不要在你的验证和测试数据中使用数据扩充</li></ul><p id="0e43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将根据设置的参数创建不同变化的随机图像。例如，我们将horizontal_flip设置为True，这意味着一些图像将被水平翻转</p><p id="e179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据扩充是一种很好的方式，可以让你的模型在不同的图像上进行训练，尤其是当你的数据集很小的时候</p><h2 id="3609" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">模型</h2><p id="7f88" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在预处理和格式化之后，我们现在终于准备好构建我们的模型了。在构建我们的CNN之前，我们肯定会从导入一些必要的库开始</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><ul class=""><li id="65c2" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">我们的第一层由32个大小为3(即3 x 3)的过滤器组成，我们的input_shape变量也位于第一层</li><li id="7189" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">下一层由最大池组成，池大小为2</li><li id="436f" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">随着过滤器64、128数量的增加，重复相同的过程</li><li id="8ac0" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">对于具有(填充=相同)的层，每个图像将被填充</li><li id="29dc" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">Kernel_initializer用于训练开始时的随机性加权</li><li id="eb54" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">使用的激活函数是“relu”</li><li id="9a37" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">展平层在传递到致密层之前展平我们图像的形状</li><li id="ccfd" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">我们只有一个密集的隐藏层，隐藏单元为128</li><li id="67f2" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">我们希望我们的模型返回一个三输出，所以我们的输出层包含3个隐藏单元和一个“softmax”激活函数</li></ul><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lf"><img src="../Images/217631db888c18fad617f3f8892df3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*5M9dP44RKYSidAhbDCJPDw.png"/></div></figure><p id="9938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将返回我们的模型的总结，我们可以看到可训练和不可训练的层和总参数</p><p id="e939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要编译我们的模型并使之适合。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><ul class=""><li id="eb25" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">Adam optimizer的学习率为0.001</li><li id="8e4a" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">我们使用“稀疏分类交叉熵”作为损失函数</li><li id="c230" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">还实现了早期停止回调来监控我们的val_loss，并且如果val_loss在10个时期内没有增加，则停止模型</li><li id="e87b" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">model.fit()将开始我们模型的训练</li><li id="a00f" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">epochs被设置为200，但是不要担心，因为我们使用了early_stopping回调，如果它开始溢出，我们的模型就会停止</li></ul><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lg"><img src="../Images/513ef6fa3aae2abac46ecb74d2892b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emp_kxjjJisbGW2OERVu8A.png"/></div></div></figure><p id="bcb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一段时间后，验证准确率将达到94%左右。一点都不差！</p><p id="e43c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过绘制来看看损耗和精度曲线是什么样子的</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lh"><img src="../Images/2e0c9e9f1d50d7eb10228b1ec78dcfb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMtlIBd0u-RUbNjd_NsBlQ.png"/></div></div></figure><p id="3096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果显示了早期停止的效果，因为它阻止了我们过度适应。</p><p id="1437" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练损失曲线和验证损失曲线都在稳步下降，其准确性也在提高</p><p id="c9c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以继续在test_data上测试它</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kp kq l"/></div></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es li"><img src="../Images/0a7434c79123bb2e3476ff95130f73f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRkYZtpfoHX0eJDCvinKPg.png"/></div></div></figure><p id="2b2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果表明，测试准确率约为98%。</p><p id="163e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结论</p><p id="e7e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能够建立一个CNN模型，并在玩石头、布、剪刀游戏的手的图像上训练它，以达到98%的模型准确性。</p></div></div>    
</body>
</html>