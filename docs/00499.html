<html>
<head>
<title>Understanding Bloom filters- Part-II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解布隆过滤器-第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-bloom-filters-part-ii-79b0e23ed174?source=collection_archive---------3-----------------------#2019-07-10">https://medium.com/analytics-vidhya/understanding-bloom-filters-part-ii-79b0e23ed174?source=collection_archive---------3-----------------------#2019-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/58014b5f6ea728bab3dce16d4b97f18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Atw61qgB47mAhpPRu7LDKA.png"/></div></div></figure><div class=""/><p id="b359" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将描述一种具有更快查询速度的新数据结构。<br/>在我们<a class="ae jo" rel="noopener" href="/p/85459df3ae37">之前描述的传统散列方案</a>、<br/>中，对于简单方案，查询时间为<strong class="is hu"> O(log(n)) </strong>，对于使用两种选择的更高级方案，查询时间为<strong class="is hu"> O(log(log(n)) </strong>)。</p><p id="429e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们要实现查询时间<strong class="is hu"> O(1) </strong>。所以恒定的查询时间，这是有保证的。回想一下，其他查询时间都是概率语句。在最坏的情况下，它可以是<strong class="is hu"> O(n) </strong>。</p><p id="b636" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种数据结构将非常简单，并且比以前占用更少的空间。没有链表之类的东西。它只是一个简单的二进制数组。现在有很多好处。它更简单，占用空间更少，查询速度更快。</p><h2 id="2378" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">听起来太好了，关键是什么！</h2><p id="54ca" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><em class="kp">现在，这种简单性和这种更快的速度必然会带来一些代价。</em> <br/>嗯，这个方案并不总是正确的。偶尔会有假阳性，这种情况发生的概率很大，我们会进行分析。</p><p id="70fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">假阳性的确切含义是什么？</em> <br/>我们有一个元素<strong class="is hu"> X </strong>，它不在我们的不可接受密码字典中。所以这是一个可以接受的密码，但是我们的算法偶尔会说，是的，这个<strong class="is hu"> X </strong>在字典里。</p><p id="4e87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此设置中，误报是可以接受的。为什么？因为我们有一个可接受的密码，但是我们说这个密码是不可接受的，它在我们的字典里。所以有人输入密码，我们说，不，这是不允许的。理想情况下，应该是允许的。因此，用户必须输入新密码。但是作为这些误报的交换，我们保证了查询时间。因此，我们很快就回答了这是否是一个可接受的密码的问题。</p><p id="9f31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，假阴性是不可接受的，这将是一个巨大的代价。当我们有一个不可接受的密码时，我们肯定想说它是不可接受的。</p><blockquote class="kq kr ks"><p id="df6c" class="iq ir kp is b it iu iv iw ix iy iz ja kt jc jd je ku jg jh ji kv jk jl jm jn hb bi translated">因此，在这种情况下，有一些小概率的假阳性是合理的，我们将尝试绑定。在其他设置中，误报可能是不可接受的，在这种情况下，布隆过滤器可能是一个坏主意。所以这不是一个通用的方案。您必须查看您的设置，并确定拥有更简单、更快速的方案的代价是否值得拥有误报。<br/>有一些小概率的假阳性是可以接受的吗？</p></blockquote><h2 id="a034" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">要求</h2><p id="3ae5" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们的数据结构将支持哪些基本操作？<br/> <strong class="is hu">第一个操作是插入X. </strong> <br/>因此给定一个可能的密码<strong class="is hu"> X </strong>，我们要将这个密码添加到我们的不可接受密码字典中。</p><p id="d8d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">第二个操作是对X，</strong> <br/>的查询。如果这个建议的密码在我们的不可接受密码字典中，那么我们总是输出<strong class="is hu"> YES </strong>，所以在这种情况下我们总是正确的。<br/>问题是，当这个建议的密码不在我们的字典中，所以它是一个可接受的密码时，我们通常输出<strong class="is hu"> NO </strong>并且我们必须绑定我们通常的意思。<br/>但是偶尔，我们会输出<strong class="is hu"> YES </strong>。因此，当这个建议的密码是可接受的，偶尔我们会有一个误报，说<strong class="is hu">是</strong>它在不可接受密码的字典中，所以这个密码是不允许的。<br/>因此，我们有一些小比率的假阳性，我们必须限制该比率，看看它看起来像什么。</p><h2 id="c924" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">理解了问题，让我们定义数据结构</h2><p id="f319" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">基本的数据结构只是一个大小为<strong class="is hu"> n </strong>的二进制数组<strong class="is hu"> H </strong>。这就是整个数据结构。</p><p id="bd5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先将<strong class="is hu"> H </strong>设置为全零。因此所有的<strong class="is hu"> n </strong>位都被设置为零。和以前一样，我们将使用一个随机散列函数，它将所有可能密码的元素映射到我们的大小为<strong class="is hu"> n </strong>的散列表中。</p><p id="daca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">我们如何将一个可能密码的元素</em> <strong class="is hu"> <em class="kp"> X </em> </strong> <em class="kp">插入到我们的不可接受密码字典中？首先我们计算它的哈希值，然后我们在这个哈希值处设置数组中的位为1。所以我们计算<strong class="is hu"> h(X) </strong>并设置<strong class="is hu">H[H(X)】</strong>=<strong class="is hu">1</strong>。现在它可能已经是<strong class="is hu"> 1 </strong>，在这种情况下，我们什么也不做。<br/>所以这些位只能从0变成1。我们从不把它们从1变回0。<br/> <em class="kp">这是这种数据结构的局限性之一。没有简单的方法来实现删除，因为我们从不把比特从1变到0。</em></em></p><p id="2bdf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们如何进行查询呢？ <br/>我们如何检查一个元素<strong class="is hu"> X </strong>是否在我们的字典<strong class="is hu"> S </strong>中？<br/>我们计算<strong class="is hu"> X </strong>的哈希值，并检查数组。<br/>如果这个哈希值的位是<strong class="is hu"> 1 </strong>，那么我们输出<strong class="is hu"> yes </strong>。我们相信它在字典里。如果它是0，那么我们保证它不在字典里。因为如果它是零，就意味着我们肯定没有插入它。<br/>如果它是<strong class="is hu"> 1 </strong>，那么我们认为，我们可能已经插入了它，但我们不确定。<br/>其他一些元素可能已经被插入到这个哈希值中，我们无法检查是否是<strong class="is hu"> X </strong>被插入到这个哈希值中。因为我们现在没有维护一个链表。</p><h2 id="d7c2" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">为什么会这样？</h2><p id="5fa4" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们有一些元素<strong class="is hu"> X </strong>要查询。它不在我们的不可接受密码字典中，但有一些其他元素<strong class="is hu"> Y </strong>在我们的不可接受密码字典中。而且这两个元素，<strong class="is hu"> X </strong>和<strong class="is hu"> Y </strong>，有相同的hash值，<strong class="is hu"> h(X)等于h(Y) </strong>。因此，当我们将<strong class="is hu"> Y </strong>插入到我们的字典中时，我们将该位置位为<strong class="is hu"> 1 </strong>。那么当我们在<strong class="is hu"> X </strong>上做查询的时候，这个位已经是<strong class="is hu"> 1 </strong>了。所以我们认为或者据我们所知，<strong class="is hu"> X </strong>可能就在我们的字典里。现在我们必须输出<strong class="is hu"> yes </strong>因为它可能在那里。但实际上是<strong class="is hu">不，</strong>因为没插。<strong class="is hu"> Y </strong>插入了相同的哈希值。假阳性就是这样产生的。</p><h2 id="0510" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">听起来是个问题</h2><p id="2c37" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们如何改善它？ <br/>我们可以试着使用我们之前在传统哈希方案中使用的二选一的方法。那我们要做什么？<br/>我们将使用两个哈希函数，而不是一个。<br/>现在在传统的方案中，从一个哈希函数到两个哈希函数有很大的收益，但是从两个到三个或者三个到四个，收益并不大。但在这里，这是一个略有不同的设置，从1到2可能会有很大的增益，但即使是从2到3也可能会有增益。不清楚使用多少哈希函数，我们将尝试优化哈希函数的数量选择。<br/>所以我们将允许使用<strong class="is hu"> k </strong>个哈希函数，而不是两个哈希函数。<br/>因此，我们希望将此方案推广到允许使用<strong class="is hu"> k </strong>个哈希函数，然后我们将返回并计算出哈希函数数量<strong class="is hu"> k </strong>的最佳选择。</p><p id="0fd2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看更健壮的设置，我们允许使用<strong class="is hu"> k </strong>散列函数，以及我们如何修改这个数据结构来容纳<strong class="is hu"> k </strong>散列函数。</p><p id="4487" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在我们有了<strong class="is hu"> k </strong>个哈希函数，而不是只有一个，<strong class="is hu"> h1 </strong>，<strong class="is hu"> h2 </strong>，直到<strong class="is hu"> hk </strong>。我们将把我们的哈希表初始化为全零。<br/>所以所有的位，即<strong class="is hu"> H </strong>的<strong class="is hu"> n </strong>位都被设置为零。</p><p id="9d4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">我们如何添加一个元素</em> <strong class="is hu"> <em class="kp"> X </em> </strong> <em class="kp">？</em> <br/>之前我们计算了这个散列值<strong class="is hu"> h(X) </strong>，并且我们将那个位设置为<strong class="is hu"> 1 </strong>。我们现在要做什么？<br/>现在我们计算<strong class="is hu"> k </strong>哈希值，并将所有这些<strong class="is hu"> k </strong>位设置为<strong class="is hu"> 1 </strong>。<br/>所以我们迭代哈希函数1到<strong class="is hu"> k </strong>，然后我们计算它的哈希值，我们将这个位设置为<strong class="is hu"> 1 </strong>。它可能已经和以前一样是1，但是我们总是像以前一样从0到1改变比特。</p><p id="bcb2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何检查一个元素X是否被插入到我们的字典S中？<br/> 我们计算它的<strong class="is hu"> k </strong>哈希值，并检查这些<strong class="is hu"> k </strong>位是否都被设置为1。如果所有这些<strong class="is hu"> k </strong>位都被设置为1，那么我们最好的猜测是<strong class="is hu"> X </strong>被插入到数据库<strong class="is hu"> S </strong>中。如果其中任何一个仍然是<strong class="is hu"> 0 </strong>，那么我们保证<strong class="is hu"> X </strong>没有被插入到数据库中。</p><p id="1b91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这个算法对于我们的查询的正确性。<br/>假设<strong class="is hu"> X </strong>被插入到我们的数据库S中，我们对<strong class="is hu"> X </strong>进行查询。我们输出什么？嗯，当我们将<strong class="is hu"> X </strong>插入数据库时，我们将所有这些<strong class="is hu"> k </strong>位设置为1。因此，当我们执行查询时，我们保证所有这些位都被设置为1，因此我们将输出<strong class="is hu"> Yes </strong>，因为没有一个位会从1变为0。<br/>比特只从0变到1。这是一个单向的过程。因此，如果<strong class="is hu"> X </strong>被插入到数据库中，当我们对<strong class="is hu"> X </strong>进行查询时，我们总是输出Yes。它在数据库里。</p><p id="522f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，假设<strong class="is hu"> X </strong>没有插入数据库，我们对<strong class="is hu"> X </strong>进行查询。有时，我们可能会说是的，我们相信它在数据库中。在这种情况下，我们得到一个假阳性。我们错误地说，是的，它在数据库里。</p><p id="ad44" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">怎么会这样？</em> <br/>如果所有的<strong class="is hu"> k </strong>位都被其他插入设置为1，就会发生这种情况。<br/>有一些元素<strong class="is hu"> Z </strong>被插入到数据库<strong class="is hu"> S </strong>中，并且<strong class="is hu"> Z </strong>的<strong class="is hu"> k </strong>位中的一个与x的<strong class="is hu">位</strong>位完全匹配。</p><p id="6247" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp"/><strong class="is hu"><em class="kp">k</em></strong><em class="kp">中的哪一位为Z？</em> <br/>先说<strong class="is hu">Z</strong>的第j位。因此，<strong class="is hu"> Z </strong>的<strong class="is hu">第j</strong>位与X<br/>的<strong class="is hu">第</strong>位相匹配，换句话说，<strong class="is hu"> X </strong>的<strong class="is hu">H[I]</strong>=<strong class="is hu">H[j]</strong>的<strong class="is hu"> Z </strong>。<br/>这意味着当<strong class="is hu"> Z </strong>被插入数据库时，我们将与<strong class="is hu"> X </strong>的<strong class="is hu">和</strong>位相匹配的这个位设置为1。<br/>并且如果这对于<strong class="is hu"> X </strong>的每一位都是真的，那么<strong class="is hu"> X </strong>的所有<strong class="is hu"> k </strong>位通过一些其他插入被设置为1。那么我们将在<strong class="is hu"> X </strong>上得到一个误报。<br/>所以这个方案有这个额外的鲁棒性或者冗余。<br/>为了得到误报，我们需要通过一些其他插入将所有这k个位设置为1，而之前的方案只有一个我们正在检查的位。<br/>现在我们有了<strong class="is hu"> k个</strong>位，它们需要被设置为1，以便得到误报。随着k的增加，情况似乎有所改善。但事实上有一个最优选择。</p><p id="6eec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">如果</em> <strong class="is hu"> <em class="kp"> k </em> </strong> <em class="kp">变得太大，假阳性率又开始飙升。这是为什么呢？</em> <br/>好吧，如果<strong class="is hu"> k </strong>是巨大的，那么每插入一次，你就把<strong class="is hu"> k </strong>位设置为1。如果k很大，你就把许多位设置为一。这意味着对于每一个插入，在<strong class="is hu"> S </strong>中的每一个元素，它们有许多位，许多选择<strong class="is hu"> j </strong>被设置为1。<br/>因此，如果<strong class="is hu"> k </strong>很大，那么这些<strong class="is hu"> k </strong>位中的一个将与<strong class="is hu"> X </strong>位中的一个匹配。<br/>因此，如果<strong class="is hu"> k </strong>太大，每次插入都会将太多的位设置为1。如果<strong class="is hu"> k </strong>很小，当我们对<strong class="is hu"> X </strong>进行查询时，我们检查的位太少。所以k有一些最佳选择，不太大也不太小。</p><p id="56fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在要做的是更精确地分析这些误报。假阳性的概率有多大？<br/>我们希望将其视为<strong class="is hu"> k </strong>的函数，然后我们可以计算出<strong class="is hu"> k </strong>的最优选择，以最小化假阳性率。然后我们可以进行比较，看看误报率是多少，看看这是不是一个好的数据结构。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h2 id="cc8a" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">假阳性分析</h2><p id="f0dd" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">像以前一样，让<strong class="is hu"> m </strong>，表示我们维护的数据库或字典的大小。<br/>并且让<strong class="is hu"> n </strong>表示我们的散列表的大小。<br/>现在，大概，<strong class="is hu"> n </strong>，我们的哈希表的大小将至少是我们维护的数据库的大小。<br/>因此，重要的参数将是这些尺寸的比率。<br/>所以，让<strong class="is hu"> c </strong>表示这个比值。与数据库大小相比，哈希表的大小。至少会有一个。<br/>我们的目标是尽可能地获得最小的。<br/>我们哈希表的大小是<strong class="is hu"> c </strong>乘以<strong class="is hu"> m </strong>。</p><p id="d80c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，对于一个元素<strong class="is hu"> X </strong>，它不在我们的数据库中。我们来看看这个<strong class="is hu"> X </strong>的误报概率。</p><p id="2145" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，我们需要将所有的<strong class="is hu"> k </strong>位<strong class="is hu"> h1(X) </strong>、<strong class="is hu"> h2(X) </strong>直到<strong class="is hu"> hk(X) </strong>都设置为1。<br/>如果所有这些位都是1，但<strong class="is hu"> X </strong>从未被插入数据库，那么我们将得到一个误报。<br/>那么，我们来试着分析一下，所有这<strong class="is hu"> k </strong>位都被设为1的这个概率。<br/>让我们先来看一个更简单的特定位的问题，<strong class="is hu"> b </strong>，范围在<strong class="is hu"> 0 </strong>和<strong class="is hu"> n-1 </strong>之间。</p><p id="154c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特定位设置为1的概率是多少？ <br/>看这个特定位被设置为零的互补事件会稍微容易一些。因此，这个特定位为1的概率是</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/ef3c74365ba5e16bbae8abe81579993f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWaJhlnQpAJsqEuzxBRR4A.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">k比特的概率被设置为1</figcaption></figure><p id="206b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了分析它仍然设置为0的概率，我们要做的是检查所有的插入是否错过了这一位。</p><p id="076f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们有<strong class="is hu"> m </strong>个插入。在我们简单的散列方案中，这些插入对应于将球扔进垃圾箱。所以，这相当于把<strong class="is hu"> m </strong>个球扔进垃圾箱。但是请注意，对于每次插入，我们都要查看<strong class="is hu"> k </strong>哈希值。并且我们将这些值中的<strong class="is hu"> k </strong>设置为<strong class="is hu"> 1 </strong>。因此，每次插入对应于<strong class="is hu"> k个</strong>球。因此，我们将把m乘以k的球扔进n个垃圾箱。<br/> <br/>为了让这个位仍然为零，我们需要所有这些<strong class="is hu"> m乘以k </strong>的球都错过这个特定的bin，<strong class="is hu"> b </strong>。<br/>所以这个位为0的概率等于所有的<strong class="is hu"> m乘以k </strong>球错过这个特定面元的概率。对于一个球来说，它错过特定框的概率是多少？</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/5b74af40a39c752c0ab00cf521813e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LkctRUJVaYLek7Qs0m6Ug.png"/></div></div></figure><p id="1036" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这个表达式不是很复杂，但是对于我们来说，有一个稍微简单一点的表达式会方便得多。让我们试着<br/>操纵这个来得到一个稍微方便一点的表达。让我们看看下面指数函数的泰勒级数。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ln"><img src="../Images/7ecb321e7482abbbfc7d24c37d841691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmjUes9RiERrPtNWQ_HMfQ.png"/></div></div></figure><p id="4cbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个无穷级数。现在对于小的<strong class="is hu"> a </strong>来说，这个级数是递减的，<br/>并且随着<strong class="is hu"> a </strong>变为零，那么这个级数就近似为<strong class="is hu"> 1-a </strong>。因此，当<strong class="is hu">和</strong>足够小时，这是一个很好的近似值。在我们的例子中，这相当于<strong class="is hu"> n </strong>足够大。所以让我们用这个近似值来简化我们对假阳性率的分析。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lo"><img src="../Images/87be248a93809d99f5884f1f8de9d21a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OozNlXPz3o-odhTD_KJXWQ.png"/></div></div></figure><p id="6de6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了一个非常简单的表达式，来表示一个特定位为零的概率。</p><p id="19e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么这些特定的位被设置为1的概率是多少？..<br/>并且我们希望<strong class="is hu"> k </strong>特定位全部设置为1。所以它的概率是，<br/>的k次方。</p><p id="4cbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总结一下，</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lp"><img src="../Images/eae846ef27bf650d597400b7dcb6f952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baI6fWEBuSN6W8fex5gs7w.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">假阳性分析</figcaption></figure><p id="d938" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个表达式就是假阳性概率。现在不是很好，因为我们有这个<strong class="is hu"> k </strong>。我们能不能通过去掉<strong class="is hu"> k </strong>来简化这一点？</p><p id="c999" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">我们能不能算出什么是最优的</em> <strong class="is hu"> <em class="kp"> k </em> </strong> <em class="kp">才能把这个误报概率降到最低？</em> <br/>回想一下我们之前的直觉，我们希望<strong class="is hu"> k </strong>不要太小，<br/>如果<strong class="is hu"> k </strong>很小，那么当我们进行查询时，我们检查的位太少。<br/>但是如果<strong class="is hu"> k </strong>很大，那么当我们进行插入时，我们将过多的位设置到<strong class="is hu"> 1 </strong>。因此，有一些中间地带，我们想找出最佳选择的<strong class="is hu"> k </strong>，以尽量减少这种假阳性概率。</p><p id="a8dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kp">那么我们要做什么？我们要对这个函数求导。将其设置为零，并找到最佳选择<strong class="is hu"> k </strong>以最小化该表达式。<br/> <br/> <em class="kp">那个最优发生在哪里？</em> <br/>事情发生在<strong class="is hu"><em class="kp">k</em></strong><em class="kp">=</em><strong class="is hu"><em class="kp">c LN2</em></strong>。那是<strong class="is hu"> c </strong>乘以2的自然对数。<br/>我们把这个选择<strong class="is hu"> <em class="kp"> k </em> </strong>插回这个表达式。</em></p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lq"><img src="../Images/dab118374d75fd07923cbeb3500ecb19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zv1TkOm286cJVACuhNpw1g.png"/></div></div></figure><p id="6b88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="kp"> c </em> </strong>是我们的哈希表相对于我们的数据库的大小的比率。现在我们有了假阳性概率的简单表达式。所以如果你告诉我你愿意做多大的散列表，我就能告诉你误报的概率是多少。</p><h2 id="c1db" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">天真计划的例子</h2><p id="0f6d" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在让我们看一些具体的例子，看看这是如何执行的。让我们假设我们做了简单的方案，其中k = 1。<br/>我们没有做<strong class="is hu"> k </strong>的最优选择。我们只设置了一个哈希函数。<br/>再来看看我们做10倍大或者100倍大的情况。<br/>为了分析这个<strong class="is hu"> k </strong> = 1的情况，我们得回到我们的表达式<strong class="is hu"> <em class="kp"> f(k) </em> </strong>。我们得到以下结果</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lr"><img src="../Images/0b02e02a51037653cae693321707a903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYxiNvaoLBbTCuP3VcAV4g.png"/></div></div></figure><h2 id="96e3" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">最佳方案示例</h2><p id="5342" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在，假设我们做<strong class="is hu"> k </strong>的最优选择。所以，</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/144c92fdfddc9a219e5621072f6e4f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGg9UCNoxByA4hh4QgLvuw.png"/></div></div></figure><p id="ae95" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑一个大100倍的哈希表是非常合理的，因为这只是一个二进制字符串。<br/>现在的误报概率是<strong class="is hu"> 1.3乘以10的负21次方</strong>。<br/>关键是这在<strong class="is hu"> c </strong>中是指数的。所以，取<strong class="is hu"> c = 100 </strong>，很微小。这真的是微乎其微的概率。如果这对你来说还不够小，你可以去c = 200，或者300，你会得到一个非常非常小的假阳性概率。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><p id="0054" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，如果你愿意有一个非常小的误报概率，<br/>那么你有这个非常简单的数据结构，它仅仅对应于一个二进制字符串。它的维护非常简单，而且查询速度非常快。假阳性概率也非常小。</p><p id="a6dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种数据结构的缺点是，有时，<br/>您可能会有一些误报，并且它不容易允许从数据库中删除。尽管有一些允许删除的试探法，这些是被称为计数布隆过滤器的修改。</p></div></div>    
</body>
</html>