<html>
<head>
<title>Enhance a Document Scan using Python and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和OpenCV增强文档扫描</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/enhance-a-document-scan-using-python-and-opencv-9934a0c2da3d?source=collection_archive---------7-----------------------#2020-07-12">https://medium.com/analytics-vidhya/enhance-a-document-scan-using-python-and-opencv-9934a0c2da3d?source=collection_archive---------7-----------------------#2020-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d4d6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入文档扫描应用程序的幕后，通过示例学习图像阈值处理。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/2980fdd6d5700ee66821048ea396b7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*28eMHGGM23Hu-zFBfsdCQg.png"/></div></figure><p id="6201" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">文档扫描和光学字符识别(OCR)是计算机视觉领域中一些最古老的问题。在这篇文章中，我们将关注如何创建一个低质量的书籍页面图像的易读版本。这个例子将概述本文中涉及的图像阈值方法之间的差异。</p><h1 id="c452" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">简单阈值处理</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kt"><img src="../Images/af13fccce9ffb79e144f964af925d7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*W4ApIeSW8khddsYqHgKH0w.gif"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">二进制阈值在行动！</figcaption></figure><p id="2187" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">也称为全局阈值处理，简单阈值处理有一个非常直接的方法:对每个像素应用相同的阈值。如果像素值小于阈值，则设置为0，否则设置为最大值。OpenCV的阈值方法需要四个参数:</p><ol class=""><li id="771f" class="ky kz hi jh b ji jj jl jm jo la js lb jw lc ka ld le lf lg bi translated">图像的灰度版本</li><li id="48af" class="ky kz hi jh b ji lh jl li jo lj js lk jw ll ka ld le lf lg bi translated">阈值</li><li id="7a37" class="ky kz hi jh b ji lh jl li jo lj js lk jw ll ka ld le lf lg bi translated">如果输入像素超过阈值(白色为255)，则指定最大值</li><li id="3be8" class="ky kz hi jh b ji lh jl li jo lj js lk jw ll ka ld le lf lg bi translated">阈值类型(参见Github上的示例代码文档)</li></ol><p id="3f59" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它将返回一个由阈值(在本例中为127)和阈值二进制图像组成的元组:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="2e31" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">虽然二进制阈值处理简单有效，但它有几个缺点。首先，您必须手动选择阈值。对于重复使用二进制阈值的应用，这种方法不是很适合。第二，如果背景的亮度不均匀，则容易出现问题。在我们的例子中，这是由拍照手机的阴影造成的。那么简单的二进制阈值处理将总是产生非最佳的结果:如果阈值太低，字母变细，如果阈值太高，背景的部分将被分割成黑色。</p><h1 id="7f4f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">自适应阈值</h1><p id="3e8d" class="pw-post-body-paragraph jf jg hi jh b ji lo ij jk jl lp im jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">为了解决后一个问题，我们需要估计与每个像素附近的字母相比，背景有多亮，而不考虑图像给定部分的光照条件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kt"><img src="../Images/e4a19a1fe0720c1ed90a0a4e532978bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*MVe0vKkTb6Jqh1GSN6emJw.gif"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">自适应阈值:微调块大小和常数参数产生最佳结果！</figcaption></figure><p id="e94e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这正是cv2.adaptiveThreshold所做的。对于每个像素，它通过使用大小为block_size x block_size的窗口来查看其周围的邻域。如果像素值比其邻域的高斯加权平均值至少大整数值c的余量，则它被设置为最大值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="873b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">大津二值化</h1><p id="4884" class="pw-post-body-paragraph jf jg hi jh b ji lo ij jk jl lp im jn jo lq jq jr js lr ju jv jw ls jy jz ka hb bi translated">Otsu的二值化方法是一种全局阈值化方法，它从灰度图像亮度直方图中自动确定其阈值。它通过最小化加权的类内方差、分割前景和背景来做到这一点。</p><div class="iy iz ja jb fd ab cb"><figure class="lt jc lu lv lw lx ly paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><img src="../Images/30a2e94b0d1016db0c335a34f65d967f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/1*2ucOPlzicQN89cYyqRkLjA.gif"/></div></figure><figure class="lt jc md lv lw lx ly paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><img src="../Images/584b3fb05eda8337d1937aca4278edeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*ltgafbNynL-Yc59FU8Le7g.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx me di mf mg translated">Otsu的方法计算出阈值为118时，加权类内方差最小。</figcaption></figure></div><p id="cc6b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当照明条件在整个画面中是均匀的时，Otsu的方法会发光，因此不需要自适应阈值。注意，这里使用的图片不包含阴影。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="70c2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您想绘制直方图来亲自检查，请使用以下代码片段:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="fd2e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl io km ip kn ir ko is kp iu kq iv kr ks bi translated">下一步是什么？</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh ln l"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">如果你想概括这篇文章，看看YouTube视频</figcaption></figure><p id="1b9d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">也可以在GitHub 上查看<a class="ae mi" href="https://github.com/joschuck/OpenCV-with-Python-Series" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="9315" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">关于更详细的方法描述，请看一下<a class="ae mi" href="https://docs.opencv.org/4.3.0/d7/d4d/tutorial_py_thresholding.html" rel="noopener ugc nofollow" target="_blank">官方OpenCV文档</a>。</p></div></div>    
</body>
</html>