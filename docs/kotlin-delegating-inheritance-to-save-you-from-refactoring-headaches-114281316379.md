# Kotlin，委托继承让你摆脱重构的困扰

> 原文：<https://medium.com/analytics-vidhya/kotlin-delegating-inheritance-to-save-you-from-refactoring-headaches-114281316379?source=collection_archive---------17----------------------->

![](img/d9ecba9a8404f0bd4080c7289aa4b0ba.png)

你好。我希望你身体健康。我猜你听说过科特林代表。这篇文章不是向你展示什么是委托，如何创建委托，也不是一些基本的用法。这个帖子正在解决具体问题，代表们正在提供帮助。

这篇文章与库/框架无关。下面的所有实现并不是要展示库/框架是如何工作的，也不是要展示你应该如何查询数据库(例如)。它只是简单地展示问题和解决方案。

短篇故事。想象一下，你已经加入了这个项目，有些文件不是很好。其中一个文件违反了单一责任原则。这个文件叫做 StorageDao，有一些函数可以存储/读取许多不同类型的数据。StorageDao 存储/读取用户数据、用户事件(用户已经参加的事件以及未来的事件)以及您在用户登机时保存的一些数据。随着时间的推移，这个文件越来越大，很难找到合适的方法。(这就是我们在这里的原因)许多其他文件依赖于这个。也就是说，如果您更改这个文件，您将需要更改许多其他文件。更糟糕的是，假设这不是接口实现，而只是一个简单的具有公共函数的类。

我们想要什么？我们希望将用户数据、事件数据和上车数据存储/读取在单独的文件中。对吗？我们不想改变大量文件(目前，也许是永远)。

这是我们的存储道类:

我们想要的文件结构是:

如果我们为所有这些接口创建实现，移动特定实现中的相关方法并删除存储，我们将会破坏大量文件。每个依赖于 StorageDao 的文件(作为构造函数参数接收)都没有编译。解决这个问题的步骤是:

第一步:更改依赖注入框架以提供和接收这些类的类。
第二步:更改接收 StorageDao 作为构造函数参数的文件，以接收所需的实现(一些文件将只需要 UserDao，而其他文件可能需要全部三个)。
第三步:检查所有使用了 StorageDao 的类并更改调用，以便它们调用正确的 Dao (UserDao，EventsDao，OnBoardingDao) - >

```
storageDao.getAllEvents() should be eventsDao.getAllEvents()
```

很多工作，对吧？

我们可以使它变得容易得多，并获得同样的好处。我们要怎么做呢？科特林代表们！

第一步是让 StorageDao 实现所有这些接口。像这样:

第二步是为这些接口创建实现。先说 UserDao。

现在，我们将与用户相关的操作从 StorageDao 委托给 UserDao。怎么会？像这样:

你可以注意到我们有了新的构造函数参数，UserDao，userDao 实现是“UserDao by userDao”，我们已经删除了用户相关的函数，它仍然可以编译。对 StorageDao 进行的每个与用户数据相关的调用都将委托给 userDao。

现在我们对活动和登机也是如此。

现在我们的存储道看起来像这样:

所有依赖和调用 StorageDao 的文件仍会按预期编译和工作。我们需要更改的唯一文件是创建 StorageDao 的文件。假设您正在使用 Koin 进行依赖注入，这很容易使用和展示。它看起来像这样:

就是这样！现在一切都编译好了，代码被分开了，你不需要改变成吨的文件。每个人都快乐(你和编译器):D

[1]通用定义:代码模块(文件/类等。)的责任不止一个。更好的定义:代码模块的改变有多个原因。