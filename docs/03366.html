<html>
<head>
<title>Predicting Sales: Time Series Analysis &amp; Forecasting with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测销售:用Python进行时间序列分析和预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-sales-time-series-analysis-forecasting-with-python-b81d3e8ff03f?source=collection_archive---------0-----------------------#2020-01-28">https://medium.com/analytics-vidhya/predicting-sales-time-series-analysis-forecasting-with-python-b81d3e8ff03f?source=collection_archive---------0-----------------------#2020-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/324fc4005642e691b080830156250c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGhy8mb-KwikYc2dIGf3YQ.png"/></div></div></figure><p id="3841" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何零售商店公司最重要的任务之一是分析其商店的业绩。任何零售商店面临的主要挑战是提前预测每个商店所需的销售额和库存，以避免库存过多和不足。这有助于企业提供最佳的顾客体验，避免亏损，从而确保商店的可持续经营。</p><p id="3c65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将使用Kaggle上的Rossmann store <a class="ae jo" href="https://www.kaggle.com/c/rossmann-store-sales" rel="noopener ugc nofollow" target="_blank">数据</a>。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/2896f23ad8a4b2efd77a818e7d679f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*kNVl-iiV6YshJBXTlMUvWg.png"/></div></figure><p id="51e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Rossmann在7个欧洲国家经营着3000多家药店。挑战在于提前预测他们长达六周的日销售额。商店销售受许多因素影响，包括促销、竞争、学校和国家假期、季节性和地点。</p><p id="714b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章分为两部分:EDA和预测</p><h1 id="2639" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">部分A)探索性数据分析(EDA) </strong></h1><p id="d2ac" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">让我们首先导入所需的库，然后进行数据探索。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="9ce4" class="lc jv hi ky b fi ld le l lf lg"># Importing required libraries<br/>import numpy as np<br/>import pandas as pd, datetime<br/>import seaborn as sns<br/>from statsmodels.tsa.stattools import adfuller<br/>import matplotlib.pyplot as plt<br/>get_ipython().run_line_magic('matplotlib', 'inline')<br/>from time import time<br/>import os<br/>from math import sqrt<br/>from statsmodels.tsa.seasonal import seasonal_decompose<br/>from statsmodels.graphics.tsaplots import plot_acf, plot_pacf<br/>import itertools<br/>import statsmodels.api as sm<br/>from statsmodels.tsa.stattools import acf,pacf<br/>from statsmodels.tsa.arima_model import  ARIMA<br/>from sklearn import model_selection<br/>from sklearn.metrics import mean_squared_error, r2_score<br/>from pandas import DataFrame<br/>import xgboost as xgb<br/>from fbprophet import Prophet<br/>import warnings<br/>warnings.filterwarnings('ignore')</span><span id="dc7d" class="lc jv hi ky b fi lh le l lf lg"># Importing store data<br/>store = pd.read_csv('./data/store.csv')<br/>store.head()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/ef636e6953812b6ae935511bf907b192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSBvpx-kzy_6aYyFByLm7Q.jpeg"/></div></div></figure><p id="13ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上表给出了罗斯曼拥有的1115家商店的信息。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="a2ac" class="lc jv hi ky b fi ld le l lf lg"># Importing train data<br/>train = pd.read_csv('./data/train.csv', index_col='Date', parse_dates = True)<br/>train.head()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/85384a827e53d07a3e554c65df443f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TSJPsDBssOKp9MsHs0XbQ.jpeg"/></div></div></figure><p id="b0e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上表中我们可以看到，日期是其中的一列。这一分析的独特之处在于,“日期”是影响销售的重要因素之一，它是一个独立变量。简而言之，这是一个时间序列数据，即按时间顺序排列的一系列数据点。</p><ol class=""><li id="3901" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated"><strong class="is hj">趋势&amp;季节性</strong></li></ol><p id="acee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看销售额如何随月份、促销、促销2(第二次促销优惠)和年份而变化。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="d6a4" class="lc jv hi ky b fi ld le l lf lg"># Sales trend over the months and year<br/>sns.factorplot(data = train_store_joined, x ="Month", y = "Sales", <br/>               col = 'Promo', # per store type in cols<br/>               hue = 'Promo2',<br/>               row = "Year")</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/4cc809131f51bee58d4c168b533f0d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VE_f7uNgiyMjWSFge_JgCg.png"/></div></div></figure><p id="4294" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图告诉我们，销售往往会在12月达到峰值，这是有道理的，因为圣诞节和假期是旺季。因此，这证实了销售随着“日期”(时间)而变化，并且在我们的数据中存在季节性因素。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="6629" class="lc jv hi ky b fi ld le l lf lg"># Sales trend over days<br/>sns.factorplot(data = train_store_joined, x = "DayOfWeek", y = "Sales", hue = "Promo")</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/9203bea0e905d1a6d1b7b5ea462f057c.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*jK4iQ_Kipelko-ceVmRYtg.png"/></div></figure><p id="c568" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上述趋势中我们可以看出，周末，即周六和周日没有促销活动，这是有道理的，因为商店希望在人们做家务的时候赚取最大利润。</p><p id="bcf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">销售额往往在周日增加，因为人们在周末购物。我们还可以看到，最大的销售发生在有促销活动的周一。</p><p id="545a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。时间序列的平稳性</strong></p><p id="dc35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用时间序列预测模型，我们需要确保我们的时间序列数据是平稳的，即恒定均值、恒定方差和恒定协方差。</p><p id="68b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种方法可以检验时间序列的平稳性:</p><p id="f3f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> a)滚动平均值</strong>:时间序列模型的滚动分析通常用于评估模型在一段时间内的稳定性。窗口以周为单位滚动(滑过数据)，其中以周为单位取平均值。滚动统计是一种可视化测试，我们可以将原始数据与滚动数据进行比较，并检查数据是否稳定。</p><p id="2f04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> b) Dicky -Fuller检验</strong>:该检验为我们提供p值等统计数据，以了解我们是否可以拒绝零假设。零假设是数据不是静态的，另一个假设是数据是静态的。如果p值小于临界值(比如0.5)，我们将拒绝零假设，并说数据是平稳的。</p><p id="365c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们检查' a '型商店的平稳性。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="c9d4" class="lc jv hi ky b fi ld le l lf lg"># Data Preparation: input should be float type<br/>train['Sales'] = train['Sales'] * 1.0</span><span id="5113" class="lc jv hi ky b fi lh le l lf lg"># Assigning one store from each category<br/>sales_a = train[train.Store == 2]['Sales']</span><span id="57eb" class="lc jv hi ky b fi lh le l lf lg"># Trend<br/>sales_a.resample('W').sum().plot(ax = ax1)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/d29533d67da38b3529f7fb4baeecd39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1U2JvtMHnDHVcxBhaALNxg.jpeg"/></div></div></figure><p id="6987" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图告诉我们，销售往往在年底达到高峰。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="4d17" class="lc jv hi ky b fi ld le l lf lg"># Function to test the stationarity<br/>def test_stationarity(timeseries):<br/>    <br/>    # Determing rolling statistics<br/>    roll_mean = timeseries.rolling(window=7).mean()<br/>    roll_std = timeseries.rolling(window=7).std()</span><span id="446e" class="lc jv hi ky b fi lh le l lf lg"># Plotting rolling statistics:<br/>    orig = plt.plot(timeseries.resample('W').mean(), color='blue',label='Original')<br/>    mean = plt.plot(roll_mean.resample('W').mean(), color='red', label='Rolling Mean')<br/>    std = plt.plot(roll_std.resample('W').mean(), color='green', label = 'Rolling Std')<br/>    plt.legend(loc='best')<br/>    plt.show(block=False)<br/>    <br/>  # Performing Dickey-Fuller test:<br/>    print('Results of Dickey-Fuller Test:')<br/>    result = adfuller(timeseries, autolag='AIC')<br/>    print('ADF Statistic: %f' % result[0])<br/>    print('p-value: %f' % result[1])<br/>    print('Critical Values:')<br/>    for key, value in result[4].items():<br/>           print(key, value)</span><span id="d3ec" class="lc jv hi ky b fi lh le l lf lg"># Testing stationarity of store type a<br/>test_stationarity(sales_a)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/8f4f30eae006ebdc64e412a85242ff51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*4EklT8IlBJmaPxNFze1t1g.jpeg"/></div></figure><p id="148e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的图和统计检验中我们可以看出，均值和方差并不随时间变化很大，即它们是常数。因此，我们不需要执行任何转换(当时间序列不稳定时需要)。</p><p id="1252" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们用分解图来看看季节性和趋势。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="566f" class="lc jv hi ky b fi ld le l lf lg"># Plotting seasonality and trend<br/>def plot_timeseries(sales,StoreType):</span><span id="b82e" class="lc jv hi ky b fi lh le l lf lg">fig, axes = plt.subplots(2, 1, sharex=True, sharey=False)<br/>    fig.set_figheight(10)<br/>    fig.set_figwidth(15)</span><span id="6bff" class="lc jv hi ky b fi lh le l lf lg">decomposition= seasonal_decompose(sales, model = 'additive',freq=365)</span><span id="6d9a" class="lc jv hi ky b fi lh le l lf lg">estimated_trend = decomposition.trend<br/>    estimated_seasonal = decomposition.seasonal<br/>    estimated_residual = decomposition.resid<br/>    <br/>    axes[1].plot(estimated_seasonal, 'g', label='Seasonality')<br/>    axes[1].legend(loc='upper left');<br/>    <br/>    axes[0].plot(estimated_trend, label='Trend')<br/>    axes[0].legend(loc='upper left');</span><span id="2510" class="lc jv hi ky b fi lh le l lf lg">plt.title('Decomposition Plots')</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/145a4ffd3b4e6f6d02896cdd92f01289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__BMD7rd77TG3jJdR3vEBQ.png"/></div></div></figure><p id="d05d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的图中，我们可以看到我们的数据中存在季节性和趋势性。因此，我们将使用考虑到这两个因素的预测模型。</p><h1 id="eb89" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">B)部分预测:预测模型</strong></h1><ol class=""><li id="b6cd" class="lk ll hi is b it ks ix kt jb ly jf lz jj ma jn lp lq lr ls bi translated"><strong class="is hj">评估指标</strong></li></ol><p id="8a2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两个流行的指标用于衡量回归(连续变量)模型的性能，即梅伊和RMSE。</p><p id="4d2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">平均绝对误差(MAE) </strong>:预测值与观测值绝对差的平均值。</p><p id="7dbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">均方根误差(RMSE) </strong>:是预测值与观测值的平方差的平均值的平方根。</p><p id="435c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MAE更容易理解和解释，但是RMSE在不希望出现大错误的情况下工作得很好。这是因为误差在被平均之前被平方，因此惩罚了大的误差。在我们的例子中，RMSE非常适合，因为我们希望以最小的误差预测销售(即惩罚高误差)，以便可以正确地管理库存。</p><p id="263e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们将选择RMSE作为衡量模型性能的指标。</p><p id="8490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。预测建模</strong></p><p id="dc69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型1:自回归综合移动平均线(ARIMA) </strong></p><p id="f473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用最常用的时间序列预测方法之一，即ARIMA。</p><p id="ad49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ARIMA模型用ARIMA(p，d，q)来表示。</p><p id="4726" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">p、d和q分别代表数据中的季节性、趋势和噪声。我们将首先创建p、d和q的所有可能组合，如下所示:</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="bb3b" class="lc jv hi ky b fi ld le l lf lg"># Define the p, d and q parameters to take any value between 0 and 3<br/>p = d = q = range(0, 2)</span><span id="05e0" class="lc jv hi ky b fi lh le l lf lg"># Generate all different combinations of p, q and q triplets<br/>pdq = list(itertools.product(p, d, q))</span><span id="5b78" class="lc jv hi ky b fi lh le l lf lg"># Generate all different combinations of seasonal p, q and q triplets<br/>seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]</span><span id="5a1f" class="lc jv hi ky b fi lh le l lf lg">print('Examples of parameter combinations for Seasonal ARIMA: ')<br/>print('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[1]))<br/>print('SARIMAX: {} x {}'.format(pdq[1], seasonal_pdq[2]))<br/>print('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[3]))<br/>print('SARIMAX: {} x {}'.format(pdq[2], seasonal_pdq[4]))</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/c19e32af17713bc1ab2216485642cba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*IszQIOCJ4ERsrS3tmO_W8g.jpeg"/></div></figure><p id="386f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">ARIMA超参数调谐</strong></p><p id="8a71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了选择上述参数的最佳组合，我们将使用<strong class="is hj">网格搜索</strong>。参数的最佳组合将给出最低的赤池信息标准(AIC)分数。AIC告诉我们一组给定数据的统计模型的质量。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="7c44" class="lc jv hi ky b fi ld le l lf lg"># Determing p,d,q combinations with AIC scores.<br/>for param in pdq:<br/>    for param_seasonal in seasonal_pdq:<br/>        try:<br/>            mod = sm.tsa.statespace.SARIMAX(train_arima,<br/>                                            order=param,<br/>                                            seasonal_order=param_seasonal,<br/>                                            enforce_stationarity=False,<br/>                                            enforce_invertibility=False)</span><span id="5cef" class="lc jv hi ky b fi lh le l lf lg">results = mod.fit()</span><span id="8519" class="lc jv hi ky b fi lh le l lf lg">print('ARIMA{}x{}12 - AIC:{}'.format(param, param_seasonal, results.aic))<br/>        except:<br/>            continue</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/6095a0b2c7bd9f075e387494b492ceec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*wULpCPJwCLs2ARfvrUmR4g.jpeg"/></div></figure><p id="6287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我只包括了网格搜索的快照。以上迭代建议<strong class="is hj"> SARIMAX(1，1，1)x(0，1，1，12)12 </strong>为最低<strong class="is hj"> AIC: 1806.29的最佳参数组合。</strong></p><p id="6c6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">拟合ARIMA模型</strong></p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="7d0c" class="lc jv hi ky b fi ld le l lf lg"># Fitting the data to ARIMA model <br/>model_sarima = sm.tsa.statespace.SARIMAX(train_arima,<br/>                                order=(1, 1, 1),<br/>                                seasonal_order=(0, 1, 1, 12),<br/>                                enforce_stationarity=False,<br/>                                enforce_invertibility=False)</span><span id="7e15" class="lc jv hi ky b fi lh le l lf lg">results_sarima = model_sarima.fit()</span><span id="2087" class="lc jv hi ky b fi lh le l lf lg">print(results_sarima.summary().tables[1])</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/6e06d4dbadc756991dd81f1613fe6162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G47mhT26epRE39MciTe0kw.jpeg"/></div></div></figure><p id="5a36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们检查诊断图来可视化我们模型的性能。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="7769" class="lc jv hi ky b fi ld le l lf lg"># Checking diagnostic plots<br/>results_sarima.plot_diagnostics(figsize=(10, 10))<br/>plt.show()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es me"><img src="../Images/a44a189d1ed1d7526f22103e58ceedae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*SSfLyezI74KzLGFOqTzrgA.png"/></div></figure><p id="431b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正态Q-Q图显示残差的有序分布遵循类似正态分布的分布。因此，我们的模型似乎相当不错。</p><p id="2642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型预测</strong></p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="1529" class="lc jv hi ky b fi ld le l lf lg"># Model Prediction<br/># Predictions are performed for the 11th Jan' 2015 onwards of the train data.</span><span id="b0a8" class="lc jv hi ky b fi lh le l lf lg">pred = results_sarima.get_prediction(start=pd.to_datetime('2015-01-11'), dynamic = False)</span><span id="e5b9" class="lc jv hi ky b fi lh le l lf lg"># Get confidence intervals of forecasts<br/>pred_ci = pred.conf_int()</span><span id="47e0" class="lc jv hi ky b fi lh le l lf lg">ax = train_arima["2014":].plot(label = "observed", figsize=(15, 7))<br/>pred.predicted_mean.plot(ax = ax, label = "One-step ahead Forecast", alpha = 1)<br/>ax.fill_between(pred_ci.index, <br/>                pred_ci.iloc[:, 0], <br/>                pred_ci.iloc[:, 1], <br/>                color = "k", alpha = 0.05)</span><span id="74eb" class="lc jv hi ky b fi lh le l lf lg">ax.set_xlabel("Date")<br/>ax.set_ylabel("Sales")</span><span id="d5b6" class="lc jv hi ky b fi lh le l lf lg">plt.legend<br/>plt.show()</span><span id="0030" class="lc jv hi ky b fi lh le l lf lg">train_arima_forecasted = pred.predicted_mean<br/>train_arima_truth = train_arima["2015-01-11":]</span><span id="4c15" class="lc jv hi ky b fi lh le l lf lg"># Calculating the error<br/>rms_arima = sqrt(mean_squared_error(train_arima_truth, train_arima_forecasted))<br/>print("Root Mean Squared Error: ", rms_arima)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/05b212edee0bbe8cd2eda66cb0b9dbf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMem6seYYznUHFmqdFZkFg.png"/></div></div></figure><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/ae0f697403dd1b88848ed60e3d414c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*mFX41emlQ9sg53A9cqMNtg.jpeg"/></div></figure><p id="df68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图显示，我们的预测值赶上了数据集中的观察值。我们的预测似乎与实际情况非常吻合，并如预期的那样在12月份出现峰值。在我们的例子中，RMSE也相当低。</p><p id="7947" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，最终的ARIMA模型可以表示为<strong class="is hj"> SARIMAX(1，1，1)x(0，1，1，12)12。这是我们能对ARIMA做的最好的，所以让我们尝试另一个模型，看看我们是否能减少RMSE。</strong></p><p id="c48c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模式二:先知</strong></p><p id="4413" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Prophet是脸书的开源工具。此过程用于预测基于加法模型的时间序列数据，在加法模型中，非线性趋势与每年、每周和每天的季节性以及假日影响相适应。</p><p id="acba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基线模型</strong></p><p id="2c01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的基线(初始)模型将使用默认参数。让我们看看它的表现如何。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="30b2" class="lc jv hi ky b fi ld le l lf lg"># Creating a train dataset<br/>train_prophet = train.copy()<br/>train_prophet.reset_index(level=0, inplace=True)</span><span id="0517" class="lc jv hi ky b fi lh le l lf lg"># Converting col names to specific names as required by Prophet library<br/>train_prophet = train_prophet.rename(columns = {'Date': 'ds',<br/>                                'Sales': 'y'})</span><span id="b605" class="lc jv hi ky b fi lh le l lf lg"># Downsampling to week because modelling on daily basis takes a lot of time<br/>ts_week_prophet = train_prophet.set_index("ds").resample("W").sum()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/3a43d1ed4d7e9040b875deb166927c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i_fSCXdSJ354FRsqZd_2Q.jpeg"/></div></div></figure><p id="b397" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">拟合先知模型</strong></p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="e844" class="lc jv hi ky b fi ld le l lf lg"># Fitting data to Prophet model<br/>prophet_1 = Prophet() <br/>prophet_1.fit(ts_week_prophet_train)</span></pre><p id="0140" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型预测</strong></p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="fe95" class="lc jv hi ky b fi ld le l lf lg">future_1 = prophet_1.make_future_dataframe(periods = 52, freq = "W") <br/>forecast_1 = prophet_1.predict(future)<br/>forecast_1[["ds", "yhat", "yhat_lower", "yhat_upper"]].tail()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/f5ad466c80833cdce18d89d0399071c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*1UjUuNjVCQr-WwK4EoheYg.jpeg"/></div></figure><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="7936" class="lc jv hi ky b fi ld le l lf lg"># Visualizing predicions of forecast<br/>prophet.plot(forecast_1);</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/072d375f3a9c9f3c98b8f92c46c5fcf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7HAygrTocsQ_dDbXmLOLw.png"/></div></div></figure><p id="093c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的图中我们可以看出，预测是相当不错的，但让我们看看RMSE，以获得更好的想法。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="9faa" class="lc jv hi ky b fi ld le l lf lg"># Checking the RMSE of Prophet model<br/>metric_prophet_1 = forecast_1.set_index('ds')[['yhat']].join(ts_week_prophet_train.set_index('ds').y).reset_index()<br/>metric_prophet_1.dropna(inplace=True)<br/>rms_prophet_1 = mean_squared_error(metric_prophet_1.y, metric_prophet_1.yhat)<br/>rms_prophet_1</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/421a861f5904f39d1777305d16a81f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*RWEvgHKqv_r0LBtM4ECiVw.jpeg"/></div></figure><p id="722b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哇！在这种情况下，RMSE太大了，我们需要做点什么。让我们看看是否可以通过操纵一些参数来降低它。</p><h2 id="111d" class="lc jv hi bd jw mk ml mm ka mn mo mp ke jb mq mr ki jf ms mt km jj mu mv kq mw bi translated"><strong class="ak">先知的超参数调整</strong></h2><p id="5ef9" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在Prophet模型中有许多可用的参数。其中最重要的是<strong class="is hj">【假日】</strong>。这让我们可以在训练模型时显式解析假日。我们将通过在学校或州放假时进行观察来创建一个新的“假期”数据框。</p><p id="ab68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还将使用另外三个参数，即。</p><ul class=""><li id="cc54" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn mx lq lr ls bi translated"><strong class="is hj"> interval_width </strong>:定义进行预测的不确定程度。默认值为0.8，但我们将采用0.95，因为我们希望在预测中更加确定。</li><li id="4465" class="lk ll hi is b it my ix mz jb na jf nb jj nc jn mx lq lr ls bi translated"><strong class="is hj">增长</strong>:我们知道‘销售’可以取任何值，不存在饱和点。因此，我们将采用“线性”增长，而不是“对数”增长。</li><li id="6d78" class="lk ll hi is b it my ix mz jb na jf nb jj nc jn mx lq lr ls bi translated"><strong class="is hj">yearly _ seasonity</strong>:我们将明确地把它作为‘True’传递，因为我们知道在我们的数据中存在一个年度季节性(如上所述)。</li></ul><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="ed6f" class="lc jv hi ky b fi ld le l lf lg"># Encoding state holiday categorical variable<br/>train_prophet["StateHoliday_cat"] = train_prophet["StateHoliday"].map({0:0, "0": 0, "a": 1, "b": 1, "c": 1})</span><span id="67e1" class="lc jv hi ky b fi lh le l lf lg"># Choosing only required cols<br/>train_prophet = train_prophet[['ds', 'y', 'SchoolHoliday', 'StateHoliday_cat']]<br/>train_prophet.head()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/460b5fafbadf30e9a8cdc026369bc7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*6as_Bi7saptg0vx99kP2eA.jpeg"/></div></figure><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="ce96" class="lc jv hi ky b fi ld le l lf lg"># Modelling holidays - creating holidays dataframe<br/>state_dates = train_prophet[(train_prophet.StateHoliday_cat == 1)].loc[:, "ds"].values<br/>school_dates = train_prophet[(train_prophet.SchoolHoliday == 1)].loc[:, "ds"].values</span><span id="5eb6" class="lc jv hi ky b fi lh le l lf lg">state = pd.DataFrame({"holiday": "state_holiday",  "ds": pd.to_datetime(state_dates)})<br/>school = pd.DataFrame({"holiday": "school_holiday", "ds": pd.to_datetime(school_dates)})</span><span id="85bb" class="lc jv hi ky b fi lh le l lf lg">holidays = pd.concat((state, school))<br/>holidays.head()</span><span id="1cc6" class="lc jv hi ky b fi lh le l lf lg"># Dropping holiday columns because not needed any more<br/>train_prophet_clean = train_prophet.drop(["SchoolHoliday", "StateHoliday_cat"], axis = 1)</span><span id="8446" class="lc jv hi ky b fi lh le l lf lg"># Downsampling to week because modelling on daily basis takes a lot of time<br/>ts_week_prophet = train_prophet_clean.set_index("ds").resample("W").sum()</span><span id="053a" class="lc jv hi ky b fi lh le l lf lg"># Resetting the index<br/>ts_week_prophet_train = ts_week_prophet.reset_index()<br/></span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/7ea1bdaf6b75591ccc85ae0a6e3dfcad.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*VPBLPXAcpDmZemWzzDgyRw.jpeg"/></div></figure><p id="87f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">拟合超调先知模型</strong></p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="6857" class="lc jv hi ky b fi ld le l lf lg"># Fitting data to Prophet model<br/>prophet_2 = Prophet(holidays = holidays, interval_width = 0.95, growth='linear', yearly_seasonality = True) <br/>prophet_2.fit(ts_week_prophet_train)<br/>print("done")</span></pre><p id="88d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型预测</strong></p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="0fce" class="lc jv hi ky b fi ld le l lf lg">future_2 = prophet_2.make_future_dataframe(periods = 52, freq = "W") <br/>forecast_2 = prophet_2.predict(future)<br/>forecast_2[["ds", "yhat", "yhat_lower", "yhat_upper"]].tail() # We have a new dataframe, which includes, the forecast and the uncertainity invervals.</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/1be9c13ee8c0f03ad17f723787a6bd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Ahzd8-arcZdLKZcfJwqXRA.jpeg"/></div></figure><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="8d28" class="lc jv hi ky b fi ld le l lf lg"># Visualizing predicions of forecast<br/>prophet.plot(forecast_2);</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7e496a0b33c9023f07fcb4cc8c9948a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpeaxUAjsQzCl1wDHonioQ.png"/></div></div></figure><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="de40" class="lc jv hi ky b fi ld le l lf lg"># Visualizing trend and seasonality components<br/>prophet.plot_components(forecast_2);</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/e825f818d53e15b9c5811fd23482e4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*J4aSYNOAeCyQQksBFVPVqA.png"/></div></figure><p id="54d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一幅图显示每周的总销售额在增加。第二个图显示了数据集中的假期差距，第三个图显示了商店在12月最后一周的销售额非常高(因为圣诞节假期)。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="18b8" class="lc jv hi ky b fi ld le l lf lg"># Checking the RMSE of Prophet model<br/>metric_prophet_2 = forecast_2.set_index('ds')[['yhat']].join(ts_week_prophet_train.set_index('ds').y).reset_index()<br/>metric_prophet_2.dropna(inplace=True)<br/>rms_prophet_2 = mean_squared_error(metric_prophet_2.y, metric_prophet_2.yhat)<br/>rms_prophet_2</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/cae45ec541709cd53083335b8185c711.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*k7tjC4iUwwXS3xmBLm6Ctg.jpeg"/></div></figure><p id="72dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的基线Prophet模型使用默认参数，我们得到的RMSE为53782649094881.14，经过超调后，我们得到的RMSE为52478331938232.15。虽然最终的模型表现更好，但与ARIMA相比，它仍然表现不佳。那么，让我们试试另一种模式。</p><p id="4c07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型3: XGBoost </strong></p><p id="0072" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">XGBoost是一个优化的分布式梯度增强库，设计为高度<strong class="is hj">高效</strong>、<strong class="is hj">灵活</strong>和<strong class="is hj">便携</strong>。虽然它不是专门为时间序列数据设计的，但众所周知，它在各种回归问题上都表现得非常好。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="607c" class="lc jv hi ky b fi ld le l lf lg"># Dropping Customers and Sale per customer<br/>ts_xgboost = train_store_joined.copy()<br/>ts_xgboost = ts_xgboost.drop(['Customers', 'SalePerCustomer', 'PromoInterval'], axis=1)</span><span id="b90a" class="lc jv hi ky b fi lh le l lf lg"># Combining similar columns into one column and dropping old columns<br/>ts_xgboost['CompetitionOpen'] = 12 * (ts_xgboost.Year - ts_xgboost.CompetitionOpenSinceYear) + (ts_xgboost.Month - ts_xgboost.CompetitionOpenSinceMonth)<br/>ts_xgboost['PromoOpen'] = 12 * (ts_xgboost.Year - ts_xgboost.Promo2SinceYear) + (ts_xgboost.WeekOfYear - ts_xgboost.Promo2SinceWeek) / 4.0<br/>ts_xgboost = ts_xgboost.drop(["CompetitionOpenSinceMonth", "CompetitionOpenSinceYear"], axis = 1)<br/>ts_xgboost = ts_xgboost.drop(["Promo2SinceWeek", "Promo2SinceYear"], axis = 1)</span><span id="d480" class="lc jv hi ky b fi lh le l lf lg"># Converting categorical cols to numerical cols and removing old cols<br/>mappings = {0:0, "0": 0, "a": 1, "b": 1, "c": 1}<br/>ts_xgboost["StateHoliday_cat"] = ts_xgboost["StateHoliday"].map(mappings)<br/>ts_xgboost["StoreType_cat"] = ts_xgboost["StoreType"].map(mappings)<br/>ts_xgboost["Assortment_cat"] = ts_xgboost["Assortment"].map(mappings)<br/>ts_xgboost = ts_xgboost.drop(["StateHoliday", "StoreType", "Assortment"], axis = 1)</span><span id="7145" class="lc jv hi ky b fi lh le l lf lg"># Splitting the data<br/>features = ts_xgboost.drop(["Sales"], axis = 1)<br/>target = ts_xgboost["Sales"]</span><span id="1736" class="lc jv hi ky b fi lh le l lf lg">X_train, X_test, y_train, y_test = model_selection.train_test_split(features, target, test_size = 0.20)</span></pre><p id="4ae2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基线模型</strong></p><p id="5861" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的基线(初始)模型将使用默认参数。让我们看看它的表现如何。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="98ee" class="lc jv hi ky b fi ld le l lf lg"># Tuning parameters - using default metrics<br/>params = {'max_depth':6, "booster": "gbtree", 'eta':0.3, 'objective':'reg:linear'}</span><span id="de60" class="lc jv hi ky b fi lh le l lf lg">dtrain = xgb.DMatrix(X_train, y_train)<br/>dtest = xgb.DMatrix(X_test, y_test)<br/>watchlist = [(dtrain, 'train'), (dtest, 'eval')]</span><span id="8e75" class="lc jv hi ky b fi lh le l lf lg"># Training the model<br/>xgboost = xgb.train(params, dtrain, 100, evals=watchlist,early_stopping_rounds= 100, verbose_eval=True)<br/>         <br/># Making predictions<br/>preds = xgboost.predict(dtest)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/98173df498aa5af19609d25a6e23636c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ziwzXbCER4vwcsYyCMQnQ.jpeg"/></div></div></figure><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="eaa8" class="lc jv hi ky b fi ld le l lf lg"># RMSE of model<br/>rms_xgboost = sqrt(mean_squared_error(y_test, preds))<br/>print("Root Mean Squared Error for XGBoost:", rms_xgboost)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/4791800c82ddc523d5ed02574cbd91c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*dOMmJyZfHzshhtrGI9euSg.jpeg"/></div></div></figure><p id="c075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至少与Prophet相比，它的表现相当不错。让我们看看能否进一步降低RMSE。</p><h2 id="3731" class="lc jv hi bd jw mk ml mm ka mn mo mp ke jb mq mr ki jf ms mt km jj mu mv kq mw bi translated">XGBoost的超调</h2><p id="ae71" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">现在，让我们尝试通过为XGBoost模型中的超参数传递不同的值来降低XGBoost的RMSE。</p><ul class=""><li id="a0fb" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn mx lq lr ls bi translated"><strong class="is hj"> eta </strong>:定义学习率，即梯度下降建模中学习数据的步长(XGBoost的基础)。默认值为0.3，但我们希望保持较低的学习速率，以避免过度拟合。所以，我们选择0.2作为eta。</li><li id="d58d" class="lk ll hi is b it my ix mz jb na jf nb jj nc jn mx lq lr ls bi translated"><strong class="is hj"> max_depth </strong>:一棵树的最大深度。默认值是6，但我们希望我们的模型更复杂，并找到更好的预测。所以，让我们选择10作为最大深度。</li><li id="5df1" class="lk ll hi is b it my ix mz jb na jf nb jj nc jn mx lq lr ls bi translated"><strong class="is hj"> gamma </strong>:在树的叶子节点上做进一步划分所需的最小损失减少。伽玛越大，算法就越保守。默认值是0，让我们选择一个稍微高一点的值，以便得到好的预测。</li></ul><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="a779" class="lc jv hi ky b fi ld le l lf lg"># Tuning parameters<br/>params_2 = {'max_depth':10, 'eta':0.1,  'gamma': 2}</span><span id="7d2b" class="lc jv hi ky b fi lh le l lf lg">dtrain = xgb.DMatrix(X_train, y_train)<br/>dtest = xgb.DMatrix(X_test, y_test)<br/>watchlist = [(dtrain, 'train'), (dtest, 'eval')]</span><span id="44f9" class="lc jv hi ky b fi lh le l lf lg"># Training the model<br/>xgboost_2 = xgb.train(params_2, dtrain, 100, evals=watchlist,early_stopping_rounds= 100, verbose_eval=True)<br/>         <br/># Making predictions<br/>preds_2 = xgboost_2.predict(dtest)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/a9fa7601899f5ac4bc2e6c5fa72198d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUfzOJoUzEdBzO7aoHBSSw.jpeg"/></div></div></figure><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="453e" class="lc jv hi ky b fi ld le l lf lg"># RMSE of model<br/>rms_xgboost_2 = sqrt(mean_squared_error(y_test, preds_2))<br/>print("Root Mean Squared Error for XGBoost:", rms_xgboost_2)</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es nl"><img src="../Images/26b01cb4ddc675294f923952fe744198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*XH-EuGFCIJ2ESh4fZ11QNA.jpeg"/></div></figure><p id="b244" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">超调后，我们看到我们的模型的RMSE下降。让我们来看看什么特征会影响商店的销售。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="71bf" class="lc jv hi ky b fi ld le l lf lg"># Let's see the feature importance<br/>fig, ax = plt.subplots(figsize=(10,10))<br/>xgb.plot_importance(xgboost_2, max_num_features=50, height=0.8, ax=ax)<br/>plt.show()</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/62fbdce9fcff2f4b39bedfcbcea2171c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGzPQ24ZWWhZbnlSoDYXnA.png"/></div></div></figure><p id="3da7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不出所料，影响商店销售的主要原因有五个，即。<strong class="is hj">商店数量、比赛距离、星期几、比赛开始和促销</strong>。</p><p id="1a88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们最终的XGBoost模型在超调后是一个具有<strong class="is hj">“max _ depth”:10，“eta”:0.1，“gamma”:2和1191.90的RMSE分数</strong>的模型，非常棒！现在，让我们比较一下所有型号的性能</p><p id="222f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。结果</strong></p><p id="f93a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用均方根误差(RMSE)来评估和验证各种模型的性能。让我们看看哪个模型表现更好，为什么/为什么不。</p><pre class="jq jr js jt fd kx ky kz la aw lb bi"><span id="5f12" class="lc jv hi ky b fi ld le l lf lg"># Comparing performance of above three models - through RMSE<br/>rms_arima = format(float(rms_arima))<br/>rms_prophet_2 = format(float(rms_prophet_2))<br/>rms_xgboost_2 = format(float(rms_xgboost_2))</span><span id="f4af" class="lc jv hi ky b fi lh le l lf lg">model_errors = pd.DataFrame({<br/>    "Model": ["SARIMA", "Prophet", "XGBoost"],<br/>    "RMSE": [rms_arima, rms_prophet_2, rms_xgboost_2]<br/>})</span><span id="9b56" class="lc jv hi ky b fi lh le l lf lg">model_errors.sort_values(by = "RMSE")</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/c3726c7fd6f7cd1e0825b4638f8120c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*UqT4XnzXl6GIfe675V0ADA.jpeg"/></div></figure><p id="f104" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。型号对比&amp;选择</strong></p><p id="d38a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a)从上表我们可以看出，SARIMA表现最好，其次是XGBoost和Prophet。</p><p id="2bde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b)这是有意义的，因为SARIMA是专门为季节性时间序列数据设计的，而XGBoost是一种通用的(尽管功能强大)机器学习方法，具有各种应用。</p><p id="7fc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">c) Prophet是制作快速预测的好选择，因为它不需要很强的技术技能。这很容易大规模实施。它在这里表现不佳的原因可能是因为缺乏数据。它最适用于具有强烈季节效应的时间序列和几个季节的历史数据。Prophet对缺失数据和趋势变化非常稳健，通常能够很好地处理异常值。</p><p id="7948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于上述分析，我们将选择ARIMA作为我们预测销售的最终模型，因为它给我们的RMSE最小，并且非常适合我们预测时间序列季节性数据的需要。我们选择<strong class="is hj"> ARIMA(1，1，1)x(0，1，1，12)12 </strong>与<strong class="is hj">AIC 1806.29和RMSE 739.06作为最终参数组合。</strong></p><p id="983a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。结论</strong></p><p id="04ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">倒影</strong></p><ul class=""><li id="b7f1" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn mx lq lr ls bi translated">数据中最有趣的是，销售额最高的商店类别并没有最高的每位顾客销售额。这可能是因为这些商店出售日常所需的小商品。</li><li id="2f7a" class="lk ll hi is b it my ix mz jb na jf nb jj nc jn mx lq lr ls bi translated">另一件有趣的事情是，第二次进行促销对增加销售额没有帮助。这可能是因为顾客在第一次促销活动中已经购买了他们想要的东西。</li></ul><p id="6552" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">致谢</strong></p><p id="d228" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/ARIMA-for-time-series-forecasting-with-python/</a></p><p id="2c83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-forecasting-with-arima-in-python-3" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/a-guide-to-time-series-forecasting-with-ARIMA-in-python-3</a></p><p id="348d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://xgboost.readthedocs.io/en/latest/python/python_intro.html" rel="noopener ugc nofollow" target="_blank">https://xgboost . readthedocs . io/en/latest/python/python _ intro . html</a></p><p id="aa09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/prophet/docs/quick_start.html</a></p><p id="c814" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多详情，请查看Github  上的<a class="ae jo" href="https://github.com/bisman16/Kaggle_Rossmann_Store_Sales_Forecasting" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">源代码。</strong></a></p></div><div class="ab cl no np gp nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="hb hc hd he hf"><p id="a195" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢阅读这个故事，请点击👏按钮并分享出来，帮助其他人学习机器学习。我很想听听你的想法，欢迎在下面留下你的评论。</p></div></div>    
</body>
</html>