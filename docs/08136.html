<html>
<head>
<title>Interactive directions map with OSM and networkx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有OSM和网络x的交互式方向地图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/interative-map-with-osm-directions-and-networkx-582c4f3435bc?source=collection_archive---------4-----------------------#2020-07-19">https://medium.com/analytics-vidhya/interative-map-with-osm-directions-and-networkx-582c4f3435bc?source=collection_archive---------4-----------------------#2020-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f23b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在地图中追踪路线本身就是一个巨大的世界，但在本教程中，我将向您展示处理这一问题的基础和核心概念，使用来自OSMNX的开放街道地图数据、Networkx图表和交互式Ipyleaflet地图来查看我们正在构建的内容。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="f030" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">它是如何工作的？</h1><p id="d90c" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">我们可以想象一个城市区域，你的街道和角落就像一个图表，包括你所有的房产。例如，拐角是节点，街道段是连接所有这些节点的顶点，用线段的长度加权。这样做的好处是，有了图，我们就能够使用所有的图算法来计算加权最短路径。</p><p id="b605" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我们将使用由Networkx库提供的Dijkstra加权最短路径算法来获得城市区域中两个节点之间的最短路径，并且我们将使用Ipyleaflet来获得这些路径是如何生成的交互视图。</p><h1 id="d985" class="jk jl hi bd jm jn kn jp jq jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh bi translated">钻研代码</h1><p id="2aff" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">首先，我们需要导入python库</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="437a" class="lb jl hi kx b fi lc ld l le lf">import networkx as nx<br/>import osmnx as ox<br/>from shapely.geometry import LineString, mapping<br/>import geopandas as gpd<br/>from ipyleaflet import *</span></pre><p id="1134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用Networkx来处理图表本身，使用OSMNX来检索开放的街道地图数据，使用shapely来在地图上绘制路线，使用GeoPandas来查看数据帧，使用Ipyleaflet来查看正在发生的事情。</p><h2 id="fbca" class="lb jl hi bd jm lg lh li jq lj lk ll ju iq lm ln jy iu lo lp kc iy lq lr kg ls bi translated">选择一个工作区域</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a7c4" class="lb jl hi kx b fi lc ld l le lf">place_name = “Kamppi, Helsinki, Finland”<br/>graph = ox.graph_from_place(place_name)<br/>fig, ax = ox.plot_graph(graph)</span></pre><figure class="ks kt ku kv fd lu er es paragraph-image"><div class="er es lt"><img src="../Images/c31c2983633463b9e7feb1e181687dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*L3ZvzriYQ6dCGL1qfXhUew.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">图表来自芬兰赫尔辛基Kammpi</figcaption></figure><p id="6924" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OSMNX有一个名为<em class="mb"> graph_from_place，</em>的功能，因此您可以通过选择社区、城市和国家来检索OSM的数据，所有这些数据都以netoworkx多向图的形式出现。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b8f6" class="lb jl hi kx b fi lc ld l le lf">nodes, edges = ox.graph_to_gdfs(graph)<br/>nodes</span></pre><figure class="ks kt ku kv fd lu er es paragraph-image"><div class="er es mc"><img src="../Images/baf0720502ad08b332bbef9afedffc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*9Ecgidsc-VkKfmspUYdOvQ.png"/></div></figure><p id="e68e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一种使用Geopandas地理数据框架查看和获取图表数据的简单方法。</p><h2 id="948a" class="lb jl hi bd jm lg lh li jq lj lk ll ju iq lm ln jy iu lo lp kc iy lq lr kg ls bi translated">创建交互式地图</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="04a9" class="lb jl hi kx b fi lc ld l le lf">center = (60.16607, 24.93116)</span><span id="8f15" class="lb jl hi kx b fi md ld l le lf">m = Map(center=center, basemap=basemaps.CartoDB.Positron, zoom=15)<br/>m</span></pre><figure class="ks kt ku kv fd lu er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es me"><img src="../Images/0025df795d942e8dbc63259fe243727c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPma5UD5wrqod8vmbVGkZQ.png"/></div></div></figure><p id="2238" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着地图的创建，我们可以创建标记来与它交互，并看到正在绘制的方向，第一个将是我们的起点，第二个是我们的目的地。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6062" class="lb jl hi kx b fi lc ld l le lf">#style for the destination marker<br/>to_marker_style = AwesomeIcon(<br/>    name='circle',<br/>    icon_color='white',<br/>    marker_color='red',<br/>    spin=False<br/>)</span><span id="e96c" class="lb jl hi kx b fi md ld l le lf">from_marker = Marker(location=center)<br/>to_marker = Marker(location=center, icon=to_marker_style)</span></pre><p id="b5c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建标记后，我们必须设置两个函数，一个基于标记位置获取最近的节点，另一个处理标记位置的变化，计算最短路径并将其添加到地图中。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9e1f" class="lb jl hi kx b fi lc ld l le lf">def set_nearest_node(marker):<br/> marker.nearest_node = ox.get_nearest_node(graph, marker.location)<br/> return</span></pre><p id="6ae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数将把nearest_node属性注入到标记实例中，这样我们就可以在这两个标记的最近节点之间搜索最短路径。</p><h2 id="f9b4" class="lb jl hi bd jm lg lh li jq lj lk ll ju iq lm ln jy iu lo lp kc iy lq lr kg ls bi translated">最后处理标记改变位置</h2><p id="bb94" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">Ipyleaflet有一个<em class="mb"> observe </em>函数，当层的状态改变时会被调用，你可以过滤你想要调用回调函数的改变类型。</p><p id="6b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将创建一个<em class="mb"> handle_change_location </em>函数来处理标记位置，并绘制由Dijkstra算法创建的路线。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d88f" class="lb jl hi kx b fi lc ld l le lf">path_layer_list = []</span><span id="28de" class="lb jl hi kx b fi md ld l le lf">def handle_change_location(event, marker):<br/>    event_owner = event['owner']<br/>    event_owner.nearest_node = ox.get_nearest_node(graph, event_owner.location)<br/>    marker.nearest_node = ox.get_nearest_node(graph, marker.location)<br/>    <br/>    shortest_path = nx.dijkstra_path(graph, event_owner.nearest_node, marker.nearest_node, <br/>                                     weight='length')<br/>    <br/>    if len(path_layer_list) == 1:<br/>        m.remove_layer(path_layer_list[0])<br/>        path_layer_list.pop()<br/>    <br/>    shortest_path_points = nodes.loc[shortest_path]<br/>    path = gpd.GeoDataFrame([LineString(shortest_path_points.geometry.values)], columns=['geometry'])<br/>    path_layer = GeoData(geo_dataframe=path, style={'color':'black', 'weight':2})<br/>    m.add_layer(path_layer)<br/>    path_layer_list.append(path_layer)</span></pre><p id="7f58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mb"> path_layer_list </em>是一个存储我们的路径层的列表，通过这个函数我们得到了抛出回调的marker实例和另一个需要计算最短路径的实例。</p><p id="b87e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次计算最近的节点，现在使用新的标记位置。我们使用networkx <em class="mb"> dijkstra_path </em>算法来计算这两个节点之间的最短路径。该函数返回表示路线本身的节点列表，我们可以通过在前面创建的Geopandas数据帧上过滤这些节点来获得节点几何。</p><p id="2c60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在只需创建要在我们的地图中绘制的线字符串，创建它的ipyleaflet图层，并将该图层添加到地图中。我们还必须提醒删除旧的路径层，如果有一个，并添加新的层到列表中。</p><p id="3113" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建好函数后，现在我们只需要将它作为回调添加到标记的observe方法中。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4c5e" class="lb jl hi kx b fi lc ld l le lf">from_marker.observe(lambda event: handle_change_location(event, to_marker), 'location')<br/>to_marker.observe(lambda event: handle_change_location(event, from_marker), 'location')</span></pre><p id="fc6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后将图层添加到地图并调用set_nearest_node。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="916e" class="lb jl hi kx b fi lc ld l le lf">m.add_layer(from_marker)<br/>m.add_layer(to_marker)<br/>set_nearest_node(from_marker)<br/>set_nearest_node(to_marker)<br/>m</span></pre><figure class="ks kt ku kv fd lu er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mj"><img src="../Images/8fde1522177027cf49a5b813871e5fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X38A8vJnQ_Pp3Kj2UArVag.png"/></div></div></figure><p id="3baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可以玩这两个标记，看看它们之间的相互作用，在街道网络中创建新的最短路径。</p><figure class="ks kt ku kv fd lu er es paragraph-image"><div class="er es mk"><img src="../Images/e6cf6a61e1b396ae8a0766904047992f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*BAPOnaBRenF_EdzupLfGgA.gif"/></div></figure><h1 id="abd6" class="jk jl hi bd jm jn kn jp jq jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh bi translated">结论</h1><p id="70a0" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">有很多很酷的东西可以用来处理图形和地图，路由只是其中之一！</p><p id="a4e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">资源库与代码的链接如下，可以随意复制和修改！</p><div class="ml mm ez fb mn mo"><a href="https://github.com/tallesfelix/directions-with-osm-networkx" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">talles Felix/带osm-networkx的方向</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">通过在GitHub上创建一个帐户，为talles Felix/directions-with-osm-networkx开发做出贡献。</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc lv mo"/></div></div></a></div></div></div>    
</body>
</html>