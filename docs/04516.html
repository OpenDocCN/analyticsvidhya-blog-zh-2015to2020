<html>
<head>
<title>RESTful API, HOW TO | Part 3 — Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RESTful API，如何|第3部分—测试</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/restful-api-how-to-part-3-testing-8fd3fac4e1cd?source=collection_archive---------21-----------------------#2020-03-22">https://medium.com/analytics-vidhya/restful-api-how-to-part-3-testing-8fd3fac4e1cd?source=collection_archive---------21-----------------------#2020-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/426628d467e0fc9849bee7e97a40a1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JBRnF_km6C-6MLpV"/></div></div></figure><p id="f347" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设计和实施服务是我日常工作的一部分，我想分享一些最佳实践和技巧，可以帮助你的工作。</p><p id="ce63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个关于RESTful API的系列文章中，我将讨论几个主题:</p><ul class=""><li id="b70c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">设计</li><li id="48a7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">履行</li><li id="b5d1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">测试</strong></li><li id="b828" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">部署</li></ul><h1 id="6a7b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">一些信息</h1><blockquote class="la lb lc"><p id="a9fe" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><em class="hi">我们将使用</em><a class="ae lh" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">swagger</em></strong></a><em class="hi">来设计我们的API，</em><a class="ae lh" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">python</em></strong></a><em class="hi">语言来创建微服务，最后</em><a class="ae lh" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">Docker</em></strong></a><em class="hi">来交付最终的解决方案。所有的代码都在这个</em> <a class="ae lh" href="https://github.com/dandpz/restfulapi-howto" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="hi">回购</em> </strong> </a> <em class="hi">中。</em></p></blockquote></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="b291" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在之前的文章中，我们看到了如何设计一个简单的RESTful API以及如何实现它。现在是添加一些测试的时候了，但是首先让我们谈谈测试，它们有什么用，以及为什么你应该总是将它们添加到你的开发流程中。</p><p id="74f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将讨论<strong class="is hj">单元测试</strong>，它们对于测试应用程序的单个组件非常有用。他们可以帮助你在投入生产之前发现错误，如果你以正确的方式编写它们，他们还可以检查在代码改变后功能是否仍然工作。我们现在正在考虑测试后，我们已经开发了几乎所有的代码。也有像TDD这样的模式，首先编写测试，运行它们(它们会失败)，最后编写代码使测试通过。</p><p id="c34e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从swagger生成的代码已经包含了一些测试，如果我们转到tests文件夹，我们可以看到类似这样的内容:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="3383" class="ly kd hi lu b fi lz ma l mb mc">from swagger_server.test import BaseTestCase<br/><br/><br/>class TestTodoController(BaseTestCase):<br/>    <em class="ld">"""TodoController integration test stubs"""<br/><br/>    </em>def test_create_todo(self):<br/>        <em class="ld">"""Test case for create_todo<br/><br/>        Create a new to-do<br/>        """<br/>        </em>body = Todo()<br/>        response = self.client.open(<br/>            "/v1/todo",<br/>            method="POST",<br/>            data=json.dumps(body),<br/>            content_type="application/json",<br/>        )<br/>        self.assert200(response, "Response body is : " + response.data.decode("utf-8"))</span></pre><p id="749d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些测试存根对于测试客户端和我们刚刚创建的API之间的交互非常有用。我们不会关注这些测试，因为我们有一个数据库要与之交互，所以我们不能说这些测试是单元测试，事实上它们的结果取决于HTTP通信和数据库可用性。这些测试可以在<strong class="is hj">集成测试</strong>环境中触发。</p><h1 id="a881" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">写作测试</h1><p id="d41c" class="pw-post-body-paragraph iq ir hi is b it md iv iw ix me iz ja jb mf jd je jf mg jh ji jj mh jl jm jn hb bi translated">让我们在同一个目录中创建一个新文件，我们将创建所有的测试用例来检查我们的DAO方法是否可以工作，但是首先，让我们稍微修改一下<strong class="is hj"> BaseTestCase </strong>类，以便它可以与DB一起工作。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="e669" class="ly kd hi lu b fi lz ma l mb mc">import logging<br/>import os<br/><br/>from flask_testing import TestCase<br/><br/>from swagger_server.__main__ import create_app<br/><br/><br/>class BaseTestCase(TestCase):<br/><br/>    os.environ["APPLICATION_ENV"] = "Testing"<br/><br/>    def create_app(self):<br/>        logging.getLogger("connexion.operation").setLevel("ERROR")<br/>        app = create_app()<br/><br/>        return app.app</span></pre><p id="be3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们应用程序的配置，我们只能改变<strong class="is hj"> APPLICATION_ENV </strong>变量，现在我们已经准备好编写我们的第一个测试:</p><p id="e854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是第一个测试，这是一个如何创建一个案例的例子，测试数据库内的记录的创建。我们使用的流程如下:</p><ul class=""><li id="2ba2" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">我们首先创建一个测试对象</li><li id="99cd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们使用之前实现的DAO方法将它保存在DB中，</li><li id="9ca1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">为了不使用代码中的其他方法，我们使用SQL原始查询来查询数据库</li><li id="fbc0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们检查记录是否已经正确保存</li></ul><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="2610" class="ly kd hi lu b fi lz ma l mb mc">class TestDaoController(BaseTestCase):<br/><br/>    def setUp(self):<br/>        with self.app.app_context():<br/>            db.create_all()<br/><br/>    def tearDown(self):<br/>        with self.app.app_context():<br/>            db.session.remove()<br/>            db.drop_all()<br/><br/>    def test_save_todo_create_a_record_inside_db(self):<br/>        test_todo = TodoModel(<br/>            name="test_name",<br/>            description="some desc",<br/>            due_date=datetime.utcnow(),<br/>            status=Status("to do")<br/>        )<br/>        test_todo.save()<br/>        raw = text("select * from todo where name = '{}'".format("test_name"))<br/>        result = db.session.execute(raw)<br/>        results = []<br/>        for r in result:<br/>            results.append(r)<br/>            self.assertTrue(r["name"] == "test_name")<br/>        self.assertTrue(len(results) == 1)</span></pre><p id="1bf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个方法<strong class="is hj"> setUp </strong>和<strong class="is hj"> tearDown </strong>值得注意，因为它们分别在每个测试用例之前和之后运行，确保每个用例有一个空的和干净的数据库，以便使每个测试用例独立。</p><p id="41b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的系列测试请查看<a class="ae lh" href="https://github.com/dandpz/restfulapi-howto" rel="noopener ugc nofollow" target="_blank">库</a>。</p><h1 id="936e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">运行测试</h1><p id="b342" class="pw-post-body-paragraph iq ir hi is b it md iv iw ix me iz ja jb mf jd je jf mg jh ji jj mh jl jm jn hb bi translated">现在是运行测试的时候了，由于生成了代码，我们已经有了一个几乎可以运行的环境。</p><p id="6c89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们已经正确地激活了虚拟环境并在其中安装了所有的需求，我们只需要在终端中键入<strong class="is hj"> tox </strong>并运行它。</p><p id="6ee8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将看到测试的结果。</p><h1 id="1bd7" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">一些考虑</h1><p id="5a6c" class="pw-post-body-paragraph iq ir hi is b it md iv iw ix me iz ja jb mf jd je jf mg jh ji jj mh jl jm jn hb bi translated">单元测试是开发的一个重要部分，它有多个层次，试图在这一系列文章中涵盖这个主题的所有方面是错误的，因为它的复杂性，它确实值得一个专门的系列。</p><p id="a35e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这篇文章中最重要的是为你的应用程序编写测试的重要性，因为它们可以节省调试的时间，主要是在代码库被其他人共享的情况下。</p><p id="34bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用<strong class="is hj"> python </strong>测试<strong class="is hj">的一些<strong class="is hj">有用的</strong>链接有:</strong></p><ul class=""><li id="dec9" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae lh" href="https://tox.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://tox.readthedocs.io/en/latest/</a></li><li id="6685" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lh" href="https://docs.pytest.org/en/latest/" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/latest/</a></li><li id="eb90" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lh" href="https://flask.palletsprojects.com/en/1.1.x/testing/" rel="noopener ugc nofollow" target="_blank">https://flask.palletsprojects.com/en/1.1.x/testing/</a></li><li id="6c86" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lh" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/unittest.html</a></li></ul></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="290c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们介绍了单元测试的主题，如何编写单元测试以及如何在合适的环境中运行单元测试，我鼓励你探索这个主题，因为它看起来很难，实际上有时也很难，但这是一个实践，一个开发人员应该能够掌握。</p><p id="3953" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一篇也是最后一篇文章中，我们将看到我们的应用程序在类似生产环境中的部署。</p><blockquote class="la lb lc"><p id="cbe2" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">提醒:</em> </strong> <em class="hi">你可以在</em><strong class="is hj"><em class="hi"/></strong><a class="ae lh" href="https://github.com/dandpz/restfulapi-howto" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">这个GitHub资源库找到所有更新的代码！</em> </strong> </a></p><p id="e1d6" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><em class="hi">链接往期文章:</em><a class="ae lh" rel="noopener" href="/analytics-vidhya/restful-api-how-to-part-2-implementation-e3bca6072b70">https://medium . com/analytics-vid hya/restful-API-how-to-part-2-implementation-E3 BCA 6072 b 70</a></p></blockquote></div></div>    
</body>
</html>