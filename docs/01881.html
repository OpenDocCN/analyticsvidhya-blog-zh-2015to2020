<html>
<head>
<title>Expected Exception Attribute in JUnit 4 is not always the best choice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JUnit 4中的预期异常属性并不总是最佳选择</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/expected-exception-attribute-in-junit-4-is-not-always-the-best-choice-363ab34b158d?source=collection_archive---------8-----------------------#2019-11-19">https://medium.com/analytics-vidhya/expected-exception-attribute-in-junit-4-is-not-always-the-best-choice-363ab34b158d?source=collection_archive---------8-----------------------#2019-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/81f746c957b136efbeaef425802f4f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5g30jJH7dwWG76_m"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Justin Veenema 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7aa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我考虑过给它起一个clickbait标题，类似于“JUnit 4中的预期异常属性很糟糕，千万不要使用它！”</p><p id="2eca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，事实是，<code class="du jt ju jv jw b">@Test</code>注释的<code class="du jt ju jv jw b">expected</code>属性有时会很有用。但大多数时候，还有更好的选择。</p><p id="2774" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您正在使用JUnit 4.12为一个Java程序开发一个测试类。假设你从来没有为一个在给定情况下抛出特定异常的单元编写过测试。</p><p id="53fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您正在使用NetBeans开始您的测试类样板文件，您可能非常了解JUnit的<code class="du jt ju jv jw b">Assert.fail()</code>。因为不管其他什么都无法通过测试，所以你可以把它放在程序执行的一个给定分支上，以便让它更有用。</p><p id="d514" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这类事情，我最常用的例子是在<code class="du jt ju jv jw b">Fraction</code>类中被零除。例如，试图用3/4除以7/2，结果应该是3/14。但是任何被0除的分数都会导致某种运行时异常。</p><p id="1595" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以你可能会这样写:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="fee1" class="kf kg hi jw b fi kh ki l kj kk">    @Test<br/>    public void testDivisionByZero() {<br/>        Fraction dividend = new Fraction(3, 4);<br/>        Fraction zero = new Fraction(0, 1);<br/>        <strong class="jw hj">try</strong> {<br/>            Fraction result = <strong class="jw hj">dividend.divides(zero)</strong>;<br/>            <strong class="jw hj">fail</strong>(dividend.toString() + " divided by 0 gave result "<br/>                                               + result.toString());<br/>        } <strong class="jw hj">catch (ArithmeticException ae)</strong> {<br/>            System.out.println("\"" + ae.getMessage() + "\"");<br/>        } catch (Exception e) {<br/>            <strong class="jw hj">fail</strong>("Expected ArithmeticException but got " +<br/>                                   e.getClass().getName());<br/>    }</span></pre><p id="5b00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以如果<code class="du jt ju jv jw b">divides()</code>给出一个不正确的结果(任何数字<code class="du jt ju jv jw b">Fraction</code>都可以代表)，或者如果它抛出一个不相关的异常(比如<code class="du jt ju jv jw b">PrinterException</code>)，这个测试应该会失败。</p><p id="3d9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是您可能会担心这不是JUnit的惯用用法。所以你可能会求助于谷歌。如果你正在使用IntelliJ，你可能会很快转向谷歌。</p><p id="62b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后Google会告诉你关于<code class="du jt ju jv jw b">@Test</code>注释的<code class="du jt ju jv jw b">expected</code>属性，它将异常的类作为它的参数。被零除测试将被改写如下:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f55e" class="kf kg hi jw b fi kh ki l kj kk">    <strong class="jw hj">@Test(expected = ArithmeticException.class)</strong><br/>    public void testDivisionByZero() {<br/>        Fraction dividend = new Fraction(3, 4);<br/>        Fraction zero = new Fraction(0, 1);<br/>        Fraction result = dividend.divides(zero);<br/>        System.out.println(dividend.toString() +<br/>                 "divided by 0 is said to be " + result.toString());<br/>    }</span></pre><p id="b16d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来干净多了，而且它的工作方式与之前的版本非常相似:如果<code class="du jt ju jv jw b">divides()</code>给出不正确的结果或者抛出除<code class="du jt ju jv jw b">ArithmeticException</code>之外的任何异常，测试就会失败。</p><p id="e675" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另请注意，它会将<code class="du jt ju jv jw b">divides()</code>可能给出的任何错误结果打印到控制台。如果您正在进行测试驱动的开发，您可能有一个<code class="du jt ju jv jw b">divides()</code>存根，它给出的结果是0，而不管实际涉及的数字。</p><p id="3fc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这个版本的测试没有打印出<code class="du jt ju jv jw b">ArithmeticException</code>消息。这是一个小缺陷，除非您有兴趣对消息做出任何断言(比如它不是空的<code class="du jt ju jv jw b">String</code>)。</p><p id="64da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你认为两个或三个不同的例外是有效的呢？例如，在被零除的情况下，我认为<code class="du jt ju jv jw b">IllegalArgumentException</code>会是更好的选择，但是<code class="du jt ju jv jw b">ArithmeticException</code>是可以接受的。</p><p id="0c43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，<code class="du jt ju jv jw b">ArithmeticException</code>提出了一个可以用更多资源解决的问题。例如，如果<code class="du jt ju jv jw b">Math.addExact()</code>溢出了一个<code class="du jt ju jv jw b">int</code>，它抛出<code class="du jt ju jv jw b">ArithmeticException</code>，这表明也许你应该使用一个<code class="du jt ju jv jw b">long</code>或者一个<code class="du jt ju jv jw b">BigInteger</code>来代替一个<code class="du jt ju jv jw b">int</code>。</p><p id="e684" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为，被零除通常是由程序员的愚蠢错误引起的。这种愚蠢的错误通常不需要切换到其他数据类型就可以解决。</p><p id="0cf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TestNG中的<code class="du jt ju jv jw b">@Test</code>注释有一个属性来指定应该发生两个或更多异常中的一个。它还有一个属性来指定异常消息应该是什么。</p><p id="fb7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在JUnit中，如果想要捕获多个有效异常中的任何一个并测试消息，就需要try-catch-fail构造。</p><p id="71e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更罕见的是，您可能希望断言某个异常包装了其他异常。那么您的测试过程需要捕捉包装异常，然后使用<code class="du jt ju jv jw b">getCause()</code>来检查包装异常。</p><p id="c020" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种选择是使用JUnit的<code class="du jt ju jv jw b">ExpectedException</code>类(带有<code class="du jt ju jv jw b">@Rule</code>注释),然后使用<code class="du jt ju jv jw b">expectCause()</code>过程。下面是来自JUnit文档的例子<a class="ae iu" href="https://junit.org/junit4/javadoc/4.12/org/junit/rules/ExpectedException.html" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0b13" class="kf kg hi jw b fi kh ki l kj kk">    @Test<br/>    public void throwsExceptionWhoseCauseCompliesWithMatcher() {<br/>        NullPointerException <strong class="jw hj">expectedCause</strong> = new<br/>                                             NullPointerException();<br/>        <strong class="jw hj">thrown.expectCause(is(expectedCause));</strong><br/>        throw new IllegalArgumentException("What happened?", cause);<br/>    }</span></pre><p id="1433" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您的测试类应该导入<code class="du jt ju jv jw b">org.junit.rules.ExpectedException</code>和<code class="du jt ju jv jw b">org.junit.Rule</code>注释。所以你还需要这个:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="ac2b" class="kf kg hi jw b fi kh ki l kj kk">    @Rule<br/>    public ExpectedException thrown = ExpectedException.none();</span></pre><p id="fd6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是从JUnit文档中逐字复制的，除了增加了一个空格。事实证明，如果您还没有导入<code class="du jt ju jv jw b">org.hamcrest.core.Is</code>，您也需要导入。</p><p id="8b76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是我的被零除测试使用<code class="du jt ju jv jw b">expectCause()</code>的样子:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="047b" class="kf kg hi jw b fi kh ki l kj kk">    @Test<br/>    public void testDivisionByZero() {<br/>        ArithmeticException <strong class="jw hj">expectedCause</strong> = new<br/>                                              ArithmeticException();<br/>        <strong class="jw hj">thrown.expectCause(Is.is(expectedCause));</strong><br/>        Fraction dividend = new Fraction(3, 4);<br/>        Fraction zero = new Fraction(0, 1);<br/>        Fraction result = dividend.divides(zero);<br/>        System.out.println(dividend.toString() +<br/>                " divided by 0 is said to be " + result.toString());<br/>    }</span></pre><p id="56ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不得不写“<code class="du jt ju jv jw b">Is.is</code>”，因为我没有静态导入<code class="du jt ju jv jw b">is()</code>。没什么大不了的。</p><p id="677f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，另一方面，让测试中的<code class="du jt ju jv jw b">ArithmeticException</code>与来自<code class="du jt ju jv jw b">Fraction.divides()</code>的<code class="du jt ju jv jw b">ArithmeticException</code>相匹配变得有点令人头疼。</p><p id="5dc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不同之处在于，在try-catch-fail中，我只会在<code class="du jt ju jv jw b">getCause()</code>上写一个<code class="du jt ju jv jw b">instanceof</code>检查，而Hamcrest匹配器可能希望异常完全相同，具有相同的消息和相同的堆栈跟踪。</p><p id="fafe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">ExpectedException</code>也有<code class="du jt ju jv jw b">expectMessage()</code>，可能比<code class="du jt ju jv jw b">expectCause()</code>对你有用得多。我认为在这种情况下包装异常是不值得的，我更关心异常消息。</p><p id="6198" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，通过静态导入<code class="du jt ju jv jw b">org.hamcrest.core.StringStartsWith.startsWith</code>,我这样重写了测试:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="e47c" class="kf kg hi jw b fi kh ki l kj kk">    @Test<br/>    public void testDivisionByZero() {<br/>        <strong class="jw hj">thrown.expectMessage(startsWith("Dividing 3/4 by 0"));</strong><br/>        Fraction dividend = new Fraction(3, 4);<br/>        Fraction zero = new Fraction(0, 1);<br/>        Fraction result = dividend.divides(zero);<br/>        System.out.println(dividend.toString() +<br/>                " divided by 0 is said to be " + result.toString());<br/>    }</span></pre><p id="44db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先让它失败，然后让它通过要容易得多。</p><p id="acb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为您已经从JUnit JAR中导入了<code class="du jt ju jv jw b">@Test</code>注释和各种断言，并且还引入了Hamcrest(您可以通过查看测试库来使用NetBeans项目窗格验证这一点)，所以您也可以使用<code class="du jt ju jv jw b">ExpectedException</code>。</p><p id="fe8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，与经典的“尝试-捕捉-失败”相比，额外的努力值得吗？这是一个你必须自己回答的问题。</p><p id="d452" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想你会同意我的观点，无论是经典的try-catch-fail还是<code class="du jt ju jv jw b">ExpectedException</code>类，在大多数情况下都比<code class="du jt ju jv jw b">@Test</code>注释的<code class="du jt ju jv jw b">expected</code>属性有用得多。</p><p id="03d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我不建议同时使用<code class="du jt ju jv jw b">expected</code>属性和<code class="du jt ju jv jw b">ExpectedException</code>类。由于相互冲突的期望，这很可能导致误导性的测试失败。</p></div></div>    
</body>
</html>