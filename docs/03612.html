<html>
<head>
<title>Everything you Need to Know About Scikit-Learn’s Latest Update (with Python Implementation)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Scikit-Learn的最新更新(Python实现)您需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/everything-you-need-to-know-about-scikit-learns-latest-update-with-python-implementation-b8ef38f03c98?source=collection_archive---------20-----------------------#2020-02-10">https://medium.com/analytics-vidhya/everything-you-need-to-know-about-scikit-learns-latest-update-with-python-implementation-b8ef38f03c98?source=collection_archive---------20-----------------------#2020-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b75d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="b3fe" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Scikit-learn是一个Python库，当我们<a class="ae kb" href="https://courses.analyticsvidhya.com/courses/applied-machine-learning-beginner-to-professional?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">构建机器学习模型</a>时，我们都不可避免地会求助于它。我已经用这个奇妙的库建立了无数的模型，我相信你们也一定有过。</p><p id="40ce" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">毫无疑问——scikit-learn提供了具有易读语法的便捷工具。在众多流行的Python库当中，scikit-learn与Pandas和NumPy并列第一。这三个Python库为机器学习管道的各个步骤提供了完整的解决方案。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/89337bc365e035771c95de8e0aa6c009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hhaG2j-xm0B_27ql.jpg"/></div></div></figure><p id="786b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我喜欢scikit-learn提供的干净、统一的代码和函数。一旦我们掌握了一种技术，使用其他技术就变得非常容易。优秀的文档是锦上添花，因为它使许多初学者能够在构建机器学习模型方面自给自足。</p><p id="666c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">scikit-learn背后的开发人员推出了一个新版本(v0.22)，其中包含一些重大更新。我将在本文中为您解开这些特性，并通过Python代码展示其中的内容。</p><p id="8e72" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">注:想从头开始学习Python吗？</em> <a class="ae kb" href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank"> <em class="kt">这个免费课程</em> </a> <em class="kt">就是完美的起点！</em></p><h1 id="4714" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="f7d5" class="ku kv hi jf b jg jh jk jl jo kw js kx jw ky ka kz la lb lc bi translated">了解sci kit-了解</li><li id="20a9" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">Scikit-Learn简史</li><li id="0706" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">sci kit-了解v0.22更新(使用Python实现)</li></ol><p id="909a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3.1-堆积分类器和回归器</p><p id="b8be" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3.2 —基于排列的特征重要性</p><p id="6b33" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3.3 —对ROC-AUC的多类支持</p><p id="e186" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3.4 —基于kNN的插补</p><p id="05cb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3.5 —树木修剪</p><h1 id="b6f8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">了解sci kit-了解</h1><p id="0b07" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个库是建立在SciPy(科学Python)库的基础上的，在使用scikit-learn之前需要安装这个库。它在一个许可的简化BSD许可下被许可，并在许多Linux发行版下被分发，鼓励学术和商业使用。</p><p id="2a3c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">总的来说，scikit-learn在幕后使用以下库:</p><ul class=""><li id="2a3a" class="ku kv hi jf b jg kc jk kd jo li js lj jw lk ka ll la lb lc bi translated"><strong class="jf hj"> NumPy </strong> : n维数组封装</li><li id="aa03" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">科学计算库</li><li id="3bfd" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated"><strong class="jf hj"> Matplotlib </strong>:绘图库</li><li id="bff6" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated"><strong class="jf hj"> iPython </strong>:交互式Python(用于Jupyter笔记本支持)</li><li id="1f7d" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">符号数学</li><li id="b8c0" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">熊猫:数据结构、分析和操作</li></ul><p id="80f0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最近，scikit-learn将其功能和软件包重组为六个主要模块:</p><ol class=""><li id="8ab7" class="ku kv hi jf b jg kc jk kd jo li js lj jw lk ka kz la lb lc bi translated"><strong class="jf hj">分类:</strong>识别物体属于哪一类</li><li id="9804" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">回归:</strong>预测与对象相关联的连续值属性</li><li id="e369" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">聚类:</strong>用于对未标记的数据进行分组</li><li id="6335" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">降维:</strong>减少要考虑的随机变量的数量</li><li id="3ee4" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">模型选择:</strong>比较、验证和选择参数和模型</li><li id="1724" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated"><strong class="jf hj">预处理:</strong>特征提取和归一化</li></ol><p id="d74e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">scikit-learn提供了执行所有步骤的功能，从预处理、模型构建、选择正确的模型、超参数调整到解释机器学习模型的框架。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lm"><img src="../Images/9ae00b0eb6c0e87325679ce41b91d1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G9mXFPzNGlYNQ4p_.png"/></div></div></figure><p id="577f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt"> Scikit-learn模块(来源:Scikit-learn主页)</em></p><h1 id="a4b3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">scikit-learn简史</h1><p id="7aa1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Scikit-learn自2007年以sci kit . learn的名字成立以来已经走过了漫长的道路。这里有一个很酷的琐事要告诉你——sci kit-learn是由David Cournapeau发起的谷歌代码之夏项目！</p><p id="8409" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这是由法国计算机科学和自动化研究所的Fabian Pedregosa、Gael Varoquaux、Alexandre Gramfort和Vincent Michel接手并重写的，其首次公开发布发生在2010年。</p><p id="3653" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">从那时起，它添加了许多功能，并经受住了时间的考验，成为跨语言和框架的最受欢迎的开源机器学习库。下面的信息图由我们的团队制作，展示了所有scikit-learn功能及其版本号的简要时间表:</p><p id="e4a8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上面的信息图显示了从2010年到2019年作为实现ML算法的公共库成立以来的特性发布</p><p id="f518" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如今，Scikit-learn正在被全球各地的组织使用，包括Spotify、JP摩根、Booking.com、Evernote等。你可以在这里找到<a class="ae kb" href="https://scikit-learn.org/stable/testimonials/testimonials.html" rel="noopener ugc nofollow" target="_blank">完整的列表和评价</a>我相信这只是这个库受欢迎程度的冰山一角，因为将会有许多大大小小的公司在原型模型的某个阶段使用scikit-learn。</p><p id="da9f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">scikit-learn的最新版本是v0.22，目前有20多个活跃的贡献者。v0.22向其武库中添加了一些优秀的特性，为一些主要的现有痛点提供了解决方案，以及一些在其他库中可用但经常导致包冲突的新特性。</p><p id="8545" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们将在这里详细介绍它们，并深入探讨如何用Python实现它们。</p><h1 id="0075" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">sci kit-了解v0.22更新</h1><p id="cdbd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">除了错误修复和性能改进，这里还有一些包含在scikit-learn最新版本中的新特性。</p><h2 id="af06" class="ln ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">1.堆叠分类器和回归器</h2><p id="07f8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">堆叠是更高级的集成技术之一，由机器学习竞赛获胜者在<a class="ae kb" href="http://datahack.analyticsvidhya.com/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank"> DataHack </a> &amp; Kaggle上流行。我们先试着简单了解一下它的工作原理。</p><blockquote class="mb mc md"><p id="22dd" class="jd je kt jf b jg kc ji jj jk kd jm jn me ke jq jr mf kf ju jv mg kg jy jz ka hb bi translated"><em class="hi">堆叠是一种集成学习技术，它使用来自多个模型(例如，决策树、KNN或SVM)的预测来构建新模型。</em></p></blockquote><p id="25f4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该模型用于对测试集进行预测。下面是我从这篇关于集合学习的<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2018/06/comprehensive-guide-for-ensemble-models/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">优秀文章</a>中摘录的一个简单堆叠集合的分步解释:</p><p id="199a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">1-列车组分为10个部分:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mh"><img src="../Images/c71d8271dd3ca4d4a49955d5ddd97b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*hMgz6giYNdmjlNZy.png"/></div></div></figure><p id="16eb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">2-基础模型(假设决策树)适用于9个部分，并对第10个部分进行预测。对列车组的每个部分都这样做:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mh"><img src="../Images/35b04c74557d35e58b435b37575fba19.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*PDGF-4il-WOc68aN.png"/></div></figure><p id="0294" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">3-基础模型(在这种情况下，决策树)随后适用于整个训练数据集</p><p id="19ce" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">4-使用此模型，对测试集进行预测:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mh"><img src="../Images/80208404c31e862de9db194eb89b1017.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*RNlK3DgF1XC4tR4a.png"/></div></figure><p id="3247" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">5-对另一个基本模型(比如KNN)重复步骤2到4，得到训练集和测试集的另一组预测:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mh"><img src="../Images/fd898a03b0990b70f6ccf55f73f60cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*j3Jq-_kX2NeVb_3c.png"/></div></figure><p id="dfd6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">6-来自训练集的预测用作构建新模型的特征:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mi"><img src="../Images/6435b04b6aba05632a789e3c27a601ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*s61r8LtQC3axlCAx.png"/></div></div></figure><p id="ad0b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">7-此模型用于对测试预测集进行最终预测</p><p id="d89e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt"> mlxtend </em>库提供了一个API来实现Python中的堆栈。现在，sklearn可以用它熟悉的API做同样的事情，这非常直观，你将在下面的演示中看到。根据您的用例，您可以导入<em class="kt">stacking regressor</em>&amp;<em class="kt">stacking classifier</em>:</p><h2 id="7e3f" class="ln ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">2.基于排列的特征重要性</h2><blockquote class="mb mc md"><p id="0446" class="jd je kt jf b jg kc ji jj jk kd jm jn me ke jq jr mf kf ju jv mg kg jy jz ka hb bi translated"><em class="hi">顾名思义，这项技术通过</em>置换<em class="hi">每个</em>特性<em class="hi">并捕捉性能下降，提供了一种为每个特性分配</em>重要性<em class="hi">的方法。</em></p></blockquote><p id="4f34" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">但是这里的置换是什么意思呢？让我们用一个例子来理解这一点。</p><p id="23bd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">假设我们试图预测房价，并且只有两个功能可以使用:</p><ul class=""><li id="42bc" class="ku kv hi jf b jg kc jk kd jo li js lj jw lk ka ll la lb lc bi translated">LotArea —(房屋的平方英尺面积)</li><li id="0a4b" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">YrSold(出售年份)</li></ul><p id="d4b3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">测试数据只有10行，如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mj"><img src="../Images/f7c10d1d4e513d5e31e8d86e88a92979.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*zDd58sAmSXeeupHM.png"/></div></figure><p id="f169" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，我们拟合一个简单的决策树模型，得到R平方值为0.78。我们选择一个特性，比如说LotArea，然后调整它，保持所有其他列不变:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mj"><img src="../Images/2cbb7ab26c70dc840c91de87d39c2c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*GtSrjQNaNxQIChSq.png"/></div></figure><p id="873f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，我们再次计算R平方，结果是0.74。我们取两者之差或比值(0.78/0.74或0.78–0.74)，重复上述步骤，取平均值来表示LotArea特性的重要性。</p><p id="797b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以对所有其他特性执行类似的步骤，以获得每个特性的相对重要性。由于我们在这里使用测试集来评估重要性值，因此只有有助于模型更好地进行概化的要素才会表现得更好。</p><p id="1e9a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">早先，我们不得不从头开始实现它，或者导入ELI5之类的包。现在，<strong class="jf hj"> Sklearn有一个内置的工具来处理基于排列的特征重要性</strong>。让我们深入代码，看看如何将它可视化:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mk"><img src="../Images/1121ea27877655404d3eb19bfa588cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*Y-tKyO21fgKSZ_5B.png"/></div></figure><p id="2268" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">正如你在上面的方框图中所看到的，有3个特性比其他4个相对更重要。您可以在任何模型上尝试这种方法，这使得它成为一种模型不可知的可解释性技术。你可以在这里阅读更多关于这个机器学习可解释性概念<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2019/08/decoding-black-box-step-by-step-guide-interpretable-machine-learning-models-python/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="b207" class="ln ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">3 —对ROC-AUC的多类支持</h2><p id="ad43" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">二元分类的ROC-AUC分数非常有用，尤其是在涉及到<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/03/imbalanced-classification-problem/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">不平衡数据集</a>时。然而，到目前为止还没有对多类分类的支持，我们必须手动编码来做到这一点。为了使用ROC-AUC分数进行多类/多标签分类，我们需要首先对目标进行二值化。</p><p id="2014" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">目前，sklearn支持两种策略来实现这一目标:</p><ul class=""><li id="eda2" class="ku kv hi jf b jg kc jk kd jo li js lj jw lk ka ll la lb lc bi translated">一对一:计算每对类别的成对ROC AUC分数的平均值(average='macro') <image/></li><li id="31de" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">一个与其余:计算每个类别相对于所有其他类别的ROC AUC得分的平均值(average='weighted') <image/></li></ul><pre class="ki kj kk kl fd ml mm mn mo aw mp bi"><span id="41cb" class="ln ig hi mm b fi mq mr l ms mt">from sklearn.datasets import load_iris from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import roc_auc_score X, y = load_iris(return_X_y=True) rf = RandomForestClassifier(random_state=44, max_depth=2) rf.fit(X,y) print(roc_auc_score(y, rf.predict_proba(X), multi_class='ovo'))</span></pre><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mu"><img src="../Images/a7633c10b990876c9e2ed434b9ee8474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bVyIyZ89OuVspLtw.png"/></div></div></figure><p id="4350" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">此外，还有一个新的绘图API，可以非常容易地绘制和比较不同机器学习模型的ROC-AUC曲线。让我们来看一个快速演示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mv"><img src="../Images/97bb3c48c2cdfc95702accc531aa92da.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*_WFTvdo8u3K6zrB7.png"/></div></figure><p id="f0a2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上图中，我们对比了两种不同的机器学习模型，分别是支持向量分类器&amp;随机森林。同样，您可以绘制更多模型的AUC-ROC曲线，并比较它们的性能。</p><h2 id="53f0" class="ln ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">4-基于kNN的插补</h2><p id="35e9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在基于kNN的插补方法中，使用与缺失值的属性最相似的给定数量的属性来插补属性的缺失值。<strong class="jf hj">对缺失值使用kNN背后的假设是，基于其他变量，一个点的值可以由与其最接近的点的值来近似。</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mw"><img src="../Images/2a7c3a3477090105b2271578583194ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*YOhuNxwKEucVVkN-"/></div></figure><p id="48d2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">使用距离函数来确定两个属性的相似性。以下是使用kNN的一些优点:</p><ul class=""><li id="0c22" class="ku kv hi jf b jg kc jk kd jo li js lj jw lk ka ll la lb lc bi translated">k-最近邻可以预测定性和定量属性</li><li id="6706" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">不需要为具有缺失数据的每个属性创建预测模型</li><li id="5078" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ll la lb lc bi translated">考虑数据的相关结构</li></ul><p id="2c8e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">Scikit-learn支持使用欧几里德距离方法的基于kNN的插补。让我们来看一个快速演示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es mx"><img src="../Images/fb231579e53367bae950ac81d2a84e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*iydc4tcohyFmj57-.png"/></div></figure><p id="8999" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你可以在这里全面了解kNN的工作细节<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="4493" class="ln ig hi bd ih lo lp lq il lr ls lt ip jo lu lv it js lw lx ix jw ly lz jb ma bi translated">5 —树木修剪</h2><p id="9a56" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">基本上，修剪是一种我们用来减少<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2016/04/complete-tutorial-tree-based-modeling-scratch-in-python/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">决策树</a>大小的技术，从而避免<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2020/02/underfitting-overfitting-best-fitting-machine-learning/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">过度拟合</a>。这也扩展到其他基于树的算法，如<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2018/12/building-a-random-forest-from-scratch-understanding-real-world-data-products-ml-for-programmers-part-3/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">随机森林</a>和<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2015/09/complete-guide-boosting-methods/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank">梯度提升</a>。这些基于树的方法提供了参数，如<code class="du my mz na mm b">min_samples_leaf</code>和，以防止树过度拟合。</p><p id="fc58" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">修剪为控制树的大小提供了另一种选择。<a class="ae kb" href="https://www.analyticsvidhya.com/blog/2017/06/which-algorithm-takes-the-crown-light-gbm-vs-xgboost/?utm_source=blog&amp;utm_medium=everything-you-should-know-scikit-learn" rel="noopener ugc nofollow" target="_blank"> XGBoost &amp; LightGBM </a>将修剪集成到了他们的实现中。然而，Scikit-learn中早就应该有一个手动修剪树的特性了(R已经提供了一个类似的工具作为<em class="kt"> rpart </em>包的一部分)。</p><p id="d298" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在其最新版本中，Scikit-learn提供了这种修剪功能，使得一旦树被构建，在大多数基于树的估计器中控制过度拟合成为可能。关于如何和为什么修剪的细节，你可以阅读Sunil的这篇优秀的关于基于树的方法的教程。现在让我们来看一个快速演示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nb"><img src="../Images/2ceaa5f79f139e9fafa66fb69ab2e3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VoDAUAHGiTnw8wBv.png"/></div></div></figure><h1 id="7dd1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="38d5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">scikit-learn包是构建机器学习模型的终极工具库。这是第一个专注于机器学习的图书馆，所有新人都依赖它来指导他们完成最初的学习过程。即使作为一个老手，我也经常发现自己用它来快速测试我脑海中的一个假设或解决方案。</p><p id="b99d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">正如我们刚刚看到的，最新版本肯定有一些重大升级。使用我在本文中提供的基础进行探索和试验绝对是值得的。</p><p id="9cec" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你试过最新的版本了吗？请在下面的评论区与社区分享您的想法。</p><p id="97b9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你也可以在分析Vidhya的Android应用上阅读这篇文章</p></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="b485" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kt">原载于2020年2月10日</em><a class="ae kb" href="https://www.analyticsvidhya.com/blog/2020/02/everything-you-should-know-scikit-learn/" rel="noopener ugc nofollow" target="_blank"><em class="kt">【https://www.analyticsvidhya.com】</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>