<html>
<head>
<title>Pointers and Dynamic Memory in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的指针和动态内存</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pointers-and-dynamic-memory-in-c-50cf0a0ce70b?source=collection_archive---------15-----------------------#2020-08-28">https://medium.com/analytics-vidhya/pointers-and-dynamic-memory-in-c-50cf0a0ce70b?source=collection_archive---------15-----------------------#2020-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="ac24" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">指针和动态内存</h1><p id="c84d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当你不知道编译时的内存需求时，动态内存是很有用的。</p><h2 id="2ac6" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">堆栈和堆</h2><p id="7f79" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">内存分为<em class="kp">堆栈</em>和<em class="kp">堆</em>或<em class="kp">空闲存储</em>。堆栈内存是自动管理的，而堆内存不是。<em class="kp">激活记录</em>是堆栈上用于实现功能的内存块。比如当<code class="du kq kr ks kt b">main</code>调用<code class="du kq kr ks kt b">foo</code>时，<code class="du kq kr ks kt b">foo</code>的激活记录在栈顶。一旦<code class="du kq kr ks kt b">foo</code>返回，<code class="du kq kr ks kt b">foo</code>的激活记录被标记为解除分配，另一个函数调用可以使用那个空间。从<code class="du kq kr ks kt b">main</code>传递到<code class="du kq kr ks kt b">foo</code>的任何参数都被复制到<code class="du kq kr ks kt b">foo</code>的激活记录中。下面是维基百科中激活记录的图示:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ku"><img src="../Images/1fcb1441d106d49c282d6f39869fc286.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*0NoK9EVdvyV6o7MA.png"/></div></figure><p id="df72" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">在堆上分配的内存独立于函数调用而存在。必须确保释放堆上分配的内存。一些语言如C#和Python有垃圾收集(GC)功能，但C++没有。然而，“智能指针”有助于自动释放内存。要在堆上显式分配内存:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="7c81" class="kb ig hi kt b fi ll lm l ln lo">int* pointerToInt;</span></pre><p id="b784" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated"><code class="du kq kr ks kt b">pointerToInt</code>当前是一个未初始化的指针。使用未初始化的指针可能会导致程序崩溃。应该总是初始化指针。它们可以设置为空(使用<code class="du kq kr ks kt b">nullptr</code>)，并对照空进行检查。<code class="du kq kr ks kt b">nullptr</code>用于布尔表达式时转换为false。示例:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="af47" class="kb ig hi kt b fi ll lm l ln lo">if(!pointerToInt)<br/>{<br/>    //execute code that handles null pointer case<br/>}</span></pre><p id="2a7f" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">new运算符用于分配内存。</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="df3a" class="kb ig hi kt b fi ll lm l ln lo">pointerToInt = new int;</span></pre><p id="3500" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">要访问新分配的值，必须<em class="kp">解引用</em>指针，或者跟随指针的地址到内存。例如，可以按如下方式设置上面指针的值:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="d063" class="kb ig hi kt b fi ll lm l ln lo">*pointerToInt = 42;</span></pre><p id="f2b6" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">要释放内存，必须使用<code class="du kq kr ks kt b">delete</code>操作符，最佳做法是将指针设置为<code class="du kq kr ks kt b">nullptr</code>:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="6281" class="kb ig hi kt b fi ll lm l ln lo">delete pointerToInt;<br/>pointerToInt = nullptr;</span></pre><p id="bf35" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">也可以声明和初始化指向堆栈上变量的指针。要获得指向变量的指针，使用操作符的<code class="du kq kr ks kt b">&amp;</code>或<em class="kp">地址:</em></p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="0754" class="kb ig hi kt b fi ll lm l ln lo">double k = 42.0<br/>double* kPtr = &amp;k;</span></pre><p id="c2e3" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">通常，要通过指针访问结构的字段，必须执行以下操作:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="c59e" class="kb ig hi kt b fi ll lm l ln lo">Person * person = getPerson();<br/>double address = (*person).address;</span></pre><p id="2d3f" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated"><code class="du kq kr ks kt b">(*ptr).</code>符号有一个简写，就是箭头符号。相同的代码可以编写如下:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="232b" class="kb ig hi kt b fi ll lm l ln lo">Person *person = getPerson();<br/>double address = person-&gt;address;</span></pre><p id="d549" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">为了避免使用无效指针，可以利用短路逻辑:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="0745" class="kb ig hi kt b fi ll lm l ln lo">bool hasValidAddress = (person &amp;&amp; person-&gt;address != "")</span></pre><h2 id="2cfb" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">动态分配的数组</h2><p id="8972" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要在堆上分配数组，请使用<code class="du kq kr ks kt b">new[]</code>操作符，如下所示:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="33e5" class="kb ig hi kt b fi ll lm l ln lo">int arySize = 10;<br/>int* ptrToDynamicAry = new int[arySize];</span></pre><p id="917e" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">下图显示了执行前面的代码后，程序员的心理记忆模型:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es ku"><img src="../Images/3bf72742555cf4c0f00bf84c581548ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*60-dglpDkv7M6pJr.png"/></div></figure><p id="ef2f" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">当使用完数组时，必须从堆中释放数组。删除操作符的“数组”版本应该用于此:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="ea21" class="kb ig hi kt b fi ll lm l ln lo">delete[] ptrToDynamicAry<br/>ptrToDynamicAry = nullptr;</span></pre><h2 id="fa50" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">智能指针</h2><p id="a278" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了避免内存泄漏，可以使用智能指针。下面两个指针<code class="du kq kr ks kt b">std::unique_ptr</code>和<code class="du kq kr ks kt b">std::shared_ptr</code>是最常用的，在<code class="du kq kr ks kt b">&lt;memory&gt;</code>头文件中有定义。<code class="du kq kr ks kt b">unique_ptr</code>类似于原始指针，但在超出范围或被删除后会自动释放内存。<code class="du kq kr ks kt b">unique_ptr</code>是它所指向的对象的唯一所有者。即使抛出异常，唯一指针指向的内存也会被释放。<code class="du kq kr ks kt b">unique_ptr</code>的语法如下:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="6437" class="kb ig hi kt b fi ll lm l ln lo">auto person = std::make_unique&lt;Person&gt;();</span></pre><p id="e5b2" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">在C++14之前，人们必须做以下事情:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="b06f" class="kb ig hi kt b fi ll lm l ln lo">std::unique_ptr&lt;Person&gt; person(new Person);</span></pre><p id="12f1" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated"><code class="du kq kr ks kt b">unique_ptr</code>可以像普通指针一样使用，因为它重载了箭头操作符(<code class="du kq kr ks kt b">-&gt;</code>)和索引操作符(<code class="du kq kr ks kt b">[]</code>)。</p><p id="77cf" class="pw-post-body-paragraph jd je hi jf b jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka hb bi translated">使用<code class="du kq kr ks kt b">unique_ptr</code>时，动态数组的前一个示例转换为以下内容:</p><pre class="kv kw kx ky fd lh kt li lj aw lk bi"><span id="fea1" class="kb ig hi kt b fi ll lm l ln lo">auto myAry = std::make_unique&lt;int&gt;(10);<br/>cout &lt;&lt; "Integer at position 5 is " &lt;&lt; myAry[4] &lt;&lt; endl;</span></pre><h1 id="8ef4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考资料:</h1><p id="1bb8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">m .格雷瓜尔(2018)。<em class="kp">专业C++ </em>。印第安纳州，约翰·威利的儿子们。</p><div class="lp lq ez fb lr ls"><a href="https://codingadventures1.blogspot.com/2020/01/c-tour-part-ii.html" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">C++教程第二部分</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">当你不知道编译时的内存需求时，动态内存是很有用的。内存分为堆栈…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">codingadventures1.blogspot.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg la ls"/></div></div></a></div></div></div>    
</body>
</html>