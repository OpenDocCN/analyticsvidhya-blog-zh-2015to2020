<html>
<head>
<title>[Paper Breakdown] Zero-shot Sequence Labeling: Transferring Knowledge from Sentences to Tokens (Rei and Søgaard, 2018 NAACL)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">【论文分解】零炮序列标注:从句子到记号的知识转移(Rei和gaard，2018 NAACL)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/paper-zero-shot-sequence-labeling-transferring-knowledge-from-sentences-to-tokens-rei-and-826f3ce78b42?source=collection_archive---------18-----------------------#2020-01-26">https://medium.com/analytics-vidhya/paper-zero-shot-sequence-labeling-transferring-knowledge-from-sentences-to-tokens-rei-and-826f3ce78b42?source=collection_archive---------18-----------------------#2020-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4b83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.aclweb.org/anthology/N18-1027/" rel="noopener ugc nofollow" target="_blank">链接到纸张。</a></p><p id="8264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近在我的实验室做一个项目，是关于使用NLP技术的隐喻检测。这被证明是一个非同小可的问题，而且对我来说是一个令人惊讶的活跃的研究领域。</p><p id="10c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我将看看由Marek Rei先生和Anders Sø gaard撰写并在NAACL 2018上发表的论文<em class="je">零镜头序列标签:将知识从句子转移到标记</em>。我不会包括本质上的细节，而是将重点放在方法上。你可以在原始文件中检查实施细节的结果。</p><p id="2cb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定阅读这篇论文的原因是因为我和我的团队目前正试图将我们的任务形式化为一个零射击学习任务。这篇论文的任务设置和我们的100%不一致，但读一读也无妨。</p><h1 id="9450" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">TL；速度三角形定位法(dead reckoning)</h1><blockquote class="kd ke kf"><p id="4300" class="if ig je ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated">作者试图在文本的标记层次上进行零元学习。他们所做的是首先训练一个模型来学习如何对<em class="hi">句子</em>进行分类，然后使用像注意力这样的机制来提取令牌级别的信息。这个问题被公式化为一个零射击学习任务，因为没有预先给定用于训练的标记的标签。</p></blockquote><h1 id="57f6" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">1.介绍</h1><p id="99e5" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">如以上概述中所述，本文解决了当令牌没有标签时<strong class="ih hj"> <em class="je">序列标签</em> </strong>的问题。对于任何不熟悉的人来说，序列标记基本上是标记序列中的标记的任务(例如<a class="ae jd" href="https://en.wikipedia.org/wiki/Part-of-speech_tagging" rel="noopener ugc nofollow" target="_blank">位置标记</a>)。</p><p id="1346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如论文中所述:<strong class="ih hj">“不是直接训练模型来预测每个标记的标签，而是使用句子级目标来优化模型。”</strong></p><p id="72b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者承认，这种方法将无法比直接在令牌上训练的监督模型执行得更好。然而，本文的动机是，它为在令牌级信息不可用或难以处理的情况下利用文本数据开辟了可能性。</p><h1 id="0f74" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">2.网络体系结构</h1><h2 id="ac60" class="ko jg hi bd jh kp kq kr jl ks kt ku jp iq kv kw jt iu kx ky jx iy kz la kb lb bi translated">概观</h2><p id="49e2" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">基本架构如下:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/7c498040ddce056fdf74d61ca1e10765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNq2j6stXm7bxFCpOyqVLg.png"/></div></div></figure><p id="276d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总流程是:</p><ol class=""><li id="9987" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">得到每个单词的单词嵌入表示(<em class="je"> w_i)。</em></li><li id="36ae" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">通过双向LSTM ( <em class="je"> h_i </em>)运行字嵌入<em class="je"> w_i </em>，并连接前向和后向隐藏状态向量。</li><li id="a219" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">通过线性投影运行隐藏状态向量的串联，然后是双曲正切激活函数，以获得表示<em class="je"> e_i </em>。这是通过一个线性投影运行一次，以获得<em class="je">\波浪号{e_i} </em>。</li><li id="5180" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">在机器翻译等更典型的情况下，注意力值<em class="je"> a_i </em>是通过softmax归一化对<em class="je"> \tilde{e_i} </em>的值进行归一化得到的。这阻止了长句子拥有“不公平”的优势，因为长句子总是有更大的量级。然而，这种形式的标准化可能不适合于这种设置，因为它假设有一个具有正确标签的标记，而序列标签不是这种情况。相反，作者首先通过逻辑sigmoid函数运行<em class="je"> \tilde{e_i} </em>，并在没有指数函数的情况下执行类似softmax的归一化。</li><li id="bda7" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">在获得关注值<em class="je"> a_i </em>之后，它们被用于对级联的隐藏向量表示<em class="je"> c </em>进行加权。</li><li id="0d9a" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">然后通过线性投影运行<em class="je"> c </em>以获得句子表示<em class="je"> d </em>。</li><li id="a75a" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><em class="je"> d </em>通过最终线性投影，并通过逻辑sigmoid函数。如果其输出<em class="je"> y </em>高于阈值(在本例中为0.5)，则该句子被标记为“正”</li></ol><p id="b77f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我刚刚列出的等式:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es mc"><img src="../Images/b370601e7cd421f69a65373463baaa82.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*4JOLZcsCdu_XvMtOhS_0vQ.png"/></div></figure><h2 id="4a75" class="ko jg hi bd jh kp kq kr jl ks kt ku jp iq kv kw jt iu kx ky jx iy kz la kb lb bi translated">损失函数</h2><p id="3556" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">作者提出损失函数的方法很有创意。总共有三个损失函数。</p><p id="08fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个损失函数只在句子层面起作用。我们的模型能够正确分类句子的标签吗？</p><p id="f281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个和第三个损失函数处理令牌级信息，比第一个稍微复杂一些。根据作者的说法，他们使用了几个约束条件:</p><ol class=""><li id="4b03" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">"句子中只有一些，而不是所有的标记可以有一个肯定的标签。"</li><li id="b925" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">“只有当整个句子是肯定的时，一个句子中才有肯定的标记。</li></ol><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es md"><img src="../Images/0881d0ffa6ae38025e2efcedec0ba7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*EjvGejTU1ymw0LH9LMeb9Q.png"/></div></figure><p id="36b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(根据作者的说法，这些约束是基于启发式的，而不是严格的证明)。</p><p id="d09b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住<em class="je">\波浪线{a_i} </em>是<strong class="ih hj">未标准化的</strong>注意力权重。第二个损失函数将这些权重中的最小权重推至接近0，这基本上确保了不是所有的标记都将具有肯定的标签，并且第三个损失函数鼓励模型将大的注意力权重分配给肯定句子的最大标记(如果<em class="je"> \tilde{y} </em>为0，则最大权重也将为0)。</p><p id="bb83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终损失函数为:</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es me"><img src="../Images/5b3c9ee103a1376ef2cd614fb4f8d2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*kbSi2HTWxOK7LU8AFBhaUQ.png"/></div></figure><p id="9100" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中γ基本上是控制那些辅助损失函数有多重要的超参数。</p><p id="75ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者还用其他方法进行了实验，包括基于梯度的方法和简单的基于频率的朴素方法。他们的方法优于其他方法。</p><h1 id="7070" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">结束语</h1><p id="295f" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">总的来说，这篇论文写得很好。作者本可以包括更多关于他们如何得出损失函数的细节，因为这似乎是他们的一个重要贡献，但总的来说，这是非常有益的。</p><p id="fbb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有想到序列标签设置中的零射击学习会以这种方式公式化，所以创造力+1。</p><p id="d283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也是我决定在媒体上做分析的第一篇论文。我一直告诉自己，我想这样做，因为这是我保持写作和学习的完美方式。我会努力保持下去，但我肯定需要保持它更短。</p></div></div>    
</body>
</html>