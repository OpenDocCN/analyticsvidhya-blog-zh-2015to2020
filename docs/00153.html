<html>
<head>
<title>Getting Started with TensorFlow the Easy Way (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以最简单的方式开始使用TensorFlow(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-tensorflow-the-easy-way-part-2-30e83830bd25?source=collection_archive---------0-----------------------#2018-10-21">https://medium.com/analytics-vidhya/getting-started-with-tensorflow-the-easy-way-part-2-30e83830bd25?source=collection_archive---------0-----------------------#2018-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="02d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这是关于如何开始使用TensorFlow的系列文章的第2部分——“tensor flow中的变量和占位符”。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl jj"><img src="../Images/275a07d42a9fa357cfe6262ea543d906.png" data-original-src="https://miro.medium.com/v2/format:webp/0*miEaj0tWdAIittAF.png"/></div></figure><p id="d642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着深度学习框架到处涌现，大多数数据科学家和研究人员都面临着不可避免的困境——哪个框架最适合他们的项目？</p><p id="9247" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TensorFlow可以说是最受欢迎的生产深度学习库，拥有巨大的社区支持，GitHub知识库中有112，180颗星星，所有这些都发生在3年内。</p><p id="9d61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是过去5年TensorFlow与Pytorch的Google趋势:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/9028c6bc44d67beb99c0fa1b76d2f698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fm9tgzws-Tu0LYiXxK1HcQ.png"/></div></div></figure><p id="3acd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，由于TensorFlow的学习曲线很陡，数据科学社区对它的早期采用率往往很低。这一系列文章的目的是让你更容易学习和使用TensorFlow。</p><p id="d63a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文(系列文章的第2部分)<em class="jd">，</em>中，我们将涵盖变量和占位符的重要概念，它们是模型构建的基础。到本文结束时，您将能够使用变量和占位符来声明和运行TensorFlow会话。</p><p id="21d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们真正开始讨论这些术语之前，让我们快速回顾一下我们在上一篇文章中所涉及的内容:</p><ol class=""><li id="7014" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">TensorFlow在计算图形上工作，计算图形是一组节点</li><li id="e928" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">这些节点共同构成了图形的操作流程</li><li id="bc3e" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">每个节点都是具有一些输入的操作，在执行后提供一个输出</li></ol><p id="c893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我鼓励您参考<a class="ae kf" rel="noopener" href="/analytics-vidhya/series-learning-tensorflow-the-easy-way-dcc5be834d74"> <em class="jd">第1部分:Tensorflow安装和设置、语法和图表</em> </a> <em class="jd"> </em>以获得详细的解释。</p><h1 id="2d61" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">变量</h1><p id="3e6d" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">当我们训练一个模型时，通常使用scikit-learn，当我们调用<code class="du lj lk ll lm b">model.fit()</code>时，权重和偏差得到优化。但是在TensorFlow中，你需要为自己建立整个机器学习模型。</p><p id="f59a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<strong class="ih hj">变量</strong>发挥作用的地方。</p><p id="80c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们用于保存在模型训练过程中优化的权重和偏差的值。但是，这个过程不同于传统的变量声明。</p><p id="56e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在TensorFlow中，在会话中使用变量之前，必须初始化所有变量。</p><p id="a808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们实现一个例子来更好地理解这一点。首先导入TensorFlow库，然后声明两个变量:</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="dc63" class="lr kh hi lm b fi ls lt l lu lv">import tensorflow as tf</span><span id="4ef2" class="lr kh hi lm b fi lw lt l lu lv">first_var = tf.random_uniform((4,4),0,1)<br/>second_var = tf.ones((4,4))<br/>print(first_var)</span><span id="8df7" class="lr kh hi lm b fi lw lt l lu lv">Out []: Tensor("random_uniform:0", shape=(4, 4), dtype=float32)</span></pre><p id="a8e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变量<code class="du lj lk ll lm b">first_var</code>仍然是一个张量对象，而不是形状<code class="du lj lk ll lm b">(4,4)</code>的统一阵列。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="11d3" class="lr kh hi lm b fi ls lt l lu lv"># Always initialize before running a session<br/>init = tf.global_variables_initializer()</span></pre><p id="2d6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，这个代码块非常重要，但在TensorFlow中设计网络时也很容易忘记。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="1fcf" class="lr kh hi lm b fi ls lt l lu lv">with tf.Session() as sess:<br/>    init.run()<br/>    print(first_var.eval())</span><span id="990c" class="lr kh hi lm b fi lw lt l lu lv">Out []: [[0.6423092  0.5614004  0.53549814 0.5330738 ]<br/>        [0.3521489  0.07537675 0.3189149  0.38606727]<br/>        [0.29591668 0.30730367 0.1751138  0.741724  ]<br/>        [0.48258722 0.33091295 0.5782666  0.7447115 ]]</span></pre><p id="3d17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">耶！你的第一个变量刚刚被赋值。</p><h1 id="728d" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">占位符</h1><p id="537f" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">顾名思义，它们是用来固定东西的。在我们的例子中，它们最初是空的，用于向模型提供训练样本。您需要在声明它们时设置数据类型。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="2c31" class="lr kh hi lm b fi ls lt l lu lv">integer_placeholder = tf.placeholder(tf.int32)<br/>float_placeholder = tf.placeholder(tf.float64)</span></pre><p id="4166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常占位符的形状是<code class="du lj lk ll lm b">(None, no_of_features)</code>。如果你第一次看到它，可能会感到困惑。但是<code class="du lj lk ll lm b">None</code>实际上是有意义的，因为它是我们传递给模型的训练实例数量的维度值。我们的模型应该采用任意数量的实例进行训练，这不是一个固定的值。</p><p id="4b69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面,<code class="du lj lk ll lm b">no_of_features</code>是一个已知的值，因此应该相应地表示您的模型。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="4a5a" class="lr kh hi lm b fi ls lt l lu lv">train_data = tf.placeholder(tf.float32, shape=(None,5))</span></pre><p id="82bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，train_data的占位符形状也应该与<code class="du lj lk ll lm b">test_data</code>相同。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="7fa6" class="lr kh hi lm b fi ls lt l lu lv">test_data = tf.placeholder(tf.float32, shape=(None,5))</span></pre><h2 id="38ff" class="lr kh hi bd ki lx ly lz km ma mb mc kq iq md me ku iu mf mg ky iy mh mi lc mj bi translated">选择什么数据类型？</h2><p id="9175" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">决定数据类型至关重要。它会影响训练时间和模型的准确性。通常，<code class="du lj lk ll lm b">float32</code>对于性能和准确性来说都是一种安全的数据类型。当准确度和精确度至关重要时，我更喜欢<code class="du lj lk ll lm b">float64</code>。</p><h1 id="98a7" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">实现图形和占位符</h1><p id="2998" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">让我们通过整合图形和占位符的概念来实现一个虚拟网络。我们将在本系列的下一部分看到变量是如何发挥重要作用的。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="6996" class="lr kh hi lm b fi ls lt l lu lv">import tensorflow as tf<br/>import numpy as np<br/>np.random.seed(13)<br/>tf.set_random_seed(13)</span></pre><p id="60d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要重现相同的输出，那么请将TensorFlow和numpy的随机种子都设置为<code class="du lj lk ll lm b">13</code>。</p><p id="b63e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们制作两个numpy变量，作为我们的示例案例的虚拟数据和权重:</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="ccbf" class="lr kh hi lm b fi ls lt l lu lv">random_data = np.random.uniform(0,100,(5,5))<br/>random_weights = np.random.uniform(0,100,(5,1))</span><span id="9bf1" class="lr kh hi lm b fi lw lt l lu lv">print(random_data)</span><span id="b2de" class="lr kh hi lm b fi lw lt l lu lv">[[77.77024106 23.754122   82.42785327 96.5749198  97.26011139]<br/> [45.34492474 60.90424628 77.55265146 64.16133448 72.20182295]<br/> [ 3.50365241 29.84494709  5.85124919 85.70609426 37.28540279]<br/> [67.98479516 25.62799493 34.75812152  0.94127701 35.83337827]<br/> [94.90941817 21.78990091 31.93913664 91.7772386   3.19036664]]</span><span id="2ce3" class="lr kh hi lm b fi lw lt l lu lv">print(random_weights)</span><span id="d2f8" class="lr kh hi lm b fi lw lt l lu lv">[[ 6.5084537 ]<br/> [62.98289991]<br/> [87.38134433]<br/> [ 0.87157323]<br/> [74.6577237 ]]</span></pre><p id="64b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<code class="du lj lk ll lm b">print</code>起作用了，因为它们是numpy而不是张量对象类型。在传统的机器学习情况下，权重是随机分配的，并通过优化器进行优化，同时最小化关于成本函数的误差。我们将在下一篇文章中讨论这个问题。</p><p id="f70d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们编写占位符和操作代码，以便在运行会话时保存数据。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="88b4" class="lr kh hi lm b fi ls lt l lu lv">a = tf.placeholder(tf.float32)<br/>b = tf.placeholder(tf.float32)</span><span id="3e93" class="lr kh hi lm b fi lw lt l lu lv">add_operation = a + b <br/>multiply_operation = a * b </span></pre><p id="1a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，TensorFlow只用+、-、*和/运算符就能处理复杂的数组运算。</p><pre class="je jf jg jh fd ln lm lo lp aw lq bi"><span id="dc66" class="lr kh hi lm b fi ls lt l lu lv">with tf.Session() as sess:<br/>    add_result = sess.run(add_operation,<br/>                          feed_dict= {a:random_data,<br/>                                      b:random_weights})<br/>    mult_result = sess.run(multiply_operation,<br/>                           feed_dict= {a:random_data,<br/>                                       b:random_weights})</span><span id="5015" class="lr kh hi lm b fi lw lt l lu lv">    print(add_result)<br/>    print('\n')    <br/>    print(mult_result.round())</span><span id="c72a" class="lr kh hi lm b fi lw lt l lu lv">[[ 84.278694   30.262575   88.93631   103.083374  103.76856  ]<br/> [108.32782   123.887146  140.53555   127.144226  135.18472  ]<br/> [ 90.885     117.226295   93.2326    173.08743   124.66675  ]<br/> [ 68.85637    26.499567   35.629696    1.8128502  36.704952 ]<br/> [169.56714    96.447624  106.59686   166.43497    77.84809  ]]<br/><br/><br/>[[5.060e+02 1.550e+02 5.360e+02 6.290e+02 6.330e+02]<br/> [2.856e+03 3.836e+03 4.884e+03 4.041e+03 4.547e+03]<br/> [3.060e+02 2.608e+03 5.110e+02 7.489e+03 3.258e+03]<br/> [5.900e+01 2.200e+01 3.000e+01 1.000e+00 3.100e+01]<br/> [7.086e+03 1.627e+03 2.385e+03 6.852e+03 2.380e+02]]</span></pre><p id="c7f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面看到的，加法和乘法操作已经成功执行。在这个实现中，没有使用变量，因为我们没有实现任何成本函数和优化。</p><p id="1d49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇文章中，我们将介绍如何在vanilla TensorFlow中编写完整的线性回归示例。</p><p id="867d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您对TensorFlow中的上述代码有任何疑问，请随时联系我。确保您关注<a class="ae kf" href="https://medium.com/analytics-vidhya" rel="noopener"> Analytics Vidhya </a>并关注本系列的后续部分。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="29dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第1部分:<a class="ae kf" rel="noopener" href="/analytics-vidhya/series-learning-tensorflow-the-easy-way-dcc5be834d74"> Tensorflow安装和设置、语法和图形</a></p><p id="bd3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">第二部分:</em><a class="ae kf" rel="noopener" href="/analytics-vidhya/getting-started-with-tensorflow-the-easy-way-part-2-30e83830bd25"><em class="jd">tensor flow中的变量和占位符</em> </a></p><p id="1ce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">第3部分:在Tensorflow中实现回归示例(下一步)</em></p><p id="e70c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">第4部分:在Tensorflow中实现分类(即将推出..)</em></p></div></div>    
</body>
</html>