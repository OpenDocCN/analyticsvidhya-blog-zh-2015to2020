<html>
<head>
<title>Machine Learning 101 : Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习101:分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/chapter-1-machine-learning-101-d7e0f470e7ca?source=collection_archive---------25-----------------------#2020-05-02">https://medium.com/analytics-vidhya/chapter-1-machine-learning-101-d7e0f470e7ca?source=collection_archive---------25-----------------------#2020-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在网上找到很多关于机器学习的定义，太棒了。但是要从根本上理解它，你需要有一个概念:</p><ul class=""><li id="a5a4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">ML可以解决的问题类型</li><li id="cf1e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">机器学习中构建模型的砖块</li><li id="f994" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">探索一些关键算法和概念，如欠拟合和过拟合、正则化和交叉验证(我们将在下面看到)</li><li id="316f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如何选择正确的算法、调整参数和验证模型</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/c58f3734a6c108ab125011f35b287da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KM1AN9Bh3t5W76Aj"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">安妮·斯普拉特在<a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="14f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这一章，让我们使用电信行业的客户流失数据。这个数据文件叫做“Orange_Telecom_Churn_Data.csv ”,在谷歌上很容易找到。数据帧如下所示:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ki"><img src="../Images/8c721660f32120e161c2043e97a90b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hT6_UzAqeyS4ZWVGPHM6Qw.png"/></div></div></figure><p id="6107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于初学者，我想使用一个非常基本和简单的技术，因为这个例子比iris dataframe有更多的行(5000对150)，结果会更准确。</p><p id="ab3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习有两大类:</p><ul class=""><li id="14e4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">监督</strong>:数据点有一个已知的结果</li><li id="4ebd" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">无监督的:数据指向未知的结果</li></ul><p id="f3a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们所有的专栏都有很好的标签，我们现在将坚持监督学习，它也可以分为两类:</p><ul class=""><li id="244b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">分类</strong>:其中结果是一个类别</li><li id="3dc1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">回归</strong>:其中结果是连续的(每说的数值)</li></ul><p id="dd64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们在本例中想要做的事情的简要概述:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kj"><img src="../Images/4bb98793d28486b82d05c485389f5aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmMcH0pkdVEBGKcnnuxHKw.png"/></div></div></figure><p id="f21a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从制作一个模型开始，向它提供一些数据，并预测一个目标值。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kk"><img src="../Images/55787054075ab4be8c2d339c07e3ee3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3qBNoIfR4Q3VTGizdLtzQ.png"/></div></div></figure><p id="1613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后给我们的模型一些数据来预测适当的结果。</p><p id="315e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —预处理— </strong></p><p id="7b2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这实际上是大部分奇迹发生的部分，对于我们的例子，让<strong class="ih hj">预测</strong>流失率<a class="ae kh" href="https://blog.comviva.com/efficient-ways-for-customer-churn-analysis-in-telecom-sector/" rel="noopener ugc nofollow" target="_blank"/>(如果一个客户停止订购某个电信业务)。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kl"><img src="../Images/a03e31c5f0d752bf20b61764e127fe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*w-AW0clqUWplVnKd8Dk6UA.png"/></div></div></figure><p id="6fea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">州、区号和电话号码是任意的，只会混淆我们的模型，所以我们使用。下降法，这是非常重要的<strong class="ih hj"/>在开始训练前发现这种列，以获得最佳效果。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es km"><img src="../Images/f54ce282b5417d32d2538434154022c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx1OC2FyiDRHHD6S0nTYfg.png"/></div></div></figure><p id="0a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，使用<a class="ae kh" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelBinarizer.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">label binarizer</strong></a><strong class="ih hj"/>库，我们将<strong class="ih hj">真</strong>和<strong class="ih hj">假</strong>数据转换为浮点数(0代表假，1代表真)<br/> <a class="ae kh" href="https://stackoverflow.com/questions/29086398/sklearn-turning-off-warnings/32389270" rel="noopener ugc nofollow" target="_blank"> filterwarnings </a>只是一个小细节，以忽略该操作可能引发的警告，从而获得干净的输出。</p><p id="0e22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kh" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">最小最大缩放器</strong> </a>，将所有数据点缩放至0到1之间的值。(更具体地说，它<strong class="ih hj">将数据</strong>标准化。标准化对于具有负值的数据很有用。它把数据排列成一个<a class="ae kh" href="https://en.wikipedia.org/wiki/Normal_distribution#Standard_normal_distribution" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a><strong class="ih hj">的标准正态分布。</strong>分类比<strong class="ih hj"> </strong>回归<strong class="ih hj">更有用。)</strong></p><p id="86bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望我们的学习尽可能的快速和精确，而不需要花费太多的时间和内存，我将使用<a class="ae kh" href="https://www.kaggle.com/arjanso/reducing-dataframe-memory-size-by-65?fbclid=IwAR1joj1puRpqAcPHCWfoieBitZRR7Oe6C5Hyr0dx6eKgvRyFC9R1QShrkVU" rel="noopener ugc nofollow" target="_blank">这个函数</a>，它将内存使用大幅减少了43%。它的简单功能是:</p><ol class=""><li id="83e2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kn jj jk jl bi translated">确定该列是否为数字</li><li id="037e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc kn jj jk jl bi translated">确定该列是否可以用整数表示</li><li id="009e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc kn jj jk jl bi translated">找出最小值和最大值</li><li id="c0ea" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc kn jj jk jl bi translated">确定并应用能够适应值范围的最小数据类型</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ko"><img src="../Images/358b4f7be1a1665fcb4f31bf611acf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BN5VteyL70tKa0CqoRhZOg.png"/></div></div></figure><p id="a23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在预处理部分，我们要做的最后一件事是分离我们想要训练模型的列(我们称之为<em class="kp"> X_data </em>)和我们想要预测的列(<em class="kp"> Y_data </em>)</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kq"><img src="../Images/d671db4f9766537d0c248c88aae24a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*mrOObAs6Zn5A9COl-1ajYw.png"/></div></figure><p id="6643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —培训— </strong></p><p id="2d38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个例子，我们需要将最后一列分为<em class="kp">真</em>或<em class="kp">假</em>类别(<strong class="ih hj">搅动</strong>或<strong class="ih hj">未搅动)。</strong>允许我们这样做的一个好算法将是<a class="ae kh" href="https://www.saedsayad.com/k_nearest_neighbors.htm" rel="noopener ugc nofollow" target="_blank">K-最近邻</a>，听起来很复杂，但相信我它并不复杂，让我用一个简单的图表向你展示它是如何使用二维工作的，因为这对我们凡人的大脑来说更容易可视化:</p><p id="819e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个医疗中心的数据，让我们画出年龄(Y轴)和一生中手术次数(X轴)的关系图。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kr"><img src="../Images/d7432be16ed16b59099d3ea80152c5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*yRrRoPAwXeotwiJqvUdcHQ.png"/></div></figure><p id="3c05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蓝点在手术中存活了下来，而橙色的则没有。假设我们有一个钻石，我们想预测它的结果。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ks"><img src="../Images/d5346267603986a77fe02f2ac59306e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*DYUiDs_a4ccBId_uEabjEQ.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">𝑑 = sqrt(|∆𝑠urgeries| + |∆𝐴𝑔e|)</figcaption></figure><p id="75c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将选取任意数量的邻居，例如3个，并测量钻石与其3个最近邻居之间的欧几里德距离。该算法将执行简单的求和以及重心运算来确定方块的结果</p><p id="55cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理论到此为止，让我们开始训练吧:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kt"><img src="../Images/362cb4152d2d964cf32d7910a067b59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*fz-ZxO1ewe3xuwhOWT43HQ.png"/></div></figure><p id="5ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是如何做到的，很好很容易，我们刚刚创建的<strong class="ih hj"> knn模型</strong>可以从给定的<em class="kp"> X_data </em>或我们想要创建的任何相同长度和参数的数组中预测<em class="kp"> y_data </em>，<em class="kp"> y_pred </em>就是预测结果。但是我们怎么知道我们的模型是否准确呢？让我们定义一个函数来衡量它的精度:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ku"><img src="../Images/f4e305e3219f784f069c44b1c789d088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*zargP0Y48-b6kzVbqkNITA.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">real_data.shape[0]只返回行数</figcaption></figure><p id="c0a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过将数据框中的实际数据与我们刚刚使用knn算法预测的数据进行比较来衡量准确性。我们得到了94.22%的准确率，这是很好的，但离完美还差得很远。也许增加邻居的数量(上面的n_neighbors参数)会有帮助？让我们来看看:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kv"><img src="../Images/31df06493bb51b2a4a4266bdad52fdfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*NbtHEXOncIMS9NinoGgLjw.png"/></div></figure><p id="f25e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，3是最准确的，但是为什么1会给出100%匹配的结果呢？这就是所谓的<strong class="ih hj">过拟合，</strong>这意味着<strong class="ih hj">我们的模型只有在给定的数据与他训练的数据非常相似时才会准确。这是我们想要避免的，因为机器学习的目的是泛化。</strong></p><p id="5fff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —奖金— </strong></p><p id="f905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们追求完美，努力提高我们目前的成绩。我们将使用统一权重训练另一个模型，这是通过将分类器方法中的<strong class="ih hj"> p </strong>参数(Minkowski距离的幂参数)更改为1来完成的(当p = 1时，这相当于使用manhattan_distance (l1)，欧几里得_distance (l2)为p = 2，这是<strong class="ih hj">默认的</strong>选项)<br/>，即<a class="ae kh" href="https://towardsdatascience.com/k-nearest-neighbors-knn-algorithm-bd375d14eec7" rel="noopener" target="_blank"> Manhattan Distance </a></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kw"><img src="../Images/0e65ccd5128799122a042361ca4e4851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*StRxCpVFM_Cx4S2InStn0g.png"/></div></figure><p id="1a5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有太大的改进(+0.34%)，因为这个例子的目的是为了知道存在哪些参数可以用来改进结果</p><p id="1d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —结局— </strong></p><p id="9fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要压倒这一章，我今天就到此为止，希望它能帮助你学会一两个技巧，你可以发电子邮件给我在cellardoorweb@gmail.com的任何要求或问题。敬请期待更多人工智能的精彩</p></div></div>    
</body>
</html>