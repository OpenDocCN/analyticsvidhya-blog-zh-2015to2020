<html>
<head>
<title>Browser-based Models with TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于浏览器的模型和TensorFlow.js</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/browser-based-models-with-tensorflow-js-afcd10be3615?source=collection_archive---------9-----------------------#2020-09-03">https://medium.com/analytics-vidhya/browser-based-models-with-tensorflow-js-afcd10be3615?source=collection_archive---------9-----------------------#2020-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="042e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">机器学习的关键技能之一不仅仅是制作模型，还有部署。最激动人心的部署场景之一是javascript，您可以在web浏览器中进行训练、测试和推理。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bba7d80acb91face3d63e78333bd5817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Grf-UsXV3MYkE0f95DB8mg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源— <a class="ae jn" href="https://www.freepik.com/free-vector/machine-learning-banner-artificial-intelligence_6993831.htm#page=1&amp;query=machine%20learning&amp;position=25" rel="noopener ugc nofollow" target="_blank">免费版</a></figcaption></figure><p id="2b36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能会想，训练一个机器学习模型并从中获得推论将需要一个大数据中心，或者至少在你的机器中需要一个大GPU。但是，在现代网络浏览器和高科技计算机的帮助下，我们可以立即训练一个模型，并将其部署在您的网络浏览器上。我们可以轻松地将图像上传到网络浏览器，或者从网络摄像头获取图像，这很酷。然后，我们可以有一个模型在web浏览器中进行推理，而不需要将图像发送到云中由任何服务器处理。</p><h1 id="6a9d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">TensorFlow.js的设计与架构</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lc"><img src="../Images/46fad8fcbea16b72d9d0f6c91b404bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npKSvz2aHjl3mzVT3bGN-A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源— <a class="ae jn" href="https://www.coursera.org/learn/browser-based-models-tensorflow/lecture/PITQg/a-few-words-from-laurence" rel="noopener ugc nofollow" target="_blank"> Coursera </a></figcaption></figure><p id="9d47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它被设计成既可以在浏览器上运行，也可以在Node.js服务器上运行。<a class="ae jn" href="https://www.tensorflow.org/js" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>中的<strong class="jq hj">层API </strong>看起来和感觉上很像Keras。因为我们将使用javascript编码，所以在语法上与我们使用python编码略有不同。低级API被称为<strong class="jq hj">核心API。</strong>它们被设计为使用TensorFlow保存的模型格式，这是一种标准文件格式，可用于移动和嵌入式设备的<a class="ae jn" href="https://www.w3schools.com/js/" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>、Python APIs，甚至<a class="ae jn" href="https://www.tensorflow.org/lite/" rel="noopener ugc nofollow" target="_blank"> TensorFlow Lite </a>。为了加速训练和推理，核心API随后与浏览器一起运行，并可以利用<a class="ae jn" href="https://en.wikipedia.org/wiki/WebGL" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> WebGL </strong> </a>。同样在<a class="ae jn" href="https://www.w3schools.com/nodejs/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Node.js </strong> </a>上，您可以构建服务器端或终端应用程序，然后根据您的机器利用CPU、GPU和TPU。</p><h1 id="6543" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">浏览器中的简单神经网络</h1><p id="6d91" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">您需要做的第一件事是在您的<a class="ae jn" href="https://www.w3schools.com/html/" rel="noopener ugc nofollow" target="_blank"> HTML </a>文件的标题下方和正文上方添加一个脚本标签，以加载TensorFlow.js文件。下面是实现这一点的代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">要使用tensorflowjs服务，您的HTML页面中必须包含此脚本</figcaption></figure><p id="46f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一行将模型定义为顺序的。最简单的神经网络是一层一个神经元。所以我们只在序列中增加了一个密集层。这个密集层中只有一个神经元，正如你所看到的，单位等于一个参数。然后我们编写了一个神经网络，其损失函数为<strong class="jq hj">均方误差</strong>，它在线性关系中工作良好，并使用<a class="ae jn" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> SGD(随机梯度下降)</strong> </a>作为优化器。<strong class="jq hj"> Model.summary </strong>只是为我们输出模型定义的摘要。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用javascript制作模型</figcaption></figure><p id="816f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，<strong class="jq hj">dot training()</strong>应该是一个异步函数，因为训练可能会花费不确定的时间，我们不想在这个过程中阻塞浏览器。您可以调用这个函数并解析您刚刚在上面创建的模型，然后进行预测。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用javascript训练模型</figcaption></figure><p id="6948" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是您将用来训练神经网络的<strong class="jq hj">数据</strong>。首先，你会注意到我们将其定义为张量2D，而在Python中我们可以使用NumPy数组。我们在JavaScript中没有NumPy，所以我们要低一点。顾名思义，当使用一个<strong class="jq hj">张量2D </strong>时，你有一个二维数组或者两个一维数组。在这种情况下，你会看到我的训练值在一个数组中，第二个数组是这些训练值的形状。所以我在一个一维数组中使用一组6个值，因此第二个参数是<strong class="jq hj">【6，1】</strong>，我们将对<strong class="jq hj"> y </strong>做同样的处理。因此，如果您调整这段代码来添加或删除参数，请记住还要添加第二个数组来匹配它的大小。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用Javascript预测</figcaption></figure><p id="fba2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">调用异步dotraining()函数后，我们可以很容易地使用<strong class="jq hj">模型进行预测。现在，您已经准备好在您的web浏览器中运行我们的第一个简单的神经网络。只需运行您的HTML文件，您就可以在控制台中看到训练以及模型的摘要，并获得预测的输出作为警告消息，如下所示。</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">整个代码的演示(<a class="ae jn" href="https://github.com/Tirth1306/Browser-based-Models-with-TensorFlow.js/tree/master/Week1/Example" rel="noopener ugc nofollow" target="_blank">浏览器中的简单神经网络</a></figcaption></figure><h1 id="3d39" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">浏览器中的图像分类</h1><p id="d1d0" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">现在，我们将看看JavaScript中的图像处理，通过在浏览器中训练用于图像分类的<a class="ae jn" href="https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53#:~:text=A%20Convolutional%20Neural%20Network%20(ConvNet,differentiate%20one%20from%20the%20other." rel="noopener" target="_blank">卷积神经网络</a>，然后编写一个浏览器应用程序，该应用程序获取这些图像并将它们传递给分类器。我们将从使用JavaScript创建模型开始。下面是用JavaScript创建一个convnet的代码。它看起来很熟悉，但也有一些小的不同。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用Javascript制作模型</figcaption></figure><p id="0954" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">可以使用模型对象的fit方法来训练模型。您传递给它训练数据和标签，以及一个参数字典。批处理数据进行训练，而不是一次用所有数据淹没模型，这总是一个好主意。当在浏览器中操作时，这是一个更好的主意，这样你就不会锁定浏览器本身。如果您希望模型在训练时进行验证以报告准确性，那么您可以使用如下所示的验证数据列表。您还可以指定想要训练的历元数，并且可以打乱数据以防止<a class="ae jn" href="https://www.geeksforgeeks.org/underfitting-and-overfitting-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">过度拟合</a>。和往常一样，您可以指定回调，这样就可以更新用户的培训状态，为此javascript有一个很酷的库，叫做tf-vis。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">输入数据</figcaption></figure><h2 id="62d9" class="ll kl hi bd km lm ln lo kq lp lq lr ku jx ls lt kw kb lu lv ky kf lw lx la ly bi translated">Javascript中的可视化工具(<a class="ae jn" href="https://github.com/tensorflow/tfjs/tree/master/tfjs-vis" rel="noopener ugc nofollow" target="_blank"> tjs-vis </a>)</h2><p id="42cd" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">JavaScript有一些额外的工具，您可以使用它们使培训的可视化更加友好。首先，用这个脚本将名为tjs-vis的库包含在代码中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">包括用于更好可视化的脚本</figcaption></figure><p id="309d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要使用带有fitCallbacks的tf-visualization库，只需声明它是来自<strong class="jq hj"> tfvis.show.fitCallbacks </strong>的返回。这个函数要求您传递一个容器，它将在其中呈现反馈，以及一组它应该跟踪的指标。很简单，将指标列表设置为您想要获取的指标，如损失、验证损失、准确性和验证准确性。对于容器，您只需设置名称和任何所需的样式，可视化库就会在浏览器中创建tose元素。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">设置tf-vis的所有参数</figcaption></figure><h2 id="6168" class="ll kl hi bd km lm ln lo kq lp lq lr ku jx ls lt kw kb lu lv ky kf lw lx la ly bi translated">—子画面</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/07bca97950d53bb13f6158b7031d4901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRYrhs_dPmjV6TMAvNQQSw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">MNIST精灵表的一部分(来源— <a class="ae jn" href="https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png" rel="noopener ugc nofollow" target="_blank">精灵表</a>)</figcaption></figure><p id="2b5e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能对包含数千张图片的<a class="ae jn" href="https://en.wikipedia.org/wiki/MNIST_database" rel="noopener ugc nofollow" target="_blank"> MNIST数据库</a>很熟悉。当在python中训练模型时，它将每张图像作为来自文件系统的输入，并根据模型非常容易和即时地处理它。但是在浏览器中，每当你加载一张图片时，它就会发出一个<a class="ae jn" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="noopener ugc nofollow" target="_blank"> HTTP </a>调用，发出数千个HTTP调用并不是一个好的做法。一个好的解决方案是制作整个MNIST数据集的<a class="ae jn" href="https://www.codeandweb.com/what-is-a-sprite-sheet" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">sprite sheet</strong></a><strong class="jq hj"/>。Sprite Sheet对于训练javascript中的分类器非常有用。因此，sprite工作表在一个图像中包含了所有70，000个图像，它们相互堆叠，然后被分割成一个单独的图像。这个单独的图像然后被转换成数组，并由模型处理。</p><p id="d04f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是使用MNIST数据集的笔迹分类演示。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">浏览器中的图像分类器演示(完整代码<a class="ae jn" href="https://github.com/Tirth1306/Browser-based-Models-with-TensorFlow.js/tree/master/Week2/Example" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><h1 id="a138" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">将模型转换为JSON格式</h1><p id="7f9b" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">我们可以把用Python中的<a class="ae jn" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>创建的模型转换成<a class="ae jn" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>格式，这样它们就可以用Javascript在浏览器中运行了。为此，我们必须在python中安装tensorflowjs。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在python中安装tensorflowjs</figcaption></figure><p id="87ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦您创建并训练了您的模型，我们需要保存我们的模型。我们将从生成一个目录来保存文件开始，我们使用时间戳来完成这项工作。所以我们将<strong class="jq hj">导入时间</strong>，获取当前时间戳，并保存模型和路径/tmp/saved_models/，后跟时间戳。它将保存的模型保存到指定的路径。现在下一行将把您保存的模型转换成JSON格式。您的模型可能有多个文件，而不仅仅是model.json，这取决于您的模型。下一步，您需要下载这些文件，并将它们放在与将要托管它们的HTML页面相同的目录中。更多方法，点击这里。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将模型转换成JSON格式的代码</figcaption></figure><p id="05fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，模型的URL必须通过HTTP加载。虽然它和HTML在同一个目录中，但是我们可以直接写名字，但是我仍然使用URL路径。一定要把这部分做好。为了获取JSON并将其转换为模型，我将通过传递那个<strong class="jq hj"> MODEL_URL </strong>来调用<strong class="jq hj">await TF . loadlayersmodel()</strong>。一旦完成，我将有一个训练有素的模型可用。现在，我可以通过调用模型的model.summary来检查模型，并通过调用<strong class="jq hj"> model.predict() </strong>来获得结果。对，就是这样。现在你可以在python中创建任何类型的模型，并且可以通过转换成JSON格式在javascript中使用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">将转换后的模型加载到javascript中的代码</figcaption></figure><h1 id="3086" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Javascript中的迁移学习</h1><p id="96b0" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated"><a class="ae jn" href="https://towardsdatascience.com/a-comprehensive-hands-on-guide-to-transfer-learning-with-real-world-applications-in-deep-learning-212bf3b2f27a" rel="noopener" target="_blank">迁移学习</a>是一种将知识应用于一个问题的技术，即从另一个问题中获得的知识。这里，和以前一样，您将从JSON模型的托管URL加载它，并使用<strong class="jq hj"> tf.loaLayersModel </strong>将其加载到一个对象中。这里我使用的是一个托管的URL<a class="ae jn" href="https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">预训练的mobilenet </strong> </a>。现在，您可以从预加载的mobilenet中获得一个输出层。我们选择名为<strong class="jq hj"> conv_p3_13_relu，</strong>的图层，在它上面我们将冻结一切。然后，我们将使用<strong class="jq hj"> tf.model </strong>类来创建一个新模型，它的构造函数可以接受输入和输出，我们将设置它接受mobilenet输入，即mobilenet的顶部，然后<strong class="jq hj"> conv_pw_13_relu </strong>作为输出。以便当我们将一组新的层连接到该模型时，该层下的所有内容都将被忽略。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">加载要使用预训练模型进行迁移学习的层</figcaption></figure><p id="3c03" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与Python不同，我们将使用javascript创建一个新的模型，而不是在原始模型的冻结层下添加一组新的紧密连接的层。其输入形状是所需mobilenet层的输出形状。然后，我们将它作为一个单独的模型来训练。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用迁移学习根据您的需求扩展预训练模型</figcaption></figure><p id="4411" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在预测时，我们将从截断的mobilenet得到一个预测，直到我们想要给我们一组嵌入的层。然后，我们将通过新模型传递这些嵌入，以获得新模型被训练的预测。正如你在下面看到的，这和你可能习惯的有点不同。</p><h1 id="9841" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">石头剪刀布蜥蜴史波克</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/80bfd080442daedacca3ac86c5b99590.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*2FXmoxqIbzfNsQi-AmOGFQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源— <a class="ae jn" href="https://the-big-bang-theory.com/rock-paper-scissors-lizard-spock/" rel="noopener ugc nofollow" target="_blank">粉丝网站</a></figcaption></figure><p id="f7ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由卡伦·布莱拉和萨姆·卡斯创作的传统碰运气游戏“石头剪刀布”的延伸。<a class="ae jn" href="http://www.samkass.com/theories/RPSSL.html" rel="noopener ugc nofollow" target="_blank">山姆·卡斯解释道</a>，他设计了这个扩展游戏，因为看起来大多数石头剪刀布游戏都会以平局告终。</p><blockquote class="mb mc md"><p id="91e4" class="jo jp me jq b jr js ij jt ju jv im jw mf jy jz ka mg kc kd ke mh kg kh ki kj hb bi translated">“剪刀剪纸，纸盖石头，石头压死蜥蜴，蜥蜴毒死斯波克，斯波克砸碎剪刀，剪刀砍头蜥蜴，蜥蜴吃纸，纸反驳斯波克，斯波克蒸发石头，一如既往，石头压死剪刀。”—谢尔顿</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/7dca6fa1d7f5c8f5c4a55d904974d16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqhlAgvVMEGzaWLyc5gNjA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源— <a class="ae jn" href="https://the-big-bang-theory.com/rock-paper-scissors-lizard-spock/" rel="noopener ugc nofollow" target="_blank">生活大爆炸</a></figcaption></figure><p id="32b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我已经使用预先训练的MobileNet模型开发了分类器，对网络摄像头捕捉的石头、布、剪刀、斯波克和蜥蜴的手势进行分类。在这个项目中，我使用了上面讨论的所有概念，下面是我的项目演示以及代码解释。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">手势分类器演示(完整代码<a class="ae jn" href="https://github.com/Tirth1306/Browser-based-Models-with-TensorFlow.js/tree/master/Week4" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><h1 id="7092" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="2005" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">在tensorflowjs的帮助下，我们可以借助javascript在浏览器中训练、测试和验证我们的模型。我们还学习了一些工具，如tjs-vis，它用于在浏览器中更好地可视化培训，以及一些技术，如sprite sheet，它对于减少对服务器的HTTP调用非常重要。然后我们学习了一些技巧，比如将预先训练好的模型转换成JSON格式，然后在javascript中使用转换后的模型。此外，我们已经看到了javascript中的迁移学习，这与我们过去在python中所做的略有不同。如果你想在这个领域更深入，我想推荐<a class="ae jn" href="https://www.coursera.org/learn/browser-based-models-tensorflow" rel="noopener ugc nofollow" target="_blank">Coursera</a>的课程。</p><h1 id="6ba5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">tirth Patel——Nirma大学计算机科学与工程专业学生。</h1><p id="5b69" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated"><a class="ae jn" href="https://www.linkedin.com/in/tirth-patel-861303171/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jn" href="https://github.com/Tirth1306/" rel="noopener ugc nofollow" target="_blank">Github</a>|<a class="ae jn" href="https://www.instagram.com/__txrth__/" rel="noopener ugc nofollow" target="_blank">insta gram</a></p></div></div>    
</body>
</html>