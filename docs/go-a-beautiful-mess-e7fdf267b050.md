# Go:漂亮的一塌糊涂

> 原文：<https://medium.com/analytics-vidhya/go-a-beautiful-mess-e7fdf267b050?source=collection_archive---------4----------------------->

## 围棋所立足的世界，我们都从围棋中得到快乐和痛苦。

![](img/29128f8e956fd79c6be6707e2536434b.png)

由[迈克·彼得鲁奇](https://unsplash.com/@mikepetrucci?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

像我这样的老派人喜欢静态类型语言，甚至我也尝到了动态类型语言在处理 JSON 等复杂结构数据或用 SQL/NoSQL 操作数据时的便利。静态类型语言避免了许多不明确的问题，让我们在单元测试报告错误之前找出错误。

所以我在很多方面都很喜欢 *Go* ，它利用了来自其他语言的许多概念，具有易于理解的结构类型，用于生产的强大工具集…等等，最重要的是，它易于编写，性能不会让你失望，但我有时也会感到困惑，并在 Go 中发现许多模糊的部分。

刚开始用 Go 的时候，惊喜地发现 Go 几乎把我的所有东西都收藏了。在大多数情况下，我需要做的就是关注代码本身。但是在我用 Go 写项目一段时间后，我开始觉得他们在 Go 中的一些设计太*简单*了，在处理更大的项目时缺乏灵活性。

在[Less is exponentially more](https://commandcenter.blogspot.fr/2012/06/less-is-exponentially-more.html)中，Rob Pike 解释了许多设计原则和许多 Go 变成这样的原因，我可以想象一些守旧派工程师坐在一起谈论 C++的场景，分享他们关于 C++的恼人经历，并决定制作一种简单的语言，创造许多便利的工具，帮助他们生活在快乐的编码世界中。有趣的是，这可能也是我认为围棋既漂亮又混乱的原因。

> 美丽的混乱——围棋站立的世界

*在撰写本文时，Go 的最新发布版本是 v1.15。因此，下面的一些观点可能会在未来发生变化。*

# 围棋之美

## 简单学习曲线

这可能不是编程语言最重要的核心特性，但令我惊讶的是，我只花了两天时间学习基本知识，花了一天时间习惯键入声明(比如写`num int`而不是`int num`)，花了大约三天时间了解 Go 模块、goroutine、上下文、通道等。

对于一个有 C/C++/Java 等经验的程序员来说，花一些时间完成[中的所有课程，一次围棋之旅](https://tour.golang.org/)将足以开始编写一个实用的围棋程序，剩下的时间将花在阅读库文档、学习惯用的方法和遇到围棋中的陷阱上。

Go 还提供了丰富的工具来帮助新手编写程序，而不需要学习很多关于编译、闪烁、打包和部署等方面的知识

从很多方面来说，Go 确实是一种简单易学的语言，它更像是一个生态系统，让人们不需要在环境设置上花费太多时间。

我们只需要编写代码并键入`go run ...`

## 没有预处理器指令

在传统的静态类型语言如 C/C++中，我们经常使用预处理器指令来定义 marcos 或在编译时进行条件测试，如下所示:

```
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b)) 
#ifdef __x86_64__
...
#else
...
#endif
```

我们出于多种目的定义 marcos(通常是因为他们可以做任何事情，即使我们知道这是邪恶的)，但是这样做的代价是缺乏类型安全性，有时会使代码不可读并且难以调试。

Go 不提供像`#define`、`#if`…等预处理指令。，在我看来，这是进步的象征，尤其是对现代语言来说。

从技术上来说，Go *提供了一些特殊的预处理器指令*，不是让人去定义 marcos，只是让人给编译器或者构建工具提供提示。

例如，Go 提供了一些类似`go:noescape`、`go:noinline`…等的编译指令，为编译器提供提示。Go 还提供了 [build tags](https://golang.org/cmd/go/#hdr-Build_constraints) 指令来约束哪些文件将被包含在包中，这不是一个完美的解决方案，也不像其他构建系统如 CMake、Gnu-make 那样有效..等等。，但无论如何，它让事情变得简单。

***延伸阅读***

[](https://dave.cheney.net/2018/01/08/gos-hidden-pragmas) [## Go 的隐藏#pragmas

dave.cheney.net](https://dave.cheney.net/2018/01/08/gos-hidden-pragmas) [](https://golang.org/cmd/go/#hdr-Build_constraints) [## Go-Go 编程语言

### 构建约束部分。

golang.org](https://golang.org/cmd/go/#hdr-Build_constraints) 

## 易于定义新类型

这是让我感觉舒服的部分，在 Go 中，从现有类型定义一个新类型是非常容易的。

用于不同目的的不同类型将使代码更具可读性，它还有助于防止将错误的参数顺序传递给函数，并提供了为每种类型编写检查方法的可能性。

从*字符串*创建一个新类型并为新类型提供一些方法是非常容易的，如下例所示:

这个例子展示了一种从字符串定义两个新类型的简单方法:`UserID`和`UserName`，并为这些类型添加了验证函数，这种独特的类型还防止我们传递错误的参数顺序。

## 并发编程从未如此简单

我一直认为围棋最大的特点是 goroutine，而*频道*的概念可能有点混乱，但也很棒。

除了 *goroutine* 的优点，比如轻量级和有一个很好的上下文控制机制，我认为 *goroutine* 最大的优点是我们可以用同步模型在 *goroutine* 中编写代码，并受益于异步模型的性能。

另一方面，一个 goroutine 的内存开销只有 2 ~ 4k 字节左右，线程的开销有几兆，这说明 *goroutine* 相比*线程*确实是一个轻量级的解决方案。

根据我的经验，Go scheduler 可以很好地处理成千上万的 goroutines 和频繁的垃圾收集。

***延伸阅读***

[](/rungo/anatomy-of-goroutines-in-go-concurrency-in-go-a4cb9272ff88) [## Go 中 Go routines/Go 中并发性的剖析

### goroutine 是在后台运行的轻量级执行线程。goroutine 是实现并发性的关键因素…

medium.com](/rungo/anatomy-of-goroutines-in-go-concurrency-in-go-a4cb9272ff88) 

## Go 中的上下文包非常棒，非常优雅

在处理网络编程时，Go standard library 提供了一个`context`包，通过一个优雅的传播机制来管理任务，如果我们想取消任务或为任务设置超时，这就变得容易多了，而不需要编写复杂的代码。同步和通知机制。

当我们编写一个大的服务程序时，网络操作可能发生在很深的代码堆栈中，我们需要非常小心地处理每个函数的超时或网络故障问题，否则会阻塞整个服务或导致连锁崩溃。

幸运的是，Go 中大多数与请求相关的函数使用`context`作为其第一个参数，并在必要时创建一个派生上下文，因此我们可以从上层函数取消或设置这些函数的超时，并以令人愉快的方式控制这些任务。

***延伸阅读***

[](/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c) [## Go:通过传播的上下文和取消

### 在 1.7 中引入的上下文包为我们提供了一种在应用程序中处理上下文的方法。这些环境可以…

medium.com](/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c) 

## **使用迭代范围作为默认样式，不使用迭代器接口**

嗯，有些人可能不同意这一部分，我知道有些程序员真的很喜欢迭代器风格，但在我看来，我更喜欢基于范围的循环，例如。

Go 对字符串、数组、切片、地图和通道使用基于范围的循环，这是一种迭代项目的干净方式，现代 C++也支持基于范围的循环、自动类型化变量和其他好的特性(这使我喜欢用 C++编程)。

Go 中基于范围的循环看起来很好看很干净，可惜 Go 没有提供 Java 和 C++那样的标准迭代器接口，所以范围操作只支持内置类型。

比如我们要迭代`sync.Map`中的条目时，不能直接对其进行 range，而需要传递一个回调函数给`Map.Range(),`Go 中容器的不良支持对我来说毫无意义。

## 标准工具链令人震撼

Go 提供的标准工具的有用性和便利性可能是我喜欢用 Go 编码的前 5 个部分。

对于格式化代码，go 提供了`gofmt`，简单快捷，不管你喜不喜欢，它为代码提供了一个*官方*规范格式，我发现很多项目都在用，我猜是因为 vscode 是 Go 开发中最受欢迎的编辑器，vscode 的 Go 扩展真的很好看，真的。

对于林挺来说，围棋提供了`golint`，不强大但简单，但有 [golintci-lint](https://golangci-lint.run/) 和 [revive](https://revive.run/) ，又好又快。

对于构造检查，它有`go vec`，对于文档化 Go 代码，Go 定义了 godoc 格式，让我们可以编写内联文档，并且有一个官方的 [https://pkg.go.dev](https://pkg.go.dev/) 包文档门户。

最好的部分是关于测试、代码覆盖报告、基准测试和性能分析，尤其是性能分析，内置的 CPU 和内存性能分析功能非常强大，它减少了性能优化的大量时间。

## 快速构建，快速测试，快速死亡

这部分是我个人的偏好，我对长时间的编译没有耐心，但是如果你生活在 C++世界，你唯一能做的就是深呼吸，接受它。

当我开始使用 Go 时，令我惊讶的是编译时间非常快，即使是一个大项目也只需要几秒钟。快速的编译时间带来更敏捷的调试效率，换句话说，如果你做错了什么，代码会死得更快。

## 便于部署

这是个人偏好的另一部分，默认的 go 编译器和链接器(不是 gccgo)可以将对象编译链接成一个静态的可执行文件，这意味着我们的程序不依赖于其他共享库。

库依赖问题在部署阶段可能会变得非常棘手，在现代部署环境中，人们越来越多地使用容器技术。像 Docker 一样，单个静态可执行文件不依赖于任何东西，所以不需要将库安装到容器中，结果是我们有了一个占用空间小的容器，DevOps 喜欢这个。

# 围棋的混乱

## 围棋的错误处理还停留在恐龙时代

人们抱怨 Go 的错误处理，我也是。

Go 的错误处理让我感觉回到了写 C 代码的 90 年代。

Golang 的开发团队说他们不想支持异常，所以最终，我们代码中的错误处理都是这样的:

由于 Go 中的接口不支持方法的默认实现，*错误*是带有`Error()`方法的接口类型，没有定义任何其他方法来支持堆栈跟踪。

即使它定义了它，要求每个自定义错误实现方法进行堆栈跟踪是不实际的，它应该让一个默认实现在*错误*接口中处理堆栈跟踪。

不幸的是，Go 接口的角色需要简单而纯粹，所以接口唯一需要做的就是定义方法的名称和签名。

所以事情变得很有趣，错误类型看起来只是一个字符串值。当一个错误发生时，我们唯一知道的是“等等…等等”出错了。我们不确定错误发生的位置，因为这个错误可能会在更深层次的函数中报告，而不是在我们调用的函数中报告，如果我们不使用类似 [errors](https://pkg.go.dev/github.com/pkg/errors) 的堆栈可跟踪包，我们需要花费大量时间来找出错误发生的实际位置。

## 恐慌，恢复，推迟，使人痛苦

我说 Go 不支持异常，但是等等…它支持！

Go 有一个函数`panic()`是像 c 中的`assert()`一样被设计用来终止程序的，而出于某种原因，也许是关于宇宙中的黑暗力量，几年后 Go v1.0 又增加了一个函数`recover()`，相关讨论在这里是[这里是](https://groups.google.com/g/golang-nuts/c/HOXNBQu5c-Q)。

当`recover()`在 Go 中加入后，panic 和 recover 成为伙伴，其行为类似于 try-catch 异常处理，panic-recover 看起来像是 *try-catch* 的怪异版本，只是 Go 称其为 panic 和 recover。

嗯，使用`recover()`来捕捉来自`panic()`的错误对我来说是一种可以接受的方式，即使我们需要在延迟函数中调用`recover()`。

> 但是如果我们想从恐慌中捕捉错误，然后返回错误或一些有意义的结果呢？

解决方案是我们需要使用[命名的 result_parameters](https://golang.org/ref/spec#Defer_statements) ，aka。命名返回值。这是因为*延迟*函数中的返回值在函数完成时被丢弃，而*延迟*函数可以在返回值被返回之前访问和修改已命名的返回值。如果我们想在一个*定义的*函数中返回一些东西，我们需要将数据设置为一个指定的返回值。

为了完成如此简单的任务，我们需要编写一些奇怪的代码，如下所示:

panic 是由`throwPanic()`抛出的，然后`catchPanic()`在一个延迟函数中通过`recover()`捕捉到它，`recover()`的返回值是一个类型为`interface{}`的值，所以我们需要检查 panic 抛出的值是否是错误的，然后我们可以将它赋给`err`。

好吧，我需要承认，这不像 Java 里的 try-catch 机制，像是 try…finally 机制！

*延迟*函数`recover()`类似于*最终*的一个块，它不确定是否有异常抛出，所以它需要检查`recover()`返回值，看看是否有`panic()`抛出的值。

无论如何，我不能理解为什么 Go 团队提供这种奇怪的解决方案，如果他们认为捕捉恐慌是一个必要的功能，而不是提供一个更可读的机制。

***延伸阅读***

[](https://yourbasic.org/golang/recover-from-panic/) [## 死机、堆栈跟踪以及如何恢复[最佳实践]

### Panics 类似于 C++和 Java 异常，但只适用于运行时错误，比如跟在 nil…

yourbasic.org](https://yourbasic.org/golang/recover-from-panic/) 

## 界面很简单，但是太简单了

接口是 Go 中类型系统的基础，接口的功能和其他语言类似:定义行为。

Go 不是面向对象的语言，但它借用了现代语言中的一些概念。Go 接口是一个提供多态性的简单解决方案，提到术语*多态性*，我想引用 BASIC 语言发明者的一句话。

> 多态性意味着你写了一个特定的程序，它的行为取决于它所操作的数据托马斯·e·库尔茨

接口的概念对我来说很好，但是当我在标准和其他社区包中处理接口时，我发现了一些有趣的现象。

*   *空的*接口被过度使用，`inteface{}`到处出现，因为地鼠用它作为 *Any/void ** 值来接收/传递具体的数据。
*   人们喜欢将接口视为基类，但事实并非如此。
*   当情况变得更糟时，人们使用 reflect package 通过一堆条件语句来解决运行时的问题。
*   人们花费大量时间来弄清楚哪个结构实现了哪个接口，因为 Go 声称它不想提供关键字*“implements”*。

除了最后一个，所有这些现象都与泛型有关，但 Go 的类型系统至少在 Go 的 v1 中不能为泛型编程提供优雅的方式。

但是泛型在某些场景下非常有用，以至于让人无法放弃，所以人们努力尝试通过定义方法、使用类型断言、反射等方式将代码写成泛型。

先说我提到的最后一个，一个接口需要一个具体的类型来实现，不管这个类型叫 class，struct，还是别的名字。所以，当我们在静态类型语言中定义一个类型来实现一个接口时，我们要让编译器知道，然后编译器可以在编译时检查接口的操作是否有效。

这给编译器带来了复杂性，也给编译时间带来了成本，Go 让类型检查操作从编译时到运行时，然后告诉程序员你的职责是在运行时检查类型，程序员说:“哦，好的”，然后就出现了一些笨拙的代码。

Go 最终会有泛型，关于泛型的提议是[这里](https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md)，希望在不久的将来会发生。

***延伸阅读***

[](https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html) [## 接口值没有价值

### 我最近在 Slack 上看到很多关于界面的问题。大多数情况下，答案是…

www.ardanlabs.com](https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html) [](/hackernoon/why-go-doesnt-have-generics-b40ef9e69833) [## 为什么 Go 没有泛型

### 首先，我只想说，是的，我知道 Go 最终会有泛型，而且已经有一个很大的…

medium.com](/hackernoon/why-go-doesnt-have-generics-b40ef9e69833) [](https://golang.org/doc/effective_go.html#interfaces_and_types) [## 有效围棋

### 围棋是一门新的语言。虽然它借鉴了现有语言的思想，但它有一些不寻常的属性，使它变得有效…

golang.org](https://golang.org/doc/effective_go.html#interfaces_and_types) 

## 该接口不支持方法的默认实现

由于[部分接口简单，但是](#686b)提到的太简单，Go 接口太简单了，除了定义方法签名之外，它不支持任何其他特性。因此它不能定义方法的默认实现，这使得在不破坏已经实现该接口的现有类型的兼容性的情况下，很难在接口中添加新方法。

如果接口没有被导出到包之外，这可能没什么大不了的，因为我们可以自己更新包中的所有类型。但是，如果我们为包中的其他人提供导出的接口，比如我们写一个开源的包放在 GitHub 上，试图给这个接口添加一个新的方法会破解使用我们包的人的代码。

所以我们唯一能做的就是升级软件包的主要版本，并将其设置为不兼容，因为我们不能为新方法提供默认实现。有一个著名的例子:

当 Go v1.13 发布时，它通过向 [errors](https://pkg.go.dev/errors) 包添加新的 [Unwrap](https://pkg.go.dev/errors#Unwrap) 方法，引入了错误链接机制。

为什么不把这个方法添加到错误接口，而是添加到[错误](https://pkg.go.dev/errors)包？这可能是我上面提到的原因:他们不能，因为这将破坏所有现有的代码。

***延伸阅读***

 [## Go:好的，坏的，丑的

### 这是“围棋不好”系列的附加帖子。Go 确实有一些不错的特性，因此有“好”的部分…

bluxte.net](https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/#interface-methods-dont-support-default-implementations) 

## Go 中的常量只支持标量类型

Go 有常量，但不是我想的*那个*常量。

Go 中常量的定义遵循一个简单的原则，使得标量值不可改变，标量值的类型有:bool、全数字类型、string。因此，没有常量结构、常量指针和常量数组。

但是如果我们看 Go 提供的标准包，你会发现有一堆*非常量*导出的变量，而这些变量不是常量的原因是:Go 不支持它们是常量。

让我们看看 [net](https://pkg.go.dev/net) 包，这个包输出`IPv4bcast`、`IPv4allsys`、`IPv4allrouter`和`IPv4zero`变量。所以很容易做一些邪恶的事情:

严格地说，这个问题是一个实现问题，有许多方法可以不在包中使用导出的变量，但是在现实世界中，有时我们需要导出一些变量来提供预定义的信息。

在这种情况下，如果可以的话，我们会想把这些变量设为常量。

## 基于范围的循环只能迭代内置类型

我们再次回到接口问题上，Go 为内置容器类型提供了一级成员徽章:数组、切片、映射、通道*(嗯，你为什么在这里，就因为你的行为像队列？但是你父亲叫你通道。)*

只有这些一级成员可以享受坐在基于范围的循环中，其他容器类型是经济舱的成员，需要找到自己的方式来提供迭代。

在[列表中。列出](https://pkg.go.dev/container/list#List)包，需要用`for e := l.Front(); e != nil; e = e.Next() {…}`迭代项，和[同步。Map](https://pkg.go.dev/sync#Map) 需要使用 [Range()](https://pkg.go.dev/sync#Map.Range) 方法和传递回调函数。

此外，这些一级成员的行为与其他成员不同，当它们作为参数传递时，它们的行为就像是通过值传递的，实际上，它们是通过指针传递的，所以它们看起来像是通过引用传递的。

顺便说一下，字符串类型是一种特殊的类型，它是不可变的，它是通过值传递的，但它只复制字符串的长度和字符串的指针。如果我们修改它，它只会创建一个新的内存空间来存储新的内容。

## 可见性的命名约定

Go 中可见性的命名约定还不错，除了有点烦人。

Go 迫使我们在导出变量、结构和方法的第一个字符中使用大写字母，如果我们一直生活在 Go 世界中，这不是问题。

但是当我们要通过 JSON/Protocol Buffers 等在网络上交换数据的时候，在 struct 字段中添加 struct 标签就有点烦人了。

struct 标签的元格式有点…嗯..太简单了！？，而且很容易一不小心出错。关于 struct 标签的另一件事是，我们需要使用 *reflect* 包来获取它并自己解析它。

## 是否导出，结构字段没有私有属性

在包范围内，一切都像老大哥 *C* 一样彼此可见，但与 C 不同的是，Go 还提供了一个简单的可见性规则:*使其在当前包外可见或不可见*。

同样的情况又发生了，它适合小的包，但是如果有一个针对大的包的细粒度可见性控制就更好了，所以:

> 给结构字段提供私有属性，让结构字段只在结构中可见，怎么样？

私有成员数据，或者我们可以称之为私有结构字段，是一个常见的概念，它确实有助于防止有人篡改数据。

## Slice 建了个陷阱等着你

Slice 在 Go 中的应用非常广泛，当我们把它简单地作为底层数组的只读视图使用时，它不会遇到问题。但是当我们将一个切片传入另一个函数，并试图用`append()`或`copy()`来修改切片时，就会遇到一些令人困惑和不直观的问题。

需要花一些时间去了解切片的内部工作原理和结构。在我看来，许多问题和陷阱与切片本身无关，但人们习惯于将切片视为值或引用/指针值，因为它看起来像值！但是切片的本质是底层数组的视图。

另一个问题是关于`append()`函数，`append()`会在目的地容量足够的情况下尽量不为底层数组分配新内存，在必要时分配新内存以避免运行时死机，然后总是返回一个可能指向相同地址也可能不指向相同地址的新片。

切片的结构是这样的:

```
type slice struct {
 array unsafe.Pointer
 len   int
 cap   int
}
```

一个切片值不是一个`slice`实例或者一个`slice`的指针，它更像是一个指向`slice.array`的值，你可以把一个切片值想象成`unsafe.Pointer((*slice)(unsafe.Pointer(&A).array)`。

让我们看一个例子:

当创建长度和容量为 4 的' A '时，想要向' A '中追加一个字节，`append()`检测到' A '的容量不够，因此它为底层数组分配新的内存。

' A '和' B '的底层数组的地址是不同的，而' A '和' B '的地址总是不同的，因为它们是不同的值。

有趣的部分是关于' C '和' D '，' C '是用零长度和 4 字节容量创建的，所以当向' C '追加一个字节时，`append()` 不是分配新的内存，而是返回一个具有相同底层数组和更新长度值的新值。

让我们观察' C '和' D '，我们发现这两个值的内存地址是相同的，当我们把 slice 看成指针时，会误导我们认为' C '和' D '都指向同一个结构，所以' C '的长度应该从 0 更新为 1，但它没有。

正如我上面提到的，切片是底层数组的**视图，它是指向底层数组的指针，而不是指向内部结构本身的指针。**

从技术上来说，slice 和`append()`函数没有问题，但是提供一个类似`A.append(B)`的 slice 方法，并在这个方法中更新长度、容量和数据地址可能会更好。

***延伸阅读***

[](/@irbekrm/go-slices-functions-append-and-copy-e4afa7646ec4) [## 执行切片、函数、追加和复制

### 我正在浏览 Go 复习一些基础知识，遇到了一个练习，你必须写一个简单的结构…

medium.com](/@irbekrm/go-slices-functions-append-and-copy-e4afa7646ec4) [](https://blog.golang.org/slices-intro) [## Go 博客

### Andrew Gerrand 2011 年 1 月 5 日简介 Go 的切片类型提供了一种方便有效的工作方式…

blog.golang.org](https://blog.golang.org/slices-intro) 

# 美丽而混乱

## godoc 很简单，但是也太简单了

刚开始学围棋的时候，看 API 文档的时候觉得头晕。我记得我当时的想法:

*   关于输入参数的描述在哪里？
*   哪一段是关于返回值的？
*   为什么他们不标记参数，而是让它看起来像普通的单词？
*   为什么这么多方法的返回值都是错误的，但我却很少看到相关的描述？

在我开始阅读 godoc 文档之后，我终于解决了我的困惑，哦…它是一个纯文本格式，除了 godoc 解析器可以解析 url 之外，没有其他任何东西。

> 甚至 UNIX 手册页也像爷爷一样把事情描述得更清楚

纯文本格式很容易编写，Go 提供官方工具来支持文档化确实是一件好事，但是编写无标记的格式需要编写更多内容来更好地描述参数和返回值，人们需要充当词法分析器来搜索关于参数和返回值的关键字，有时由于 Go 中的速记命名约定而有点累。

在我看来，如果有一个官方的方法来标记参数和返回值，比如 [javadoc](https://en.wikipedia.org/wiki/Javadoc) ，那就太好了。

## Go 模块不错，可以进一步改进

Go 模块大概是 Go v1.11 引入时最激动人心的。

它省去了依赖性管理的麻烦，我喜欢使用 URL 作为模块名称空间的惯用方式，看起来很清楚，避免了命名冲突问题。

不幸的是，因为人们使用 GOPATH 多年，所以 Go 模块需要尽可能兼容，为了向后兼容，当我们即将发布新的主要版本时，事情变得有点尴尬。

> 推荐的策略是在以主要版本后缀命名的目录中开发`v2+`模块。— [Go 模块:v2 及以上](https://blog.golang.org/v2-go-modules)

在 [Go Modules: v2 and Beyond](https://blog.golang.org/v2-go-modules) 中，解释了为什么这是推荐的方式，而不是为主要版本创建 v+分支的常见方式。

我希望 Go 模块可以更好地处理这个问题。

**提供一种从私有库获取模块的简单方法**

流行的包管理器 [npm](https://www.npmjs.com/) 很好的处理了这个话题。它支持多种方式访问 git 库，支持通过 ssh、git 和 https 访问，有或没有访问令牌，它支持从库直接获取包，从 gzipped tarball，从本地目录，从注册表…等等。

简而言之，npm 提供了一种更灵活的方式来获取包，然后进入模块。

对于托管在启用了身份验证的私有存储库中的 Go 模块，我们需要首先设置一些东西:

*   设置 GOPRIVATE 环境变量以绕过官方代理
*   在 git 配置中做一些小技巧。
*   如有必要，设置 GONOSUMDB 环境变量。

一般来说，对于不同的模块源，Go 模块和模块代理可能需要更灵活的符号。

***延伸阅读***

[](https://blog.golang.org/v2-go-modules) [## Go 博客

### Jean de Klerk 和 Tyler Bui-Palsulich 2019 年 11 月 7 日引言本文是系列文章的第 4 部分。作为一个成功的…

blog.golang.org](https://blog.golang.org/v2-go-modules) [](https://blog.golang.org/v2-go-modules) [## Go 博客

### Jean de Klerk 和 Tyler Bui-Palsulich 2019 年 11 月 7 日引言本文是系列文章的第 4 部分。作为一个成功的…

blog.golang.org](https://blog.golang.org/v2-go-modules) [](/cloud-native-the-gathering/go-modules-with-private-git-repositories-dfe795068db4) [## 带有私有 Git 库的 Go 模块

### 如何配置 Go 模块来使用私有 Git 库，包括本地开发和 Docker 的例子。

medium.com](/cloud-native-the-gathering/go-modules-with-private-git-repositories-dfe795068db4) 

# 结论

现实世界，美与乱共存不是矛盾，而是一种常态，每个人对美或乱都有不同的看法。

当我开始写这篇文章的时候，它原本期望是一篇表达我个人观点的 3 ~ 4 页的文章，尽量做到中立公正。但是正如你所看到的，一个观点会带来其他观点，就像积极的一面总是有另一面。

我对围棋的感觉很复杂，我个人对围棋或其他语言的偏好更明确。比如我喜欢 C++，即使它超级复杂，语法看起来也不好看；我不喜欢 Java，即使我尊重它的许多好的语言设计理念；我喜欢 Javascript(现代版)即使它这么乱；我不喜欢 Python，因为它很慢。

Go 就像一个友善的大叔，幽默风趣，精力充沛，但也偏执固执，有时喜欢穿时髦的行头，但有时又坚持旧毛衣是最好的。

围棋的独特魅力和特点让你很快喜欢上了它，并开始对它抱有期望，然后你可能会开始觉得它有点顽固，最后你学会习惯它。

简单是美好的，少即是多，我看到围棋团队为了保持简单付出了很多努力。事实上，围棋很容易学习，也很容易在生产环境中使用。但是如果我们总是谈论简单，那么专注于简单会带来困惑，然后事情会变得复杂。

编程语言流行总是有原因的。比如:当 [node.js](https://nodejs.org/) 遇到 [express](https://expressjs.com/) 框架，当 [Ruby](https://www.ruby-lang.org/) 遇到 [Rails](https://rubyonrails.org/) 的时候，PHP……嗯，让我们跳过。性能、并发和云友好的特性使人们开始从其他语言转向 Go。

同样的事实也适用于我，在我的常规使用场景中，Go 可以节省大量时间来实现高性能、低延迟和实时的 web 服务。我喜欢使用 node.js 在前端提供 RESTful API，让 node.js 做数据验证和其他 I/O 密集型工作，然后将写入的任务调度到后端并发执行计算任务。

我希望这篇文章能给你一些提示，提供一些你以前可能没有意识到的观点。如果你能在阅读后避免陷入一些陷阱，那将是我的荣幸。