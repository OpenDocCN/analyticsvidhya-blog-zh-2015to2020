<html>
<head>
<title>Create your own sketch with OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 OpenCV 创建你自己的草图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/create-your-own-sketch-with-opencv-638a463c6ec6?source=collection_archive---------8-----------------------#2020-10-06">https://medium.com/analytics-vidhya/create-your-own-sketch-with-opencv-638a463c6ec6?source=collection_archive---------8-----------------------#2020-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5f2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你多久想让一位艺术家给你画一张素描？不用多说，现在你可以很容易地使用 OpenCV，在几分钟内制作出你自己的草图。只需 4 个步骤，OpenCV 将为您提供相同的肖像。</p><p id="711a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图像 1 到图像 2 只需 4 步。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/2248818397b2f16555e9cf64aacfb0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*4Ho8zrRX8F_nNLI77YMeUw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图 1:常规 RGB 图片</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/bb5ac2dc4387171d19230fe87d1d8586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*14zN3XsN5KJVv5nh7Huf1A.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图 2:铅笔素描肖像</figcaption></figure><p id="686e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，让我们开始吧，不用拿起画笔，自己画一张素描。</p><p id="734a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于这个特定的任务，我们将使用 Google Colaboratory 或简称为“Colab ”,它允许您在浏览器中编写和执行 Python，无需任何配置，可以免费访问 GPU 并轻松共享。嗯，你也可以用 Jupyter 笔记本，完全由你决定。</p><p id="21a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们今天要用的四个步骤如下:</p><ol class=""><li id="d909" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">将 RGB 彩色图像转换为灰度图像。</li><li id="363e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将灰度图像转换为负片。</li><li id="6d87" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">使用<a class="ae kd" href="https://docs.opencv.org/master/d4/d13/tutorial_py_filtering.html" rel="noopener ugc nofollow" target="_blank">高斯模糊</a>平滑图像。</li><li id="242e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">匀光和燃烧图像，以获得最终的输出。</li></ol><h1 id="f14a" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">入门</strong></h1><p id="6680" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">所以首要的第一步是加载图像并将其转换成灰度图像。<br/>我需要的图像存在于我的 google drive 中，因此我们必须将该驱动器安装到协作室中，这样做也是一样的。</p><p id="bf40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用下面这段代码来实现这一点:</p><blockquote class="lh li lj"><p id="eabf" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">从 google.colab 导入驱动<br/>drive . mount(' content/drive ')</em></p></blockquote><p id="4cc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行此命令时，您会发现一个需要访问的 google 身份验证链接，以便您可以复制身份验证代码并开始使用您驱动器的内容。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/4b7e9fbc98ea77ff1e1c7088dfc44793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*J9w77Oa2AtpZ0PIjL-_LEA.png"/></div></figure><p id="3d9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来了必要的导入，您需要导入 cv2 模块来完成所需的任务。此外，由于 cv2 模块的 imshow()函数不能与 google colab 一起工作，我们需要使用一个替代方法来查看图像。</p><blockquote class="lh li lj"><p id="def7" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">从 google.colab.patches 导入 cv2_imshow <br/>导入 cv2<br/>img = cv2 . im read(' picture . jpg ')<br/>cv2 _ im show(img)</em></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/396efb739748b1642f595075dd6be728.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*QlPHmCUL4i25zy9Dura6cQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">要转换的图像</figcaption></figure><p id="2f89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为草图将 RGB 彩色图像转换为灰度图像</strong></p><p id="9974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了图像，我们把它转换成灰度，这样以后就可以使用 cv2 模块中的 cvtColor()方法把它转换成负片。同样的方法也用于将图像转换为 HSV 和 RGB 格式。</p><blockquote class="lh li lj"><p id="db18" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">gray = cv2 . CVT COLOR(img . cv2 _ COLOR _ bgr 2 gray)<br/>cv2 _ im show(gray)</em></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lo"><img src="../Images/0752753d02605202d93dac0d317d4026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*6QTZf_eij3LPHgOpOobW6Q.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">灰度图像输出</figcaption></figure><p id="7b38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将灰度图像转换成负片图像</strong></p><p id="9459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要使用位运算将灰度图像转换为负数。逐位运算用于图像处理，并用于提取图像中的重要部分。</p><p id="5d61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将通过反转灰度图像在 0-255 之间的像素来获得图像的负片。为了反转图像，我们将使用 cv2 模块中的 bitwise_not()操作。</p><blockquote class="lh li lj"><p id="b223" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">img _ invert = cv2 . bitwise _ not(gray)<br/>cv2 _ im show(img _ invert)</em></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/bfedf920d2dcda522342d2f182501a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*wEHZh6vYw19vWPMdV6LhgA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">反转图像输出</figcaption></figure><p id="2b96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用</strong> <a class="ae kd" href="https://docs.opencv.org/master/d4/d13/tutorial_py_filtering.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">高斯模糊</strong> </a>平滑图像</p><p id="6775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图像处理中，高斯模糊(也称为高斯平滑)是通过高斯函数模糊图像的结果。这是图形软件中广泛使用的效果，通常用于减少图像噪声和细节。</p><p id="914a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种方法中，使用高斯核，而不是由相等的滤波器系数组成的箱式滤波器。这是通过函数 cv2 完成的。GaussianBlur():</p><blockquote class="lh li lj"><p id="bb42" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated">gblur_img=cv2。GaussianBlur(img_invert，(21，21)，sigmaX=0，sigmaY=0)</p><p id="bd97" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated">cv2_imshow(gblur_img)</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/c903071daedf5506d0f6cea6f3de19e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*nUCusUTxp0lP4DCp55-ybA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">平滑图像</figcaption></figure><p id="7e6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以根据自己的适合性更改内核大小，并查看输出如何变化。为了更好的理解，你可以学习更多关于<a class="ae kd" href="https://www.pyimagesearch.com/2016/07/25/convolutions-with-opencv-and-python/" rel="noopener ugc nofollow" target="_blank">内核</a>的知识。</p><p id="e436" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对图像进行匀光和刻录，得到最终输出</strong></p><p id="52ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">匀光和灼烧指的是传统摄影中印刷过程中使用的技术。在传统摄影的好日子里，人们会试图通过控制曝光时间来使暗房照片的某个区域变亮或变暗。闪避使图像变亮，而燃烧使图像变暗。</p><p id="1b17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Photoshop 等现代图像编辑工具提供了模仿这些传统技术的方法。例如，具有遮罩 B 的图像 A 的颜色匀光实现如下:</p><p id="cd05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">((B[idx] == 255)？B[idx] : min(255，((A[idx] &lt;&lt; 8) / (255-B[idx]))))</p><p id="e578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">This is essentially dividing the grayscale (or channel) value of an image pixel A[idx] by the inverse of the mask pixel value B[idx], while making sure that the resulting pixel value will be in the range [0,255] and that we do not divide by zero. We could translate this into a naïve Python function that accepts two OpenCV matrices (an image and a mask) and returns the blended image.</p><p id="0a2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">We’re lucky that we can do this with just minimal code with the help of Opencv.</p><p id="590b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Here we create custom function dodge_img() which takes a grayscale image and an inverse image as a mask as the arguments to the function and then convert the image to a dodged image.</p><blockquote class="lh li lj"><p id="a3d6" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi"> def dodge_img(x，y): <br/> return cv2.divide(x，255-y，scale=256) </em></p><p id="750d" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">道奇 _ img =道奇 _img(gray，gblur_img) <br/> cv2_imshow(道奇 _img) </em></p></blockquote><p id="5d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生以下结果:-</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/d9d78d7a353c7cc0a1233798e42d0e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*nLn0zLuplzP_XuPpKFiCZg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">闪避图像输出</figcaption></figure><p id="2411" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了执行烧录，我们将再次创建一个自定义函数 burn_img()，该函数将被遮挡的图像和被平滑的图像作为该函数的参数，该函数将使图像变暗，从而执行图像的烧录。</p><blockquote class="lh li lj"><p id="45b0" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi"> def burn_img(image，mask):<br/>return 255—cv2 . divide(255-image，255-mask，scale=256) </em></p><p id="feb4" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">final _ image = burn _ img(sodied _ img，gblur_img) </em></p></blockquote><p id="8cf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此这最后一步最终产生我们的草图的原始图片:—</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/bb5ac2dc4387171d19230fe87d1d8586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*14zN3XsN5KJVv5nh7Huf1A.png"/></div></figure><p id="d2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">瞧！这就是你用 OpenCV 画的草图。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lt"><img src="../Images/2f752575e903ef0a94c8da1f5dd8cfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*jC8eIujPq2mpy62RCq-rSg.png"/></div></figure></div></div>    
</body>
</html>