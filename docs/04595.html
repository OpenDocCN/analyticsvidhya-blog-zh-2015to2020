<html>
<head>
<title>Step by step guide on working with the weather dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用天气数据集的分步指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/step-by-step-guide-on-working-with-the-weather-dataset-9aa8c77e30a8?source=collection_archive---------21-----------------------#2020-03-25">https://medium.com/analytics-vidhya/step-by-step-guide-on-working-with-the-weather-dataset-9aa8c77e30a8?source=collection_archive---------21-----------------------#2020-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/489b15aff307479286a233d4f4af259d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cx6T6j95zwMeLxlvD9WtCw.png"/></div></div></figure><p id="6ab7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我之前的文章中，我发表了过去5年(2015年至2020年)全球477个城市的天气分析结果，可以在这里<a class="ae jp" rel="noopener" href="/@esimonova/the-quest-for-finding-the-best-weather-in-the-world-bd5f24f7da09">访问</a>。今天，我将解释我的努力的技术背景，希望这对面临类似数据分析项目的其他人有用。</p><figure class="jr js jt ju fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es jq"><img src="../Images/ee2de493bd14999533312340fc59eb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HEBe5Iu4Mq1YVJ1QnOf49g.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">熊猫，Dask还是PySpark？您应该为数据集选择什么？(medium.com张萌)</figcaption></figure><p id="2fa0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我们开始处理数据之前，我们需要决定使用哪个库。上面你可以看到一个简单的决策树，它将帮助我们找出一个最佳的方法。在我的例子中，总数据库大小约为900兆字节，有2100万条观察数据，所以我选择了熊猫。从技术上讲，由于我是一次处理一个城市的数据，所以我使用了chunksize方法，因为我没有将整个数据库加载到内存中。</p><p id="65d7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们的第一步是评估数据的质量。我在PostgreSQL浏览器中手动检查了第一个城市的年度数据。我检查了数据集中是否有丢失的值，并发现了一些小时/天丢失或某些天的湿度/温度数据不可用方面的差距。然后，我检查数据是否一致，例如，datetime观察是否在同一时间进行，理想情况下每小时取整一次，但实际情况并非如此。下一步是识别数据中的异常值。我检查了我将用于这个项目的数据列是否没有极端的异常值。例如，相对湿度应该只在0到100之间变化，因此看到高于100的值意味着数据集中有问题。使用SQL代码，我检查了数据没有负值或超过100的值。</p><p id="0532" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我已经开始使用一种类似的基本方法来检测温度值中的异常值。我查看了维基百科上的温度记录，大多数国家的记录都在50摄氏度左右。然而，在我的数据集中，有135个值超过了这个值。这些温度可能是由温度计的错误造成的。我用Python写了一行，将每一行与下一行进行比较，以检查两次观察之间的温度变化是否小于5度。但首先我想检查一下每小时最频繁的变化是什么。所以我计算了整个数据集各行之间的差异。正如所料，最频繁的变化是零。考虑到数据中有一些丢失的小时，我决定位于平均值的三个标准偏差(99.7%的数据)内的一切都是每小时的正常温度变化。但是，其余的(0.3 %的数据)应该排除在外。所以我找出了99.85和0.15个百分点，分别是5和-5，我用它们来排除数据，这些数据可能是由于测量错误而出现的</p><p id="4fae" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">之后，我安装了连接PostgreSQL和进行数据分析所需的所有软件包，分别是SQLAlchemy (1.3.12)、pandas (0.25.3)、psycopg2 (2.8.4)和psycopg2-binary (2.8.4)。然后我连接到PostgreSQL来获取数据，并通过SQL查询创建了一个熊猫表。</p><p id="cdcc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">还以更严格的统计方式检查了数据中是否存在异常值。在一个单独的脚本中，在建立了到数据库的连接之后，从SQL查询中创建了pandas表。然后，创建了函数find_outliers。该函数用于heat_index列和相对湿度列。然后，下面的函数会将异常值添加到列表中。对于相对湿度数据，低于8%的湿度被标记为异常值。然而，相对湿度是从温度和露点计算出来的，如果露点极低而温度很高，它给出的相对湿度值低于8%，所以我没有从分析中排除这些值。</p><figure class="jr js jt ju fd ik"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="103c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然后我继续清理数据。首先，我删除了所有不必要的列，它们是观测id(“id”)、完成观测的时间“end_time”(该列与start_time相同，因此我保留start_time以获得datetime对象)、日期标识符(“day_ind”)，它显示观测是在白天(D)还是在晚上(N)、进行观测的机场位置(“airport_four_letter_code”)、“dew_point”、天气“type”(“wx _ icon”)、大气压力(“pressure”)、“visibility”——这些列没有包含在我的分析中选择要移除的柱子是非常主观的，因为风寒会降低感知温度，这在温暖的天气会产生积极的影响，在寒冷的天气会产生消极的影响。很难客观地测量包括风参数在内的天气，因此在本文中不包括它。然后我删除了重复项和所有温度为空的行。对于相对湿度缺失的数据，我使用了pandas方法fillna (method='fflil ')，因为湿度在几个小时或几天内变化不大(我允许自己这样做，因为没有很多缺失值)。</p><figure class="jr js jt ju fd ik"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="cdc9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我的分析还依赖于为雨天提供惩罚，然而不幸的是，我的数据集中的<em class="kb">降水量</em>列的值不正确，更好的值是免费提供的。然而，数据集包含一个更准确的列，名为<em class="kb">wx _ phrase</em>——对当时天气状况的简短描述——小雨、雪、晴天、云等。由于我的天气质量公式只依赖于温度、湿度和降雨的存在，我能够根据降雨的存在将所有的天气条件绘制成一个真/假列。例如，<em class="kb">is _ deposition</em>在“阳光明媚”的时候是假的，但在“小雨”的时候是真的。</p><figure class="jr js jt ju fd ik"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="7e62" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">另一个挑战是价值观缺失。一些气象站每隔几小时才更新一次天气。其他人甚至在整个数据集中到处都有几天不见了。因此，我需要推断数据框架中缺失的天数和小时数。对于每个城市和年份的组合，我得出的逻辑如下:</p><ol class=""><li id="6b31" class="kc kd hi it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk bi translated">检查一年的第一天是否存在。如果没有，就抓住前一年的最后一天</li><li id="1cc7" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">按时间顺序走过一年中的每一天，直到我们找到缺失的一天</li><li id="9c50" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">对于每个缺少的日子，将前一天的值复制到其中</li><li id="5cda" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">重复，直到我们到达年底</li></ol><figure class="jr js jt ju fd ik"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="c425" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，如果我的数据集错过了6月1日，我会将5月31日的值复制到其中。对于我的分析来说，这似乎是可以接受的，因为天气通常在一天内变化很小。后来，我需要解决一天中缺少时间的问题:</p><ol class=""><li id="9a5c" class="kc kd hi it b iu iv iy iz jc ke jg kf jk kg jo kh ki kj kk bi translated">将所有时间戳值四舍五入到最接近的小时</li><li id="c6a3" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">删除舍入过程中可能出现的任何重复项(例如，1:50和1:55都将舍入到2:00)</li><li id="81d3" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">检查一年中第一天的第一个小时是否存在。如果没有，那就抓住去年最后一个小时</li><li id="a490" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">按照时间顺序遍历一年中每一个可能的小时，直到我们找到一个丢失的小时(例如，从1月1日00:00开始，然后继续到01:00，等等)</li><li id="6229" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">与天数逻辑类似，复制前一个可用小时来代替丢失的小时</li><li id="47c5" class="kc kd hi it b iu kl iy km jc kn jg ko jk kp jo kh ki kj kk bi translated">继续，直到所有缺少的小时数都已填满</li></ol><figure class="jr js jt ju fd ik"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="9004" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">体验过Pandas的读者可能会注意到<a class="ae jp" href="https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758" rel="noopener ugc nofollow" target="_blank">这是一个低效的算法</a>，因为我被迫遍历数据帧，而不是使用一个本地外推函数或lambda函数。不幸的是，当时我找不到更好的解决方案，但如果你能在评论中解释一下，我会很高兴。不过好的一面是这个操作只需要完成一次，因为天气得分的计算与缺失值的外推是分开进行的。因此，在我的数据分析中，我只使用了一次低效的pandas操作。</p><p id="cb6c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">接下来，我使用一个简单的lambda函数计算天气得分，并将干净的数据加载回PostgreSQL。</p><figure class="jr js jt ju fd ik"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="1d0b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">用于分析的完整版本代码可以在<a class="ae jp" href="https://github.com/kate-simonova/py-weather-analytics" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我希望你喜欢阅读！</p></div></div>    
</body>
</html>