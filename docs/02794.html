<html>
<head>
<title>HMM for Multidimensional Categorical Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多维分类数据的隐马尔可夫模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hmm-for-multidimensional-categorical-data-68b1091c9d66?source=collection_archive---------13-----------------------#2020-01-02">https://medium.com/analytics-vidhya/hmm-for-multidimensional-categorical-data-68b1091c9d66?source=collection_archive---------13-----------------------#2020-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/199556e865c530bd4c91f57c9f833467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viEbbEcq9Z306cfwW0rpng.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">多维苏格兰(由我拍摄)</figcaption></figure><p id="e2df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您正在处理顺序数据吗？你喜欢经典的机器学习吗？您是否听说过隐马尔可夫模型(HMM)但没有机会在您的数据上进行尝试？在Python中找到一个像样的HMM包有困难吗？如果你对以上问题中的至少一个回答“是”，我邀请你阅读这篇文章。</p><p id="be50" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将首先解释一下HMM模型，然后用代码示例展示一个很棒的Python包。</p><h1 id="7123" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">解释HMM结构—以用户行为为例</h1><p id="8f96" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">HMM是一种模型，它允许您在给定数据的情况下找到最可能的状态序列(如果不清楚，请遵循示例)。该模型被广泛应用于各种领域:声音处理、语言模型、遗传学等等。</p><p id="74bd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的例子中，我将展示如何使用HMM来预测用户行为——步行或驾驶活动的片段。该预测基于来自蜂窝传感器的数据，如步数计数器、GPS位置、WiFi连接等。</p><p id="d4e8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要使用HMM，我们首先需要将世界的统计模型形式化，我们对世界的所有了解将总结为两个小矩阵:<strong class="iw hj">转移矩阵</strong>和<strong class="iw hj">排放矩阵</strong>。下面是一个简单的例子，说明如何构建这些矩阵，并使用它们来预测蜂窝传感器的用户行为:</p><p id="5712" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们假设一个用户可以处于三种状态中的一种——驾驶、行走或就位。让我们假设我们已经标记了数据，用户每分钟报告他们一天中的状态。例如:</p><ul class=""><li id="2213" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">08:00 —地点</li><li id="909b" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">08:01 —地点</li><li id="7762" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">08:02—步行</li><li id="54b9" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">08:03 —开车</li><li id="26ed" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">等等。</li></ul><h2 id="d069" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">跃迁矩阵</h2><p id="5115" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">状态A和状态B之间的转移概率是一个人从状态A转移到状态B的概率。我们可以从标记数据中找到转移概率。例如，<em class="lx"> </em> <strong class="iw hj"> <em class="lx">处</em> </strong>和<strong class="iw hj"> <em class="lx">处</em> </strong>之间的转移概率将是数据中<strong class="iw hj"><em class="lx"/></strong>处<strong class="iw hj"> <em class="lx">处</em> </strong>后的<strong class="iw hj"> <em class="lx">处</em> </strong>分钟的总数。</p><p id="fb66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以用两种方式来描述转移概率——图表或<strong class="iw hj">转移矩阵:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/4e9867b2cd25168c719dc09650f70b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IW_QCeMzr7fgsB5b6kbKRg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">左图:转移概率的图示。右图:相同概率的转移矩阵。</figcaption></figure><h2 id="f0c6" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">马尔可夫链</h2><p id="4b52" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">找到概率后，我们可以基于转移矩阵建立一个<a class="ae md" href="https://en.wikipedia.org/wiki/Markov_chain" rel="noopener ugc nofollow" target="_blank">马尔可夫链</a>。</p><p id="9daf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将从其中一个事件开始这个链，让我们选择<strong class="iw hj"> <em class="lx">地点</em> </strong>。然后我们将“掷骰子”，意思是我们有90%的机会再次获得<strong class="iw hj"> <em class="lx">位置</em> </strong>，7.5%的机会获得<strong class="iw hj"><em class="lx"/></strong>驱动，2.5%的机会获得<strong class="iw hj"> <em class="lx">行走</em> </strong>。由于概率的原因，我们可能会再次得到<strong class="iw hj"> <em class="lx">位置</em> </strong>，我们继续掷骰子，直到到达另一个状态，比如说<strong class="iw hj"> <em class="lx">驱动</em> </strong>。然后我们把“放置骰子”放到一边，使用“驱动骰子”:80%继续<strong class="iw hj"> <em class="lx">驱动</em> </strong>，15%获得<strong class="iw hj"> <em class="lx">放置</em> </strong>，5%获得<strong class="iw hj"><em class="lx"/></strong>。</p><p id="74aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一天结束时，当我们掷出不同的骰子1440次(每天的分钟数)时，我们将得到一系列事件:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/1b61389c402e4a9cba132c63a4a83ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsqg5U1OS-u_3ECDc39QZw.png"/></div></div></figure><p id="1339" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个链还没有与我们从我们的特征中获得的任何信息联系起来(请记住，我们有来自蜂窝传感器的数据)，但它已经存储了关于我们数据性质的非常基本的见解，如每个状态的典型持续时间和典型的状态序列。</p><h2 id="f337" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">发射矩阵</h2><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/22a52f393f400b22a3068d18e74299d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEoTGrchJypp8zVJohbxbQ.png"/></div></div></figure><p id="e06f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们的问题世界中，状态是<strong class="iw hj">隐藏的</strong>，我们需要根据<strong class="iw hj">观察到的</strong>特征来找到它们，这些特征是手机传感器输出(移动、计步、连接到wifi等)。).</p><p id="a0c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了在我们的模型中包含这些特征，我们将构建<strong class="iw hj">发射矩阵</strong>。</p><p id="4122" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是二元要素(只能获得真/假值的要素)的概率矩阵示例:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/ec7c620d36cebac139c14196db9c0ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ld5G7J6zTeAkBnjaj8idhQ.png"/></div></div></figure><p id="9161" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">构建矩阵的方式也非常直接——例如，在<strong class="iw hj"> <em class="lx">位置</em> </strong>状态下看到wifi连接的概率是用户在<strong class="iw hj"> <em class="lx">位置</em> </strong>状态下连接wifi的分钟数除以所有<strong class="iw hj"> <em class="lx">位置</em> </strong>状态下的分钟数。</p><p id="9495" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们已经有了<strong class="iw hj">跃迁矩阵和发射矩阵</strong>，我们可以进入python的实际部分了！</p><h1 id="8d3e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">嗯Python包</h1><p id="5a8b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">当我着手这个项目时，我很难找到一个能够处理多维分类数据的Python包。我确信我会在我心爱的<a class="ae md" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> sklearn </a>中找到它，但是我遇到了三个问题:</p><ol class=""><li id="e45b" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr mh lb lc ld bi translated"><a class="ae md" href="http://scikit-learn.sourceforge.net/stable/modules/hmm.html" rel="noopener ugc nofollow" target="_blank"> sklearn.hmm </a>模块早就不推荐使用了。</li><li id="ac94" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr mh lb lc ld bi translated"><a class="ae md" href="https://ogrisel.github.io/scikit-learn.org/sklearn-tutorial/modules/generated/sklearn.hmm.GaussianHMM.html" rel="noopener ugc nofollow" target="_blank"> GaussianHMM </a>模块支持多种特性，但不支持分类特性。</li><li id="45f8" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr mh lb lc ld bi translated"><a class="ae md" href="https://ogrisel.github.io/scikit-learn.org/sklearn-tutorial/modules/generated/sklearn.hmm.MultinomialHMM.html" rel="noopener ugc nofollow" target="_blank">多项式HMM </a>模块支持单个分类特征，但不支持多个特征。</li></ol><p id="27a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以在谷歌上搜索了一下，我找到了<a class="ae md" href="https://pomegranate.readthedocs.io/en/latest/HiddenMarkovModel.html" rel="noopener ugc nofollow" target="_blank">石榴</a>——一个伟大的Python HMM包，作者是Jacob Schreiber。该软件包非常灵活，易于使用，它支持多种分类和连续的功能！网站上有一些很棒的教程，我想在这里介绍一个关于我如何在我的案例中使用它的小教程。</p><h1 id="f645" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">代码示例</h1><h2 id="c36c" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">(1)一维分类数据</h2><p id="b232" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我们这里的数据是我根据真实数据创建的虚拟数据集。有98分钟，每一分钟我们都有一个计步器。我创建了每分钟4箱步数[0，50，100，150]步。本例中的目标是将分钟分为两种状态:<strong class="iw hj"> <em class="lx">行走</em> </strong>和<strong class="iw hj"> <em class="lx">静止</em> </strong>。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/e9feb9e36112a268a74bac3da37a926f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukeOQOR_Ak1oYVeBG6zNlg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这些数据证明了检测行走部分的挑战，因为我们看到它是有噪声的。</figcaption></figure><h2 id="fca8" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">步骤1:初始化模型并设置排放概率</h2><p id="7097" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为每个状态设置步骤通道的分布:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><ul class=""><li id="1582" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">注意:HiddenMarkovModel()、DiscreteDistribution()和State()都是石榴包的类—不需要实现任何东西:)</li></ul><h2 id="1e50" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">步骤2:设置转移概率和烘焙模型</h2><p id="669c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在这里，我还添加了开始概率，这是从每个状态开始链的概率。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="2f80" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">预测的可视化</h2><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/03dfe799cc44c03d1431cdf3eea9ca87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cv1_A5mZ-xV7YjwHlkGORA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">绿色表示“行走”的片段，白色表示“静止”的片段</figcaption></figure><h2 id="f986" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">(2)多维分类数据</h2><p id="67b4" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">现在，我们可以增加一些复杂性，并为我们的数据增加一个通道(并在以后使用相同的代码添加任意多的通道)。</p><p id="94c3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">除了计步器之外，我们将增加用户位置在前一分钟和当前分钟之间的距离(以米为单位)。让我们将距离分成4个区间:[0，20，50，75]。</p><p id="891b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的数据现在看起来像这样:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/641997726305cc77e9a31e827d03bd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lL7jOU3KB66w1umA_8scKA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">传感器输出与时间的关系。步数用蓝色表示，距离用红色表示，紫色点实际上是红色上面的蓝色</figcaption></figure><h2 id="b521" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">步骤1:初始化模型并设置排放概率</h2><p id="f1db" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这里，我们为每个特性和每个状态创建单独的分布，然后使用IndependentComponentsDistribution组合这些特性。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="423e" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">步骤2:设置转移概率和烘焙模型</h2><p id="ec89" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">一模一样…</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="231f" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">预测的可视化</h2><p id="b9d1" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">预测考虑了来自两个特征的数据:步数和距离。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/8af618aa5265dc8c642fd0bab440bf2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZphqMdAGpCBnHb_ftQE21A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">绿色表示“行走”的片段，白色表示“静止”的片段</figcaption></figure><p id="dad2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，我们不必绑定我们的数据——软件包允许我们使用连续分布，如高斯分布。我们甚至可以将某些特性的离散分布和其他特性的连续分布结合起来。</p><p id="c5f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望你已经发现这个帖子清晰而有用，如果你有任何问题，我很乐意听到你的！</p><p id="18aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我想感谢</p></div></div>    
</body>
</html>