<html>
<head>
<title>Conversion and operations on the non arithmetic data types in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C 语言中非算术数据类型的转换和运算</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/conversion-and-operations-on-the-non-arithmetic-data-types-in-c-6d31e82d5e85?source=collection_archive---------35-----------------------#2020-12-29">https://medium.com/analytics-vidhya/conversion-and-operations-on-the-non-arithmetic-data-types-in-c-6d31e82d5e85?source=collection_archive---------35-----------------------#2020-12-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="97ea" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">有哪些不同的 C 数据类型？</h1><p id="8f10" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">C 标准将它的可用类型分成两大类<strong class="je hi"><em class="ka"/></strong>:对象类型和函数类型。</p><p id="6316" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">C 中的<strong class="je hi"> <em class="ka">对象类型</em> </strong>有:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="74e6" class="kp if hh kl b fi kq kr l ks kt">Integer types such as int  , short  , enum  …<br/>Floating point number types such as float  , double , long double .<br/>Structures<br/>Unions<br/>Arrays<br/>Pointers<br/>Atomic<br/>void</span></pre><p id="978a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在 C 中，对象类型也有<strong class="je hi"> <em class="ka">多种概念划分</em> </strong>。例如，标量类别是由整数(如<code class="du ku kv kw kl b">int</code>)和浮点类型(如<code class="du ku kv kw kl b">float</code>)以及指针组成的类别。</p><p id="7dd1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个关于算术类型之间转换的教程，可以在这里找到<a class="ae kx" href="http://twiserandom.com/c/what-is-widening-truncation-promotion-and-conversion-between-the-different-c-arithmetic-data-types/" rel="noopener ugc nofollow" target="_blank"/>，这个<strong class="je hi"> <em class="ka">教程是关于</em> </strong>转换，非算术类型之间的转换。</p><h1 id="0f72" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">什么是虚空型？</h1><p id="7a39" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">void 类型<strong class="je hi"> <em class="ka">可以理解为</em> </strong> <em class="ka">为</em>一个值的缺席。<br/> <strong class="je hi"> <em class="ka">例如</em> </strong> <em class="ka"> </em>，当声明一个函数有一个 void 返回类型时，这意味着这个函数没有返回值。此外，当声明该函数具有未命名的 void 参数类型时，这意味着该函数没有参数，因此它不带任何参数。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b1df" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="d4f2" class="kp if hh kl b fi ky kr l ks kt">void helloWorld(void ){<br/>    printf("hello world \n" );<br/>    /*The helloWorld function , has no parameters , <br/>      as such it has one parameter of type void . <br/>      It returns no values , as such as its <br/>      return type , it also has the void type .*/}</span><span id="909d" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>    helloWorld( );}<br/>/*Output : <br/>hello world .*/</span></pre><p id="3eb2" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">void 类型，也可用于<strong class="je hi"> <em class="ka">忽略任何值</em> </strong>，由任何表达式返回。因此，转换为 void 类型的表达式，其值会被忽略或丢弃。计算一个空表达式的副作用</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a962" class="kp if hh kl b fi kq kr l ks kt">(void) 1 ; <br/>/* The literal 1 is of the int type , <br/>   it is cast to the void type . The <br/>   result is an expression of the <br/>   void type , as a consequence , <br/>   the expression has no value .*/</span><span id="1653" class="kp if hh kl b fi ky kr l ks kt">void helloWorld(void ){<br/>    printf("hello world \n" );}</span><span id="b781" class="kp if hh kl b fi ky kr l ks kt">helloWorld("Hello world" );<br/>/*The expression , has a void type , <br/>  since the return type of the <br/>  helloWorld function is void . As<br/>  a consequence , the expression has<br/>  no value .  The  helloWorld function , <br/>  is used for printing the message <br/>  Hello world .*/</span></pre><p id="d4a9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">类型为 void，<strong class="je hi"> <em class="ka">的表达式不能被</em> </strong>转换为任何其他类型。</p><h1 id="153a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">指针类型</h1><h2 id="f5ee" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">有哪些不同的可用指针类型？</h2><p id="5485" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><code class="du ku kv kw kl b">C</code> <strong class="je hi"> <em class="ka">中的指针可以是指向</em> </strong> <em class="ka">一个对象类型的指针，也可以是指向一个函数的指针。</em></p><h2 id="915d" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">哪些整数类型能够存储指针？</h2><p id="37c9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">指针保存着</em> </strong>的一个地址。地址有数值，也有类型。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c156" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="74a3" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>    int val_i = 1 ; <br/>    /*Declare and initialize the <br/>      variable val_i .*/</span><span id="e694" class="kp if hh kl b fi ky kr l ks kt">int *ptr_i = &amp;val_i;<br/>    /*ptr_i is a pointer to an int .<br/>     It contains a numeric value , <br/>     which is the address of <br/>     val_i . This address is of type <br/>     int . So when dereferencing <br/>     this address , a specific number of <br/>     bits , equal to the number of bits <br/>     in the type int , is read .*/</span><span id="27a1" class="kp if hh kl b fi ky kr l ks kt">printf("<a class="ae kx" href="http://twitter.com/address" rel="noopener ugc nofollow" target="_blank">@address</a> : %p -&gt; value : %d\n", ptr_i , *ptr_i ) ;<br/>    /*Print the address stored in ptr_i ,<br/>      and dereference the address , <br/>      to get the stored value .*/</span><span id="c2fd" class="kp if hh kl b fi ky kr l ks kt">/*Output :<br/><a class="ae kx" href="http://twitter.com/address" rel="noopener ugc nofollow" target="_blank">@address</a> : 0x7fff59e438ec -&gt; value : 1 */}</span></pre><p id="8a5b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">指针 中存储的<strong class="je hi"> <em class="ka">数值为整数数据类型。C 标准规定，存储在指针中的整数数据类型可以存储在<code class="du ku kv kw kl b">intptr_t</code>和<code class="du ku kv kw kl b">uintptr_t</code>中。因此，指针和<code class="du ku kv kw kl b">intptr_t</code>或<code class="du ku kv kw kl b">uintptr_t</code>之间的转换总是由 C 标准定义的。在<code class="du ku kv kw kl b">stdint.h</code>标题中定义了<code class="du ku kv kw kl b">intptr_t</code>和<code class="du ku kv kw kl b">uintptr_t</code>。</em></strong></p><p id="57bd" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">对于<strong class="je hi"><em class="ka"/></strong>其他整数数据类型，如果指针的整数值，大于要转换为的范围，整数数据类型，则转换的结果不定义。反之，如果整数数据类型值的位数大于<code class="du ku kv kw kl b">intptr_t</code>或<code class="du ku kv kw kl b">uintptr_t</code>，则转换结果未定义。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="464d" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;<br/>#include&lt;stdint.h&gt;</span><span id="edc8" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="c8d6" class="kp if hh kl b fi ky kr l ks kt">int val_i = 1 ; <br/>  /*Declare an int variable <br/>    val_i , and  initialize <br/>    it , with 1 .*/</span><span id="622e" class="kp if hh kl b fi ky kr l ks kt">int *ptr_i = &amp;val_i;<br/>  /*Declare a pointer to an integer , <br/>    and initialize it with the address<br/>    of val_i */</span><span id="a2d7" class="kp if hh kl b fi ky kr l ks kt">uintptr_t t_uip = (uintptr_t) ptr_i;<br/>  /*Cast a pointer to uintptr_t */</span><span id="5adc" class="kp if hh kl b fi ky kr l ks kt">printf("ptr_i : %p , t_uip : %#lx\n" , ptr_i , t_uip );<br/>  /*Print the address stored in the pointer<br/>    ptr_i , and the hexadecimal numeric value<br/>    stored in t_uip .*/</span><span id="3ad8" class="kp if hh kl b fi ky kr l ks kt">ptr_i = (int * ) t_uip;<br/>  /*Cast the integer value stored <br/>    in t_uip , to a pointer , to an <br/>    int ,  and assign the result<br/>    to ptr_i .*/</span><span id="e509" class="kp if hh kl b fi ky kr l ks kt">printf("ptr_i : %p , *ptr_i : %d\n" , ptr_i , *ptr_i );<br/>  /*Print the address of ptr_i , and the <br/>      value stored by the address <br/>      referenced by ptr_i .*/<br/>}</span><span id="bc48" class="kp if hh kl b fi ky kr l ks kt">/*Output : <br/>ptr_i : 0x7fff599d88ec , t_uip : 0x7fff599d88ec<br/>ptr_i : 0x7fff599d88ec , *ptr_i : 1 */</span></pre><h1 id="bf83" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">什么是指向 void 的指针？</h1><p id="bc28" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个指向 void 的指针，或者说 void 指针，<strong class="je hi"> <em class="ka">可以理解为含义</em> </strong>，那对于现在来说，指针的类型，是不感兴趣的。在这种情况下，缺少值是地址的类型，而不是存储在地址中的数值。如前所述，指针变量存储地址。地址有一个数值和一个类型。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b986" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="0c43" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  void *ptr_v = (void *) 1 ;<br/>  /*1 is an int literal , an integer<br/>   can be cast to any pointer type .<br/>   In this case , it is cast to <br/>   a pointer to void .<br/>   The gotten address has a numeric value , <br/>   it has a void type , as such it does <br/>   not hava a type .*/<br/>  printf("The stored address in ptr_v numeric value is : %p\n" , ptr_v );}</span><span id="3672" class="kp if hh kl b fi ky kr l ks kt">/*Output : <br/>The stored address in ptr_v numeric value is : 0x1 .*/</span></pre><p id="89ae" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">任何<strong class="je hi"> <em class="ka">类型的指针都可以被转换成</em> </strong>类型的空指针，而任何空指针类型，都可以被转换成任何指针类型。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a2e1" class="kp if hh kl b fi kq kr l ks kt">/*In this First example , any pointer sent to<br/>  the printAddressVar function , is<br/>  cast to a void pointer .<br/>  The printAddressVar function , prints<br/>  the numeric value of the address<br/>  stored in the pointer .*/</span><span id="68d4" class="kp if hh kl b fi ky kr l ks kt">#include&lt;stdio.h&gt;</span><span id="321e" class="kp if hh kl b fi ky kr l ks kt">void printAddressVar(void *var_vptr){<br/>  printf("%p\n" , var_vptr );}</span><span id="37e9" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  int flowers_i = 10 ;<br/>  printAddressVar(&amp;flowers_i );<br/>  float angle_f = 3.4f;<br/>  printAddressVar(&amp;angle_f );<br/>  double elevation_d = 1.3;<br/>  printAddressVar(&amp;elevation_d );}<br/>/*Output : <br/>0x7fff5dc4f8e4<br/>0x7fff5dc4f8e0<br/>0x7fff5dc4f8d8 */</span><span id="0a5d" class="kp if hh kl b fi ky kr l ks kt">/*Second example .*/</span><span id="cf2e" class="kp if hh kl b fi ky kr l ks kt">#include&lt;stdio.h&gt;</span><span id="4b5e" class="kp if hh kl b fi ky kr l ks kt">int add (int x , int y ){return x+y; };<br/>int sub (int x , int y ){return x-y; };<br/>int mul (int x , int y ){return x*y; };<br/>/*Declare , the add , sub , and multiply<br/>  function .*/</span><span id="d290" class="kp if hh kl b fi ky kr l ks kt">typedef int (* fct_signature ) (int , int) ;<br/>/*fct_signature is alias to :  pointer to a<br/>  function that takes two int , and<br/>  returns , an int .*/</span><span id="5c90" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  void *arr_vptr[] = {add , sub , (void *) mul };<br/>  /*add , sub , mul , are functions .<br/>    A pointer to each , has a signature of<br/>    int (* ) (int , int ) .<br/>    Each pointer to each function is cast<br/>    to the void pointer . <br/>    The gotten casts are stored in<br/>    the array arr_vptr .*/</span><span id="5dd4" class="kp if hh kl b fi ky kr l ks kt">int x = 1 , y = 2 , result = 0;</span><span id="c732" class="kp if hh kl b fi ky kr l ks kt">result = ((fct_signature ) arr_vptr[0] )(x , y );<br/>  /*Cast arr_vptr[0] to a pointer to a function .<br/>    The pointer to the function has a signature :<br/>    int (* ) (int , int ). After the casting ,<br/>    the function is called .*/<br/>  printf("%d\n" , result );<br/>  /*Output : 3 */</span><span id="c4ca" class="kp if hh kl b fi ky kr l ks kt">result = ((int (* ) (int , int )) arr_vptr[1] )(x , y );<br/>  printf("%d\n" , result );<br/>  /*Output : -1 */</span><span id="f24f" class="kp if hh kl b fi ky kr l ks kt">result = ((fct_signature ) arr_vptr[2] )(x , y );<br/>  printf("%d\n" , result );<br/>  /*Output : 2 */}</span></pre><h2 id="a97f" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">什么是空指针？</h2><p id="a6ca" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">空指针常量，或简称为空指针，<strong class="je hi"> <em class="ka">由 C 标准的</em> </strong>定义，作为具有值的常量文字<code class="du ku kv kw kl b">0</code>。<br/>空指针常量，也是由 C 标准定义的，将它的常量文字值<code class="du ku kv kw kl b">0</code>转换为指向 void 类型的指针。这两个定义是相等的，或者说是相同的。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="14ba" class="kp if hh kl b fi kq kr l ks kt">#define NULL_PTR_CONSTANT 0</span><span id="117d" class="kp if hh kl b fi ky kr l ks kt">#define NULL_PTR_CONSTANT ((void* ) 0 )</span></pre><p id="14a4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du ku kv kw kl b"><em class="ka">NULL</em></code> <strong class="je hi"> <em class="ka">宏，是标准头文件<code class="du ku kv kw kl b">stddef.h</code>中定义的</em> </strong>，为空指针常量。</p><p id="f400" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">空指针常量可以被</em> </strong>强制转换为任何其他指针类型，结果是一个空指针，属于那种类型。所有空指针比较起来都是相等的。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="698d" class="kp if hh kl b fi kq kr l ks kt">#define NULL ((int * ) 0 )<br/>/*Cast the null pointer 0 , to<br/>  a pointer to an int , the <br/>  result is a null pointer .*/</span><span id="db05" class="kp if hh kl b fi ky kr l ks kt">#include&lt;stdio.h&gt;</span><span id="9d40" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  printf("%d\n" , (int *) 0 == 0 ); <br/>  /*All null pointers are equal , printf <br/>    outputs 1 , which is true . <br/>    1 */}</span></pre><p id="95a0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">空指针不等于非空指针，所以空指针不等于没有值<code class="du ku kv kw kl b">0</code>的指针。在指针变量的初始化中，可以使用空指针</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9d1b" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="a2a2" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>    int var_i = 1 ;</span><span id="1f4c" class="kp if hh kl b fi ky kr l ks kt">int *var2_ip = &amp;var_i;<br/>    /*Initialize var2_ip with the address <br/>      of var_i .*/</span><span id="d99b" class="kp if hh kl b fi ky kr l ks kt">int *var3_ip = 0 ;<br/>    /* The null pointer constant 0<br/>       is cast , to (int * ) , the<br/>       result is  a null pointer of the <br/>       int type , the null pointer <br/>       is stored in var3_ip .*/<br/>    <br/>    printf("%d\n" , var3_ip != var2_ip );<br/>    /*A null pointer is not equal , to a <br/>      not null pointer , as such , printf<br/>      outputs 1 , which is true .*/}</span></pre><p id="b17d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">空指针常量<strong class="je hi"> <em class="ka">可以理解为</em> </strong>，本身具有常量文字<code class="du ku kv kw kl b">0</code>的值，用来表示空指针的位模式不一定都是<code class="du ku kv kw kl b">0</code>。空指针常量表示地址中缺少数值，因此取消空指针的引用是未定义的。地址本身可以是无类型的，比如在<code class="du ku kv kw kl b">void</code>空指针的情况下，或者是有类型的，比如在<code class="du ku kv kw kl b">int</code>空指针的情况下。</p><p id="6c0e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">将空指针常量<strong class="je hi"> <em class="ka">转换为整数类型</em> </strong>会产生<code class="du ku kv kw kl b">0</code>，因为空指针的值，而不是空指针解引用的值，是常量文字<code class="du ku kv kw kl b">0</code>。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="bb23" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="62da" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="84da" class="kp if hh kl b fi ky kr l ks kt">void *ptr_v = 0 ;<br/>  printf("%d\n" , (int ) ptr_v );</span><span id="3c02" class="kp if hh kl b fi ky kr l ks kt">int *ptr_i = 0;<br/>  printf("%d\n" , (int ) ptr_i ); }<br/>/*Output :                                                                                                                  <br/>0<br/>0*/</span></pre><h2 id="898c" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">强制转换对象类型指针</h2><p id="b86e" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">要记住</em> </strong>的关键一点，就是指针存储的是一个地址。地址有一个数值，因为 C 是一种类型化语言，所以地址有一个类型。<br/>在处理对象类型指针之间的转换时，存储在地址中的数值不会改变，只有地址的类型会被重新解释。</p><p id="2415" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">话虽如此，<strong class="je hi"> <em class="ka">对象类型指针，可以在</em> </strong> <em class="ka"> </em>之间相互转换，唯一的要求就是对象类型有一个共同的对齐方式。对齐是对象在内存中可以放置的位置。如果对象类型没有公共的对齐方式，则将一个指针转换为另一个指针的结果是不定义的。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="3d15" class="kp if hh kl b fi kq kr l ks kt">/*Example 1 */</span><span id="c8c3" class="kp if hh kl b fi ky kr l ks kt">#include&lt;stdio.h&gt;</span><span id="002d" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  <br/>  float var_f = 1.0f ;<br/>  int var_i = (int ) var_f ; <br/>  /*Casting a float type to an int <br/>    type , will change its bit <br/>    representation .<br/>    1.0f is encoded as :   <br/>      00111111100000000000000000000000<br/>    1 is encoded as :<br/>      00000000000000000000000000000001*/</span><span id="cb7e" class="kp if hh kl b fi ky kr l ks kt">printf("%f , %d\n" , var_f , var_i );<br/>  /*Output : <br/>    1.000000 , 1 */</span><span id="728d" class="kp if hh kl b fi ky kr l ks kt">float *ptr_f = &amp;var_f ;<br/>  int *ptr_i = (int *) ptr_f ;<br/>  /*ptr_f is cast to a pointer <br/>      to an int . The address <br/>      stored in ptr_f is copied to <br/>      ptr_i . <br/>    The bit pattern stored at that <br/>      address did not change . It is <br/>      00111111100000000000000000000000 */<br/>    printf("%f , %d\n" , *ptr_f , *ptr_i );<br/>    /*Output : <br/>      1.000000 , 1065353216 */ }</span><span id="487f" class="kp if hh kl b fi ky kr l ks kt">/*Example 2 */</span><span id="3f9f" class="kp if hh kl b fi ky kr l ks kt">#include&lt;stddef.h&gt;<br/>#include&lt;stdio.h&gt;</span><span id="d378" class="kp if hh kl b fi ky kr l ks kt">void toHex(unsigned char *ptr_uc , size_t size_data ){<br/>    printf("%p : " , ptr_uc );<br/>    /*Print the address of ptr_uc */<br/>    for(size_t i = 0 ; i &lt; size_data ; i++ )<br/>        printf("%02x" , ptr_uc[i] );<br/>        /*Print the hexadecimal representation <br/>          Of data .*/<br/>    printf("\n" );}</span><span id="3c2c" class="kp if hh kl b fi ky kr l ks kt">struct flag{<br/>  unsigned char num_stars ;<br/>  unsigned int num_colors;<br/>};</span><span id="83f4" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  struct flag var_struct_flag = {255 , 4294967295 };<br/>  toHex((unsigned char *)&amp;var_struct_flag , sizeof(struct flag ));<br/>  /*Output : <br/>    0x7fff539528e8 : ff000000ffffffff , <br/>      address         data hex dump<br/>    The structure is padded with 6 bytes , <br/>    this is why , there are six 0 between<br/>    255 , and 4294967295 .*/</span><span id="9359" class="kp if hh kl b fi ky kr l ks kt">struct flag var_struct_flag1 = {0 , 0x0000FFFF };<br/>  toHex((unsigned char *)&amp;var_struct_flag1 , sizeof(struct flag ));}<br/>  /*Output : <br/>    0x7fff599b68e0 : 00000000ffff0000 <br/>       adress         data hex dump<br/>    This is a little Indian machine , <br/>    since the int type is stored in<br/>    reverse .*/</span></pre><p id="94cc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">如前所述</em> </strong> <em class="ka"> </em>，空指针可以被转换成任何其他指针，反之亦然，而空常量指针，可以被转换成任何其他指针。</p><h2 id="7e45" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">合格和不合格指针类型之间的转换</h2><p id="f0c9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">C 标准定义，将一个指向非限定类型的指针，比如<code class="du ku kv kw kl b">int *</code>，强制转换为限定类型的指针，比如<code class="du ku kv kw kl b">const int *</code>、<strong class="je hi">、<em class="ka">总是定义为</em>、</strong>。</p><p id="4c8f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">C 语言中<strong class="je hi"> <em class="ka">可用的类型限定符</em> </strong>有<code class="du ku kv kw kl b">const</code>、<code class="du ku kv kw kl b">volatile</code>、<code class="du ku kv kw kl b">restrict</code>和<code class="du ku kv kw kl b">_Atomic</code>。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9026" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="7f1d" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  int var_i = 1 ;<br/>  int *ptr_i = &amp;var_i ;<br/>  const int *ptr_ci = ptr_i;<br/>  /* *ptr_ci = 10;<br/>     is illegal , because the<br/>     pointer is a pointer to<br/>     a const int. */<br/>  *ptr_i = 10 ;<br/>  /* Legal , because the pointer<br/>     is a pointer to an int .*/}</span></pre><h2 id="8329" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">强制转换函数类型指针</h2><p id="f73a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi">、<em class="ka">的指针可以在</em>、</strong>之间相互转换。此外，如前所述，void 类型可以转换为任何其他类型，任何其他类型都可以转换为 void 类型，空常量指针可以转换为任何其他指针类型。</p><p id="9674" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果指向一个函数的指针被强制转换为指向另一个函数、指针类型和目标函数类型，则<strong class="je hi"> <em class="ka">与</em> </strong>源函数类型不兼容，调用使用目标类型的函数，未定义。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c326" class="kp if hh kl b fi kq kr l ks kt">int negate(int x ) {return -x ;}<br/>int subtract(int x , int y ) {return x-y ;}</span><span id="1e0e" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  int (* sig1_ptr ) (int )  = negate;<br/>  int (* sig2_ptr ) (int , int ) = subtract;<br/>  sig2_ptr = (int (* ) (int , int ))  sig1_ptr;<br/>    /* Any function pointer can be cast<br/>       to any other function pointer .<br/>       If the signature of the casted <br/>       function , is not compatible with the  <br/>       signature of the pointer function type , <br/>       calling the function pointed by the <br/>       pointer , is not defined . Hence <br/>       sig2_ptr(1 , 1 ) is not defined .*/ }</span></pre><h2 id="18b3" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">比较指针的顺序</h2><p id="54ec" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">关系运算符</em> </strong>、小于<code class="du ku kv kw kl b">&lt;</code>、小于等于<code class="du ku kv kw kl b">&lt;=</code>、大于<code class="du ku kv kw kl b">&gt;</code>、大于等于<code class="du ku kv kw kl b">&gt;=</code>，可以用来比较顺序。</p><p id="2334" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">比较指针的顺序，<strong class="je hi"> <em class="ka">仅针对</em> </strong>对象类型指针定义，仅在比较指针与结构、数组和联合的成员时使用。</p><p id="350b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">指向结构中的对象的指针，在同一结构中的对象之后声明，或者指向数组中的元素的指针，其位置比同一数组中的元素更高，顺序也更高。<br/>反过来也是如此，所以指针<strong class="je hi"> <em class="ka">指向的对象在</em> </strong> <em class="ka">一个</em>结构中，声明在同一个结构中的对象之前，或者到一个数组中的元素之前，有一个位置较低的，那么同一个数组中的元素，有一个较低的顺序。<br/><strong class="je hi"><em class="ka">最后一个元素可比</em> </strong>为数组中的顺序，等于数组长度加一。</p><p id="6c1e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">指向同一个 的任意<strong class="je hi"> <em class="ka">成员的指针，具有相同的顺序。指向相同数组成员或相同结构成员的指针，具有相同的指针地址:类型和数值，也具有相同的顺序。</em></strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="df26" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="f382" class="kp if hh kl b fi ky kr l ks kt">struct rational {<br/>  int numerator ;<br/>  int denominator; };</span><span id="e6d1" class="kp if hh kl b fi ky kr l ks kt">union search{<br/>  int close_i ;<br/>  int far_i; };</span><span id="7d9b" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="fc21" class="kp if hh kl b fi ky kr l ks kt">struct rational var_rat = {1 , 2 };</span><span id="1140" class="kp if hh kl b fi ky kr l ks kt">int *num_ip = &amp;var_rat.numerator ;<br/>  /*Store the address of numerator , in<br/>    the pointer num_ip*/<br/>  int *den_ip = &amp;var_rat.denominator ;<br/>  /*Store the address of denominator ,<br/>    in the pointer den_ip */</span><span id="d6cf" class="kp if hh kl b fi ky kr l ks kt">printf("%d\n" , num_ip &lt; den_ip );<br/>  /*numerator is declared before denominator ,<br/>   in struct rational , as such its address<br/>   has a lower order .<br/>   Output : 1 .*/</span><span id="5552" class="kp if hh kl b fi ky kr l ks kt">union search var_ser;</span><span id="386a" class="kp if hh kl b fi ky kr l ks kt">int *close_ip = &amp;var_ser.close_i;<br/>  int *far_ip = &amp;var_ser.far_i;</span><span id="d305" class="kp if hh kl b fi ky kr l ks kt">printf("%d\n" , close_ip &lt;= far_ip );<br/>  /*close_i and far_i , are member of the<br/>    same union , as such their address<br/>    have the same order ,<br/>    Output : 1 .*/<br/>  printf("%d\n" , close_ip &lt; far_ip );<br/>  /*close_i and far_i , are member of the<br/>    same union , as such their address<br/>    have the same order ,<br/>    Output : 0 .*/</span><span id="a55b" class="kp if hh kl b fi ky kr l ks kt">int arr_i[] = {1 };</span><span id="0645" class="kp if hh kl b fi ky kr l ks kt">printf("%d\n" , arr_i &lt; arr_i + 1 );<br/>  /*address last element of array<br/>    plus one , has higher order than<br/>    preceding element .<br/>    Output : 1 .*/<br/>  printf("%d\n" , num_ip &lt;= &amp;var_rat.numerator );<br/>  /*Pointers same member of structure ,  are<br/>    equal .*/}</span></pre><h2 id="b158" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">比较指针是否相等</h2><p id="23db" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">当使用等式<code class="du ku kv kw kl b">==</code>或差分运算符<code class="du ku kv kw kl b">!=</code>、<strong class="je hi">、<em class="ka">时，两个指针等于</em>、</strong>，如果存储的地址具有相同的数值和相同的类型。</p><p id="6c46" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果一个操作数是指针，第二个是空指针常量，那么在执行比较之前，<strong class="je hi"> <em class="ka">空指针常量</em> </strong>被转换为指针类型。</p><p id="7b72" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果一个操作数是指向对象类型的指针，而另一个操作数是指向 void  的合格或不合格<strong class="je hi"> <em class="ka">指针，那么对象指针就被强制转换为指向 void 的合格或不合格指针。</em></strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b586" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="7179" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  int var_i = 1;<br/>  int *ptr_i = &amp;var_i;<br/>  int *ptr1_i = &amp;var_i;</span><span id="262a" class="kp if hh kl b fi ky kr l ks kt">double var_d = 1.0;<br/>  void *ptr_v = &amp;var_d;</span><span id="4036" class="kp if hh kl b fi ky kr l ks kt">printf("%d\n" , ptr_i == ptr1_i );<br/>  /*Both ptr_i , and ptr1_i , address <br/>    contain the same numeric value , <br/>    and type , they are equal<br/>    Output : 0.*/</span><span id="0b40" class="kp if hh kl b fi ky kr l ks kt">printf("%d\n" , ptr_i == 0 );<br/>  /*The constant pointer literal<br/>    0 , is cast to a null pointer<br/>    literal of the type int . <br/>    A null pointer is not equal <br/>    to a non null pointer , as such<br/>    the result is false .<br/>    Output : 0.*/</span><span id="167a" class="kp if hh kl b fi ky kr l ks kt">printf("%d\n" , ptr_i == ptr_v );<br/>  /*ptr_v is a void pointer , ptr_i<br/>    is cast to a void pointer , the<br/>    numeric value of the address are<br/>    not equal , as such the result<br/>    is false .<br/>    Output : 0 .*/ }</span></pre><h1 id="4a89" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">逻辑运算符</h1><p id="2eb5" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">逻辑运算符，and <code class="du ku kv kw kl b">&amp;&amp;</code>，or <code class="du ku kv kw kl b">||</code>，not <code class="du ku kv kw kl b">!</code>，<strong class="je hi">，<em class="ka">可以与</em>，</strong>，<em class="ka">一起用于</em>标量类型。标量类型是整数类型、浮点类型和指针类型。</p><p id="a772" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果<code class="du ku kv kw kl b">&amp;&amp;</code>的任何一个操作数是<code class="du ku kv kw kl b">0</code>，它将产生<code class="du ku kv kw kl b">0</code>。</p><p id="4c7c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du ku kv kw kl b">||</code>将产生<code class="du ku kv kw kl b">1</code>，如果它的任何一个操作数是<code class="du ku kv kw kl b">1</code>。</p><p id="d418" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果其操作数为<code class="du ku kv kw kl b">0</code>，则<code class="du ku kv kw kl b">!</code>将产生<code class="du ku kv kw kl b">1</code>，否则产生<code class="du ku kv kw kl b">1</code>。</p><p id="ee97" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">所以<strong class="je hi"> <em class="ka">在指针的情况下，如果</em> </strong>指针是空指针，那么<code class="du ku kv kw kl b">&amp;&amp;</code>将产生假或<code class="du ku kv kw kl b">0</code>，如果指针不是空指针，那么<code class="du ku kv kw kl b">||</code>将产生真，或<code class="du ku kv kw kl b">1</code>。至于<code class="du ku kv kw kl b">!</code>，如果指针不是空指针，它将产生<code class="du ku kv kw kl b">0</code>，如果指针是空指针，它将产生<code class="du ku kv kw kl b">1</code>。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0818" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="cc75" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  int var_i = 1 ;<br/>  int *ptr_i = 0;<br/>  if(!ptr_i )<br/>    /* Apply , the not operator ,<br/>      on ptr_i . ptr_i is the null<br/>      pointer , it has a value of 0 ,<br/>      as such after applying the not<br/>      operator , it will have a value of<br/>      1 . When 1 , if execute , the<br/>      following statement , which initialize<br/>      the pointer to the address of<br/>      var_i .*/<br/>    ptr_i = &amp;var_i;<br/>  if(ptr_i || 0 )<br/>    /* ptr_i , is not null , as such<br/>      || does not evaluate the ,<br/>      second expression , and returns<br/>      1. On 1 , if exceutes the<br/>      following statement , which<br/>      prints the value found , <br/>      in ptr_i .<br/>      Output : 1 .*/<br/>    printf("%d\n", *ptr_i );<br/>  if(ptr_i &amp;&amp; 0 )<br/>    /* ptr_i is not a null pointer ,<br/>      &amp;&amp; evaluates 0 . On 0 ,<br/>      it returns 0 .<br/>      If , on 0 , does not execute , <br/>      the next statement , hence<br/>      printf is not executed .*/<br/>    printf("%d\n", *ptr_i );}</span></pre><h2 id="b24b" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">添加</h2><p id="657a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于指针类型，使用加法运算符，<code class="du ku kv kw kl b">+</code>，<strong class="je hi"/>时定义，<em class="ka">，一个操作数是整数类型，第二个操作数是指向完整对象类型的指针。</em></p><p id="67ff" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">完整的对象类型</em> </strong>，是一个有大小的对象。例如，void 类型不是一个完整的对象类型，因为它没有大小，一个已声明但未定义的结构，因此它没有主体，这是不完整类型的另一个示例。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="fee5" class="kp if hh kl b fi kq kr l ks kt">struct t_s;</span></pre><p id="620f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">当将一个整数值加到存储在指针中的数值上时，加到 上的不是整数值<strong class="je hi"> <em class="ka">，而是指针指向的乘以对象大小的整数值。</em></strong></p><p id="7ff1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">对于指针的整数加法，<strong class="je hi"> <em class="ka">有效</em> </strong>，指针必须是指向数组对象成员的指针，或者是指向数组最后一个对象成员之后的元素的指针，加法的结果必须是指向数组对象的指针，或者是指向数组最后一个对象之后的元素的指针，否则不定义指针加法。</p><p id="9d17" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">数组最后一个对象成员之后的元素是<strong class="je hi"> <em class="ka">不一定是空的</em> </strong>指针，但是在所有情况下都不能使用<code class="du ku kv kw kl b">*</code>操作符取消引用。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="e8c5" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="1b7c" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="06c9" class="kp if hh kl b fi ky kr l ks kt">float arr_f[] = {1.0f , 2.0f };<br/>  float *ptr_f = &amp;arr_f[0 ];</span><span id="5e3d" class="kp if hh kl b fi ky kr l ks kt">printf("sizeof(float ) : %zd\n\n" , sizeof(float ));<br/>  /*Print the size of the type of the object<br/>    pointed by ptr_f */</span><span id="2bf5" class="kp if hh kl b fi ky kr l ks kt">printf(" %p : ptr_f\n %p : ptr_f+0\n %p : ptr_f+1\n %p : ptr_f+2 \n" ,<br/>                ptr_f , ptr_f + 0 , ptr_f + 1 , ptr_f + 2  );<br/>  /*Perform pointer addition , and print the<br/>   successive addresses .<br/>   add 0 , 1 , and 2 , to ptr_f . <br/>   ptr_f points to the first element ,<br/>   of the array arr_f . The addition , <br/>   is defined , as long as<br/>   the gotten pointer , is a pointer to an<br/>   element of the array arr_f , or one past ,<br/>   the last element , of the array arr_f .*/</span><span id="6db1" class="kp if hh kl b fi ky kr l ks kt">printf("ptr_f + 2 == (void * ) 0 -? %d \n\n\n" , (ptr_f + 2 )  == 0 );<br/>  /*The element past the last object ,<br/>    member of an array , is not<br/>    necessarily the null pointer ,<br/>    and it must not be dereferenced  .*/</span><span id="8cb0" class="kp if hh kl b fi ky kr l ks kt">char *ptr_c = (char * ) ptr_f;<br/>  /*Cast the pointer ptr_f , to a<br/>    pointer to a char .*/</span><span id="ef4f" class="kp if hh kl b fi ky kr l ks kt">printf("sizeof(char ) : %zd\n\n" , sizeof(char ));<br/>  /*Print the size of the type<br/>    of the object , pointed by<br/>    ptr_c .*/</span><span id="2f33" class="kp if hh kl b fi ky kr l ks kt">printf(" %p : ptr_c\n %p : ptr_c+0\n %p : ptr_c+1\n %p : ptr_c+2 \n"<br/>         " %p : ptr_c+3\n %p : ptr_c+4\n %p : ptr_c+5 \n"<br/>         " %p : ptr_f+6\n %p : ptr_c+7\n %p : ptr_c+8  \n\n\n"<br/>         , ptr_c , ptr_c + 0 , ptr_c + 1 , ptr_c + 2 , ptr_c + 3 , ptr_c + 4<br/>         , ptr_c + 5 , ptr_c + 6 , ptr_c + 7 , ptr_c + 8 );<br/>  /*Perform pointer addition . The pointer is now a pointer<br/>    to an object of type char . The addition is still valid ,<br/>    as long as the gotten pointer , is a pointer to<br/>    an object in the array , or one past the last<br/>    oject in the array . The array is now interpreted ,<br/>    as being , an array of characters .*/}</span><span id="e69f" class="kp if hh kl b fi ky kr l ks kt">/*Output : <br/>sizeof(float ) : 4</span><span id="a01e" class="kp if hh kl b fi ky kr l ks kt">0x7fff5230c8c0 : ptr_f<br/> 0x7fff5230c8c0 : ptr_f+0<br/> 0x7fff5230c8c4 : ptr_f+1<br/> 0x7fff5230c8c8 : ptr_f+2 <br/>ptr_f + 2 == (void * ) 0 -? 0</span><span id="1a7b" class="kp if hh kl b fi ky kr l ks kt">sizeof(char ) : 1</span><span id="82f1" class="kp if hh kl b fi ky kr l ks kt">0x7fff5230c8c0 : ptr_c<br/> 0x7fff5230c8c0 : ptr_c+0<br/> 0x7fff5230c8c1 : ptr_c+1<br/> 0x7fff5230c8c2 : ptr_c+2 <br/> 0x7fff5230c8c3 : ptr_c+3<br/> 0x7fff5230c8c4 : ptr_c+4<br/> 0x7fff5230c8c5 : ptr_c+5 <br/> 0x7fff5230c8c6 : ptr_f+6<br/> 0x7fff5230c8c7 : ptr_c+7<br/> 0x7fff5230c8c8 : ptr_c+8 */</span></pre><h2 id="2d08" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">减法</h2><p id="b3a6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">减法<em class="ka">是</em> <strong class="je hi"> <em class="ka">为指针</em> </strong>定义的，当进行减法时，是将一个指针减法到一个完整的对象类型，再从另一个指针减法到一个完整的对象类型。当从整数值中减去指向完整对象类型的指针时，也为指针定义了减法。一个完整的对象类型是有大小的。</p><p id="90f8" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">为了使两个指针<strong class="je hi"> <em class="ka">相减有效</em> </strong>，它们必须指向属于同一个数组的对象。指向元素，越过属于数组的最后一个对象，也是允许的。</p><p id="a012" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">从另一个指针中减去一个指针的结果是类型<code class="du ku kv kw kl b">ptrdiff_t </code>。这个结果<strong class="je hi"> <em class="ka">是两个指针之间的距离</em> </strong>，作为这两个指针的对象类型的大小的计数。<code class="du ku kv kw kl b">ptrdiff_t</code>被定义，在<code class="du ku kv kw kl b">stddef.h</code>头中。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="3b6a" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="1a20" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="622a" class="kp if hh kl b fi ky kr l ks kt">int arr_i [] = {0 , 1 };<br/>  int *ptr_i = &amp;arr_i[0 ];</span><span id="e912" class="kp if hh kl b fi ky kr l ks kt">printf("%td\n" , ptr_i - &amp;arr_i[1 ]);<br/>  /*Print the difference between<br/>    the two pointers . The result is<br/>    of the type ptrdiff_t , hence the use<br/>    of %td .<br/>    Output : -1 .*/</span><span id="dddb" class="kp if hh kl b fi ky kr l ks kt">printf("%td\n" ,  &amp;arr_i[2] - ptr_i );<br/>  /*Print the difference between<br/>    the two pointers . The distance from<br/>    one past the last object , member of<br/>    the array , to the first object member<br/>    in the array is 2 int , since the pointers<br/>    are of type int .<br/>    Output : 2 .*/</span><span id="d962" class="kp if hh kl b fi ky kr l ks kt">char *ptr_c = (char * )ptr_i ;<br/>  printf("%td\n" ,  (char * ) &amp;arr_i[2] - ptr_c );<br/>  /*Cast ptr_i , to a pointer to a char .<br/>    Print the difference , between one<br/>    past the last object member of the<br/>    array , now interpreted as a char ,<br/>    and the first object member of the<br/>    array .<br/>    Output : 8 .*/}</span></pre><p id="835a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">从整数中减去一个指针，<strong class="je hi"> <em class="ka">有效的</em> </strong>，指针必须指向数组中的一个对象，或者指向数组中最后一个对象成员之后的一个元素，结果必须指向数组中的一个对象，或者指向数组中最后一个对象之后的一个元素。</p><p id="6b11" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">从指针中减去一个整数</em> </strong>就是从指针中存储的地址的数值中减去指针所指向的整数，乘以对象的大小。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c42d" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="41af" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="c80a" class="kp if hh kl b fi ky kr l ks kt">unsigned char arr_uc[] = {0 , 255 , 0 , 255 };<br/>  /*Declare an array of type unsigned char , <br/>    and initialize it .*/</span><span id="1665" class="kp if hh kl b fi ky kr l ks kt">unsigned char  *ptr_uc = (unsigned char * ) &amp;arr_uc[4 ];<br/>  /*Get a pointer , to one past the last<br/>    object  , member of the array <br/>    arr_uc .*/</span><span id="a33a" class="kp if hh kl b fi ky kr l ks kt">int length_arr_uc = sizeof(arr_uc ) / sizeof (unsigned char );<br/>  /*Calculate the length of the <br/>    array of type , unsigned char .*/</span><span id="3788" class="kp if hh kl b fi ky kr l ks kt">for(int i = length_arr_uc ; i &gt;= 0 ; i-- ){<br/>  /*Print the address , and value if any , <br/>    of address accessible using subtraction<br/>    by an integer from a pointer , which points<br/>    to one past the last object , member<br/>    of the array .*/<br/>    printf("%p : " , ptr_uc - i );<br/>  if(ptr_uc - i != ptr_uc )<br/>    printf("%u" , *(ptr_uc -i ));<br/>  printf("\n" );}}</span><span id="863e" class="kp if hh kl b fi ky kr l ks kt">/*Output : <br/>0x7fff559338e8 : 0<br/>0x7fff559338e9 : 255<br/>0x7fff559338ea : 0<br/>0x7fff559338eb : 255<br/>0x7fff559338ec :     */</span></pre><p id="0fb5" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">当对指向完整对象类型的指针执行加法和减法时，指向不是成员 的完整对象<strong class="je hi"> <em class="ka">的指针，或者数组最后一个元素之后的指针，就好像该对象是长度为 1 的数组，并且是指针所指向的对象的类型。</em></strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="1552" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="f033" class="kp if hh kl b fi ky kr l ks kt">int main(void ){</span><span id="8469" class="kp if hh kl b fi ky kr l ks kt">int var_i = 2002874948 ;<br/>  /*Declare an int variable ,<br/>    having a value of 2002874948 .*/</span><span id="478c" class="kp if hh kl b fi ky kr l ks kt">int size_of_var_i = sizeof(var_i );<br/>  /*Get the size of the int <br/>    variable . The size is <br/>    returned in bytes . <br/>    1 char , has a size of 1 byte .*/</span><span id="1acc" class="kp if hh kl b fi ky kr l ks kt">char *ptr_c = (char *) &amp;var_i;<br/>  /*Get a pointer to the int <br/>    variable , and cast it to<br/>    pointer , to a char .*/</span><span id="4edd" class="kp if hh kl b fi ky kr l ks kt">for(int i = 0 ; i &lt; size_of_var_i ;  i++ )<br/>    printf("%c" , *(ptr_c + i ));}<br/>/*output :<br/>Draw */</span></pre><h2 id="d4e2" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">后缀和前缀、递增和递减运算符</h2><p id="2c34" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">后缀、前缀、递增和递减运算符:<code class="du ku kv kw kl b">++</code>、<code class="du ku kv kw kl b">--</code>、<strong class="je hi">、<em class="ka">可以在指针类型上使用</em>、</strong>。</p><p id="893a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">当递增或递减一个指针时，指针中存储的地址，<strong class="je hi"><em class="ka"/></strong><em class="ka">递增或递减了指针所指向的对象的大小</em>。</p><p id="e8e7" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">使用后缀运算符递增和递减的结果是<strong class="je hi"> <em class="ka">只能从下一条语句</em> </strong>中访问，因此在执行它们的语句中，后缀递增和递减运算符返回操作数值不变。</p><p id="a8c8" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">前缀，递增和递减运算符，递增或递减操作数，<strong class="je hi"> <em class="ka">返回递增或递减的</em> </strong>操作数。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4962" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="f71c" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  char array_c[ ] = "aa";<br/>  /*Create an array of length 3 ,<br/>    initialized with the characters<br/>    a a , and terminated  with<br/>    the null character . The null<br/>    character , has all of its<br/>    bits , set to 0 .*/</span><span id="1022" class="kp if hh kl b fi ky kr l ks kt">char *ptr_c = &amp;array_c[0 ];<br/>  /*ptr_c is a pointer of<br/>   typ char , it contains ,<br/>   the address of the first<br/>   object , member of the array<br/>   array_c .*/</span><span id="cc9a" class="kp if hh kl b fi ky kr l ks kt">while(ptr_c &amp;&amp; *ptr_c != '\0' ){<br/>    printf("%#2x\n" , *ptr_c++);}<br/>  /*Print the hexadecimal representation ,<br/>    of the data stored in array_c .<br/>    The pointer is incremented using ,<br/>    the postfix operator , hence <br/>    ptr_c value is only incremented , <br/>    starting the next statement . <br/>    Output :<br/>    0x61<br/>    0x61 */<br/>  printf("\n" );</span><span id="2907" class="kp if hh kl b fi ky kr l ks kt">ptr_c = &amp;array_c[0 ];<br/>  /*Rewind the pointer , <br/>    to the address of the <br/>    first object , stored in <br/>    array_c .*/</span><span id="a780" class="kp if hh kl b fi ky kr l ks kt">while(ptr_c &amp;&amp; *ptr_c != '\0' ){<br/>    printf("%#2x\n" , *++ptr_c);}<br/>  /*ptr_c contains the address <br/>    of the first object , member<br/>    of the array array_c . <br/>    The while statement , loops<br/>    through array_c elements , using<br/>    the prefix increment operator , <br/>    the address stored in ptr_c , is<br/>    first incremented . Next , it is<br/>    dereferenced . <br/>    Output : <br/>    0x61<br/>    0 */ }</span></pre><h2 id="b047" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">乘法、除法</h2><p id="2fbe" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">乘法和除法<strong class="je hi"> <em class="ka">只适用于</em> </strong>整数和浮点类型，因此不适用于指针类型。</p><h2 id="f79a" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">位运算</h2><p id="7711" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">位运算只适用于</em> </strong>整数类型，因此它们不是为指针类型定义的。</p><h2 id="baba" class="kp if hh bd ig kz la lb ik lc ld le io jn lf lg is jr lh li iw jv lj lk ja ll bi translated">条件运算符</h2><p id="5ca0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">条件运算符<strong class="je hi"> <em class="ka">的格式为</em> </strong>:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f45a" class="kp if hh kl b fi kq kr l ks kt">Operand_One?Operand_Two:Operand_Three</span></pre><p id="8138" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">操作数 _One 必须是</em> </strong>标量。C #中的标量类型有整型、浮点型和指针型。</p><p id="576a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果将<strong class="je hi"> <em class="ka">指针用作第二个或第三个操作数</em> </strong>，则:</p><p id="58c1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">要么，一个操作数是指向一个对象的指针，第二个操作数是指向一个  <em class="ka"> </em>合格或不合格 void 指针的<strong class="je hi"> <em class="ka">。在这种情况下，指向对象的指针被转换为 void 指针的限定或非限定版本。</em></strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6997" class="kp if hh kl b fi kq kr l ks kt">int *ptr_i ;<br/>const void *ptr_v ;<br/>ptr_v = 1 ? ptr_i : ptr_v ;<br/>/*When the first operand is  1 ,<br/>  the second operand is evaluated .<br/>  ptr_i is cast using <br/>  (const void * ) .*/</span></pre><p id="9ce0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">要么，一个操作数<strong class="je hi"> <em class="ka">是指针</em> </strong> <em class="ka"> </em> <strong class="je hi"> <em class="ka">指向</em> </strong> a C 类型，第二个操作数是空指针常量。在这种情况下，空指针常量被转换为所指向的 C 类型的指针。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="356c" class="kp if hh kl b fi kq kr l ks kt">volatile short *ptr_vs; <br/>ptr_vs  = 0 ? ptr_vs : 0 ;<br/>/*When the first operand is 0 , <br/>  the third operand is evaluated.<br/>  The result is a volatile<br/>  short null pointer . */</span></pre><p id="1e5a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">要么，两个指针操作数，<strong class="je hi">、<em class="ka">都有相同的</em>、</strong> C 类型，但有不同或相同的类型限定符。结果是一个指针，指向相同的类型，有所有的限定符。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="e35d" class="kp if hh kl b fi kq kr l ks kt">volatile int *ptr_vi;<br/>const int * ptr_ci;<br/>const volatile int *ptr_cvi = 1 ? ptr_vi : ptr_ci ;<br/>/*When the first operand is 1 , <br/>  the second operand ptr_vi is <br/>  evaluated.<br/>  The result is a constant volatile <br/>  int pointer . */</span></pre><h1 id="45d2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">数组</h1><p id="9b3b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">数组是一个聚合类型，不能将<strong class="je hi"> <em class="ka">转换为</em> </strong>之类的<code class="du ku kv kw kl b">(int [ ])</code>或<code class="du ku kv kw kl b">(int [3 ])</code>数组类型。只能对标量类型进行强制转换，如<code class="du ku kv kw kl b">(int * ) </code>。标量类型有整数类型、浮点类型和指针类型。</p><p id="b255" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">按位运算符</em> </strong>如 shifting】，不适用于数组，它们只适用于整数类型。</p><p id="d4cc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">乘除</em> </strong>，只适用于整数和浮点类型，同样它们不适用于数组。</p><p id="3c9b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">当一个数组<strong class="je hi"> <em class="ka">被传递给一个函数时，当执行相等比较(如<code class="du ku kv kw kl b">!=</code>)或顺序比较(如<code class="du ku kv kw kl b">&lt;=</code>)时，该数组充当指针</em> </strong>。当执行逻辑运算时，如<code class="du ku kv kw kl b">&amp;&amp;</code>和执行加法、<code class="du ku kv kw kl b">+</code>和减法<code class="du ku kv kw kl b">-</code>，数组也被视为指针。</p><p id="35c5" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">数组 充当的<strong class="je hi"> <em class="ka">指针，是数组第一个元素的地址，这是一个常量指针，所以它的地址不能改变。</em></strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8cec" class="kp if hh kl b fi kq kr l ks kt">#include&lt;stdio.h&gt;</span><span id="e390" class="kp if hh kl b fi ky kr l ks kt">int add(int *ptr_i , int length ){<br/>  int sum = 0 ;<br/>  for(int i = 0 ; i &lt; length ; i++ )<br/>    sum += *(ptr_i + i );<br/>  return sum;}</span><span id="026c" class="kp if hh kl b fi ky kr l ks kt">int main(void ){<br/>  int arr_i[] = {1 , 2 , 4 , 6};<br/>  /*Create an int array , containing<br/>    4 elements .*/</span><span id="e63d" class="kp if hh kl b fi ky kr l ks kt">printf("sizeof(arr_i ) : %zd bytes\n", sizeof(arr_i ));<br/>  /*Print the size of the array ,<br/>    Output :<br/>    sizeof(arr_i ) : 16 bytes */</span><span id="3ed7" class="kp if hh kl b fi ky kr l ks kt">const int *cptr_i = arr_i;<br/>  /*When assigning an array to a pointer ,<br/>    the array act as a constant pointer to<br/>    its first element .*/</span><span id="39a4" class="kp if hh kl b fi ky kr l ks kt">printf("sizeof(cptr_i ) : %zd bytes\n", sizeof(cptr_i ));<br/>  /*Prints the size of the pointer , not the size<br/>    of the array .<br/>    Output :<br/>    sizeof(cptr_i ) : 8 bytes */</span><span id="dad7" class="kp if hh kl b fi ky kr l ks kt">printf("Number of elements in array : %zd\n" , sizeof(arr_i ) / sizeof(arr_i[1 ] ));<br/>  /*Print the number of elements in the array .<br/>    This can be gotten by dividing the size of the<br/>    array , which is 16 bytes , by the size of<br/>    an element in an array. <br/>    The size of an int on this machine is 4 bytes ,<br/>    as such the number of elements is 4 .<br/>    Output :<br/>    Number of elements in array : 4 */</span><span id="e42e" class="kp if hh kl b fi ky kr l ks kt">int * ptr_i = 0;<br/>  if(ptr_i != arr_i )<br/>    ptr_i = arr_i;<br/>  /*When performing comparison<br/>    operations , the array<br/>    acts as a constant pointer , to<br/>    its first element .<br/>    The null pointer is different<br/>    from a not null pointer , hence<br/>    the assignment operation is <br/>    performed , and ptr_i is a <br/>    pointer , to the first<br/>    element of the array .*/</span><span id="f1d7" class="kp if hh kl b fi ky kr l ks kt">printf("2nd element of array is : %d\n" , *(arr_i + 3 ));<br/>  /*Print the value of the second ,<br/>   element of the array . When performing<br/>   addition or subtraction on an array ,<br/>   it acts as constant pointer to its<br/>   first element . This is<br/>   pointer addition or subtraction .<br/>   Output :<br/>   2nd element of array is : 6 */</span><span id="f980" class="kp if hh kl b fi ky kr l ks kt">printf("sum elements array : %d\n" , add(arr_i , 4 ));<br/>  /*When passed to a function , the array acts<br/>    as a constant pointer , to its first element .<br/>    The recieving function parameter , get the<br/>    refered address .<br/>    The add function calculates , the sum of the<br/>    elements , of the array .<br/>    Output :<br/>    sum elements array : 13 */</span><span id="658c" class="kp if hh kl b fi ky kr l ks kt">if( (arr_i &lt; arr_i + 1 ) &amp;&amp; arr_i )<br/>    printf("True\n" );<br/>  /*When using order comparison &lt; &lt;= &gt;= &gt; ,<br/>    the array acts as a constant pointer ,<br/>    to its first element , the address<br/>    of the first element is less than<br/>    the address of the second element<br/>    of the array .<br/>    &amp;&amp; evaluates its first operand ,<br/>    which returns 1 . Since the first<br/>    operand returned 1 , &amp;&amp; <br/>    evaluates , its second operand . <br/>    The second operand is arr_i  , since<br/>    this is a logical operation , arr_i<br/>    acts as a constant pointer to its<br/>    first element , the gotten pointer <br/>    is not a null pointer , hence the <br/>    second operand of &amp;&amp; evaluates to 1 ,<br/>    as such &amp;&amp; evaluates to 1 .<br/>    When 1 , the if statement ,<br/>    executes , the next statement ,<br/>    which prints True .<br/>    Output:<br/>    True .*/}</span></pre><p id="19b3" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">使用后缀和前缀递增<code class="du ku kv kw kl b">++</code>和递减<code class="du ku kv kw kl b">--</code>运算符，数组<strong class="je hi"> <em class="ka">不能递增或递减</em> </strong>。</p><h1 id="bf15" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结构、联合</h1><p id="c6d6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">强制转换只适用于标量类型，标量类型有整数类型、浮点类型和指针类型，因此<strong class="je hi"> <em class="ka">不适用于</em> </strong>结构和联合。</p><p id="9a8c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">不能使用</em> </strong>顺序、或等式、或按位、或逻辑、或乘法和除法、或加法和减法、或后缀和前缀递增和递减运算符，以及结构和联合。</p><p id="9a5d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">结构和联合<strong class="je hi"> <em class="ka">可以是三元运算符<code class="du ku kv kw kl b">?:</code>的第二个</em> </strong>和第三个操作数，在这种情况下，它们必须具有相同的类型。</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><p id="e5b9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><em class="ka">原载于 2020 年 12 月 29 日 https://twiserandom.com</em><a class="ae kx" href="https://twiserandom.com/c/conversion-and-operations-on-the-non-arithmetic-data-types-in-c/" rel="noopener ugc nofollow" target="_blank"><em class="ka"/></a><em class="ka">。</em></p></div></div>    
</body>
</html>