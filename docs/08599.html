<html>
<head>
<title>Multiprocessing — Get your compute working for you</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多处理—让您的计算为您服务</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-dummys-guide-to-multiprocessing-in-python-1d93c1943b9e?source=collection_archive---------22-----------------------#2020-08-04">https://medium.com/analytics-vidhya/a-dummys-guide-to-multiprocessing-in-python-1d93c1943b9e?source=collection_archive---------22-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/21f9ddc6121c66e6651d6736eafd2a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HselCkvT6rKKSIgV"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">基特·苏曼在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a51b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">当我开始尝试在 python 代码中使用多核的旅程时，我发现没有个人博客可以帮助我实现目标。我希望这篇博客能够填补我发现的一些空白，让读者能够快速了解嵌入多处理的过程，从而充分利用您的所有计算能力！</em></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="04f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个博客由几个部分组成，我试图根据对我来说似乎合理的顺序来分解它们。内容细分如下:</p><ul class=""><li id="0ef4" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js kg kh ki kj bi translated">包装</li><li id="5f66" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">核心</li><li id="aebb" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">存储您的结果</li><li id="08f6" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">功能</li><li id="2642" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">运行您的功能</li><li id="070d" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">需要考虑的事项</li><li id="1a69" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js kg kh ki kj bi translated">例子</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="e68a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">套餐</strong></h1><p id="3d93" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">首先，要创建你自己的多重处理程序，你需要一个特定的包来做这件事。在本文中，我将使用来自<a class="ae iu" href="https://pypi.org/project/multiprocess/" rel="noopener ugc nofollow" target="_blank"> <em class="jt">多进程</em> </a>的<em class="jt">多进程</em>来构建一个例子</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="e24d" class="mb kq hi lx b fi mc md l me mf">import multiprocessing</span></pre><h1 id="517a" class="kp kq hi bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated"><strong class="ak">内核</strong></h1><p id="44c8" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">现在，您已经将多处理导入到您的笔记本电脑/环境中，您将能够看到您有多少内核可用。只需使用下面的代码就可以做到这一点。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="063c" class="mb kq hi lx b fi mc md l me mf">multiprocessing.cpu_count()</span></pre><p id="a69f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将输出一个整数，这是您可以运行多处理的最大内核数。</p><blockquote class="ml mm mn"><p id="0891" class="iv iw jt ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">提示:为了确保您总是使用最大计算，我通常在脚本中将它设置为一个输入—processors = multi processing . CPU _ count()</p></blockquote><h1 id="6e85" class="kp kq hi bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated"><strong class="ak">存储您的结果</strong></h1><p id="a7d9" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">这可能是从现有文档中理解的最具挑战性的事情，因为不清楚在运行多处理时如何从多核中提取结果。</p><p id="f3f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要提取结果，您需要创建一个特定的字典，您的结果可以传递到这个字典中，如下所示。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="e125" class="mb kq hi lx b fi mc md l me mf">multiprocessing_dict = multiprocessing.Manager().dict()</span></pre><p id="c01d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将在脚本中将<em class="jt"> multiprocessing_dict_ </em>设置为一个空的 DictProxy 对象。在本文的后面，您将看到如何存储结果。</p><h1 id="3c5a" class="kp kq hi bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">功能</h1><p id="cb8d" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">因此，您可以定制部分来满足您的多处理需求。</p><p id="052c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要跨内核执行任何任务，您需要创建一个可以被进程调用的函数，您可以像平常一样编写这个函数。然而，要使多重处理能够使用它并存储结果，您需要向函数中添加两个特定的参数。</p><p id="d0c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是；</p><ol class=""><li id="5795" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js mr kh ki kj bi translated">运行它的处理器；</li><li id="8e6a" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js mr kh ki kj bi translated">我们在上一步中创建的字典。</li></ol><p id="224c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，不是像通常那样通过<em class="jt">返回</em>来返回函数输出，而是将它传递给 multi_dict_ argument，用 processor_ 作为它的键。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="daa1" class="mb kq hi lx b fi mc md l me mf">def your_func(your args, processor_, multi_dict_):<br/>    <br/>    your function <br/>    <br/>    multi_dict_[processor_] = your output</span></pre><blockquote class="ml mm mn"><p id="6f8f" class="iv iw jt ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">注意:我已经尝试编写了一个通用的函数 shell 来演示函数的参数需求。如果不清楚这一点，在继续之前参考示例代码可能是值得的。</p></blockquote><h1 id="8bb0" class="kp kq hi bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">运行您的功能</h1><p id="651b" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">现在我们已经创建了一个函数，我们可以看看如何在之前找到的内核数量上运行这个函数。这里有几个步骤，所以我会试着分解它们。</p><ol class=""><li id="22ca" class="kb kc hi ix b iy iz jc jd jg kd jk ke jo kf js mr kh ki kj bi translated">首先，您需要创建一个空列表，用于存储函数输出。</li><li id="a616" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js mr kh ki kj bi translated">然后，您需要创建一个关于处理器数量的循环。当您调用多重处理函数时，您可以将您的函数传递给它，并带有相关的参数。然后将它存储在步骤 1 中创建的空列表中。</li><li id="529d" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js mr kh ki kj bi translated">现在你已经在你的列表中存储了多重处理命令，你可以遍历这个列表并开始多重处理。</li><li id="36eb" class="kb kc hi ix b iy kk jc kl jg km jk kn jo ko js mr kh ki kj bi translated">然后，您可以将列表中的输出连接在一起。</li></ol><p id="f41a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很多内容在这一点上可能没有意义，所以让我们看看它在代码中是什么样子的，这些步骤被标记为注释。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="afa6" class="mb kq hi lx b fi mc md l me mf">1#<br/>multiprocessing_loop_ = []</span><span id="2607" class="mb kq hi lx b fi ms md l me mf">2#<br/>for processor_ in range(processors):<br/>    <br/>    multi_process_ = multiprocessing.Process(<br/>        target = your_func, <br/>        args = (your args, processor_, multiprocessing_dict)<br/>    )</span><span id="604c" class="mb kq hi lx b fi ms md l me mf">    multiprocessing_loop_.append(multi_process_)</span><span id="ff51" class="mb kq hi lx b fi ms md l me mf">#3<br/>for process_ in multiprocessing_loop_:<br/>    process_.start()</span><span id="f5b5" class="mb kq hi lx b fi ms md l me mf">#4<br/>for process_ in multiprocessing_loop_:<br/>    process_.join()</span></pre><blockquote class="ml mm mn"><p id="e94b" class="iv iw jt ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">注意:同样，我试图保持这部分代码的通用性，以演示运行需求。如果不清楚这一点，在继续之前参考一下示例代码可能是值得的。</p></blockquote><h1 id="ea69" class="kp kq hi bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">需要考虑的事项</h1><p id="480f" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated"><strong class="ix hj">拆分您的输入— </strong>在上面的示例中，我们将在您指定的任意数量的内核上，对相同的输入运行相同的功能。</p><p id="597e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想要运行特定的输入子集，在多重处理之前构建这些步骤是很重要的。</p><p id="229d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经在文章结尾的例子中演示了如何做到这一点。</p><p id="66c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">理解您的输出— </strong>在上面的例子中，您的输出将作为一个字典存储在一个列表中。因此，仍然需要将输出提取为可用的格式。</p><p id="9486" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经在文章结尾的例子中演示了如何做到这一点。</p><p id="cfac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Windows 操作系统— </strong>不幸的是，在 Windows 操作系统上部署多处理并不容易。据我所知，这是由于 fork()的需求。</p><p id="e2e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我不会在本文中尝试解决这个问题。</p><h1 id="7e1e" class="kp kq hi bd kr ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm bi translated">例子</h1><p id="d737" class="pw-post-body-paragraph iv iw hi ix b iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">最后，让我们将我们所学的内容合并到一个脚本中。</p><p id="c0b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我创建了一个包含两列的 DataFrame。一个是随机数，另一个是随机整数(1 到 100 之间)。我为这些列中的每一列模拟了 10，000，000 行。</p><p id="37c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的函数将我的随机数提升到我的随机整数的幂。</p><p id="45b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将作为列“RandomPower”添加到数据帧中。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="4021" class="mb kq hi lx b fi mc md l me mf">import pandas as pd<br/>import numpy as np<br/>import multiprocessing as mp</span><span id="da50" class="mb kq hi lx b fi ms md l me mf">processors = mp.cpu_count()<br/>mp_dict = mp.Manager().dict()<br/>mp_loop = []</span><span id="dee9" class="mb kq hi lx b fi ms md l me mf">size = 10000000<br/>input_step = int(size / processors)</span><span id="7be2" class="mb kq hi lx b fi ms md l me mf">df = pd.DataFrame(data = {<br/>    'RandomNumber' : np.random.random(size = size),<br/>    'RandomInt' : np.random.randint(0, high = 100, size = size)<br/>})</span><span id="dbe1" class="mb kq hi lx b fi ms md l me mf">def func(df_, indexlist_, processor_, multi_dict_):<br/>    '''<br/>    This function will raise the RandomNumber in the dataframe by the power of the RandomInt in the dataframe.<br/>    ''' <br/>    series_ = pd.Series(<br/>        data = df_.loc[indexlist_, 'RandomNumber'].values ** df_.loc[indexlist_, 'RandomInt'].values,<br/>        index = indexlist_<br/>    )</span><span id="b06d" class="mb kq hi lx b fi ms md l me mf">multi_dict_[processor_] = series_.to_dict()</span><span id="ccb4" class="mb kq hi lx b fi ms md l me mf">for processor_ in range(processors):    <br/>    if processor_ == 0:       <br/>        index_ = list(range(0, input_step, 1))<br/>    elif processor_ == processors - 1:<br/>        index_ = list(range(processor_ * input_step, size, 1))<br/>    else:<br/>        index_ = list(range(input_step * processor_, input_step * (processor_ + 1), 1))</span><span id="6774" class="mb kq hi lx b fi ms md l me mf">mp_ = mp.Process(<br/>        target = func,<br/>        args = (df, index_, processor_, mp_dict)<br/>    )    <br/>    mp_loop.append(mp_)</span><span id="108e" class="mb kq hi lx b fi ms md l me mf">for l_ in mp_loop:<br/>    l_.start()<br/>    <br/>for l_ in mp_loop:<br/>    l_.join()<br/>    <br/>df_results = pd.DataFrame([])<br/>    <br/>for key_ in mp_dict.keys():<br/>    df_results = df_results.append(<br/>        pd.DataFrame.from_dict(<br/>            mp_dict[key_], orient = 'index', columns = ['RandomPower']<br/>        )<br/>    )<br/>    <br/>df = df.merge(<br/>    df_results, <br/>    how = 'left',<br/>    left_index = True, <br/>    right_index = True<br/>)</span></pre><blockquote class="ml mm mn"><p id="259b" class="iv iw jt ix b iy iz ja jb jc jd je jf mo jh ji jj mp jl jm jn mq jp jq jr js hb bi translated">注意:这个特殊的例子实际上比使用 numpy 在多个内核上运行需要更长的时间。它纯粹是为了演示在多个内核上运行时如何操作和提取函数的结果而创建的。</p></blockquote></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="8088" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这篇博客对你有所帮助。</p><p id="32fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">写和发表你的第一篇文章是令人畏惧的，所以任何反馈都将是非常有帮助的——希望能有一些掌声！</p><p id="d0fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，如果您注意到我的代码中有任何错误，请让我知道，以便我可以相应地纠正它。</p></div></div>    
</body>
</html>