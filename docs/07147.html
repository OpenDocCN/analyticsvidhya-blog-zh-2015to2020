<html>
<head>
<title>[NodeJS] Express source code — Router, Route, Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[NodeJS] Express源代码—路由器、路由、层</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/nodejs-express-source-code-explanation-c1770ac9c989?source=collection_archive---------9-----------------------#2020-06-15">https://medium.com/analytics-vidhya/nodejs-express-source-code-explanation-c1770ac9c989?source=collection_archive---------9-----------------------#2020-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2dc75e806205e59d9884e71cbe9a886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w2wU2GfWQ5GTLy25"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@intothefab?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥·康帕雷利</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="aab7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想写一篇关于我经常使用的一些库的文章，并试图弄清楚它是如何工作的。要看你对它的理解程度，我认为可以通过你能否用自己的话解释概念来判断。这项技能值得花时间去练习。所以，这篇文章是一种修行。让我们开始吧。</p><h1 id="ca3c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">文章内容</h1><ol class=""><li id="bfe7" class="kr ks hi ix b iy kt jc ku jg kv jk kw jo kx js ky kz la lb bi translated">Express是做什么的？</li><li id="d031" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">了解Express的文件结构</li><li id="8ed3" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">举一个例子</li></ol><h1 id="a8aa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Express是做什么的？</h1><p id="3396" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">“Express”允许您构建一个用于接收请求和发送响应的服务器。此外，另一个基本功能是允许在访问某个端点时执行特定功能(例如，当URL为<a class="ae iu" href="https://mywebsite/get/userInfo" rel="noopener ugc nofollow" target="_blank">https://my website/get/userInfo</a>时，将IP地址保存到日志文件中……等等)。</p><h1 id="9ff6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Express的文件结构</h1><p id="7225" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">下图显示了每个文件之间的关系。箭头一侧是文件需要运行的依赖项。比如<code class="du lk ll lm ln b">router/index.js</code>需要<code class="du lk ll lm ln b">router/router.js</code>和<code class="du lk ll lm ln b">router/layer.js</code>才能运行。不要被这样的图片吓到，我们不会全部看完，只看最重要的部分。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/b2274c52790a39e607628353f6a00788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMgNsU2O7XICH6dl9JLi0g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安装后，转到node_modules &gt; express &gt; lib查看源代码</figcaption></figure><ul class=""><li id="8cad" class="kr ks hi ix b iy iz jc jd jg lt jk lu jo lv js lw kz la lb bi translated">index.js:模块的入口点</li><li id="a696" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js lw kz la lb bi translated">express.js:将应用程序的不同部分组合成一个对象</li><li id="b7a3" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js lw kz la lb bi translated">application.js:应用级属性和方法</li><li id="de8e" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js lw kz la lb bi translated">router.js:路由器级属性和方法</li><li id="c012" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js lw kz la lb bi translated">route.js和layer.js:完成路由器功能的基本文件</li></ul></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="f46b" class="jt ju hi bd jv jw me jy jz ka mf kc kd ke mg kg kh ki mh kk kl km mi ko kp kq bi translated">通过</h1><p id="18e9" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我将参考官方网站上的示例代码，并将该文件命名为<code class="du lk ll lm ln b">testing.js</code></p><pre class="lp lq lr ls fd mj ln mk ml aw mm bi"><span id="fd1e" class="mn ju hi ln b fi mo mp l mq mr">//testing.js<br/>const express = require('express');<br/>const app = express();<br/>const PORT = 8000</span><span id="d7e6" class="mn ju hi ln b fi ms mp l mq mr">app.get('/', (req, res) =&gt; {<br/>    res.send('Hello World!')<br/>})</span><span id="242b" class="mn ju hi ln b fi ms mp l mq mr">app.listen(PORT, () =&gt; console.log(`Listening at <a class="ae iu" href="http://localhost:${PORT}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${PORT}`</a>))</span></pre><h2 id="4dbc" class="mn ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">步骤1:获取express的实例</h2><p id="23c0" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">从代码中，第一步是将<code class="du lk ll lm ln b">require('express')</code>赋给一个变量。这允许您从相关文件中获取<code class="du lk ll lm ln b">module.exports</code>对象。在这种情况下，它实际上是从<code class="du lk ll lm ln b">lib/express.js</code>获取函数<code class="du lk ll lm ln b">createApplication</code>，因为该函数已被分配给<code class="du lk ll lm ln b">module.exports</code>。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/f4e6a86d90e12f95e2b262d898c50c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPkEAEoVCUkD1o3IQHIfSQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><code class="du lk ll lm ln b">lib/express.js</code></figcaption></figure><h2 id="bd44" class="mn ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">步骤2:使用“应用程序”对象</h2><p id="1c1c" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">您可以使用<code class="du lk ll lm ln b">express()</code>执行我们的<code class="du lk ll lm ln b">testing.js</code>中的功能。在<code class="du lk ll lm ln b">createApplication</code>函数中的过程之后，将返回一个<code class="du lk ll lm ln b">app</code>对象。它包含了我们在使用Express JS时需要的方法。(例如，应用程序使用等)。要开始利用<code class="du lk ll lm ln b">app</code>带给我们的东西，我们可以进入下一步。</p><h2 id="f641" class="mn ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">第三步:制定一条新路线</h2><p id="6f0a" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">让我们转到<code class="du lk ll lm ln b">app.get('/', ...)</code>。这为快速应用程序创建了一条新的路径。显示如果端点<code class="du lk ll lm ln b">'/'</code>被命中，运行后一个函数。实际使用可以是，如果到达特定页面，发送请求到后端获取数据。你可以看到有两个参数。一个是“路径”。一个是名为“处理程序”的函数。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/ec5e5556ac1dd85ff31588b66a22f16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jz6Hmi9KgG6-uiJ07O5unw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">app.get函数声明</figcaption></figure><p id="7f4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">绿色的字和<code class="du lk ll lm ln b">&lt;&gt;</code>符号如果你对<code class="du lk ll lm ln b">generic</code>不是那么熟悉可以忽略。不过，可以注意到的一些有趣的点是<code class="du lk ll lm ln b">handlers</code>中还有<code class="du lk ll lm ln b">...</code>。这意味着函数中可以传递多个处理程序。这涉及到我们将在后面讨论的中间件概念。</p><h2 id="d71a" class="mn ju hi bd jv mt mu mv jz mw mx my kd jg mz na kh jk nb nc kl jo nd ne kp nf bi translated">步骤4:构建服务器</h2><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/e8a69662cf879fedefa89c420863a7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u47FpFt44pg281OgS-4OLQ.png"/></div></div></figure><p id="d96d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从最后一行演示代码开始，有<code class="du lk ll lm ln b">app.listen</code>。这是构建服务器的步骤，此时<code class="du lk ll lm ln b">app.listen</code>调用<code class="du lk ll lm ln b">createServer()</code>并通过调用<code class="du lk ll lm ln b">server.listen</code>监控是否有任何请求。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="18e7" class="jt ju hi bd jv jw me jy jz ka mf kc kd ke mg kg kh ki mh kk kl km mi ko kp kq bi translated">路由器、路由和层之间的关系</h1><p id="fdf8" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">你可能认为application.js中有一个<code class="du lk ll lm ln b">app.get</code>函数，这样就可以调用这个函数了。是的，它是。然而，作者使用了一种聪明的方法来避免在application.js中声明一堆HTTP动词动作函数。已经使用了一个函数<code class="du lk ll lm ln b">methods.forEach(...)</code>。当我们使用<code class="du lk ll lm ln b">require</code>函数时，js文件将运行一次。当运行时涉及到<code class="du lk ll lm ln b">methods.forEach()</code>时，它会将那些HTTP动词动作函数设置到<code class="du lk ll lm ln b">app</code>对象中。因此，它可以将HTTP动词动作功能委托给路由器[方法]功能。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/bb8ffa9c70ce076ef739cf52eb9ef263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rDIyVrnNAlEouzNJEoFx7A.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用调试器显示app.get后的函数</figcaption></figure><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es nk"><img src="../Images/b96bec1ce42e4a38db1ac487dc18b45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*LqNJ7ju7ilUDp00bXisT7A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">函数来处理不同的HTTP动词动作</figcaption></figure><p id="c98c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">功能<code class="du lk ll lm ln b">lazyrouter()</code>已经初始化了路由器。值得一提的是，有一个<strong class="ix hj"> <em class="nl">路由器</em> </strong> <strong class="ix hj"> <em class="nl">栈(实际上是JS中的一个数组)用于保存路由</em> </strong>。之后，路由器中的<code class="du lk ll lm ln b">route</code>方法将被执行，生成一个新的<code class="du lk ll lm ln b">Route</code>，并使用一个<code class="du lk ll lm ln b">Layer</code>来包装它。<code class="du lk ll lm ln b">Route</code> <strong class="ix hj"> <em class="nl">还有一个堆栈</em> </strong>用来存储匹配具体路线时应该调用的函数。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/eb376307876dd26cf8da83a31ea36c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKqp4lo0xoVAuOBYpkd5Jg.png"/></div></div></figure><p id="fa87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<code class="du lk ll lm ln b">Router</code>、<code class="du lk ll lm ln b">Route</code>和<code class="du lk ll lm ln b">Layer</code>的关系可以表示如下:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/e848c4cddaedd5b05cccb512a99e1f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJnKBhN3EP4JrUBAnesNOw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">层、路由器、路由之间的关系</figcaption></figure><p id="df6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">路由器堆栈在express应用程序内部。最下面的应该是app路由器，可能上面还有其他路由器。在每个路由器中，都有一个路由堆栈来存储当端点被命中时需要执行的功能。</p><h1 id="9cc9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="fd40" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们在这篇文章中讨论了几件事情。以下是一些关键要点。可能下次的话题会集中在<code class="du lk ll lm ln b">req</code>和<code class="du lk ll lm ln b">res </code>机构上。如果您有任何问题或意见，请在下面评论或通过<a class="ae iu" href="https://twitter.com/frankytse_07" rel="noopener ugc nofollow" target="_blank"> Twitter </a> (@frankytse_07)联系我。再见。</p><ul class=""><li id="0e7f" class="kr ks hi ix b iy iz jc jd jg lt jk lu jo lv js lw kz la lb bi translated">application.js文件定义了express应用程序使用的必要方法。</li><li id="f48b" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js lw kz la lb bi translated"><code class="du lk ll lm ln b">methods.forEach()</code>在application.js中，将HTTP动词动作(如get delete…)委托给路由器，并进一步将路由器的处理函数分配给路由。</li><li id="7291" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js lw kz la lb bi translated">用于存储路由器的路由器堆栈。每个路由器都有自己的路由堆栈来保存功能。</li></ul></div></div>    
</body>
</html>