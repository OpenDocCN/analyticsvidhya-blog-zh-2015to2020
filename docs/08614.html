<html>
<head>
<title>Steps You Should Follow TO Successfully Train MLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成功培训MLP应该遵循的步骤</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/steps-you-should-follow-to-successfully-train-mlp-40a98c3b5bb3?source=collection_archive---------5-----------------------#2020-08-05">https://medium.com/analytics-vidhya/steps-you-should-follow-to-successfully-train-mlp-40a98c3b5bb3?source=collection_archive---------5-----------------------#2020-08-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7952fb8a814646db62014ee867ce1ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r2dO-k-Avr5g-1YQ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae iu" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>拍摄的照片</figcaption></figure><p id="d3b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">训练多层感知器不是一件容易的事情，你必须遵循许多步骤来训练MLP，并从中获得最大收益，如果你错过了其中的任何一步，那么一切都将化为乌有。所以请不要忘记在创建你的MLP模型之前做这些步骤。</p><p id="9f2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所需步骤</p><ol class=""><li id="5838" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">数据预处理</li><li id="7d86" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">权重初始化</li><li id="9ddc" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">选择正确的激活功能</li><li id="4267" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">批量标准化</li><li id="b6c6" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">添加辍学者</li><li id="d481" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用优化器</li><li id="9a56" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">超参数</li><li id="e3e1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">损失函数</li></ol><h1 id="e25e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">1.数据预处理</h1><p id="1cca" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">数据预处理是任何机器学习或深度学习项目中最重要的步骤之一，如果你不打算使用数据预处理，那么你制作的任何模型都是无用的。</p><p id="3853" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从现实世界中获得的数据是不完整的、不一致的、不准确的(包含错误或异常值)，并且通常缺少特定的属性值/趋势。所以这就是<strong class="ix hj">数据预处理</strong>来拯救的地方。在数据预处理中，我们基本上清理数据，填补丢失的值，找到并移除异常值。</p><p id="352d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据预处理步骤:</strong></p><p id="b65b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1 <strong class="ix hj">数据清洗:</strong>我们得到的数据可能会有很多不相关和缺失的数据点，所以要处理这部分，就要进行数据清洗。它涉及丢失数据、噪声数据等的处理。这涉及到更多的步骤。</p><p id="4a29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2 <strong class="ix hj">特征缩放:</strong>通过将所有数据值纳入指定范围(-1.0至1.0或0.0至1.0)，将不同比例的数据纳入同一比例。我们进行<strong class="ix hj">数据标准化</strong>来重新调整数据，使平均值为0，标准差为1(单位方差)。我们使用<strong class="ix hj"> <em class="lk">归一化</em> </strong>将值重新调整到范围[0，1]</p><h1 id="eb2e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">2.权重初始化</h1><p id="5acb" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">权重初始化用于防止激活层输出在通过深度神经网络的向前和向后传播的过程中出现爆炸梯度或消失梯度问题。</p><p id="6668" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重量初始化主要取决于您使用的激活功能。如果你有<strong class="ix hj"> Sigoid或tanh </strong>作为你的激活函数，那么最好使用<strong class="ix hj"> Xavier初始化</strong>或<strong class="ix hj"> Glorot普通初始化器</strong>和<strong class="ix hj"> </strong>像<strong class="ix hj"> ReLu </strong>这样的激活函数最好使用<strong class="ix hj">普通</strong></p><h1 id="f413" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">3.选择正确的激活功能</h1><p id="17e9" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">当你没有一个密集连接的深MLP，那么你基本上可以使用任何激活函数，如<strong class="ix hj"> Sigmoid或tanh </strong>，但当你处理具有多个隐藏层的密集连接的MLP时，那么你不应该选择Sigmoid或tanh，因为它们必须消除梯度问题，那么最好使用<strong class="ix hj"> ReLu </strong>或其他不同的变化。</p><h1 id="5a0f" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">4.批量标准化</h1><p id="fa29" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">批处理规范化是一种用于提高神经网络的速度、性能和稳定性的技术。所以你必须使用批量标准化，尤其是在深度MLPs的情况下，并尝试对接近<strong class="ix hj">输出层</strong>的层使用批量标准化</p><p id="c176" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">批量标准化</strong>通过减去<strong class="ix hj">批量</strong>平均值并除以<strong class="ix hj">批量</strong>标准偏差来标准化先前激活层的输出。</p><h1 id="038f" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">5.添加辍学者</h1><p id="99e7" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">过拟合一个多层感知器是非常容易的，所以为了防止过拟合多层感知器，我们必须使用辍学。辍学是保护你的MLP免于过度劳累的最好方法。在这种情况下，我们决定我们的辍学率，并通过我们的模型随机选择神经元，一些神经元在训练过程中被忽略。他们是随机“辍学”的，因此得名<strong class="ix hj">辍学</strong>。</p><h1 id="10ae" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">6.使用优化器</h1><p id="1bd0" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">训练一个深度神经网络不是一件容易的事情，而且是一件非常耗时的事情，特别是对于复杂的问题。但是，我们可以通过选择正确的优化器来减少时间，而不是简单地使用常规梯度下降优化器，该优化器会缓慢地收敛到全局最小值，或者甚至会停留在局部最小值，从而导致更差的模型。因此，在选择正确的优化器时，您应该非常小心，因为它将节省您的时间，并提高您的模型的性能。</p><p id="ef97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数时候，<em class="lk">自适应学习速率算法</em>如<strong class="ix hj">亚当</strong>或<strong class="ix hj">那达慕</strong>在速度上胜过<strong class="ix hj">梯度下降算法</strong> s或它的不同变体如<strong class="ix hj">随机梯度下降(SGD ) </strong>和<strong class="ix hj">小批量梯度下降</strong>，特别是在深度神经网络中。然而，<strong class="ix hj"> <em class="lk">自适应学习率算法</em> </strong> <em class="lk"> </em>并不能保证绝对收敛到全局最小值。</p><p id="fc52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果您的模型不太复杂，并且具有较少的特征和数据点，那么建议使用<strong class="ix hj">随机梯度下降(SGD ) </strong>作为起点，然后我们可以稍后调整我们的参数，如学习率，稍后选择优化器函数。但是，当你处理大量数据点和具有大量特征的复杂模型时，你可以使用<strong class="ix hj">亚当</strong>或<strong class="ix hj">那达慕</strong>创建你的第一个模型，因为这些模型具有更快的收敛速度，并且不会陷入局部最小值。</p><p id="7fbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里列出了所有的优化器，有优点也有缺点，所以你可以相应地选择最适合你的</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/e3e2bfbdcbf22e020c75f65169b49184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bB2Ia6MWqXSxdFT_.png"/></div></div></figure><h1 id="90e6" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.超参数</h1><p id="dbbc" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">深度学习模型充满了超参数，选择正确的超参数并不是一件容易的事情。由于有大量的超参数需要调整，训练一个深度多层感知器变得非常困难。</p><p id="aa26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">超参数非常重要，因为它们直接控制训练算法的行为，对训练中的模型的性能有重要影响，因为超参数将决定模型的性能，因此您一定不能跳过这一步。</p><p id="f676" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一些您可以调整的超参数，这些都可以通过<strong class="ix hj"> GridSearchCV或RandomSearch来完成。</strong></p><ul class=""><li id="02a3" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js lq jz ka kb bi translated">学习率</li><li id="4608" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lq jz ka kb bi translated">时代数</li><li id="29d6" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lq jz ka kb bi translated">隐藏层和隐藏单元</li><li id="f825" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lq jz ka kb bi translated">激活功能</li></ul><p id="be3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">学习率:</strong>如果我们的模型的学习率非常大<strong class="ix hj"> </strong>，那么它将超过理想状态，并且算法可能不收敛(因为当局部最小值在中间时，它将保持从左向右跳跃)。当我们保持我们的学习率太低时，那么我们的模型可能需要几年才能收敛(将需要更多的纪元来达到理想状态)。所以我们一般选择自己的学习率为<strong class="ix hj"> 0.001。</strong>我们还随着时期大小的增加不断改变我们的学习率，这是使我们的学习率随时间变化的最佳方式，因为它有助于我们的模型更快地收敛。</p><p id="cd89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时期数:</strong>要为训练步骤选择正确的时期数，我们应该注意的指标是<strong class="ix hj">验证误差</strong>。直观的<em class="lk">手动</em>方法是，只要验证误差不断减小，就让模型训练尽可能多的迭代次数，然后会有一个点，从这个点开始，我们的模型性能不会改变太多，甚至可能会降低，然后我们停止，在图的帮助下，我们可以选择我们的最佳时期数。总是试着做一个既有训练错误又有测试错误的图，否则你会过度拟合你的模型。</p><p id="ac5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">隐藏层:</strong>涉及第一个隐藏层的另一个启发是，将隐藏单元的数量设置为大于输入的数量往往会在许多任务中实现更好的结果，这意味着如果你有5个输入层，那么在你的第一个隐藏层中的隐藏层中有20个神经元是好的。大多数情况下，3层神经网络是理想的，它优于2个隐藏层，然后增加更多的神经网络通常不会有回报，直到你不使用卷积神经网络，它们越深，性能越好。</p><h1 id="1e2c" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">8.损失函数</h1><p id="6d4f" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们通常处理3种类型的问题，即回归问题、二元分类问题和多类分类问题，它们中的每一个都有不同的损失函数，所以让我们寻找所有的问题。</p><p id="5e71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">回归损失函数:</strong>在回归问题中，我们预测我们的实数值。因此，在这种情况下，我们使用三种不同类型的损失函数，即</p><ol class=""><li id="8e6b" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">均方误差损失</li><li id="bda5" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">均方对数误差损失</li><li id="86a0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">平均绝对误差损失</li></ol><p id="3b69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">二进制分类损失函数:</strong>在二进制分类问题中，我们只有两类:是或否、0或1。这里我们使用的损失函数是:</p><ol class=""><li id="bc4b" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">二元交叉熵</li><li id="0d42" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">铰链损耗</li><li id="810c" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">平方铰链损耗</li></ol><p id="f8a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">多类分类损失函数:</strong>这里我们正在处理多种情况，如我们的<strong class="ix hj"> MNIST数据集i </strong> n，我们必须识别手写数字，甚至最流行的数据集，即我们的<strong class="ix hj">虹膜数据集，也是一个多类问题。</strong>因此，我们在这种情况下使用的损失函数是:</p><ol class=""><li id="20ca" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">多类交叉熵损失</li><li id="0aee" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">稀疏多类交叉熵损失</li><li id="c11d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Kullback Leibler发散损失</li></ol></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="ac39" class="kh ki hi bd kj kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le bi translated">结论:</h1><p id="3c70" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">所有上述步骤都非常重要，因此您必须遵循每一个步骤，以获得一个完全工作的模型。如果你错过了任何一步，那么你所有的其他步骤都将是徒劳的，你的模型将会有一个糟糕的表现。所以在创建你的模型之前，总是试着写下这些步骤，因为我们作为人类容易忘记事情，这将直接影响我们的模型。</p></div></div>    
</body>
</html>