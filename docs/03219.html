<html>
<head>
<title>BigQuery Partitioning &amp; Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大查询分区和聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bigquery-partitioning-clustering-9f84fc201e61?source=collection_archive---------1-----------------------#2020-01-21">https://medium.com/analytics-vidhya/bigquery-partitioning-clustering-9f84fc201e61?source=collection_archive---------1-----------------------#2020-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d705cf44476d4c42c66884bcb1cd155d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4SKkJW2Y9T8_NEYTM4krg.jpeg"/></div></div></figure><p id="c53e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博文中，我将解释BigQuery中的分区和集群特性，以及如何提高查询性能和降低查询成本。</p><h1 id="de2e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">分割</h1><p id="9eaa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对表进行分区可以使查询运行得更快，同时花费更少。直到2019年12月，BigQuery才支持仅使用<strong class="is hj"> date数据类型</strong>的表分区。现在，你也可以在整数范围内这样做。如果您想了解更多关于这种表分区方式的信息，请查看Guillaume Blaquiere的<a class="ae kr" rel="noopener" href="/google-cloud/partition-on-any-field-with-bigquery-840f8aa1aaab">博客文章</a>。</p><p id="c7a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我将重点介绍<strong class="is hj">日期类型</strong>分区。您可以使用两种主要策略对数据进行分区:一方面，您可以使用表列，另一方面，您可以使用数据摄取时间。</p><p id="dcf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您有非常大的多年前的数据集时，这种方法特别有用。事实上，如果您希望只在特定时间段运行分析，那么按时间对表进行分区可以让BigQuery只读取和处理特定时间段的行。因此，您的查询将运行得更快，而且因为它们读取的数据更少，所以成本也更低。</p><p id="7168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建分区表是一项简单的任务。在创建表时，您可以指定哪个列将用于分区，否则，您可以在<a class="ae kr" href="https://cloud.google.com/bigquery/docs/creating-partitioned-tables" rel="noopener ugc nofollow" target="_blank">摄取时间</a>设置分区。因为可以用与未分区的表完全相同的方式查询该表，所以不必更改现有查询的任何一行。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="210e" class="lb jp hi kx b fi lc ld l le lf">select<br/>  day,<br/>  count(*)<br/>from full_history<br/>where sampling_date &gt;= ‘2019–08–05’<br/>and sampling_date &lt; ‘2019–08–06’<br/>group by 1</span></pre><p id="ebc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设“<strong class="is hj"> sampling_date </strong>”是分区列，现在BigQuery可以使用“where子句”中指定的值来只读属于正确分区的数据。</p><h2 id="c9cc" class="lb jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">奖金金块</h2><p id="9762" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">您可以使用<strong class="is hj">分区装饰器</strong>来更新、删除和覆盖整个单个分区，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d1d6" class="lb jp hi kx b fi lc ld l le lf"># overwrite single partition loading from file<br/>bq load —-replace \<br/>  project_id:dataset_name.table_name$20190805 \<br/>  gs://my_input_bucket/data/from/20190805/* ./schema.json</span></pre><p id="f0b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a015" class="lb jp hi kx b fi lc ld l le lf"># overwrite single partition from query results<br/>bq query —- replace --use_legacy_sql=false \<br/>  —-destination_table project_id:dataset.table$20190805 \<br/>  ‘select * from project_id:dataset.another_table’ </span></pre><p id="bff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上述情况下，加载的数据和查询结果都必须属于被引用的分区，否则作业将失败。</p><h1 id="8c2d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使聚集</h1><p id="4b7c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">聚类是组织数据的另一种方式，它将在所选的聚类列中共享相似值的所有行一个接一个地存储。这个过程提高了查询效率和性能。注意，BigQuery只在分区表上支持这个特性。</p><p id="1eca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BigQuery可以利用聚簇表只读取与查询相关的数据，因此它变得更快、更便宜。</p><p id="3642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在创建表时，您可以在逗号分隔的列表中提供最多4个聚类列，例如“<strong class="is hj"> wiki </strong>”、“<strong class="is hj"> title </strong>”。你也应该记住它们的顺序是最重要的，但是我们一会儿就会看到。</p><p id="6d08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一节中，我们将使用来自<a class="ae kr" href="https://twitter.com/felipehoffa" rel="noopener ugc nofollow" target="_blank"> Felipe Hoffa </a>的公共数据集的“<em class="lt"> wikipedia_v3 </em>”，该数据集包含维基百科页面浏览量的年度表格。这些按“<strong class="is hj">日期时间</strong>列划分，并聚集在“<strong class="is hj">维基</strong>和“<strong class="is hj">标题</strong>列上。单行可能如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0e46" class="lb jp hi kx b fi lc ld l le lf">datehour, language, title, views<br/>2019–08–10 03:00:00 UTC, en , Pizza, 106<br/>...</span></pre><p id="10ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下查询统计了从2015年1月1日到2015年1月1日意大利维基的所有页面浏览量。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d740" class="lb jp hi kx b fi lc ld l le lf">select<br/>  _table_suffix as year,<br/>  wiki,<br/>  sum(views) / pow(10, 9) as Views<br/>from `fh-bigquery.wikipedia_v3.pageviews_*`<br/>where wiki = ‘it’and datehour &gt;= ‘2015–01–01’<br/>group by 1,2<br/>order by 1 asc</span></pre><p id="c323" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在BigQuery UI中编写这个查询，它将估计4.5 TB的数据扫描。但是，如果您实际运行它，最终扫描的数据将只有160 GB。</p><p id="b7c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这怎么可能？</p><p id="956a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当BigQuery读取时，只读取属于包含意大利语wiki数据的集群的行，而丢弃其他所有内容。</p><p id="97f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么列顺序在集群中如此重要？</p><p id="74f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很重要，因为BigQuery将根据创建表时指定的列顺序分层组织数据。</p><p id="ce2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用下面的例子:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="94a1" class="lb jp hi kx b fi lc ld l le lf">select<br/>  wiki,<br/>  sum(views) / pow(10, 9) as Views<br/>from `fh-bigquery.wikipedia_v3.pageviews_2019`<br/>where title = ‘Pizza’<br/>and datehour &gt;= ‘2019–01–01’<br/>group by 1<br/>order by 1 asc</span></pre><p id="188f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个查询需要访问所有的“wiki”集群，然后它可以使用“title”值跳过不匹配的集群。</p><p id="0f68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这导致扫描比按相反顺序"<strong class="is hj"> title </strong>"、"<strong class="is hj"> wiki </strong>"的聚类列多得多的数据。</p><p id="09b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在撰写本文时，上面的查询估计扫描成本为1.4 TB，但它实际上只扫描了875.6 GB的数据。</p><p id="f26e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们颠倒集群列的顺序，将第一个"<strong class="is hj"> title </strong>"和第二个"<strong class="is hj"> wiki </strong>"放在一起，您可以使用以下命令来完成:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4a14" class="lb jp hi kx b fi lc ld l le lf">bq query --allow_large_results --nouse_legacy_sql \<br/>  --destination_table my_project_id:dataset_us.wikipedia_2019 \<br/>  --time_partitioning_field datehour \<br/>  --clustering_fields=title,wiki \<br/>'select * from `fh-bigquery.wikipedia_v3.pageviews_2019`'</span></pre><p id="b2a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的新表上运行“Pizza”查询“<strong class="is hj">my _ project _ id:dataset _ us . Wikipedia _ 2019</strong>”应该会便宜很多。事实上，虽然估计值仍为1.4 TB，但实际读取的数据仅为26.3 GB，少了33倍。</p><p id="5452" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为最后的测试，让我们试着过滤一下“<strong class="is hj"> wiki </strong>专栏:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="75e2" class="lb jp hi kx b fi lc ld l le lf">select<br/>  wiki,<br/>  sum(views) / pow(10, 9) as Views_B<br/>from `my_project_id:dataset_us.wikipedia_2019`<br/>where wiki = ‘it’ and title is not null<br/>and datehour &gt;= ‘2019–01–01’<br/>group by 1<br/>order by 1 asc</span></pre><p id="7262" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据读取估计值始终相同，但现在实际数据读取量跃升至1.4 TB(整个表)，而在第一个示例中，实际数据读取量仅为160 GB。</p><p id="8840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:由于BigQuery使用列存储，“<strong class="is hj">title not null</strong>”确保我们在每个查询中总是引用相同数量的列。否则，从最后一个查询中读取的数据会更少，因为我们引用的列更少。</p><p id="5dd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，选择正确的聚类列及其顺序会产生很大的影响。您应该根据您的工作量来计划。</p><p id="e550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住，永远<strong class="is hj">分区</strong>和<strong class="is hj">簇</strong>你的表！这是免费的，它不需要改变你的任何查询，它会使他们更便宜，更快。</p><p id="70b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作者的<a class="ae kr" href="https://github.com/alepuccetti" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae kr" href="https://twitter.com/alepuccetti" rel="noopener ugc nofollow" target="_blank"> Twitter </a>。</p></div></div>    
</body>
</html>