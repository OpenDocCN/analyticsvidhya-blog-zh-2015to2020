<html>
<head>
<title>Learning Pandas.Series(Part-5)(.loc explored for Indexing and slicing)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习熊猫。系列(第五部分)。为索引和切片而探索的loc)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/learning-pandas-part-5-series-loc-explored-for-indexing-and-slicing-6447c5d7298c?source=collection_archive---------43-----------------------#2020-05-23">https://medium.com/analytics-vidhya/learning-pandas-part-5-series-loc-explored-for-indexing-and-slicing-6447c5d7298c?source=collection_archive---------43-----------------------#2020-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/50420d9fd076779b764f06f4d355d824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WURrR14KNQRVfXgM"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a4e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在学习熊猫的第5部分中，我们将在<code class="du jt ju jv jw b"><strong class="ix hj">Pandas.Series</strong></code>中探索用于索引和切片的<code class="du jt ju jv jw b"><strong class="ix hj">loc</strong></code>索引器。如果您直接跳到这里，您可以查看第4部分，了解我们为什么需要索引器:</p><div class="jx jy ez fb jz ka"><a rel="noopener follow" target="_blank" href="/@milankmr/learning-pandas-part-4-series-why-we-need-separate-indexers-loc-iloc-c081047f3a79"><div class="kb ab dw"><div class="kc ab kd cl cj ke"><h2 class="bd hj fi z dy kf ea eb kg ed ef hh bi translated">学习熊猫(第4部分)(系列—为什么我们需要单独的索引器(loc，iloc..)?)</h2><div class="kh l"><h3 class="bd b fi z dy kf ea eb kg ed ef dx translated">为什么iloc和loc是熊猫索引和切片的首选？一开始可能会很困惑，但是相信我，你…</h3></div><div class="ki l"><p class="bd b fp z dy kf ea eb kg ed ef dx translated">medium.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko io ka"/></div></div></a></div><blockquote class="kp kq kr"><p id="2897" class="iv iw ks ix b iy iz ja jb jc jd je jf kt jh ji jj ku jl jm jn kv jp jq jr js hb bi translated"><code class="du jt ju jv jw b"><strong class="ix hj">.loc</strong></code> <strong class="ix hj">属性是指用于索引和切片的显式索引，这意味着它是基于索引标签而不是元素的位置。</strong></p></blockquote><pre class="kw kx ky kz fd la jw lb lc aw ld bi"><span id="70cb" class="le lf hi jw b fi lg lh l li lj">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=[11,12,13,14,15,16],<br/>          name='series_name1')</span><span id="f4b4" class="le lf hi jw b fi lk lh l li lj">print(series1.loc[11])</span><span id="ca0b" class="le lf hi jw b fi lk lh l li lj">Output:<br/>10</span><span id="630d" class="le lf hi jw b fi lk lh l li lj">series2 = pd.Series([10,12,19,44,15,60],<br/>          index=['a','b','c','d','e','f'],<br/>          name='series_name2')</span><span id="3914" class="le lf hi jw b fi lk lh l li lj">print(series2.loc['a'])</span><span id="27af" class="le lf hi jw b fi lk lh l li lj">Output:<br/>10</span></pre><p id="7d9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中<code class="du jt ju jv jw b"><strong class="ix hj">11</strong></code> <strong class="ix hj"> </strong>是索引标签而不是位置索引。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/52fa1affc7b1cdf256ef102fdd406e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyf_K5ThNmr2UGK2eixPfA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用loc索引器的串行访问</figcaption></figure><blockquote class="kp kq kr"><p id="58c0" class="iv iw ks ix b iy iz ja jb jc jd je jf kt jh ji jj ku jl jm jn kv jp jq jr js hb bi translated">如果<strong class="ix hj">我们试图访问不存在的标签索引，它将引发</strong> <code class="du jt ju jv jw b"><strong class="ix hj">key error</strong></code> <strong class="ix hj"> :-如下图所示，我们试图访问值为</strong> <code class="du jt ju jv jw b"><strong class="ix hj"> 1</strong></code> <strong class="ix hj">的标签索引，1不可用作标签索引。</strong></p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/327df996660c51f1d2ba25b8728aaf30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEJNhtBgd8tUg3ExNSySlg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">当索引标签不存在时，在序列中使用loc时出现键错误</figcaption></figure><p id="4976" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">问</span> <strong class="ix hj">问题</strong>:现在我们知道<code class="du jt ju jv jw b"><strong class="ix hj">.loc</strong></code>属性指的是显式索引，如果我们在创建序列时不提供显式索引会怎么样？</p><p id="0533" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi ln translated">是的，你猜对了，无论我们是否创建，序列中总是存在索引，所以它仍然引用生成的索引，而不是基于位置的索引，尽管它看起来像是基于位置的，因为索引是从0到len-1生成的。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/23b6c7440a9f4b314064795ba46dbb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kcrGbHdD7_1pDTJhrnkWw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">具有不带显式索引的序列的loc属性</figcaption></figure><p id="fb1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi ln translated">现在，如果你在一个序列中有重复的索引，你将得到从属性返回的序列</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/14b8b070acb9fa17ce5ea58634bae17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-Lc1N79zN7T0qHGyHnYAQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><code class="du jt ju jv jw b">.loc</code>在具有重复索引的序列上</figcaption></figure><blockquote class="kp kq kr"><p id="c55b" class="iv iw ks ix b iy iz ja jb jc jd je jf kt jh ji jj ku jl jm jn kv jp jq jr js hb bi translated"><strong class="ix hj">花式索引用。loc:如果您想一次为多个不连续的索引选择值，您可以使用花式索引，您可以传入您想要获取数据的索引列表(我们可以使用连续切片)</strong></p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/8de4cc10a251fdec9d2eeb00a5c3756a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOd5m9QMrQAxgDSFOIBgMA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">花式索引。熊猫系列锁定</figcaption></figure><p id="86f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> C </span></p><p id="f669" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用一个问题来理解可调用索引:-</p><p id="f2bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问题</strong> :-假设我们想从系列中选择数据，其值满足某些条件，如值&gt; 12</p><p id="1a04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">回答</strong> :-我们可以使用python中的lambda函数将callable作为索引器，如下所示，<code class="du jt ju jv jw b"><strong class="ix hj">we may also use the boolean array which is discussed after this .</strong></code></p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/6395b9aa84224198508ebe8208c49636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgFCYRONSQ9xNpjtQ3YTcw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">熊猫系列中的可调用索引器</figcaption></figure><p id="3f17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> B </span>布尔数组作为系列的索引器:-我们可以使用布尔数组作为索引器，将选择数组中值为真的索引。</p><pre class="kw kx ky kz fd la jw lb lc aw ld bi"><span id="0ff8" class="le lf hi jw b fi lg lh l li lj">import pandas as pd<br/>series2 = pd.Series([10,12,19,44,15,60],<br/>          index=[2,4,1,3,6,5],<br/>          name='series_name2')</span><span id="e188" class="le lf hi jw b fi lk lh l li lj">bool_array = [True,False,True,True,False,True]<br/>series2.loc[bool_array]</span><span id="38ef" class="le lf hi jw b fi lk lh l li lj">#indexes 4,6 are false so the corresponding data are not present in output</span><span id="3e2b" class="le lf hi jw b fi lk lh l li lj">2    10 <br/>1    19 <br/>3    44 <br/>5    60 <br/>Name: series_name2, dtype: int64</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/e7c8f20d61780a5a7f1f76edb90e72e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H38Ve1l5OlCcDOI85wOFpw.png"/></div></div></figure><p id="742b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们进一步了解series对象上的操作，我们会发现，对于series对象上的逻辑操作，我们会得到布尔数组作为输出，它可能会进一步用作索引器。让我们看看同样的例子。</p><pre class="kw kx ky kz fd la jw lb lc aw ld bi"><span id="164d" class="le lf hi jw b fi lg lh l li lj">import pandas as pd<br/>series2 = pd.Series([10,12,19,44,15,60],<br/>          index=[2,4,1,3,6,5],<br/>          name='series_name2')</span><span id="78fd" class="le lf hi jw b fi lk lh l li lj">bool_array = series2 &gt; 15<br/>print(bool_array)<br/>print(series2.loc[bool_array]) --&gt; output where data_value &gt; 15</span><span id="1cd9" class="le lf hi jw b fi lk lh l li lj">#one-liner<br/>print(series2.loc[series2&gt;12])--&gt; output where data_value &gt; 12</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/083f025f3e6f66dfb028abf5992bcd07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvmt4xuwj6XQ6DJOorCkiQ.png"/></div></div></figure><p id="4267" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这和索引有点关系。loc属性串联，我们开始了解<code class="du jt ju jv jw b"><strong class="ix hj">slicing using .loc attribute</strong></code></p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="47fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">→ <strong class="ix hj">切片</strong> :-切片是一种机制，我们可以从不同的数据结构(如序列、数据帧等)中提取基于范围的子集。</p><blockquote class="kp kq kr"><p id="a905" class="iv iw ks ix b iy iz ja jb jc jd je jf kt jh ji jj ku jl jm jn kv jp jq jr js hb bi translated">与...一致。位置属性是指 <code class="du jt ju jv jw b"><strong class="ix hj">explicit labeled indexes</strong></code> <strong class="ix hj">中的序列和非位置/隐式索引:</strong></p></blockquote><p id="d904" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">切片格式→</strong>[开始]:[结束][:步长] →开始、结束和步长为整数，方括号表示可选值和</p><p id="b6ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">开始和结束包含在使用</strong> <code class="du jt ju jv jw b"><strong class="ix hj">.loc</strong></code>标记的索引切片中</p><p id="3ed2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">使用字符串标记的索引进行切片</strong> :-在下面的示例中，我们从值为‘a’的索引开始，一直移动到找到索引‘d’为止，并且两者都包含在内。</p><pre class="kw kx ky kz fd la jw lb lc aw ld bi"><span id="4dad" class="le lf hi jw b fi lg lh l li lj">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=['a','c','d','e','b','f'],<br/>          name='series_name1')</span><span id="1842" class="le lf hi jw b fi lk lh l li lj">print(series1.loc['a':'d'])<br/>print(series1.loc['a':'f':2])</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/8ae0ee6cddbb3d5f0cd8244f3fe8e264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWWN-T5NHamxNL0pJQKy7Q.png"/></div></div></figure><p id="761d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">使用整数标记索引进行切片:</strong></p><pre class="kw kx ky kz fd la jw lb lc aw ld bi"><span id="368a" class="le lf hi jw b fi lg lh l li lj">series2 = pd.Series([10,12,19,44,15,60],<br/>          index=[2,4,1,3,6,5],<br/>          name='series_name2')</span><span id="ebe2" class="le lf hi jw b fi lk lh l li lj">print(series2.loc[2:4])</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/ca1605988bce427f55dfba85e62c7285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXktRVw6S0B3Cz_P0hcItg.png"/></div></div></figure><p id="463c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果index不存在，我们尝试使用<code class="du jt ju jv jw b"><strong class="ix hj">.loc</strong></code>进行切片，我们会得到类似于indexing with的<code class="du jt ju jv jw b"><strong class="ix hj">key error</strong></code>。通信线路（LinesofCommunication）</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/6cb96731d224e6016d7d7263858151fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRyo3SKP8EmA4mTQZHUPaw.png"/></div></div></figure><p id="64e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> O </span></p><p id="199d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b"><strong class="ix hj">If we don’t provide any value for start , it start with the first index</strong></code>和</p><p id="dc97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b"><strong class="ix hj">if we don’t provide end , it will consider last index as end</strong></code>。</p><pre class="kw kx ky kz fd la jw lb lc aw ld bi"><span id="7936" class="le lf hi jw b fi lg lh l li lj">import pandas as pd<br/>series1 = pd.Series([10,12,19,44,15,60],<br/>          index=['a','c','d','e','b','f'],<br/>          name='series_name1')</span><span id="c3c7" class="le lf hi jw b fi lk lh l li lj">print(series1.loc[:'d'])<br/>print(series1.loc['e':])</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/9c44b9c59459a94433bf1b283d15902c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9m0C6PpRQx3WMHniiDUpug.png"/></div></div></figure></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="698b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，我希望您今天学到了一些新东西，在数据科学领域有很多与索引和切片相关的内容，但这是一个良好的开端😄</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="f626" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在系列的下一部分，我们将了解<code class="du jt ju jv jw b"><strong class="ix hj">.iloc attribute</strong></code>，敬请期待快乐学习！！</p></div></div>    
</body>
</html>