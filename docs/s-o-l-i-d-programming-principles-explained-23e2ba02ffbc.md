# 南解释了 O.L.I.D 编程原则

> 原文：<https://medium.com/analytics-vidhya/s-o-l-i-d-programming-principles-explained-23e2ba02ffbc?source=collection_archive---------20----------------------->

![](img/5b6c0bf31ffb8a193702d5261311e83d.png)

南 O.L.I.D 编程原则最初是由罗伯特·c·马丁(又名鲍勃大叔)阐明的。这些原则概述了面向对象的设计规则，旨在使大型代码库更容易维护、重用和扩展。它们还使开发团队在遵循敏捷原则的同时，更容易重构代码和添加新功能。

1.  单一责任原则
2.  o:开闭原则
3.  李:里斯科夫替代原理
4.  I:界面分离原理
5.  依赖倒置原则

**S —单一责任原则 SRP**

单一责任原则规定一个类应该有且只有一个责任/功能。例如:

现在假设我们想画正方形和圆形。为了实现绘制功能，我们有两个选项:

1.  为每个类添加一个 draw 方法，并编写绘图代码。这将导致正方形和圆形类也有责任绘制给定的形状，这是违反 SRP 的。每个 draw 方法都有自己的基于类的方法实现。

2.创建另一个名为 ShapeDrawer 的类，它将绘制任何给定的输入形状。该选项将使代码遵守 SRP 原则。

**O —开闭原理 OCP**

对象或实体应该对扩展开放，对修改关闭。

这个原则表明，一个类一旦被编写，就不应该对其进行修改，以防需要添加新的功能；相反，为了增加新的功能，这个类应该以一种易于扩展的方式创建。

再次考虑上面的代码片段:

可以看出，如果添加一个新的形状，如三角形，ShapeDrawer 类将需要通过添加另一个方法 drawTriangle 来修改，这违背了开闭原则。

下面的代码片段显示了如何使 ShapeDrawer 类变得易于扩展:通过创建一个 Shape 接口，然后在 Square 和 Circle 类中实现该接口，修改上面的 Square 和 Circle 示例，如下所示:

请注意上面 ShapeDrawer 类实现的变化。

**L —利斯科夫替代原理 LSP**

Liskov 替换原则指出，在不改变程序正确性的情况下，子类型应该可以替换为类型。

请考虑下面鲍勃大叔(罗伯特·c·马丁)解释利斯科夫替代原则的意思的话:

`Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.`

超类的任何子类化或者抽象(接口)的实现必须遵守抽象接口的需求和约定。

例如:

**I —接口隔离原则 ISP**

接口分离原则声明，消费者方法、接口实现或子类不应该被强制依赖于它不使用的方法。

以下是 ISP 遵守的修改示例。

**D —依存反演原理倾角**

依赖性反转原理陈述如下:

1.  高层模块不应该依赖低层模块。两者都应该依赖于抽象。
2.  抽象不应该依赖于细节。细节应该依赖于抽象。

假设我们有一个 PasswordReminder 类，它访问一个 MySQLConnection 对象来连接数据库并返回密码。

可以看出，PasswordReminder 类直接依赖于 MySQLConnection 对象。这很麻烦，并且违反了 DIP，因为如果明天我们决定将数据库迁移到 Teradata 会怎么样？我们将不得不再次重写这个类，这将违反开闭原则。

PasswordReminder 类应该与数据库无关，并且不应该关心特定的数据库引擎。为了使 PasswordReminder 数据库不可知，我们创建了一个接口:

假设我们想要添加一个 TeradataConnection 对象，现在我们只需创建一个 TeradataConnection 类，因为它在 PasswordReminder 类中使用。

**结论**

南 O.L.I.D 原则对于编写可维护、可重用和易于扩展的代码库非常重要。此外，这些原则也是相互关联的。就像如果我们应用开闭原则&利斯科夫替代原则，我们会自动确保依赖倒置原则。这一切都从单一责任的第一个原则开始，并归结为我们如何在代码中分离程序功能而不产生直接依赖。