<html>
<head>
<title>Using dependency injection and SOLID principles with Symfony: the Geocoding example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Symfony使用依赖注入和固体原理:地理编码示例</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dependency-injection-and-solid-principles-with-symfony-the-geocoding-example-f18ad08ed20b?source=collection_archive---------2-----------------------#2020-03-01">https://medium.com/analytics-vidhya/dependency-injection-and-solid-principles-with-symfony-the-geocoding-example-f18ad08ed20b?source=collection_archive---------2-----------------------#2020-03-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5c6cba9cca2e8a9ea15e49b536c75bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NBRsnHlnvoh9wS23"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@dead____artist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">捕捉人心。</a>号上<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></figcaption></figure><p id="a4fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">本文假设你对Symfony框架(制作控制器、实体、处理表单、构造器/方法注入……)、PHP7和OOP有基本的了解。</em></p><p id="729a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">撰写时使用的版本:<br/>PHP 7 . 4 . 1<br/>Symfony 4 . 4 . 4</em>T12】</strong></p><p id="26eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我的第一篇文章，希望你会喜欢。<br/>不要犹豫，提出任何你可能觉得有用的意见和/或建议！</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="0231" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">本文的目标</h1><p id="bfd5" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">本文的目标是提供一个地理编码功能实现的例子，使用Symfony并试图记住<a class="ae iu" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的原则</a>。</p><p id="9b68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我决定遵循这种形式:我们从一大块代码(最明显/简单的一个)开始，然后我们通过多个步骤将它分解成最终结果。</p><h1 id="b110" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">背景</h1><p id="1c5a" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">您正在开发一个包含“目的地”实体的“旅行”应用程序。此实体与“国家”实体有多对一链接。</p><p id="c8e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个目的地基本上是一个“城市”字符串字段，一个“坐标”<code class="du lj lk ll lm b">LatLng </code> <a class="ae iu" href="https://www.doctrine-project.org/projects/doctrine-orm/en/2.7/tutorials/embeddables.html" rel="noopener ugc nofollow" target="_blank">条令可嵌入</a>与2个“纬度”和“液化天然气”字符串字段，以及到“国家”的链接。</p><p id="9179" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你有一个管理界面，你可以在那里CRUD目的地，当你创建一个新的目的地时，你想检索一个目的地的GPS坐标，使用<a class="ae iu" href="https://wiki.openstreetmap.org/wiki/Nominatim" rel="noopener ugc nofollow" target="_blank">nom im OpenStreeMap API</a>。</p><p id="0c20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，您将能够在界面中的地图上锁定目的地。</p><h1 id="c40c" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">1 —让我们在控制器中处理它</h1><p id="9b9e" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">第一种方法是在控制器中处理表单提交，并检索我们的坐标。这将是我们的起点:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">DestinationController.php文件摘录，“新”控制器</figcaption></figure><p id="d323" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里做什么？</p><ul class=""><li id="370b" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">注入并使用带有参数类型提示的<a class="ae iu" href="https://symfony.com/doc/current/components/http_client.html" rel="noopener ugc nofollow" target="_blank"> HttpClient Symfony组件</a></li><li id="b00e" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">向OSM API发出请求</li><li id="f16a" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">创建嵌入的锁定对象并保存我们的目的地</li></ul><p id="2f0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">这里有什么问题？</strong></p><ul class=""><li id="d0bc" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">我们的控制器处理所有的逻辑。相反，它应该充当应用程序组件/服务之间的“粘合剂”。现在，它太长了，做了太多的事情</li><li id="43bd" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们的代码不是动态的(例如硬编码的OSM API URL)</li><li id="f7ee" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们的代码很难读懂</li><li id="f058" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们的代码很难测试</li><li id="03a9" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">因此，我们的代码很难维护/发展</li></ul><h1 id="26a8" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">2-分离服务中的地理编码逻辑</h1><p id="9c97" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">像许多框架一样，Symfony提供了一个<a class="ae iu" href="https://symfony.com/doc/current/service_container.html" rel="noopener ugc nofollow" target="_blank">服务容器</a>，它允许我们将应用程序的各个部分分成不同的服务。这有利于更好地分离特征。</p><p id="b442" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个新的地理编码服务:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的首个osm地理编码服务</figcaption></figure><p id="0d7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，由于<code class="du lj lk ll lm b">autowire: true</code> <a class="ae iu" href="https://symfony.com/doc/current/service_container.html#service-container-services-load-example" rel="noopener ugc nofollow" target="_blank">默认配置</a>，我们可以在我们的控制器中输入提示我们的服务:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="ff51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们做了什么？</p><ul class=""><li id="b9b6" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">我们将地理编码逻辑分离到它自己的服务中</li><li id="84a1" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们的代码可读性更强:更容易理解<code class="du lj lk ll lm b">$geocodingService-&gt;geocode...</code></li></ul><p id="caa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自罗伯特·c·马丁的《<a class="ae iu" href="https://www.amazon.fr/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/" rel="noopener ugc nofollow" target="_blank">清洁守则</a>》一书，在第十章“类”中，有一节是关于“单一责任原则”(SRP)的，说:</p><blockquote class="mh mi mj"><p id="f06a" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">我们希望我们的系统由许多小类组成，而不是几个大类。每个小类都封装了一个单独的职责，有一个单独的变更理由，并与其他一些人合作来实现期望的系统行为。<br/>(来源:干净的代码，罗伯特·c·马丁)</p></blockquote><p id="ee37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几年后，Robert C. Martin在他的书“<a class="ae iu" href="https://www.amazon.fr/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>”中提到了单一责任原则(SRP)的最终版本:</p><blockquote class="mh mi mj"><p id="9c6b" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">一个<strong class="ix hj">模块</strong>应该只对一个<strong class="ix hj">角色</strong>负责。</p></blockquote><p id="6ed4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="ix hj">模块</strong>可以被认为是一个源文件，或者一组"<em class="jt">内聚的函数和数据结构</em>"(来源:“Clean Architecture”，Robert C. Martin)。</p><p id="882b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="ix hj">参与者</strong>通常是，对于一个给定的必需的变更，“一个或者多个人需要那个变更”(来源:“干净的架构”，Robert C. Martin)。</p><p id="9406" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们将一个地理编码逻辑分离成一个新的类(一个源文件)。这可以被认为是一个模块。</p><p id="b54c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果，对于一个给定的场景，这个模块负责一个参与者，这意味着它改变的唯一原因是因为一个参与者的需求，从“干净的架构”的角度来看，这可以被认为是一个更好的SRP，即坚实原则的<strong class="ix hj"> S </strong>。</p><p id="ea55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在这里，参考SRP的“干净代码”定义可能更方便:我们的目标更多的是将一个职责封装到一个类中。</p><p id="fd38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢<a class="ae iu" rel="noopener" href="/@vlcek.rx">弗尔切克Rx </a>指出这一点。</p><p id="a93a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">有哪些问题？</strong></p><p id="0081" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的代码可能看起来更好，但我们仍然有一些东西要修复:</p><ul class=""><li id="3b95" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">在我们的<code class="du lj lk ll lm b">OsmGeocoding </code>服务中，我们硬编码了OSM API Url</li><li id="22a5" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们的控制器与<code class="du lj lk ll lm b">OsmGeocoding </code>服务紧密耦合</li><li id="caae" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们在<code class="du lj lk ll lm b">geocode </code>方法中检索所有地理编码数据，然后只返回<code class="du lj lk ll lm b">coordinates </code></li></ul><h1 id="dbec" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">3 —改善我们的服务</h1><p id="0d24" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">在控制器“耦合”部分之前，让我们首先关注我们的服务。</p><p id="066c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的地理编码服务还不错，但还可以做得更好。我们可以以一种允许我们以后添加更多方法的方式来设计它，并且我们可以将基本URL变成应用程序参数，这样，如果/当它改变时，我们将能够非常容易地更新它。</p><p id="bd54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du lj lk ll lm b">services.yaml</code>文件中定义一个新的<a class="ae iu" href="https://symfony.com/doc/current/best_practices.html#use-parameters-for-application-configuration" rel="noopener ugc nofollow" target="_blank">应用参数</a>；</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们新的“app.api_osm_base_url”应用程序参数</figcaption></figure><p id="b88f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过添加新的私有<code class="du lj lk ll lm b">$baseUrl</code>字段和带有新参数的构造函数签名来更改您的服务:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="ceb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们可以<a class="ae iu" href="https://symfony.com/doc/current/service_container.html#manually-wiring-arguments" rel="noopener ugc nofollow" target="_blank">手动将参数</a>连接到我们的应用程序参数:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f1f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们只是告诉服务容器将参数值注入到服务构造函数中。该服务现在可以依靠该字段来发出请求:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用服务容器注入的参数</figcaption></figure><p id="3b88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以通过定义一个公共的<code class="du lj lk ll lm b">getLatLng</code>方法来进一步改进我们的服务。这将让<code class="du lj lk ll lm b">geocode</code>方法自由地用于其他任何事情，因为它提供了所有的地理编码信息。我们还可以将<code class="du lj lk ll lm b">geocode</code>设为私有，以便从外部强制使用我们的公共<code class="du lj lk ll lm b">getLatLng</code>方法，或者我们将在以下情况后实现的任何其他方法:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的服务有一个新的公共方法getLatLng</figcaption></figure><p id="3c6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，我们现在必须在控制器中使用<code class="du lj lk ll lm b">getLatLng</code>方法。<br/>变化:</p><pre class="ln lo lp lq fd mn lm mo mp aw mq bi"><span id="a40b" class="mr kc hi lm b fi ms mt l mu mv">$coordinates = $geocodingService-&gt;geocode($location);</span></pre><p id="e7be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">收件人:</p><pre class="ln lo lp lq fd mn lm mo mp aw mq bi"><span id="19a3" class="mr kc hi lm b fi ms mt l mu mv">$coordinates = $geocodingService-&gt;getLatLng($location);</span></pre><p id="7db4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们做了什么？</p><ul class=""><li id="2b7e" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">将OSM API基本Url放入应用程序参数中，并将其注入我们的OsmGeocoding服务(更易于维护)</li><li id="4195" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">定义一个新的<code class="du lj lk ll lm b">getLatLng</code>方法来提高我们服务的可用性和可读性。<code class="du lj lk ll lm b">geocode</code>方法现在是私有的，因为它提供所有的地理编码信息，没有任何区别。如果我们需要更多的信息或者信息的组合，我们现在能够定义新的公共方法。但是我们只会把必要的东西还给外面</li></ul><p id="4db8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">有哪些问题？</strong></p><p id="5e83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们仍然有一个问题:<code class="du lj lk ll lm b">DestinationController</code>与我们的<code class="du lj lk ll lm b">OsmGeocoding</code>服务紧密耦合。</p><ul class=""><li id="9d80" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">如果我们必须使用谷歌地图，会发生什么？或任何其他地理编码提供商？</li><li id="b159" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">控制器真的需要知道使用的是哪个地理编码提供者吗？</li><li id="6b58" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">如果我需要使用不同的地理编码提供程序(例如，基于用户计划),该怎么办？它可能是免费计划的OpenStreetMap，以及付费计划的改进功能的谷歌地图…</li></ul><h1 id="4abb" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">4-抽象地理编码过程</h1><p id="71c0" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">嗯，这一节的标题是剧透，但我觉得这是最有趣的部分。</p><p id="e364" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经看到了坚实原则的<strong class="ix hj"> S </strong>。通过创建新的抽象层次，并以特定的方式组织我们的类/接口，我们也将利用<strong class="ix hj"> O </strong>、<strong class="ix hj"> L </strong>和<strong class="ix hj"> D </strong>。</p><p id="b4ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，让我们问自己正确的问题，而不是首先考虑固体。基本的问题是:我们如何才能摆脱紧密的<code class="du lj lk ll lm b">OsmGeocoding</code> / <code class="du lj lk ll lm b">DestinationController </code>耦合？</p><p id="cb3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">毕竟，问题是:<code class="du lj lk ll lm b">DestinationController</code>真的需要知道地理编码过程是由<code class="du lj lk ll lm b">OsmGeocoding</code>服务操作的吗？</p><p id="efc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">如果我们的控制器只使用一个“地理编码服务”，而不知道执行的是哪一个，不是更好吗？可能是OpenStreetMap、谷歌地图……如果我们将来需要使用的话。</strong></p><p id="f22b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以考虑，对于我们的应用程序，“地理编码服务”通常应该是一个具有<code class="du lj lk ll lm b">getLatLng</code>方法的类。我们应该为此定义一个<strong class="ix hj">契约</strong>，因为<em class="jt">这就是我们现在需要的地理编码服务</em>。</p><p id="0b3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这正是一个<a class="ae iu" href="https://www.php.net/manual/en/language.oop5.interfaces.php" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">接口</strong> </a>的定义。</p><p id="2b71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建它:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="2d48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事情是这样的，我们已经让我们的<code class="du lj lk ll lm b">OsmGeocoding </code>实现了一个<code class="du lj lk ll lm b">getLatLng</code>公共方法，正如我们的接口中所描述的。所以我们可以说<code class="du lj lk ll lm b">OsmGeocoding</code>T10实现了T3:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="7efd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里所做的是通过创建接口来创建地理编码服务的<strong class="ix hj">通用定义。这个接口告诉我们“地理编码服务必须有一个<code class="du lj lk ll lm b">getLatLng</code>公共方法”。顺便说一句:</strong></p><blockquote class="mh mi mj"><p id="5fbb" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">接口中声明的所有方法都必须是公共的；这就是界面的本质(来源:<a class="ae iu" href="https://www.php.net/manual/en/language.oop5.interfaces.php" rel="noopener ugc nofollow" target="_blank">PHP.net</a>)。</p></blockquote><p id="bdf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们用<code class="du lj lk ll lm b">OsmGeocoding</code>实现了地理编码服务的第一个具体实现。</p><p id="3bc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，这样做允许我们在<code class="du lj lk ll lm b">DestinationController</code>中改变我们的类型提示:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="c636" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Symfony实际上在他们的<a class="ae iu" href="https://symfony.com/doc/current/service_container/autowiring.html#working-with-interfaces" rel="noopener ugc nofollow" target="_blank">文档</a>中告诉我们:</p><blockquote class="mh mi mj"><p id="964e" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">当使用<a class="ae iu" href="https://symfony.com/blog/new-in-symfony-3-3-psr-4-based-service-discovery" rel="noopener ugc nofollow" target="_blank">服务定义原型</a>时，如果只发现一个实现接口的服务，并且该接口也在同一个文件中被发现，则配置别名不是强制性的，Symfony将自动创建一个。</p></blockquote><p id="23eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只有<code class="du lj lk ll lm b">OsmGeocoding</code>实现<code class="du lj lk ll lm b">IGeocoding</code>，所以服务容器会在看到<code class="du lj lk ll lm b">IGeocoding </code>类型提示时自动注入它。您可以通过在控制台中执行以下命令来验证这一点:</p><pre class="ln lo lp lq fd mn lm mo mp aw mq bi"><span id="5344" class="mr kc hi lm b fi ms mt l mu mv">php bin/console debug:autowiring Geocoding</span></pre><p id="b867" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这应该会输出如下内容:</p><pre class="ln lo lp lq fd mn lm mo mp aw mq bi"><span id="0e59" class="mr kc hi lm b fi ms mt l mu mv">Autowirable Types<br/>=================</span><span id="089c" class="mr kc hi lm b fi mw mt l mu mv">The following classes &amp; interfaces can be used as type-hints when autowiring:<br/> (only showing classes/interfaces matching Geocoding)</span><span id="85c5" class="mr kc hi lm b fi mw mt l mu mv">App\Geocoding\IGeocoding (App\Geocoding\OsmGeocoding)</span></pre><p id="09a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里做了3件事(我们将在后面润色) :</p><ul class=""><li id="a509" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> O </strong>笔封闭原则</a> ( <strong class="ix hj"> <em class="jt">未完成但第一个版本</em> </strong>):通过创建一个新的抽象层次，<strong class="ix hj">我们将代码开放给扩展而不是修改</strong>。如果我们需要一个新的地理编码服务，我们不需要修改<code class="du lj lk ll lm b">OsmGeocoding</code>，但是我们可以创建一个新的实现，一个新的具体的类来代替<code class="du lj lk ll lm b">implements IGeocoding</code>。我们将在后面看到如何完成这一点，因为我们在<code class="du lj lk ll lm b">OsmGeocoding</code>中还有<code class="du lj lk ll lm b">geocode</code>方法，它还不是地理编码服务通用规范的一部分。</li><li id="813d" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> D </strong>依赖倒置原则</a>:在<code class="du lj lk ll lm b">DestinationController</code>中，我们现在依赖的是地理编码服务的抽象<code class="du lj lk ll lm b">IGeocoding</code>，而不是地理编码服务的具体实现<code class="du lj lk ll lm b">OsmGeocoding</code>。我们将控制器从<code class="du lj lk ll lm b">OsmGeocoding</code>中分离出来，使我们的架构更加灵活。</li><li id="45cc" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> L </strong>伊斯科夫替换原则</a>:我们在<code class="du lj lk ll lm b">IGeocoding</code>中为<code class="du lj lk ll lm b">getLatLng</code>定义了一个签名，比如“它必须返回<code class="du lj lk ll lm b">LatLng|null</code>”。这样，当我们的应用程序将使用<code class="du lj lk ll lm b">IGeocoding</code>的一个子类型，即一个具体的地理编码服务的实例时，实现的<code class="du lj lk ll lm b">getLatLng</code>方法的行为将保持一致。举例来说，如果我们选择返回一个<code class="du lj lk ll lm b">array</code>，这将是不一致的，因为我们没有指定的格式，我们可以将子类中的任何东西返回到这个数组中。</li></ul><h1 id="fcf1" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">5-让我们完成并抛光它</h1><p id="af69" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">为了拥有一个可扩展的模型，让我们定义一个地理编码服务是一个<code class="du lj lk ll lm b">AbstractGeocoding</code>对象，实现<code class="du lj lk ll lm b">IGeocoding.</code></p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/e4f5741a80a26c024a4c40b5627c85a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*g-rzAEYJAOYpRY3lPF1FQA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用<a class="ae iu" href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" rel="noopener ugc nofollow" target="_blank"> PlantUML </a>制造</figcaption></figure><p id="d7cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些都在抽象类中受到保护。</p><p id="8e75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于<code class="du lj lk ll lm b">geocode </code>方法来说没问题，因为它是私有的，我们不能把它放入基本接口。</p><p id="aaa6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们将其抽象，因为我们只想使用<code class="du lj lk ll lm b">OsmGeocoding</code>或其他具体的类，还因为我们想在子类中实现<code class="du lj lk ll lm b">getLatLng</code>和<code class="du lj lk ll lm b">geocode </code>方法，例如<code class="du lj lk ll lm b">OsmGeocoding</code>。</p><p id="a1bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们有一个开放的架构来实现更具体的类。</p><blockquote class="mh mi mj"><p id="fce8" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">等等，要用谷歌地图，我需要用一个API密匙！</p></blockquote><p id="4c8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，那么，让我们定义另一个抽象地理编码类型，它可以使用一个API键:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es my"><img src="../Images/ba80dae03e93a3a253ec26619ec5293b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*j70QMlLixgmhMgSfIZAmMw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用<a class="ae iu" href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" rel="noopener ugc nofollow" target="_blank"> PlantUML </a>制造</figcaption></figure><p id="fa8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们只有2个具体的类:GoogleMapsGeocoding和OsmGeocoding。</p><h2 id="a20f" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">关于API密钥</h2><p id="181c" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">我们可以将API键定义为<code class="du lj lk ll lm b">.env.local</code>中的一个env变量，然后使用参数注入:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h2 id="501e" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">配置服务容器以在实现之间进行选择</h2><p id="1073" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">现在我们已经有了地理编码服务的<strong class="ix hj"> 2个实现</strong>，我们必须配置服务容器<strong class="ix hj">实际上选择了一个</strong>。</p><p id="51eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以很容易地在<code class="du lj lk ll lm b">services.yaml</code>中配置它:</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4f2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们只是告诉容器，如果他遇到了<code class="du lj lk ll lm b">IGeocoding</code>类型提示，就选择注入<code class="du lj lk ll lm b">OsmGeocoding</code>服务。</p><p id="66a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于语法中的' @ '，Symfony在他们来自<a class="ae iu" href="https://symfony.com/doc/current/service_container.html#choose-a-specific-service" rel="noopener ugc nofollow" target="_blank">文档</a>的例子中告诉我们:</p><blockquote class="mh mi mj"><p id="373f" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">' @ '符号很重要:它告诉容器<br/>你想要传递id为' monolog.logger.request '，<br/>的*service*，而不仅仅是* string * ' monolog . logger . request '</p></blockquote><h1 id="8075" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">6-最后(但并非最不重要)</h1><p id="339e" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">这里我们遇到的最后一个问题是，我们只在控制器中检索坐标。<br/> <strong class="ix hj">如果我在应用程序中从另一个地方创建目的地会怎样</strong>？将执行的不是同一个控制器，然后……我将不得不<strong class="ix hj">复制我的代码</strong>(这很糟糕)，以便能够使用地理编码服务并再次实现相同的逻辑。</p><h2 id="7bff" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">利用事件订阅者自动进行坐标检索</h2><p id="88df" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">这里的解决方案是创建一个<a class="ae iu" href="https://symfony.com/doc/current/event_dispatcher.html" rel="noopener ugc nofollow" target="_blank">事件订阅者或事件监听器</a>。当实体管理器将要保存一个目的地时，它唯一的任务是检索坐标并用结果填充目的地。</p><p id="de11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要做到这一点，我们可以听一个<a class="ae iu" href="https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/events.html#lifecycle-events" rel="noopener ugc nofollow" target="_blank">学说生命周期事件</a>(例如prePersist)。因此，当实体管理器将要持久化目的地时，我们从<code class="du lj lk ll lm b">IGeocoding</code>依赖关系中触发坐标检索。每当要创建一个新的目的地时，这就会在应用程序中的任何地方触发。</p><blockquote class="mh mi mj"><p id="ee68" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">由于这不是本文的主题，我也不想让它太长，所以我没有在这里放任何代码。但是您可以在我放在文章末尾的示例应用程序中找到事件订阅者实现，在Github repo中。我认为它值得一提，因为它帮助我们分离代码并自动化一些操作。</p></blockquote><h1 id="3e08" class="kb kc hi bd kd ke le kg kh ki lf kk kl km lg ko kp kq lh ks kt ku li kw kx ky bi translated">结论</h1><p id="7f3a" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">有了这种实现，我们做了什么？</p><h2 id="62ed" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">单一责任原则</h2><p id="1d72" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">根据“干净的架构”这本书，SRP是关于参与者的。这里，我们的例子可能更多的是关于“干净的代码”一书的定义:这里的目标是将我们的代码分成不同的部分。结果是<strong class="ix hj">的代码乍一看可能不容易理解，但是更容易维护、发展和测试</strong>(单元/功能测试不是本文的主题)。</p><h2 id="2d98" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">以后扩展我们架构的可能性(开闭原则)</h2><p id="4a59" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">这种架构允许我们在需要时<strong class="ix hj">扩展它</strong>。我们没有设计一个封闭的、过于具体的架构，而是保留了一些特性，但是它们被封装在具体的、最终的类中。这些类继承自抽象类和接口，这样我们可以在将来定义更具体的类。每一个具体的类都有自己的行为，继承自父类的定义。</p><h2 id="4487" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">依赖抽象而不是具体的类(依赖倒置)</h2><p id="22d0" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">通过引入<code class="du lj lk ll lm b">IGeocoding</code>接口，我们定义了一个<strong class="ix hj">通用行为</strong>，它必须在较低的级别(具体类)实现。然后，具体的行为将取决于注入服务的具体类型。</p><p id="7e3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们甚至可以实现一个动态选择地理编码服务的<strong class="ix hj">特性</strong>，使用一个<a class="ae iu" href="https://symfony.com/doc/current/service_container/service_subscribers_locators.html" rel="noopener ugc nofollow" target="_blank">服务订阅者</a>或者一个具有服务定位器依赖的工厂。唯一的条件是有一个<code class="du lj lk ll lm b">IGeocoding</code>实例作为返回类型。</p><h2 id="6490" class="mr kc hi bd kd mz na nb kh nc nd ne kl jg nf ng kp jk nh ni kt jo nj nk kx nl bi translated">利斯科夫替代原理</h2><p id="586b" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">因为我们有一个定义方法的父接口，所以我们确保子类将与这个定义保持一致。所以，当我们对一个<code class="du lj lk ll lm b">IGeocoding</code>类型、<strong class="ix hj">有依赖时，我们知道任何具体使用的对象都会实现这个契约</strong>，比如“当我调用<code class="du lj lk ll lm b">getLatLng</code>时，返回一个<code class="du lj lk ll lm b">LatLng</code>对象”。</p><p id="6e90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们没有看到“I”(针对<a class="ae iu" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原理</a>)，因为我们这里只有一个接口。如果我们仅在所有具体地理编码提供程序的子集中拥有一些新要素，我们可能需要这一原则。然后，我们应该分离方法定义，以避免在具体类中不需要这些方法的空的和无用的实现。</p><blockquote class="mh mi mj"><p id="f6c2" class="iv iw jt ix b iy iz ja jb jc jd je jf mk jh ji jj ml jl jm jn mm jp jq jr js hb bi translated">当然，这是实现该特性的一种方式，还有许多其他方式。有更简单的，更普通的，这取决于你喜欢/需要什么和你有多少时间。</p></blockquote><p id="942b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你会在Github上找到一个示例应用，这里:<a class="ae iu" href="https://github.com/ld-web/medium-sf-di-solid-geocoding" rel="noopener ugc nofollow" target="_blank">https://github.com/ld-web/medium-sf-di-solid-geocoding</a></p><p id="edae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要犹豫评论和/或建议任何你可能发现有用的东西！</p></div></div>    
</body>
</html>