<html>
<head>
<title>The Foundations for Building an Apache Flink Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Apache Flink应用程序的基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-an-apache-flink-application-from-scratch-7d12ce00de8d?source=collection_archive---------2-----------------------#2020-04-14">https://medium.com/analytics-vidhya/building-an-apache-flink-application-from-scratch-7d12ce00de8d?source=collection_archive---------2-----------------------#2020-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f853" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Flink自底向上理解流处理；云服务和其他平台提供了流处理解决方案(对一些人来说，Flink是在引擎盖下集成的)。如果你错过了基本的，这个指南是给你的。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bc801e4151dc8245920ef4d6765e928d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4JM65qw3lOdVbID9EgcZA.png"/></div></div></figure><p id="a55a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的monolith解决方案无法应对不断增加的传入数据负载，因此必须不断发展。这是我们下一代产品的时候了。与我们到目前为止实现的批处理相比，流处理是新的数据摄取范例。</p><p id="e392" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，我的团队开始使用Flink处理信息。关于Flink的特性和优势有大量的文章，Cloudera分享了一张关于Flink 的<a class="ae kf" href="https://www.slideshare.net/secret/lEfaV6zHhdHY91" rel="noopener ugc nofollow" target="_blank">精彩幻灯片；本文是关于如何从基础开始构建一个简单的流处理应用程序的实践指南。</a></p><h1 id="5912" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">阿帕奇Flink两句话</h1><p id="9820" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">Apache Flink是一个可伸缩的分布式流处理框架，意味着能够处理连续的数据流。这个框架提供了各种功能:源、流转换、并行处理、调度、资源分配和各种目的地。它的一些连接器是HDFS，卡夫卡，亚马逊Kinesis，RabbitMQ和Cassandra。</p><p id="e165" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Flink以其高吞吐量和低延迟而闻名，支持恰好一个一致性(所有数据处理一次，没有重复)，并且它还支持高可用性。像任何其他成功的开源产品一样，它有一个广泛的社区来培养和扩展它的特性。</p><p id="13a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Flink可以处理不确定的数据流或确定的数据集。本博客将重点讨论前者(使用数据流对象)。</p><h1 id="8103" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">流处理—挑战</h1><p id="6b6b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">如今，当物联网设备和其他传感器无处不在时，数据从许多来源源源不断地流出。这种源源不断的数据迫使传统的批处理计算进行调整。</p><ul class=""><li id="8f0a" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">这个数据是无界的；没有开始和结束。</li><li id="c10d" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">新数据的不可预测和不一致的间隔。</li><li id="58c7" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">数据可能是无序的，有不同的时间戳。</li></ul><p id="13f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于这些独特的特征，处理和查询数据是复杂的任务。结果变化很快，几乎不可能得到确定的结论；有时，在试图产生有效结果时，计算可能会受到阻碍。此外，由于数据不断变化，结果不可重复。最后，延迟是一个影响结果准确性的因素。</p><p id="80b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Apache Flink通过基于传入数据源中的时间戳进行处理来解决这些问题。它有一种机制，在应用处理执行之前，根据事件的时间戳来累积事件。它消除了微量批次的使用，从而提高了结果的准确性。</p><p id="20ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Flink实现了恰好一次一致性，这确保了计算的正确性，而无需开发人员为其编程。</p><h1 id="0130" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">基础——Flink软件包构建模块</h1><p id="8e23" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">弗林克主要吸收各种来源的水流。基本对象是<code class="du lr ls lt lu b">DataStream&lt;T&gt;</code>，表示同类型元素的流；其元素的类型在编译时通过设置泛型类型T来定义(在这里阅读关于<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/DataStream.html" rel="noopener ugc nofollow" target="_blank">数据流对象</a>)。</p><p id="9f49" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">数据流对象包含许多有用的方法来转换、分割和过滤它的数据[1]。熟悉的方法<em class="lv">地图，减少，</em>和<em class="lv">过滤器</em>是一个好的开始；这些是主要的转换方法:</p><ul class=""><li id="1e56" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj"> Map: </strong>接收T对象，返回R类型对象的结果；映射函数在数据流对象的每个元素上只应用一次<strong class="jl hj">。</strong></li></ul><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="5423" class="ma kh hi lu b fi mb mc l md me"><a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/SingleOutputStreamOperator.html" rel="noopener ugc nofollow" target="_blank">SingleOutputStreamOperator</a>&lt;R&gt; <a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.3/api/java/org/apache/flink/api/common/functions/MapFunction.html" rel="noopener ugc nofollow" target="_blank">map</a>(<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/api/common/functions/MapFunction.html" rel="noopener ugc nofollow" target="_blank">MapFunction</a>&lt;<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/DataStream.html" rel="noopener ugc nofollow" target="_blank">T</a>,R&gt; mapper)</span></pre><ul class=""><li id="1259" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj"> Reduce: </strong>接收两个连续的值，<strong class="jl hj">将它们组合成同一个对象类型后返回一个对象</strong>；该方法对组中的所有值运行，直到只剩下一个值。</li></ul><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="f85e" class="ma kh hi lu b fi mb mc l md me"><a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/api/common/functions/ReduceFunction.html#reduce-T-T-" rel="noopener ugc nofollow" target="_blank">T reduce(T value1, T value2)</a></span></pre><ul class=""><li id="a31a" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj"> Filter: </strong>接收T对象，返回T对象流；此方法对数据流中的每个元素运行，但只返回函数返回true的元素。</li></ul><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="5463" class="ma kh hi lu b fi mb mc l md me"><a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/SingleOutputStreamOperator.html" rel="noopener ugc nofollow" target="_blank">SingleOutputStreamOperator</a>&lt;<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/DataStream.html" rel="noopener ugc nofollow" target="_blank">T</a>&gt; filter(<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/api/common/functions/FilterFunction.html" rel="noopener ugc nofollow" target="_blank">FilterFunction</a>&lt;<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/DataStream.html" rel="noopener ugc nofollow" target="_blank">T</a>&gt; filter)</span></pre><h2 id="3fbd" class="ma kh hi bd ki mf mg mh km mi mj mk kq js ml mm ks jw mn mo ku ka mp mq kw mr bi translated">数据接收装置</h2><p id="9276" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">除了转换数据，Flink的主要目的是在将数据流处理成不同的目的地后，对其进行控制。这些目的地被称为“汇点”。Flink具有内置的接收器(text、CSV、socket)，以及到其他系统的开箱即用的连接器(如Apache Kafka)[2]。</p><h2 id="67ce" class="ma kh hi bd ki mf mg mh km mi mj mk kq js ml mm ks jw mn mo ku ka mp mq kw mr bi translated">Flink事件时间戳</h2><p id="3c47" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">时间的概念对于处理数据流是至关重要的。定义时间戳有三个选项:</p><ul class=""><li id="0e6c" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">处理时间</strong>(默认选项)<strong class="jl hj"> : </strong>是执行流处理操作的机器的系统时间，因此是最简单的时间概念；它不需要流和机器之间的任何协调。因为它基于机器的时间，所以它提供了最佳的性能和最低的延迟。<br/>使用<em class="lv">处理时间</em>的缺点在分布式和异步环境中很明显，因为它不是一种确定性的方法。如果机器时钟之间有间隙，流事件的时间戳可能会不同步；网络延迟还会在事件离开一台机器和到达另一台机器的时间之间产生差距。</li></ul><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="2972" class="ma kh hi lu b fi mb mc l md me">// Setting the <em class="lv">Processing Time</em> attribute of <!-- -->StreamExecutionEnvironment object</span><span id="50e3" class="ma kh hi lu b fi ms mc l md me">streamEnv<strong class="lu hj">.</strong>setStreamTimeCharacteristic<strong class="lu hj">(TimeCharacteristic.</strong>ProcessingTime<strong class="lu hj">);</strong></span></pre><ul class=""><li id="cf1e" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">事件时间:</strong>是指在进入Flink之前，每个单个事件在其产生源上接收的时间。事件时间嵌入在事件本身中，可以提取出来，以便Flink可以正确地处理它。<br/>因为时间戳不是由Flink设置的，所以应该有一种机制来通知事件是否应该被处理；这种机制被称为<em class="lv">水印。这个话题超出了这篇博文的范围(因为我想保持简洁)；你可以在<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/event_time.html#event-time-and-watermarks" rel="noopener ugc nofollow" target="_blank"> Flink文档</a>中找到更多信息。</em></li></ul><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="d6ed" class="ma kh hi lu b fi mb mc l md me">// Defining the <em class="lv">Event Time</em> as the timestamp method<br/>streamEnv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><span id="89b9" class="ma kh hi lu b fi ms mc l md me">DataStream&lt;String&gt; dataStream<br/>   = streamEnv.readFile(auditFormat,<br/>          dataDir,    // the progon of the events<br/>          FileProcessingMode.PROCESS_CONTINUOUSLY,<br/>          1000).<br/>          <strong class="lu hj">assignTimestampsAndWatermarks</strong>(<br/>                  new TimestampExtractor());</span><span id="ca1d" class="ma kh hi lu b fi ms mc l md me">// ... more code ...</span><span id="7356" class="ma kh hi lu b fi ms mc l md me">// Defining a class to extract the timestamp from the stream events<br/>public class TimestampExtractor implements <br/>                AssignerWithPeriodicWatermarks&lt;String&gt;{</span><span id="58b7" class="ma kh hi lu b fi ms mc l md me">@Override<br/>public Watermark getCurrentWatermark() {<br/>      return new Watermark(System.<em class="lv">currentTimeMillis</em>()-maxTimeFrame);<br/>   }</span><span id="c120" class="ma kh hi lu b fi ms mc l md me">@Override<br/>public long extractTimestamp(String str, long l) {<br/>     return InputData.<em class="lv">getDataObject</em>(str).timestamp;<br/>   }<br/>}</span></pre><ul class=""><li id="e00a" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">摄取时间:</strong>指事件进入Flink的时间；它在源处被分配一次，因此被认为比在开始处理时分配的<em class="lv">处理时间</em>更稳定。<br/> <em class="lv">摄取时间</em>无法处理无序事件或延迟数据，因为一旦摄取开始，就会设置时间戳，而<em class="lv">事件时间</em>具有识别延迟事件并基于水印机制处理它们的功能。</li></ul><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="4eee" class="ma kh hi lu b fi mb mc l md me">// Setting the <em class="lv">Ingestion Time</em> attribute of <!-- -->StreamExecutionEnvironment object</span><span id="4ce1" class="ma kh hi lu b fi ms mc l md me">streamEnv<strong class="lu hj">.</strong>setStreamTimeCharacteristic<strong class="lu hj">(TimeCharacteristic.</strong>IngestionTime<strong class="lu hj">);</strong></span></pre><p id="0ae0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可以在下面的链接中阅读更多关于时间戳以及它如何影响流处理的信息。</p><h2 id="89ab" class="ma kh hi bd ki mf mg mh km mi mj mk kq js ml mm ks jw mn mo ku ka mp mq kw mr bi translated">开窗术</h2><p id="1b5b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">顾名思义，一条小溪是没有尽头的；因此，处理的机制是通过定义帧(例如，基于时间的窗口)。这样，流就被划分到桶中进行聚合和分析。窗口定义是对一个<code class="du lr ls lt lu b">DataStream </code>对象或其一个继承者的操作。</p><p id="2f79" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有几个基于时间的窗口:</p><ul class=""><li id="bd87" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">翻滚窗口(默认配置):<br/> </strong>将流分成大小相等的窗口，没有任何重叠。只要流在流动，Flink就根据这个固定的时间框架连续计算数据。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/b1963ffcc18300ab374e45d4c8639a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3txRzNeVJpfBycxRa59TrQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">翻滚窗口插图</figcaption></figure><p id="1997" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">代码实现:</p><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="c100" class="ma kh hi lu b fi mb mc l md me">// To be used for a non-keyed stream<br/>public <a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/AllWindowedStream.html" rel="noopener ugc nofollow" target="_blank">AllWindowedStream</a>&lt;<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/datastream/DataStream.html" rel="noopener ugc nofollow" target="_blank">T</a>,<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.html" rel="noopener ugc nofollow" target="_blank">TimeWindow</a>&gt; timeWindowAll(<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/api/java/org/apache/flink/streaming/api/windowing/time/Time.html" rel="noopener ugc nofollow" target="_blank">Time</a> size)</span><span id="1697" class="ma kh hi lu b fi ms mc l md me">// Tumbling window for a key-based stream<br/>public <a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.6/api/java/org/apache/flink/streaming/api/datastream/WindowedStream.html" rel="noopener ugc nofollow" target="_blank">WindowedStream</a>&lt;<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.6/api/java/org/apache/flink/streaming/api/datastream/KeyedStream.html" rel="noopener ugc nofollow" target="_blank">T</a>,<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.6/api/java/org/apache/flink/streaming/api/datastream/KeyedStream.html" rel="noopener ugc nofollow" target="_blank">KEY</a>,<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.6/api/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.html" rel="noopener ugc nofollow" target="_blank">TimeWindow</a>&gt; timeWindow(<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.6/api/java/org/apache/flink/streaming/api/windowing/time/Time.html" rel="noopener ugc nofollow" target="_blank">Time</a> size)</span></pre><ul class=""><li id="a3b2" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">滑动窗口<br/> </strong>由窗口大小和偏移量(何时开始下一个窗口)组成的重叠窗口。这样，在给定时间内，可以在多个窗口中处理事件。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/549fd0e090623732aa42f6ab03a4ceac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmiSsTfCcMgcs5it_-jhOw.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">滑动窗口插图</figcaption></figure><p id="947b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是它在代码中的样子:</p><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="a1c1" class="ma kh hi lu b fi mb mc l md me"><em class="lv">// sliding time window of 1 minute length and 30 secs trigger interval<br/></em>dataStreamObject<strong class="lu hj">.</strong>timeWindow<strong class="lu hj">(Time.</strong>minutes<strong class="lu hj">(</strong>1<strong class="lu hj">),</strong> <strong class="lu hj">Time.</strong>seconds<strong class="lu hj">(</strong>30<strong class="lu hj">))</strong></span></pre><ul class=""><li id="89a5" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">会话窗口<br/> </strong>包括会话边界下的所有事件。当在定义的时间范围内没有活动或事件时，会话结束。基于所处理的事件，该时间范围可以是固定的或动态的。从理论上讲，如果会话的事件间隔小于窗口大小，会话就永远不会结束。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/3c9ec725a9b03e811279696462bb5b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LnmfJoasRPXxvkCNDZdQQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">会话窗口图示</figcaption></figure><p id="1cad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的第一个代码片段举例说明了一个基于固定时间的会话(2秒)。第二个会话窗口基于流的事件实现了一个动态窗口。</p><pre class="iy iz ja jb fd lw lu lx ly aw lz bi"><span id="d0d4" class="ma kh hi lu b fi mb mc l md me">// Defining a fixed session window of 2 seconds<br/>dataStreamObject<strong class="lu hj">.</strong>window<strong class="lu hj">(ProcessingTimeSessionWindows.</strong>withGap<strong class="lu hj">(</strong>Time<strong class="lu hj">.</strong>seconds<strong class="lu hj">(</strong>2<strong class="lu hj">)))</strong></span><span id="54bd" class="ma kh hi lu b fi ms mc l md me">// Defining a dynamic window session, which can be set by the stream elements<br/>dataStreamObject<strong class="lu hj">.</strong>window<strong class="lu hj">(EventTimeSessionWindows.</strong>withDynamicGap<strong class="lu hj">((</strong>elem<strong class="lu hj">)</strong> <strong class="lu hj">-&gt;</strong> <strong class="lu hj">{</strong><br/>        <em class="lv">// return the session gap, which can be based on the stream's events</em><br/>    <strong class="lu hj">}))</strong></span></pre><ul class=""><li id="4224" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">全局窗口<br/> </strong>将整个流视为一个单独的窗口。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/fe7e0edb82809183982cf2986bf26783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vJyPQPhzYLaRD2R3cLwlw.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">全局窗口插图</figcaption></figure><p id="526c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Flink还支持使用用户定义的逻辑实现自定义窗口，这将是另一篇博文的主题😎。</p><p id="6522" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了基于时间的窗口之外，还有其他窗口，例如<em class="lv">计数窗口、</em>，其通过输入事件的数量接近极限；一旦达到X阈值，Flink就会处理X个事件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/d26e462d05197703604edd2563d35e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaQNIa1sNzSxLJxqYIQyKQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">三个事件的计数窗口</figcaption></figure></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="871a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在理论介绍之后，让我们进入一个实际的数据流。你可以在<a class="ae kf" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank">官网</a>找到更多关于Apache Flink和stream进程的信息。</p><h2 id="4c6b" class="ma kh hi bd ki mf mg mh km mi mj mk kq js ml mm ks jw mn mo ku ka mp mq kw mr bi translated">蒸汽流描述</h2><p id="0930" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">为了重述理论部分，下图描绘了这篇博文中代码样本的主要数据流。下面的流程从一个源(文件被写入一个文件夹)开始，并继续将事件处理成对象。</p><p id="3f6f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面描述的实现由两个处理轨道组成。最上面的那个把一条小溪分成两条支流，然后把它们合并成第三种类型的小溪。底部的场景处理一个流，然后将结果传输到一个接收器中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nj"><img src="../Images/29ad112029ec0ac537dd4e2c79f92a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mod6tH1YVJO31VMTVjFwnw.png"/></div></div></figure><p id="e3c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下一部分旨在将理论的流处理转化为实际的实践；你可以在GitHub 上找到完整的源代码<a class="ae kf" href="https://github.com/liorksh/FlinkBasicDemo" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b795" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">基本流处理(示例#1)</h1><p id="90ab" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">从一个基本的应用程序开始更容易掌握Flink的概念。在这个应用程序中，制作者将文件写入一个文件夹，这模拟了一个流动的流。Flink从这个文件夹中读取文件，对它们进行处理，并将摘要写入目标文件夹；这是水槽。</p><p id="384c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们关注流程部分:</p><ol class=""><li id="263f" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke nk lj lk ll bi translated">将原始数据转换为对象:</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="21b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.下面的代码示例将流对象(InputData)转换为字符串和整数的元组。它只从对象流中提取某些字段，在两秒钟内按一个字段对它们进行分组。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="2cd0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.为流创建目的地(实现数据接收器):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">构建数据接收器的代码示例</figcaption></figure><h1 id="9459" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">分流(示例2)</h1><p id="7fa5" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在这个例子中，我们演示了如何在使用侧输出流的同时分割主流。Flink能够从主<code class="du lr ls lt lu b">DataStream</code>生产多个支流。驻留在每个侧流中的数据类型可以不同于主流，也可以不同于每个侧流。</p><p id="d3cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，使用一个侧面输出流可以一举两得:拆分流并将may流类型转换成多种数据类型(对于每个侧面输出流可以是唯一的)。</p><p id="829d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码示例调用了<code class="du lr ls lt lu b">ProcessFunction</code>，它根据输入的属性将一个流分成两个支流。为了获得相同的结果，我们应该不止一次地使用函数<code class="du lr ls lt lu b">filter</code>。</p><p id="3912" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lr ls lt lu b">ProcessFunction</code>将某些对象(基于标准)收集到主输出收集器(在<code class="du lr ls lt lu b">SingleOutputStreamOperator</code>中捕获)，同时将其他事件添加到副输出。<code class="du lr ls lt lu b">DataStream</code>是垂直拆分的，为每个侧流发布不同的格式。</p><p id="587c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，侧面输出流定义是基于一个惟一的输出标签(<code class="du lr ls lt lu b">OutputTag</code>对象)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">如何分割流的代码示例</figcaption></figure><h1 id="ed05" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">合并流(示例#3)</h1><p id="bd3e" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">这篇博文的最后一个操作演示了合并流的操作。这个想法是将两个不同的流(它们的数据格式可能不同)组合起来，产生一个具有统一数据结构的流。与水平合并数据的SQL合并操作相反，合并流的操作是垂直的，因为事件继续流动，没有任何限定的时间范围。</p><p id="9e13" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过调用方法<code class="du lr ls lt lu b">connect</code>合并流，然后在每个单独的流中的每个元素上定义map操作。结果是一个合并的流。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">如何合并流的代码示例</figcaption></figure><h1 id="1dd5" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">构建可行的项目</h1><p id="1628" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">将所有这些放在一起:我上传了一个<a class="ae kf" href="https://github.com/liorksh/FlinkBasicDemo" rel="noopener ugc nofollow" target="_blank">演示项目到GitHub </a>。您可以按照说明来构建和编译它。这是和Flink玩的一个好的开始。</p><p id="73df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">希望你觉得这个回购有用。如果你有任何问题，不要犹豫与我联系。</p><h1 id="4caa" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">外卖</h1><p id="b4db" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">本文重点介绍了基于Flink构建工作流处理应用程序的必要基础。其目的是提供对流处理挑战的基本理解，并为构建独立的Flink应用程序奠定基础。</p><p id="e835" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为流处理有许多方面和复杂性，所以没有涵盖许多主题。例如，Flink执行和任务管理，使用水印将<em class="lv">事件时间</em>设置到流事件中，在流的事件中植入状态，运行流迭代，在流上执行类似SQL的查询，等等。我希望在后续的文章中涵盖其中的一些主题。</p><p id="ef30" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我希望这篇博客为你提供了开始使用Flink的基本信息。</p><p id="c4f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">继续编码😎。</p><p id="90b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">— Lior</p></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="3987" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">资源:</p><p id="d3a7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">[1]数据流操作:<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/stream/operators/index.html" rel="noopener ugc nofollow" target="_blank">https://ci . Apache . org/projects/flink/flink-docs-release-1.10/dev/stream/operators/index . html</a></p><p id="7de9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">[2]数据接收器:<a class="ae kf" href="https://ci.apache.org/projects/flink/flink-docs-release-1.10/dev/datastream_api.html#data-sinks" rel="noopener ugc nofollow" target="_blank">https://ci . Apache . org/projects/flink/flink-docs-release-1.10/dev/datastream _ API . html #数据接收器</a></p></div></div>    
</body>
</html>