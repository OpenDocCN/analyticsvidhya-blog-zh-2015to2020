<html>
<head>
<title>House rental — the Data Science way Part 2: train a regression model with TPOT and Auto_ml</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房屋租赁——数据科学方法第2部分:用TPOT和Auto_ml训练回归模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/house-rental-the-data-science-way-part-2-train-a-regression-model-tpot-and-auto-ml-9cdb5cb4b1b4?source=collection_archive---------14-----------------------#2019-12-29">https://medium.com/analytics-vidhya/house-rental-the-data-science-way-part-2-train-a-regression-model-tpot-and-auto-ml-9cdb5cb4b1b4?source=collection_archive---------14-----------------------#2019-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0a2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前面的<a class="ae jd" rel="noopener" href="/@wonka929/house-rental-the-data-science-way-part-1-scrape-it-all-with-python-and-beautifulsoup-94d9d1222e32">章节</a>中，我们描述了如何从一个著名的意大利网站收集来自全国各地许多中介机构的房屋销售和租赁公告，以便创建一个数据集，我们可以在此基础上训练我们的价格回归模型。在这一章中，我们将会这样做。开始吧！</p><h1 id="880d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">烹饪需要一个锅…为什么不是一个锅？</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kc"><img src="../Images/24f76eb9e85727003d3ad45d4b272eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XF3akvvCtNu3u2745BPBLQ.jpeg"/></div></figure><p id="7df2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是TPOT？来自创作者的<a class="ae jd" href="https://epistasislab.github.io/tpot/" rel="noopener ugc nofollow" target="_blank">网站</a>:</p><blockquote class="kk kl km"><p id="8a8a" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">把TPOT当成你的<strong class="ih hj">数据科学助理</strong>。TPOT是一个Python自动化机器学习工具，它使用遗传编程优化机器学习管道。</p></blockquote><p id="c8f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，TPOT是一种机器学习专家，它使用Scikit-learn的python库来搜索最佳算法，并通过使用遗传编程来优化超参数。如果你想了解更多，网站上有很多文档。</p><p id="72ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我们的目的而言，我们希望获得了解房屋租赁价格的结果，而不是为我们的任务建立一个如何选择最佳算法的指南，我们必须保持简单:将所有成分放入锅中，然后看看神奇的事情发生了。</p><h1 id="1781" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据集清理</h1><p id="5f20" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">呆在厨房比喻，厨师在把所有东西放在烤架上之前，必须清洗和切割食材。</p><p id="f4b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">了解数据集中是否有问题的最佳方式是一个简单的pandas函数:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="0628" class="lb jf hi kx b fi lc ld l le lf">dataset['column_name'].unique</span></pre><p id="fdbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">熊猫。Series.unique函数返回Series对象的唯一值，因此可以查看列中是否存储了与该列的性质不匹配的值。</p><p id="6439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原来，在应该由整数组成的列“Prezzo”、“Locali”和“Superficie”(英文为“Price”、“Rooms”和“Surfaces”)中，我们有不一致的值。例如，在“Prezzo”列中有一些字符串表示:“<em class="kn">价格待商定</em>”。在“Locali”中，我们可以找到一个“<em class="kn"> C </em>”值。</p><p id="112c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了摆脱所有这些问题，我们需要做点手脚，发布一些公告:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="2586" class="lb jf hi kx b fi lc ld l le lf">import pandas as pd</span><span id="900c" class="lb jf hi kx b fi lg ld l le lf">#the dataset we saved in the previous chapter<br/>dataset = pd.read_csv('dataset.csv', sep=";")</span><span id="4246" class="lb jf hi kx b fi lg ld l le lf">#Drop some trash<br/>dataset.drop(columns='Unnamed: 0', inplace=True)<br/>dataset.replace('5+', 6, inplace = True)<br/>dataset.replace('3+', 4, inplace = True)<br/>dataset = dataset[dataset.Prezzo != 'Affitto\n                                                                                    750/mese\n                                        ']<br/>dataset = dataset[dataset.Prezzo != 'Affitto\n                                                                                    500/mese\n                                        ']<br/>dataset = dataset[dataset.Locali != 'C']<br/>dataset = dataset[dataset.Prezzo != 'prezzo su richiesta']<br/>dataset = dataset[dataset.Superficie != '250, terreno di proprietà 2.000']<br/>dataset = dataset[dataset.Superficie != '100, terreno di proprietà 200']<br/>dataset = dataset[dataset.Superficie != '160, terreno di proprietà 400']<br/>dataset = dataset[dataset.Superficie != '165, terreno di proprietà 450']<br/>dataset = dataset[dataset.Superficie != '105, terreno di proprietà 100']</span><span id="bc65" class="lb jf hi kx b fi lg ld l le lf">#Get rid of NaN<br/>dataset.fillna(value=0, inplace=True)</span></pre><p id="0ede" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们的数据集是干净的。耶！</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es lh"><img src="../Images/3ac9a34d4654bf075ca914ad0af8e8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*WsZyOBVHK_kzAf2W0Jw20Q.gif"/></div></figure><p id="de5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，TPOT需要两样东西:一个包含要素值的数据集和一个包含目标的列表，因此它可以根据数据训练模型以获得目标。在我们的例子中，目标是租赁价格，数据集中的所有其他信息都是我们的特征。将它们分开，并在需要的地方将它们转换为int:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="c54c" class="lb jf hi kx b fi lc ld l le lf">dataset['Prezzo'] = dataset['Prezzo'].astype(int)<br/>dataset['Superficie'] = dataset['Superficie'].astype(int)<br/>dataset['Locali'] = dataset['Locali'].astype(int)<br/>dataset.drop(columns= ['Spese condominio', 'Spese riscaldamento'], inplace=True)</span></pre><p id="4566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">专注于流程。</p><p id="7032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是文章中唯一真正概念性的部分:<strong class="ih hj">分类特征</strong></p><blockquote class="kk kl km"><p id="8d6b" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">分类变量(有时称为名义变量)是指有两个或更多类别的变量，但这些类别没有内在的排序。例如，性别是具有两个类别(男性和女性)的分类变量，并且这些类别没有内在的顺序。头发颜色也是一个分类变量，有许多种类(金发、棕色、深色、红色等。)同样，也没有一个商定的方法来将这些从最高到最低排序。纯分类变量只是允许你分配类别，但你不能清楚地排序变量。如果变量有明确的顺序，那么这个变量就是一个序数变量。</p><p id="69a6" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated"><a class="ae jd" href="https://stats.idre.ucla.edu/other/mult-pkg/whatstat/what-is-the-difference-between-categorical-ordinal-and-numerical-variables/" rel="noopener ugc nofollow" target="_blank">https://stats . idre . UCLA . edu/other/mult-pkg/what stat/what-is-the-difference-between-categorial-ordinal-and-numerical-variables/</a></p></blockquote><p id="cc06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之:像房屋所在区域这样的特征不是一个数字值，甚至不可能给一个区域分配比另一个区域更高的值。房东想要提供的租赁合同也是如此。这些特征必须作为虚拟/指标变量进行管理，这可以通过熊猫来实现。这将大大增加我们问题的特征数量，从而增加数据框架的维度，但这是我们处理分类特征的唯一方法。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="1ae5" class="lb jf hi kx b fi lc ld l le lf">dataset = dataset.merge(pd.get_dummies(dataset['Zona']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Piano']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Contratto']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Tipologia']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Tipo proprietà']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Anno di costruzione']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Stato']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Riscaldamento']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Climatizzatore']), left_index=True, right_index=True)<br/>dataset = dataset.merge(pd.get_dummies(dataset['Classe energetica']), left_index=True, right_index=True)</span><span id="d880" class="lb jf hi kx b fi lg ld l le lf">dataset.drop(columns='Zona', inplace=True)<br/>dataset.drop(columns='Piano_x', inplace=True)<br/>dataset.drop(columns='Contratto', inplace=True)<br/>dataset.drop(columns='Tipologia', inplace=True)<br/>dataset.drop(columns='Tipo proprietà', inplace=True)<br/>dataset.drop(columns='Anno di costruzione', inplace=True)<br/>dataset.drop(columns='Stato', inplace=True)<br/>dataset.drop(columns='Riscaldamento', inplace=True)<br/>dataset.drop(columns='Climatizzatore', inplace=True)<br/>dataset.drop(columns='Classe energetica', inplace=True)</span><span id="71d6" class="lb jf hi kx b fi lg ld l le lf">dataset.fillna(0,inplace=True)</span></pre><p id="7a6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们创建了假人，并将其合并到我们的数据集。然后，我们去掉了仍然存在的分类列，为了确保安全，填充了所有的NaN(不应该有任何NaN，但是你永远不知道)。</p><p id="d228" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果需要的话，只需过滤器宣布(我的意思是，通常巨大或非常昂贵的房子与普通人的房子有不同的市场模式，所以我决定只选择那些月租金低于1000€的房子)</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="3704" class="lb jf hi kx b fi lc ld l le lf">dataset = dataset[dataset['Prezzo']&lt;1000]<br/>target = dataset['Prezzo']<br/>data = dataset.drop(columns= ['Prezzo'])</span></pre><p id="8df4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…目标和数据分开…</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="d17d" class="lb jf hi kx b fi lc ld l le lf">from tpot import TPOTRegressor<br/>from sklearn.model_selection import train_test_split</span><span id="54ae" class="lb jf hi kx b fi lg ld l le lf">X_train, X_test, y_train, y_test = train_test_split(data.values, target.values, train_size=0.75, test_size=0.25)</span><span id="e197" class="lb jf hi kx b fi lg ld l le lf">tpot = TPOTRegressor(generations=50, population_size=20, verbosity=2, max_eval_time_mins=2, n_jobs=4)<br/>tpot.fit(X_train, y_train)</span><span id="170c" class="lb jf hi kx b fi lg ld l le lf">print(tpot.score(X_test, y_test))<br/>tpot.export('tpot_torino_pipeline.py')</span></pre><p id="b916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里开始优化过程。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="2a34" class="lb jf hi kx b fi lc ld l le lf">Optimization Progress: 26%<br/>264/1020 [13:49&lt;2:36:11, 12.40s/pipeline]</span><span id="828a" class="lb jf hi kx b fi lg ld l le lf">Generation 1 - Current best internal CV score: -11481.139384411077<br/>Generation 2 - Current best internal CV score: -11116.07477241672<br/>Generation 3 - Current best internal CV score: -11116.07477241672<br/>Generation 4 - Current best internal CV score: -10869.853396609586<br/>Generation 5 - Current best internal CV score: -10869.853396609586<br/>Generation 6 - Current best internal CV score: -10869.853396609586<br/>Generation 7 - Current best internal CV score: -10869.853396609586<br/>Generation 8 - Current best internal CV score: -10869.853396609586<br/>Generation 9 - Current best internal CV score: -10686.280416803686<br/>Generation 10 - Current best internal CV score: -10629.285228481005<br/>Generation 11 - Current best internal CV score: -10540.157544616217<br/>Generation 12 - Current best internal CV score: -10540.157544616217<br/>...</span></pre><p id="5c09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将需要一段时间，取决于您的计算机的具体情况。所以，准备一杯<strong class="ih hj">真正的</strong>茶，在客厅里跳一会儿舞。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es li"><img src="../Images/d95f632bddb08e41882789d1c2e01dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/1*2nuTBQI9anHku-6BshvIhg.gif"/></div></figure><p id="de76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">过程完成后，保存模型并查看结果。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="a759" class="lb jf hi kx b fi lc ld l le lf">import pickle</span><span id="d5d2" class="lb jf hi kx b fi lg ld l le lf">with open('tpot_faster.pickle','wb') as xx:<br/>    pickle.dump(tpot.fitted_pipeline_,xx)</span><span id="5961" class="lb jf hi kx b fi lg ld l le lf">with open('tpot_faster.pickle', 'rb') as xx:<br/>    model = pickle.load(xx)</span></pre><h1 id="c128" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结果</h1><p id="e1a9" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">理解我们的模型是否能够解释数据的最令人印象深刻的方法之一是对所有数据集进行预测，然后用价格的基本事实评估结果。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="f5ff" class="lb jf hi kx b fi lc ld l le lf">import matplotlib.pyplot as plot</span><span id="4d09" class="lb jf hi kx b fi lg ld l le lf">predictions = []<br/>for item in data.values:<br/>    prediction = tpot.predict([item])<br/>    predictions.append(prediction)</span><span id="964b" class="lb jf hi kx b fi lg ld l le lf">flat_list = []<br/>for sublist in predictions:<br/>    for item in sublist:<br/>        flat_list.append(item)<br/>    <br/>ground_truth = target.values</span><span id="c485" class="lb jf hi kx b fi lg ld l le lf">confronto = pd.DataFrame()<br/>confronto['ground_truth'] = ground_truth<br/>confronto['predictions'] = flat_list<br/>plt = confronto.plot(figsize=(25,10))<br/>fig = plt.get_figure()<br/>fig.savefig("comparison.svg")</span></pre><p id="8e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯…还不错！预测和现实有着几乎相同的趋势！那就好！</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/00fe8cd14e3199d379c317247d3944dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPo2C-Qsu73V8iSFw7SCOQ.png"/></div></div></figure><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="e957" class="lb jf hi kx b fi lc ld l le lf">from scipy.stats.stats import pearsonr</span><span id="77cb" class="lb jf hi kx b fi lg ld l le lf">pearsonr(confronto['ground_truth'].values,confronto['predictions'].values)</span></pre><p id="dcac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">皮尔森给了我们一个0.944的相关值。那很好。检查误差图的外观:</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="a1e2" class="lb jf hi kx b fi lc ld l le lf">diff = confronto['ground_truth']-confronto['predictions']<br/>diff.plot(figsize=(25,10))</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/4e12da6d9b81c655be0ac70730046f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SPBGvd7aO8VFTjA0iTbF2A.png"/></div></div></figure><p id="a55d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那也行！</p><h1 id="0e5c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">深入挖掘</h1><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="1a60" class="lb jf hi kx b fi lc ld l le lf">my_dict = list(tpot.evaluated_individuals_.items())</span><span id="d6ae" class="lb jf hi kx b fi lg ld l le lf">model_scores = pd.DataFrame()<br/>for model in my_dict:<br/>    model_name = model[0]<br/>    model_info = model[1]<br/>    cv_score = model[1].get('internal_cv_score')  # Pull out cv_score as a column (i.e., sortable)<br/>    model_scores = model_scores.append({'model': model_name,<br/>                                        'cv_score': cv_score,<br/>                                        'model_info': model_info,},<br/>                                       ignore_index=True)</span><span id="4f11" class="lb jf hi kx b fi lg ld l le lf">model_scores = model_scores.sort_values('cv_score', ascending=False)<br/>print(model_scores)</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lp"><img src="../Images/165cb1d89a4e937711abc2c13e797d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Gvgl7_glig2hCqx4t1-Fw.png"/></div></div></figure><p id="aedb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，赢家是一个有很多其他参数的RandomForestRegressor。<br/>好吧。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="ba80" class="lb jf hi kx b fi lc ld l le lf">most_valuable_features=pd.DataFrame(columns=['Variables', 'Pesi'])<br/>most_valuable_features['Variables'] = data.columns.astype(str)<br/>most_valuable_features['weights'] = exctracted_best_model.feature_importances_[2:228]<br/>most_valuable_features.set_index('Variables', inplace=True)<br/>most_valuable_features[most_valuable_features['weight']&gt;0.01].plot(kind='bar', figsize=(15,7))</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lq"><img src="../Images/1b17fd1a6635fb3ae3a3589c54fa2c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FtdcYpJy_KyfOTEu-CwjA.png"/></div></div></figure><p id="cbe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特性的重要性有点棘手。每种算法都使用自己的方法来训练模型。例如，在本例中，我输入了一个包含226个要素的数据集，要素重要性给出了一个包含229个项目的输出。听起来很奇怪…但是就是这样，当你使用暴力时，你可能会完成一个需要一些其他输入特性的算法。我们可以在另一篇文章中讨论它。</p><p id="a6ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在…回到我们最初的目的。我是不是花钱太多了？创建一个“我的房子”列表，然后交给模特</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="f2be" class="lb jf hi kx b fi lc ld l le lf">my_house =[[25,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]]</span><span id="ee00" class="lb jf hi kx b fi lg ld l le lf">tpot.predict(my_house)</span><span id="8ff5" class="lb jf hi kx b fi lg ld l le lf"><em class="kn">-- array([382.5005])</em></span></pre><p id="54f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我的住宿费是每月382.5€。<br/>抱歉，我会保守秘密:)</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="0028" class="je jf hi bd jg jh ly jj jk jl lz jn jo jp ma jr js jt mb jv jw jx mc jz ka kb bi translated">另一个锅:auto_ml</h1><p id="4680" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/ClimbsRocks/auto_ml" rel="noopener ugc nofollow" target="_blank"> Auto_ml </a>让一切变得更简单。作者将其描述为:</p><blockquote class="kk kl km"><p id="e667" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">面向生产和分析的自动化机器学习</p></blockquote><p id="9c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确实很简洁。</p><p id="f9f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，看一下代码。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="7e94" class="lb jf hi kx b fi lc ld l le lf">from sklearn.model_selection import train_test_split<br/>from auto_ml import Predictor<br/>from auto_ml.utils import get_boston_dataset<br/>from auto_ml.utils_models import load_ml_model<br/>from sklearn.model_selection import train_test_split<br/>import pandas as pd</span><span id="539e" class="lb jf hi kx b fi lg ld l le lf">dataset = pd.read_csv('dataset.csv', sep=";")<br/>dataset.drop(columns='Unnamed: 0', inplace=True)<br/>dataset.fillna(0, inplace=True)</span><span id="1b22" class="lb jf hi kx b fi lg ld l le lf">dataset['Prezzo'] = dataset['Prezzo'].astype(int)<br/>dataset['Locali'] = dataset['Locali'].astype(int)<br/>dataset = dataset[dataset['Price']&lt;1000]<br/>dati = dataset.drop(columns= ['Prezzo','Spese condominio', 'Spese riscaldamento'])</span><span id="74e9" class="lb jf hi kx b fi lg ld l le lf">column_descriptions = {<br/>    'Price': 'output',<br/>    'Zona':'categorical',<br/>    'Piano':'categorical',<br/>    'Contratto':'categorical',<br/>    'Tipologia':'categorical',<br/>    'Tipo proprietà':'categorical',<br/>    'Anno di costruzione':'categorical',<br/>    'Stato':'categorical',<br/>    'Riscaldamento':'categorical',<br/>    'Climatizzatore':'categorical',<br/>    'Classe energetica':'categorical'<br/>}</span><span id="5f78" class="lb jf hi kx b fi lg ld l le lf">df_train, df_test = train_test_split(dati,train_size=0.75, test_size=0.25)</span><span id="0408" class="lb jf hi kx b fi lg ld l le lf">ml_predictor = Predictor(type_of_estimator='regressor', column_descriptions=column_descriptions)</span><span id="4b0d" class="lb jf hi kx b fi lg ld l le lf">ml_predictor.train(df_train)</span><span id="579b" class="lb jf hi kx b fi lg ld l le lf"># Score the model on test data<br/>test_score = ml_predictor.score(df_test, df_test.Price)<br/>test_modello = ml_predictor.save()<br/>trained_model = load_ml_model(test_modello)</span><span id="f38c" class="lb jf hi kx b fi lg ld l le lf">predictions = trained_model.predict(df_test)<br/>print(predictions)</span></pre><p id="3ad1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Auto_ml自动处理分类特征。你总是可以创建虚拟对象，但是使用auto_ml你也可以只在<em class="kn">列描述</em>中写列名，比如说它是分类的，它会处理所有的事情。对于目标也是一样，只需将列名标记为<em class="kn">‘output’</em>就可以了。对于它正在做的事情，它也有一个很好的输出日志。</p><p id="33da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AAAA…<strong class="ih hj">训练只花了1秒。</strong>真是恶心的家伙！</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="0d71" class="lb jf hi kx b fi lc ld l le lf"> Total training time:<br/>0:00:01</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es lh"><img src="../Images/a21eba0482b4f1339b9c9de08a4f9ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9AWzgifB1rklQvZ4slX_wQ.gif"/></div></figure><p id="e4c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，再一次，找出更多关于表演的东西。<br/>它不像TPOT那样给我们那么多输出去应付，所以直接走就行了。</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="c08f" class="lb jf hi kx b fi lc ld l le lf">valutazione = pd.DataFrame()<br/>ground_truth = dati['Price'].values<br/>predictions = trained_model.predict(dati)<br/>valutazione['Reale'] = ground_truth<br/>valutazione['predictions'] = predictions</span><span id="eca1" class="lb jf hi kx b fi lg ld l le lf">import matplotlib.pyplot as plot<br/>plt = valutazione.plot(figsize=(25,10))<br/>fig = plt.get_figure()<br/>fig.savefig("risultato_automl.svg")</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/fc7abab3405790887478a086e31aa17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yKhjwJlABlfHNSzae0bug.png"/></div></div></figure><p id="47d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇！1秒钟的训练是非常准确的！</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="77f0" class="lb jf hi kx b fi lc ld l le lf">from scipy.stats.stats import pearsonr</span><span id="8c7f" class="lb jf hi kx b fi lg ld l le lf">pearsonr(valutazione['Reale'].values,valutazione['predictions'].values)</span></pre><p id="c0dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">皮尔森说:0.860 <br/>好吧，这比TPOT低，但是…还是印象深刻！</p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="0245" class="lb jf hi kx b fi lc ld l le lf">diff = valutazione['Reale']-valutazione['predictions']<br/>print(diff.std())<br/>diff.plot(figsize=(25,10))</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/a28bed24fdf46a3e0dbde5c87b8f1e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zd4y5wCNaWOx5g4yVacihQ.png"/></div></div></figure><p id="f1f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">地面真实和预测之间的差异是振荡更多，但它是确定的。</p><p id="8886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果跟<em class="kn">我的_房子:</em></p><pre class="kd ke kf kg fd kw kx ky kz aw la bi"><span id="a83d" class="lb jf hi kx b fi lc ld l le lf">trained_model.predict(my_house)</span><span id="c3bf" class="lb jf hi kx b fi lg ld l le lf"><em class="kn">-- 348.6003</em></span></pre><p id="d432" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">348€/月。足够接近TPOT模型结果。</p><p id="60f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到auto_ml网站…</p><blockquote class="kk kl km"><p id="d7c8" class="if ig kn ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">自动化整个机器学习过程，使其非常容易用于分析，并在生产中获得实时预测。</p></blockquote><p id="3acc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哦，是的，宝贝！确实如此！</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="4051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，就这样了！厨师希望你喜欢这顿饭！<br/>再见，伙计们！；D</p><p id="2540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kn">本文是教程的第二部分，你可以在这个链接找到:<br/></em><a class="ae jd" rel="noopener" href="/@wonka929/house-rental-the-data-science-way-part-1-scrape-it-all-with-python-and-beautifulsoup-94d9d1222e32"><em class="kn">https://medium . com/@ wonka 929/house-rental-the-data-science-way-part-1-scrape-it-all-with-python-and-beautiful soup-94d 9d 1222 e 32</em></a></p></div></div>    
</body>
</html>