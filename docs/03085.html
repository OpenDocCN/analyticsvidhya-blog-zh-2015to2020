<html>
<head>
<title>Class and instance attributes in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中的类和实例属性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/class-and-instance-attributes-in-python-85aa895eb81d?source=collection_archive---------11-----------------------#2020-01-15">https://medium.com/analytics-vidhya/class-and-instance-attributes-in-python-85aa895eb81d?source=collection_archive---------11-----------------------#2020-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/3b0679ec467217fa9b3ead188d0bf93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*snSBJdEFTecwObG5OTRZUA.png"/></div></figure><p id="c5d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可能是一个初学编程的人，试图进入面向对象编程的神奇世界，或者你可能已经是一个有点健忘症的专家了。在任何情况下，回顾概念总是好的，并且清楚地知道你正在编码的是什么，以及你如何使用它的全部潜力，在这种情况下是属性。</p><h1 id="316a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">类和对象</h1><p id="1b21" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">让我们记住，类是一种创建代码的蓝图或模板，更确切地说是对象。后者是包含的组件，具有使特定数据集有用的方法和属性。</p><p id="afa9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这方面的一个例子如下:</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/70897ddc4f51a8b68032cbe24c2ca75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*CCFlH65erVNJ5S_-ao1iTQ.png"/></div></figure><p id="371a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，创建了一个名为<em class="ks"> Employee </em>的空类。之后，我们生成该类的一个新实例，一个名为<em class="ks"> emp1 </em>的对象。</p><h1 id="169d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">什么是职业属性</strong></h1><p id="b0f0" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">当我们创建类时，我们也在设置一个封闭的空间，我们的对象将存在于其中。在这个空间中，我们可以让所有实例以一种全局方式访问变量。这些变量不属于任何对象，而是属于类本身。</p><p id="7de5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下一个例子中，我们创建了一个名为<em class="ks"> company_name </em>的类属性。在前面，我们创建了雇员<em class="ks">的两个实例。</em></p><p id="3ad3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们尝试打印每个实例的<em class="ks"> company_name </em>，您会注意到两者是一样的。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/bfac362f82fe604314acfbd69d201fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*qz3zRv2j5AVzX66gGNRUwg.png"/></div></figure><h1 id="3462" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">什么是实例属性</strong></h1><p id="87fa" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如果类属性是属于类的变量，并且可用于所有实例，那么实例属性是属于特定实例的变量，并且仅可用于该实例。</p><p id="c628" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下一个例子中，我们有两个雇员的实例。</p><p id="942d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于第一个实例，<em class="ks"> emp1 </em>，我们为一个名为<em class="ks"> name </em>的新属性赋值<em class="ks">“约翰”</em>。</p><p id="7007" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们打印<em class="ks"> emp1.name </em>，我们会得到相应的输出。但是如果我们试图打印相同的属性，现在用我们的第二个实例<em class="ks"> emp2 </em>，我们将得到一个错误。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/0654b68e0bfd719476408d649889dfc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*6S_-KyNaOBN_ST5S7j2cxQ.png"/></div></figure><p id="960a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是因为<em class="ks"> name </em>是一个实例属性，只属于对象emp1。</p><h1 id="d6bb" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">创造它们的所有方法是什么，Pythonic式的方法是什么</h1><p id="14ae" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">可以用不同的方式为类和实例创建属性。</p><blockquote class="kv kw kx"><p id="6b85" class="im in ks io b ip iq ir is it iu iv iw ky iy iz ja kz jc jd je la jg jh ji jj hb bi translated">在类声明之外创建类属性:</p></blockquote><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/c64206c5d31c629bc13c0d00ca9d2859.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*8fnhik7GN-7FGCb78UwTQg.png"/></div></figure><blockquote class="kv kw kx"><p id="b7fb" class="im in ks io b ip iq ir is it iu iv iw ky iy iz ja kz jc jd je la jg jh ji jj hb bi translated">逐个创建实例属性:</p></blockquote><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/b4953ade519c4ccc1fb3042630b4463d.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*Yw7jADRT5oOb09hUQJMKfg.png"/></div></figure><p id="4d20" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，这些创建属性的方法是不被认可的，因为它们要求程序员重复代码并且缺乏组织性。</p><blockquote class="kv kw kx"><p id="eb50" class="im in ks io b ip iq ir is it iu iv iw ky iy iz ja kz jc jd je la jg jh ji jj hb bi translated">对于类变量来说，最好是在类的开头，在任何方法之前进行声明。</p></blockquote><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/a5176631f0a37d8c26b49e61f02bfc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*RYMkIk4kHlkXA40X_wRRPw.png"/></div></figure><blockquote class="kv kw kx"><p id="7d6f" class="im in ks io b ip iq ir is it iu iv iw ky iy iz ja kz jc jd je la jg jh ji jj hb bi translated">对于实例属性，建议使用类的__init__方法，这样每次创建实例时，都会自动分配其属性。</p></blockquote><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es le"><img src="../Images/55828fd77e55a38b96568479837bb60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*u1BGL7HaUclfCy11lIqn4g.png"/></div></figure><h1 id="416e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">类和实例属性有什么区别</strong></h1><p id="ecdc" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在这两种属性之间，应该考虑以下几点。</p><ul class=""><li id="1799" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">如果希望在类的所有实例之间共享属性的单个实例(单个值)，请使用类属性。</li><li id="b771" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">如果希望类的每个实例都具有不同的属性值，请使用实例属性。</li></ul><h1 id="c9ec" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">他们各自的优缺点是什么</strong></h1><p id="ec6d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">类别属性的优点:</p><ul class=""><li id="e15e" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">它们像“全局”变量一样作用于你的类的所有实例</li><li id="d757" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">它们允许对属于该类的所有对象进行操作和数据管理。</li></ul><p id="dd79" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">类属性的缺点:</p><ul class=""><li id="d13c" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">当创建同名的实例属性时，类属性可能会变得混乱，这意味着它的行为可能会变得出乎意料。</li></ul><p id="39a7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实例属性的优点:</p><ul class=""><li id="3402" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">它们特定于一个对象</li><li id="63c4" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">它们可以与同名的类变量共存</li></ul><p id="a7d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实例属性的缺点:</p><ul class=""><li id="e586" class="lf lg hi io b ip iq it iu ix lh jb li jf lj jj lk ll lm ln bi translated">如果需要，另一个实例不能直接访问它们。</li><li id="1a5f" class="lf lg hi io b ip lo it lp ix lq jb lr jf ls jj lk ll lm ln bi translated">一旦实例被删除，它的属性就消失了。</li></ul><h1 id="707f" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">Python如何使用</strong> <code class="du lt lu lv lw b"><strong class="ak">__dict__</strong></code>处理对象和类属性</h1><p id="4c70" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Python中的每个对象都有一个用<em class="ks"> __dict__表示的属性。</em></p><p id="9fe9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该属性包含一个形式为<em class="ks"> key: value </em>的字典，其中存储了所有其他属性。</p><p id="e168" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果我们创建属性为<em class="ks"> company_name </em>的<em class="ks">类Employee </em>，并打印它的<em class="ks"> __dict__ </em>，我们将看到几个属于该类的变量，包括我们刚刚声明的属性。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/16a9a5554a6a0c63f5e797f382031ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*MM1Jc0QBebnwzEwtBLRDsQ.png"/></div></figure><p id="2fb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们现在创建该类的一个新实例，并试图打印它的字典，我们将看到一个空的数据结构。但是，如果我们尝试打印它的属性<em class="ks"> company_name </em>，我们不会得到任何错误。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/1fed0ebba15d8a2dc2244565223ece94.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*hUd3uEY3JIW24SWTytXGTw.png"/></div></figure><p id="12e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是因为python首先在<em class="ks"> emp1 </em>字典中搜索属性。如果在那里没有找到该属性，python就会在类空间中寻找它，然后在那里打印出来。</p><p id="97f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以给与类属性同名的<em class="ks"> emp1 </em>实例分配一个新属性。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/070465c652c4fea7298274ebb63a62e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*41Y14qUv6n3aFx2HeJPgWQ.png"/></div></figure><p id="2c06" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果再次检查<em class="ks"> emp1 </em>的字典，可以找到并打印刚刚创建的属性。</p><p id="a0a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这并不意味着class属性被替换，因为它仍然存在，并且可以被访问。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/21a2f6b12f565a5f20541fa072f15c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*JrI51gZP894oIjs5hfAfjg.png"/></div></figure><p id="3027" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作者:乔安·斯蒂文·萨莫拉·凯塞多</p></div></div>    
</body>
</html>