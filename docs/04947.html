<html>
<head>
<title>EfficientNet: The State Of The Art In ImageNet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">efficient net:ImageNet的最新技术</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/efficientnet-the-state-of-the-art-in-imagenet-701d4304cfa3?source=collection_archive---------15-----------------------#2020-04-06">https://medium.com/analytics-vidhya/efficientnet-the-state-of-the-art-in-imagenet-701d4304cfa3?source=collection_archive---------15-----------------------#2020-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/722a458275b91825d731b6e87ee376d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jJTLTSjiyr47KYWD"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">Markuss Gigengaar在Unsplash上的图片</figcaption></figure><p id="83c0" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">EfficientNet是一组卷积网络模型，与imagenet中的其他竞争模型相比，它在imagenet数据库中以非常少的参数实现了最先进的准确性。高效模型组有8个来自B0-B7的模型，其中每个模型按时间顺序指的是更高的精度和更多数量的参数。下图总结了参数对获得精确度的影响。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ka"><img src="../Images/87ccab57fc677251f5b9f37f994a5053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3ia4bXAYOOOO4C0x.png"/></div></div></figure><h1 id="1387" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">EfficientNet如何工作:</h1><p id="b054" class="pw-post-body-paragraph jc jd hi je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hb bi translated">该模型强调在提高精度的同时保持较少的参数数量。为此，它使用在MobileConvnet中引入的深度方向可分离卷积和点方向卷积。下图给出了深度方向卷积的概述。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es le"><img src="../Images/923e1739dc57d0a08beea466594a085f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*3KS0utW0g8IV-4pZ.png"/></div></div></figure><p id="15e9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在深度方向卷积的情况下，我们一次对一个通道进行滤波，而不是同时对所有通道进行滤波。当我们有M个大小为Dk * Dk * 1的不同滤波器时，我们得到大小为Dp*Dp*1的输出。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lf"><img src="../Images/8c1e330f4b0badf17f1b6a484c70ff6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/0*jkogvjUlAh6T__Gm.png"/></div></figure><p id="5432" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">类似地，在逐点卷积的情况下，在M个信道上应用1*1卷积。这里我们将有N个大小为1*1*M的过滤器。要了解这两个操作如何减少参数的数量，请参见本文<br/><a class="ae lg" rel="noopener" href="/@adityamohanty/mobilenet-the-whos-who-of-faster-cnn-classifier-b6d5ab6a79c2">https://medium . com/@ adityamohanty/mobilenet-the-whos-who-of-fast-CNN-classifier-b 6 D5 ab 6a 79 c 2</a>。</p><h1 id="0b0f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">模型缩放:</h1><p id="ec35" class="pw-post-body-paragraph jc jd hi je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hb bi translated">当我们增加架构的宽度或深度，甚至增加输入图像的分辨率时，我们通常会获得更好的精度。但是超过一定限度，这并不能改善模型性能。因此，当我们处理更大的模型时，平衡这三个部分是很重要的。现在的问题是，我们应该如何调整上面讨论的三个超参数。该论文的作者提出了一种称为复合缩放的技术来做同样的事情。</p><h2 id="e237" class="lh kc hi bd kd li lj lk kh ll lm ln kl jn lo lp kp jr lq lr kt jv ls lt kx lu bi translated">复合缩放:</h2><p id="0794" class="pw-post-body-paragraph jc jd hi je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hb bi translated">为了知道缩放到什么程度，作者提出了下面的公式。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lv"><img src="../Images/97950e8600e5f9a6099c674d80f7b4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XB9OqtG9YQuLTy90.png"/></div></figure><p id="b194" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这里，phi是用户指定的源，它控制用于模型缩放的资源，例如宽度、分辨率和深度。α、β和γ也是将资源分配给这三个参数的系数。作者发现α、β和γ的最佳值应分别为1.2、1.1和1.15。对于efficientnet-B0架构，我们将phi的值固定为1。对于后续架构(如B1-B7 ),我们增加phi的值，同时假设资源在每个阶段都翻倍。执行该步骤时，保持α、β、γ值与之前发现的相同。</p><h1 id="12a8" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">实施:</h1><p id="5c2a" class="pw-post-body-paragraph jc jd hi je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hb bi translated">最初，efficientnet是为具有1000个类的imagenet数据库构建的。但是，假设我们有一个二进制分类问题，那么我们必须删除最后一层，就像我们在其他迁移学习中通常做的那样。要做到这一点，我们可以首先使用画中画的架构。</p><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="b333" class="lh kc hi lx b fi mb mc l md me">pip install efficientNet<br/><strong class="lx hj">from</strong> <strong class="lx hj">efficientnet</strong> <strong class="lx hj">import</strong> EfficientNetB0 <strong class="lx hj">as</strong> efficient<br/><strong class="lx hj">from</strong> <strong class="lx hj">efficientnet</strong> <strong class="lx hj">import</strong> center_crop_and_resize, preprocess_input</span><span id="a15b" class="lh kc hi lx b fi mf mc l md me">initial = efficient(weights='imagenet', include_top=<strong class="lx hj">False</strong>)</span></pre><p id="7799" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这就是创建模型的方式。下面的代码片段实现了进行二进制分类所需的所有功能。</p><pre class="in io ip iq fd lw lx ly lz aw ma bi"><span id="67c2" class="lh kc hi lx b fi mb mc l md me">model = Sequential()<br/>model.add(initial)<br/>model.add(layers.GlobalMaxPooling2D())<br/>model.add(layers.Dense(2, activation='softmax', name="fc_out"))</span></pre><p id="ce65" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">以上只是使用efficientNet的二进制分类的伪实现。根据我们的数据集和类的数量，我们应该在冻结有效净重后添加更多的层或相应地添加更多的类。</p></div></div>    
</body>
</html>