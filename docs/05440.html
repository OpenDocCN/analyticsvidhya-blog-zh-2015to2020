<html>
<head>
<title>Python Tuples vs Lists — Comparison Between Lists and Tuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python元组与列表-列表和元组之间的比较</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-tuples-vs-lists-comparison-between-lists-and-tuples-807b5692aafb?source=collection_archive---------8-----------------------#2020-04-21">https://medium.com/analytics-vidhya/python-tuples-vs-lists-comparison-between-lists-and-tuples-807b5692aafb?source=collection_archive---------8-----------------------#2020-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/47a55b67adece2f24671c723cfb3841e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAMMTi5xcB0T7aIoaAsgCA.png"/></div></div></figure><p id="19a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将尝试解释元组和列表之间的审查差异。它们都是python中相似的序列类型。当考虑列表和元组时，有很大的不同。元组是不可变的列表，但列表不是这样。所以，你不能改变它们的大小以及它们的不可变对象。</p><p id="6ce7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">元组直接引用它们的元素。此外，对象的长度和顺序也很重要。但是列表有一个额外的间接指向外部指针数组的层。这为元组提供了索引查找和解包的速度优势。</p><p id="10f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用元组有两个好处。</p><ol class=""><li id="d1df" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">清晰</strong>:当你在代码中看到一个元组，你就知道长度信息永远不会改变。</li><li id="07a5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">性能</strong>:一个元组比相同长度的链表使用的内存少。</li></ol></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="8cec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kj">例题1。</em> </strong>我们不能改变元组中的条目:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="120f" class="kt ku hi kp b fi kv kw l kx ky">&gt;&gt;&gt; a = (1, 'foo')<br/>&gt;&gt;&gt; a[0] = 10<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object does not support item assignment</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="eebf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kj">例二。</em> </strong>如果一个tuple中有任何list(mutable)，我们可以改变它。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="9a79" class="kt ku hi kp b fi kv kw l kx ky">&gt;&gt;&gt; a = (1, 'foo', [1, 2])<br/>&gt;&gt;&gt; b = (1, 'foo', [1, 2])<br/>&gt;&gt;&gt; a == b<br/>True<br/>&gt;&gt;&gt; b[-1].append(3)<br/>&gt;&gt;&gt; a == b<br/>False<br/>&gt;&gt;&gt; b<br/>(1, 'foo', [1, 2, 3])</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="39b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kj">例三。</em> </strong>元组的大小是固定的，不会过度分配。因此，它可以比需要过度分配以使<strong class="is hj"> <em class="kj"> append() </em> </strong>操作高效的列表更紧凑地存储。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="ac20" class="kt ku hi kp b fi kv kw l kx ky">&gt;&gt;&gt; import sys</span><span id="e85f" class="kt ku hi kp b fi kz kw l kx ky">&gt;&gt;&gt; a = (1, 2, 3)<br/>&gt;&gt;&gt; id(a)<br/>4468514392<br/>&gt;&gt;&gt; sys.getsizeof(a)<br/>72</span><span id="32d2" class="kt ku hi kp b fi kz kw l kx ky">&gt;&gt;&gt; b = [1, 2, 3]<br/>&gt;&gt;&gt; id(b)<br/>4469068104<br/>&gt;&gt;&gt; sys.getsizeof(b)<br/>88</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="a64c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kj">例4。</em> </strong>空元组总是只将一个元组作为单体。它自己会立即返回。此外，它的长度为零。当我们创建一个空元组时，指向python已经预分配的元组。因此，他们有相同的地址。他们在节省内存。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="25e7" class="kt ku hi kp b fi kv kw l kx ky">&gt;&gt;&gt; a = ()<br/>&gt;&gt;&gt; b = ()<br/>&gt;&gt;&gt; a is b<br/>True<br/>&gt;&gt;&gt; id(a)<br/>4390871112<br/>&gt;&gt;&gt; id(b)<br/>4390871112</span><span id="15db" class="kt ku hi kp b fi kz kw l kx ky">&gt;&gt;&gt; a = (1, 2, 3)<br/>&gt;&gt;&gt; b = tuple(a)<br/>&gt;&gt;&gt; a is b<br/>True</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="b83d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="kj">例5。</em> </strong>既然元组是<strong class="is hj">不可变的</strong>，就不一定要<strong class="is hj">复制</strong>。列表是<strong class="is hj">可变的</strong>对象，需要将所有数据<strong class="is hj">复制</strong>到一个新列表中:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="f020" class="kt ku hi kp b fi kv kw l kx ky">&gt;&gt;&gt; a = []<br/>&gt;&gt;&gt; b = []<br/>&gt;&gt;&gt; a is b<br/>False<br/>&gt;&gt;&gt; id(a)<br/>4504237576<br/>&gt;&gt;&gt; id(b)<br/>4504282440</span><span id="0b70" class="kt ku hi kp b fi kz kw l kx ky">&gt;&gt;&gt; a = [1, 2, 3] <br/>&gt;&gt;&gt; b = list(a)<br/>&gt;&gt;&gt; a is b<br/>False</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="4946" class="la ku hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">tuple一般用在哪里？</strong></h1><ul class=""><li id="94de" class="jo jp hi is b it lx ix ly jb lz jf ma jj mb jn mc ju jv jw bi translated">字符串格式。</li><li id="6060" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mc ju jv jw bi translated">使用变量和参数。</li><li id="2044" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mc ju jv jw bi translated">迭代字典键值对。</li><li id="5b56" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mc ju jv jw bi translated">从一个函数中返回两个或更多的项。</li></ul><h1 id="b40c" class="la ku hi bd lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls mh lu lv lw bi translated">摘要</h1><p id="b243" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb mi jd je jf mj jh ji jj mk jl jm jn hb bi translated">在本文中，我们解释了元组和列表序列类型。元组(可变)序列更紧凑，更快，更好用。它可以保存列表(可变)对象，并确保在嵌套数据结构中正确使用这些对象。虽然它不能被改变，但是如果它包含一个列表(可变的)对象，它就可以改变。</p><h1 id="7274" class="la ku hi bd lb lc md le lf lg me li lj lk mf lm ln lo mg lq lr ls mh lu lv lw bi translated">参考</h1><ul class=""><li id="ec67" class="jo jp hi is b it lx ix ly jb lz jf ma jj mb jn mc ju jv jw bi translated"><a class="ae ml" href="https://docs.python.org/3/library/collections.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/collections.html</a></li><li id="51c2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mc ju jv jw bi translated"><a class="ae ml" href="https://realpython.com/python-lists-tuples/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/python-lists-tuples/</a></li></ul></div></div>    
</body>
</html>