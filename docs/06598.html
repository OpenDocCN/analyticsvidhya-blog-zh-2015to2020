<html>
<head>
<title>How right equals() method could improve the performance of your application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">right equals()方法如何提高应用程序的性能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-right-equals-method-could-improve-the-performance-of-your-application-2f96388f7c91?source=collection_archive---------13-----------------------#2020-05-27">https://medium.com/analytics-vidhya/how-right-equals-method-could-improve-the-performance-of-your-application-2f96388f7c91?source=collection_archive---------13-----------------------#2020-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b698" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">当我们谈论性能改进时，我们通常会想到算法及其复杂性，但有些事情并不那么明显，但却至关重要。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/eaa731037934842e24f8f9f232361b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gvqTpQKSn6Rez5Vc"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">克里斯里德在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2276" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们假设我们有一个包含成千上万学生记录的数据库。我们的学生有以下特点:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="1455" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public class </strong>Student {<br/>    <strong class="kl hj">private </strong>String <em class="kv">city</em>;<br/>    <strong class="kl hj">private </strong>String <em class="kv">university</em>;<br/>    <strong class="kl hj">private </strong>String <em class="kv">fullName</em>;<br/>    <strong class="kl hj">private int </strong><em class="kv">classNumber</em>;<br/>}</span></pre><p id="e5da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将从以下值中生成学生:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="63c5" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">private static final </strong>String[] <em class="kv">cities </em>= {"New York", "Los Angeles", "Chicago", "Houston", "Phoenix"};<br/><strong class="kl hj">private static final </strong>String[] <em class="kv">names </em>= {"James", "Mary", "John", "Patricia", "Robert"};<br/><strong class="kl hj">private static final </strong>String[] <em class="kv">lastName </em>= {"Smith", "Johnson", "Williams", "Brown", "Jones"};<br/><strong class="kl hj">private static final </strong>String[] <em class="kv">university </em>= {"Liberty University", "California State University, Fullerton","Texas A&amp;M University — College Station", "University of Central Florida","The Ohio State University — Columbus"};</span></pre><p id="5e51" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所有学生字段将从适当的数组中随机设置，从1到5的班级编号和从随机的名字和第二个名字合并的全名。</p><p id="ca36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，对于这个Student.class，我们必须编写equals()方法。通常，我们不会关心我们的equals()方法看起来如何，并通过IDE(在我的情况下是Intellij思想)生成它，但从性能角度来看，这种解决方案是最好的吗？</p><p id="192d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以我们有三个equals()方法。你认为，什么是最快的？</p><p id="190c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">由Intellij IDEA生成</strong></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="42ee" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public boolean </strong>ideaEquals(Object <em class="kv">o</em>) {<br/>    <strong class="kl hj">if </strong>(<strong class="kl hj">this </strong>== <em class="kv">o</em>) <strong class="kl hj">return </strong>true;<br/>    <strong class="kl hj">if </strong>(<em class="kv">o </em>== <strong class="kl hj">null </strong>|| getClass() != <em class="kv">o</em>.getClass()) <strong class="kl hj">return </strong>false;</span><span id="c69f" class="kp kq hi kl b fi kw ks l kt ku">Student <em class="kv">student </em>= (Student) <em class="kv">o</em>;</span><span id="7b60" class="kp kq hi kl b fi kw ks l kt ku"><strong class="kl hj">if </strong>(<em class="kv">classNumber </em>!= <em class="kv">student</em>.<em class="kv">classNumber</em>) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(city, <em class="kv">student</em>.<em class="kv">city</em>)) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(<em class="kv">university</em>, <em class="kv">student</em>.<em class="kv">university</em>)) <br/>        <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">return </strong>Objects.<em class="kv">equals</em>(<em class="kv">fullName</em>, <em class="kv">student</em>.<em class="kv">fullName</em>);<br/>}</span></pre><p id="5218" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">自定义#1 </strong></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="d223" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public boolean </strong>custom1equals(Object <em class="kv">o</em>) {<br/>    <strong class="kl hj">if </strong>(<strong class="kl hj">this </strong>== <em class="kv">o</em>) <strong class="kl hj">return </strong>true;<br/>    <strong class="kl hj">if </strong>(o == <strong class="kl hj">null </strong>|| getClass() != <em class="kv">o</em>.getClass()) <strong class="kl hj">return </strong>false;</span><span id="ade0" class="kp kq hi kl b fi kw ks l kt ku">Student <em class="kv">student </em>= (Student) <em class="kv">o</em>;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(<em class="kv">fullName</em>, <em class="kv">student</em>.<em class="kv">fullName</em>)) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">if </strong>(classNumber != <em class="kv">student</em>.<em class="kv">classNumber</em>) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(<em class="kv">city</em>, <em class="kv">student</em>.<em class="kv">city</em>)) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">return </strong>Objects.<em class="kv">equals</em>(<em class="kv">university</em>, <em class="kv">student</em>.<em class="kv">university</em>);<br/>}</span></pre><p id="5a3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">自定义#2 </strong></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="0cc1" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public boolean </strong>custom2Equals(Object o) {<br/>    <strong class="kl hj">if </strong>(<strong class="kl hj">this </strong>== o) <strong class="kl hj">return </strong>true;<br/>    <strong class="kl hj">if </strong>(o == <strong class="kl hj">null </strong>|| getClass() != o.getClass()) <strong class="kl hj">return </strong>false;</span><span id="cfe0" class="kp kq hi kl b fi kw ks l kt ku">Student student = (Student) o;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(city, student.city)) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(fullName, student.fullName)) <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">if </strong>(!Objects.<em class="kv">equals</em>(university, student.university)) <br/>        <strong class="kl hj">return </strong>false;<br/>    <strong class="kl hj">return </strong>(classNumber == student.classNumber);<br/>}</span></pre><p id="991a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你选择了IntelliJ generated equals()，你的想法是对的，但是…</p><p id="716e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们创建1000个学生实体</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="4f09" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public static </strong>Student generateStudent() {<br/>    <strong class="kl hj">final </strong>Student student = <strong class="kl hj">new </strong>Student();<br/>    student.setCity(<strong class="kl hj">new </strong>String(<em class="kv">cities</em>[<em class="kv">generateInt</em>(0, 4)]));<br/>    student.setClassNumber(<em class="kv">generateInt</em>(1, 5));<br/>    student.setFullName(<em class="kv">generateFullName</em>());<br/>    student.setUniversity(<strong class="kl hj">new </strong>String(<em class="kv">university</em>[<em class="kv">generateInt</em>(0, 4)]));</span><span id="3f59" class="kp kq hi kl b fi kw ks l kt ku">    <strong class="kl hj">return </strong>student;<br/>}</span></pre><p id="432e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用这个相当复杂的方法来计算有多少个实体是相等的</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="d8da" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">private static int </strong>equalStudentsCount(List&lt;Student&gt; students) {<br/>    <strong class="kl hj">int </strong>similar = 0;<br/>    <strong class="kl hj">final int </strong>size = students.size();<br/>    <strong class="kl hj">final long </strong>start = System.<em class="kv">currentTimeMillis</em>();<br/>    <strong class="kl hj">for </strong>(<strong class="kl hj">int </strong>i = 0; i &lt; size; i++) {<br/>        <strong class="kl hj">for </strong>(<strong class="kl hj">int </strong>j = i + 1; j &lt; size; j++) {<br/>            <strong class="kl hj">if </strong>(students.get(i).equals(students.get(j))) {<br/>                similar++;<br/>            }<br/>        }<br/>    }<br/>    <strong class="kl hj">return </strong>similar;<br/>}</span></pre><p id="e1e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了获得准确的结果，我们将使用相同的值列表测试这些方法。每种方法我们将执行100次，并计算平均值</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="1d4b" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public static void </strong>countAverage() {<br/>    <strong class="kl hj">int </strong>size = 1500;<br/>    <strong class="kl hj">int </strong>loops = 100;<br/>    <strong class="kl hj">final </strong>List&lt;Student&gt; students = <em class="kv">generateStudentList</em>(size);<br/>    <strong class="kl hj">final long </strong>start = System.<em class="kv">currentTimeMillis</em>();<br/>    <strong class="kl hj">for </strong>(<strong class="kl hj">int </strong>i = 0; i &lt; loops; i++) {<br/>        <em class="kv">equalStudentsCountIDEA</em>(students);<br/>    }<br/>    <strong class="kl hj">final long </strong>result =(System.<em class="kv">currentTimeMillis</em>() - start)/loops;<br/>}</span></pre><p id="ac1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是测试结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kx"><img src="../Images/8ad07e1e2432ccf9fe78bd5d76bf908d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4hI4yJJB54mXEvy_pSwxw.png"/></div></div></figure><p id="fd8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如你所见，IntelliJ IDEA生成的equals()方法非常快，但并不是在所有情况下都如此。但是怎么做呢？在这个方法中，我们首先比较整数值，然后比较所有字符串。这种行为的主要原因是字段值的唯一性。</p><p id="513c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在字符串之前比较原始值是一个很好的性能观点，但是如果这些值是公共的，这可能会在方法中创建过多的检查。例如，如果我们有1000个实体，并且它们都有相同的布尔值，即使布尔比较比字符串或整数快得多，也没有理由将布尔检查置于其他字段的检查之上。</p><p id="a01a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的例子中，我们的整数字段<strong class="jq hj"> classNumber </strong>介于1和5之间，它具有较低的唯一性，因此没有理由将它放在检查的顶部。字段<strong class="jq hj">城市</strong>和<strong class="jq hj">大学</strong>具有相同的唯一性。<strong class="jq hj"> Student.class </strong>中最独特的字段是<strong class="jq hj"> fullName </strong>，名和姓有25种可能的组合。但是为什么定制#1 不总是比IDE生成的更快呢？</p><p id="a690" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看看String.class equals方法:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="4451" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">public boolean </strong>equals(Object anObject) {<br/>    <strong class="kl hj">if </strong>(<strong class="kl hj">this </strong>== anObject) {<br/>        <strong class="kl hj">return </strong>true;<br/>    }<br/>    <strong class="kl hj">if </strong>(anObject <strong class="kl hj">instanceof </strong>String) {<br/>        String anotherString = (String)anObject;<br/>        <strong class="kl hj">int </strong>n = value.length;<br/>        <strong class="kl hj">if </strong>(n == anotherString.value.length) {<br/>            <strong class="kl hj">char </strong>v1[] = value;<br/>            <strong class="kl hj">char </strong>v2[] = anotherString.value;<br/>            <strong class="kl hj">int </strong>i = 0;<br/>            <strong class="kl hj">while </strong>(n-- != 0) {<br/>                if (v1[i] != v2[i])<br/>                    <strong class="kl hj">return </strong>false;<br/>                i++;<br/>            }<br/>            <strong class="kl hj">return </strong>true;<br/>        }<br/>    }<br/>    <strong class="kl hj">return </strong>false;<br/>}</span></pre><p id="2a35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先“if”部分检查对象是否链接到字符串池中的同一个对象上(这就是为什么我在生成set Student <strong class="jq hj"> city </strong>和<strong class="jq hj"> university </strong>时使用<code class="du ky kz la kl b">new String()</code>)。在这个方法检查之后，如果字符串具有相同的长度，这使得String equals()方法有时真的很快。但是，如果字符串有相同的长度，坏的部分来了，方法逐步比较字符串的每一个字符。这是String.class equals()方法最糟糕的部分，也是人们通常将字符串比较放在equals()方法底部的原因。</p><p id="b5e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，这也是为什么Custom #1 equals()方法并不总是比IntelliJ IDEA one快。一些组合具有相同的长度但是不同的值(例如“玛丽·布朗”和“玛丽·琼斯”，“帕特里夏·史密斯”和“帕特里夏·琼斯”)，但是在String.class equals()方法发现这些字符串是不同的之前，它已经比较了许多字符。</p><p id="32dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们测试这些方法，只使用唯一的名，不使用姓</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="df9a" class="kp kq hi kl b fi kr ks l kt ku"><strong class="kl hj">private static final </strong>String[] <em class="kv">uniqueNames </em>= {"James", "Mary", "John", "Patricia", "Robert", "William", "David",<br/>        "Richard", "Thomas", "Charles", "Daniel", "Matthew", "Anthony", "Donald", "Mark", "Paul", "Steven", "Andrew",<br/>        "Kenneth", "Joshua", "George", "Kevin", "Brian", "Edward", "Ronald"};</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kx"><img src="../Images/49aea1283e49dde7817c1b6ff9f785da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ch9h8UXFqdh0uFFvQO0pZg.png"/></div></div></figure><p id="3889" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如我们所见，结果令人印象深刻，让我们更详细地比较Custom #1和IDEA generated equals()方法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lb"><img src="../Images/e5d892ed28e3df6a961c795d9d74176d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*JWZeg3P6ZEizYMz5gBURfg.png"/></div></figure><p id="7833" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在某些情况下，更多的唯一值让Custom #1 equals()方法的速度更快，如果我们比较Custom #1和IntelliJ生成的方法，这种增加并不明显，但一般来说，这种变化提高了所有equals方法的速度，最多超过600毫秒。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="cd9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，这种速度提升并不是很大，也不值得到处编写自定义的equals()方法。我也喜欢在任何可能的地方使用Lombok。这有助于保持代码的整洁。但这只是一个简单的模板，在真实的项目中，我们有更多的字段和更困难的层次结构的实体。而错误的equals()方法会大大降低应用程序的速度。</p><p id="9809" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">IntelliJ equals()方法生成器很聪明，它首先放置原始值，如boolean、int、short等。但这并不是在所有情况下都有效。</p><p id="2f39" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以有几个规则可以提高使用equals()方法的方法的速度:</p><ul class=""><li id="6777" class="lj lk hi jq b jr js ju jv jx ll kb lm kf ln kj lo lp lq lr bi translated">将唯一字段检查放在首位，即使这是一个字符串。</li><li id="c09d" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">在将字符串放在equals()检查的顶部之前，请注意字符串的长度和唯一性类型。如果每个字符串都是唯一的，但是非常长，并且最终只有值不同(例如<code class="du ky kz la kl b">very-very-long-string-1</code>和<code class="du ky kz la kl b">very-very-long-string-2</code>)，那么将这个字段放在equals()检查的顶部是一个坏主意。</li><li id="ace5" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">如果你不确定数据库中每个字段的唯一性，那么先放入布尔值、枚举、整数。</li><li id="f875" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">在比较实体的所有字段之前，不要忘记空检查。</li></ul></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="558f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望这篇文章对你提高申请速度有所帮助。通常，我们选择较少的代码量而不是应用程序性能，对于某些人来说，这一测试结果可能并不重要，但现在许多应用程序在具有数百个字段的数据库中包含数百万个条目，并使用具有高复杂性的繁重算法，这些算法可能使用equals()方法，因此这几毫秒很容易变成几秒甚至几分钟。</p></div></div>    
</body>
</html>