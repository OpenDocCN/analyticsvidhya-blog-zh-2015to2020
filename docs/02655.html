<html>
<head>
<title>Creating a serverless(almost free) event-driven data analytics pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个无服务器(几乎免费)的事件驱动的数据分析管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-a-serverless-almost-free-event-driven-data-analytics-pipeline-with-aws-athena-s3-sns-a0815fe872eb?source=collection_archive---------16-----------------------#2019-12-27">https://medium.com/analytics-vidhya/creating-a-serverless-almost-free-event-driven-data-analytics-pipeline-with-aws-athena-s3-sns-a0815fe872eb?source=collection_archive---------16-----------------------#2019-12-27</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="16c6" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">与AWS雅典娜，S3，SNS和Lambda</h2></div><p id="7b0d" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">“大数据”分析现在风靡一时，但以如此微不足道的成本分析大量数据从未如此容易。</p><p id="f127" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">AWS Athena是亚马逊的“无服务器交互式查询服务”——使用标准SQL，数据科学家可以对存储在S3的大量数据进行查询(存储如此大量数据的地方非常便宜)。</p><p id="073b" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">有几十篇文章介绍如何开始使用Athena和Glue表(本质上是数据的模式),所以我在这里就不再赘述了。本文的重点是设计和解释一个事件驱动的、持续的分析管道，它可以随您的数据而扩展。</p><p id="ad3e" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated"><em class="jv">先不说:我存储胶合表模式的首选格式是编写</em> <a class="ae ju" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <em class="jv">协议缓冲区</em> </a> <em class="jv">，并从这些缓冲区生成胶合模式。这对于在服务/语言之间传递数据非常有用。</em></p><p id="97eb" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">我将要描述的架构概述如下:</p><figure class="jx jy jz ka fe kb es et paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="es et jw"><img src="../Images/88194560c6815e8c9c9632f86f548a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvFPPPItaU48k_h0Y4Ce0g.png"/></div></div><figcaption class="ki kj eu es et kk kl bd b be z dy translated">事件驱动的Athena分析架构</figcaption></figure><h1 id="bc27" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">数据源</h1><p id="eeb5" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">在本例中，我使用的数据源是一个弹性Beanstalk应用程序和原始IoT MQTT数据。</p><p id="435f" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">这里需要注意的重要部分是，两个服务都将它们的信息发布到支持<a class="ae ju" href="https://docs.aws.amazon.com/firehose/latest/dev/data-transformation.html" rel="noopener ugc nofollow" target="_blank">数据转换</a>的<strong class="ja hk">消防软管</strong>。这非常方便，因为它允许将不同的数据源预先格式化成符合Glue模式的标准化格式。还有其他几种方法可以实现这一点，但我发现一个连接到消防水管的Lambda是最具成本效益和最实时的。</p><h1 id="bd43" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">数据存储</h1><p id="9a85" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">在转换成标准化格式后，数据被存储在S3。对于中小型数据量，压缩的(GZIP) JSON文件应该足够了，但是如果您愿意，Firehose也支持输出到Parquet。</p><p id="89a6" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">S3的定价是可笑的便宜(在我看来)，但雅典娜收费每GB的数据扫描，所以较小的文件(GZIP)是首选。如果数据中有大量不经常查询的列/JSON键，那么使用Parquet输出格式会更有意义(因为它是列格式的，会限制扫描的数据量)。</p><h1 id="9a18" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">事件驱动的数据分析</h1><p id="17dd" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">S3有一个很棒的特性，它能够通知许多其他AWS服务各种事件，其中之一是“对象创建”。</p><p id="1370" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">当Firehose将数据“刷新”到S3时，该事件可以直接触发Lambda、SNS主题和各种其他事件。直接调用Lambda可能有点限制(因为只能触发一个Lambda ),所以我推荐一个Lambda订阅的SNS主题。</p><p id="58ec" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">Lambda然后调用Athena查询。SNS通知将包含关于添加了什么文件的信息，因此这个密钥前缀可以用来告诉Lambda在Athena中运行哪个/哪些查询。</p><p id="bf42" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">示例:</p><ol class=""><li id="30a5" class="lj lk hj ja b jb jc je jf jh ll jl lm jp ln jt lo lp lq lr bi translated">一个文件从Firehose添加到<code class="dv ls lt lu lv b">raw/v0/deviceping</code>(来自物联网设备的心跳消息)—由于数据已在Firehose中缓冲，这将不是单个物联网设备，而是在缓冲间隔[最长15分钟]内接收的所有新心跳消息的串联</li><li id="3916" class="lj lk hj ja b jb lw je lx jh ly jl lz jp ma jt lo lp lq lr bi translated">Lambda对该前缀执行查找，并知道执行查询，从而创建所有物联网设备当前电池电量的报告。</li><li id="ae98" class="lj lk hj ja b jb lw je lx jh ly jl lz jp ma jt lo lp lq lr bi translated">该查询的输出被输出到另一个S3文件，例如<code class="dv ls lt lu lv b">processed/v0/devicebattery</code></li></ol><h1 id="a9cd" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">第二层分析</h1><p id="092c" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">这是事件驱动架构真正开始脱颖而出的地方。使用另一个<strong class="ja hk">对象创建</strong> S3事件，上面输出的报告可用于进一步分析。</p><p id="f5d5" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated"><em class="jv">令人恼火的是，Athena输出了一个CSV文件，我发现这个文件有些局限。作为中间步骤，我调用另一个Lambda将CSV转换成GZIPed JSON，因为CSV不能很好地与Athena/Glue的模式兼容。</em></p><h1 id="0965" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">雅典娜双人舞</h1><p id="5ea9" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">让我们假设高层喜欢图表，并希望看到上周所有物联网设备的电池电量变化的时间序列图。</p><p id="2060" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">为了使该图表尽可能实时，只要Athena输出新的设备电池报告，就可以重新生成该图表。因此，不需要每小时手动(或使用cron)重新计算设备电池图表，如果(且仅如果)有新数据可用，图表可以重新生成！这保持了所显示数据的实时正确性，并防止在底层数据没有改变时进行无用的重新查询。</p><h1 id="2cb9" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">请给我Python！</h1><p id="033c" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">Athena是一个了不起的工具，但它仅限于您可能需要的数据源的一小部分(尽管<a class="ae ju" href="https://aws.amazon.com/blogs/big-data/query-any-data-source-with-amazon-athenas-new-federated-query/" rel="noopener ugc nofollow" target="_blank">联邦查询</a>的发布可能会解决这个问题)。有时可能需要另一种工具(如Python)来进行进一步分析。</p><p id="80e9" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">幸运的是，这种事件驱动的架构可以轻松处理这种情况。第二层Lambda不是通过Athena调用另一个SQL查询，而是调用Python Lambda来执行任何所需的处理。</p><h1 id="372c" class="km kn hj bd ko kp kq kr ks kt ku kv kw ip kx iq ky is kz it la iv lb iw lc ld bi translated">包扎</h1><p id="9a4a" class="pw-post-body-paragraph iy iz hj ja b jb le ik jd je lf in jg jh lg jj jk jl lh jn jo jp li jr js jt hc bi translated">这篇文章仅仅强调了一个被提议的架构，我发现它非常有用而且便宜。对于那些对真实代码示例更感兴趣的人，我很乐意分享一个为上述架构生成CloudFormation模板的<a class="ae ju" href="https://github.com/aws/aws-cdk" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>项目。</p><p id="f195" class="pw-post-body-paragraph iy iz hj ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">感谢阅读！</p></div></div>    
</body>
</html>