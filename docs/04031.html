<html>
<head>
<title>Building A TicTacToe Bot With Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用回归构建TicTacToe机器人</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-tictactoe-bot-with-regression-ba79f2ae74bb?source=collection_archive---------13-----------------------#2020-03-02">https://medium.com/analytics-vidhya/building-a-tictactoe-bot-with-regression-ba79f2ae74bb?source=collection_archive---------13-----------------------#2020-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回归分析是统计学和数据科学中一个令人兴奋且备受推崇的领域。大多数文章都是关于因变量的预测，但是其他问题也可以解决，比如赢得一场比赛。在这篇文章中，我描述了一个简单的TicTacToe机器人，当然你可以在Github上找到我的代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/df388850ff0d112b6285507eb3ecf545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwETQSv2Otys9yYjrHmbzQ.jpeg"/></div></div></figure><h1 id="49a3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">理论</strong></h1><p id="a880" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">首先，我解释了这项任务的一些理论，如果这让你厌烦，你只需滚动到实现细节:)</p><p id="1f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的任务，我们有什么样的培训经验:</p><ul class=""><li id="fd36" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">直接:我们有一套正确移动的棋盘状态</li><li id="d8a1" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">间接:我们有一套实际的游戏(所有动作都设定好了)和最终结果</li></ul><p id="8e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有人监督还是无人监督？</p><ul class=""><li id="8811" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">一切都给了吗？</li><li id="bea4" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">神谕</li><li id="5062" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">与自己作对</li></ul><p id="3a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们必须问自己，我的培训经验(如数据)是否具有代表性？我们当然假设它。在我们的情况下，我们有一个直接的训练，我们想和自己比赛。</p><h2 id="3e86" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">目标功能</strong></h2><p id="178b" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们的bot应该学习什么样的知识呢？一个好的起点是学习如何在可能的行动中选择最佳的行动。因此，我们想学习一个目标函数<em class="lv"> V </em>，用它我们可以选择最佳的移动。</p><p id="b1bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标函数<em class="lv"> V </em>的可能定义如下:</p><ul class=""><li id="caa6" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">如果我们的最终棋盘状态<em class="lv"> b </em>获胜:<em class="lv"> V </em> ( <em class="lv"> b </em> )=1</li><li id="b58c" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">如果我们最终的棋盘状态<em class="lv"> b </em>是亏损:<em class="lv">V</em>(<em class="lv">b</em>)= 1</li><li id="997d" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">如果我们最后的棋盘状态<em class="lv"> b </em>是和棋:<em class="lv"> V </em> ( <em class="lv"> b </em> )=0</li></ul><p id="0ef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果我们在游戏中，所以没有最终状态<em class="lv"> b </em>呢？在这种情况下，我们定义<em class="lv">V</em>(<em class="lv">b</em>)=<em class="lv">V</em>(<em class="lv">b</em>’)，其中<em class="lv">b</em>’是我们可以从起始板状态<em class="lv"> b </em>达到的最佳最终板状态。</p><p id="6c5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个功能的问题是它不可操作。当<em class="lv"> b </em>是最终的棋盘状态时，我们可以有效地计算它，否则我们将不得不寻找一个最优解，直到游戏结束。</p><p id="6e41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要一个目标函数的操作描述。在机器学习领域，你通常期望你的学习算法是目标函数的近似，所以我们要做的是函数近似。</p><h2 id="9715" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">目标功能表示</strong></h2><p id="3eb8" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们现在有一个理想的目标函数<em class="lv"> V </em>并且想要这个函数的近似值。因为<em class="lv"> V </em>是不可操作的，我们定义了它的一个表示:<em class="lv">V</em>’。我们的表示将被计算为自定义特征的线性组合:</p><ul class=""><li id="1d38" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₀:常数1</li><li id="679b" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₁:列/行/对角线的数量，有两个我们自己的棋子和一个空的字段</li><li id="4214" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₂ <strong class="ih hj"> </strong>:有两个敌方棋子和一个空棋子的列/行/对角线的数量</li><li id="6c43" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₃ <strong class="ih hj"> </strong>:我们自己的那块是不是在场地中央？</li><li id="0906" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₄ <strong class="ih hj"> </strong>:我们自己在角落里的棋子数</li><li id="92dc" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₅ <strong class="ih hj"> </strong>:有一个自己的棋子和两个空字段的列数/行数/对角线数</li><li id="66ab" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₆ <strong class="ih hj"> </strong>:有三个自己棋子的列数/行数/对角线数</li></ul><p id="1824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们要添加将由我们的学习算法学习的权重。这个权重将决定一个特征对结果的重要性。我们当前的函数近似现在看起来像这样:</p><p id="42b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="lv">v</em>′=<em class="lv">w</em></strong>₀<strong class="ih hj">∫<em class="lv">x</em></strong>₀<strong class="ih hj">+<em class="lv">w</em></strong>₁<strong class="ih hj">∫<em class="lv">x</em></strong>₁<strong class="ih hj">+<em class="lv">w</em></strong>₂<strong class="ih hj">∫<em class="lv">x</em></strong> ∵<em class="lv">x</em>₅<strong class="ih hj">+<em class="lv">w</em></strong>₆<strong class="ih hj">∵<em class="lv">x</em></strong>₆</p><p id="c890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你不需要<strong class="ih hj"><em class="lv">x</em></strong>₀<strong class="ih hj"/>因为它被设置为1，我只是用它来更容易地迭代权重。<strong class="ih hj"><em class="lv">w</em></strong>₀-weight给我们的近似值增加了一个附加常数，如果我们所有的<strong class="ih hj"><em class="lv">x</em></strong>-值都为零，我们的<strong class="ih hj"><em class="lv">v</em>′</strong>就会是<strong class="ih hj"> <em class="lv"> w </em> </strong> ₀.因此，在<strong class="ih hj"/><em class="lv">x</em>ᵢ<strong class="ih hj">= 0</strong>的情况下，它是<strong class="ih hj"><em class="lv">v</em>’</strong>的期望平均值，也是我们的最佳猜测。</p><p id="fddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在学习我们的近似值<strong class="ih hj"><em class="lv">V</em>’</strong>我们需要训练示例，其中某个板状态<em class="lv"> b </em>给出结果<em class="lv"> Vtrain </em> ( <em class="lv"> b </em>)。在我们的井字游戏示例中，可能的结果是</p><p id="0e8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">⟨⟨<em class="lv">x</em>T3】₀<strong class="ih hj">= 1，<em class="lv"> x </em> </strong> ₁ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₂ <strong class="ih hj"> =1，<em class="lv"> x </em> </strong> ₃ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₄ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₅ <strong class="ih hj"> =0，<em class="lv"> x </em></strong></strong></p><h2 id="9d1d" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">培训评估</strong></h2><p id="c022" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">根据上层棋盘状态，我们现在将更新我们的权重，但这仅适用于最终的棋盘状态。我们还必须注意中级棋盘的状态，这样我们才能在训练中确定最佳的棋步。一个非常简单且成功的方法是为每个中间板状态分配<em class="lv">V train</em>(<em class="lv">b</em>)V′(<em class="lv">succ</em>(<em class="lv">b</em>))的值。<em class="lv">V</em>’是我们当前的近似值，<em class="lv"> succ </em> ( <em class="lv"> b </em>)是我们移动后的棋盘状态的继任者。在井字游戏中，这相当容易，因为你只有有限的可能棋步。所以在你移动之前，你要计算<em class="lv">V</em>′(<em class="lv">succ</em>(<em class="lv">b</em>))的值，如果结果比<em class="lv">V</em>′(<em class="lv">b</em>)高，那么这就是一个好的移动。请注意，使用<em class="lv"> succ </em> ( <em class="lv"> b </em>)时，我们的特性值会发生变化。</p><h2 id="cd94" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">更新权重</strong></h2><p id="e214" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们想更新我们的权重，以确定哪些特征是重要的。在我们的例子中，我们希望最小化平方误差。平方误差的计算公式如下:</p><p id="d580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lv">E</em>=(<em class="lv">V train</em>(<em class="lv">b</em>)—<em class="lv">V</em>’(<em class="lv">b</em>))</p><p id="15e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们想更新我们的权重，这样他们可以最小化这个误差。我们将误差平方，这样我们就有一个正值，大的误差会受到更严厉的惩罚。因此，我们使用LMS算法(最小均方)。</p><p id="ae83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个训练样本，我们使用当前权重来计算我们的<em class="lv">V</em>’(<em class="lv">b</em>)，其中<em class="lv"> b </em>是我们当前的棋盘状态。现在，每个重量都更新为:</p><p id="704d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lv">w</em>ᵢ=<em class="lv">w</em>ᵢ+<em class="lv">η</em>(<em class="lv">v train</em>(<em class="lv">b</em>)v'(<em class="lv">b</em>)<em class="lv">x</em>ᵢ</p><p id="42ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lv"> η </em>是一个常数(如0.001)，它调节权重更新的度量。如果我们的项<em class="lv">v train</em>(<em class="lv">b</em>)<em class="lv">v</em>’(<em class="lv">b</em>)等于零，则权重不更新，如果它是正的<em class="lv">v</em>’(<em class="lv">b</em>)太低，则我们希望通过相应特征<em class="lv"> x </em> ᵢ.的比例来增加我们的权重如果特征为零，我们不更新权重，因为该特征对于结果没有意义。</p><p id="f216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样…我们有一个学习算法。现在我们可以实现它了。</p><h1 id="4e13" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">实施</strong></h1><p id="6c99" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">理论到此为止…我们来编码一下。</p><h2 id="15bf" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">我们的玩家</strong></h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/3387d7d99969394118c1a2a938b603d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViuUweB-VVkcZpOR5UYpjA.jpeg"/></div></div></figure><p id="5260" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于上面提到的每个特征，我们都有一个权重，该权重将被更新以确定哪个特征比另一个特征更重要，通常在回归分析中，我们添加一个截距作为第7个权重。我们将每一场胜利定为1，每一场平局定为0，每一场失败定为-1。</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="6838" class="lh jr hi ly b fi mc md l me mf">weights = [1.0 for _ in range(7)]</span></pre><h2 id="0e53" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">训练循环</strong></h2><p id="4f99" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们要针对自己训练10000个游戏，学习如何玩游戏。因此，我们有一个简单的训练循环:</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="24b1" class="lh jr hi ly b fi mc md l me mf">board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><span id="1d47" class="lh jr hi ly b fi mg md l me mf">while(True):<br/>    pre_features = player1.get_board_features(board)<br/>    pre_approx = player1.evalApproximation(pre_features, weights)<br/>    player1.make_move(board, weights)<br/>    outcome = finished(board, player1)</span><span id="e04f" class="lh jr hi ly b fi mg md l me mf">#…</span></pre><p id="6c2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的棋盘将为每个训练示例重置，当我们玩游戏时，我们通过<code class="du mh mi mj ly b">get_board_features(board)</code>获得当前的棋盘功能。在第一次迭代中，它返回:</p><p id="d106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lv"> x </em> </strong> ₀ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₁ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₂ <strong class="ih hj"> =，<em class="lv"> x </em> </strong> ₃ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₄ <strong class="ih hj"> =0，<em class="lv"> x </em> </strong> ₅ <strong class="ih hj"> =0，<em class="lv"/></strong></p><p id="0511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于稍后的权重更新，我们需要当前与<code class="du mh mi mj ly b">evalApproximation()</code>的近似值。在<code class="du mh mi mj ly b">make_move(board, weights)</code>中，通过尝试将会计算出最好的移动。首先，我们创建所有可能的新棋盘状态:</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="5210" class="lh jr hi ly b fi mc md l me mf">for i in range(3):<br/>    for j in range(3):<br/>        if board[i][j] == 0:<br/>            new_board = copy.deepcopy(board)<br/>            new_board[i][j] = self.color <br/>            new_boards.append((new_board, (i, j)))</span></pre><p id="4ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mh mi mj ly b">deepcopy</code>非常重要，因为否则我们只有参考，所有的动作都将在同一块板上完成。</p><p id="3ded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在创建每个可能的继任者后，我们将获得新的电路板功能，并使用此功能评估每个电路板副本:</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="af8e" class="lh jr hi ly b fi mc md l me mf">def evalApproximation(self, features, weights):</span><span id="9425" class="lh jr hi ly b fi mg md l me mf">    val = 0.0</span><span id="5c8c" class="lh jr hi ly b fi mg md l me mf">    for i in range(len(weights)):<br/>        val += features[i] * weights[i]</span><span id="25f1" class="lh jr hi ly b fi mg md l me mf">    return val</span></pre><p id="73c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们对每个棋盘副本都有一个评级，我们选择最高值作为最佳移动。每走一步后，我们都要测试游戏是否结束，如果没有，第二个玩家(仍然在训练我们的机器人)就走一步。</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="4476" class="lh jr hi ly b fi mc md l me mf">#…</span><span id="79ce" class="lh jr hi ly b fi mg md l me mf">if outcome[0] != -1:<br/>    break</span><span id="010f" class="lh jr hi ly b fi mg md l me mf">player2.make_move(board, weights)<br/>outcome = finished(board, player2)<br/>if outcome[0] != -1:<br/>    break</span><span id="f822" class="lh jr hi ly b fi mg md l me mf">#…</span></pre><p id="0dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一次迭代之后，我们必须更新我们的权重，因为我们走了一步，而我们的对手走了一步。</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="e0b9" class="lh jr hi ly b fi mc md l me mf">#…</span><span id="02c6" class="lh jr hi ly b fi mg md l me mf">succ_features = player1.get_board_features(board)<br/>succ_approx = player1.evalApproximation(succ_features, weights)</span><span id="bc63" class="lh jr hi ly b fi mg md l me mf">weight_update(weights=weights,lr_const=lr,train_val=succ_approx, approx=pre_approx, features=pre_features)</span></pre><p id="e12e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再次评估移动后的特征，并计算我们的函数<em class="lv">V</em>′(<em class="lv">succ</em>(<em class="lv">b</em>))的当前近似值。我们的权重更新将按照LMS更新规则执行:</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="60ae" class="lh jr hi ly b fi mc md l me mf">def weight_update(weights, lr_const, train_val, approx, features):</span><span id="98fe" class="lh jr hi ly b fi mg md l me mf">    for i in range(len(weights)):<br/>        weights[i] = weights[i] + lr_const* (train_val — approx) *                                              <br/>                                             features[i]</span></pre><p id="1ba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个权重，我们计算后续近似和当前近似的误差。如果现在我们的值大于零，这是一个很好的举动，因为我们的最终结果应该是1。如果它比当前的近似值小，这是一个糟糕的举动，因为损失的结果是-1。</p><p id="3fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">游戏结束后，执行最后一次权重更新。这里结果被设置为<code class="du mh mi mj ly b">train_val</code>，1表示赢，0表示平，1表示输。</p><h2 id="c797" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated"><strong class="ak">评价</strong></h2><p id="3834" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">经过10.000场比赛的初始训练，1000场比赛对一个随机设置代币的玩家。如果两个随机的玩家互相对战，结果几乎是平衡的:</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="7269" class="lh jr hi ly b fi mc md l me mf">╔═══════════╦════════════════════╦═══════════════╗<br/>║   Won     ║       Draw         ║     Loss      ║<br/>╠═══════════╬════════════════════╬═══════════════╣<br/>║   410     ║       138          ║     452       ║<br/>╚═══════════╩════════════════════╩═══════════════╝</span></pre><p id="b991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果第一个玩家根据我们的回归学习，它赢了91.9%！</p><pre class="jf jg jh ji fd lx ly lz ma aw mb bi"><span id="8038" class="lh jr hi ly b fi mc md l me mf">╔═══════════╦════════════════════╦═══════════════╗<br/>║   Won     ║       Draw         ║     Loss      ║<br/>╠═══════════╬════════════════════╬═══════════════╣<br/>║   919     ║       38           ║     46        ║<br/>╚═══════════╩════════════════════╩═══════════════╝</span></pre><p id="d55f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还实现了你可以和机器人对战的地方。如果你迈出第一步，你会很容易赢，因此我认为我们可以添加更多的功能，但对于第一次测试来说，这已经足够了。</p><p id="3a15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整代码在<a class="ae jd" href="https://github.com/Skyy93/TicTacToeRegressionBot" rel="noopener ugc nofollow" target="_blank"> Github </a>网站上</p><p id="2c78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">敬请关注。</p><p id="3d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来源:汤姆·米切尔——机器学习</p></div></div>    
</body>
</html>