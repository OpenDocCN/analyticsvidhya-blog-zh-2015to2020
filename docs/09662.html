<html>
<head>
<title>Minimum Spanning Tree — Prim</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最小生成树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/minimum-spanning-tree-prim-3f32445ce854?source=collection_archive---------15-----------------------#2020-09-15">https://medium.com/analytics-vidhya/minimum-spanning-tree-prim-3f32445ce854?source=collection_archive---------15-----------------------#2020-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来源:<a class="ae jd" href="https://shawnlyu.com/algorithms/minimum-spanning-tree-prim/" rel="noopener ugc nofollow" target="_blank">https://shawnlyu.com/algorithms/minimum-spanning-tree-prim/</a></p><p id="2f36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">一棵</em> <strong class="ih hj"> <em class="je">最小生成树</em></strong><em class="je">(</em><strong class="ih hj"><em class="je">MST</em></strong><em class="je">)或</em> <strong class="ih hj"> <em class="je">最小权重生成树</em> </strong> <em class="je">是一棵</em> <a class="ae jd" href="https://en.wikipedia.org/wiki/Connected_graph" rel="noopener ugc nofollow" target="_blank"> <em class="je">连接</em> </a> <em class="je">的边的子集，是连接所有</em> <a class="ae jd" href="https://en.wikipedia.org/wiki/Vertex_(graph_theory)" rel="noopener ugc nofollow" target="_blank"> <em class="je">顶点的边加权无向图</em></a></p><p id="2182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本帖将介绍其中一个寻找MST的算法:<strong class="ih hj"> Prim </strong>。将提供逻辑、时间/空间复杂性和实现。壮举。Leetcode挑战<a class="ae jd" href="https://leetcode.com/problems/min-cost-to-connect-all-points/" rel="noopener ugc nofollow" target="_blank"> 1584。连接所有点的最小成本</a>。</p><h1 id="489f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">逻辑</h1><p id="7e96" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">Prim的逻辑与<a class="ae jd" href="https://shawnlyu.com/algorithms/shortest-path-algorithms-i-dijkstra/" rel="noopener ugc nofollow" target="_blank"> Dijkstra的算法</a>颇为相似，同样是贪婪地寻找最轻的边缘。它从任意顶点<code class="du ki kj kk kl b">v</code>开始，以一组跨越所有顶点的边<code class="du ki kj kk kl b">A</code>结束。在每一步，它都会寻找连接<code class="du ki kj kk kl b">A</code>和图中孤立顶点的边。伪代码如下所示。</p><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="23a9" class="ku jg hi kl b fi kv kw l kx ky">MST-PRIM(G,w,r)<br/>'''<br/>G: the connected graph<br/>w: weights<br/>r: the root vertex<br/>Q: a min-priority queue based on a key field<br/>key: for each vertex v, key[v] is the minimum weight \<br/>     of any edge connecting to a vertex in the MST<br/>π: for each vertex v, π[v] names the parent of v in the MST<br/>'''<br/>for each u in V[G]<br/>    key[u] = inf<br/>    π[u] = NIL<br/>key[r] = 0<br/>Q = V[G]<br/>while Q:<br/>    u = EXTRACT_MIN(Q)<br/>    for each v in Adj[u]<br/>        if v in Q and w(u,v)&lt;key[v]<br/>            π[v] = u<br/>            key[v] = w(u,v)</span></pre><p id="5357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是普里姆的一个例子:</p><figure class="km kn ko kp fd la er es paragraph-image"><div class="er es kz"><img src="../Images/fffee87eaba75ba4f22f72edf0a079eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/0*sRJQy9-CU_5H7wS3.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">来源:<a class="ae jd" href="https://shawnlyu.com/algorithms/minimum-spanning-tree-prim/" rel="noopener ugc nofollow" target="_blank">https://shawnlyu.com/algorithms/minimum-spanning-tree-prim/</a></figcaption></figure><h1 id="e17f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">复杂性</h1><p id="ba5a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><strong class="ih hj">线17 </strong>有两种实现方式。</p><ul class=""><li id="3158" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">使用邻接矩阵，使EXTRACT_MIN取<em class="je">O</em>(<em class="je">V</em>)；</li><li id="cfe6" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">使用二进制堆，以便EXTRACT_MIN取<em class="je"> O </em> ( <em class="je"> logV </em>)。</li></ul><h2 id="3b6e" class="ku jg hi bd jh lv lw lx jl ly lz ma jp iq mb mc jt iu md me jx iy mf mg kb mh bi translated">邻接矩阵</h2><ul class=""><li id="8924" class="lh li hi ih b ii kd im ke iq mi iu mj iy mk jc lm ln lo lp bi translated">初始化需要<em class="je"> O </em> ( <em class="je"> V </em>)(第11–15行)。</li><li id="be46" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">第16行将执行<em class="je"> O </em> ( <em class="je"> V </em>)次，所以EXTRACT_MIN总共需要<em class="je">O</em>(<em class="je">V</em>∫<em class="je">V</em>)。</li><li id="52ee" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">由于第16行的while循环将针对每个顶点执行，第18行的for循环将针对顶点的每个边执行，因此第18行的for循环将执行<em class="je"> O </em> ( <em class="je"> E </em>)次。</li></ul><p id="fd30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，总的时间复杂度将是<em class="je">o</em>(<em class="je">v</em>+<em class="je">v^</em>2+<em class="je">e</em>)=<em class="je">o</em>(<em class="je">v^</em>2)。空间复杂度为<em class="je">O</em>(<em class="je">V</em>+<em class="je">E</em>)。</p><h2 id="97fe" class="ku jg hi bd jh lv lw lx jl ly lz ma jp iq mb mc jt iu md me jx iy mf mg kb mh bi translated">二元堆</h2><ul class=""><li id="a456" class="lh li hi ih b ii kd im ke iq mi iu mj iy mk jc lm ln lo lp bi translated">初始化需要<em class="je"> O </em> ( <em class="je"> V </em>)(第11–15行)。</li><li id="4537" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">第16行将执行<em class="je"> O </em> ( <em class="je"> V </em>)次，所以EXTRACT_MIN总共需要<em class="je">O</em>(<em class="je">V</em>∫<em class="je">logV</em>)。</li><li id="8cda" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">由于第16行的while循环将针对每个顶点执行，第18行的for循环将针对顶点的每个边执行，因此第18行的for循环将执行<em class="je"> O </em> ( <em class="je"> E </em>)次。</li><li id="b1d4" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">第21行表示堆上的更新操作，因此取<em class="je"> logV </em>。</li></ul><p id="d9c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，总时间复杂度将为<em class="je">O</em>(<em class="je">V</em>+<em class="je">VlogV</em>+<em class="je">ElogV</em>)=<em class="je">O</em>(<em class="je">ElogV</em>)。空间复杂度为<em class="je">O</em>(<em class="je">V</em>+<em class="je">E</em>)。</p><h1 id="0ed7" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">实现— <a class="ae jd" href="https://leetcode.com/problems/min-cost-to-connect-all-points/" rel="noopener ugc nofollow" target="_blank"> 1584。连接所有点的最小成本</a></h1><p id="27df" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">将提供使用二进制堆和邻接矩阵的两种实现。注意到这个图是一个密集图，因此使用二进制堆带来了<em class="je">o</em>(<em class="je">elogv</em>)=<em class="je">o</em>(<em class="je">v^</em>2<em class="je">logv</em>)并且使用邻接矩阵带来了<em class="je"> O </em> ( <em class="je"> V^ </em> 2)。因此，后一种方法将提供更有效的解决方案。</p><h2 id="1a4a" class="ku jg hi bd jh lv lw lx jl ly lz ma jp iq mb mc jt iu md me jx iy mf mg kb mh bi translated">二元堆</h2><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="233e" class="ku jg hi kl b fi kv kw l kx ky">class Solution:<br/>    def minCostConnectPoints(self, points: List[List[int]]) -&gt; int:<br/>        dist = collections.defaultdict(list)<br/>        n = len(points)<br/>        for i in range(n):<br/>            for j in range(i+1,n):<br/>                d = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])<br/>                dist[i].append((j,d))<br/>                dist[j].append((i,d))<br/>        ret = 0<br/>        visited = set([])<br/>        pq = [(0,0)]<br/>        while pq:<br/>            w,u = heapq.heappop(pq)<br/>            if u not in visited:<br/>                ret += w<br/>                visited.add(u)<br/>                for v,d in dist[u]:<br/>                    if v not in visited: heapq.heappush(pq,(d,v))<br/>        return ret</span></pre><h2 id="90a7" class="ku jg hi bd jh lv lw lx jl ly lz ma jp iq mb mc jt iu md me jx iy mf mg kb mh bi translated">邻接矩阵</h2><pre class="km kn ko kp fd kq kl kr ks aw kt bi"><span id="4906" class="ku jg hi kl b fi kv kw l kx ky">class Solution:<br/>    def minCostConnectPoints(self, points: List[List[int]]) -&gt; int:<br/>        def dist(u,v):<br/>            return abs(points[u][0]-points[v][0])+abs(points[u][1]-points[v][1])<br/>        n = len(points)<br/>        ret = 0<br/>        visited = [False]*n<br/>        visited[0] = True<br/>        closest = [0]*n<br/>        for i in range(1,n): closest[i] = dist(0,i)<br/>        for _ in range(n-1):<br/>            mini = float('inf')<br/>            node = -1<br/>            for i in range(n):<br/>                if not visited[i] and closest[i] &lt; mini:<br/>                    mini = closest[i]<br/>                    node = i<br/>            ret += mini<br/>            visited[node] = True<br/>            for i in range(n):<br/>                if not visited[i]: closest[i] = min(closest[i],dist(i,node))<br/>        return ret</span></pre><h1 id="c945" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">参考</h1><ul class=""><li id="0812" class="lh li hi ih b ii kd im ke iq mi iu mj iy mk jc lm ln lo lp bi translated"><a class="ae jd" href="https://shawnlyu.com/algorithms/shortest-path-algorithms-i-dijkstra/" rel="noopener ugc nofollow" target="_blank">https://Shawn lyu . com/algorithms/shortest-path-algorithms-I-Dijkstra/</a></li><li id="9ec6" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://leetcode.com/problems/min-cost-to-connect-all-points/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/min-cost-to-connect-all-points/</a></li><li id="da03" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://iq.opengenus.org/prim-minimum-spanning-tree-algorithm/" rel="noopener ugc nofollow" target="_blank">https://IQ . open genus . org/prim-minimum-spanning-tree-algorithm/</a></li><li id="2c92" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Prim%27s_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Prim%27s_algorithm</a></li></ul></div></div>    
</body>
</html>