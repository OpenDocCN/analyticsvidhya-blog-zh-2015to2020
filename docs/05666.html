<html>
<head>
<title>K-Means Clustering | Image Compression Done Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k-均值聚类|图像压缩做得好</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/k-means-clustering-image-compression-done-right-dfad434652b6?source=collection_archive---------16-----------------------#2020-04-28">https://medium.com/analytics-vidhya/k-means-clustering-image-compression-done-right-dfad434652b6?source=collection_archive---------16-----------------------#2020-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="d621" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">Python中的K-means、Elbow方法(WCSS)和图像压缩研究</p></blockquote></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="0953" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我希望你以最好的健康和工作精神阅读这篇文章。由于新冠肺炎的封锁给了我们前所未有的时间去探索更多。这是我第一次以程序员的身份尝试数据科学，也是我第一次以作家的身份尝试Medium所以请容忍我。</p><p id="4bff" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">数据点</strong>是与我们最初零散的原始观测片段；很少或没有关于他们关系的信息。<br/> <strong class="il hj">聚类</strong>就是寻找数据点之间的某种联系，把相似的数据点聚在一起。在当前的全球形势下，人们经常在媒体上听到新冠肺炎的集群，其中新冠肺炎是<em class="ik">数据点</em>(人类)之间的<em class="ik">关系</em>。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/c8994fdc80abf4d7105500e6180c0615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDRHb4IQUpvdxbWFOerIeA.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">天体星团</figcaption></figure><p id="d4e8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">在数据点之间的关系不容易被注意到的复杂场景中，各种数学和计算机科学工具被用来寻找相同的东西。<br/> K-Means算法就是这样一种方法。</p></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="4efc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">它是如何做到的，它能做什么？</strong></p><p id="6653" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">第一个</strong> <em class="ik">，K-Means </em>在N维空间中挑选<em class="ik"> K个</em>随机初始点(称它们为<em class="ik">初始点【前方T21】)(N是数据点的独立属性/特性(假设，对于Covid患者，这些特性可以是年龄、血压、先前的呼吸问题等)。</em></p><p id="b326" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">其次，</strong>计算每个数据点与<em class="ik">初始点</em>之间的距离(假设<em class="ik">欧几里德</em>)。然后，每个数据点被分配到其最近的<em class="ik"> InitPoint。</em>从而形成初始聚类集。</p><blockquote class="if ig ih"><p id="a4db" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi">距离可以是</em>闵可夫斯基<em class="hi">、</em>欧几里德<em class="hi">或其他距离。</em></p></blockquote><p id="6af5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">第三，</strong>每个<em class="ik">初始点</em>被移动到分配给它的各个数据点的新获得的质心(外行:中心/中间)。</p><p id="f2d4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">重复</strong>第二步，寻找每个数据点和新质心(旧<em class="ik">初始点</em>)之间的距离，并将数据点重新分配到最近的质心(移动<em class="ik">初始点</em>)。接着是第三步。<br/>重复这两个步骤，直到没有数据点到新的不同最近质心/ <em class="ik"> InitPoint </em>的新分配发生。即质心被正确地分配给所有的数据点。</p><p id="232c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我们现在拥有的是一个有K个集群的N维空间。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kh"><img src="../Images/2cc71c081db49d44d22cd772c5414497.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*A-85GuVEk4o3-iFdXzRcHQ.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">通过反复计算点和初始点的距离获得聚类质心</figcaption></figure></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="7b91" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">如何决定随机初始点的个数“<em class="ik"> K </em>”？</strong> <br/> <strong class="il hj">肘法</strong></p><p id="5217" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我们从<em class="ik"> K </em> = 1开始，并假设所有数据点都在一个集群中。然后按照<em class="ik"> K-Means </em>算法，我们得到正确的质心。<br/>此后，我们计算所谓的<strong class="il hj"><em class="ik"/></strong>【簇内平方和】<br/>，这是在已经执行了<em class="ik"> K-means </em>之后，每个数据点到其指定质心/ <em class="ik"> InitPoint </em> 的距离的平方和<strong class="il hj">。</strong></p><p id="d4fc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">数学上给出如下:-</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ki"><img src="../Images/45b81882c0e8c35b251eae22e47783c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*7wJ_8xbLCgcunOUVrT92WA.png"/></div></figure><p id="c634" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我们取<em class="ik"> K </em> =2，<em class="ik"> K </em> = 3 …以此类推，计算<em class="ik"> WCSS </em>的行程。<br/>然后，我们绘制一张<strong class="il hj"> <em class="ik"> K </em>与<em class="ik"> WCSS之间的关系图。</em> </strong></p><p id="f8bb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">就像这样出现了:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kj"><img src="../Images/d862ab16b8f81b94f40cecce7642f898.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*_koAZm2-vkceT-J59JgCtw.png"/></div></figure><p id="bffd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">因此，我们看到，对于数据点的一些给定样本，对于<em class="ik"> K = </em> 3，观察到肘形弯曲；给我们一个关于计数的概念。这最终将是集群的计数。人们必须观察到，如果我们不断增加星团的数量，WCSS就会不断下降。如果我们建立和数据点数量一样多的聚类。WCSS将降为零。因为每个点本身就是质心。</p><p id="aff1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">这样的聚类没有解决任何目的。更确切地说，拾取初始点，随机有其自身的问题<em class="ik"> </em>称为<strong class="il hj"> <em class="ik">随机初始化陷阱</em> </strong>，导致不同的start <em class="ik"> InitPoints </em>产生不同的最终结果(集群集)。因此，请多读一些关于“K-means++的内容来避免这个陷阱。</p></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><h1 id="b3c2" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">图像压缩做得很好</h1><p id="17f4" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jo lk iw ix jp ll ja jb jq lm je jf jg hb bi translated">K-Means算法有不同的应用，从预测营销活动的正确受众到文本和图像聚类。</p><p id="27d1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">下面是用于压缩图像的K-Means的实际实现。</p><p id="bf67" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">我是一个狂热的旅行者，所以在这里我从雄伟的喜马拉雅山<em class="ik">的<em class="ik"> Kheergana Trek </em>中挑选了一张我最喜欢的图片，并将其压缩，用Python编程。</em></p><blockquote class="if ig ih"><p id="639b" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">完整代码如下:</p></blockquote><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">利用KMeans聚类进行图像压缩</figcaption></figure><blockquote class="if ig ih"><p id="16e8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">之前和之后:</p></blockquote><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lp"><img src="../Images/55a9fa7b2044adc18b7e5a382e76946a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnyduG8lrXZ-tjheuNk3zw.png"/></div></div></figure><p id="5bb2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">这里初始图片是1200*1600像素。因为每种颜色/像素由三原色红、绿、蓝组成；叫做RGB。每个像素的RGB值可以是(0，0，0)到(255，255，255)之间的任何值。<br/>该方法是从图像中读取所有像素，并在三维空间(R，G，B)中为每个像素形成64个聚类。RGB是我们的数据点。</p><p id="9079" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">这些群集的质心将保存RGB值，我们需要打印该群集下的所有像素。本质上，上面右边的图片仅仅是由64种颜色组成的！！！</p><p id="6ad3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">读取图像像素:</p><pre class="js jt ju jv fd lq lr ls lt aw lu bi"><span id="ef57" class="lv kl hi lr b fi lw lx l ly lz">org_image = Image.open('Kheerganga.jpeg','r')<br/>size = org_image.size<br/>pixels = list(org_image.getdata())<br/>final_pixels = []<br/>for i in range(0,len(pixels)):<br/>    final_pixels.append( np.array(pixels[i]) )<br/>final_pixels = np.array(final_pixels)</span></pre><blockquote class="if ig ih"><p id="5e69" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这里我们取64个聚类，并预测每个像素的聚类为:</p></blockquote><pre class="js jt ju jv fd lq lr ls lt aw lu bi"><span id="20df" class="lv kl hi lr b fi lw lx l ly lz">kmeans = KMeans(n_clusters = 64, init = 'k-means++', n_init= 10, max_iter = 20)<br/>y_kmeans = kmeans.fit_predict(final_pixels)</span></pre><blockquote class="if ig ih"><p id="c557" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">下面的代码给出了质心:</p></blockquote><pre class="js jt ju jv fd lq lr ls lt aw lu bi"><span id="597c" class="lv kl hi lr b fi lw lx l ly lz">centroids = kmeans.cluster_centers_</span></pre><p id="1be1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated"><strong class="il hj">最后</strong>，我们遍历每个像素，获取它的聚类(从64个中)，以及相应的质心值(RGB)。</p><blockquote class="if ig ih"><p id="3cd2" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我们做的情节是:</p></blockquote><pre class="js jt ju jv fd lq lr ls lt aw lu bi"><span id="fe0b" class="lv kl hi lr b fi lw lx l ly lz">X = np.arange(0,org_image.size[0])<br/>for y in range(0,org_image.size[1]):<br/>    plt.scatter(np.full((1,org_image.size[0]),y)[0],X ,c = kmeans.cluster_centers_[ykmeans[y][X]]/255)<br/>plt.show()</span></pre></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="a435" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jo iv iw ix jp iz ja jb jq jd je jf jg hb bi translated">这是我对算法的一点回顾。非常欢迎建设性的批评、意见和建议；)下次见。#StayHomeStaySafe</p></div></div>    
</body>
</html>