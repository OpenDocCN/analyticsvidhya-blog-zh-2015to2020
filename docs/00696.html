<html>
<head>
<title>Math Behind Support Vector Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持向量机背后的数学</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/math-behind-support-vector-machines-642421e45b08?source=collection_archive---------5-----------------------#2019-08-27">https://medium.com/analytics-vidhya/math-behind-support-vector-machines-642421e45b08?source=collection_archive---------5-----------------------#2019-08-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在之前的一篇关于分类的文章中已经看到了关于逻辑回归的内容。在这篇文章中，我们将看看另一种机器学习算法，即支持向量机。</p><p id="2369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">支持向量机创建n维超平面来基于参数分离数据。如果数据有2个变量，那么它是一条线，3，它是一个平面，等等。</p><h2 id="73e5" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">问题定义:</strong></h2><p id="4dc5" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">考虑一个分类问题，有两个类。目标是找到一个超平面，以最大化点之间的间隔的方式对两个类进行分类。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ke"><img src="../Images/7748bb10003619429d4a49dd27607002.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*ltHWLdqzaomul_4DUt8_iA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">可视化支持向量</figcaption></figure><p id="a190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的图片中，有两个类别，它们是根据描述的形状来区分的。“<em class="kq"> + </em>”符号是一组分类为“- <em class="kq"> 1 </em>”的点，而“<em class="kq"> o </em>”则用于“<em class="kq"> +1 </em>”类。蓝色和橙色的点称为支持向量。支持向量机的整个目标是最大化两条虚线之间的距离，即两个类之间的间隔，那里的街道尽可能宽。</p><h2 id="3199" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">直觉:</strong></h2><p id="c4aa" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">让我们把支持向量问题中的所有点看作一个向量。即它有大小和方向。将点分类为属于正类或负类的方式是通过获取点的矢量(<em class="kq"> x </em>)，将其投影到另一个矢量“<em class="kq"> w </em>”上，该矢量垂直于图中的中线(因此中线将被称为中线)。如果投影值大于常数'<em class="kq"> c </em>'，则为阳性样本，否则为阴性样本。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kr"><img src="../Images/ef1786cc1e46f2e815d2293831210325.png" data-original-src="https://miro.medium.com/v2/resize:fit:150/1*BkGQkzTsPRIxl4oMymyFjQ.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">两个向量的点积，x是输入，w是垂直于中线的向量</figcaption></figure><p id="4c54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的等式可以写成</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ks"><img src="../Images/049f3804b7b98fdb6907bf8e4619eaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:210/1*-y6iOY6A24mlA9oMbbY2zw.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">其中c = -b</figcaption></figure><p id="784d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述等式给出了支持向量机的基本直觉，其中任何等于零的值都将在超平面上。</p><p id="ac0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将上面的等式用于每一个正类'<em class="kq"> +1 </em>'和每一个负类'<em class="kq"> -1 </em>'</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kt"><img src="../Images/89ed4eba718cd4fac91cb77cb1ace509.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/1*9dPhCPKPESQtfdo9Zr0Yuw.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">对于正类</figcaption></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ku"><img src="../Images/aeddfd490f39c65254795840cd52f7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/1*4ASA1oqUEDuUAeQYBlmcTA.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">对于负类</figcaption></figure><p id="3a35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值[-1，1]之间的距离是我们试图最大化的余量。为了数学上的方便，我们引入另一个变量'<em class="kq"> y </em>'，将上述两个方程合二为一。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kv"><img src="../Images/8c94165e4b1a0630d3fcc67b4dc15cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/1*2WTWSjRRMT0KLlnHwf9Arg.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">yi=+1表示正类，yi = -1表示负类</figcaption></figure><p id="a339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于街道内的任何一点，该等式转换为</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kw"><img src="../Images/8c2cb10d9ecb168668860aa7e657b62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/1*vdzGHFtZ_Mf7Nte-Fge8dg.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">街头价值的等式1。</figcaption></figure><p id="8982" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑虚线上的两点，一个在正侧，另一个在负侧，</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kx"><img src="../Images/b2868c094b3f46d0ca2f6fee8f2304ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*KsG2iwwYLoM--oK7sxg3LA.png"/></div></figure><p id="a997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要找到两条虚线或我们称之为街道之间的距离。让我们考虑一个单位法向量。由于我们使用了'<em class="kq"> w </em>'作为中线的法向量，我们将把它除以它的大小，得到单位法向量。设代表正负两点的向量为</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ky"><img src="../Images/151ec66f7ffa400086516119657f9296.png" data-original-src="https://miro.medium.com/v2/resize:fit:38/1*atIZCr1VQI35GwReBMZePg.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">负类中点的向量</figcaption></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kz"><img src="../Images/0e848c31b6e140f3e5ca0b3d14752232.png" data-original-src="https://miro.medium.com/v2/resize:fit:40/1*HXTf3BHd3NIqZ0c8xN-jhQ.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">正类中点的向量</figcaption></figure><p id="8fd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个点都位于街道两侧的虚线上，这意味着这两个点之间的差异，单位法线的点积就是街道的宽度。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es la"><img src="../Images/39d4bf62a5f79e64f0bc7ee0446b8b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/1*XUxqbgRbWvWTGFAlLoJ_0w.gif"/></div></figure><p id="daf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，将上述等式中的“<em class="kq"> x+ </em>”和“<em class="kq"> x- </em>”的值代入等式1，我们得到“<em class="kq"> x+ </em>”和“<em class="kq"> x- </em>”与单位法向量“<em class="kq"> w </em>”进行点积之前的值，给出</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lb"><img src="../Images/d63e7677e068d5a3b544336e53afa61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/1*cCNHJzLahgmcZ6YXxcFCZg.gif"/></div></figure><p id="7ecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这产生了</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lc"><img src="../Images/b7a54b78d16eca056a664ffd2585ee02.png" data-original-src="https://miro.medium.com/v2/resize:fit:98/1*Ig-y23-AU_Nlh5jxNKpWmg.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">为SVM创造最大价值</figcaption></figure><p id="7a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也可以写成最小化'<em class="kq"> w </em>'</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ld"><img src="../Images/65912dacdb53cc95619db7df2f29418c.png" data-original-src="https://miro.medium.com/v2/resize:fit:96/1*2HkOjt_CvF6GIcBZ0TXF-A.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">分子中的1，因为它是一个常数值。</figcaption></figure><p id="6b99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于数学计算，我们可以将方程转换为</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es le"><img src="../Images/d04e90d971e9448c6a1381371f7c28a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/1*8Sho-vugzIl45lxIXl5R4w.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">最小化支持向量机的值</figcaption></figure><p id="6840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们使用拉格朗日乘数，在等式1的约束下最大化上述等式，我们得到</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lf"><img src="../Images/ad4b1a01215853fd7e2a0d0be98b2fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/1*bF5ItbjM-oI5gU8saIRgbw.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">使用拉格朗日乘数，等式2</figcaption></figure><p id="0230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们取'<em class="kq"> w </em>'和'<em class="kq"> b </em>'的导数，将其设为零，并将其代入等式2，我们得到</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lg"><img src="../Images/b3b3e2bab1cbd8c2070f1061b7275ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/1*xOCCeqiR4QOpBogMq_sAgQ.gif"/></div></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lh"><img src="../Images/23867d491a6998e0141321fac3a0680a.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/1*2gVDB6jTibFqpD2wvBpzXQ.gif"/></div></figure><p id="8374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们将上述两个等式设为零，并将其代入等式2时，我们得到</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es li"><img src="../Images/950581a8029fa1a68051e5876e06624c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*ZQFLwf8nlhyEl5k_PgxhBA.gif"/></div></figure><p id="11a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简化后给出</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/26b638765a0bf85fa526b88f4972e662.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/1*cEXMSjlMQCld7qaxXwLo3Q.gif"/></div></div></figure><p id="93b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以清楚地观察到，这个等式取决于'<em class="kq"> x </em>'中样本值的点积。</p><p id="ab56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经讨论了线性可分类，即当数据集中没有数据点重叠时。然而，在实际的数据集中，这是不可能的，会有某些数据点在任何一边，我们需要我们的支持向量机模型来考虑这一点，并仍然产生最佳的超平面。</p><p id="5eb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是通过在传统的支持向量机方程中引入松弛变量来实现的。松弛变量惩罚不在超平面右侧的点。在下面的等式中，它是eta，而C是一个超级参数，我们需要调整它来告诉我们对每个错误的惩罚程度。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lo"><img src="../Images/1eda6c1cb7ffc88a8fdd7c470473ae8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/1*zZ1vVUbP03XfbKl2H_7G5w.gif"/></div></figure><p id="a8ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述等式受到以下约束:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lp"><img src="../Images/a11f8b6b38ed8c03ac1372fec8fe3725.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/1*5u-0tj7mevU874ys2awIyA.gif"/></div></figure><p id="ae2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们的整个SVM方程可以归结为:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lq"><img src="../Images/db517daea8a5c509b8377bbffc0b20e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/1*4HQNrnSPPFC5IzzydLajEQ.gif"/></div></figure><p id="2ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超级参数'<em class="kq"> c </em>'定义了我们处罚错误的幅度。“<em class="kq"> c </em>的值越大，模型成为硬边界分类的机会就越大。</p><p id="e105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与支持向量机相关联的损失函数被称为铰链损失，因为，如果最大值函数中的第二项的值为负，则第二项为“<em class="kq"> 0 </em>”,如果最大值函数中的第二项为0，则第二项为“<em class="kq"> 1 </em>”。</p><blockquote class="lr ls lt"><p id="b9c0" class="if ig kq ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">github的要点是</p></blockquote><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><blockquote class="lr ls lt"><p id="24b0" class="if ig kq ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">如果你发现任何错误，请随意评论。</p></blockquote></div></div>    
</body>
</html>