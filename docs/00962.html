<html>
<head>
<title>Improving meteorological and ocean models with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用机器学习改进气象和海洋模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/improving-meteorological-and-ocean-models-with-machine-learning-part-2-applying-deep-learning-to-239883b4815e?source=collection_archive---------14-----------------------#2019-09-21">https://medium.com/analytics-vidhya/improving-meteorological-and-ocean-models-with-machine-learning-part-2-applying-deep-learning-to-239883b4815e?source=collection_archive---------14-----------------------#2019-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ba4c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第二部分:应用深度学习增强气象模型预测的能见度变量</h2></div><p id="46b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在上一篇文章<a class="ae jt" rel="noopener" href="/@robinat539/improving-meteorological-and-ocean-models-with-machine-learning-part-1-assessing-the-4c309851a81e"> part 1 </a>中可以看到，visibility这个变量的模型性能是低劣的。我们将评估模型的性能，并尝试用深度学习来改进它。</p><p id="bca2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以从我的Github帐户开始定义数据框:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="280a" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">import pandas as pd<br/>#from Github link <br/>url=”</strong><a class="ae jt" href="https://raw.githubusercontent.com/granantuin/LEVX_class/master/maestro.csv" rel="noopener ugc nofollow" target="_blank"><strong class="jz hj">https://raw.githubusercontent.com/granantuin/LEVX_class/master/maestro.csv</strong></a><strong class="jz hj">"<br/>master=pd.read_csv(url,index_col=”datetime”,parse_dates=True)</strong></span></pre><p id="8fc0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据帧的变量在文章<a class="ae jt" rel="noopener" href="/@robinat539/improving-meteorological-and-ocean-models-with-machine-learning-part-0-set-up-a-data-frame-4abd3744ec75">第0部分</a>中有解释。我们的自变量将是“visibility_o”，自变量将是由带有扩展名“_p”的模型预测的变量。因此:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4efa" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">master_f=master[[‘dir_p’, ‘lhflx_p’, ‘mod_p’, ‘prec_p’, ‘rh_p’, ‘visibility_p’,<br/> ‘mslp_p’, ‘temp_p’, ‘cape_p’, ‘cfl_p’, ‘cfm_p’, ‘cin_p’,<br/> ‘conv_prec_p’,”visibility_o”]]</strong></span></pre><p id="824e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">master_f只包含我们感兴趣的变量。我们可以使用Seaborn库绘制相关性矩阵:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="3670" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">import seaborn as sns<br/>sns.set(rc={‘figure.figsize’:(11.7,8.27)})<br/>sns.heatmap(master_f.corr(),annot=True,linewidths=.5)</strong></span></pre><p id="a1d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是:</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kj"><img src="../Images/74a0d3260747e45077a5cf64cfe5544f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4-gJJ_qU-UhSw8kCyh2_A.jpeg"/></div></div></figure><p id="8fd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">观察到的能见度和预测的能见度之间的相关性很弱。我们可以评估定义相同参数的气象模型来评估机器学习算法。预测能见度何时低于阈值至关重要。可以解决二元分类问题。我们的目标是找到能见度小于阈值的时间。首先，我们定义以下阈值:50，500，1000，5000米，并评估模型容量以预测它们。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="46a5" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">for threshold in [50,500,1000,5000]:<br/> master_f[“visibility_o_”+str(threshold)]=[True if c&lt;=threshold else False <br/> for c in master_f.visibility_o]<br/> master_f[“visibility_p_”+str(threshold)]=[True if c&lt;=threshold else False <br/> for c in master_f.visibility_p]<br/> print(“**** Confusion matrix threshold:”+str(threshold)+”m”+” ****”)<br/> print(confusion_matrix(master_f[“visibility_o_”+str(threshold)],<br/> master_f[“visibility_p_”+str(threshold)],<br/> labels=[False,True]))<br/> print(“***************”)<br/> target_names = [“&gt;”+str(threshold)+”m”,”&lt;=”+str(threshold)+”m” ]<br/> print(classification_report(master_f[“visibility_o_”+str(threshold)],<br/> master_f[“visibility_p_”+str(threshold)],<br/> target_names=target_names))</strong></span></pre><p id="ae28" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是:</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kr"><img src="../Images/08e302ac5cc7564bd0dac26e5277bde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utHLhAthAiGOjRnDUIxkug.jpeg"/></div></div></figure><p id="1499" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的数据我们可以看到不同的变量来评估气象模型的性能。例如，如果我们观察支柱支撑处的阈值500米(能见度小于500米):能见度小于500米时为3034小时，能见度大于500米时为58222小时。查看混淆矩阵，气象模型正确548次。它预测2189能见度小于500米错误。还有，有2486个小时的实际能见度低于500米的错误预报。</p><p id="0dd7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将结果绘制在ROC中，并获得AUC来评估几个阈值(可见性范围)的模型结果。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1353" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">from itertools import cycle<br/>import matplotlib.pyplot as plt<br/>from sklearn import metrics<br/>from sklearn.metrics import roc_curve, auc</strong></span><span id="b097" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">#ROC model one figure<br/>ranges=[50,500,1000,5000]<br/>fprl=[]<br/>tprl=[]<br/>thresholdsl=[]<br/>roc_aucl=[]</strong></span><span id="e627" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">for vis_range in ranges:<br/> y_data=[False if c&lt;=vis_range else True for c in master_f.visibility_o]<br/> y_pred=master_f.visibility_p<br/> fpr, tpr, thresholds = metrics.roc_curve(y_data,y_pred)<br/> roc_auc = auc(fpr, tpr)<br/> fprl.append(fpr)<br/> tprl.append(tpr)<br/> thresholdsl.append(thresholds)<br/> roc_aucl.append(roc_auc)</strong></span><span id="ac51" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">plt.figure(figsize=[12,10])<br/>n_ranges=len(ranges)<br/>colors = cycle([‘aqua’, ‘darkorange’, ‘cornflowerblue’,”red”])</strong></span><span id="87a9" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">for i, color in zip(range(n_ranges), colors):<br/> plt.plot(fprl[i], tprl[i], color=color, lw=2,<br/> label=’ROC curve of range {0} (area = {1:0.2f})’<br/> .format(ranges[i],roc_aucl[i]))</strong></span><span id="f41a" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">plt.plot([0, 1], [0, 1], color=’navy’, lw=2, linestyle=’ — ‘)<br/>plt.xlim([0.0, 1.0])<br/>plt.ylim([0.0, 1.05])<br/>plt.xlabel(‘False Positive Rate’)<br/>plt.ylabel(‘True Positive Rate’)<br/>plt.title(“ROC range:”)<br/>plt.legend(loc=”lower right”)<br/>plt.show()</strong></span></pre><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kt"><img src="../Images/34cec3ea71f6656e7bc7db91b7854354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Ugyu9DqgbSbx3eUnvYd3w.png"/></div></div></figure><p id="8bc5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以建立一个神经网络来增强结果。我们定义因变量和自变量。观察到的因变量可见度和自变量，模型预测的变量。让我们开始吧:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5bdf" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">threshold1=500<br/>y_data=pd.DataFrame({“datetime”:master_f.index,<br/> “visibility_o”:[1 if c&lt;=threshold1 else 0 for c in <br/> master_f[“visibility_o”]]}).set_index(“datetime”)</strong></span><span id="14c6" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">x_data=master_f[[‘dir_p’, ‘lhflx_p’, ‘mod_p’, ‘prec_p’, ‘rh_p’, ‘visibility_p’,<br/> ‘mslp_p’, ‘temp_p’, ‘cape_p’, ‘cfl_p’, ‘cfm_p’, ‘cin_p’,<br/> ‘conv_prec_p’]]</strong></span></pre><p id="ef98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们建立一个神经网络并显示结果:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="8197" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">import numpy as np<br/>#neural network<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import confusion_matrix ,classification_report <br/>from sklearn.model_selection import cross_val_score,cross_validate<br/>import tensorflow as tf<br/>from tensorflow.keras import optimizers<br/>from tensorflow.keras.models import Model, load_model, Sequential<br/>from tensorflow.keras.layers import Input, Dense, Dropout, AlphaDropout<br/>from tensorflow.keras.callbacks import ModelCheckpoint, TensorBoard<br/>from sklearn.preprocessing import StandardScaler, MinMaxScaler, RobustScaler</strong></span><span id="a2c1" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">scaler = MinMaxScaler()</strong></span><span id="7c7f" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">#transform x_data or pca_vectors<br/>scaled_df = scaler.fit_transform(x_data)</strong></span><span id="8bd1" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">x_train, x_test, y_train, y_test = train_test_split(scaled_df,y_data.visibility_o, test_size=0.2,)</strong></span><span id="972b" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">class_weight = {0: (sum(y_train == 1)/len(y_train)), 1: (sum(y_train == 0)/len(y_train))}</strong></span><span id="0a57" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">mlp = Sequential()<br/>mlp.add(Input(shape=(x_train.shape[1], )))<br/>mlp.add(Dense(24, activation=’relu’))<br/>mlp.add(Dropout(0.5))<br/>mlp.add(Dense(24, activation=’relu’))<br/>mlp.add(Dropout(0.5))<br/>mlp.add(Dense(1, activation=’sigmoid’))<br/>mlp.summary()<br/>mlp.compile(optimizer=tf.keras.optimizers.Adam(lr=0.0001),<br/> loss=’binary_crossentropy’,<br/> metrics=[‘accuracy’,tf.keras.metrics.Recall()]<br/> )</strong></span><span id="e48d" class="kd ke hi jz b fi ks kg l kh ki"><strong class="jz hj">history = mlp.fit(x=x_train,<br/> y=y_train,<br/> batch_size=128,<br/> epochs=50,<br/> validation_data=(x_test, y_test),<br/> class_weight=class_weight,<br/> verbose=1).history<br/>pd.DataFrame(history).plot(grid=True,figsize=(12,12),yticks=np.linspace(0.0, 1.0, num=11))<br/>y_pred=mlp.predict(x_test)</strong></span></pre><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ku"><img src="../Images/dcb8cd550a02601799c3a467eeed1dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tr3gUzSENCzwHsobqk6wRw.png"/></div></div></figure><p id="f897" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看来神经网络表现良好。验证损失在下降，验证召回在上升。现在我们要绘制两个箱线图。一个描述了当y测试是一个意味着能见度低于阈值(在我们的例子中是500米)时由神经网络获得的值。另一个表示y检验为零(能见度大于500米)时神经网络得到的值。理想的结果应该是，在第一种情况下，神经网络预测的高值接近1，而在第二种情况下，值接近0。代码是:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="bc9e" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">result=pd.DataFrame({“y_test”:y_test.values,”y_pred”:y_pred.reshape(1,-1)[0],<br/> “datatime”:y_test.index}).set_index(“datatime”)<br/>pd.DataFrame({“y_pred test==1”:result[“y_pred”][result.y_test==1],<br/> “y_pred test==0”:result[“y_pred”][result.y_test==0]}).plot(kind=”box”)</strong></span></pre><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kv"><img src="../Images/202227be64051230c4037065b6be13be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-YsarmPd9_kaQVJQqgFIA.jpeg"/></div></div></figure><p id="a53a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在寻找一个区分1和0的阈值。根据上图的指示，我选择0.55。如果神经网络预测值小于0.55，则意味着能见度大于500米，反之亦然。代码:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2f42" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">#select threhold_nor<br/>threshold_nor=0.55<br/>y_pred_nor =[0 if c&lt;=threshold_nor else 1 for c in result.y_pred]<br/>target_names = [“&gt;”+str(threshold1)+”m”,”&lt;=”+str(threshold1)+”m” ]<br/>print(classification_report(y_test.values,y_pred_nor , target_names=target_names)<br/>print(“**** Confusion matrix ****”)<br/>print(confusion_matrix(y_test,y_pred_nor))</strong></span></pre><p id="1de1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到:</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kr"><img src="../Images/f1ebc9e1b72a6bf29e019bd4d3a837b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jp7IjY_6QmjOBWrkzmqaBw.jpeg"/></div></div></figure><p id="a77a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">似乎参数比气象模型略好。最后，我们绘制ROC曲线并计算曲线下面积(AUC):</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a43f" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">#ROC model <br/>fpr, tpr, thresholds = metrics.roc_curve(y_test,y_pred)<br/>roc_auc = auc(fpr, tpr)<br/>plt.figure()<br/>lw = 2<br/>plt.plot(fpr, tpr, color=’darkorange’,<br/> lw=lw, label=’ROC curve (area = %0.2f)’ % roc_auc)<br/>plt.plot([0, 1], [0, 1], color=’navy’, lw=lw, linestyle=’ — ‘)<br/>plt.xlim([0.0, 1.0])<br/>plt.ylim([0.0, 1.05])<br/>plt.xlabel(‘False Positive Rate’)<br/>plt.ylabel(‘True Positive Rate’)<br/>plt.title(“ROC “)<br/>plt.legend(loc=”lower right”)<br/>plt.show()</strong></span></pre><p id="15d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并获得:</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kw"><img src="../Images/b1025b9e39db92ed0b9a149ff57c6add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9phCh8ie_2GN2L_zBvWQOw.png"/></div></div></figure><h2 id="386a" class="kd ke hi bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">结论</h2><p id="f8e0" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">也许是用深度学习算法改进气象模型的一步…</p><p id="e8e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>