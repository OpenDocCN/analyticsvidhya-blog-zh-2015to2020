<html>
<head>
<title>Real Time Object Detection using YOLOv3 with OpenCV and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OpenCV和Python的YOLOv3实时物体检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/real-time-object-detection-using-yolov3-with-opencv-and-python-64c985e14786?source=collection_archive---------1-----------------------#2019-11-08">https://medium.com/analytics-vidhya/real-time-object-detection-using-yolov3-with-opencv-and-python-64c985e14786?source=collection_archive---------1-----------------------#2019-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2d98134157621c3420d54e46ba790580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OXEjbPrOg6HLuh7MoeEwg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">实时物体检测:使用yolov3检测雨伞、人、汽车、摩托车</figcaption></figure><p id="7a15" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在之前的<a class="ae js" rel="noopener" href="/@darshanadakane/object-detection-with-opencv-python-using-yolov3-481f02c6aa35">文章</a>中，我们已经看到了使用YOLOv3算法对图像进行物体检测。在本文中，让我们更进一步，看看我们如何使用YOLOv3进行实时对象检测。</p><p id="739a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以用两种方法解决这个问题。一个是用CPU，一个是用GPU。</p><p id="4452" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CPU的优点是我们不需要安装任何额外的资源，安装。我们可以马上使用OpenCV来做这件事。但缺点是它非常慢(这取决于什么配置的CPU你正在运行，但是的，它很慢)。推荐给初学者。</p><p id="2fbd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一方面，GPU具有视频图形处理器的优势，因此速度更快。但缺点是我们需要手动编译许多库，并在开始利用我们的问题定义之前配置许多东西。</p><p id="9b48" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们继续这个教程来使用CPU进行实时物体检测。在上一个教程中，我们使用的是单幅图像，而现在我们将使用OpenCV中的一系列图像(即视频)作为输入。</p><p id="9e41" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在加载图像之前，我们将重述代码。我们导入cv2，numpy库。然后我们在<strong class="iw hj">网</strong>中加载暗网架构，在<strong class="iw hj">类</strong>中存储来自<strong class="iw hj"> coco.names </strong>文件的所有不同对象。并从<strong class="iw hj">网</strong>中获取最后一层，以识别最后一层中的对象。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/d8c92264f1130acef973bd3c28933af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ou3atfmZpL61ak_DdI0fIA.png"/></div></div></figure><p id="186e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们从网络摄像头加载捕获视频。因此我们使用<strong class="iw hj"> cv2。视频捕捉(0) </strong>。这里0表示它来自第一个网络摄像头。同样，为了检测我们每秒处理多少帧，我们将导入<strong class="iw hj"> time </strong>库。我们使用<strong class="iw hj"> frame_id </strong>来计算帧数。为了得到经过的时间，我们从<strong class="iw hj"> time.now中减去<strong class="iw hj">starting . time</strong>。</strong>我们已经将<strong class="iw hj">字体</strong>定义为HERSHEY_PLAIN</p><p id="4078" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们加载while循环中运行的视频的所有帧，并使用<strong class="iw hj"> cap.read </strong>存储每个帧，并执行我们在上一篇文章中对每个图像所做的操作。在<strong class="iw hj">高度、宽度、通道中存储每帧的详细信息。为了更快地处理图像，我们将把斑点尺寸从416x416减小到320x320。这种变化会使精确度降低一点。另一方面，如果我们增加608x608，它将准确，但在检测非常缓慢。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/f7a9e10836149b46a3835e3080e8b430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1o7upLS4AyRqUags9n9vg.png"/></div></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/4d3cbe9468c056a1fd4d6cec622fadff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQ_5Ob8iRyDWnwJ3P6kWjQ.png"/></div></div></figure><p id="2ee6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码中，<strong class="iw hj"> fps </strong>是我们用帧数除以运行时间计算的每秒帧数。我们将把这个值作为文本放在检测到的对象上。最后，我们使用了<strong class="iw hj">键</strong> =27(键盘上的Esc键)，如果按下该键，将会中断循环并停止执行。</p><p id="9689" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我想分享的最后一件事是关于自信。请记住，我们使用的是阈值0.5，如果我们提高阈值，这意味着我们将获得更高的检测精度，但目标数量会减少，反之亦然。我们也在box上展示了这个置信度值。</p><p id="cf8d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">测试视频从网络摄像头检测到以下物体:雨伞，汽车，人和摩托车。点击<a class="ae js" href="https://github.com/darshanadakane/yolov3_realTimeObjectDetection" rel="noopener ugc nofollow" target="_blank">这里</a>查看输出文件(文件名为<a class="ae js" href="https://github.com/darshanadakane/yolov3_realTimeObjectDetection/blob/master/Webcam_ObjectDetection.MOV" rel="noopener ugc nofollow" target="_blank">网络摄像头_对象检测。MOV </a></p><p id="b78e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了加速检测过程，除了减小斑点图像尺寸之外，还有另一种方法。方法是使用微型YOLO。在这里，我们将传递一个不同的权重和cfg文件。它将比原始的yolov3 cfg文件具有更少的卷积层数。要使用它，只需如下替换代码中的文件名，其余代码保持不变。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/4d74b19b86269e857a9de9051d08686c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A43povoLKLZdpcmZfZRhew.png"/></div></div></figure><p id="1f8d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以在以下位置找到这些文件:</p><p id="a93f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">yolov3-tiny.weights:从<a class="ae js" href="https://github.com/pjreddie/darknet/tree/master/cfg" rel="noopener ugc nofollow" target="_blank">这里</a>下载</p><p id="4375" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">yolov3-tiny.cfg:从<a class="ae js" href="https://github.com/pjreddie/darknet/tree/master/cfg" rel="noopener ugc nofollow" target="_blank">这里</a>下载</p><p id="4111" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，如果你正在处理低配置的CPU，tiny yolo是最好的选择。但是现在，随着最新的笔记本电脑计算能力的增加(有些还支持GPU)，我会推荐直接使用普通的yolov3。</p><p id="9f20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望这将有助于实现yolov3实时对象检测算法。我试图让初学者的心态可以理解。如果您有任何问题或意见，请告诉我。</p><p id="6436" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">回旋石！</p><p id="84e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">快乐学习！</p><p id="4043" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">【你可以在<a class="ae js" href="https://github.com/darshanadakane/yolov3_realTimeObjectDetection" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到完整的代码。喜欢就明星。谢谢]</p></div></div>    
</body>
</html>