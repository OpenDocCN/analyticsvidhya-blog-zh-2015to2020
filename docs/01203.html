<html>
<head>
<title>HTTP Interceptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP拦截器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/angular8-http-interceptors-e8dcab7339cb?source=collection_archive---------8-----------------------#2019-10-08">https://medium.com/analytics-vidhya/angular8-http-interceptors-e8dcab7339cb?source=collection_archive---------8-----------------------#2019-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7306" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将简要讨论有角度的http拦截器。在深入研究http拦截器之前，让我们先了解一下Angular上下文中的拦截器是什么。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/997091274d1f0782634138f82f9ac95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLB6EHQOLmO-KTaZlMrjMA.jpeg"/></div></div></figure><h1 id="d74a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">拦截器:</h1><p id="ec6e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">正如名字<strong class="ih hj"> interceptor </strong>所暗示的，Angular中的interceptor是一种机制，用于拦截传入或传出的http请求，在将请求/响应传递给下一个处理程序之前全局修改请求/响应。通过拦截器，我们可以在请求到达外部api之前对其进行编辑。拦截器在Angular上下文中最常见的用途是，它们使我们能够向请求添加额外的头，如身份验证令牌，以便请求在服务器端获得授权。此外，我们可以在一个地方处理由于http请求而产生的错误。在本文中，我们将看到如何利用拦截器的能力来发送JSON Web令牌和请求。但是拦截器的效用并不仅限于发送认证令牌。</p><p id="5164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了学习拦截器，我们需要设置一个Angular应用程序，我不会详细介绍。让我们直接进入代码。</p><p id="4bbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从认证服务开始。由于我们只处理拦截器，我们将硬编码JWT令牌，并假设用户已经登录。用户登录后，我们将把JWT令牌存储在localstorage中，并在需要时从localstorage中检索令牌。</p><p id="829e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">authentic ation . service . ts</strong></p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="a8a0" class="kx jq hi kt b fi ky kz l la lb">import { Injectable } from '<a class="ae lc" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import {HttpClient } from '<a class="ae lc" href="http://twitter.com/angular/common" rel="noopener ugc nofollow" target="_blank">@angular/common</a>/http';</span><span id="0ce8" class="kx jq hi kt b fi ld kz l la lb">interface IUser {<br/>  username: string;<br/>  password: string;<br/>};</span><span id="fd87" class="kx jq hi kt b fi ld kz l la lb"><a class="ae lc" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>({<br/>  providedIn: 'root'<br/>})</span><span id="75f0" class="kx jq hi kt b fi ld kz l la lb">export class AuthenticationService {</span><span id="105f" class="kx jq hi kt b fi ld kz l la lb">constructor(private http: HttpClient) { }</span><span id="1a0e" class="kx jq hi kt b fi ld kz l la lb">user: IUser = {<br/>    username: 'test',<br/>    password: 'test',<br/>  };<br/>  authToken : string = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJtYXZlbmlyIiwiZXhwIjoxNTY5ODUwNTQ1LCJ<br/>  pc3MiOiJtZGUtc2VydmVyIiwiYXVkIjoibWRlLXBvcnRhbCJ9.viLdfqeUQ83-F8AjLfpXyQUFIMwyhB5yM9vHXRYhVKYuFwTszW1e7_wJ2DumVbIZUVKhqggRBPEMjSJmxSWQGQ';<br/>  url: string = '<a class="ae lc" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts'</a>;<br/>  someOtherUrl: string = '<a class="ae lc" href="https://jsonplaceholder.typicode.com/posts/1/comments'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts/1/comments'</a>;<br/>  <br/>  login() {<br/>    this.http.post(this.url, this.user)<br/>    .subscribe((response: any) =&gt; {<br/>      localStorage.setItem('jwtToken', this.authToken);<br/>    })<br/>   }</span><span id="b725" class="kx jq hi kt b fi ld kz l la lb">getToken(): string {<br/>     return localStorage.getItem('jwtToken');<br/>   }</span><span id="17d9" class="kx jq hi kt b fi ld kz l la lb">someOtherRestApiCall () {<br/>    this.http.get(this.someOtherUrl)<br/>    .subscribe((response) =&gt; {<br/>      console.log(response);<br/>    })<br/>   }<br/>}</span></pre><p id="4514" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们在认证服务中有一个方法someOtherRestApiCall()来对一些虚拟url进行REST api调用。</p><p id="1075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的认证服务已经完成了，让我们来看一下拦截器文件。为此，我们将创建一个名为httpinterceptor.service.ts的新文件，并将以下内容写入其中。</p><p id="9aa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">http interceptor . service . ts</strong></p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="8c57" class="kx jq hi kt b fi ky kz l la lb">import { Injectable } from '<a class="ae lc" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '<a class="ae lc" href="http://twitter.com/angular/common" rel="noopener ugc nofollow" target="_blank">@angular/common</a>/http';<br/>import { AuthenticationService } from './authentication.service';<br/>import { Observable } from 'rxjs';</span><span id="fe55" class="kx jq hi kt b fi ld kz l la lb"><a class="ae lc" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>({<br/>  providedIn: 'root'<br/>})<br/>export class HttpinterceptorService implements HttpInterceptor{</span><span id="e4dd" class="kx jq hi kt b fi ld kz l la lb">constructor(public auth: AuthenticationService) {}<br/>  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {<br/>    <br/>    request = request.clone({<br/>      setHeaders: {<br/>        Authorization: `Bearer ${this.auth.getToken()}`<br/>      }<br/>    });<br/>    return next.handle(request);<br/>  }<br/>}</span></pre><p id="eb05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它看起来像一个简单的角度服务，但是这里有几件重要的事情。我们可以看到，HttpInterceptorService类实现了从@angular/common/http包导入的HttpInterceptor。该服务注入了我们之前创建的身份验证服务。该服务有一个名为intercept的方法，它有两个参数request和next。<strong class="ih hj">请求</strong>参数是我们要发送给服务器的请求对象。<strong class="ih hj"> next </strong>是一个http处理程序，一旦我们完成了这个特定的拦截器，它将负责下一个进程。在intercept方法中，我们简单地克隆了请求对象，并为out REST api调用设置了头。我们还通过使用getToken()方法从身份验证服务中检索JWT令牌。我们使用ES6字符串插值来设置承载令牌。</p><p id="9733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是时候在app模块中注册http拦截器了。所以我们的app.module.ts文件应该如下所示。</p><p id="d98d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">应用模块ts </strong></p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="79db" class="kx jq hi kt b fi ky kz l la lb">import { BrowserModule } from '<a class="ae lc" href="http://twitter.com/angular/platform-browser" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser</a>';<br/>import { NgModule } from '<a class="ae lc" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';</span><span id="2c3a" class="kx jq hi kt b fi ld kz l la lb">import { AppRoutingModule } from './app-routing.module';<br/>import { AppComponent } from './app.component';<br/>import { HttpClientModule, HTTP_INTERCEPTORS } from '<a class="ae lc" href="http://twitter.com/angular/common" rel="noopener ugc nofollow" target="_blank">@angular/common</a>/http';<br/>import { HttpinterceptorService } from './services/httpinterceptor.service';</span><span id="0352" class="kx jq hi kt b fi ld kz l la lb"><a class="ae lc" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>  declarations: [<br/>    AppComponent,<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    AppRoutingModule,<br/>    HttpClientModule<br/>  ],<br/>  providers: [<br/>    {<br/>      provide: HTTP_INTERCEPTORS,<br/>      useClass: HttpinterceptorService,<br/>      multi: true<br/>    }<br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</span></pre><p id="0248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，大部分繁重的工作已经完成，我们只需要设置应用程序组件，其中我们将有一个简单的按钮，它将调用一个方法并进行api调用。因此，app.component.html文件将像下面这样简单。</p><p id="0f31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">app.component.html<strong class="ih hj"/></p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="989a" class="kx jq hi kt b fi ky kz l la lb">&lt;button (click) = 'someApiCall()'&gt;Some other API call&lt;/button&gt;</span></pre><p id="7000" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，对于app.component.ts文件，我们编写以下内容。</p><p id="b958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">应用组件</strong></p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="ec69" class="kx jq hi kt b fi ky kz l la lb">import { Component } from '<a class="ae lc" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { AuthenticationService } from './services/authentication.service';</span><span id="1ef4" class="kx jq hi kt b fi ld kz l la lb"><a class="ae lc" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.css']<br/>})<br/>export class AppComponent {<br/>  title = 'testapp';</span><span id="c2b1" class="kx jq hi kt b fi ld kz l la lb">constructor(private auth: AuthenticationService) {}</span><span id="470d" class="kx jq hi kt b fi ld kz l la lb">ngOnInit() {<br/>    this.auth.login();<br/>  }</span><span id="01d9" class="kx jq hi kt b fi ld kz l la lb">someApiCall() {<br/>    this.auth.someOtherRestApiCall();<br/>  }<br/>}</span></pre><p id="9387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，完成所有这些工作后，是时候看看结果了。当点击按钮时，我们可以看到下面的结果。我们可以清楚地看到，承载令牌被附加到http请求上。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/dfc5980e5e1478d4e58f309af96a4abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu8T-KxdFtOtWv-AblKiFQ.png"/></div></div></figure><p id="1687" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是萨特雅普里雅·米什拉。在这里可以联系到我。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="1769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm">原载于2019年10月8日</em><a class="ae lc" href="http://blog.imsatya.com/angular8-http-interceptors/" rel="noopener ugc nofollow" target="_blank"><em class="lm">http://blog.imsatya.com</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>