<html>
<head>
<title>A simple face verification system using Keras and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Keras和OpenCV的简单人脸验证系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-simple-face-verification-system-using-keras-and-opencv-894495bcf202?source=collection_archive---------4-----------------------#2019-12-22">https://medium.com/analytics-vidhya/a-simple-face-verification-system-using-keras-and-opencv-894495bcf202?source=collection_archive---------4-----------------------#2019-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5982912e44838372ac14399f5ac73a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ISgYk8CDXDm8_kWI.jpeg"/></div></div></figure><p id="ae3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你肯定遇到过“人脸验证”这个术语，或者可能遇到过使用这种新技术的系统。但是，有没有想过在这些奇妙的系统里发生了什么？好吧，让我来谈谈这个想法。</p><p id="ba41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你一定见过生物计量系统，它捕捉人们的照片，并试图确定他们是否属于预先定义的一组人。这样一个系统所做的是试图找到一个匹配的人，他的脸被捕获，和一个人已经存在于它的数据库中作为一个授权用户。</p><h2 id="4e0a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">什么是人脸验证？</strong></h2><p id="f1ab" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">它可以被认为是一个分类问题，其中使用匹配分数来验证人的身份。因此，如果两幅图像是同一个人的，则它们应该具有高匹配分数，如果两幅图像是两个不同的人的，则匹配应该较低。</p><p id="0a73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能想到的第一件事是，为什么不将捕捉到的图片与另一张图片<strong class="is hj">逐像素匹配</strong>？如果捕获图像的像素值和另一个图像的像素值之间的距离(均方或绝对)很小，则它们一定对应于同一个人。但是由于即使光线、位置或方向有微小的变化，图像中的像素值也会发生显著的变化，所以这种方法可能不会，事实上也不会很好地工作。</p><p id="9f01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我们现在做什么？这就是卷积神经网络，更好地称为CNN，帮助我们的地方。这种网络可以帮助我们通过将每个图像嵌入到d维向量空间中来更好地表示图像。然后评估图像嵌入的相似性。</p><h2 id="6161" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">解决这个问题的一些方法</h2><ol class=""><li id="c47a" class="ko kp hi is b it kj ix kk jb kq jf kr jj ks jn kt ku kv kw bi translated"><strong class="is hj">样本支持向量机:</strong>这里的想法是为训练集中的每个样本训练一个线性<a class="ae kx" rel="noopener" href="/machine-learning-101/chapter-2-svm-support-vector-machine-theory-f0812effc72"> SVM分类器</a>，这样在每种情况下，我们都以一个正面实例和许多负面实例结束。要了解更多关于样本支持向量机的信息，请参考<a class="ae kx" href="https://www.cs.cmu.edu/~tmalisie/projects/iccv11/" rel="noopener ugc nofollow" target="_blank">本</a>。</li><li id="4320" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is hj"> DeepID: </strong>在这里，验证的任务被认为是人脸识别的子问题(给每个人分配一个标签)。这是基于这样的想法，即训练一个神经网络来解决更困难的识别问题，原则上可以给出非常好的验证描述符。据观察，这是为了学习考虑人脸的多个视图的特征变换。要了解更多关于DeepID的信息，请参考<a class="ae kx" href="http://mmlab.ie.cuhk.edu.hk/pdf/YiSun_CVPR14.pdf" rel="noopener ugc nofollow" target="_blank">本</a>。</li><li id="e976" class="ko kp hi is b it ky ix kz jb la jf lb jj lc jn kt ku kv kw bi translated"><strong class="is hj">暹罗网:</strong>这是基于个人内部距离应该比人际距离小很多的想法。这就是我们在这里详细讨论的方法。</li></ol><p id="4167" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在深入研究连体网络之前，让我们首先讨论一个非常重要的概念，连体网络是基于。这就是一次性学习。</p><p id="bb98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一次性学习</strong>是一个对象分类问题，主要出现在计算机视觉中，它试图从一个或几个训练样本中学习关于对象类别的信息。通常，在深度学习中，我们需要大量的数据，并且我们可以访问的数据越多越好。但在人脸验证的情况下，在学习实际开始之前，不太可能获得一个人的数千张图像。其次，我们的大脑不需要成千上万张一个人的照片来识别他/她。因此，使用大脑建模的深度学习和神经网络也应该不需要大量的例子来完成任务。</p><p id="bc7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于人脸验证任务，我们期望系统能够从单张/几张图像中判断一个人的身份。</p><p id="52d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我前面提到的，CNN有助于图像的矢量化表示。但是CNN确实需要大量的例子来训练。此外，每次在数据库中添加一个新人的图像时训练一个模型是不方便的。那么，为什么不建立一个模型来学习两个不同的人之间的距离，同时相似地表现同一个人的两个图像。这正是暹罗网络所做的。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/f75abed9fb253a02bb1161698a97333f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i-6rpif-W898_ykS.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">图片来源:<a class="ae kx" href="https://www.youtube.com/watch?v=6jfw8MuKwpI" rel="noopener ugc nofollow" target="_blank">deep learning . ai的卷积神经网络</a></figcaption></figure><p id="ae22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图像x(1)被馈送到CNN，由<a class="ae kx" href="https://machinelearningmastery.com/convolutional-layers-for-deep-learning-neural-networks/" rel="noopener ugc nofollow" target="_blank">卷积层</a>和<a class="ae kx" href="https://leonardoaraujosantos.gitbooks.io/artificial-inteligence/fc_layer.html" rel="noopener ugc nofollow" target="_blank">全连接层</a>组成。卷积层提供了一个有意义的、低维的、稍微不变的特征空间，而附加到卷积层的全连接层在该空间中学习一个函数(主要是非线性的)。我们最终得到的是一个特征向量(没有softmax激活被添加到特征向量，因为它在这个阶段不会被用于分类)。图像x(2)被传送到与上图完全相同的CNN。在我们的例子中，我们有第三个图像x(3)提供给同一个CNN。</p><p id="39f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们选择x(1)作为我的锚点图像，x(2)作为我的正面图像，x(3)作为负面图像。锚和正图像属于同一个人，而负图像是其他人的。因此，我们的目标将是最小化正图像和锚之间的距离，同时最大化锚和负图像之间的距离。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/6070160073ccfbbfdc5a34d47df91d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tEGR3o3hkLZfdHgD.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">d是距离函数，a的平方<a class="ae kx" href="http://mathworld.wolfram.com/L2-Norm.html" rel="noopener ugc nofollow" target="_blank"> L2范数</a>。</figcaption></figure><p id="9d1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目标可以写成:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/e37e65957c2b7ae6b4c8860f7d5f54f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*H-LIeaxWwTSX3Xo9iAocHg.png"/></div></figure><p id="f875" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这有可能为正图像和负图像学习相同的(或几乎相同的)编码，这确实可以满足上面的等式。这就是为什么我们需要增加一个小的margin alpha(一个超参数)来保证d(x(1)，x(2))和d(x(1)，x(3))之间总有一些空隙。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/9ded17c445782fd87478baa247c7fe82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5xbgGw1iTgRWvT_l.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">对方程式所做的修改。这里A=x(1)，P=x(2)，N=x(3)</figcaption></figure><p id="8ce3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们如何把它框定为损失函数。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/d9bb688c457483b262a9d5166f3d25cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c8ToRWjPMH7qhmDO.png"/></div></div></figure><p id="9475" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是所谓的<a class="ae kx" href="https://en.wikipedia.org/wiki/Triplet_loss" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">三重态损失函数</strong> </a>。如我们所见，这个损失函数确保max函数中的第一项不超过0，否则会导致误差。</p><p id="4d9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们深入研究了很多理论。</p><p id="8346" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看期待已久的代码。</p><h1 id="696d" class="lq jp hi bd jq lr ls lt ju lu lv lw jy lx ly lz kb ma mb mc ke md me mf kh mg bi translated">代码</h1><h2 id="c37f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">创建数据</h2><p id="c34d" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这是创建数据集的代码。它使用一个预先训练好的分类器，称为<a class="ae kx" href="https://docs.opencv.org/trunk/db/d28/tutorial_cascade_classifier.html" rel="noopener ugc nofollow" target="_blank">哈尔正面人脸分类器</a>，以级联方式识别人脸。下面的代码存储了使用网络摄像头拍摄的20张人脸图像，并将其存储在文件夹&lt; username &gt;中。此类文件夹存储在<em class="mh">数据集</em>文件夹中。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">文件的链接可以在<a class="ae kx" href="https://github.com/Debapriya-Tula/Face-Verification/blob/master/create_data.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到</figcaption></figure><h2 id="7f54" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">创建模型并对其进行训练</h2><p id="13a8" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在创建数据集时，您可以看到我已经用一些值填充了现有的图像(这里宽度方向为22，高度方向为12)。这是因为我使用了在ImageNet数据集上预训练的VGG16模型，该数据集期望输入图像具有维度(224，224，3)，并且我使用的数据集对于每个图像具有维度(200，180，3)。</p><p id="3ffc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">三元组被形成并存储在<em class="mh">三元组</em>列表中(在下面附加的代码中)。对于每个人(由数据集<em class="mh">文件夹</em>中的文件夹标识的人)，我们存储5个三元组(A，P，N)。然后在模型上对它们进行训练，该模型本身由三个VGG16模型组成，通过实现三重损失函数的Lambda层连接。</p><p id="c06b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码非常直观，易于理解。</p><blockquote class="mk ml mm"><p id="1bab" class="iq ir mh is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">为了训练由大约420，000，000个参数组成的模型，使用了英特尔的dev cloud<strong class="is hj">I</strong><a class="ae kx" href="https://software.intel.com/en-us/devcloud" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">，它为您提供了<strong class="is hj"> 200 GBs </strong>的存储和<strong class="is hj"> RAM </strong>的高达<strong class="is hj"> 92 GBs </strong>。其次，针对Tensorflow、Pytorch、Caffe等框架进行优化。我花了大约3-4个小时来训练我的网络，然后我将它存储在“model.h5”中。</strong></a></p></blockquote><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">该文件的链接可以在<a class="ae kx" href="https://github.com/Debapriya-Tula/Face-Verification/blob/master/Siamese_train_store.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到</figcaption></figure><h2 id="cc94" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">使用模型进行验证</h2><p id="5f9b" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated"><em class="mh"> detect_face </em>功能接收图像，<em class="mh"> img </em>(使用网络摄像头捕捉的人物图像)找到人脸并将其裁剪出来。用户还在验证他/她的面部时输入用户名。然后，现在裁剪的面被验证如下:</p><p id="1340" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a)我们在我们的<em class="mh">数据集</em>文件夹中找到名为<username>的文件夹。我们从该文件夹中选择一幅图像。</username></p><p id="1cc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b)我们随机选择其他三个文件夹，并从每个文件夹中选择一张图片。这些将作为负像。</p><p id="4cf6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">c)我们找到每个图像的编码，一个由<em class="mh"> detect_face </em>返回，一个从步骤a)找到，三个从步骤b)找到。</p><p id="4a2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">d)我们发现从步骤a)和b)获得的每个图像的编码的均方误差与由<em class="mh"> detect_face </em>返回的图像的均方误差。</p><p id="0b9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">e)如果从步骤b)获得的任何图像具有比从步骤a)获得的图像更小的误差，则我们说该人被授权，否则不被授权。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">文件的链接可以在这里找到<a class="ae kx" href="https://github.com/Debapriya-Tula/Face-Verification/blob/master/detect_and_verify.py" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="f035" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们如何实现一个简单的人脸识别工具。上述实现的代码可以在这里找到。</p><div class="mq mr ez fb ms mt"><a href="https://github.com/Debapriya-Tula/Face-Verification" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">德巴普里亚-图拉/面部验证</h2><div class="na l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng io mt"/></div></div></a></div><p id="a0cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博文是英特尔学生大使竞赛的一部分。</p><h2 id="726b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">参考资料:</h2><div class="mq mr ez fb ms mt"><a href="https://www.coursera.org/learn/convolutional-neural-networks/lecture/gjckG/one-shot-learning" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">一次性学习-特殊应用:人脸识别和神经类型转移</h2><div class="nh l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">deeplearning.ai为课程“卷积神经网络”创建的视频。了解CNN如何应用于…</h3></div><div class="na l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">www.coursera.org</p></div></div><div class="nb l"><div class="ni l nd ne nf nb ng io mt"/></div></div></a></div><div class="mq mr ez fb ms mt"><a href="https://arxiv.org/abs/1503.03832" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">FaceNet:人脸识别和聚类的统一嵌入</h2><div class="nh l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">尽管最近在人脸识别领域取得了重大进展，但实现人脸验证和识别…</h3></div><div class="na l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">arxiv.org</p></div></div></div></a></div><div class="mq mr ez fb ms mt"><a href="https://joaoloula.github.io/face-verification.html" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">DeepID</h2><div class="nh l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">假设我们想实现一个生物识别系统，在这个系统中，给定一张…</h3></div><div class="na l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">Joao Lula . github . io</p></div></div><div class="nb l"><div class="nj l nd ne nf nb ng io mt"/></div></div></a></div><div class="mq mr ez fb ms mt"><a rel="noopener follow" target="_blank" href="/datadriveninvestor/face-recognition-929464856b86"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">人脸识别:学习从零开始创建人脸识别系统</h2><div class="nh l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">人工智能正在彻底改变世界。人脸识别就是其中之一。让我们了解一下这些系统是如何学习的…</h3></div><div class="na l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="nk l nd ne nf nb ng io mt"/></div></div></a></div></div></div>    
</body>
</html>