<html>
<head>
<title>GitHub Actions: An Introduction to CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub Actions:CI简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/github-actions-an-introduction-to-ci-819040f2a087?source=collection_archive---------6-----------------------#2020-01-23">https://medium.com/analytics-vidhya/github-actions-an-introduction-to-ci-819040f2a087?source=collection_archive---------6-----------------------#2020-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="db45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据<a class="ae jd" href="https://creativecommons.org/licenses/by-sa/4.0/" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 4.0许可证</a>获得许可</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/963322675597285be2c5076fa51d070d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ukfzSBNkdmPEFMov"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">在CC0许可下，Pixabay在<a class="ae jd" href="https://www.pexels.com/photo/mirror-lake-reflecting-wooden-house-in-middle-of-lake-overlooking-mountain-ranges-147411/" rel="noopener ugc nofollow" target="_blank">像素</a>上的封面图片</figcaption></figure><p id="22f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ju">注意:</em> </strong> <em class="ju">我将在我从第三方来源引用的一些文本后使用方括号(例如[1])。这些资源的链接在最后。</em></p><h1 id="4574" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">CI？那是什么？</h1><p id="2048" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">CI代表持续集成，不，这不是微积分1，持续集成是指将一个开发团队所做的工作集成或合并到主要的源代码或主线或主干中。[1]基本上，它是一个工具，在开源项目的情况下，它允许一组开发人员或贡献者在相同的代码基础上同时工作和协作。一些CI服务——比如GitHub——甚至为项目的维护者提供工具，让他们接受这些变更，提出改进代码的建议，甚至完全拒绝变更。它本质上允许一个大型团队在同一个项目上协作。</p><p id="a8b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数CI服务需要用户制作代码基础或主线的本地副本，独立工作，并将他们的更改作为建议提交给代码主线。这些建议然后由同事或主管审查，他们或者接受，或者拒绝，或者建议对已更改的代码进行更改。随着审查变更过程的进行，一些变更被接受到主线代码中，开发人员的本地副本慢慢地不再反映实际的主线，这需要开发人员刷新本地副本。不更新本地副本通常会导致冲突，希望维护人员和开发人员能够解决这个问题。</p><p id="4196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博文中，我们将从GitHub和GitHub Actions的角度分析CI/CD的一些优点和缺点，以及在Julia开发中使用CI/CD的方法。</p><h1 id="f872" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">CD是什么？</h1><p id="77d8" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">CD是CI最好的朋友；这两者通常是成对的，并且一起使用来指代软件开发的增量式风格。</p><p id="f1d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用缩写CD实际上引入了一点模糊性；CD可以代表持续交付和持续部署。它们听起来可能一样，但它们之间有细微的差别。首先，我们将讨论它们的共同点。持续部署和持续交付都是在小而短的周期内生产软件，并对代码库进行增量更改，如添加功能、修复bug和改善用户体验，而不是每年左右发布一个与前任完全不同的重大返工产品。</p><p id="1616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两者指的是快速开发(不要与敏捷混淆)，测试和部署周期通常持续几个月。一些著名的项目如Windows 10[2]，Linux发行版(如Arch Linux，Gentoo Linux等。[3])，大多数开源包都使用这种形式的开发。</p><p id="8561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，连续部署和连续交付之间的主要区别在于，连续部署在发布更新之前使用自动化系统来构建、部署和测试软件，而在连续交付中同样是手动完成的。</p><p id="5226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博文中，我们将只讨论GitHub动作上下文中的持续部署，以及在现有repo上实现它的方法。因此，此后术语CD将代表连续部署。</p><h1 id="7b25" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么选择CI/CD？</h1><p id="9130" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">CI的优势是显而易见的:整个开发团队可以无缝地同时处理相同的代码。在这篇博文中，我们将讨论局限于GitHub虽然可能有更好的CI系统可以更好地处理合并冲突，但我们将讨论作为主流服务的GitHub，以及GitHub操作如何有利于开发团队的工作流程。</p><p id="942a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，CD也有以下限制[4]:</p><ul class=""><li id="cd4b" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><strong class="ih hj">客户偏好:</strong>如果客户不喜欢推送有时可能很关键的小增量更新(如安全补丁)，并且不更新他们的系统，则系统可能会受到危害，并且错误会影响系统本身的功能。例如，关键任务软件正在运行，或者该组织的工作流不支持CI/CD。然后，一些系统可能无法更改系统文件或在更新后重新启动。<br/>由于这一点，公司已经采取了自己的对策来应对这一劣势:Ubuntu每两年发布一次LTS(长期支持)版本，在发布前进行广泛的调试，预计该软件将在未来几年内运行并得到支持。Windows 10为不同类型的客户提供了不同的更新渠道。企业用户在发布6个月后会收到更新，在此期间，许多安全补丁、错误修复、用户体验改进和优化会被推送到企业版。此外，建议企业在将更新推送到该组织中的所有PC之前，在选定的机器上测试新的更新。</li><li id="a167" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">需要人工干预的测试:</strong>在医学研究领域，需要进行数年的测试和认证，所有这些繁文缛节减缓了这一过程，这样的开发周期在这些领域并不真正适用。</li></ul><h1 id="bbc4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">朱莉娅和CI/CD</h1><p id="1655" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">当然，就像其他编程语言一样，你可以在GitHub上建立一个代码库，你可以在这里找到这个<a class="ae jd" href="https://help.github.com/en/github/getting-started-with-github" rel="noopener ugc nofollow" target="_blank"/>。我们不会深入探讨这个问题，因为这篇博文假设你以前有过设置GitHub回购、克隆回购、创建问题、拉请求、派生回购以及与多个分支机构合作的经验。</p><p id="9398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你有了一个包含Julia代码的repo，用GitHub动作设置CD工作流就非常容易了。GitHub动作本质上是每次事件发生时执行给定步骤的脚本。事件可以是时间的流逝、问题或拉取请求的创建或关于相同内容的评论的创建、提交或在此处<a class="ae jd" href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#webhook-events" rel="noopener ugc nofollow" target="_blank">指定的任何其他事件</a>。用户可以根据需要定义步骤。它可能是运行一个脚本，测试一个构建，创建一个新的发布，标记问题和拉请求，检查拉请求中变更的可行性，等等。</p><p id="4019" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于Julia开发，在撰写本文时有两个GitHub操作:</p><ul class=""><li id="ef6d" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">设置Julia环境以运行Julia脚本:<a class="ae jd" href="https://github.com/marketplace/actions/setup-julia-environment" rel="noopener ugc nofollow" target="_blank">设置Julia环境</a></li><li id="013b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">为Julia包的发布添加标签:<a class="ae jd" href="https://github.com/marketplace/actions/julia-tagbot" rel="noopener ugc nofollow" target="_blank"> Julia TagBot </a></li></ul><p id="0534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除非你正在维护和编写一个Julia包，否则你很少有机会需要了解第二个包。现在让我们来看看如何开始在Julia repos上使用GitHub Actions。稍后，我们将了解为包设置CI工作流的过程。</p><h1 id="0545" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为在GitHub上运行Julia脚本设置CI脚本</h1><p id="23c7" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在设置包含要运行的. jl文件的repo后，执行以下步骤来自动运行该脚本:</p><ol class=""><li id="fa4c" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc lm le lf lg bi translated">在repo的根目录下创建一个<code class="du ln lo lp lq b">.github</code>文件夹，并在刚刚创建的<code class="du ln lo lp lq b">.github</code>文件夹中创建一个<code class="du ln lo lp lq b">workflows</code>文件夹。</li><li id="7256" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc lm le lf lg bi translated">在这个工作流文件夹中创建一个<code class="du ln lo lp lq b">name.yml</code>文件，其中<code class="du ln lo lp lq b">name</code>是您想要为自动运行的脚本设置的名称。</li><li id="7229" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc lm le lf lg bi translated">回到repo的根目录，创建一个名为<code class="du ln lo lp lq b">src</code>的文件夹。把你所有的Julia代码都放到这个文件夹里。现在，您的文件夹应该具有以下层次结构:</li></ol><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="808c" class="lv jw hi lq b fi lw lx l ly lz">Repo_name<br/> |<br/> | — → src<br/> |      ├ — -&gt; mycode.jl<br/> |      └ → morecode.jl<br/> | — → .github<br/> |        └ — — -&gt; workflows<br/> └ ...                 └ — → name.yml<br/>Note: The … stands for all the other files (README, LICENSE, and all other unimportant files)</span></pre><p id="6355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.既然代码的框架结构已经准备好了，让我们开始编写name.yml脚本，它将自动执行我们的脚本。回到name.yml，我们将在那里添加一些代码来实现自动化。</p><p id="98e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.前往<a class="ae jd" href="https://github.com/marketplace/actions/setup-julia-environment" rel="noopener ugc nofollow" target="_blank">https://github . com/market place/actions/setup-Julia-environment</a>，点击“使用最新版本”。复制出现在对话框中的代码。如果您在编写自动化脚本时拷贝了任何其他文本，请将其粘贴到记事本中。现在，让我们开始写剧本。我们首先需要定义自动化脚本的名称。为此，您可以在脚本顶部键入以下内容:</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="543d" class="lv jw hi lq b fi lw lx l ly lz">name: ‘Name of your script’<br/>description: ‘Description of what your script does’<br/>author: ‘Your name’</span></pre><p id="3e19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之下，我们将设置运行任务的时间表。</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="0d5b" class="lv jw hi lq b fi lw lx l ly lz">on:<br/>  schedule:<br/>    - cron: ‘*/5 * * * *’</span></pre><p id="df00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述脚本每5分钟运行一次。要更改此时间表或设置脚本在不同的事件上运行，请参见本文中的<a class="ae jd" href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/configuring-a-workflow#triggering-a-workflow-with-events" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们让脚本运行我们的Julia代码。为此，我们将创建一个<code class="du ln lo lp lq b">job</code>，并将<code class="du ln lo lp lq b">steps</code>添加到那个<code class="du ln lo lp lq b">job</code>中。由于运行我们的代码本质上是一个构建活动，我们将把我们的步骤放在一个<code class="du ln lo lp lq b">build</code>中。</p><p id="f278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ln lo lp lq b">runs-on</code>只是脚本在哪个操作系统上运行的规范。这可能是这里<a class="ae jd" href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners#supported-runners-and-hardware-resources" rel="noopener ugc nofollow" target="_blank">提到的任何操作系统</a>。我用过<code class="du ln lo lp lq b">ubuntu-latest</code>。您还需要使用我们之前从对话框中复制的代码来设置Julia。</p><p id="7dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用构建步骤构建包(我们的Julia代码)，运行步骤将执行我们的Julia脚本。将代码粘贴到我们之前粘贴的<code class="du ln lo lp lq b">on</code>块下面。</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="92ef" class="lv jw hi lq b fi lw lx l ly lz">jobs:<br/>  build:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - name: Setup Julia environment<br/>      uses: julia-actions/setup-julia@v1.0.2<br/>      - name: Build<br/>      uses: julia-actions/julia-buildpkg@master<br/>      - name: Run<br/>      run: julia --project src/mycode.jl</span></pre><p id="4483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，您必须在最后一行中更改脚本的名称，这样才能正常工作。</p><p id="6671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要为我们的项目设置一些依赖项(Julia代码)。由于GitHub Actions虚拟机没有安装所需的Julia包，我们必须安装它们。你可以通过简单地改变</p><p id="9b10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ln lo lp lq b"><em class="ju">using</em> Example, Example1</code></p><p id="4e92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="5e34" class="lv jw hi lq b fi lw lx l ly lz"><em class="ju">import</em> Pkg</span><span id="411e" class="lv jw hi lq b fi ma lx l ly lz">Pkg.add(“Example”); <em class="ju">using</em> Example<br/>Pkg.add(“Example1”); <em class="ju">using</em> Example1</span></pre><p id="f8b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将安装每次运行代码时所需的最新版本的包。</p><p id="8b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们就成功地自动化了我们的脚本！</p><h1 id="8e40" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">Julia软件包和CI/CD</h1><p id="dc3a" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">Julia包作为包的注册表保存在一个地方，其中有关于包的信息。每次使用JuliaRegistrator应用程序更新注册表时，都需要在Julia包的实际repo上生成新的版本。TagBot自动更新软件包repo上的版本。</p><p id="0df0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要设置TagBot，请执行以下步骤:</p><ol class=""><li id="d690" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc lm le lf lg bi translated">在您的repo的根目录下创建一个<code class="du ln lo lp lq b">.github</code>文件夹。</li><li id="0316" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc lm le lf lg bi translated">在<code class="du ln lo lp lq b">.github</code>文件夹中创建一个<code class="du ln lo lp lq b">workflows</code>文件夹</li><li id="601b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc lm le lf lg bi translated">在<code class="du ln lo lp lq b">workflows</code>文件夹中创建一个名为<code class="du ln lo lp lq b">TagBot.yml</code>的文件。</li><li id="0424" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc lm le lf lg bi translated">将以下代码粘贴到<code class="du ln lo lp lq b">TagBot.yml</code>文件中:</li></ol><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="e0b2" class="lv jw hi lq b fi lw lx l ly lz">name: TagBot</span><span id="2469" class="lv jw hi lq b fi ma lx l ly lz">on:<br/>  schedule:<br/>    - cron: 0 * * * *</span><span id="30dd" class="lv jw hi lq b fi ma lx l ly lz">jobs:<br/>  TagBot:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: JuliaRegistries/TagBot@v1<br/>        with:<br/>          token: ${{ secrets.GITHUB_TOKEN }}</span></pre><p id="fd39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，每次你在JuliaRegistry上为你的包创建一个发布，它会自动更新repo来反映最新的发布。</p><h1 id="ef51" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">在合并拉取请求之前测试代码</h1><p id="1b51" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">有时，我们需要在合并请求之前运行测试，看看构建是否失败。这可以使用矩阵测试来完成，以便保持跨平台兼容性。为此，我们必须编写一个测试脚本来测试repo上的所有代码，并检查它是否按预期运行。编写<code class="du ln lo lp lq b">tests.jl</code>或<code class="du ln lo lp lq b">runtests.jl</code>脚本的过程对于每个回购来说都是不同的，所以你必须自己找出答案。</p><p id="633c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设已经编写了测试脚本，并且可以测试整个回购的错误，我们现在可以为回购设置一个自动化的工作流。要设置自动化跨平台测试[5]:</p><p id="28f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将测试脚本(<code class="du ln lo lp lq b">tests.jl</code>或<code class="du ln lo lp lq b">runtests.jl</code>)放在存储库的根目录下。</p><p id="5b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在repo的根目录中创建一个<code class="du ln lo lp lq b">.github</code>文件夹，并在这个<code class="du ln lo lp lq b">.github</code>文件夹中创建一个<code class="du ln lo lp lq b">workflows</code>文件夹。</p><p id="9f8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个<code class="du ln lo lp lq b">workflows</code>文件夹中创建一个<code class="du ln lo lp lq b">testing.yml</code>文件。</p><p id="2e63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们编写<code class="du ln lo lp lq b">testing.yml</code>的代码</p><p id="6faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要在脚本的顶部定义动作的名称，如下所示:</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="aa01" class="lv jw hi lq b fi lw lx l ly lz">name: Run tests</span></pre><p id="77bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要安排这次测试。在大多数测试场景中，您会希望在每个push to master和每个Pull请求上运行这个程序:</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="b4f8" class="lv jw hi lq b fi lw lx l ly lz">on:<br/>  push:<br/>    branches: master<br/>  pull_request:</span></pre><p id="469e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们最后为我们的脚本设置<code class="du ln lo lp lq b">job</code>。由于这是一个测试活动，我们将把所有or步骤放在一个<code class="du ln lo lp lq b">test</code>块中。为了支持跨平台测试，我们使用一种叫做矩阵测试的东西。这样可以在不同的操作系统和Julia版本上运行代码，以确保跨平台兼容性和向后兼容性。</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="905b" class="lv jw hi lq b fi lw lx l ly lz">jobs:<br/>  test:<br/>    runs-on: ${{ matrix.os }}<br/>    strategy:<br/>      fail-fast: false<br/>      matrix:<br/>        julia-version: [‘1.0’, ‘1.1’, ‘1.2’, ‘1.3’, nightly]<br/>        os: [ubuntu-latest, windows-latest, macOS-latest]<br/>    steps:<br/>      - uses: actions/checkout@v1.0.0</span><span id="5ef9" class="lv jw hi lq b fi ma lx l ly lz">      - name: “Set up Julia ${{ matrix.julia-version }}”<br/>        uses: julia-actions/setup-julia@v1<br/>        with:<br/>          version: ${{ matrix.julia-version }}</span><span id="235a" class="lv jw hi lq b fi ma lx l ly lz">     - name: Test exercises<br/>       run: julia --color=yes --check-bounds=yes --project -e using Pkg; Pkg.test(coverage=true)</span></pre><p id="8c8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们如何使用一个<code class="du ln lo lp lq b">matrix</code>将<code class="du ln lo lp lq b">runs-on</code>设置到不同的操作系统。现在让我们看一下步骤:首先，我们签出我们的repo，以便我们的工作流可以访问它，然后，我们用matrix指定的版本设置一个Julia环境，最后，我们运行测试我们的包的测试脚本。</p><p id="0c4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就完成了跨平台测试的工作流程。</p><p id="25ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于安全原因，建议在GitHub动作中检查我们的repo时使用提交散列而不是版本。因此，我们的结帐步骤将是</p><pre class="jf jg jh ji fd lr lq ls lt aw lu bi"><span id="2c5e" class="lv jw hi lq b fi lw lx l ly lz">steps:<br/>  - uses: actions/checkout@*commit hash*<br/>  - name: “Set up Julia ${{ matrix.julia-version }}”</span></pre><p id="de1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，该操作将按照使用该提交哈希提交后的方式使用代码。有关使用该版本如何会带来安全风险的更多信息，你可以参考<a class="ae jd" href="https://julienrenaux.fr/2019/12/20/github-actions-security-risk/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>。</p><h1 id="9925" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">参考</h1><p id="c5f6" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">由Pixabay在<a class="ae jd" href="https://www.pexels.com/photo/mirror-lake-reflecting-wooden-house-in-middle-of-lake-overlooking-mountain-ranges-147411/" rel="noopener ugc nofollow" target="_blank">像素</a>上制作的封面图片</p><p id="3914" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]—<a class="ae jd" href="https://en.wikipedia.org/wiki/Continuous_integration" rel="noopener ugc nofollow" target="_blank">持续集成的定义来自维基百科</a></p><p id="2b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2] — <a class="ae jd" href="https://docs.microsoft.com/en-us/windows/deployment/update/waas-overview" rel="noopener ugc nofollow" target="_blank"> Windows即服务，以CI/CD为例</a></p><p id="d836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[3] — <a class="ae jd" href="https://en.wikipedia.org/wiki/Rolling_release" rel="noopener ugc nofollow" target="_blank"> Linux作为CI/CD的一个例子</a></p><p id="fb0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[4]—<a class="ae jd" href="https://en.wikipedia.org/wiki/Continuous_delivery#Benefits_and_obstacles" rel="noopener ugc nofollow" target="_blank">CD的障碍</a></p><p id="dd1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[5] — <a class="ae jd" href="https://github.com/invenia/PkgTemplates.jl/blob/master/test/fixtures/AllPlugins/.github/workflows/ci.yml" rel="noopener ugc nofollow" target="_blank">包的标准测试脚本</a></p></div></div>    
</body>
</html>