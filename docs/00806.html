<html>
<head>
<title>Web Scraping with a Headless Browser: A Puppeteer Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无头浏览器的网络抓取:木偶师教程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/web-scraping-with-a-headless-browser-a-puppeteer-tutorial-96e82d8093aa?source=collection_archive---------5-----------------------#2019-09-09">https://medium.com/analytics-vidhya/web-scraping-with-a-headless-browser-a-puppeteer-tutorial-96e82d8093aa?source=collection_archive---------5-----------------------#2019-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/12c9d2fc5ad5e4cb9390f2ce6b8bd9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7l_x15uRgj1hLBH_dBKtJg.jpeg"/></div></div></figure><p id="6e64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的十年中，Web开发以惊人的速度前进，出现了许多用于后端和前端开发的框架。网站变得越来越智能，开发网站的底层框架也变得越来越智能。web开发中的所有这些进步也导致了浏览器本身的发展。大多数浏览器现在都有“无头”版本，用户可以在没有任何用户界面的情况下与网站进行互动。你也可以在这些<strong class="is hj"> <em class="jo">无头浏览器</em> </strong>上使用像<strong class="is hj"> <em class="jo">木偶</em> </strong>和nodeJS这样的包来抓取网站。</p><p id="7a33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Web开发严重依赖于测试机制，以便在我们将它们推向生产环境之前进行质量检查。一个复杂的网站在我们部署之前需要一个复杂的测试套件结构。<strong class="is hj"> <em class="jo">无头浏览器</em></strong><em class="jo"/><strong class="is hj"><em class="jo">由于没有任何UI的开销</em>，大大减少了web开发中的测试时间 </strong> <em class="jo">。这些浏览器让我们能够在更短的时间内处理更多的网页。</em></p><p id="a1b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将学习使用nodeJS和<a class="ae jp" href="https://blog.datahut.co/asynchronous-web-scraping-using-python/" rel="noopener ugc nofollow" target="_blank">异步编程</a>在这些<strong class="is hj"> <em class="jo">无头浏览器</em> </strong>上抓取网站。在我们开始抓取网站之前，让我们更详细地了解一下无头浏览器。此外，如果你担心抓取的<a class="ae jp" href="https://blog.datahut.co/is-web-data-scraping-legal/" rel="noopener ugc nofollow" target="_blank">合法性，你可以清除你关于网页抓取</a>的<a class="ae jp" href="https://blog.datahut.co/busting-8-myths-about-web-scraping/" rel="noopener ugc nofollow" target="_blank">神话。</a></p><h1 id="6008" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是无头浏览器</h1><p id="79ae" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj"><em class="jo"/></strong><em class="jo">无头浏览器在执行基于web的自动化测试</em>  <em class="jo">等任务时更加</em> <strong class="is hj"> <em class="jo">灵活、快速、优化。由于没有任何UI的开销，</em> <strong class="is hj"> <em class="jo">无头</em> </strong> <em class="jo">浏览器适用于</em> <strong class="is hj"> <em class="jo">自动化压力测试和网页抓取，因为这些任务可以更快地运行</em> </strong>。虽然像PhantomJS、HtmlUnit这样的供应商已经在市场上提供无头浏览器功能很长时间了，但chrome和firefox这样的浏览器玩家现在也在提供他们浏览器的“无头”版本。因此，不需要为无头功能安装额外的浏览器。</strong></p><h1 id="4add" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">对无头浏览器的需求</h1><p id="1b4e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">随着web开发框架的进步，浏览器也变得更加智能，可以加载所有的javascript库。随着web开发技术的发展，网站的测试也在发展，并且已经成为web开发行业的基本要素之一。无头浏览器的发展允许我们执行以下应用</p><ol class=""><li id="1efc" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">端到端测试是一种用于测试应用程序的流程是否从头到尾都按照设计执行的方法。执行端到端测试的目的是识别系统依赖性，并确保正确的信息在各种系统组件和系统之间传递。<strong class="is hj">web应用的测试自动化</strong> <strong class="is hj"> <em class="jo">无头浏览器</em> </strong>就是为了迎合这种用例而设计的，因为它们支持使用CLI进行更快的web测试。</li><li id="369e" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><strong class="is hj"> <em class="jo">无头浏览器</em> </strong>能够更快地抓取网站，因为它们不必处理打开任何UI的开销。有了<strong class="is hj"> <em class="jo">无头浏览器</em> </strong>，人们可以简单地自动化废弃机制，并以更加优化的方式提取数据。</li><li id="2b36" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">无头浏览器 可能不提供任何GUI体验，但它们确实允许用户拍摄他们正在渲染的网站的快照。这当然有助于执行自动化测试，并希望在网站上可视化代码效果，并以截图的形式存储结果。使用<strong class="is hj"> <em class="jo">无头浏览器</em> </strong>拍摄大量没有任何实际UI的截图是小菜一碟。</li><li id="1d5f" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">成功提供卓越客户体验的公司总是比竞争对手做得更好。<strong class="is hj">绘制跨网站的用户旅程<br/> <em class="jo">无头浏览器</em> </strong>允许我们运行绘制客户旅程测试案例的程序，以优化用户在网站决策过程中的体验。</li></ol><h1 id="e450" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是木偶师</h1><p id="ab0b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj"><em class="jo">puppeter是一个API库，用DevTools协议来控制Chrome或者Chrome</em></strong><em class="jo">。它通常是无头的，但可以设置为操作Chrome或整个Chrome(非无头)</em>。此外，Puppeteer是一个节点库，我们可以使用它来监控Chrome实例，而无需heads (UI)。</p><h1 id="4e80" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用木偶师进行网页抓取</h1><p id="8bf7" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在本文中，我们将使用<strong class="is hj">木偶师</strong>来<a class="ae jp" href="https://blog.datahut.co/scraping-amazon-reviews-python-scrapy/" rel="noopener ugc nofollow" target="_blank">从网站</a>上抓取产品列表。<strong class="is hj"> <em class="jo">木偶师会使用无头chrome浏览器打开网页，查询回所有结果</em> </strong>。在我们开始实际实现用于web抓取的puppeteer之前，我们将研究一下它的设置和安装。</p><p id="7307" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，我们将实现一个简单的用例，在这个用例中，我们将访问一个<a class="ae jp" href="https://blog.datahut.co/scraping-yahoo-finance-data-using-python/" rel="noopener ugc nofollow" target="_blank">电子商务网站，搜索一个产品并抓取所有结果</a>。所有上述任务将通过使用<strong class="is hj">木偶师</strong>库以编程方式处理。此外，我们将使用nodeJS语言来完成上面定义的任务。</p><h1 id="108e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">安装木偶师</h1><p id="c384" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">下面的代码片段将帮助您安装node js</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b596" class="lq jr hi lm b fi lr ls l lt lu">## Updating the system libraries ## sudo apt-get update ## Installing node js in the system ## sudo apt-get install nodejs</span></pre><p id="3990" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用下面的命令来安装<strong class="is hj">木偶师</strong>包</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c924" class="lq jr hi lm b fi lr ls l lt lu">npm install --save puppeteer</span></pre><p id="6d3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们现在已经安装了所有的依赖项，我们可以使用<strong class="is hj">木偶师</strong>开始实现我们的抓取用例。我们将使用由<strong class="is hj">木偶师</strong>包驱动的节点JS程序来控制网站上的动作。</p><h1 id="4229" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用木偶师抓取产品列表</h1><p id="e5f4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">第一步:访问页面并搜索产品</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5e61" class="lq jr hi lm b fi lr ls l lt lu">const puppeteer = require('puppeteer');const browser = await puppeteer.launch(); const page = await browser.newPage(); var args = process.argv[2] await page.goto("https://www.croma.com/"); await page.click('button.mobile__nav__row--btn-search') await page.type('input#js-site-search-input', args) await page.keyboard.press('Enter'); await page.screenshot({path: 'sample.png'})</span></pre><p id="d723" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二步:清理物品清单</p><p id="eb1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一节中，我们将收集搜索给定产品后得到的产品列表。HTML选择器被用来获取网页内容。所有废弃的结果被整理在一起形成数据集。querySelector函数允许我们使用HTML选择器从web页面中提取内容。querySelectorAll函数获取用特定选择器标记的所有内容，而querySelector函数只返回第一个匹配的元素。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="9df9" class="lq jr hi lm b fi lr ls l lt lu">let urls = await page.evaluate(() = { let results = []; let items = document.querySelectorAll('li.product__list--item'); items.forEach((item) = { let name = item.querySelector('a.product__list--name').innerText let price = item.querySelector('span.pdpPrice').innerText let discount = item.querySelector('div.listingDiscnt').innerText results.push({ prod_name: name, prod_price: price, prod_discount: discount }); }); return results; })</span></pre><p id="2dcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是实现的完整工作示例。我们已经在运行函数中包装了整个登录，并在控制台中记录废弃的结果。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="26cb" class="lq jr hi lm b fi lr ls l lt lu">const puppeteer = require('puppeteer'); function run () { return new Promise(async (resolve, reject) ={ try { const browser = await puppeteer.launch(); const page = await browser.newPage(); var args = process.argv[2] await page.goto("https://www.croma.com/"); await page.click('button.mobile__nav__row--btn-search') await page.type('input#js-site-search-input', args) await page.keyboard.press('Enter'); await page.screenshot({path: 'sample.png'}) let urls = await page.evaluate(() = { let results = []; let items = document.querySelectorAll('li.product__list--item'); items.forEach((item) = { let name = item.querySelector('a.product__list--name').innerText let price = item.querySelector('span.pdpPrice').innerText let discount = item.querySelector('div.listingDiscnt').innerText results.push({ prod_name: name, prod_price: price, prod_discount: discount }); }); return results; }) browser.close(); return resolve(urls); } catch (e) { return reject(e); } }) } run().then(console.log).catch(console.error);</span></pre><p id="f162" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用下面的命令，通过<strong class="is hj">无头浏览器</strong>运行上面的<strong class="is hj">木偶师</strong>脚本。我们将使用nodejs来运行我们的代码。你只需要提到关键字节点和文件名，然后是产品名称，你需要在给定的网站上搜索其数据并抓取结果。</p><p id="3523" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们在Croma网站上搜索iPhones，然后删除产品列表。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f544" class="lq jr hi lm b fi lr ls l lt lu">node headlessScrape.js iphones</span></pre><p id="b8d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong></p><p id="4702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述代码的输出可以这样可视化</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/21d9329eaaf63a76d613756aa5a6f7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*pFIldVjBjmC9s0S5n1QSlg.png"/></div></figure><p id="b9dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">通过无头浏览器抓取后的产品列表</em></p><p id="c56a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在为时已晚之前，您应该加入在您的操作中使用数据抓取的行列。它将帮助你<em class="jo">提升你的组织的绩效</em>。此外，它将帮助你<strong class="is hj">获得你目前可能不知道的洞察力</strong>。这将使<strong class="is hj">在您的业务流程中做出明智的决策</strong>。</p><p id="fcab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们学会了使用nodeJS中的<strong class="is hj"><em class="jo"/></strong>包从<em class="jo"> </em> <strong class="is hj"> <em class="jo">无头浏览器</em> </strong>中抓取数据。我们还执行了一些自动化任务，以便在最终删除内容之前自动完成网站上的一些操作。无头浏览器仍处于萌芽状态，但在自动网页抓取和网页测试领域显示出很大的前景。通过<strong class="is hj"> <em class="jo">无头浏览器</em> </strong>进行更快的网页抓取将有助于你在服务器成本方面比市场上的其他玩家更有竞争力。</p></div></div>    
</body>
</html>