<html>
<head>
<title>Predicting Basketball Results Using Python and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Docker预测篮球比赛结果</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-basketball-results-using-python-and-docker-9630d7c3be56?source=collection_archive---------7-----------------------#2020-07-03">https://medium.com/analytics-vidhya/predicting-basketball-results-using-python-and-docker-9630d7c3be56?source=collection_archive---------7-----------------------#2020-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="92af" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">简介</strong></h1><p id="93a2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将在Python中构建一个基本的预测模型，计算篮球比赛中两队之间的获胜概率。为了验证其准确性，我们将比较模型的输出和实际的博彩赔率。这个模型将是一个简单的REST API，运行在Docker容器中(我的意思是，它<em class="kb">毕竟是</em> 2020)。</p><p id="57bf" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">以防你还不知道，这里有这个项目的技术栈的概述，完全不是从维基百科上抄来的:</p><p id="6b41" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb"> Python </em> </strong>是一种解释型高级通用编程语言。它被设计成易于阅读和简单实施。</p><p id="9ad2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb"> Docker </em> </strong>是一套平台即服务(PaaS)产品，使用操作系统级虚拟化来交付称为容器的软件包中的软件。</p><h2 id="61a6" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated"><strong class="ak">对接器设置</strong></h2><p id="c8e2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在你的机器上安装Docker引擎是这个项目的先决条件，所以如果你还没有这样做，你必须在你的机器上安装和设置Docker。根据您运行的操作系统的不同，说明会略有不同，所以在进行安装和设置时，一定要仔细阅读文档。</p><p id="f8fa" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">一旦你完成了这个过程，打开你的终端并输入</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a055" class="kh ig hi lb b fi lf lg l lh li">docker --version</span></pre><p id="abfd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如果它返回的不是你的Docker版本，那么…你将不得不再次经历设置过程，因为有可能出错了。</p><p id="7885" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">安装Docker后，您需要创建您的工作目录。我把我的叫做‘python-basketball ’,但是当然你可以随便叫它什么。现在为了让Docker工作，我们需要在这个目录中创建两个文件:一个<strong class="jf hj"> Dockerfile </strong>(注意末尾没有文件扩展名)和<strong class="jf hj"> docker-compose.yml </strong>文件。我不会详细介绍它们是什么，但本质上Dockerfile是一个简单的文本文件，包含用户可以调用来组合图像的命令，而Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。</p><p id="9861" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">Dockerfile 的设置非常简单，我们可以用与Docker Hub库中的官方Python页面相同的方式组装我们的映像——只需更改运行脚本的名称。该文件应该如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="333a" class="kh ig hi lb b fi lf lg l lh li">FROM python:3</span><span id="aa44" class="kh ig hi lb b fi lj lg l lh li">WORKDIR /usr/src/app</span><span id="fe97" class="kh ig hi lb b fi lj lg l lh li">COPY requirements.txt ./</span><span id="1037" class="kh ig hi lb b fi lj lg l lh li">RUN pip install — no-cache-dir -r requirements.txt</span><span id="e57c" class="kh ig hi lb b fi lj lg l lh li">COPY . .</span><span id="d742" class="kh ig hi lb b fi lj lg l lh li">CMD [ “python”, “./run.py” ]</span></pre><p id="63db" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们的<strong class="jf hj"> docker-compose.yml </strong>会是这样的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bb6a" class="kh ig hi lb b fi lf lg l lh li">version: '3.4'<br/>services:<br/>  probability-calculator:<br/>    build: .<br/>    volumes:<br/>      - '.:/usr/src/app'</span></pre><p id="5e57" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最后，在同一个目录中创建一个<strong class="jf hj"> run.py </strong>文件，其中包含一个简单的hello world输出:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d9bc" class="kh ig hi lb b fi lf lg l lh li">print("Hello World")</span></pre><p id="9cc2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">书中最古老的把戏。无论如何，这就是在Docker中运行Python程序所需要的全部内容。如果你回到终端输入</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2a94" class="kh ig hi lb b fi lf lg l lh li">docker-compose up </span></pre><p id="1a79" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">瞧，你应该得到一个可爱的“Hello World”印到你的控制台上！</p><p id="aa72" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">您已经成功地在Docker容器中运行了一个应用程序，没有了实际安装Python(或其任何工具和依赖项)的麻烦，并且减少了管理虚拟机的开销。</p><p id="c2e8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">很酷吧？</p><h1 id="7c08" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">让我们实际建立模型</h1><p id="37ae" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好了，让我们开始实际编写一些代码。</p><p id="c2ae" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在这个项目中，我们将使用几个软件包来帮助我们:</p><ol class=""><li id="1956" class="lk ll hi jf b jg kc jk kd jo lm js ln jw lo ka lp lq lr ls bi translated"><strong class="jf hj"> <em class="kb">烧瓶</em>，</strong>一个帮助构建web应用的微框架。</li><li id="3e9c" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated"><strong class="jf hj"> <em class="kb"> SciPy </em> </strong>，一个基于Python的数学、科学和工程开源软件生态系统。</li></ol><p id="7aef" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">通常，我们需要使用pip在Python中手动安装这些包——然而，当我们使用Docker时，我们需要做的只是根据需要添加它们，当Docker映像构建完成时，它们会自动安装。在您的工作目录中创建一个名为<strong class="jf hj"> requirements.txt </strong>的文件。将以下几行添加到文件中:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="52cb" class="kh ig hi lb b fi lf lg l lh li">Flask==0.12.2<br/>scipy==1.4.1<br/>flask-restful==0.3.6</span></pre><p id="a552" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，我们需要创建一个文件夹，它代表保存模型Python代码的包。我把这个文件夹叫做‘概率计算器’。为了让Python知道这是一个包而不仅仅是一个随机的文件夹，我们需要创建一个名为<strong class="jf hj"> __init__的文件。py </strong>。要启动该文件，请添加以下内容:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="825b" class="kh ig hi lb b fi lf lg l lh li">#import the SciPy framework<br/>import scipy.stats as sp</span><span id="4abd" class="kh ig hi lb b fi lj lg l lh li">#import the Flask framework<br/>from flask import Flask, g<br/>from flask_restful import Resource, Api, reqparse </span><span id="0b3e" class="kh ig hi lb b fi lj lg l lh li">#create an instance of Flask<br/>app = Flask(__name__) </span><span id="3829" class="kh ig hi lb b fi lj lg l lh li">#create the API<br/>api = Api(app)</span></pre><h2 id="fcb5" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">模型</h2><p id="1818" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好了，现在我们进入代码的核心部分，也就是构建实际的模型。这个模型是基于韦恩·温斯顿的数学理论——他解释说，在NBA，一个评级系统预测的比赛结果的历史标准差是12分。换句话说，在任何给定的比赛中，两支球队之间实际差距的可能性可以用一个以赛前差距为中心的钟形概率分布来描述。我们从哪里得到这些差价？嗯，网上赌博的繁荣意味着我们可以很容易地从网上博彩公司那里得到它们。</p><p id="2e59" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">多亏了新冠肺炎，7月底之前没有NBA比赛。我们将不得不用退而求其次的东西——中国篮球协会！以下是Pinnacle从2020年6月24日星期三开始的价格:</p><figure class="kw kx ky kz fd lz er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es ly"><img src="../Images/a5eb295cd5a3070f0239267ec59e9298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEGTCX4srOOE2UK73HAG5w.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><strong class="bd ih">中国篮协赛事巅峰赔率</strong></figcaption></figure><p id="1978" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们有四场比赛，都有价差(“差点”)。让我们以第一场比赛为例——在第一场比赛中，我们有上海鲨鱼队和辽宁飞豹队，他们之间的差距为10.5分，这意味着飞豹队需要击败鲨鱼队11分或更多才能获胜。</p><p id="675c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">“金钱线”是任何一方获胜的概率。鉴于10.5分的差距有利于上面的飞豹，Pinnacle给鲨鱼队的十进制赔率为4.92，这意味着他们有20.3%的胜算。飞豹队的十进制赔率为1.161，相当于86.1%的胜算。</p><p id="3079" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">等一下，这些概率加起来是106.3%——概率的总和不是100%吗？没错，但博彩公司从<a class="ae kv" href="https://en.wikipedia.org/wiki/Mathematics_of_bookmaking" rel="noopener ugc nofollow" target="_blank">超过</a>中赚钱，这基本上是他们加入选择的百分比，使他们值得下注。为了方便起见，我们将使用中学数学来用比率标准化这些百分比。我们将得出每个团队的以下获胜概率:</p><p id="f385" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上海鲨鱼:19.09% <br/>辽宁飞豹:80.91%</p><p id="8cc4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">唷，这些中文名字真拗口。当你需要一个像“明尼苏达森林狼队”这样干脆的NBA球队名字时，哪里还有这样的名字呢？</em></p><h1 id="3399" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">回码</strong></h1><p id="c4f1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">既然我们已经知道了博彩公司给这两个团队的价差和获胜概率，那么是时候回到Python中工作了。</p><p id="3ce8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以将标准差硬编码为12.0(在中国联赛中可能与NBA略有不同，但让我们改天再讨论这个问题)。接下来，我们需要生成获胜概率。这些将基于正态分布(也称为高斯分布),该分布以庄家价差的平均值为中心，以及给定的标准偏差。回到<strong class="jf hj"> __init__。py </strong>让我们写下模型:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="94bf" class="kh ig hi lb b fi lf lg l lh li">STD_DEV = 12.0</span><span id="0d27" class="kh ig hi lb b fi lj lg l lh li">def calculate_probability(spread, std_dev):<br/>    return sp.norm.sf(0.5,spread, std_dev)</span></pre><p id="3b0e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该函数仅返回给定庄家价差和标准差的情况下，一个团队赢1分或更多分的概率。你可以在SciPy关于正态分布的文档中阅读这方面的内容。</p><p id="9dbc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，实际的模型请求。这将是一个利用flask-resftul的HTTP POST请求，flask包的扩展提供了快速构建API的工具。它的工作方式是这样的:</p><ol class=""><li id="93f7" class="lk ll hi jf b jg kc jk kd jo lm js ln jw lo ka lp lq lr ls bi translated">用户为每个端点创建一个类</li><li id="b7b9" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">然后，用户为每个要接受的方法创建一个函数</li></ol><p id="bc23" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">记住这一点，下面是用200状态代码编码的请求，如果成功，还会有消息:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6e7f" class="kh ig hi lb b fi lf lg l lh li">class WinProbability(Resource):</span><span id="f5ad" class="kh ig hi lb b fi lj lg l lh li">def post(self):<br/>    parser = reqparse.RequestParser()<br/>    parser.add_argument('spread', required=True, type=str)</span><span id="86fa" class="kh ig hi lb b fi lj lg l lh li">    args = parser.parse_args()</span><span id="bb2b" class="kh ig hi lb b fi lj lg l lh li">    favourite_win = calculate_probability(float(args.spread),  <br/>    STD_DEV)<br/>    outsider_win = 1 - favourite_win</span><span id="369a" class="kh ig hi lb b fi lj lg l lh li">    return{'message': 'POST really was excellent',    <br/>    'favouriteProbability': favourite_win, 'outsiderProbability':<br/>    outsider_win}, 200</span></pre><p id="f3e4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">那真是太棒了。</p><p id="5495" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在我们测试模型和响应之前，不要忘记在文件的末尾添加这个资源:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7c15" class="kh ig hi lb b fi lf lg l lh li">api.add_resource(WinProbability, '/winProbability')</span></pre><p id="3127" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，让我们实际上从<strong class="jf hj"> run.py </strong>文件中删除“Hello World”儿童剧，并代之以我们的应用程序:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bdb5" class="kh ig hi lb b fi lf lg l lh li">from probability_calculator import app</span><span id="07fe" class="kh ig hi lb b fi lj lg l lh li">app.run(host='0.0.0.0', port =80, debug=True)</span></pre><p id="1c75" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最后，让我们在最后的<strong class="jf hj"> docker-compose.yml </strong>中公开这个应用程序的端口5000:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="31e1" class="kh ig hi lb b fi lf lg l lh li">ports:<br/>  - '5000:80'</span></pre><p id="6a82" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在我们可以出发了！</p><h1 id="c3e5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">测试模型</strong></h1><p id="0cbc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们需要一个<a class="ae kv" href="https://www.slant.co/topics/7913/~rest-api-clients#2" rel="noopener ugc nofollow" target="_blank"> REST客户端</a>来测试我们的HTTP请求——我使用的是Postman，但是你可以使用任何你喜欢的。</p><p id="7fef" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">进入项目目录，启动终端，输入</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="04c8" class="kh ig hi lb b fi lf lg l lh li">docker-compose up</span></pre><p id="baf9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">启动应用程序。</p><p id="be66" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在使用我们的REST客户端，让我们使用POST请求访问端口5000，内容类型设置为<code class="du mk ml mm lb b">application/json</code>，主体如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3778" class="kh ig hi lb b fi lf lg l lh li">{"spread": 10.5}</span></pre><p id="4175" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如果一切顺利，你<em class="kb">应该</em>得到这样的回应:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ee4a" class="kh ig hi lb b fi lf lg l lh li">{</span><span id="a605" class="kh ig hi lb b fi lj lg l lh li">"message": "POST really was excellent",</span><span id="621b" class="kh ig hi lb b fi lj lg l lh li">"favouriteProbability": 0.7976716190363569,</span><span id="57cf" class="kh ig hi lb b fi lj lg l lh li">"outsiderProbability": 0.20232838096364314</span><span id="94a5" class="kh ig hi lb b fi lj lg l lh li">}</span></pre><p id="5a5f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">但是我们如何验证这些概率是否真的有用呢？</p><p id="3328" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们将把它们与之前Pinnacle的比赛结果市场进行比较。回到我们之前记录的上海鲨鱼队和辽宁飞虎队的获胜概率，我们可以看到鲨鱼队为19.09%，飞虎队为80.91%。离20.2%和79.8%也不算太远。不错！我想我们现在可以开始自己的博彩业务了，对吗？</p><p id="ed3b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">没那么快。首先，我们需要量化我们的模型输出实际上离预期概率有多远。有几种方法可以做到这一点，但一个很好的方法是使用样本数据的<a class="ae kv" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">均方误差</a> (MSE)。出于时间的考虑，这有点跑题，误差平方和(SSE)就是所有模型误差与实际数据相比的平方。当你将总和除以数据点的数量时，你得到MSE。对于本例，平方误差为</p><p id="3a98" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">匹配1的平方误差= (19.09 - 20.24) = 1.3225 </em> </strong></p><p id="04b9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们必须对所有四个匹配运行我们的模型，以比较结果并获得MSE。现在，我们可以为此编写另一个Python模块，或者我们可以像非受虐狂那样，创建一个Excel电子表格:</p><figure class="kw kx ky kz fd lz er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mn"><img src="../Images/30f42553bf07973b0d3cd6f6e54b9350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLoF-5USk9k6CagvtFb8cQ.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><strong class="bd ih">模型输出的SSE和MSE</strong></figcaption></figure><p id="b253" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">请注意，我们只需要四个数据点，因为该模型只针对热门概率运行了四次。局外人的概率正好是补数，即1-最有希望获胜的概率。</em></p><p id="17a1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">数据集的MSE是2.13——也许我们还没有完全准备好推出自己的体育博彩业务。</p><h1 id="8a75" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="54ee" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">唷。从在我们的操作系统上设置Docker开始，我们已经走了很长的路——我们现在有一个用Python构建的篮球模型，运行在它自己的Docker容器上！那真是太棒了。</p><p id="07ec" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在的问题是可以做些什么来改进这个模型？我已经能想到一些事情了:</p><ol class=""><li id="d7eb" class="lk ll hi jf b jg kc jk kd jo lm js ln jw lo ka lp lq lr ls bi translated">数据集的标准偏差不一定是12.0</li><li id="7b83" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">4的样本数据不可能足以证明任何模型</li><li id="d9a6" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">最初的假设可能过于简单——你真的能根据高斯分布预测篮球比赛结果吗？可能有更好的方式来模拟篮球比赛的结果吗？</li><li id="0fce" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">代码错误处理是不存在的(而且寿命很短)</li></ol><p id="8404" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">另外，我认为这是篮球预测建模的一个很好的尝试。如果我的博客文章是垃圾，而你宁愿只是翻录我的代码，在我的<a class="ae kv" href="https://github.com/ourandy/python-basketball" rel="noopener ugc nofollow" target="_blank"> Github库</a>里随意这么做。</p><p id="fa38" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">今天谢谢你！</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="ce60" class="if ig hi bd ih ii mv ik il im mw io ip iq mx is it iu my iw ix iy mz ja jb jc bi translated">其他文章</h1><div class="na nb ez fb nc nd"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/solving-our-python-basketball-model-d89edfb83f79"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">Python中的优化可减少均方误差</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">使用scipy.optimize库优化模型</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr me nd"/></div></div></a></div></div></div>    
</body>
</html>