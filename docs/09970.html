<html>
<head>
<title>Community Detection &amp; Network Analysis of the Stock Market in Python &amp; R — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python &amp; R 中股票市场的社区检测和网络分析—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/community-detection-network-analysis-of-the-stock-market-in-python-r-part-2-9b5a5dbe5d5b?source=collection_archive---------10-----------------------#2020-09-28">https://medium.com/analytics-vidhya/community-detection-network-analysis-of-the-stock-market-in-python-r-part-2-9b5a5dbe5d5b?source=collection_archive---------10-----------------------#2020-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="62a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是之前展示数据收集和清理的<a class="ae jd" rel="noopener" href="/@akiboy96/community-detection-network-analysis-of-the-stock-market-in-python-r-part-1-a8a3366dc5a5">博客</a>的延续。我们现在将着手对我们的网络进行建模，并使用聚类算法形成社区，这些算法最终将被用于<a class="ae jd" rel="noopener" href="/@akiboy96/community-detection-network-analysis-of-the-stock-market-in-python-r-part-3-ca4e0fbb8ca9">创建我们的投资组合</a>，这可能会超过间谍平均回报率<a class="ae jd" href="https://www.investopedia.com/articles/investing/122215/spy-spdr-sp-500-trust-etf.asp#:~:text=SPY%20Performance&amp;text=The%20SPDR%20S%26P%20500%20ETF%20Trust%20(SPY)%20has%20generated%20an,average%20annual%20returns%20of%208.93%25." rel="noopener ugc nofollow" target="_blank">的 8.93% </a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/fb92e1a19d4eddbeed8f09c1e353bcdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*cStacbcB7ylqz6gutZvQkQ.png"/></div></figure><h2 id="fd25" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated">第 2 部分:建模</h2><p id="fa7b" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">这种端到端的解决方案架构展示了股票信息将如何转化为一个网络，该网络通过随时间推移的价格变动来构建相关股票的社区。</p><p id="b496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是通过计算相关系数来建立股票之间的关系，如下所示。</p><p id="4ee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">时间序列互相关计算:</strong></p><p id="978e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个函数来计算不同时间窗口内股票的交叉相关性。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="2bbb" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv"># Function to calculate corr</em><br/>def calculate_corr(df_stock_returns, returns_window, corr_window_size, corr_method):<br/>    stocks_cross_corr_dict = {}<br/>    <em class="kv">#Calculate mean correlation by window for plot</em><br/>    x_days = []<br/>    y_mean_corr = []        <br/><em class="kv">#     W = corr_window_size</em><br/>    for i <strong class="kn hj">in</strong> range(returns_window,len(df_stock_returns),corr_window_size):<br/>        dic_key = i<br/>        stocks_cross_corr_dict[dic_key]=df_stock_returns.iloc[i:(i+W)].corr(method='pearson')<br/>        stocks_cross_corr_dict[dic_key].fillna(0,inplace=True)<br/>        x_days.append(dic_key)<br/>        y_mean_corr.append(np.mean([abs(j) for j <strong class="kn hj">in</strong> stocks_cross_corr_dict[dic_key].values.flatten().tolist()]))        <br/>    return stocks_cross_corr_dict, x_days,y_mean_corr</span></pre><p id="4565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦建立了相关函数，我们就可以在不同的时间窗口内对其进行可视化。在下面的代码中，我们选择 21 作为时间窗口，并在 5 个滚动窗口中进行计算。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="371a" class="jm jn hi kn b fi kr ks l kt ku">%matplotlib inline<br/><em class="kv"># stocks_cross_corr_dict = {}</em><br/><em class="kv">#Time Window width</em><br/><em class="kv">#TO DO: try different windows and different algorithms</em><br/><em class="kv">#t= 21 #21 based on the paper Asset trees and asset graphs in financial markets J.-P. Onnela et all</em><br/><em class="kv"># Try window from 1 month to 6 months of trading days</em><br/><em class="kv"># 21 days is one month trading days</em><br/>start = 21<br/>end = 126<br/>step = 21;<br/>plt.figure(figsize=(20, 10))<br/><em class="kv">#Find corr for the entire time period </em><br/><em class="kv"># _, x_days, y_mean_corr = calculate_corr(df_stock_prices,1,len(df_stock_prices), 'pearson')</em><br/><em class="kv"># x_days_t = range(0,len(df_stock_prices), 1)</em><br/><em class="kv"># y_mean_corr_t = np.empty(len(df_stock_prices))</em><br/><em class="kv"># y_mean_corr_t.fill(y_mean_corr[0])</em><br/><em class="kv"># plt.plot(x_days_t, y_mean_corr_t)</em><br/>for t <strong class="kn hj">in</strong> range(start, end, step):<br/>    x_days = []<br/>    y_mean_corr = []<br/>    W = t<br/>    _, x_days, y_mean_corr = calculate_corr(df_stock_prices,1,W, 'pearson')<br/>    plt.plot(x_days, y_mean_corr)<br/>    plt.xlabel('Days')<br/>    plt.ylabel('Mean Correlation')<br/>    l = list(range(start, end, step))<br/><em class="kv">#     l.insert(0, len(df_stock_prices))</em><br/>    plt.legend(l, loc='upper left')     <br/><br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kw"><img src="../Images/794126c8a3fd1863d3ad9a63a797e102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmZNCXed9Ne3GEL_TQyxbg.png"/></div></div></figure><p id="0269" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图显示了 21、42、63、84 和 105 天窗口跨度内滚动平均值的平均相关性。<em class="kv">它显示了标准普尔 500 指数中的股票在不同时间间隔</em>内的平均相关性的周期性变化。可视化后，我们可以选择我们的间隔，并得到如下所示的相关性。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="8a1e" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv">#Calculate corr for the entire period.</em><br/>stocks_cross_corr, _, _ = calculate_corr(df_stock_prices,1, len(df_stock_prices), 'pearson')<br/>stocks_cross_corr[1]</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lb"><img src="../Images/52a82f8af28be58d8d66c45a7b6baaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2XwBaQIIQ8yDZFVeWP4jw.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">标准普尔 500 股票的互相关输出</figcaption></figure><h2 id="26e0" class="jm jn hi bd jo jp jq jr js jt ju jv jw iq jx jy jz iu ka kb kc iy kd ke kf kg bi translated">现在我们已经在矩阵中找到了股票之间的相关性。我们可以继续构建将用于网络分析和社区检测的图表。模型工程过程中的第一步是将上述相关矩阵转换成无向加权图形数据结构，其中节点<strong class="ak"><em class="lg"/></strong>表示公司/股票代号，节点之间的<strong class="ak"> <em class="lg">边</em> </strong>是股票之间的互相关。</h2><p id="4dad" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">使用 Python 中的<strong class="ih hj"> <em class="kv"> networkx </em> </strong>和<strong class="ih hj"> <em class="kv">社区</em> </strong>包来构建图形。我们在上面看到的相关矩阵将被转换成图形数据结构，如下面的代码所示。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="e249" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv">#Build the Graph with stocks as nodes and corr as edges</em><br/>import networkx as nx<br/>import networkx.algorithms.community as nxcom<br/>import community<br/><br/>edge_weights = []<br/>def build_graph(stocks_cross_corr, threshold):<br/>    graph_edges = []<br/>    for x <strong class="kn hj">in</strong> stocks_cross_corr.keys():<br/>        for y <strong class="kn hj">in</strong> stocks_cross_corr[x].keys():<br/>            <em class="kv">#print(x, y) </em><br/>            <em class="kv"># Filter by absolute value of the corr</em><br/>            if abs(stocks_cross_corr[x][y]) &gt; threshold:<br/>                <em class="kv">#if same stock, continue</em><br/>                if  x == y:<br/>                    continue<br/>                if x &lt; y: <em class="kv">#Avoid duplicates, AxAAL vs AALxA</em><br/>                    graph_edges.append([x,y,dict(weight=abs(stocks_cross_corr[x][y]))])<br/>                    edge_weights.append(abs(stocks_cross_corr[x][y]))<br/>                else:<br/>                    None</span></pre><p id="fb69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦构建图的函数完成，我们就可以开始实现<strong class="ih hj"> <em class="kv"> CNM、GN 和 Louvain </em> </strong>算法了。</p><p id="7dfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kv">实现 GN </em> </strong></p><p id="a98b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于格文·纽曼的实现，我们将相关阈值设置为 0.6。<strong class="ih hj">格文-纽曼</strong>算法的基本思想是基于通过最短路径最多的边的迭代消除。请随意使用下面的代码，看看当您增加或减少关联阈值时，有多少社区被检测到。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="7d58" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv">#Community detection using Girvan Newman (GN)</em><br/>stocks_cross_corr, _, _ = calculate_corr(df_stock_prices,1, len(df_stock_prices), 'pearson')<br/>stocks_cross_corr = stocks_cross_corr[1]<br/><br/><br/>cor_thresold = 0.6<br/>G = build_graph(stocks_cross_corr, cor_thresold)<br/>result = nxcom.girvan_newman(G)<br/>communities_gn = next(result)<br/><em class="kv"># Set node and edge communities</em><br/>set_node_community(G, communities_gn)<br/>set_edge_community(G)<br/>print("GN Communities: ", len(communities_gn))<br/><br/><em class="kv"># Set community color for nodes</em><br/>node_color = [    <br/>    get_color(G.nodes[v]['community'])    <br/>    for v <strong class="kn hj">in</strong> G.nodes]<br/><br/><em class="kv"># Set community color for internal edgese</em><br/>external = [    <br/>    (v, w) for v, w <strong class="kn hj">in</strong> G.edges    <br/>    if G.edges[v, w]['community'] == 0]<br/>internal = [    <br/>    (v, w) for v, w <strong class="kn hj">in</strong> G.edges    <br/>    if G.edges[v, w]['community'] &gt; 0]<br/>internal_color = [    <br/>    get_color(G.edges[e]['community'])    <br/>    for e <strong class="kn hj">in</strong> internal]<br/><br/>stock_pos = nx.spring_layout(G)<br/>plt.rcParams.update({'figure.figsize': (15, 15)})<br/><em class="kv"># Draw external edges</em><br/>nx.draw_networkx(    <br/>    G, pos=stock_pos, node_size=0,    <br/>    edgelist=external, edge_color="#333333", with_labels=False)<br/><em class="kv"># Draw nodes and internal edges</em><br/>nx.draw_networkx(    <br/>    G, pos=stock_pos, node_color=node_color,    <br/>    edgelist=internal, edge_color=internal_color, with_labels=False)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lh"><img src="../Images/4807ea895e746b4d50b428561764eef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSgzpry_QT6Iz4NaaYZ7UQ.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">用 0.6 相关阈值形成的 GN 社区:19</figcaption></figure><p id="fe12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kv">鲁汶的实现:</em> </strong></p><p id="a028" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于格文·纽曼的实现，我们将相关阈值设置为 0.7，您可以随意将其设置为您喜欢的任何值。<strong class="ih hj"> Louvain </strong>算法的基本思想是分层聚类，递归地将社区合并到单个节点，并在浓缩图上执行模块性聚类。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="8ded" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv"># Louvian</em><br/>%matplotlib inline<br/>stocks_cross_corr, _, _ = calculate_corr(df_stock_prices,1, len(df_stock_prices), 'pearson')<br/>stocks_cross_corr = stocks_cross_corr[1]<br/><br/>cor_thresold = 0.7<br/>G = build_graph(stocks_cross_corr, cor_thresold)<br/>partition = community.best_partition(G)<br/>modularity = community.modularity(partition, G)<br/>values = [partition.get(node) for node <strong class="kn hj">in</strong> G.nodes()]<br/>plt.figure(figsize=(10,10))<br/>nx.draw_spring(G, cmap = plt.get_cmap('jet'), node_color = values, node_size=30, with_labels=False)<br/>#print(modularity)<br/>print("Total number of Communities=", len(G.nodes()))</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es li"><img src="../Images/dde9a24b0f0ad12020d6c4873bd8d13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*re5qEdVRkjjQ4w2q9NZlHg.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">使用 0.7 阈值的 Louvain 形成的社区总数:271</figcaption></figure><p id="b521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kv">实现 CNM </em> </strong></p><p id="d4bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<strong class="ih hj">子句集、纽曼-摩尔算法</strong>的实现，我们将相关阈值设置为 0.6。就像卢万算法一样，<strong class="ih hj"> CNM </strong>算法使用模块化作为它的度量和目标。也就是说，它被构造成最大化模块性得分 q。</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="3677" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv">#Community detection using CNM</em><br/>cor_thresold = 0.6<br/>G = build_graph(stocks_cross_corr, cor_thresold)<br/><br/>communities_cnm = sorted(nxcom.greedy_modularity_communities(G), key=len, reverse=True)<br/><em class="kv"># Set node and edge communities</em><br/>set_node_community(G, communities_cnm)<br/>set_edge_community(G)<br/>print("CNM Communities: ", len(communities_cnm))<br/><br/><em class="kv"># Set community color for nodes</em><br/>node_color = [    <br/>    get_color(G.nodes[v]['community'])    <br/>    for v <strong class="kn hj">in</strong> G.nodes]<br/><br/><em class="kv"># Set community color for internal edgese</em><br/>external = [    <br/>    (v, w) for v, w <strong class="kn hj">in</strong> G.edges    <br/>    if G.edges[v, w]['community'] == 0]<br/>internal = [    <br/>    (v, w) for v, w <strong class="kn hj">in</strong> G.edges    <br/>    if G.edges[v, w]['community'] &gt; 0]<br/>internal_color = [    <br/>    get_color(G.edges[e]['community'])    <br/>    for e <strong class="kn hj">in</strong> internal]<br/><br/>stock_pos = nx.spring_layout(G)<br/>plt.rcParams.update({'figure.figsize': (15, 15)})<br/><em class="kv"># Draw external edges</em><br/>nx.draw_networkx(    <br/>    G, pos=stock_pos, node_size=0,    <br/>    edgelist=external, edge_color="#333333", with_labels=False)<br/><em class="kv"># Draw nodes and internal edges</em><br/>nx.draw_networkx(    <br/>    G, pos=stock_pos, node_color=node_color,    <br/>    edgelist=internal, edge_color=internal_color, with_labels=False)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lh"><img src="../Images/6ea63822546004a3841c5c9f9f8e15e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sP7l0sJt6ZkCRRi4VdmvUw.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">使用相关阈值为 0.6 的 CNM 发现 27 个社区</figcaption></figure><p id="5b8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于<strong class="ih hj"> CNM </strong>创建了最佳数量的社区，我们可以使用<a class="ae jd" href="https://igraph.org/python/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> iGraph </strong> </a>创建一个 graphML 对象，以便更容易地在不同的相关性阈值上实现该模型。下面的代码可以做到这一点</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="a627" class="jm jn hi kn b fi kr ks l kt ku"><em class="kv">#Create graph and write it as GraphML</em><br/>stocks_cross_corr, _, _ = calculate_corr(df_stock_prices,1, len(df_stock_prices), 'pearson')<br/>stocks_cross_corr = stocks_cross_corr[1]<br/>cor_thresold = 0.6<br/>G = build_graph(stocks_cross_corr, cor_thresold)<br/><br/><em class="kv">#sp_500_graph_06.graphml</em><br/><em class="kv">#sp_500_graph_08.graphml</em><br/><em class="kv">#stocks_2B_graph_06.graphml</em><br/><em class="kv">#stocks_2B_graph_08.graphml</em><br/>nx.write_graphml(G,'sp_500_graph_06.graphml')<br/>stocks_cross_corr, _, _ = calculate_corr(df_stock_prices,1, len(df_stock_prices), 'pearson')<br/>stocks_cross_corr = stocks_cross_corr[1]<br/>cor_thresold = 0.8<br/>G = build_graph(stocks_cross_corr, cor_thresold)<br/><br/>nx.write_graphml(G,'sp_500_graph_08.graphml')</span></pre><p id="80c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj"> <em class="kv"> igraph </em> </strong>包，我们可以用下面的代码读取并可视化 graphML 对象:</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="6775" class="jm jn hi kn b fi kr ks l kt ku">import igraph as ig<br/>from tabulate import tabulate<br/><br/>Gix08 = ig.read('sp_500_graph_08.graphml',format="graphml")<br/>Gix06 = ig.read('sp_500_graph_06.graphml',format="graphml")</span><span id="2a7d" class="jm jn hi kn b fi lj ks l kt ku"><em class="kv"># Community detection with CNM </em><br/>dendrogram_cnm = Gix06.community_fastgreedy(weights="weight")<br/>optimal_count_cnm = dendrogram_cnm.optimal_count<br/>print("CNM Optimum community count: ", optimal_count_cnm)<br/><em class="kv"># convert it into a flat clustering</em><br/>clusters_cnm = dendrogram_cnm.as_clustering()<br/><em class="kv"># get the membership vector</em><br/>membership_cnm = clusters_cnm.membership<br/>modularity_cnm = clusters_cnm.q<br/>print("Modularity: ", modularity)</span><span id="e7d5" class="jm jn hi kn b fi lj ks l kt ku">CNM Optimum community count:  27<br/>Modularity:  0.3010881432242652</span><span id="ed07" class="jm jn hi kn b fi lj ks l kt ku">import random<br/>random.seed(1)<br/><br/>ig.plot(clusters_cnm, label=True, mark_groups = True)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lk"><img src="../Images/2a5cfede908b4e61d4a63aba61359f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0T6CV-j2k_10Rg_oe7oKlg.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">使用 CNM 算法形成的股票社区</figcaption></figure><p id="cd85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们可视化了不同股票的社区，我们可以将它们打印出来，以便更好地了解它们是如何聚集在一起的，如下所示:</p><pre class="jf jg jh ji fd km kn ko kp aw kq bi"><span id="f0e8" class="jm jn hi kn b fi kr ks l kt ku">community_list_cnm = []<br/>for name, membership <strong class="kn hj">in</strong> zip(Gix06.vs["id"], membership_cnm):<br/>    community_list_cnm.append([name, membership])<br/><em class="kv">#     print(name, membership)</em><br/>df_community_cnm = pd.DataFrame(community_list_cnm, columns = ['symbol', 'community'])<br/><em class="kv"># df_community_cnm.set_index('symbol',inplace=True)</em><br/><em class="kv"># df_community_cnm.sort_values(by=['community', 'symbol'], inplace=True)</em><br/><br/>df_community_cnm = df_community_cnm.groupby('community', as_index=True).agg(lambda x: ', '.join(set(x.astype(str))))<br/>print(df_community_cnm.to_markdown())</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ll"><img src="../Images/838f610daea1a5dccbe1cb0e6755abb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNzKm8lrPpbBNIdwvCk_-g.png"/></div></div></figure><blockquote class="lm ln lo"><p id="e1bf" class="if ig kv ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">现在，我们已经找到了价格运动相关的股票社区，如上所示，例如第四指数:<strong class="ih hj"><em class="hi"/>AmerisourceBergen Corporation</strong>(<strong class="ih hj">ABC)、McKesson Corporation (MCK)、Cardinal Health，Inc. (CAH) </strong>，我们可以开始确定我们的投资组合中需要什么样的股票了。就你所知，找出 ABC、MCK 和 CAH 的共同点。</p></blockquote><p id="abe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唷！我们现在就上到最酷的部分，<a class="ae jd" rel="noopener" href="/@akiboy96/community-detection-network-analysis-of-the-stock-market-in-python-r-part-3-ca4e0fbb8ca9"><strong class="ih hj"/></a><strong class="ih hj">。</strong>现在我们有了股票社区，我们可以使用<strong class="ih hj"> Louvain </strong>算法中的中心性和模块性指标，在下一部分<a class="ae jd" rel="noopener" href="/@akiboy96/community-detection-network-analysis-of-the-stock-market-in-python-r-part-3-ca4e0fbb8ca9">中更有效地理解和选择股票。</a></p><blockquote class="ls"><p id="ccf5" class="lt lu hi bd lv lw lx ly lz ma mb jc dx translated">整个架构如下图所示，以使生活更轻松。所有这些的代码库也可以在<a class="ae jd" href="https://www.kaggle.com/akiboy96/stock-network-analysis" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到:</p></blockquote><figure class="md me mf mg mh jj er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mc"><img src="../Images/72380ce2331f91397614a861343b9127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0XOUSFjzBgfPO83DU7xzQ.png"/></div></div></figure></div></div>    
</body>
</html>