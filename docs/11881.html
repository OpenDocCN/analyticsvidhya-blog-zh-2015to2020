<html>
<head>
<title>Dynamic Programming with OpenCV : Implementing Kadane’s Algorithm to find brightest area on Astronomical images and videos.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV动态编程:实现Kadane的算法在天文图像和视频上寻找最亮的区域。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dynamic-programming-with-opencv-implementing-kadanes-algorithm-to-find-brightest-area-on-9fe6e9af38d4?source=collection_archive---------12-----------------------#2020-12-22">https://medium.com/analytics-vidhya/dynamic-programming-with-opencv-implementing-kadanes-algorithm-to-find-brightest-area-on-9fe6e9af38d4?source=collection_archive---------12-----------------------#2020-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dee715596120d38ed8e2136a47f76bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*QZqNG-wk162w7HoPkDleTA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">基本天文图像</figcaption></figure><p id="0aa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都遇到过各种OpenCV库，并使用它们来获得图像上最亮的区域或点。显然，我们在OpenCV中有cv2.minMaxLoc(…)来做这件事并获得我们的位置。但是你有没有想过我们是否可以为这种方法采用一种动态编程方法。</p><blockquote class="jo jp jq"><p id="a27d" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">这个问题在算法中被称为最大连续子阵列和。我们通常有一个一维数组，并被要求找出该数组所有子数组中可能的最大和。我们可以使用蛮力方法在O(n)次内解决它，或者使用分治法在O(log n)次内得到它。对于我们的方法，我们将使用动态规划来在O(n)时间内得到它。</p></blockquote><p id="4848" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谈到我们的问题，我们有一个图像，我们可以使用OpenCV方法读取，我们处理图像，从中获得一个2D数组。</p><p id="5238" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不能直接将数组输入到Kadane的算法中，因为在我们读取图像后，我们不会得到一个2d数组，它将具有更高的像素速率，这在Kadane的算法中会运行得非常慢。因此，我们首先将其整形为较小的矩阵，比如(150，150)形状。请注意，我们减少的越多，完成过程的速度就越快。注意到150平均花费2秒。如果我们达到100，我们可以在0.7秒内得到，但是精度会降低。所以越高越好，因此我们必须平衡时间和像素尺寸。150似乎工作得很好，很快就能得到结果。接下来，我们对数组进行灰度处理，使数组变成2d形状。重要的是要注意，我们有int8类型的矩阵，因此值永远不会为负，但在Kadane的中，我们也需要负的，以获得正确的最大和面积，否则我们可能最终检测到整个数组作为和。所以我们把它们转换成int16。我们只是使用高斯模糊来平滑数组，然后用最大值减去数组的所有值，再加1。这种解决方案非常有帮助，当它想要得到最亮点的准确面积。接下来，我们将这个数组传递给一个函数，用于Kadane的算法处理。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="1792" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将这个矩阵传递给一个名为findMaxSum的函数，这个函数将给出最大的和以及相应的坐标。这个函数的工作原理是将矩阵列传递到Kadane的函数中，然后进行比较并获得最大和。代码如下所示:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="ab55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了深入理解函数的工作原理，我生成了一个3 * 3矩阵的例子。此链接将指导您实时了解每个代码的工作原理:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="dc70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，一旦我们使用Kadane的算法通过了它，我们将获得我们的最高和，以及与之对应的坐标。因为我们想指出图像上最亮的区域，所以我们需要把它圈起来。因此，为了找到坐标，我们必须对finalbottom和finaltop以及finalleft和finalright取平均值。这给了我们中心。</p><p id="a906" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的想法是调整图像的大小，但是我们知道一旦我们调整了大小，图像的质量就会大幅度下降。所以这里的技巧是使用比例的概念，当图像被转换成一个特定的更大的像素时得到坐标。因此，这里我们基本上再次调用原始图像，并找到相对于在调整大小的图像上生成的图像的坐标。</p><p id="143a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成后，我们使用cv2.circle函数在图像最亮的地方画一个圆。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="a460" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们最终得到的图像是这样的:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es kb"><img src="../Images/419891f9ff39814909f9498158fcba8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InJztI5P7Jdq9qcYfkBr9g.png"/></div></div></figure><p id="bbeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以使用相同的概念，并运行它来获得视频中最亮的区域。下面给出了图像和视频的代码，如果你能找到更好的优化或有疑问，请随时开始回购并帮助我:</p><div class="kg kh ez fb ki kj"><a href="https://github.com/Siddharth1698/Image-Processing-to-find-the-brightest-area-in-Astronomical-image-and-video-using-Kadane-s-Algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="kk ab dw"><div class="kl ab km cl cj kn"><h2 class="bd hj fi z dy ko ea eb kp ed ef hh bi translated">悉达多1698/图像处理-使用Kada找到天文图像和视频中最亮的区域…</h2><div class="kq l"><h3 class="bd b fi z dy ko ea eb kp ed ef dx translated">使用Kadane的算法寻找天文图像中最亮的区域。使用最大连续概念…</h3></div><div class="kr l"><p class="bd b fp z dy ko ea eb kp ed ef dx translated">github.com</p></div></div><div class="ks l"><div class="kt l ku kv kw ks kx ik kj"/></div></div></a></div></div></div>    
</body>
</html>