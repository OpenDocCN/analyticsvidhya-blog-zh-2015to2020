<html>
<head>
<title>More DataFrame Manipulation using Pandas — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pandas操作更多数据帧—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dataframe-manipulation-using-pandas-part-i-c4e95abfbed5?source=collection_archive---------11-----------------------#2020-12-14">https://medium.com/analytics-vidhya/dataframe-manipulation-using-pandas-part-i-c4e95abfbed5?source=collection_archive---------11-----------------------#2020-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f66321e20930be5b1307c352a8e55e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBwgeqgE7IqsC3W1ozLbBg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="f754" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在几个月前发表了第一篇博客，命名为“<a class="ae js" rel="noopener" href="/me/stats/post/221e12db08b6">使用Pandas </a>的基本数据帧操作”，在这篇博客中，我试图给出一些提示并展示我经常使用的简短工作流程。大部分内容(如果不是全部的话)是为初学者准备的，所以我决定再写一篇，用稍微复杂一点的函数和方法，我把它分成两部分，这样就不会让一篇超长的博客冗长乏味。</p><p id="e8af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将再次尝试这样做，从创建我自己的数据框架(df)开始，然后尽可能多地使用它，试图将它保持在最高中级水平。稍后，在这篇博客的第一部分和第二部分发表后，我将集中精力在一个有真实数据的项目之后写一篇文章。</p><p id="7f21" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我将涉及的内容如下:</p><ol class=""><li id="4888" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">从字典创建数据帧</li><li id="2fc9" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">配置和设置</li><li id="013c" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">组合数据帧</li><li id="e3be" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">重塑您的数据框架</li><li id="9b18" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用日期时间模块</li><li id="c1ae" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用groupby()方法/函数</li><li id="3f1c" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">切片使用。loc和。iloc</li></ol><p id="fa9f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果当我完成第二部分的时候，我发现水平不够高，那么我会修改这个内容，并在这个博客中编辑它，这样它们就都是连贯的。</p><p id="5125" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我是一个超级篮球迷，我将再次使用NBA的数据，但这一次我将从2019-2020年最近结束的赛季中获取统计数据，我将使用前25名得分手。说完这些，让我们直接进入内容。</p><p id="d08b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 1。从字典创建数据帧</strong></p><p id="8037" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我看来，用篮球数据列表来创建数据框架最简单的方法是通过字典，当然前提是你不需要处理大量的列表。如果您有大型数据集，这显然不是创建df的最有效的方法，但是对于25行(每个玩家一行)这样的小数据集，这就行了。</p><p id="1028" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以在下面的要点中看到，我从<a class="ae js" href="https://www.nba.com/stats/players/traditional/?DateFrom=12%2F12%2F2020&amp;DateTo=12%2F12%2F2020&amp;PerMode=Totals&amp;sort=PTS&amp;dir=-1" rel="noopener ugc nofollow" target="_blank"> NBA </a>主网页上创建了10个与球员名字相对应的列表和一系列统计数据。然后我创建了一个名为“stats”的字典，在这里我分配了键和值，键是我未来df的列/特性的名称。随后，我使用pandas DataFrame创建函数，并将我的输出命名为“nba”。在最后一行(17)你可以看到我已经调用了“25”。我这样做是为了能够看到将和我一起工作的25名球员。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">从一系列列表创建数据帧</figcaption></figure><p id="871c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行这段代码给了我名为“nba”的df，你可以在下面的图1中看到我选择的所有统计数据。在我上面分享的那个链接上，你会发现更多的信息，如果你想创建更大的数据框架，你可以手工抓取或复制这些信息。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/57156955a3e0932b097ed35b364549e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*ec8Ml99UeNTKt6_rM52ltA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图一。NBA 2019-2020年25名最佳射手数据框</figcaption></figure><p id="a694" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我不喜欢输出df的一个小细节，那就是索引起始编号(图1中最左边的一列)。默认情况下，它以“0”开头，但因为我使用的是顶级射手，所以给“詹姆斯·哈登”一个“0”而不是“1”感觉不太对。因此，我将修改它，从1开始，代码如下:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="b5f6" class="kt ku hi kp b fi kv kw l kx ky">df.index = df.index + 1</span></pre><p id="6085" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2。配置和设置</strong></p><p id="889f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我经常做的一件事是根据我运行的项目来配置我的数据框架。有时我想显示更多或更少的信息，或者我只想让我的所有数据框架在报告中看起来都一样。这样做很简单，我认为这是一个初学者水平，但我仍然会在这里补充，因为我没有在我以前的博客上这样做，这是我经常做的事情。</p><p id="ca5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你会发现在Pandas中，你有很多选择来定制你的数据框架。如果你想进一步探索的话，我会用例子来说明一些常见的，并给你留下这个<a class="ae js" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/options.html" rel="noopener ugc nofollow" target="_blank">链接</a>供你阅读。</p><p id="1617" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2.1最大行数&amp;最大列数</strong></p><p id="0361" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">设置行和列非常方便。例如，如果您有太多的行和/或列，您可以将最大数量设置为一个较大的数字，以便显示所有的行和/或列，或者相反，您可能只想看到其中的几行和/或列，如图2所示。如果不修改，默认设置为20。实现这一点的代码非常简单:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="d24e" class="kt ku hi kp b fi kv kw l kx ky">pd.set_option(‘display.max_rows’, 6, ‘display.max_columns’, 6)</span></pre><p id="f841" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里的限制是，如果您减少数字，那么您可能会丢失大量信息，因此这对于您希望保持整洁的报告或其他文档，或者当您非常熟悉您的数据框架时非常有用。</p><p id="9ccd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2.2精度</strong></p><p id="a01a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">精度设置输出数字显示小数。根据我们现有的数据，我们只有1位小数，所以让我们强制它为“0”，这样您就可以看到它的效果(图2):</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="c5f0" class="kt ku hi kp b fi kv kw l kx ky">pd.set_option(‘precision’, 0)</span></pre><p id="a0f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2.3尺寸</strong></p><p id="6629" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Dimension也是直截了当的，因为它在左下角打印出数据框的大小/形状(图2)。代码与前一个代码一样，但只有两个选项，即True或False调用:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="333c" class="kt ku hi kp b fi kv kw l kx ky">pd.set_option(‘show_dimensions’, True)</span></pre><p id="9ab2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2.4 max_colwidth </strong></p><p id="569d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这对应于Pandas数据结构的repr中一列的最大宽度。当列溢出时，输出中会嵌入一个“…”占位符(图2 ),您可能在拥有超过20列的df中见过这种情况。“无”值表示无限制。同样，代码非常简单:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="ef72" class="kt ku hi kp b fi kv kw l kx ky">pd.set_option(‘max_colwidth’, 8)</span></pre><p id="7114" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您所想象的，您不需要为您想要设置的每个参数/选项写一行，您可以像下面的要点所描述的那样，在一次调用中添加所有参数/选项，并且您所做的任何修改都可以通过使用下面的代码(在要点上方)重置回其默认值:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="a8f8" class="kt ku hi kp b fi kv kw l kx ky">pd.reset_option(‘^display’)</span></pre><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据帧选项设置要点</figcaption></figure><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/38c7bd73c98263b6a9bf1f55887c5634.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*34ZyQPbpurWO13oNrpaJ-A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图二。数据帧，参数设置为最多6列和6行，无小数，显示形状在左下角，最大列宽为8。行号也被修改为从1开始。</figcaption></figure><p id="a0c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">图2显示了我们上面设置的所有选项的输出。请记住，如果您想要遵循这个工作流，您将需要在这一点上重置_options，以便您保留默认参数，并可以遵循我将使用的其余方法。</p><p id="52d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 3。组合数据帧</strong></p><p id="3cb5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了Pandas，在join/merge类型的操作中，有各种方法可以轻松地将带有不同类型的集合逻辑索引和关系代数功能的数据帧组合在一起。让我们来看看我认为最有用的三个:</p><p id="a532" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 3.1拼接</strong></p><p id="a7a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">串联可能是最常用的一种，它可以被视为一种简单的堆叠，可以水平或垂直进行。为了向您展示它是如何真正工作的，我创建了适合目的的单独的数据帧，用于“连接”以及“合并”和“附加”。我将在每个方法中添加一个要点，这样您也可以从原始方法中重新创建它们，从下面的要点开始，这将为您提供如图3所示的数据框架。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">为连接练习创建数据帧</figcaption></figure><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es la"><img src="../Images/54cf7dcc636976a18df6cff78a36b577.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*canQv30DMJbbXPtzLpL05Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3。通过对原始数据帧切片而创建的两个数据帧。上面的对应nab_1，下面的对应nba_2</figcaption></figure><p id="c36f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用下面的代码垂直连接nba_1和nba_2相当简单:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="f87d" class="kt ku hi kp b fi kv kw l kx ky">nba_1_2 = pd.concat([nba_1, nba_2], axis = 0)<br/>nba_1_2.head()</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/f53c97e67dab2dadc70592264d0068d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*9SOwv-yUtC7lS6tcinVO1w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4。通过垂直连接nba_1和nba_2得到的数据帧</figcaption></figure><p id="d8dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们已经看到了垂直连接是如何完成的，让我们看看水平连接，它基本上是相同的代码。再一次，下面你会发现要点和必要的代码来重现我将使用的数据帧，如图5所示。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="be85" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您查看图5中的数据帧，您会发现好像我把它分成了两个独立的部分。事实上，这就是我使用上述要点中的切片所做的。因此，水平连接它们(下面的代码)，基本上将它们重新连接在一起，如图6所示。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/d119886bb9ce56de587d763efbefe50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*sRZa_49D-mGMT2kLfnOYUg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图5。通过切片创建的数据帧，用于水平连接练习。左图对应nba_3，右图对应nba_4</figcaption></figure><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="52d3" class="kt ku hi kp b fi kv kw l kx ky">nba_3_4 = pd.concat([nba_3, nba_4], axis=1)<br/>nba_3_4.head()</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/221a94a7eba5bbe6f6c6fdbd6570ebd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*-ylsolNQ9JG--AZzArA_Zw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图6。水平连接nba_3和nba_4的结果</figcaption></figure><p id="bcf6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 3.2合并</strong></p><p id="fab8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">连接是简单直接的，现在合并稍微困难一些，但是也更强大。为此，您需要在两个数据框架之间使用一个公共属性/特征作为连接点。在许多情况下，如果两者都不存在，你甚至可能不得不设计它。</p><p id="07d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面是为合并重新创建数据帧的要点，正如您所看到的，它们都有一个共同的列“NAME”。图7和图8显示了合并后的输出。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es le"><img src="../Images/426cfdefd462a13a98cf4a397b20fb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*oH_lLtn8_cj0YVT1Oh5sFw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图7。为合并练习创建的数据帧。左一对应nba_6，右一对应nba_7。</figcaption></figure><p id="674c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的代码中，为了合并数据帧，您会注意到有三个参数需要填写。第一个是将在左边的df，第二个是右边的df，第三个对应于用作连接点/列名的内容。</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="b1db" class="kt ku hi kp b fi kv kw l kx ky">nba_8 = pd.merge(left=nba_6, right=nba_7, on=’NAME’)<br/>nba_8.head()</span></pre><p id="66d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">图8显示了合并输出，正如您所看到的，它们已经使用“NAME”列合并，并且考虑到了所选择的左右df输入。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es la"><img src="../Images/b0e2a618d08299ccf810021dd41800d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*5TpRHLirJT4ah-t13CSqfg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图8。合并nba_6和nba_7的输出</figcaption></figure><p id="d615" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 3.3追加</strong></p><p id="498f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">连接和合并非常简单，只要您不需要为合并设计您的“连接”,但是。append()可能是最简单的。“append()”用于将其他数据帧的行附加到给定df的末尾，返回新的df。如果碰巧有一列不在您试图追加的行中，那么这些行将被填充NaN值(图9)。</p><p id="950a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，我不会添加要点，因为与前几个一样，您将能够重新创建所需的数据框架。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es le"><img src="../Images/238c4e636d0f165e7f45941b2b86bfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*3mZrmvJq1SJ4gH6OPjrMng.png"/></div></figure><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/3a0ff555255d8afda974192c861e297c.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*bAjMmCmIyhUIT2UHLbM-dg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图9。要附加的数据帧(左右两边)和结果数据帧(下面)</figcaption></figure><p id="f81f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">追加的代码可能是最简单的一个(如下)。你选择了你的输出名(nba_11)，然后选择了上面的df (nba_9)和下面的df (nba_10)</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="eecb" class="kt ku hi kp b fi kv kw l kx ky">nba_11 = nba_9.append(nba_10)<br/>nba_11</span></pre><p id="601d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 4。重塑您的数据框架</strong></p><p id="8d29" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有几种方法可以重塑df，使之比其他的更复杂、更强大。我将再次集中讨论我最常用的四种，如果你想了解更多信息，我建议你浏览这个<a class="ae js" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="b6b9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">和前面的例子一样，我创建了更小的数据框架来分别显示每个整形函数/方法的效果。</p><p id="f17e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 4.1通过熔化进行整形()</strong></p><p id="1fcc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个非常有趣的函数，它将df转换成一种格式，其中一列或多列是标识符变量，而其他列则与行轴分离，留下一两个非标识符列“变量”和“值”。如果您愿意，可以像我一样重命名这些新列(变量和值)(代码如下)</p><p id="a4c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我将原始的nba df切片并向您展示它的输出(图10):</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="9dd0" class="kt ku hi kp b fi kv kw l kx ky">nba_12 = nba.iloc[0:3, 0:5]<br/>nba_12.head(3)</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/4753f8ed93ecbe966f5a611850406b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*3La6EbAH7iu-QseG8u5gyw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图10。从原来的nba中切下了减少的df</figcaption></figure><p id="a4b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了上面的df(图10 ),我将选择保留变量“NAME”和“POS ”,并融合其余的。我还将变量和值的名称分别改为“Stats”和“Values”(参见下面的代码)。结果如图11所示。</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="2859" class="kt ku hi kp b fi kv kw l kx ky">nba_12 = nba_12.melt(id_vars=[‘NAME’, ‘POS’], var_name=’Stats’, value_name=’Values’)</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/8db88b28adb9af89ef667133f7590fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*0uPkaVZ0TBddhbz7pQ6BLQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图11。图10中熔化数据帧的结果</figcaption></figure><p id="9e34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如你所看到的，融合把3个属性加到了1个，我们现在得到了一个相当大的df，但是所有的属性都在一个栏里。</p><p id="dbdd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 4.2通过枢轴整形()</strong></p><p id="ab2d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Pivot是重塑数据帧最常用的函数之一，也是我最喜欢的函数之一。基本上它所做的是在两个维度上聚合。在我们应用melt()后创建的例子中，pivot变得非常方便。在这种情况下，它将允许我们重组“Stats”列中描述的那些类别，并重新组织df。</p><p id="1496" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">应用透视非常简单，您需要定义新的“索引”、“列”和“值”，如下面的代码所示:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="7b75" class="kt ku hi kp b fi kv kw l kx ky">nba_13a = nba_12.pivot(index=’Stats’, columns=’NAME’, values=’Values’)</span></pre><p id="94ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出如图12所示</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es li"><img src="../Images/173ba41e8a48502369e5822c93be6822.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*lypES-IFcfCBqmVLyBkQ5g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图12。旋转由上一练习中的熔化()产生的df的结果</figcaption></figure><p id="0389" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我相信您已经注意到，您可以轻松地使用您的索引、列和值，并以非常高效和快速的方式做有趣的事情。有了支点，如果你愿意，你可以很容易地进行转置。请看图13，这次我不会给出答案，因为它非常简单。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/b6f9dac8f4f8d671ded985440795a873.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*d2J8WPPfo1G_sbvtBrArRg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图13。由熔化产生的旋转df的不同结果()</figcaption></figure><p id="ad47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 4.3通过堆叠和拆堆进行整形</strong></p><p id="a190" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">stacking()和unstacking()方法与pivot()方法密切相关。stacking()旨在与多索引对象协同工作。堆叠旋转一级列标签，返回一个带有新的最内层行标签索引的df，而拆分则是相反的操作，它旋转生成一个带有新的最内层列标签的整形df。</p><p id="f8a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个练习中，让我们用下面的代码从原来的new df中切割出一个新的df(输出如图14所示):</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="5259" class="kt ku hi kp b fi kv kw l kx ky">nba_14 = nba.iloc[0:5, 0:4]</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/3d12b520cbe739a62d6f99f6b5a15ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*A7LUbJ_0u-9_Xy-12Tx4-w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图14。从原来的nba联盟中切割出新的df</figcaption></figure><p id="23f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">堆叠这个df非常简单，如下面的代码所示(结果如图15所示):</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="ef37" class="kt ku hi kp b fi kv kw l kx ky">nba_14_stack = nba_14.stack()</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/74946ad746cc559c8a2c86e413b719d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*--xAtfa7tL6LWsmZGG2txw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图15。图14显示了叠加测向的结果。</figcaption></figure><p id="6376" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以看到，它基本上分解了每个球员/名字的所有统计/类别，并做出了完全不同的显示(图15)。恢复这一点很容易，我相信你可以想象…我们如何使用' unstack()'方法(代码如下)。我不会显示结果，因为它们与图14中显示的结果相同。</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="d168" class="kt ku hi kp b fi kv kw l kx ky">nba_14_unstacked = nba_14_stack.unstack()</span></pre><p id="18af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 4.4通过转置进行整形</strong></p><p id="f1ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">移调一个df非常有用，甚至比之前所有的方法都简单。你只需要用字母“T”或者。转置()。下面的代码显示了一个df是如何从原来的nba中切分出来的，以及它是如何使用T转置的(图16)。</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="ea0c" class="kt ku hi kp b fi kv kw l kx ky">nba_15 = nba.iloc[0:10, :]<br/>nba_15 = nba_15.set_index(‘NAME’)<br/>nba_15 = nba_15.T # or nba_14.transpose()</span></pre><figure class="kh ki kj kk fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/4d8af5ed85d6ae833714db04186c7889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*xP38_dwPbO6YyLRytm-hmg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图16。将nba原始数据切片生成的df进行移调的结果</figcaption></figure><p id="0faf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">转置的结果基本上是轴的改变，其中列名随着新定义的索引(“名称”)改变了位置。如果我没有定义一个新的索引，你将会用默认的数字索引来代替你的列名。</p><p id="124a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是操作数据帧的第一部分。我希望你喜欢这个。一如既往，如果您有任何反馈或问题，或者甚至有任何您想在第二部分看到的内容，请随时给我发消息，我希望从现在起一周内可以发布。这是我的<a class="ae js" href="https://www.linkedin.com/in/jaherbas-ds-geophysicist/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae js" href="https://github.com/JaHerbas/Working-with-DataFrames---Part-II" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，在这里你会发现更多我玩过的东西。</p></div></div>    
</body>
</html>