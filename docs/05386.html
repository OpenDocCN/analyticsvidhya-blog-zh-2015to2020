<html>
<head>
<title>Transfer Learning in Deep Learning using keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于keras的深度学习中的迁移学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/transfer-learning-in-deep-learning-using-keras-b12e0ca6c459?source=collection_archive---------22-----------------------#2020-04-19">https://medium.com/analytics-vidhya/transfer-learning-in-deep-learning-using-keras-b12e0ca6c459?source=collection_archive---------22-----------------------#2020-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d11a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迁移学习是一种机器学习技术，其中在一个任务上训练的模型被重新用于第二个相关的任务</p><p id="a965" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深度学习中，迁移学习是一种技术，通过这种技术，神经网络模型首先针对与正在解决的问题类似的问题进行训练。然后，来自训练模型的一个或多个层被用在针对感兴趣的问题训练的新模型中。</p><p id="5dc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1)开发模型方法</strong><br/>T3】选择源任务</p><p id="9170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您必须选择具有大量数据的相关预测建模问题，其中输入数据、输出数据和/或在从输入数据到输出数据的映射过程中学习到的概念之间存在某种关系。</p><p id="5c9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">开发源模型</em></p><p id="0f40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，你必须为第一个任务开发一个熟练的模型。该模型必须比天真的模型更好，以确保已经执行了一些特征学习。</p><p id="7380" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">重用模型。</em></p><p id="d409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，源任务上的模型拟合可以用作感兴趣的第二个任务上的模型的起点。这可能涉及到使用模型的全部或部分，这取决于所使用的建模技术。</p><p id="4633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">调谐模式。</em></p><p id="c5a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可选地，该模型可能需要根据可用于感兴趣的任务的输入-输出对数据进行调整或改进。</p><p id="e7b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)预训练模型方法</strong> <br/>选择源模型。</p><p id="3638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从可用模型中选择预训练的源模型。许多研究机构发布大型和挑战性数据集上的模型，这些数据集可能包含在候选模型池中以供选择。</p><p id="f5b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">重用模型。</em></p><p id="a6af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，模型预训练模型可以用作感兴趣的第二任务的模型的起点。这可能涉及到使用模型的全部或部分，这取决于所使用的建模技术。</p><p id="4a38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">调模型。</em></p><p id="48db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可选地，该模型可能需要根据可用于感兴趣的任务的输入-输出对数据进行调整或改进。</p><p id="dd2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以将其中一些使用模式总结如下:</p><p id="7995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1)分类器:</strong>预先训练好的模型直接用于对新图像进行分类。<br/> <strong class="ih hj"> 2)独立特征提取器:</strong>预训练的模型或模型的某一部分，用于预处理图像并提取相关特征。<br/> <strong class="ih hj"> 3)集成特征提取器:</strong>预训练模型或模型的某个部分被集成到新模型中，但是预训练模型的层在训练期间被冻结。<br/> <strong class="ih hj"> 4)权重初始化:</strong>将预训练模型或模型的某个部分集成到新模型中，并且与新模型一致地训练预训练模型的层</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/dd2a2a3f00b521328048f51dfa048e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cX9pzef150TB7Lzf17B2pg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">让我们以蚂蚁图像为例，使用迁移学习对其进行分类</figcaption></figure><p id="8d44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> VGG16 </strong> (include_top=True，weights='imagenet '，input_tensor=None，input_shape=None，pooling=None，classes=1000)默认参数</p><p id="2ee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> include_top (True): </strong>是否包含模型的输出层。如果您正在根据自己的问题拟合模型，则不需要这些。<br/> <strong class="ih hj">权重(' imagenet'): </strong>加载什么权重。如果您对从头开始训练模型感兴趣，可以指定<strong class="ih hj"> None </strong>不加载预训练的权重。<br/><strong class="ih hj">input _ tensor(None):</strong>一个新的输入层，如果你想让模型适合不同大小的新数据。<br/><strong class="ih hj">input _ shape(None):</strong>如果改变输入层，模型预期拍摄的图像尺寸。<br/> <strong class="ih hj">池化(无):</strong>训练一组新的输出层时使用的池化类型。当<code class="du ju jv jw jx b">include_top</code>为<code class="du ju jv jw jx b">False</code> <br/> <strong class="ih hj">类时，用于特征提取的可选池模式(1000): </strong>模型的类的数量(如输出向量的大小)，仅当<code class="du ju jv jw jx b">include_top</code>为<code class="du ju jv jw jx b">True</code>时指定，且未指定<code class="du ju jv jw jx b">weights</code>参数时指定。</p><ol class=""><li id="886e" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated"><strong class="ih hj">分类器:</strong></li></ol><p id="f8a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预先训练的模型可以直接用于将新照片分类为图像分类中的1，000个已知类别之一</p><p id="f1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用VGG16，它预计图像大小为224*224</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kh"><img src="../Images/b1d801a1c1cbcac2f19327c21e443702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDaNOAYno2AfN-PYiDABuQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">VGG16(include_top=True，weights='imagenet '，input_tensor=None，input_shape=None，pooling=None，classes=1000)默认参数</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ki"><img src="../Images/8d25abfb88d9cf3411ba7f11f0e9007f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*zGshnieE9YqgF7aLf8Z3iQ.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">我们的keras模型在没有任何训练的情况下以91.98的准确度将图像分类为蚂蚁</figcaption></figure><p id="c1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)作为特征提取器预处理器的预训练模型:</strong></p><p id="ecd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预训练模型可用于提取新图像的特征。然后，这些特征可以用作新模型开发中的输入。</p><p id="3eec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">VGG16模型的最后几层是输出层之前的完全连接层。这些层将提供一组复杂的特征来描述给定的输入图像，并且可以在训练用于图像分类或相关计算机视觉任务的新模型时提供有用的输入。</p><p id="33ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">手动移除最终输出图层。这意味着具有4，096个节点的倒数第二个完全连接的层将是新的输出层。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f259b75153087cab07e7b1c95442f4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kcvl6bVUIJHGmytRK3-EUg.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kj"><img src="../Images/c5411a68e997fbc44bee2a271ec0485f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*8h2Ki-VdPjKtOejrRmhenw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">如果与先前的模型概要<strong class="bd kk">预测进行比较，则</strong>层缺失，特征向量大小为<strong class="bd kk"> 4096 </strong>，并且可以对新的训练数据集中的每张照片重复该过程，以获得每张照片的特征</figcaption></figure><p id="046d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3)预训练模型作为模型中的特征提取器:</strong></p><p id="e3f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以直接使用预训练模型中的一些或所有层作为新模型的特征提取组件。</p><p id="a0fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过加载模型，然后简单地添加新层来实现。这可能涉及添加新的卷积层和池层以扩展模型的特征提取功能，或者添加新的全连接分类器类型层以了解如何解释新数据集上的提取特征，或者进行某种组合。</p><p id="10c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以通过将"<em class="jd"> include_top </em>"参数指定为"<em class="jd"> False </em>"来加载没有模型分类器部分的VGG16模型，并将新数据集中图像的首选形状指定为300×300。</p><p id="c0ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:<strong class="ih hj"> input_shape </strong>可选形状元组，仅在<code class="du ju jv jw jx b">include_top</code>为<code class="du ju jv jw jx b">False</code>时指定(否则输入形状必须为<code class="du ju jv jw jx b">(224, 224, 3)</code></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kl"><img src="../Images/122c929a7cd2eca0c249b7d9fe90906d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*PuYlI4JL7DLZ-z9PI0uK8Q.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">在这里，我们移除了VGG16中的展平层、密集层和输出层(通过给include_top=False ),并创建了我们自己的层</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es km"><img src="../Images/2104bb3bd98fca4a44bb72c29520d260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*GoDix7XDNQ7W8hLvMmHHew.png"/></div></figure><p id="cf53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们可能希望使用VGG16模型层，但训练模型的新层，而不更新VGG16层的权重。这将允许新的输出层学习解释VGG16模型的学习特征。</p><p id="d1fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过在训练之前将加载的VGG模型中的每个层上的“<em class="jd">可训练的</em>”属性设置为假来实现。例如:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kn"><img src="../Images/ead7759a878a7dc3d10ddcaecc3e33f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfLVxZ0hH0SpWWHvKFdf-w.png"/></div></div></figure><p id="6e4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以挑选哪些层是可训练的。</p><p id="5773" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，您可能希望重新训练模型中较深的一些卷积层，但不训练模型中较早的层。例如:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ko"><img src="../Images/4b83c81329cebe1d22890c2e289d6bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*-dmBjuBhbweVaDJo-u_H6w.png"/></div></figure><p id="5d8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何在用于迁移学习的keras中更改图像的输入形状尺寸</strong></p><p id="c082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常我们认为卷积神经网络接受固定大小的输入(即<em class="jd"> 224×224 </em>、<em class="jd"> 227×227 </em>、<em class="jd"> 299×299 </em>等)。)</p><p id="da1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么您可能想要利用不同的图像尺寸？</p><p id="ce86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两个常见的原因:</p><ul class=""><li id="4a8d" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kp ke kf kg bi translated">你的输入图像尺寸<strong class="ih hj"> <em class="jd">比CNN训练的</em> </strong>要小得多，增加它们的尺寸会引入太多的伪像，并极大地损害损失/准确性。</li><li id="01a1" class="jy jz hi ih b ii kq im kr iq ks iu kt iy ku jc kp ke kf kg bi translated">您的图像是<strong class="ih hj"> <em class="jd">高分辨率</em> </strong>并且包含难以检测的小物体。调整到CNN的原始输入尺寸会损害准确性，你假设增加分辨率将有助于改善你的模型。</li></ul><p id="2a85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Keras中，您可以通过<strong class="ih hj"> input_tensor (None): </strong>一个新的输入层来更改用于迁移学习的输入图像尺寸，如果您想要在不同大小的新数据上拟合模型的话。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="ab fe cl kv"><img src="../Images/742ff71059f735a70f5a56511c0b77af.png" data-original-src="https://miro.medium.com/v2/format:webp/1*38ZsNJyDFsL8uojkuMoNRA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">VGG16带有224*224*3通过使用input_tensor您可以将图像尺寸更改为128*128*3</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kw"><img src="../Images/1fc61eef3c7e062e11f3a7d5dc436d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z1F3oZBTR6DGAZYi8HkVlA.png"/></div></div></figure><p id="7529" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果您的输入图像尺寸太小，那么CNN会在向前传播期间自然减少体积尺寸，然后有效地“用完”数据。</p><p id="2102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，当使用<em class="jd"> 48×48 </em>输入图像时，我收到了以下错误消息:</p><p id="916a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Keras更改输入形状尺寸以进行微调</p><p id="a6ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ValueError </strong>:输入shapes: [？,1,1,512].</p><p id="fc6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献:</strong></p><div class="kx ky ez fb kz la"><a href="https://machinelearningmastery.com/how-to-use-transfer-learning-when-developing-convolutional-neural-network-models/" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">基于计算机视觉模型的Keras迁移学习——机器学习掌握</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">深度卷积神经网络模型可能需要几天甚至几周的时间在非常大的数据集上进行训练。一种方法…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">machinelearningmastery.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jo la"/></div></div></a></div><p id="3613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lp" href="https://www.pyimagesearch.com/2019/06/24/change-input-shape-dimensions-for-fine-tuning-with-keras/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2019/06/24/change-input-shape-dimensions-for-fine-tuning-with-keras/</a></p></div></div>    
</body>
</html>