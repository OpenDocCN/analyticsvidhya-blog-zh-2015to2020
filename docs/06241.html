<html>
<head>
<title>Trees, Trees and More Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树，树和更多的树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/trees-trees-and-more-trees-4d31c62b8d71?source=collection_archive---------24-----------------------#2020-05-15">https://medium.com/analytics-vidhya/trees-trees-and-more-trees-4d31c62b8d71?source=collection_archive---------24-----------------------#2020-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/30d16224d98c8cbfc27fc5e9d2319288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*yea9K4Uxo-aFTsuTREGj-w.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:<a class="ae iq" href="https://xkcd.com/835/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/835/</a></figcaption></figure><p id="fe54" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Arrays</em></strong></code>、<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Stacks</em></strong></code>、<em class="jt">、</em>、<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Linked-List</em></strong></code>和<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Queue</em></strong></code>，都有一个共同点:数据结构的逻辑起点和终点，这些被认为是“线性的”然后我们到达<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Trees</em></strong></code> <em class="jt">，</em>一个巨大的分支混乱，没有明确的结尾，并且有一种非常特定的方式来存储数据，这引发了各种各样的混乱。</p><p id="d0b6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们将一起澄清任何关于树木的困惑，激发更多使用树木的信心。</p><p id="c5db" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们开始吧！</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="885b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是树？</h1><blockquote class="kz la lb"><p id="97e2" class="ir is jt it b iu iv iw ix iy iz ja jb lc jd je jf ld jh ji jj le jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="hi">Tree</em></strong></code>是一种广泛使用的抽象数据类型(ADT)——或实现这种ADT的数据结构——它模拟一种分层的<code class="du jp jq jr js b"><strong class="it hj">tree</strong></code>结构，具有<code class="du jp jq jr js b"><strong class="it hj">root</strong></code>值和带有<code class="du jp jq jr js b"><strong class="it hj">parent node</strong></code>的<code class="du jp jq jr js b"><strong class="it hj">children</strong></code>子树，被表示为一组非线性链接的<code class="du jp jq jr js b"><strong class="it hj">nodes</strong></code>。—<a class="ae iq" href="https://computersciencewiki.org/" rel="noopener ugc nofollow" target="_blank">https://computersciencewiki.org/</a></p></blockquote><p id="ebca" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我知道，我知道，有很多要理解，所以让我们一起来分析一下:</p><p id="ba6b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">抽象数据类型(ADT)，</strong>其行为由一组值和一组操作定义的对象。简而言之，它们是<strong class="it hj"><em class="jt"/></strong>执行的是什么操作vs<strong class="it hj"><em class="jt"/></strong><em class="jt"/>一个操作是如何实现的。这意味着它可以应用于你需要它代表的任何东西；在这种情况下，一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">tree</em></strong></code>可以代表:一个家庭，一个流程图，甚至一个故事。</p><p id="8e29" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我们来看最难的部分:什么是树的技术细节，但是不要担心，最容易理解的方法是通过可视化。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/8f06fc8210675747240bf4aa04f97492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*w-zjteTvYm2ir5VPn7TSUQ.png"/></div></figure><p id="463d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">想象一棵绿色的大松树。树的顶端是第一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>，然后随着我们越往下，第一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node </em></strong></code>分支到另一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">nodes</em></strong></code>，我们在树上越往下，它就变得越大。</p><p id="9a7f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">就像树叶用树枝连接到其他树叶一样，这些节点用树枝连接到其他节点，你猜怎么着？树枝！这就是树的极端简单性:<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">leaves</em></strong></code>、<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">branches</em></strong></code>和<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">nodes</em></strong></code></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="ceb2" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">树的属性</h1><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/fad6333f5190a22dd5f2af4ac2b4ce5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wrw9Pwo3e3yJIxyQMk1DmA.png"/></div></div></figure><p id="b186" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">每个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>包含一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">value</em></strong></code>或<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">data</em></strong></code>，可以有也可以没有<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">child</em></strong> <strong class="it hj"><em class="jt">node</em></strong></code>。<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Nodes</em></strong> </code>由<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">edges</em></strong></code>管理并相互连接。</p><p id="1970" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">tree</em></strong></code>中用蓝色表示的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">first node</em></strong></code><em class="jt">称为<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">root</em></strong></code>。如果这个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">root</em></strong> <strong class="it hj"><em class="jt">node</em></strong></code>由另一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>连接，那么<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">root</em></strong></code>既是一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">parent node</em></strong></code>，连接的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>是一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">child</em></strong></code>。每个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>的这种精确格式在每个深度级别中被进一步遵循，相反，它们表示<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">parent node</em></strong></code>。这些孤立的集合是子树[ <em class="jt">用红色</em>表示]。</em></p><p id="dbeb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">绿色的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Leaves</em></strong></code><em class="jt"/>是<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">tree</em></strong></code> <strong class="it hj"> <em class="jt">上的最后一个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">nodes</em></strong></code>。</em> </strong>它们是没有<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">children</em></strong></code>的节点。</p><p id="39f3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然后我们有了最后两个属性:<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Height</em></strong></code>和<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Depth</em></strong></code>。<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">tree</em></strong></code>的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">height</em></strong></code>是到<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">leaf</em></strong></code>的最长路径的长度，<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">depth</em></strong></code>是到其<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">root</em></strong></code>的路径的长度。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/de33c697926dc90bf7d3ad6bff133b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmThRwOYJEC_8O3-ILsaLA.png"/></div></div></figure><h2 id="a72e" class="lq kc hi bd kd lr ls lt kh lu lv lw kl jc lx ly kp jg lz ma kt jk mb mc kx md bi translated">高度、深度和类型</h2><p id="40bd" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated">让我们试着一起找出树的不同部分。</p><p id="a43b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">100是什么类型的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code>？</p><p id="88b9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">什么是<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">height</em></strong></code> <strong class="it hj"> <em class="jt"> </em> </strong>之树？</p><p id="2d2c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code> <strong class="it hj"> <em class="jt"> </em> </strong> 60的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">depth</em></strong></code>是什么？</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mj"><img src="../Images/c386243237853910724df4c806719ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvWnsA9UegwxKLm1dzBwpw.png"/></div></div></figure><p id="4d59" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Node 100</em></strong></code>是第一个节点，因此它是一个根，也有节点与之相连，所以它也是一个父节点。</p><p id="f13f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">当我们从叶子向上数时，<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node 500</em></strong></code>的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">height</em></strong></code>是4。</p><p id="073d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node 60</em></strong></code>的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">depth</em></strong></code>是3倒数到叶子。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="f100" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">编码一棵树！</h1><p id="0049" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated">现在我们已经有了主要的抽象上下文，让我们开始实现我们自己的<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Tree</em></strong></code>，特别是<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">binary tree</em></strong></code>。</p><p id="b177" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Binary trees</em></strong></code>是<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">tree</em></strong></code>数据结构的最简单版本，您一直都可以看到它们！可以猜到<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">binary trees</em></strong></code>只允许两个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">node</em></strong></code> <code class="du jp jq jr js b"><strong class="it hj"><em class="jt">branches</em></strong></code>。具体来说，这两个<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">nodes</em></strong></code>就是属性<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">left</em></strong></code>和<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">right</em></strong></code>及其<code class="du jp jq jr js b"><strong class="it hj"><em class="jt">data</em></strong></code>。所以让我们试着创建一个二叉树类:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="314a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们像前面的例子一样，从100开始初始化前三个节点:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="cef6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我们可以继续做<code class="du jp jq jr js b">root.left.left(70)</code>等等来完成这个树，但是这不是太程序化了，不是吗？</p><h2 id="06e4" class="lq kc hi bd kd lr ls lt kh lu lv lw kl jc lx ly kp jg lz ma kt jk mb mc kx md bi translated">自动插入节点</h2><p id="02f6" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated">所以在我们的类中，让我们创建两个新的方法，命名为:<code class="du jp jq jr js b">insert_left</code>和<code class="du jp jq jr js b">insert_right</code>。之后，我们将检查适当的名称是否是<code class="du jp jq jr js b">None</code>，这样我们就可以在该点分配节点数据。否则，我们会将该节点重新分配给下一个节点，并再次检查，直到我们找到一个空节点。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="fdf5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在它工作了，试着创建上面描述的整个树。</p><p id="982e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">等等！</p><p id="8617" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们怎么知道它是否有效？“我甚至不能读取数据，”你一定在想，但这就是为什么我们有树遍历！</p><h2 id="e70f" class="lq kc hi bd kd lr ls lt kh lu lv lw kl jc lx ly kp jg lz ma kt jk mb mc kx md bi translated">树遍历</h2><p id="a20c" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated">在树遍历中，我们有三种类型，它们的优先级顺序如下:</p><ol class=""><li id="df2f" class="mm mn hi it b iu iv iy iz jc mo jg mp jk mq jo mr ms mt mu bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Post Order</em></strong></code>:左、右、根</li><li id="3ff2" class="mm mn hi it b iu mv iy mw jc mx jg my jk mz jo mr ms mt mu bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">Pre Order</em></strong></code>:根，左，右</li><li id="8aa3" class="mm mn hi it b iu mv iy mw jc mx jg my jk mz jo mr ms mt mu bi translated"><code class="du jp jq jr js b"><strong class="it hj"><em class="jt">In Order</em></strong></code>:左、根、右</li></ol><p id="c15a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">那就这么定了！</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="59e0" class="kb kc hi bd kd ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky bi translated">摘要</h1><p id="269d" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated">简而言之，这篇文章有助于阐明什么是树，它们的用途，方法，以及如何实现它们。本文还有助于理解如何对节点进行编程、插入和遍历。希望你所有的困惑都已经消除，或者你已经学到了一些新的东西。现在出去用那些树吧！</p><h2 id="40f3" class="lq kc hi bd kd lr ls lt kh lu lv lw kl jc lx ly kp jg lz ma kt jk mb mc kx md bi translated">互动链接:</h2><p id="7092" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated"><a class="ae iq" href="https://www.figma.com/file/cfniDAItfeYeOgphQGyFRa/Node-Tree-Tree-Tree?node-id=0%3A1" rel="noopener ugc nofollow" target="_blank">https://www.figma.com/embed?embed_host=share&amp;URL = https % 3A % 2F % 2fwww . fig ma . com % 2ff ile % 2fcfnidaitfeyeoegphqgyfra % 2f节点-树-树-树</a></p><h2 id="7448" class="lq kc hi bd kd lr ls lt kh lu lv lw kl jc lx ly kp jg lz ma kt jk mb mc kx md bi translated">来源:</h2><p id="659a" class="pw-post-body-paragraph ir is hi it b iu me iw ix iy mf ja jb jc mg je jf jg mh ji jj jk mi jm jn jo hb bi translated"><a class="ae iq" href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/tree-traversals-in order-preorder-and-post order/</a></p></div></div>    
</body>
</html>