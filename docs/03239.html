<html>
<head>
<title>Want to Generate your own Music using Deep Learning? Here’s a Guide to do just that!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想要使用深度学习生成自己的音乐吗？这里有一个这样做的指南！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/want-to-generate-your-own-music-using-deep-learning-heres-a-guide-to-do-just-that-dd35d6ddcd01?source=collection_archive---------21-----------------------#2020-01-21">https://medium.com/analytics-vidhya/want-to-generate-your-own-music-using-deep-learning-heres-a-guide-to-do-just-that-dd35d6ddcd01?source=collection_archive---------21-----------------------#2020-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="8048" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><ul class=""><li id="162d" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">了解如何开发用于自动音乐生成的端到端模型</li><li id="a6af" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">了解WaveNet架构，并使用Keras从头开始实现它</li><li id="9785" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">比较WaveNet与长短期记忆在建立自动音乐生成模型中的性能</li></ul><h1 id="5a24" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><blockquote class="ka"><p id="ef01" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated">如果我不是物理学家，我可能会成为音乐家。我经常在音乐中思考。我在音乐中实现我的白日梦。我从音乐的角度看待我的生活——阿尔伯特·爱因斯坦</p></blockquote><p id="bf1a" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">我可能不是爱因斯坦先生那样的物理学家，但我完全同意他对音乐的看法！我不记得有哪一天不打开我的音乐播放器。我往返办公室的旅途伴随着音乐，老实说，它帮助我专注于我的工作。</p><p id="4d55" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我一直梦想创作音乐，但不太懂乐器。直到我遇到了<a class="ae lh" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">深度学习</a>。使用某些技术和框架，我能够在不真正了解任何音乐理论的情况下创作自己的原创乐谱！</p><p id="3ad5" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">这是我最喜欢的专业项目之一。我把我的两个爱好音乐和深度学习结合起来，创造了一个自动音乐生成模型。这是梦想成真！</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es li"><img src="../Images/3229cfebc89df71b5b99891c0a0124a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rg0i-JkoPqtu5mwR.jpg"/></div></div></figure><p id="f294" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我很高兴能与你分享我的方法，包括让你生成自己的音乐的全部代码！我们将首先快速理解自动音乐生成的概念，然后再深入研究我们可以用来执行此操作的不同方法。最后，我们将启动Python并设计我们自己的自动音乐生成模型。</p><h1 id="c522" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目录</h1><ol class=""><li id="7f08" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq lu js jt ju bi translated">什么是自动音乐生成？</li><li id="10cf" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">音乐的构成要素是什么？</li><li id="37fe" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">不同的音乐创作方法<br/>-使用WaveNet架构<br/>-使用长短期记忆(LSTM)</li><li id="146e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">实现—使用Python自动作曲</li></ol><h1 id="76b9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是自动音乐生成？</h1><blockquote class="ka"><p id="e1ef" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated">音乐是一门艺术，也是一种通用语言</p></blockquote><p id="b3d2" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">我把音乐定义为不同频率音调的集合。因此，自动音乐生成是一个在最少人工干预下创作一小段音乐的过程。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es lv"><img src="../Images/16da5e5afd9af1bcb7ec1dd79bff484c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*vgEA_B-CobXVaK6p.gif"/></div></figure><p id="40a2" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">创作音乐最简单的形式是什么？</p><p id="208b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">这一切都是从随机选择声音并将它们组合成一段音乐开始的。1787年，莫扎特为这些随机的声音选择提出了一个<strong class="jf hj">骰子游戏</strong>。他手动作曲将近272个音！然后，他根据两个骰子的和选择了一个音调。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es lw"><img src="../Images/00615313d0cd4c877d486c228c6ca839.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*1lFn9egDOCgLLfwB.gif"/></div></figure><p id="e86b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">另一个有趣的想法是利用音乐语法来创作音乐。</p><blockquote class="ka"><p id="0bb6" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated">音乐语法包含了音乐声音的合理安排和组合以及音乐作品的正确演奏所必需的知识<br/>——音乐语法基础</p></blockquote><p id="9750" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">20世纪50年代初，亚尼斯·克塞纳基斯使用<a class="ae lh" href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science-2?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">统计和</a>的概念创作音乐——俗称<strong class="jf hj">随机音乐</strong>。他将音乐定义为偶然出现的元素(或声音)的序列。因此，他用随机理论将其公式化。他对元素的随机选择严格依赖于数学概念。</p><p id="a707" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">最近，深度学习架构已经成为自动音乐生成的艺术状态。在本文中，我将讨论使用WaveNet和LSTM(长短期记忆)架构的两种不同的自动音乐创作方法。</p><p id="2f3b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><em class="lx">注意:本文要求对一些深度学习概念有基本的理解。我推荐浏览下面的文章:</em></p><ul class=""><li id="27e5" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq jr js jt ju bi translated"><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2018/12/guide-convolutional-neural-network-cnn/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">从头开始学习卷积神经网络(CNN)的综合教程</a></li><li id="d39e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2017/12/fundamentals-of-deep-learning-introduction-to-lstm/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">深度学习精要:长短期记忆介绍(LSTM) </a></li><li id="ed6a" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2019/01/sequence-models-deeplearning/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">学习序列建模必读教程</a></li></ul><h1 id="3264" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">音乐的构成要素是什么？</h1><p id="6873" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">音乐本质上是由音符和和弦组成的。让我从钢琴乐器的角度来解释这些术语:</p><ul class=""><li id="616d" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq jr js jt ju bi translated"><strong class="jf hj">音符</strong>:单键发出的声音称为音符</li><li id="0d39" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">和弦</strong>:两个或两个以上的键同时发出的声音称为和弦。一般来说，大多数和弦至少包含三个关键音</li><li id="4ecd" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">八度</strong>:一个重复的模式称为一个八度。每个八度音阶包含7个白键和5个黑键</li></ul><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es me"><img src="../Images/8a3b316b635c47f520f2588b42cf0801.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*WSSCAS8GPwAM3Ns3ixioAw.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">钢琴</figcaption></figure><h1 id="5acc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">自动音乐生成的不同方法</h1><p id="e139" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">我将详细讨论两种基于深度学习的自动生成音乐的架构——wave net和LSTM。但是，为什么只有深度学习架构？</p><p id="f54b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">深度学习是受神经结构启发的机器学习领域。这些网络从数据集中自动提取特征，并且能够学习任何非线性函数。这就是为什么神经网络被称为<strong class="jf hj">通用函数逼近器</strong>的原因。</p><p id="e1e1" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">因此，深度学习模型是各个领域的最先进技术，如<a class="ae lh" href="https://courses.analyticsvidhya.com/courses/natural-language-processing-nlp?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP) </a>、<a class="ae lh" href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>、语音合成等等。让我们看看如何为音乐创作建立这些模型。</p><h1 id="02be" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">方法1:使用WaveNet</h1><blockquote class="ka"><p id="d355" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated"><em class="kk"> WaveNet是Google DeepMind开发的基于深度学习的原始音频生成模型。</em></p></blockquote><p id="201c" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">WaveNet的主要目标是从数据的原始分布中生成新的样本。因此，它被称为生成模型。</p><blockquote class="ka"><p id="baa9" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated"><em class="kk"> Wavenet就像是来自NLP的语言模型。</em></p></blockquote><p id="8bfa" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">在<a class="ae lh" href="https://www.analyticsvidhya.com/blog/2019/08/comprehensive-guide-language-model-nlp-python-code/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">语言模型</a>中，给定一个单词序列，模型试图预测下一个单词:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mj"><img src="../Images/69f829fd6ffeb4f8dadbcd88d599189a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZtY582PARhKSESvt.jpg"/></div></div></figure><p id="9c84" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">与语言模型类似，在WaveNet中，给定一个样本序列，它会尝试预测下一个样本。</p><h1 id="0bc6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">方法2:使用长短期记忆(LSTM)模型</h1><p id="3e35" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated"><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2017/12/fundamentals-of-deep-learning-introduction-to-lstm/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">长短期记忆模型</a>，俗称LSTM，是<a class="ae lh" href="https://www.analyticsvidhya.com/blog/2017/12/introduction-to-recurrent-neural-networks/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank">递归神经网络</a>的变体，能够捕捉输入序列中的长期依赖性。LSTM在序列到序列建模任务中有广泛的应用，如语音识别、文本摘要、视频分类等。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mk"><img src="../Images/912e814d6f12aa40d07fc2884906910e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*mnq9yTpYbckgWrX0.png"/></div></figure><p id="c757" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">让我们详细讨论如何使用这两种方法来训练我们的模型。</p><h1 id="145e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Wavenet:培训阶段</h1><blockquote class="ka"><p id="b228" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated"><em class="kk">这是一个多对一的问题，输入是一个幅度值序列，输出是后续值。</em></p></blockquote><p id="159c" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">让我们看看如何准备输入和输出序列。</p><p id="bb30" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">波网输入:</strong></p><p id="596d" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">WaveNet将原始音频波的块作为输入。原始音频波是指时间序列域中的波的表示。</p><p id="ca81" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">在时间序列域中，声波以不同时间间隔记录的振幅值的形式表示:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es ml"><img src="../Images/660491d1ad21016cb0a5e5602a02ce33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*IDtqHfj7BrISx-uo.gif"/></div></figure><p id="50df" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">波网输出:</strong></p><p id="2bc9" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">给定振幅值的序列，WaveNet试图预测连续的振幅值。</p><p id="36d2" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">让我们借助一个例子来理解这一点。考虑一个5秒钟的音频波，采样率为16，000(即每秒16，000个样本)。现在，我们有80，000个样本在5秒钟内以不同的间隔记录下来。让我们将音频分成大小相等的块，比如1024(这是一个超参数)。</p><p id="6ded" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">下图说明了模型的输入和输出序列:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mm"><img src="../Images/8bae7e5039418b778516783ae37c21a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*d4n1mnllqcLBDX3k.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">前3个词块的输入和输出</figcaption></figure><p id="2060" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我们可以按照类似的程序处理其余的块。</p><p id="d2d3" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我们可以从上面推断出，每个块的输出仅取决于过去的信息(即，先前的时间步长)，而不取决于未来的时间步长。因此，这个任务被称为<strong class="jf hj">自回归任务</strong>，这个模型被称为<strong class="jf hj">自回归模型</strong>。</p><h1 id="e699" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推理阶段</h1><p id="280c" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">在推理阶段，我们将尝试生成新的样本。让我们看看如何做到这一点:</p><ol class=""><li id="843c" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq lu js jt ju bi translated">选择样本值的随机数组作为建模的起点</li><li id="7417" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">现在，模型输出所有样本的概率分布</li><li id="516e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">选择概率最大的值，并将其追加到样本数组中</li><li id="76d9" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">删除第一个元素，并作为输入传递给下一次迭代</li><li id="691d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq lu js jt ju bi translated">重复步骤2和4一定次数的迭代</li></ol><h1 id="d8e6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">了解WaveNet架构</h1><p id="bf34" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">WaveNet的构建模块是<strong class="jf hj">因果扩张1D卷积层</strong>。让我们先了解一下相关概念的重要性。</p><p id="b39c" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">为什么和什么是卷积？</strong></p><blockquote class="ka"><p id="5908" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated"><em class="kk">使用卷积的主要原因之一是从输入中提取特征。</em></p></blockquote><p id="f881" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">例如，在图像处理的情况下，用滤波器卷积图像给我们一个特征图。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mn"><img src="../Images/212c1660b20b23c59d65f0f4656113a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OqTuawGNCXGu6bdf.jpg"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">与图像卷积后提取的特征</figcaption></figure><p id="81b9" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">卷积是一种结合两个函数的数学运算。</strong>在图像处理的情况下，卷积是图像的某些部分与内核的线性组合。</p><p id="3cb1" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">您可以浏览以下文章，了解有关卷积的更多信息:</p><p id="78db" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2017/06/architecture-of-convolutional-neural-networks-simplified-demystified/?utm_source=blog&amp;utm_medium=how-to-perform-automatic-music-generation" rel="noopener ugc nofollow" target="_blank"> <em class="lx">去神秘化的卷积神经网络架构</em> </a></p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mo"><img src="../Images/18ee9e0071ab36176231fa626e890fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/0*bQxd8KZJOMpQeHLk.gif"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">卷积2D</figcaption></figure><p id="ab99" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">什么是1D卷积？</strong></p><p id="d846" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">1D卷积的目的类似于长短期记忆模型。它被用来解决与LSTM类似的任务。在1D卷积中，内核或滤波器仅沿一个方向移动:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es lw"><img src="../Images/9707613e420fcb5714474b90c7339cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*KSgVBgjCLNJ571M1.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">Conv1D</figcaption></figure><p id="9f2d" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">卷积的输出取决于内核的大小、输入形状、填充类型和步幅。现在，我将带您了解不同类型的填充，以理解使用扩张因果1D卷积层的重要性。</p><p id="8131" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">当我们设置填充<strong class="jf hj">有效</strong>时，输入和输出序列长度不同。输出的长度小于输入的长度:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mp"><img src="../Images/7c41fb9685bc2e016da78854188af9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/0*xCT7H_9HjTm_6IiM.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">Conv1D with padding="valid "</figcaption></figure><p id="a908" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">当我们将填充符设置为<strong class="jf hj"> same </strong>时，在输入序列的两边填充零，以使输入和输出的长度相等:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mq"><img src="../Images/89023910ed86be6e7ee7920943782d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*_sd7SGIxcTpX5ew-.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">Conv1D with padding="same "</figcaption></figure><p id="95d4" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">1D卷积的优点:</strong></p><ul class=""><li id="ccdc" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq jr js jt ju bi translated">捕获输入序列中的顺序信息</li><li id="e05e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">与GRU或LSTM相比，训练速度要快得多，因为没有经常性的联系</li></ul><p id="c609" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">1D卷积的缺点:</strong></p><ul class=""><li id="c3cd" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq jr js jt ju bi translated">当padding设置为<strong class="jf hj"> same </strong>时，时间步长<strong class="jf hj"> t </strong>的输出也与先前的<strong class="jf hj"> t-1 </strong>和未来的时间步长<strong class="jf hj"> t+1 </strong>卷积。因此，它违反了自回归原理</li><li id="eb0b" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">当padding设置为<strong class="jf hj"> valid </strong>时，输入和输出序列的长度会发生变化，这是计算剩余连接所需的长度(将在后面介绍)</li></ul><p id="505b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">这为因果卷积扫清了道路。</p><p id="1c17" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj"> <em class="lx">注:</em> </strong>我这里说的<em class="lx">利弊都是针对这个问题的。</em></p><p id="1478" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">什么是1D因果卷积？</strong></p><blockquote class="ka"><p id="baf1" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated"><em class="kk">这被定义为卷积，其中在时间</em> <strong class="ak"> <em class="kk"> t </em> </strong> <em class="kk">的输出仅与来自时间</em> <strong class="ak"> <em class="kk"> t </em> </strong> <em class="kk">和先前层中的元素进行卷积。</em></p></blockquote><p id="0bcb" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">简单来说，正常卷积和因果卷积的区别仅在于填充。在因果卷积中，零被添加到输入序列的左侧，以保持自回归原理:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mr"><img src="../Images/1f7d4299eb90dbc2731b15ddb7938408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/0*VZIVhmCmpMA9pNjT.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">因果卷积1D</figcaption></figure><p id="3509" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">因果1D卷积的利弊:</strong></p><p id="b273" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">1.因果卷积不考虑未来时间步长，而未来时间步长是构建生成模型的标准</p><p id="ebbc" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">因果1D卷积的弊端:</strong></p><ol class=""><li id="927f" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq lu js jt ju bi translated">因果卷积不能追溯到过去或序列中较早发生的时间步长。因此，因果卷积具有非常低的感受野。网络的感受域是指影响输出的输入数量:</li></ol><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es ms"><img src="../Images/8a8e7497b4b0ead30aff67f75c7dea0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*ecj3wTFUgaQC-PTp.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">因果关系</figcaption></figure><p id="2ad6" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">正如您在这里看到的，输出仅受5个输入的影响。因此，网络的感受野是5，这是非常低的。网络的感受域也可以通过增加大尺寸的核来增加，但是要记住计算复杂度会增加。</p><p id="d58d" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">这让我们想到了可怕的膨胀1D因果卷积的概念。</p><p id="527f" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">什么是扩张型1D因果卷积？</strong></p><blockquote class="ka"><p id="f32b" class="kb kc hi bd kd ke kf kg kh ki kj jq dx translated"><em class="kk">在核的值之间具有空洞或空间的因果1D卷积层被称为扩张1D卷积。</em></p></blockquote><p id="c1a7" class="pw-post-body-paragraph kl km hi jf b jg kn ko kp ji kq kr ks jk kt ku kv jm kw kx ky jo kz la lb jq hb bi translated">要添加的空间数量由膨胀率给出。它定义了网络的接收域。大小为<strong class="jf hj"> k </strong>且膨胀率为<strong class="jf hj"> d </strong>的内核在内核<strong class="jf hj"> k </strong>的每个值之间有<strong class="jf hj"> d-1 </strong>个洞。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mt"><img src="../Images/6861e01de8210346032e8c3eb23c9ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*j0EocPgcJ-mR9RH-.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">扩张因果卷积2D</figcaption></figure><p id="36c4" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">正如您在这里所看到的，在7 * 7的输入上以2的膨胀率卷积3 * 3的核得到5 * 5的接收场。</p><p id="665d" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">扩张1D因果卷积的利弊:</strong></p><ol class=""><li id="77d1" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq lu js jt ju bi translated">扩张的1D卷积网络通过指数增加每个隐藏层的扩张率来增加感受野:</li></ol><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mu"><img src="../Images/4b8619c6d401dd891c85be74b7656a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*mMO7HIOvt4kABvui.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">扩张1D因果卷积</figcaption></figure><p id="2894" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">正如您在这里看到的，输出受到所有输入的影响。因此，网络的感受野是16。</p><p id="c9bd" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">波网残差块:</strong></p><p id="5a29" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">构建块包含残差和跳过连接，添加这些连接只是为了加速模型的收敛:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mv"><img src="../Images/a406e23c784c1183326d75350089c7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/0*uRjMR3BKVUfcGGHS.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">波网剩余块</figcaption></figure><p id="4260" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">wave net的工作流程:</strong></p><ul class=""><li id="3cfa" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq jr js jt ju bi translated">输入被送入因果1D卷积</li><li id="d9c0" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">然后，输出被送入两个不同的膨胀1D卷积层，分别激活<strong class="jf hj">s形</strong>和<strong class="jf hj"> tanh </strong></li><li id="e76d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">2个不同激活值的逐元素乘法导致跳过连接</li><li id="c738" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">并且跳过连接和因果1D输出的逐元素相加产生残差</li></ul><h1 id="9081" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">长短期记忆(LSTM)方法</h1><p id="056b" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">另一种自动音乐生成的方法是基于长短期记忆(LSTM)模型。输入和输出序列的准备与WaveNet类似。在每个时间步长，一个幅度值被输入长短期记忆单元，然后计算隐藏向量，并将其传递给下一个时间步长。</p><p id="99ea" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">基于当前输入和先前的隐藏向量来计算时间步长处的当前隐藏向量。这是在任何递归神经网络中捕获顺序信息的方式:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es mw"><img src="../Images/812d4a5e59982c7c5b7927289a41d665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/0*hEz2hopBqyu0dzB7.jpg"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">长短期记忆模型</figcaption></figure><p id="48b1" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">LSTM的优点:</strong></p><ol class=""><li id="b61b" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq lu js jt ju bi translated">捕获输入序列中的顺序信息</li></ol><p id="c21d" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">LSTM的缺点:</strong></p><ol class=""><li id="dc23" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq lu js jt ju bi translated">由于它是按顺序处理输入的，所以需要花费大量的训练时间</li></ol><h1 id="ba34" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">实现—使用Python自动生成音乐</h1><p id="ff9d" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">等待结束了！让我们为音乐的自动生成开发一个端到端的模型。打开你的Jupyter笔记本或Colab(或任何你喜欢的IDE)。</p><p id="62d5" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">下载数据集</strong>:</p><p id="cb31" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我从众多资源中下载并组合了一架数码钢琴的多个古典音乐文件。你可以从<a class="ae lh" href="https://drive.google.com/file/d/1qnQVK17DNVkU19MgVA4Vg88zRDvwCRXw/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>下载最终的数据集。</p><p id="dde6" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">让我们首先为可重复的结果播下种子。这是因为深度学习模型可能会由于随机性而在执行时输出不同的结果。这确保了我们每次都能产生相同的结果。</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="323b" class="nc ig hi my b fi nd ne l nf ng">from numpy.random import seed                       <br/>seed(1)                       </span><span id="14d4" class="nc ig hi my b fi nh ne l nf ng">from tensorflow import set_random_seed                       set_random_seed(2)</span></pre><p id="e77e" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">导入库:</strong></p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="db19" class="nc ig hi my b fi nd ne l nf ng">#dealing with midi files                       <br/>from music21 import *                                                </span><span id="5337" class="nc ig hi my b fi nh ne l nf ng">#array processing                       <br/>import numpy as np                            </span><span id="e2f2" class="nc ig hi my b fi nh ne l nf ng">import os                                               </span><span id="7f01" class="nc ig hi my b fi nh ne l nf ng">#random number generator                       <br/>import random                                                        </span><span id="dfd9" class="nc ig hi my b fi nh ne l nf ng">#keras for building deep learning model                       <br/>from keras.layers import *                        <br/>from keras.models import *                       <br/>import keras.backend as K</span></pre><p id="b33c" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><strong class="jf hj">读取数据</strong>:</p><p id="8b60" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">定义一个函数来读取MIDI文件。它返回音乐文件中的一组音符和和弦。</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="a017" class="nc ig hi my b fi nd ne l nf ng">def read_midi(file):<br/>  notes=[]<br/>  notes_to_parse = None</span><span id="69a4" class="nc ig hi my b fi nh ne l nf ng">#parsing a midi file<br/>  midi = converter.parse(file)<br/>  #grouping based on different instruments<br/>  s2 = instrument.partitionByInstrument(midi)</span><span id="cd23" class="nc ig hi my b fi nh ne l nf ng">#Looping over all the instruments<br/>  for part in s2.parts:<br/>    #select elements of only piano<br/>    if 'Piano' in str(part): <br/>      notes_to_parse = part.recurse() <br/>      #finding whether a particular element is note or a chord<br/>      for element in notes_to_parse:<br/>        if isinstance(element, note.Note):<br/>          notes.append(str(element.pitch))<br/>        elif isinstance(element, chord.Chord):<br/>          notes.append('.'.join(str(n) for n in element.normalOrder))<br/>      <br/>  return notes</span></pre><p id="1f7a" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">从目录中读取MIDI文件:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="74f6" class="nc ig hi my b fi nd ne l nf ng">#read all the filenames<br/>files=[i for i in os.listdir() if i.endswith(".mid")]</span><span id="9f08" class="nc ig hi my b fi nh ne l nf ng">#reading each midi file<br/>all_notes=[]<br/>for i in files:<br/>  all_notes.append(read_midi(i))</span><span id="3357" class="nc ig hi my b fi nh ne l nf ng">#notes and chords of all the midi files<br/>notes = [element for notes in all_notes for element in notes]</span></pre><p id="3eb2" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">准备文章中提到的输入和输出序列:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="3729" class="nc ig hi my b fi nd ne l nf ng">#length of a input sequence<br/>no_of_timesteps = 128</span><span id="a4c9" class="nc ig hi my b fi nh ne l nf ng">#no. of unique notes<br/>n_vocab = len(set(notes))</span><span id="0e7f" class="nc ig hi my b fi nh ne l nf ng">#all the unique notes<br/>pitch = sorted(set(item for item in notes))</span><span id="42ad" class="nc ig hi my b fi nh ne l nf ng">#assign unique value to every note<br/>note_to_int = dict((note, number) for number, note in enumerate(pitch))</span><span id="6b70" class="nc ig hi my b fi nh ne l nf ng">#preparing input and output sequences<br/>X = []<br/>y = []<br/>for notes in all_notes:<br/>  for i in range(0, len(notes) - no_of_timesteps, 1):<br/>    input_ = notes[i:i + no_of_timesteps]<br/>    output = notes[i + no_of_timesteps]<br/>    X.append([note_to_int[note] for note in input_])<br/>    y.append(note_to_int[output])</span></pre><p id="654d" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我在这里定义了两种架构——wave net和LSTM。请尝试这两种架构，以了解WaveNet架构的重要性。</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="3178" class="nc ig hi my b fi nd ne l nf ng">def lstm():<br/>  model = Sequential()<br/>  model.add(LSTM(128,return_sequences=True))<br/>  model.add(LSTM(128))<br/>  model.add(Dense(256))<br/>  model.add(Activation('relu'))<br/>  model.add(Dense(n_vocab))<br/>  model.add(Activation('softmax'))<br/>  model.compile(loss='sparse_categorical_crossentropy', optimizer='adam')<br/>  return model</span></pre><p id="0382" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我简化了WaveNet的架构，没有添加剩余和跳过连接，因为这些层的作用是提高更快的收敛(WaveNet将原始音频波作为输入)。但是在我们的例子中，输入将是一组节点和和弦，因为我们正在生成音乐:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="59bc" class="nc ig hi my b fi nd ne l nf ng">K.clear_session()<br/>def simple_wavenet():<br/>  no_of_kernels=64<br/>  num_of_blocks= int(np.sqrt(no_of_timesteps)) - 1   #no. of stacked conv1d layers</span><span id="9ce4" class="nc ig hi my b fi nh ne l nf ng">model = Sequential()<br/>  for i in range(num_of_blocks):<br/>    model.add(Conv1D(no_of_kernels,3,dilation_rate=(2**i),padding='causal',activation='relu'))<br/>  model.add(Conv1D(1, 1, activation='relu', padding='causal'))<br/>  model.add(Flatten())<br/>  model.add(Dense(128, activation='relu'))<br/>  model.add(Dense(n_vocab, activation='softmax'))<br/>  model.compile(loss='sparse_categorical_crossentropy', optimizer='adam')<br/>  return model</span></pre><p id="9411" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">定义每50个时期后保存模型的回调:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="55ce" class="nc ig hi my b fi nd ne l nf ng">import keras                       <br/>mc = keras.callbacks.ModelCheckpoint('model{epoch:03d}.h5', save_weights_only=False, period=50)</span></pre><p id="7f8b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">实例化并训练批量大小为128的模型:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="9f41" class="nc ig hi my b fi nd ne l nf ng">model = simple_wavenet()                       model.fit(X,np.array(y), epochs=300, batch_size=128,callbacks=[mc])</span></pre><p id="c532" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">这是文章中提到的推理阶段的一个实现。它预测特定迭代次数的最可能元素:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="4971" class="nc ig hi my b fi nd ne l nf ng">def generate_music(model, pitch, no_of_timesteps, pattern):<br/>    <br/>    int_to_note = dict((number, note) for number, note in enumerate(pitch))<br/>    prediction_output = []<br/>    <br/>    # generate 50 elements<br/>    for note_index in range(50):<br/>        #reshaping array to feed into model<br/>        input_ = np.reshape(pattern, (1, len(pattern), 1))<br/>        <br/>        #predict the probability and choose the maximum value<br/>        proba = model.predict(input_, verbose=0)<br/>        index = np.argmax(proba)<br/>        <br/>        #convert integer back to the element<br/>        pred = int_to_note[index]<br/>        prediction_output.append(pred)<br/>        pattern = list(pattern)<br/>        pattern.append(index/float(n_vocab))<br/>        <br/>        #leave the first value at index 0<br/>        pattern = pattern[1:len(pattern)]<br/>  <br/>  return prediction_output</span></pre><p id="d55b" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">下面是一个将创作的音乐转换成MIDI文件的函数:</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="859a" class="nc ig hi my b fi nd ne l nf ng">def convert_to_midi(prediction_output):<br/>    offset = 0<br/>    output_notes = []</span><span id="1c13" class="nc ig hi my b fi nh ne l nf ng"># create note and chord objects based on the values generated by the model<br/>    for pattern in prediction_output:<br/>        # pattern is a chord<br/>        if ('.' in pattern) or pattern.isdigit():<br/>            notes_in_chord = pattern.split('.')<br/>            notes = []<br/>            for current_note in notes_in_chord:<br/>                new_note = note.Note(int(current_note))<br/>                new_note.storedInstrument = instrument.Piano()<br/>                notes.append(new_note)<br/>            new_chord = chord.Chord(notes)<br/>            new_chord.offset = offset<br/>            output_notes.append(new_chord)<br/>        # pattern is a note<br/>        else:<br/>            new_note = note.Note(pattern)<br/>            new_note.offset = offset<br/>            new_note.storedInstrument = instrument.Piano()<br/>            output_notes.append(new_note)</span><span id="eaaa" class="nc ig hi my b fi nh ne l nf ng">       # Specify duration between 2 notes<br/>        offset+  = 0.5<br/>       # offset += random.uniform(0.5,0.9)</span><span id="b21f" class="nc ig hi my b fi nh ne l nf ng">midi_stream = stream.Stream(output_notes)<br/>    midi_stream.write('midi', fp='music.mid')</span></pre><p id="a8fe" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">让我们现在创作自己的音乐吧！</p><pre class="lj lk ll lm fd mx my mz na aw nb bi"><span id="5c60" class="nc ig hi my b fi nd ne l nf ng">#Select random chunk for the first iteration<br/>start = np.random.randint(0, len(X)-1)<br/>pattern = X[start]</span><span id="9ff2" class="nc ig hi my b fi nh ne l nf ng">#load the best model<br/>model=load_model(‘model300.h5’)</span><span id="3251" class="nc ig hi my b fi nh ne l nf ng">#generate and save music<br/>music = generate_music(model,pitch,no_of_timesteps,pattern)<br/>convert_to_midi(music)</span></pre><p id="6ab5" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">这是我们的模特创作的几首曲子。是时候享受音乐了！</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="ni nj l"/></div></figure><p id="d8ce" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">太棒了，对吧？但是你的学习不止于此。以下是进一步提高模型性能的几种方法:</p><ul class=""><li id="9fcf" class="jd je hi jf b jg lc ji ld jk ly jm lz jo ma jq jr js jt ju bi translated">增加训练数据集的大小会产生更好的旋律，因为深度学习模型在大型训练数据集上概括得很好</li><li id="73b6" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">在构建具有大量层的模型时，添加跳过连接和剩余连接</li><li id="2097" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">尝试不同的架构，看看性能是否会提高</li></ul><h1 id="766c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结束注释</h1><p id="77b3" class="pw-post-body-paragraph kl km hi jf b jg jh ko kp ji jj kr ks jk mb ku kv jm mc kx ky jo md la lb jq hb bi translated">深度学习在我们的日常生活中有着广泛的应用。解决任何问题的关键步骤是理解问题陈述，制定它并定义解决问题的架构。</p><p id="33c0" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">在这个项目中，我获得了很多乐趣(和学习)。音乐是我的一种激情，将深度学习与此结合起来非常有趣。</p><p id="a558" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated">我期待在评论区听到你对这个问题的看法。如果你对这篇文章有任何反馈或任何疑问/疑问，请在下面的评论区分享，我会尽快回复你。</p><p id="6ea7" class="pw-post-body-paragraph kl km hi jf b jg lc ko kp ji ld kr ks jk le ku kv jm lf kx ky jo lg la lb jq hb bi translated"><em class="lx">原载于2020年1月21日https://www.analyticsvidhya.com</em><a class="ae lh" href="https://www.analyticsvidhya.com/blog/2020/01/how-to-perform-automatic-music-generation/" rel="noopener ugc nofollow" target="_blank"><em class="lx"/></a><em class="lx">。</em></p></div></div>    
</body>
</html>