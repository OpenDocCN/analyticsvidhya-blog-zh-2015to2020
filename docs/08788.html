<html>
<head>
<title>Here’s All you Need to Know About Encoding Categorical Data (with Python code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是关于编码分类数据(使用Python代码)您需要知道的全部内容</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/heres-all-you-need-to-know-about-encoding-categorical-data-with-python-code-53e367a79b5c?source=collection_archive---------7-----------------------#2020-08-13">https://medium.com/analytics-vidhya/heres-all-you-need-to-know-about-encoding-categorical-data-with-python-code-53e367a79b5c?source=collection_archive---------7-----------------------#2020-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ea8f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在这里，您将看到一些非常有趣的数据编码技术，用于您的机器学习项目的分类特征。</h2></div><h1 id="eb0e" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">概观</h1><ul class=""><li id="2ea8" class="jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">理解什么是分类数据编码</li><li id="8f46" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">了解不同的编码技术以及何时使用它们</li></ul><h1 id="820c" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="ea42" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">机器学习模型的性能不仅取决于模型和超参数，还取决于我们如何处理和向模型提供不同类型的变量。由于大多数机器学习模型只接受数字变量，预处理分类变量成为一个必要的步骤。我们需要将这些分类变量转换成数字，以便模型能够理解和提取有价值的信息。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/d62333955432b59a78f3c5c1136e2ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MI3fPk6iNaSKIbN7.png"/></div></div></figure><p id="9dba" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">典型的数据科学家花费70–80%的时间清理和准备数据。转换分类数据是不可避免的活动。它不仅提高了模型质量，而且有助于更好地进行特征工程。现在的问题是，我们如何进行？我们应该使用哪种分类数据编码方法？</p><p id="7f8c" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在本文中，我将解释各种类型的分类数据编码方法，以及在Python中的实现。</p><p id="dfc7" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated"><em class="lq">如果你想学习视频格式的数据科学概念，请查看我们的课程- </em> <a class="ae lr" href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science-2?utm_source=blog&amp;utm_medium=Categorical_data_encoding" rel="noopener ugc nofollow" target="_blank"> <em class="lq">数据科学介绍</em> </a></p><h1 id="f4e1" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">目录</h1><ul class=""><li id="3e79" class="jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">什么是分类数据？</li><li id="29e7" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">标签编码或顺序编码</li><li id="9537" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">一个热编码</li><li id="47b6" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">虚拟编码</li><li id="710e" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">效果编码</li><li id="4dbf" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">二进制编码</li><li id="f3f7" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">BaseN编码</li><li id="6c4a" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">哈希编码</li><li id="45a0" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated">目标编码</li></ul><h1 id="5911" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">什么是分类数据？</h1><p id="cdca" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">因为我们将在本文中研究分类变量，所以这里用几个例子快速复习一下。分类变量通常表示为“字符串”或“类别”,并且数量有限。这里有几个例子:</p><ol class=""><li id="7adc" class="jp jq hi jr b js ll ju lm jw ls jy lt ka lu kc lv ke kf kg bi translated">一个人居住的城市:德里、孟买、艾哈迈达巴德、班加罗尔等。</li><li id="8537" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc lv ke kf kg bi translated">一个人工作的部门:财务、人力资源、IT、生产。</li><li id="f8b0" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc lv ke kf kg bi translated">一个人拥有的最高学历:高中、文凭、学士、硕士、博士。</li><li id="1bdc" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc lv ke kf kg bi translated">学生的成绩:A+，A，B+，B，B-等。</li></ol><p id="a3bd" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在上面的例子中，变量只有确定的可能值。此外，我们可以看到有两种分类数据-</p><ul class=""><li id="e934" class="jp jq hi jr b js ll ju lm jw ls jy lt ka lu kc kd ke kf kg bi translated"><strong class="jr hj">序数数据:</strong>类别有一个固有的顺序</li><li id="3283" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc kd ke kf kg bi translated"><strong class="jr hj">名义数据:</strong>类别没有固有的顺序</li></ul><p id="f72a" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在有序数据中，在编码时，应该保留关于提供类别的顺序的信息。就像上面的例子一样，一个人拥有的最高学位提供了关于他的资格的重要信息。学历是决定一个人是否适合某个岗位的重要特征。</p><p id="2a0c" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在对名义数据进行编码时，我们必须考虑某个特征的存在与否。在这种情况下，没有秩序的概念。比如一个人生活的城市。对于数据来说，保留一个人住在哪里很重要。在这里，我们没有任何顺序或次序。如果一个人住在德里或班加罗尔，这是平等的。</p><p id="4c12" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">对于分类数据的编码，我们有一个python包category_encoders。以下代码有助于您轻松安装。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="57b9" class="mb iy hi lx b fi mc md l me mf">pip install category_encoders</span></pre><h1 id="dc76" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">标签编码或顺序编码</h1><p id="42ac" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">当分类特征是有序的时，我们使用这种分类数据编码技术。在这种情况下，保留订单很重要。因此，编码应该反映顺序。</p><p id="53d0" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在标签编码中，每个标签都被转换为整数值。我们将创建一个变量，它包含代表一个人的教育资格的类别。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="a38c" class="mb iy hi lx b fi mc md l me mf">import category_encoders as ce <br/>import pandas as pd <br/>train_df=pd.DataFrame({'Degree':['High school','Masters','Diploma','Bachelors','Bachelors','Masters','Phd','High school','High school']})<br/> # create object of Ordinalencoding <br/>encoder= ce.OrdinalEncoder(cols=['Degree'],return_df=True, mapping=[{'col':'Degree', 'mapping':{'None':0,'High school':1,'Diploma':2,'Bachelors':3,'Masters':4,'phd':5}}]) </span><span id="d7b0" class="mb iy hi lx b fi mg md l me mf">#Original data <br/>train_df</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mh"><img src="../Images/9daaea1897608f74c9107870e5a7ef14.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/0*kBLjf-YIUimd_sB2.png"/></div></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="93f1" class="mb iy hi lx b fi mc md l me mf">#fit and transform train data <br/>df_train_transformed = encoder.fit_transform(train_df)<br/>df_train_transformed</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mi"><img src="../Images/f76d5e7302cf52ecd3651b8ebeea21e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/0*IVjVL4YC1HIU4RPB.png"/></div></figure><h1 id="57ef" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">一个热编码</h1><p id="02f6" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">当特征是名义上的(没有任何顺序)时，我们使用这种分类数据编码技术。在一个热编码中，对于分类特征的每个级别，我们创建一个新变量。每个类别都映射有一个包含0或1的二进制变量。这里，0表示不存在，1表示该类别存在。</p><p id="2a16" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">这些新创建的二进制特征被称为<strong class="jr hj">虚拟变量。</strong>虚拟变量的数量取决于分类变量的级别。这听起来可能很复杂。让我们举个例子来更好地理解这一点。假设我们有一个动物类别的数据集，有不同的动物，如狗、猫、羊、牛、狮子。现在我们必须对这些数据进行一次性编码。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mj"><img src="../Images/741fb4756f7eea1177357ccab2765fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CswB9sW2DRuJWfvK.png"/></div></div></figure><p id="ed67" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">编码后，在第二个表中，我们有虚拟变量，每个虚拟变量代表特征动物中的一个类别。现在，对于存在的每个类别，我们在该类别的列中有1，在其他类别中有0。让我们看看如何用python实现一键编码。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="1a94" class="mb iy hi lx b fi mc md l me mf">import category_encoders as ce <br/>import pandas as pd <br/>data=pd.DataFrame({'City':[ 'Delhi','Mumbai','Hydrabad','Chennai','Bangalore','Delhi','Hydrabad','Bangalore','Delhi' ]}) <br/>#Create object for one-hot encoding encoder=ce.OneHotEncoder(cols='City',handle_unknown='return_nan',return_df=True,use_cat_names=True) <br/>#Original Data<br/> data</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mk"><img src="../Images/9e67c703d01f02bf8dea81287a239bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/0*6-xETH2Cg3qR_5C9.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="5e6f" class="mb iy hi lx b fi mc md l me mf">#Fit and transform Data<br/> data_encoded = encoder.fit_transform(data)<br/> data_encoded</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ml"><img src="../Images/8cb5ebbd662ab877f15bcf6e316accbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SkN4DUgOBx3An85M.png"/></div></div></figure><p id="8e08" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">现在让我们转到另一个非常有趣且广泛使用的编码技术，即虚拟编码。</p><h1 id="9ead" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">虚拟编码</h1><p id="b5d8" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">伪编码方案类似于独热编码。这种分类数据编码方法将分类变量转换成一组二进制变量(也称为哑变量)。在一键编码的情况下，对于一个变量中的N个类别，它使用N个二进制变量。伪编码是对一位热编码的一个小小的改进。虚拟编码使用N-1个特征来表示N个标签/类别。</p><p id="65a2" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">为了更好地理解这一点，让我们看看下图。这里，我们使用一位热编码和虚拟编码技术对相同的数据进行编码。而one-hot使用3个变量来表示数据，而dummy编码使用2个变量来编码3个类别。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mm"><img src="../Images/74015cda5bef4eb9a4b635890fb665ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P9gfm8hVKyTFp1ee.png"/></div></div></figure><p id="8c13" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">让我们用python来实现它。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="598e" class="mb iy hi lx b fi mc md l me mf">import category_encoders as ce<br/>import pandas as pd<br/>data=pd.DataFrame({'City':['Delhi','Mumbai','Hyderabad','Chennai','Bangalore','Delhi,'Hyderabad']}) <br/>#Original Data<br/>data</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mk"><img src="../Images/909e666609e14ff9e4d8500d1fc5d0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/0*UuOTdsY71ALDipFU.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="ce14" class="mb iy hi lx b fi mc md l me mf">#encode the data data_encoded=pd.get_dummies(data=data,drop_first=True)<br/>data_encoded</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mn"><img src="../Images/cf17e6257a88e2cd8b55889fb519e1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*gnjpI9sRab5JU4nW.png"/></div></figure><p id="f895" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">这里使用<em class="lq"> drop_first </em>参数，我们用0表示第一个标签Bangalore。</p><h1 id="04e1" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">一位热编码和虚拟编码的缺点</h1><p id="c9dd" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">One hot编码器和dummy编码器是两种强大而有效的编码方案。它们在数据科学家中也很受欢迎，但在以下情况下可能不太有效</p><ol class=""><li id="d12d" class="jp jq hi jr b js ll ju lm jw ls jy lt ka lu kc lv ke kf kg bi translated">数据中存在大量级别。在这种情况下，如果一个特征变量中有多个类别，我们需要相似数量的虚拟变量来编码数据。例如，有30个不同值的列将需要30个新变量进行编码。</li><li id="afc4" class="jp jq hi jr b js kh ju ki jw kj jy kk ka kl kc lv ke kf kg bi translated">如果我们在数据集中有多个分类特征，类似的情况也会发生，我们将再次得到几个二元特征，每个二元特征代表一个分类特征及其多个类别，例如，一个数据集有10个或更多分类列。</li></ol><p id="4e4d" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在上述两种情况下，这两种编码方案在数据集中引入了稀疏性，即几列为0，几列为1。换句话说，它会在数据集中创建多个虚拟要素，而不会添加太多信息。</p><p id="5608" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">此外，它们可能会导致虚拟变量陷阱。这是一种特征高度相关的现象。这意味着使用其他变量，我们可以很容易地预测一个变量的值。</p><p id="9ed5" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">由于数据集中的大量增加，编码减慢了模型的学习，同时降低了整体性能，最终使得模型的计算成本很高。此外，当使用基于树的模型时，这些编码不是最佳选择。</p><h1 id="0924" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">效果编码:</h1><p id="f181" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">这种编码技术也被称为<strong class="jr hj">偏差编码</strong>或<strong class="jr hj">和编码。</strong>效果编码和哑编码差不多，有一点区别。在虚拟编码中，我们使用0和1来表示数据，但在实际编码中，我们使用三个值，即1、0和-1。</p><p id="d808" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在虚拟编码中只包含0的行在有效编码中被编码为-1。在虚拟编码示例中，索引为4的城市班加罗尔被编码为0000。而在实际编码中，它被表示为-1–1–1–1。</p><p id="0432" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">让我们看看如何用python实现它</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="a74e" class="mb iy hi lx b fi mc md l me mf">import category_encoders as ce <br/>import pandas as pd <br/>data=pd.DataFrame({'City':['Delhi','Mumbai','Hyderabad','Chennai','Bangalore','Delhi,'Hyderabad']}) <br/>encoder=ce.sum_coding.SumEncoder(cols='City',verbose=False,) #Original Data <br/>data</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mk"><img src="../Images/6eed934376d71fc0e3a183e919b5a757.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/0*S8vSe9T_fbvSQBGp.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="ddef" class="mb iy hi lx b fi mc md l me mf">encoder.fit_transform(data)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mo"><img src="../Images/4a3a4c2cd4633dc5a0029c0c1e9060b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*KXHF1-2ws5dHZ9Np.png"/></div></figure><p id="080c" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">效果编码是一种先进的技术。如果你有兴趣了解更多关于效果编码的知识，请参考<a class="ae lr" href="https://www.researchgate.net/publication/256349393_Categorical_Variables_in_Regression_Analysis_A_Comparison_of_Dummy_and_Effect_Coding" rel="noopener ugc nofollow" target="_blank">这篇</a>有趣的论文。</p><h1 id="9182" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">哈希编码器</h1><p id="2f37" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">为了理解散列编码，有必要了解散列。哈希是以固定大小值的形式对任意大小的输入进行转换。我们使用哈希算法来执行哈希运算，即生成输入的哈希值。此外，散列是单向过程，换句话说，不能从散列表示生成原始输入。</p><p id="8702" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">散列有几个应用，如数据检索，检查数据损坏，以及在数据加密。我们有多种散列函数可用，例如消息摘要(MD、MD2、MD5)、安全散列函数(SHA0、SHA1、SHA2)等等。</p><p id="2a23" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">就像一次性编码一样，哈希编码器使用新的维度来表示分类特征。在这里，用户可以使用<em class="lq"/><strong class="jr hj"><em class="lq">n _ component</em></strong>参数来固定变换后的维数。我的意思是，一个具有5个类别的特征可以用N个新特征来表示。同样，一个具有100个类别的特征也可以用N个新特征来转换。这听起来是不是很神奇？</p><p id="f9b2" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">默认情况下，哈希编码器使用md5 哈希算法，但是用户可以通过他选择的任何算法。如果想探究md5算法，我建议<a class="ae lr" href="https://ieeexplore.ieee.org/document/5474379" rel="noopener ugc nofollow" target="_blank">这篇</a>论文。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="43bb" class="mb iy hi lx b fi mc md l me mf">import category_encoders as ce <br/>import pandas as pd <br/>#Create the dataframe <br/>data=pd.DataFrame({'Month':['January','April','March','April','Februay','June','July','June','September']}) <br/>#Create object for hash encoder encoder=ce.HashingEncoder(cols='Month',n_components=6)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mp"><img src="../Images/d87298aeb1c6dd3ab6281871b40cc02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/0*uPK0isgXk-53wswA.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="122a" class="mb iy hi lx b fi mc md l me mf">#Fit and Transform Data<br/>encoder.fit_transform(data)</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mq"><img src="../Images/41c2b76d9fd9b2a6287b2138bf807b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*EG6YS6_i8bAod-Vy.png"/></div></figure><p id="f341" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">由于哈希变换的数据维数较小，因此可能会导致信息丢失。哈希编码器面临的另一个问题是<strong class="jr hj">冲突。</strong>由于在这里，大量的特征被描绘成较小的维度，因此多个值可以由相同的散列值来表示，这被称为冲突。</p><p id="ce0c" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">此外，哈希编码器在一些Kaggle比赛中非常成功。如果数据集具有高基数特性，那么尝试一下是很棒的。</p><h1 id="a4bd" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">二进制编码</h1><p id="ecf6" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">二进制编码是哈希编码和一键编码的组合。在这种编码方案中，首先使用顺序编码器将分类特征转换成数字。然后这些数字被转换成二进制数。之后，二进制值被分成不同的列。</p><p id="77ff" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">当有大量类别时，二进制编码非常有效。例如，一个公司供应其产品的国家的城市。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="f01a" class="mb iy hi lx b fi mc md l me mf">#Import the libraries <br/>import category_encoders as ce<br/>import pandas as pd <br/>#Create the Dataframe <br/>data=pd.DataFrame({'City':['Delhi','Mumbai','Hyderabad','Chennai','Bangalore','Delhi','Hyderabad','Mumbai','Agra']}) <br/>#Create object for binary encoding <br/>encoder= ce.BinaryEncoder(cols=['city'],return_df=True) <br/>#Original Data <br/>data</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mr"><img src="../Images/e124596a6a650853d0e5af9c90269fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/0*cIilxl5dbk-zBtPB.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="21d9" class="mb iy hi lx b fi mc md l me mf">#Fit and Transform Data <br/>data_encoded=encoder.fit_transform(data) <br/>data_encoded</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ms"><img src="../Images/9014a00d91b0f43aed2a58c524f1c4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*A4rS3eDg8-JluQCa.png"/></div></figure><p id="1daa" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">二进制编码是一种节省内存的编码方案，因为它使用的功能比一位热码编码少。此外，它减少了高基数数据的<strong class="jr hj">维数灾难</strong>。</p><h1 id="bf69" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">基数N编码</h1><p id="afb2" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">在深入BaseN编码之前，让我们先试着理解这里的Base是什么？</p><p id="a9fa" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在数字系统中，基数是用来表示数字的位数或数字和字母的组合。我们在生活中最常用的基数是10或十进制，这里我们用10个唯一的数字，即0到9来代表所有的数字。另一种广泛使用的系统是二进制，即基数是2。它使用0和1，即2位数来表示所有的数字。</p><p id="ff0f" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">对于二进制编码，基数是2，这意味着它将类别的数值转换为相应的二进制形式。如果你想改变编码方案的基数，你可以使用基数N编码器。在类别较多且二进制编码无法处理维度的情况下，我们可以使用更大的基数，如4或8。</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="5ae8" class="mb iy hi lx b fi mc md l me mf">#Import the libraries import category_encoders as ce import pandas as pd #Create the dataframe data=pd.DataFrame({'City':['Delhi','Mumbai','Hyderabad','Chennai','Bangalore','Delhi','Hyderabad','Mumbai','Agra']}) #Create an object for Base N Encoding encoder= ce.BaseNEncoder(cols=['city'],return_df=True,base=5) #Original Data data</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mr"><img src="../Images/04ae58f9f18ddae706793d5d1fe73b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/0*9uziK-UmYWEraOe-.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="f8dd" class="mb iy hi lx b fi mc md l me mf">#Fit and Transform Data data_encoded=encoder.fit_transform(data) data_encoded</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es mt"><img src="../Images/660bd82acb1ae7751fc3a70b60537456.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/0*rAoXlTSg2hkyFJ4d.png"/></div></figure><p id="da8a" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">在上面的例子中，我使用了基数为5的五进制。它类似于二进制编码的例子。二进制编码通过4个新特征表示相同的数据，而BaseN编码仅使用3个新变量。</p><p id="fda6" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">因此，BaseN编码技术进一步减少了有效表示数据所需的特征数量，并提高了内存使用率。基数N的默认基数是2，相当于二进制编码。</p><h1 id="42f6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">目标编码</h1><p id="7b65" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">目标编码是一种贝叶斯编码技术。</p><blockquote class="mu"><p id="1771" class="mv mw hi bd mx my mz na nb nc nd kc dx translated"><em class="ne">贝叶斯编码器使用来自从属/目标变量的信息对分类数据进行编码。</em></p></blockquote><p id="ba83" class="pw-post-body-paragraph km kn hi jr b js nf ij ko ju ng im kp jw nh kr ks jy ni ku kv ka nj kx ky kc hb bi translated">在目标编码中，我们计算每个类别的目标变量的平均值，并用平均值替换类别变量。在分类目标变量的情况下，目标的后验概率代替每个类别..</p><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="ed93" class="mb iy hi lx b fi mc md l me mf">#import the libraries <br/>import pandas as pd <br/>import category_encoders as ce <br/>#Create the Dataframe <br/>data=pd.DataFrame({'class':['A,','B','C','B','C','A','A','A'],'Marks':[50,30,70,80,45,97,80,68]}) <br/>#Create target encoding object encoder=ce.TargetEncoder(cols='class') <br/>#Original Data <br/>Data</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es nk"><img src="../Images/ff8210e4337b695cea5df53f4622b836.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/0*gxSCC5RKwKAjGw8b.png"/></div></figure><pre class="la lb lc ld fd lw lx ly lz aw ma bi"><span id="aeb8" class="mb iy hi lx b fi mc md l me mf">#Fit and Transform Train Data encoder.fit_transform(data['class'],data['Marks'])</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es nl"><img src="../Images/56b8956e6476324b873fc103043fa584.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/0*ZpoSgWTV8HGUlbLc.png"/></div></figure><p id="6c18" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">我们仅对训练数据执行目标编码，并使用从训练数据集获得的结果对测试数据进行编码。虽然，一个非常高效的编码系统，它有以下问题<strong class="jr hj"> </strong>造成模型性能恶化——</p><ol class=""><li id="8703" class="jp jq hi jr b js ll ju lm jw ls jy lt ka lu kc lv ke kf kg bi translated">它会导致目标泄漏或过度拟合。为了解决过度拟合，我们可以使用不同的技术。</li></ol><p id="4279" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">A.在留一编码中，当前目标值从目标的总平均值中减少，以避免泄漏。</p><p id="0f40" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">B.在另一种方法中，我们可以在目标统计中引入一些高斯噪声。该噪声的值是模型的超参数。</p><p id="9210" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">2.我们可能面临的第二个问题是训练和测试数据中类别的不适当分布。在这种情况下，类别可能会采用极端值。因此，该类别的目标平均值与目标的边际平均值相混合。</p><h1 id="d01e" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">尾注</h1><p id="25df" class="pw-post-body-paragraph km kn hi jr b js jt ij ko ju jv im kp jw kq kr ks jy kt ku kv ka kw kx ky kc hb bi translated">总之，对分类数据进行编码是特征工程不可避免的一部分。更重要的是知道我们应该使用什么编码方案。考虑到我们正在处理的数据集和我们将要使用的模型。在本文中，我们看到了各种编码技术及其问题和合适的用例。</p><p id="c833" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated">如果你有任何意见，请在下面的评论中联系我。</p></div><div class="ab cl nm nn gp no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hb hc hd he hf"><p id="07b8" class="pw-post-body-paragraph km kn hi jr b js ll ij ko ju lm im kp jw ln kr ks jy lo ku kv ka lp kx ky kc hb bi translated"><em class="lq">原载于2020年8月13日https://www.analyticsvidhya.com</em><a class="ae lr" href="https://www.analyticsvidhya.com/blog/2020/08/types-of-categorical-data-encoding/" rel="noopener ugc nofollow" target="_blank"><em class="lq"/></a><em class="lq">。</em></p></div></div>    
</body>
</html>