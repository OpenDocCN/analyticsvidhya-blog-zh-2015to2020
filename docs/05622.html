<html>
<head>
<title>Deep dive into Threaded Binary Tree step-by-step</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逐步深入到线程二叉树</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-dive-into-threaded-binary-tree-step-by-step-aa8f90400c5a?source=collection_archive---------8-----------------------#2020-04-27">https://medium.com/analytics-vidhya/deep-dive-into-threaded-binary-tree-step-by-step-aa8f90400c5a?source=collection_archive---------8-----------------------#2020-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/a1236c62c77a286cf0af67792560247d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNpnaHP70L0WLarOMvenww.jpeg"/></div></div></figure><p id="9d87" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你熟悉线程二叉树的概念以及它相对于标准二叉树(BT) /二叉查找树(BST)的优势吗？那么，这篇文章将一步一步地给你分析线程二叉树及其实现。在这篇文章中，我不会深入讨论二叉树和二分搜索法树，这篇文章是关于理解线程二叉树:它相对于二叉树的优势及其实现。我假设你熟悉二叉树和二分搜索法树。</p><p id="87e0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">从名字上看，线程二叉树表明节点是用线程连接的，但是等等，节点是通过<strong class="ja hj">线程</strong>连接的，但是<strong class="ja hj">为什么</strong>和<strong class="ja hj">如何</strong>与普通的二叉查找树有什么不同。对于线索二叉树，我还有几个问题:</p><p id="29fd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Q1。什么是线索二叉树？</p><p id="2488" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Q2。怎么比二叉树好？</p><p id="3a7c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Q3。线索二叉树有哪些类型？</p><p id="a184" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Q4。线程二叉树将如何在Python中实现？</p><p id="7af8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们将逐一分析每个问题。有两种类型的线索二叉树。让我们从它们各自的定义开始:</p><p id="e224" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在<strong class="ja hj">双线程二叉树</strong>中，节点的左指针应该指向<em class="jw">中的前序</em>，右指针应该指向<em class="jw">中的后序。</em>唯一的例外是树中最左边节点的左指针，和树中最右边节点的右指针都要指向<strong class="ja hj"> NULL </strong>。</p><p id="2986" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在<strong class="ja hj">单线程二叉树</strong>中，节点的左指针或右指针指向前序或后序。多线程二叉树的例外是树中最左边节点的左指针和树中最右边节点的右指针都应该指向<strong class="ja hj"> NULL </strong>。</p><p id="c039" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">迷茫？让我们想象一下。</strong></p><p id="40b9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是简单的二叉查找树:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es jx"><img src="../Images/117dd2a5121836cb6eaca7aba2ee0e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*OmSc8L13gi06mISZnbeBEQ.jpeg"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">二叉查找树</figcaption></figure><p id="9bef" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在二叉树/二叉查找树的问题是子节点的左右指针都被浪费了，因为它们都指向空的T21，所以我们需要使用这些指针来更好地遍历，但是怎么做，为什么呢？</p><p id="8394" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">为什么的答案是:</strong></p><blockquote class="kc kd ke"><p id="6704" class="iy iz jw ja b jb jc jd je jf jg jh ji kf jk jl jm kg jo jp jq kh js jt ju jv hb bi translated">在简单的迭代有序遍历中，我们需要使用栈来进行树的有序遍历；因此，通过将树转换成线程二叉树，我们不需要使用栈来进行有序遍历。因此节省了空间。</p><p id="fc4d" class="iy iz jw ja b jb jc jd je jf jg jh ji kf jk jl jm kg jo jp jq kh js jt ju jv hb bi translated">第二个优点是从子节点到根节点的遍历需要较少的遍历；因此，这将增强树算法中的搜索特性，这需要逻辑的持续流动，以在树中频繁地向上和向后。</p></blockquote><p id="07b7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我相信用实现来解释会有更好的理解。我们将在本文中分析双线索树。</p><p id="3765" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">如何的答案是:</strong></p><p id="9ee1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我假设你们大多数人会直接跳到实现，那么现在让我们开始有趣的部分:<strong class="ja hj">它是如何实现的？</strong></p><p id="4058" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我们看看下面的树的有序遍历:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es jx"><img src="../Images/117dd2a5121836cb6eaca7aba2ee0e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*OmSc8L13gi06mISZnbeBEQ.jpeg"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">为了穿越二叉查找树</figcaption></figure><h2 id="db7c" class="ki kj hi bd kk kl km kn ko kp kq kr ks jj kt ku kv jn kw kx ky jr kz la lb lc bi translated">上述树的顺序遍历是:</h2><h2 id="3fcf" class="ki kj hi bd kk kl km kn ko kp kq kr ks jj kt ku kv jn kw kx ky jr kz la lb lc bi translated"><strong class="ak">5-&gt;7-&gt;8-&gt;10-&gt;25-&gt;30</strong></h2><p id="c81b" class="pw-post-body-paragraph iy iz hi ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hb bi translated"><em class="jw">(以防您忘记遍历顺序:访问左节点，然后根节点，然后右节点)</em></p><p id="8fad" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">非常简单，现在让我们跳到如何使用它来制作线程二叉树:</p><h2 id="c788" class="ki kj hi bd kk kl km kn ko kp kq kr ks jj kt ku kv jn kw kx ky jr kz la lb lc bi translated"><strong class="ak">制作线索树的步骤:</strong></h2><ol class=""><li id="e02d" class="li lj hi ja b jb ld jf le jj lk jn ll jr lm jv ln lo lp lq bi translated">让我们开始遍历，我们遍历到树的最左边的节点:</li></ol><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lr"><img src="../Images/052f6787e4398ac3e30d9cf3e8b719a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*A2HdOymeiB_5C1919yjoFw.jpeg"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">显示节点值为5的线程</figcaption></figure><p id="600c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">最左边的节点是5。5的有序前任为空；因此，它指向NULL，并且5的有序后继者是7，因此节点值5的右指针指向7。</p><p id="6d32" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">2.遍历节点值<strong class="ja hj"> 8 </strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lr"><img src="../Images/9d941f5c11511710c8e551b6a14dcb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*Cs0GWUdcMlTaxUrLVH1c-w.jpeg"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">显示节点值为8的线程</figcaption></figure><p id="24f8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在上图中，递归地回到根节点(7)，它检查正确的节点。在这种情况下，节点值7的右边节点是8。首先，我们将检查节点的左指针；如果它为空，那么我们将把它指向该节点的后继节点，即7。对于右边的指针，我们将检查它是否指向NULL，然后我们将修改对后继节点的引用，即10，因此它将指向10。</p><p id="e209" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">3.对于<strong class="ja hj"> 25 </strong>同样如此:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lr"><img src="../Images/3615ec9bf44dbbf68bc690cf4a6205da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*lzGleafjCC9KI6V7V-ovww.jpeg"/></div></figure><p id="d03d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">4.<strong class="ja hj"> 30 </strong>的逻辑类似。因为这是树的最右边的节点，所以它的右边指针将指向NULL。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ls"><img src="../Images/54cd2677e48bee32f870d1f1bc7145e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*QkDfcw3FpOtBQfcnmIZAIA.jpeg"/></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="db40" class="ki kj hi bd kk kl km kn ko kp kq kr ks jj kt ku kv jn kw kx ky jr kz la lb lc bi translated"><strong class="ak">编码时间！！</strong></h2><p id="b867" class="pw-post-body-paragraph iy iz hi ja b jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv hb bi translated">让我们看看上面的线程树的编程Python实现:</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="cbcf" class="ki kj hi lu b fi ly lz l ma mb">class Node: <br/>    def __init__(self,key): <br/>        self.left = None<br/>        self.right = None<br/>        self.val = key</span><span id="de27" class="ki kj hi lu b fi mc lz l ma mb">if __name__ == "__main__":<br/>queue = []<br/>counter = 0<br/>root = Node(10) <br/>root.left     = Node(7) <br/>root.right     = Node(25) <br/>root.left.left = Node(5) <br/>root.left.right = Node(8) <br/>root.right.right = Node(30)</span></pre><p id="4a0c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在上图中，我已经初始化了节点并构建了一个树形结构。我还初始化了空队列(Queue)和一个计数器变量(我们将讨论在哪里使用队列和计数器变量)。</p><p id="87ec" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，在下面的代码中，我们正在对树进行有序遍历，我们将有序遍历结果节点存储在队列中，如下所示:</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="d064" class="ki kj hi lu b fi ly lz l ma mb">def printInorder(root,queue): <br/>    if root: <br/>        # Recursion on left child<br/>        printInorder(root.left,queue)</span><span id="9f73" class="ki kj hi lu b fi mc lz l ma mb"># Printing the data of the node<br/>        print(root.val)<br/>        queue.append(root)</span><span id="a9f5" class="ki kj hi lu b fi mc lz l ma mb"># Recursion on the right child<br/>        printInorder(root.right,queue)</span></pre><p id="0bcd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，主要的逻辑来了，<strong class="ja hj">创建线程二叉树</strong>:</p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="0881" class="ki kj hi lu b fi ly lz l ma mb">def createThreadedTree(root,queue,counter):<br/>    if root == None:<br/>        return<br/>    if root.left is not None:<br/>        createThreadedTree(root.left,queue,counter)<br/>        counter += 1<br/>    else:<br/>        if counter == 0:<br/>            root.left = None<br/>        else:<br/>            node = queue.pop(0)<br/>            root.left = node<br/>    if root.right is not None:<br/>        createThreadedTree(root.right,queue,counter)<br/>    else:<br/>        node = queue.pop(0)<br/>        if len(queue) &gt; 0:<br/>            root.right = queue[0]<br/>        else:<br/>            root.right = None</span></pre><p id="acb5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是对上面创建线索树的代码的解释:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es md"><img src="../Images/43a94b4c7f70ac58127b5bda05c2d575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sG55aNCB9VjcGiG2PqKkXw.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">创建线程二叉树的Python实现</figcaption></figure><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="b7f6" class="ki kj hi lu b fi ly lz l ma mb">Line <strong class="lu hj">4</strong> to <strong class="lu hj">5: </strong>recursively reach till the left most node of the tree.</span><span id="b5bb" class="ki kj hi lu b fi mc lz l ma mb">Line <strong class="lu hj">6:</strong> counter is only incremented when it is not the leftmost node of the tree.</span><span id="b310" class="ki kj hi lu b fi mc lz l ma mb">Line <strong class="lu hj">8</strong>: Counter is used to identify weather it is <br/>left most node or node, if it is then assign NULL value to it.</span><span id="4d80" class="ki kj hi lu b fi mc lz l ma mb">Line <strong class="lu hj">11: </strong>If not the leftmost node, then<strong class="lu hj"> </strong>Pop the element from the queue (queue having Inorder traversal of nodes) and assign the left pointer of node to Inorder predessor to the node</span><span id="098b" class="ki kj hi lu b fi mc lz l ma mb">Line <strong class="lu hj">13</strong>: Similary, recursively find the right node, if the right pointer of node is pointing to null then pop the element from the queue and assign the Inorder successor to the right pointer of that node.</span><span id="553c" class="ki kj hi lu b fi mc lz l ma mb">Line <strong class="lu hj">17</strong>: Length of queue is used to identify weather it is right most child or not</span></pre><p id="31d1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，我们已经看到了创建线程二叉树的实现及其概念，此时我心中有一个问题:</p><p id="1b05" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">遍历时，我如何识别子节点的指针是否指向有序的前趋/后继，或者它们是指向其子节点的父节点？这个问题的答案是创建一个带有两个标签的节点<strong class="ja hj">左标签</strong>和<strong class="ja hj">右标签</strong>。如果指针指向子节点，那么我们将把左/右标签的布尔值设置为<strong class="ja hj"> 1 </strong>，否则如果指针指向前一个或后一个节点，那么我们将把左/右标签的布尔值设置为<strong class="ja hj"> 0 </strong>。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es me"><img src="../Images/ffe6d3a158d8c5c39b16793f3f1784f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*aCUKXUjr7yrAxNbGa0Whcg.jpeg"/></div></figure><p id="1e15" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">因此，下面是创建带有左右标签的线索二叉树的更新实现。</strong></p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="d95b" class="ki kj hi lu b fi ly lz l ma mb">def createThreadedTree(root,queue,counter):<br/>    if root == None:<br/>        return<br/>    if root.left is not None:<br/>        createThreadedTree(root.left,queue,counter)<br/>        counter += 1<br/>    else:<br/>        # Added left tag<br/>        root.left_tag = 0<br/>        <br/>        if counter == 0:<br/>            root.left = None<br/>        else:<br/>            node = queue.pop(0)<br/>            root.left = node<br/>    if root.right is not None:<br/>        createThreadedTree(root.right,queue,counter)<br/>    else:<br/>        node = queue.pop(0)<br/>        <br/>        # Added Right Tag<br/>        root.right_tag = 0<br/>        <br/>        if len(queue) &gt; 0:<br/>            root.right = queue[0]<br/>        else:<br/>            root.right = None</span></pre><p id="9c67" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在上面的实现中，每当子节点指向父节点时，左/右标签更新为<strong class="ja hj"> 0 </strong>，这取决于哪个指针指向父节点。</p><p id="f2ef" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">下面是线程二叉树的有序遍历代码:</strong></p><pre class="in io ip iq fd lt lu lv lw aw lx bi"><span id="0a4f" class="ki kj hi lu b fi ly lz l ma mb">def inorderThreadedTree(root):<br/>    node = root<br/>    #This is to go the leftmost node of the tree<br/>    while(node.left):<br/>        node = node.left<br/>    <br/>    #this is to check for all nodes<br/>    while(node is not None):<br/>        # if the left pointers of the nodes pointing to parent node <br/>        # then print the value and go to the <br/>        # right node (parent node). <br/>        # This is identified using left_tag <br/>        # (0 means poiting to parent node)<br/>        if node.left_tag == 0:<br/>            print(node.val)<br/>            node = node.right<br/>        else:<br/>            print(node.val)<br/>            node = node.right<br/>            # if pointing to child node then keep on moving to child<br/>            # left node<br/>            if node and node.left_tag == 1:<br/>                node = node.left</span></pre><p id="cdaf" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> Pheww，就是这样！！</strong></p><p id="ed8c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我希望我已经成功地解释了我对线索二叉树的所有理解。请让我知道，如果逻辑/代码需要一些修改，或者如果你想提出更好的线程二叉树的实现。我非常乐意阅读你的建议。</p><h2 id="0012" class="ki kj hi bd kk kl km kn ko kp kq kr ks jj kt ku kv jn kw kx ky jr kz la lb lc bi translated">数据结构很有趣！！编码快乐！！</h2></div></div>    
</body>
</html>