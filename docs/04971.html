<html>
<head>
<title>Induction Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">归纳原则</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/induction-principles-b64c8686d1a2?source=collection_archive---------39-----------------------#2020-04-06">https://medium.com/analytics-vidhya/induction-principles-b64c8686d1a2?source=collection_archive---------39-----------------------#2020-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">链表的归纳原则让我们想起了自然数的归纳原则。树呢？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/85c40e20768db5a2f8ad3cf211497bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*sl9nPfF0mEJ8JyGRHemm_w.png"/></div></figure><p id="b31d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">归纳法</strong>，有时也叫<em class="jd">数学归纳法</em>，是一种对可数无限结构进行推理的工具。通常，我们可以用一种叫做“归纳法证明”的东西来验证存在于无穷远处的事实。</p><p id="1bbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来复习一下。假设你在一所大学主修计算机科学，这是你的第一年:你被要求<strong class="ih hj">展示</strong>那个<code class="du jm jn jo jp b">a + b = b + a</code>。我们都希望你能按照以下步骤进行-</p><ul class=""><li id="a08e" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:教授，<code class="du jm jn jo jp b">a</code>和<code class="du jm jn jo jp b">b</code>是什么？</li><li id="051f" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong> : <code class="du jm jn jo jp b">a</code>和<code class="du jm jn jo jp b">b</code>是任意自然数</li><li id="48bc" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:和<code class="du jm jn jo jp b">+</code>符号，是普通自然数加法？</li><li id="880f" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">T21教授:是的</li><li id="81f4" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">你:武断是什么意思？</li></ul><p id="4ea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">教授更新了问题。“请出示<code class="du jm jn jo jp b">forall (a b : nat), a + b = b + a</code>”</p><p id="c9c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望你不要从下面的列表开始</p><pre class="jf jg jh ji fd ke jp kf kg aw kh bi"><span id="5b61" class="ki kj hi jp b fi kk kl l km kn">0 + 1 = 1 + 0 <br/>1 + 2 = 2 + 1 <br/>0 + 2 = 2 + 0 <br/>...</span></pre><p id="7acf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使你意识到存在一个系统的列表程序，你也会因为缺少纸张而受挫，因为你被要求对一个<em class="jd">无限</em>集合的所有进行操作(或者，在短时间内，对<em class="jd"> a类型</em>进行操作)。</p><p id="cff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，我们希望你开始下面的<em class="jd">证明</em></p><ul class=""><li id="045e" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:设<code class="du jm jn jo jp b">a</code>和<code class="du jm jn jo jp b">b</code>为任意的<code class="du jm jn jo jp b">nat</code> s .通过对<code class="du jm jn jo jp b">a</code>的归纳，有两种情况需要证明。第一种情况，<code class="du jm jn jo jp b">a = Z</code>。我们需要验证的目标是<code class="du jm jn jo jp b">Z + b = b + Z</code>。由于<code class="du jm jn jo jp b">Z</code>是相对于<code class="du jm jn jo jp b">+</code>的中性<code class="du jm jn jo jp b">nat</code>，这就简化为<code class="du jm jn jo jp b">b = b</code>，我们通过反身性知道。在第二种情况下，让<code class="du jm jn jo jp b">n</code>是某个任意的<code class="du jm jn jo jp b">nat</code>并假设<code class="du jm jn jo jp b">n + b = b + n</code>。我们需要验证的目标是<code class="du jm jn jo jp b">(Suc n) + b = b + (Suc n)</code>。根据<code class="du jm jn jo jp b">+</code>的定义，我们可以将其简化为<code class="du jm jn jo jp b">Suc (n + b) = b + (Suc n)</code>，然后应用我们的假设，将我们的目标转换为<code class="du jm jn jo jp b">Suc (b + n) = b + (Suc n)</code>。如果我们配备了一个引理，使得<code class="du jm jn jo jp b">Suc</code>可以从右边的论证而不是左边的论证中提取出来，我们可以应用它来获得<code class="du jm jn jo jp b">Suc (b + n) = Suc (b + n)</code>，通过反身性我们可以看到它是真实的。</li><li id="5c3f" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong>:非常好。让我们在接下来的课程中更仔细地了解一些细节。<code class="du jm jn jo jp b">nat</code>正是由一个<strong class="ih hj">空构造函数</strong>(或<em class="jd">常量</em>)和一个<strong class="ih hj">一元构造函数</strong>组成的数据类型。前者是著名的数字<code class="du jm jn jo jp b">Z</code>，后者是后继函数<code class="du jm jn jo jp b">Suc</code>，通称<code class="du jm jn jo jp b">Suc n = n + 1</code>。现在请给我们解释一下你提到的<code class="du jm jn jo jp b">+</code>的定义。</li><li id="5194" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">Coq中自然数上加号的定义</figcaption></figure><ul class=""><li id="aaca" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">教授:太棒了！因为我的班上都是程序员，所以我希望他们中的一个能解释这是怎么回事？</li><li id="330b" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">你的<strong class="ih hj">模式匹配</strong>有两个分支，因为你的类型像教授说的有两个构造函数。当左自变量<code class="du jm jn jo jp b">n</code>为<code class="du jm jn jo jp b">Z</code>时，返回右自变量<code class="du jm jn jo jp b">m</code>，否则将<code class="du jm jn jo jp b">n</code>解构为<code class="du jm jn jo jp b">S n'</code>，其中<code class="du jm jn jo jp b">n'</code>也是<code class="du jm jn jo jp b">nat</code>，返回表达式<code class="du jm jn jo jp b">S (plus n' m)</code>。</li><li id="a32b" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong>:确实。换句话说，非零的情况看起来像<code class="du jm jn jo jp b">n + m = 1 + (n-1) + m</code>，因此该术语减少到<code class="du jm jn jo jp b">Z</code>。现在需要有人在板上写<code class="du jm jn jo jp b">nat</code>。辛普利西欧，你准备好了吗？</li><li id="26b8" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">辛普利西奥:当然可以。</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">Coq中自然数类型的定义</figcaption></figure><ul class=""><li id="ca28" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong>:谢谢。现在谁愿意证明一个列表的两次反转<code class="du jm jn jo jp b">l</code>等于<code class="du jm jn jo jp b">l</code>？</li><li id="dfb4" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">你没有。</li><li id="9336" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">教授:打扰一下？</li><li id="d263" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">教授，我认为他们的意思是，我们还不知道如何处理列表，也不知道如何反过来处理列表。</li><li id="5163" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">教授:很好。给我一点时间。</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div></figure><ul class=""><li id="bfd9" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">教授:如果你愿意的话</li><li id="d699" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">Coq中reverse (reverse l) = l的证明</figcaption></figure><p id="0dc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Coq中，每个归纳数据类型(即用<code class="du jm jn jo jp b">Inductive</code>关键字定义的类型)都配备了一个<strong class="ih hj">归纳原则</strong>。让我们观察下面的定义</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">一个愚蠢但非常真实的数据类型</figcaption></figure><p id="087f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是说正面是一个硬币，反面是一个硬币，如果你运行这段代码时观察Coq系统的输出，它会说</p><pre class="jf jg jh ji fd ke jp kf kg aw kh bi"><span id="a2e2" class="ki kj hi jp b fi kk kl l km kn">coin is defined <br/>coin_rect is defined <br/>coin_ind is defined <br/>coin_rec is defined</span></pre><p id="cee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jm jn jo jp b">coin_ind</code>是硬币数据类型的归纳原则。让我们运行<code class="du jm jn jo jp b">Check coin_ind</code>将其打印出来</p><pre class="jf jg jh ji fd ke jp kf kg aw kh bi"><span id="b811" class="ki kj hi jp b fi kk kl l km kn">coin_ind <br/>     : forall P : coin -&gt; Prop, P heads -&gt; P tails -&gt; forall c : coin, P c</span></pre><p id="5021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是一个函数类型。在英语中，它说“对于硬币上的每个谓词，如果它有头和尾，那么它适用于所有硬币。”</p><p id="02f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看它的运行，定义一个谓词(一个函数<code class="du jm jn jo jp b">coin -&gt; Prop</code>，其中<code class="du jm jn jo jp b">Prop</code>代表命题)</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">专门针对特定谓词的归纳原则</figcaption></figure><p id="a7d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经<em class="jd">特殊化了</em>归纳原则，该原则被定义在一个特定谓词<code class="du jm jn jo jp b">is_heads</code>的所有谓词上。为了进一步特殊化它，我们需要提供一个<code class="du jm jn jo jp b">is_heads heads</code>的证明，并且为了一直特殊化它，我们需要一个<code class="du jm jn jo jp b">is_heads tails</code>的证明。<code class="du jm jn jo jp b">is_heads tails</code>不是可证命题，所以例子很傻。</p><p id="8723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想向您展示<em class="jd">函数应用发生在类型级别</em>并且<em class="jd">专门化一个</em> <code class="du jm jn jo jp b"><em class="jd">forall</em></code> <em class="jd">的行为就像向函数</em>提供一个参数。</p><ul class=""><li id="f4fa" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong>:您在列表示例中用来生成目标和归纳假设的<em class="jd">战术</em>和<code class="du jm jn jo jp b">induction</code>正是由<code class="du jm jn jo jp b">listnat</code>的归纳原理赋予的。观察。</li></ul><p id="e521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">教授在黑板上写下<code class="du jm jn jo jp b">Check listna_ind</code>,就在它下面开始具体化以下类型</p><pre class="jf jg jh ji fd ke jp kf kg aw kh bi"><span id="73ee" class="ki kj hi jp b fi kk kl l km kn">listnat_ind <br/>     : forall P : listnat -&gt; <br/>       Prop, P empt -&gt; <br/>       (forall (h : nat) (t : listnat), P t -&gt; P (cons h t)) -&gt;                      forall l : listnat, P l</span></pre><ul class=""><li id="9e18" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">教授:在英语中，这种类型是说，如果我有一个关于链表的任意谓词，如果我有一个证明它适用于空链表，并且证明如果它适用于某个链表，那么它适用于那个带有前缀的链表，那么我有效地证明了它适用于所有的链表。事实上，正是这种类型告诉<code class="du jm jn jo jp b">induction</code>关键词<em class="jd">如何</em>为你产生目标和假设。</li><li id="3125" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">辛普利西奥:当然，我相信。这让我想起了普通感应过<code class="du jm jn jo jp b">nat</code>。</li><li id="a457" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:那是因为类型差不多。两者都有一个常量构造函数和另一个带有一个自引用点的构造函数。</li><li id="f821" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">Simplicio :教授，您能打印出<code class="du jm jn jo jp b">nat</code>的归纳原理吗？</li><li id="f9f5" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong> : <code class="du jm jn jo jp b">Check nat_ind</code></li></ul><pre class="jf jg jh ji fd ke jp kf kg aw kh bi"><span id="4ede" class="ki kj hi jp b fi kk kl l km kn">nat_ind <br/>     : forall P : nat -&gt; Prop, <br/>       P Z -&gt; <br/>       (forall n : nat, P n -&gt; P (S n)) -&gt; <br/>       forall n : nat, P n</span></pre><ul class=""><li id="7880" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:看，<code class="du jm jn jo jp b">listnat_ind</code>中的术语<code class="du jm jn jo jp b">h</code>很重要，但它不会影响字体的<em class="jd">形状</em>，因为影响<em class="jd">形状</em>的只有自参照点。</li><li id="4441" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong>:非常好。</li></ul><p id="52a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前一种类型的英文翻译是<em class="jd">字面上的</em>普通的、普通的“数学归纳”的定义。<strong class="ih hj">类型</strong> <code class="du jm jn jo jp b"><strong class="ih hj">nat_ind</strong></code> <strong class="ih hj">只不过是如何证明关于</strong> <code class="du jm jn jo jp b"><strong class="ih hj">nat</strong></code>的东西的算法描述，你会发现对于任何其他归纳类型也是如此(包括<code class="du jm jn jo jp b">bool</code>(我们看到的另一个名字是<code class="du jm jn jo jp b">coin</code>)、各种类型的树，甚至整个编程语言)。</p><ul class=""><li id="b0ca" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">教授:在我们结束归纳讨论之前，最后一个例子。你，请在黑板上写下树叶中有数据的树的类型。</li><li id="0d61" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">你</strong>:</li></ul><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">树叶中有数据的树的类型</figcaption></figure><p id="3b66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">棋盘闪烁着光芒，宣布:<code class="du jm jn jo jp b">tree is defined. tree_ind is defined.</code></p><ul class=""><li id="1e81" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">教授</strong>:辛普利西奥。请告诉我们你如何计算<code class="du jm jn jo jp b">tree</code>的感应原理，而不是让系统打印出来。</li><li id="5f08" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">辛普里西奥</strong> : <em class="jd">大口</em>。好吧。您必须从量化谓词开始，所以我会从<code class="du jm jn jo jp b">forall P : tree -&gt; Prop, ...</code>开始。我们有两个构造函数，所以将有两个证明来支持结论<code class="du jm jn jo jp b">forall (t : tree), P t</code>。然后，我注意到第一个构造函数没有任何自引用，所以需要的第一个证明是<code class="du jm jn jo jp b">forall (n : nat), P (leaf n)</code>。现在我们来看一下自引用构造函数，即<code class="du jm jn jo jp b">node</code>的构造函数。一个<code class="du jm jn jo jp b">node</code>结构中有两个<code class="du jm jn jo jp b">tree</code>，所以这个证明应该有两个前提，看起来像<code class="du jm jn jo jp b">_ -&gt; _ -&gt; _</code>，我知道会是<code class="du jm jn jo jp b">_ -&gt; _ -&gt; P (node l r)</code>。我们需要建立<code class="du jm jn jo jp b">l</code>和<code class="du jm jn jo jp b">r</code>，所以会有量词，最后我们需要假设减少的实参的谓词，所以第二个构造函数对应的证明是<code class="du jm jn jo jp b">forall (l : tree), P l -&gt; forall (r : tree), P r -&gt; P (node l r)</code>。现在我可以把它们都包起来，然后说</li></ul><pre class="jf jg jh ji fd ke jp kf kg aw kh bi"><span id="88a5" class="ki kj hi jp b fi kk kl l km kn">tree_ind <br/>     : forall P : tree -&gt; Prop, <br/>       (forall (n : nat), P (leaf n)) -&gt; <br/>       (forall (l : tree), P l -&gt; forall (r : tree), P r -&gt; P (node l r)) -&gt; <br/>       forall (t : tree), P t</span></pre><p id="65a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">要了解更多信息，请阅读</em> <a class="ae ku" href="https://softwarefoundations.cis.upenn.edu" rel="noopener ugc nofollow" target="_blank"> <em class="jd">软件基础</em> </a>。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="a41d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">最初发表于</em><a class="ae ku" href="https://gist.github.com/quinn-dougherty/a16724272a5d9bc793f61d4681accbfc" rel="noopener ugc nofollow" target="_blank"><em class="jd">【http://github.com】</em></a><em class="jd">。</em></p></div></div>    
</body>
</html>