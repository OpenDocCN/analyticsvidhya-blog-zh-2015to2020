<html>
<head>
<title>Chat Room using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的聊天室</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/chat-room-server-using-python-ab34d8cb1567?source=collection_archive---------16-----------------------#2020-07-13">https://medium.com/analytics-vidhya/chat-room-server-using-python-ab34d8cb1567?source=collection_archive---------16-----------------------#2020-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1e80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di"> T </span>他的文章简要介绍了使用Python编程语言建立聊天室并允许多个用户相互交流的想法。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/dcfcf34a682f0b2908ddd0482af5af78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gkMQ0-I3Mid0l5pS"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">由<a class="ae kc" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="kd ke kf"><p id="5c18" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">在深入之前，我们先了解一下什么是插座。</p></blockquote><h1 id="f7b1" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么是插座？</h1><p id="670e" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">一个<strong class="ih hj">套接字</strong>是在网络上运行的两个程序之间的双向通信链路的一个端点。“当我们谈到Python时，套接字编程是一种连接网络上两个节点以便相互通信的方法。在Python代码中，我们将使用套接字库，因为它使用户能够通过网络传输信息</p><p id="0e97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将在网络的两端设置一个套接字，并允许客户端通过服务器与其他客户端进行交互。会有两种不同的剧本-</p><ol class=""><li id="9fbf" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated"><strong class="ih hj">服务器端脚本</strong></li><li id="d0ce" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">客户端脚本</strong></li></ol><p id="77b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在操作系统命令提示符或终端中运行这些脚本。当服务器端脚本运行时，它等待客户端连接。一旦建立了连接，客户端和服务器就可以相互通信了。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><blockquote class="kd ke kf"><p id="4c8c" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">“Python从一开始就是Google的重要组成部分，并且随着系统的成长和发展而保持不变。如今，数十名谷歌工程师使用Python，我们正在寻找更多掌握这种语言的人。”</p><p id="980e" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">~ Peter Norvig，<a class="ae kc" href="http://google.com/" rel="noopener ugc nofollow" target="_blank">谷歌公司的搜索质量总监</a></p></blockquote></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h1 id="ec4e" class="kk kl hi bd km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld mm lf lg lh bi translated">服务器端<strong class="ak">脚本</strong></h1><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es mn"><img src="../Images/b7cc07d4bbe38d1defa02afb9244b786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wZkyYBodFLjUwgCs"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">托马斯·詹森在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="35fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是必须运行的第一个脚本，以便建立一个套接字，按照代码中的指定将主机和端口绑定在一起。现在，我们将使用Localhost进行演示。</p><p id="0a2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">导入库:</strong></p><p id="3eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">套接字库使用户能够通过网络传输信息。它提供了bind()、send()、recv()、close()等各种函数。为此我们使用TCP套接字，因此我们使用<code class="du mo mp mq mr b">AF_INET</code>和<code class="du mo mp mq mr b">SOCK_STREAM</code>标志。导入后，让我们设置一些<em class="kg">常量</em>以备后用:</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="5b11" class="mw kl hi mr b fi mx my l mz na">import socket<br/>import select <br/>HEADER_LENGTH = 10 <br/>IP = "127.0.0.1"<br/>PORT = 4321</span></pre><p id="a59b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">插座连接:</strong></p><p id="9f8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建一个套接字并将其与IP和端口连接，我们将使用以下语句-</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="a453" class="mw kl hi mr b fi mx my l mz na">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span></pre><p id="170f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Bind和Listen : </strong>接下来，我们将使用Bind()和Listen()。bind()方法将服务器绑定到特定的IP和端口。listen()方法将服务器置于监听模式。这允许服务器侦听新的连接。</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="e36f" class="mw kl hi mr b fi mx my l mz na">server_socket.bind((IP, PORT))<br/>server_socket.listen()</span></pre><p id="4494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建列表并调试:</strong></p><p id="ec43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将创建一个套接字列表来选择和跟踪我们的客户端。该列表将连接到客户端。在这里，插座被用作钥匙。</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="68d9" class="mw kl hi mr b fi mx my l mz na">sockets_list = [server_socket]<br/>clients = {}<br/>print(f 'Listening for connections on {IP}:{PORT}...')</span></pre><p id="e341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接收消息:</strong></p><p id="a674" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，服务器必须接收消息并将它们显示给连接的客户机。它执行以下步骤</p><ul class=""><li id="91ba" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc nb lt lu lv bi translated">阅读标题。</li><li id="16ed" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">如果客户端以任何方式失去连接，那么socket.close()方法将有助于返回false值。</li><li id="f704" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">将标头转换为长度(整数值)。</li><li id="da40" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">返回一些有意义的数据。</li><li id="5318" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">如果上述条件为假，则返回假。</li></ul><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="1ae6" class="mw kl hi mr b fi mx my l mz na">def receive_message(client_socket):<br/>try:<br/>  message_header = client_socket.recv(HEADER_LENGTH)<br/>  <br/>  if not len(message_header):<br/>      return False<br/>        <br/>  message_length = int(message_header.decode('utf-8').strip())<br/>        <br/>  return {'header': message_header, 'data': client_socket.recv(message_length)}</span><span id="cc8c" class="mw kl hi mr b fi nc my l mz na">except:<br/>   return False</span></pre><p id="9621" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">阅读和传递信息:</strong></p><p id="4502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们必须从所有的客户端套接字读取消息，并将它们发送到各自的客户端。这是通过以下方式实现的:</p><ul class=""><li id="59e8" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc nb lt lu lv bi translated">我们将使用“while循环”,然后我们将使用select.select</li><li id="dc93" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">我们现在将遍历read_sockets列表。这些是必须读取数据的套接字。</li><li id="09a9" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">如果通知的套接字是我们的服务器套接字，那么这意味着我们得到了一个新的连接，我们想要处理它。</li><li id="dca6" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">现在，我们想把这个新的client_socket添加到sockets_list中。</li><li id="aa10" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">最后，我们将保存这个客户机的用户名，我们将把它保存为socket对象的键值。</li><li id="b43a" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">如果客户端断开连接，那么消息将是空的。</li><li id="7f10" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc nb lt lu lv bi translated">假设这不是一个断开。</li></ul><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="7ac2" class="mw kl hi mr b fi mx my l mz na">while True:<br/>read_sockets, _, exception_sockets = select.select(sockets_list, [], sockets_list)<br/>    <br/>for notified_socket in read_sockets:<br/>        <br/>if notified_socket == server_socket:<br/>            <br/>client_socket, client_address = server_socket.accept()<br/>            <br/>user = receive_message(client_socket)<br/>            <br/>if user is False:<br/>   continue<br/>           <br/>sockets_list.append(client_socket)<br/>            <br/>clients[client_socket] = user</span><span id="412e" class="mw kl hi mr b fi nc my l mz na">print('Accepted new connection from {}:{}, username{}'.format(*client_address, user['data'].decode('utf-8')))<br/>        <br/>else:<br/>   message = receive_message(notified_socket)</span><span id="a5eb" class="mw kl hi mr b fi nc my l mz na">if message is False:<br/>   print('Closed connection from:{}'.format(clients[notified_socket]['data'].decode('utf-8')))</span><span id="49ef" class="mw kl hi mr b fi nc my l mz na">sockets_list.remove(notified_socket)</span><span id="33b5" class="mw kl hi mr b fi nc my l mz na">del clients[notified_socket]</span><span id="a003" class="mw kl hi mr b fi nc my l mz na">continue</span><span id="0434" class="mw kl hi mr b fi nc my l mz na">user = clients[notified_socket]</span><span id="c745" class="mw kl hi mr b fi nc my l mz na">print(f'Received message from {user["data"].decode("utf-8")}:{message["data"].decode("utf-8")}')</span><span id="31a3" class="mw kl hi mr b fi nc my l mz na">for client_socket in clients:<br/>      <br/>if client_socket != notified_socket:</span><span id="0ed7" class="mw kl hi mr b fi nc my l mz na">client_socket.send(user['header'] + user['data'] + message['header'] + message['data'])</span><span id="e504" class="mw kl hi mr b fi nc my l mz na">for notified_socket in exception_sockets:</span><span id="b567" class="mw kl hi mr b fi nc my l mz na">sockets_list.remove(notified_socket)</span><span id="6c7c" class="mw kl hi mr b fi nc my l mz na">del clients[notified_socket]</span></pre><blockquote class="kd ke kf"><p id="496c" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">不要忘记将这个文件保存为- Server.py</p></blockquote></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h1 id="480e" class="kk kl hi bd km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld mm lf lg lh bi translated">客户端</h1><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es nd"><img src="../Images/ac3da8da2cc045b0e50d04e3b2d798ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*meAtuqanABvC5WBA"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">照片由<a class="ae kc" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="10a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要一些可以与我们的服务器交互的东西。初始步骤与Server.py相同</p><blockquote class="kd ke kf"><p id="47c0" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">该文件将保存为Client.py</p></blockquote><p id="a7af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">导入库:</strong></p><p id="4501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">套接字库使用户能够通过网络传输信息。它提供了bind()、send()、recv()、close()等各种函数。为此我们使用TCP套接字，因此我们使用<code class="du mo mp mq mr b">AF_INET</code>和<code class="du mo mp mq mr b">SOCK_STREAM</code>标志。导入后，让我们设置一些<em class="kg">常量</em>以备后用:</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="f89e" class="mw kl hi mr b fi mx my l mz na">import socket<br/>import select<br/>import errno</span><span id="b007" class="mw kl hi mr b fi nc my l mz na">HEADER_LENGTH = 10<br/>IP = "127.0.0.1"<br/>PORT = 4321<br/>my_username = input("Username: ")</span><span id="210f" class="mw kl hi mr b fi nc my l mz na">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><span id="a950" class="mw kl hi mr b fi nc my l mz na">client_socket.connect((IP, PORT))</span></pre><p id="603f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">连接服务器:</strong></p><p id="a9c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要将<strong class="ih hj"> s </strong> et连接到非阻塞状态，所以recv()调用不会阻塞，只是返回一些异常。我们将把recv方法设置为不阻塞。我们的服务器希望第一条消息是用户名</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="1ecf" class="mw kl hi mr b fi mx my l mz na">client_socket.setblocking(False)</span><span id="94b2" class="mw kl hi mr b fi nc my l mz na">username = my_username.encode('utf-8')</span><span id="b0c2" class="mw kl hi mr b fi nc my l mz na">username_header =f"{len(username):&lt;{HEADER_LENGTH}}".encode('utf-8')</span><span id="2a5b" class="mw kl hi mr b fi nc my l mz na">client_socket.send(username_header + username)</span></pre><p id="7373" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通过消息交流:</strong></p><p id="6700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在已经为客户端的主循环做好了准备，它将接受来自客户端的新消息。我们将用户名附加到客户端发送的消息中。</p><p id="28c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也想要接收信息。为了显示消息，我们需要用户名和消息，它们都有单独的头和内容。我们会得到真实的用户名。用同样的逻辑，我们可以得到信息。然后我们将用户名和消息输出到屏幕上。</p><pre class="jn jo jp jq fd ms mr mt mu aw mv bi"><span id="776c" class="mw kl hi mr b fi mx my l mz na">while True:<br/>    message = input(f'{my_username} &gt; ')</span><span id="db15" class="mw kl hi mr b fi nc my l mz na">if message:<br/>        message = message.encode('utf-8')<br/>        message_header = f"{len(message):&lt;{HEADER_LENGTH}}".encode('utf-8')<br/>        client_socket.send(message_header + message)</span><span id="3231" class="mw kl hi mr b fi nc my l mz na">try:<br/>        while True:<br/>            username_header = client_socket.recv(HEADER_LENGTH)</span><span id="ee14" class="mw kl hi mr b fi nc my l mz na">if not len(username_header):<br/>                print('Connection closed by the server')<br/>                exit()<br/>username_length = int(username_header.decode('utf-8').strip())</span><span id="d0fe" class="mw kl hi mr b fi nc my l mz na">username = client_socket.recv(username_length).decode('utf-8')</span><span id="2760" class="mw kl hi mr b fi nc my l mz na">message_header = client_socket.recv(HEADER_LENGTH)</span><span id="cd6d" class="mw kl hi mr b fi nc my l mz na">message_length = int(message_header.decode('utf-8').strip())</span><span id="27a0" class="mw kl hi mr b fi nc my l mz na">message = client_socket.recv(message_length).decode('utf-8')</span><span id="a233" class="mw kl hi mr b fi nc my l mz na">print(f'{username} &gt; {message}')</span><span id="7f12" class="mw kl hi mr b fi nc my l mz na">except IOError as e:<br/>   if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:<br/>       print('Reading error: {}'.format(str(e)))<br/>       exit()</span><span id="e3a7" class="mw kl hi mr b fi nc my l mz na">continue</span><span id="ad52" class="mw kl hi mr b fi nc my l mz na">except Exception as e:<br/>exit()</span></pre></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><blockquote class="kd ke kf"><p id="997e" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated"><em class="hi">祝贺你能坚持到现在。你现在可以建立自己的聊天室了。</em>你可以在这里查阅服务器端和客户端的代码<a class="ae kc" href="https://github.com/wbhoomika/Chat_Room-using-Python" rel="noopener ugc nofollow" target="_blank">和详细注释。</a></p><p id="38b9" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated"><strong class="ih hj">如果你有任何想法、评论、问题或者你只是想了解我的最新内容，请随时与我联系</strong><a class="ae kc" href="https://www.linkedin.com/in/bhoomikawavhal/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="hi">Linkedin</em></strong></a><strong class="ih hj"><em class="hi">或</em></strong><a class="ae kc" href="https://github.com/wbhoomika" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="hi">Github</em></strong></a><strong class="ih hj"><em class="hi">。</em> </strong></p></blockquote></div></div>    
</body>
</html>