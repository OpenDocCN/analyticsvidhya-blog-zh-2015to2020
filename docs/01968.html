<html>
<head>
<title>Advanced Golang Tutorials: gRPC Bi-Directional Streaming without Protobuf</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Golang教程:不带Protobuf的gRPC双向流</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/advanced-golang-tutorials-grpc-bi-directional-streaming-without-protobuf-f13ab43de205?source=collection_archive---------11-----------------------#2019-11-24">https://medium.com/analytics-vidhya/advanced-golang-tutorials-grpc-bi-directional-streaming-without-protobuf-f13ab43de205?source=collection_archive---------11-----------------------#2019-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7b79696ec0477cd2c91575f3d48e558a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOvc8I_1CAEIiv9aFrnaUg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">不带Protobuf的gRPC双向流</figcaption></figure><p id="ee4d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我将给出一个最近很流行的话题的高级例子:<strong class="iw hj"> gRPC。</strong> <br/> <br/> gRPC是一个现代的开源高性能RPC框架，可以在任何环境下运行。它可以通过对负载平衡、跟踪、运行状况检查和身份验证的可插拔支持，高效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。<a class="ae js" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> grpc.io </a> <br/> <br/> gRPC也很棒，因为它是用不同编程语言编写的微服务之间的通信协议。关于gRPC还有很多要说的，但是我不打算深入它的细节，因为我假设你已经熟悉它了。如果你不熟悉，<a class="ae js" rel="noopener" href="/pantomath/how-we-use-grpc-to-build-a-client-server-system-in-go-dd20045fa1c2">这里有一篇很棒的文章</a>详细讲解。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="e4d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我开始研究gRPC时，我很快意识到它实际上带有一个内置的序列化和反序列化机制，称为Protobuf(协议缓冲区)。协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——想想XML，但是更小、更快、更简单。一旦定义了数据的结构化方式，就可以使用专门生成的源代码，使用各种语言轻松地将结构化数据写入各种数据流或从中读取。但是，如果您没有定义的消息类型，您会觉得需要禁用Protobuf序列化和反序列化。让我们看看如何在围棋中做到这一点:</p><p id="d9ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的<strong class="iw hj"> <em class="ka"> main.proto </em> </strong>描述了使用双向流<em class="ka">远程过程调用</em>通信并携带原始<strong class="iw hj">字节</strong>作为消息类型的服务<strong class="iw hj"> Main </strong>。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="572d" class="kk kl hi kg b fi km kn l ko kp">syntax = “proto3”;</span><span id="7fdf" class="kk kl hi kg b fi kq kn l ko kp">package rpc;</span><span id="68c7" class="kk kl hi kg b fi kq kn l ko kp">service Main {<br/> rpc RPC (stream Payload) returns (stream Payload) {}<br/>}</span><span id="5560" class="kk kl hi kg b fi kq kn l ko kp">message Payload {<br/> bytes Data = 1;<br/>}</span></pre><p id="da25" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建原型文件后，我们需要使用该文件为服务器和客户机生成源代码:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="308b" class="kk kl hi kg b fi km kn l ko kp"> protoc -I main/ main.proto — go_out=plugins=grpc:main</span></pre><p id="737b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此命令将生成将在您的项目中使用的必要源代码。下一步是创建一个<em class="ka">有效负载</em>结构，它将在服务器-客户端对之间传送消息。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ef51" class="kk kl hi kg b fi km kn l ko kp">package rpc</span><span id="fded" class="kk kl hi kg b fi kq kn l ko kp">// Payload defines the service message format.<br/>type Payload struct {<br/> data []byte<br/>}</span><span id="e951" class="kk kl hi kg b fi kq kn l ko kp">// NewPayload creates and returns a new payload with the given byte slice.<br/>func NewPayload(d []byte) *Payload {<br/> p := new(Payload)<br/> if d != nil {<br/> p.Set(d)<br/> }<br/> return p<br/>}</span><span id="d1d5" class="kk kl hi kg b fi kq kn l ko kp">// Set sets the payload<br/>func (p *Payload) Set(d []byte) {<br/> p.data = d<br/>}</span><span id="6e3e" class="kk kl hi kg b fi kq kn l ko kp">// Get returns the payload<br/>func (p *Payload) Get() []byte {<br/> return p.data<br/>}</span></pre><p id="a194" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们已经到了需要向gRPC库添加自定义编解码器的地步，这样它就不会试图对我们通过网络发送的字节进行序列化和反序列化。这背后的主要原因是为了使通信更快，因为我们不知道gRPC服务器和客户端之间的流的大小。</p><p id="7d35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://www.codemio.com/2019/08/advanced-golang-tutorials-grpc-bidi-streaming-custom-codec.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> <em class="ka">阅读更多</em> </strong> </a></p></div></div>    
</body>
</html>