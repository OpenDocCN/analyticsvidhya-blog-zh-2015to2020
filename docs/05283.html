<html>
<head>
<title>Easy API building for Data Scientists with R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用R为数据科学家构建简单的API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/easy-api-building-for-data-scientists-with-r-673b381c4ae1?source=collection_archive---------7-----------------------#2020-04-16">https://medium.com/analytics-vidhya/easy-api-building-for-data-scientists-with-r-673b381c4ae1?source=collection_archive---------7-----------------------#2020-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="89ba" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何用Docker和R Plumber构建一个健壮的REST API。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3995741d908a12b35eb43d27e99e55de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyPYVz8iWMoMRsb2in2Qiw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Google Big Query上的公共实时数据集的模式，我们将为其构建一个API</figcaption></figure><p id="e991" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj">这篇文章还发表在https://www.r-bloggers.com/</em><a class="ae kk" href="https://www.r-bloggers.com/" rel="noopener ugc nofollow" target="_blank"><em class="kj"/></a><em class="kj">上。</em></p><p id="cfb3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj">这是用R和Docker构建和部署一个健壮的API的系列文章的第三部分，这个API允许您从Google Big Query中提取实时数据。第一部分，参见</em> <a class="ae kk" rel="noopener" href="/analytics-vidhya/google-big-query-with-r-875facef7844"> <em class="kj">使用R </em> </a> <em class="kj">的Google大查询，第二部分，参见</em> <a class="ae kk" rel="noopener" href="/analytics-vidhya/live-data-extraction-with-cron-and-r-f29324bf153e"> <em class="kj">使用Cron和R </em> </a> <em class="kj">的实时数据提取。关于Docker的简短介绍，请参阅关于构建和部署仪表板的文章系列的第二部分，</em> <a class="ae kk" rel="noopener" href="/analytics-vidhya/deploying-a-shiny-flexdashboard-with-docker-cca338a10d12"> <em class="kj">使用Docker </em> </a> <em class="kj">部署闪亮的Flexdashboard。</em></p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="e987" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi ks translated">pi是一种独立于编程语言跨设备访问数据的便捷方式。RE<strong class="jp hj">RE</strong>presentational<strong class="jp hj">S</strong>state<strong class="jp hj">T</strong>传输API是最常见的Web API类型。REST是一种软件架构范例，它定义了一组统一的无状态操作。统一的操作使得定义接口变得简单，无状态性使得接口可靠、快速且易于修改和扩展。常用的交换协议是HTT协议，其操作GET、HEAD、POST、PUT、PATCH、DELETE、CONNECT、OPTIONS和TRACE发送到一个IP地址或其关联的URL。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="cb40" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将使用<a class="ae kk" href="https://www.rplumber.io/" rel="noopener ugc nofollow" target="_blank"> Plumber包</a>在R中构建一个REST API，以便轻松访问来自<a class="ae kk" href="https://openaq.org/#/?_k=h8s64f" rel="noopener ugc nofollow" target="_blank"> openAQ </a>的公共大查询实时空气质量数据集的数据。我们能够通过Cron 在Docker容器中通过<a class="ae kk" rel="noopener" href="/analytics-vidhya/live-data-extraction-with-cron-and-r-f29324bf153e">计划的数据提取来保存空气质量的永久记录，因为当添加新数据时，数据集的旧条目会被忽略。R Plumber API将在其自己的Docker容器中运行，该容器将与数据提取Docker容器一起在容器网络中运行。这种架构有几个优点:</a></p><ul class=""><li id="796f" class="lb lc hi jp b jq jr jt ju jw ld ka le ke lf ki lg lh li lj bi translated">将整个服务移植到其他机器或云服务</li><li id="cfab" class="lb lc hi jp b jq lk jt ll jw lm ka ln ke lo ki lg lh li lj bi translated">明确定义的依赖关系避免了功能的破坏</li><li id="7843" class="lb lc hi jp b jq lk jt ll jw lm ka ln ke lo ki lg lh li lj bi translated">提取和预聚合数据实现了快速的API响应时间，而不需要数据库查询</li><li id="5c48" class="lb lc hi jp b jq lk jt ll jw lm ka ln ke lo ki lg lh li lj bi translated">增强的数据安全性，因为API操作和数据库访问在不同的容器中</li><li id="ef2b" class="lb lc hi jp b jq lk jt ll jw lm ka ln ke lo ki lg lh li lj bi translated">模块化使得服务的调试和附加部分的集成更加容易</li></ul></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="31d9" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jw ma mb mc ka md me mf ke mg mh mi mj bi translated">r水管工脚本</h2><p id="1a22" class="pw-post-body-paragraph jn jo hi jp b jq mk ij js jt ml im jv jw mm jy jz ka mn kc kd ke mo kg kh ki hb bi translated">Plumber允许您用定义端点和各种输入参数的注释来修饰R代码。然后，您可以在定义的IP地址公开修饰的R代码。从CRAN或GitHub安装Plumber，并打开一个新的Plumber脚本来查看一些示例。如果你有RStudio，你可以点击“Run API”按钮，用Swagger在本地测试你的端点。默认情况下，plumber输出作为JSON发送，但是您可以使用其他序列化程序或创建新的序列化程序来指示Plumber以不同的格式呈现输出。更多信息，参见<a class="ae kk" href="https://www.rplumber.io/docs/quickstart.html#customizing-the-output" rel="noopener ugc nofollow" target="_blank">管道工文档</a>。</p><p id="ee10" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面的脚本指示plumber公开各种R函数，从提取的空气质量数据中获取数据，这些数据保存在两个Docker容器的共享卷中，名为<code class="du mp mq mr ms b">/shared-data/airquality-india.RDS</code>。端点<code class="du mp mq mr ms b">/plot</code>处的最后一个函数将会按照序列化器<code class="du mp mq mr ms b">#* @png</code>的指定以PNG格式调用时得到一个测试直方图。注意，代替<code class="du mp mq mr ms b">elseif</code>语句，您可以参数化函数以获得更简洁的代码。你可以在这里克隆整个项目GitHub repo <a class="ae kk" href="https://github.com/timosch29/Dockerized-Plumber-API" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="8b99" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jw ma mb mc ka md me mf ke mg mh mi mj bi translated">API的docker文件</h2><p id="10a7" class="pw-post-body-paragraph jn jo hi jp b jq mk ij js jt ml im jv jw mm jy jz ka mn kc kd ke mo kg kh ki hb bi translated">我们将在Docker文件中创建一个包含<a class="ae kk" href="https://docs.docker.com/registry/recipes/" rel="noopener ugc nofollow" target="_blank">食谱的Docker图像，将图像层层叠加。我们将使用来自</a><a class="ae kk" href="https://hub.docker.com/r/rocker/tidyverse/dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>的摇杆/tidyverse图像作为基础图像。这假设了Docker的基本知识，如果没有看到<a class="ae kk" rel="noopener" href="/analytics-vidhya/deploying-a-shiny-flexdashboard-with-docker-cca338a10d12"> <em class="kj">用Docker </em> </a> <em class="kj">部署闪亮的Flexdashboard。</em>最终的commad层<code class="du mp mq mr ms b">CMD ["R", "-e", "pr &lt;- plumber::plumb('/src/API.R'); pr$run(host='0.0.0.0', port=3838)"]</code>将在本地主机(容器)上公开我们脚本中的函数，作为我们通过层<code class="du mp mq mr ms b">EXPOSE 3838</code>公开的容器端口3838上的端点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="ca02" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在Dockerfile运行<code class="du mp mq mr ms b">docker build -t openaq_api .</code>的目录中，这将从Dockerfile构建图像，并将其标记为<em class="kj"> openaq_api </em>。要测试docker化的API，请通过此命令运行docker容器，将主机端口3838绑定到API运行的暴露容器端口。</p><pre class="iy iz ja jb fd mv ms mw mx aw my bi"><span id="ec5b" class="lp lq hi ms b fi mz na l nb nc">$ docker run -d \<br/>  -p 3838:3838 \<br/>  --restart=always \<br/>  --name <!-- -->openaq_api<!-- -->_container \<br/>  --rm \<br/>   <!-- -->openaq_api</span></pre><p id="77ef" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后检查测试直方图是否通过控制台中的curl或通过带有R:</p><pre class="iy iz ja jb fd mv ms mw mx aw my bi"><span id="d076" class="lp lq hi ms b fi mz na l nb nc">require("httr")</span><span id="47d8" class="lp lq hi ms b fi nd na l nb nc"># send API HTTP operation<br/>api_output &lt;- GET("http://0.0.0.0:3838/plot", verbose(),</span><span id="76eb" class="lp lq hi ms b fi nd na l nb nc">   # param list not needed here as /plot endpoint has none<br/>   #query = list(param1 =, param2=,...)<br/>   )</span><span id="7a7a" class="lp lq hi ms b fi nd na l nb nc"># show body of output                                                                                                 <br/>content(api_output)</span></pre><p id="c4a3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这将向您显示一个PNG格式的测试直方图。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="12cb" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jw ma mb mc ka md me mf ke mg mh mi mj bi translated"><strong class="ak">创建多容器服务</strong></h2><p id="6741" class="pw-post-body-paragraph jn jo hi jp b jq mk ij js jt ml im jv jw mm jy jz ka mn kc kd ke mo kg kh ki hb bi translated">我们定义了一个由API容器和数据提取容器组成的服务，通过docker-compose在它们之间共享一个卷。<a class="ae kk" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker-compose </a>是一个可以附加安装到Docker引擎上的工具，它使得通过YAML文件中的定义以编程方式设置多容器服务变得容易。我们通过参数<code class="du mp mq mr ms b">volumes:</code>定义了共享卷，并通过参数<code class="du mp mq mr ms b">networks:</code>定义了一个共享网络，使容器能够监听彼此的端口(这在这个服务中不是必需的，只是为了完整性而显示)。容器是通过参数<code class="du mp mq mr ms b">services:</code>定义的，这里的<code class="du mp mq mr ms b">build:</code>参数指定容器镜像是从<code class="du mp mq mr ms b">context:</code>中的docker文件重建的。共享卷被挂载到<code class="du mp mq mr ms b">volumes:</code>中容器内的一个目录中。API容器的公开端口3838通过<code class="du mp mq mr ms b">ports:</code>绑定到主机的端口3838。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="35cf" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你克隆了<a class="ae kk" href="https://github.com/timosch29/Dockerized-Plumber-API" rel="noopener ugc nofollow" target="_blank">项目GitHub repo </a>，你可以看到顶层目录中带有docker-compose.yml文件的文件结构。在顶层目录中，使用命令构建并启动容器</p><pre class="iy iz ja jb fd mv ms mw mx aw my bi"><span id="e84a" class="lp lq hi ms b fi mz na l nb nc">$ docker-compose up</span></pre><p id="13ca" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要在分离模式下运行，添加<code class="du mp mq mr ms b">-d</code>。要强制重建现有容器和/或强制重建映像，请添加<code class="du mp mq mr ms b">--force-recreate --build </code>。要停止YAML文件中指定的所有已启动的网络和容器，只需运行<code class="du mp mq mr ms b">docker-compose down</code>。</p><p id="2f22" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">提取过程现在应该启动并运行了，如docker日志中所示，因为我们跟踪了预定cron作业的日志。当第一次提取运行完成时，您可以使用Plumber API接收R:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/48da5e6891adc2158e864d980387a805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLJP0FaytdplQ5V5OD0ORw.png"/></div></div></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h2 id="c16b" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jw ma mb mc ka md me mf ke mg mh mi mj bi translated">何去何从:结束语和补充说明</h2><p id="b950" class="pw-post-body-paragraph jn jo hi jp b jq mk ij js jt ml im jv jw mm jy jz ka mn kc kd ke mo kg kh ki hb bi translated">就这样，我们构建了一个健壮的服务来从Google Big Query中提取数据，并在这三篇文章系列中使用Docker和R通过REST API轻松访问数据。</p><p id="b879" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最初，我在API容器的docker-compose.yml中安装了主机docker守护进程的docker UNIX套接字作为卷<code class="du mp mq mr ms b">-/var/run/docker.sock:/var/run/docker.sock</code>,以便能够通过API调用从主机获取docker日志。然而，我删除了这一部分，因为这种做法是一个巨大的安全问题，特别是如果容器用于生产。详见<a class="ae kk" href="https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/" rel="noopener ugc nofollow" target="_blank">https://raesene . github . io/blog/2016/03/06/The-Dangers-Of-docker . sock/</a>。</p><p id="4d53" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从现在开始，你可以将这种多容器服务部署到生产中，例如部署到云服务，如<a class="ae kk" href="https://www.ybrikman.com/writing/2015/11/11/running-docker-aws-ground-up/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae kk" href="https://blog.machinebox.io/deploy-docker-containers-in-google-cloud-platform-4b921c77476b" rel="noopener ugc nofollow" target="_blank">谷歌云</a>和<a class="ae kk" href="https://blog.machinebox.io/deploy-machine-box-in-digital-ocean-385265fbeafd" rel="noopener ugc nofollow" target="_blank">数字海洋</a>。部署像<a class="ae kk" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>或<a class="ae kk" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器编排工具来管理您的Docker容器及其共享资源是非常有用的。</p><p id="092c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在生产环境中，您可能希望使用反向代理服务器，如<a class="ae kk" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>将API请求重定向到一个URL，进一步指向API Docker容器的公开端口，并通过HTTPS对其进行加密。此外，您可能想用R包<a class="ae kk" href="https://testthat.r-lib.org/" rel="noopener ugc nofollow" target="_blank">test</a>为您的API 编写单元测试，并在许多请求下用R包<a class="ae kk" href="https://github.com/tmobile/loadtest" rel="noopener ugc nofollow" target="_blank"> loadtest </a>对您的API进行负载测试。</p><p id="c5a8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">管道工按顺序处理API请求。如果您遇到很多API调用，一个选择是部署几个API容器，并通过Nginx对传入的流量进行负载平衡。如果您想要运行四个API容器，请运行docker-compose up with scale参数:</p><pre class="iy iz ja jb fd mv ms mw mx aw my bi"><span id="aa4a" class="lp lq hi ms b fi mz na l nb nc">$ docker-compose up --scale REST-API=4</span></pre><p id="4898" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">另一个选择是不要用水管工构建你的API，而是用R包<a class="ae kk" href="https://restrserve.org/" rel="noopener ugc nofollow" target="_blank">rest serve</a>。它并行处理请求，如果您需要行业级API，它可能是总体上更好的解决方案，但是定义端点更复杂。关于加速API的其他技巧，请参见<a class="ae kk" rel="noopener" href="/@JB_Pleynet/how-to-do-an-efficient-r-api-81e168562731">https://medium . com/@ JB _ pley net/how-to-do-an-efficient-r-API-81e 168562731</a>。</p></div></div>    
</body>
</html>