<html>
<head>
<title>Practical Approach to KMeans Clustering — Python and Why Scaling is Important!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KMeans集群的实用方法——Python和为什么伸缩很重要！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/practical-approach-to-kmeans-clustering-python-and-why-scaling-is-important-44ac0b0fea47?source=collection_archive---------2-----------------------#2019-11-08">https://medium.com/analytics-vidhya/practical-approach-to-kmeans-clustering-python-and-why-scaling-is-important-44ac0b0fea47?source=collection_archive---------2-----------------------#2019-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="a721" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">学习K意味着聚类，现在你想在现实生活中应用？<br/>应用了聚类算法但对结果不满意？<br/>从您见过的最简单的数据集开始，了解扩展如何影响聚类，以及数据的微小变化如何导致完全不同的聚类！</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/eb64af60f7d564369d421c0eb75fbff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9--oVofFpUG8IFKjNLzGmQ.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片来自<a class="ae jx" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1509707" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jx" href="https://pixabay.com/users/arielrobin-2483349/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1509707" rel="noopener ugc nofollow" target="_blank"> arielrobin </a></figcaption></figure><h1 id="e7e2" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">先决条件</h1><ol class=""><li id="178a" class="kw kx hi il b im ky iq kz la lb lc ld le lf jg lg lh li lj bi translated"><em class="ik">你应该知道什么是聚类。</em></li><li id="87f9" class="kw kx hi il b im lk iq ll la lm lc ln le lo jg lg lh li lj bi translated"><em class="ik">你应该知道KMeans算法。</em></li><li id="5967" class="kw kx hi il b im lk iq ll la lm lc ln le lo jg lg lh li lj bi translated"><em class="ik">Python基础知识</em></li></ol><h1 id="7152" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">让我们开始编码吧</h1><h2 id="5724" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">步骤1:导入所需的库</h2><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="888f" class="lp jz hi me b fi mi mj l mk ml">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><h2 id="e55a" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">步骤2:读取数据集</h2><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="6072" class="lp jz hi me b fi mi mj l mk ml">movies = pd.read_csv('movies.csv')</span></pre><h2 id="95cd" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">步骤3:理解数据集</h2><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="6c8f" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj"># View the first five rows of the dataset</strong><br/>movies.head()</span><span id="9792" class="lp jz hi me b fi mm mj l mk ml"><strong class="me hj"># If you want to view first n rows of the dataset:</strong><br/># movies.head(n=number)</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mn"><img src="../Images/39441a77e53daf6d634fbbb23a20a9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*mBBEmkPv5ttfzdjXXQO2oA.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">数据集的前五行</figcaption></figure><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="21bf" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#View summary of the data</strong><br/>movies.info()</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mo"><img src="../Images/2db8a2c8c8003e81dc265dbcdf102016.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*IVEv-aiLqIWtIz76oyD0aQ.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">电影信息</figcaption></figure><p id="40d3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们看到总共有10行和6个特征(列)。<br/>其中两个特征为<em class="ik">整数类型</em>，四个特征为<em class="ik">对象类型</em>。<br/>我们可以看到，它显示了10个非空，这意味着总共有10个非空条目，总共有10行，这意味着数据中没有空值。</p><p id="31e3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们可以删除“Id”功能，因为它不会为我们提供任何相关信息。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="09e7" class="lp jz hi me b fi mi mj l mk ml">del movies['Id']</span></pre><p id="8245" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">让我们查看完整的数据，因为只有10行。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="1fbf" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#View the complete data</strong><br/>display(movies)</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mp"><img src="../Images/0a034957f3713a71f50ac19a317f1e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*VB1rX2aDuSMPfneBPFGUtw.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">完整的电影数据</figcaption></figure><p id="00a3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">这是一个小数据集，我们看到，有许多电影都是由相同的演员或导演出演的，但我们可以使用<em class="ik"> groupby </em>来了解更多的数据。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="ebaa" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Grouping the movies by actors and displaying them</strong><br/>actors = movies.groupby('Actor')<br/>for actor,rows in actors:<br/>    display(actor,rows)</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mq"><img src="../Images/6452589831a490556c48afae6bcfffd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*i4g9jwFH-AHYbK2O8Ng-fw.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">按结果的演员分组</figcaption></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mr"><img src="../Images/7b592ac51b852b753570c98ed455e698.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*DHl6lOle2-LV5U4WVUkZXg.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">按结果的演员分组</figcaption></figure><p id="9e48" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们看到总共有四位演员:克里斯蒂安·贝尔、休·杰克曼、乔阿金·菲尼克斯和汤姆·克鲁斯。克里斯蒂安·贝尔在数据集中拥有最高数量的电影，即5部，乔阿金·菲尼克斯和汤姆·克鲁斯各有两部电影，休·杰克曼只有一部电影。</p><p id="93b0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">现在让我们按导演分组</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="b2f2" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Grouping the movies by directors and displaying them<br/></strong>directors = movies.groupby('Director')<br/>for director,rows in directors:<br/>    display(director,rows)</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ms"><img src="../Images/e9ad532c1e52a9469edceabca6dc27bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*F5g85mBp9Qq5ZG-50pg-xw.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">按结果划分的控制器组</figcaption></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mt"><img src="../Images/ccde224f5db158317dfca30e83d32497.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*Q51JX-_0EQ2mrQHjCgKvgw.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">按结果划分的控制器组</figcaption></figure><p id="3016" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">共有六位导演，克里斯托弗·诺兰和大卫·罗素只和克里斯蒂安·贝尔合作过，而詹姆斯·曼高德只和休·杰克曼和汤姆·克鲁斯合作过。</p><p id="f7dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">现在让我们按流派分组</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="b79f" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Grouping the movies by genre and displaying them</strong><br/>genres = movies.groupby('Genre')<br/>for genre,rows in genres:<br/>    display(genre,rows)</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mu"><img src="../Images/0f31bd2bb446fa9d6e00601fc518abf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*wI02tmQNSKG39xyaKhm5Cw.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">流派分组依据结果</figcaption></figure><p id="2ead" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">有3种独特的类型。只有汤姆·克鲁斯演过动作片，克里斯蒂安·贝尔和乔阿金·菲尼克斯演过漫画和剧情片。</p><h2 id="3e53" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">步骤4:预处理</h2><p id="f65c" class="pw-post-body-paragraph ii ij hi il b im ky io ip iq kz is it la mv iw ix lc mw ja jb le mx je jf jg hb bi translated">在建模之前，我们必须将数据转换为数字格式，因为KMeans不能处理分类变量。<br/>因此我们必须为演员、导演和流派创造虚拟变量。<br/>我们没有为电影名称创建虚拟变量，因为它也是一个标识符，在聚类中没有用，因此我们也删除了它。</p><blockquote class="if ig ih"><p id="c230" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">注意:建议制作原始数据集的副本，并对副本而不是原始数据集进行修改。</p></blockquote><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="bc04" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Creating dummy variables<br/></strong>actor_dummy = pd.get_dummies(movies['Actor'])<br/>director_dummy = pd.get_dummies(movies['Director'])<br/>genre_dummy = pd.get_dummies(movies['Genre'])</span><span id="824a" class="lp jz hi me b fi mm mj l mk ml"><strong class="me hj">#Concatenating the dummy variables to the original dataset</strong> movie_dummy_set=pd.concat([movies,actor_dummy,<br/>director_dummy,genre_dummy],axis=1)</span><span id="c853" class="lp jz hi me b fi mm mj l mk ml"><strong class="me hj">#Deleting categorical variable from the dummy set</strong><br/>del movie_dummy_set['MovName']<br/>del movie_dummy_set['Actor']<br/>del movie_dummy_set['Director']<br/>del movie_dummy_set['Genre'].</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es my"><img src="../Images/0ac1bbfdb9886d0adf347e131bbc5363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDz5TchqurtIjUjCSh8Q-Q.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">预处理后的数据</figcaption></figure><h2 id="473a" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">第五步:建模</h2><p id="c1a9" class="pw-post-body-paragraph ii ij hi il b im ky io ip iq kz is it la mv iw ix lc mw ja jb le mx je jf jg hb bi translated">让我们从导入建模所需的库开始</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="4ad0" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Importing KMeans<br/></strong>from sklearn.cluster import KMeans</span></pre><p id="3eba" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">让k等于2，即我们想要两个数据集群。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="9066" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Modeling<br/></strong>kmeans = KMeans(2)<br/>kfit = kmeans.fit(movie_dummy_set)<br/>identified_clusters = kfit.predict(movie_dummy_set)</span></pre><p id="1c36" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们已经将识别出的聚类存储在一个新的变量中，并将它添加到原始数据集中。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="0bd3" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Appending the identified clusters to the original data<br/></strong>clustered_data = movies.copy()<br/>clustered_data['Cluster'] = identified_clusters</span><span id="c248" class="lp jz hi me b fi mm mj l mk ml"><strong class="me hj">#Viewing the data with clusters<br/></strong>display(clustered_data.sort_values(by='Cluster'))</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mz"><img src="../Images/e06ab8f83318a5927c27eff6176df943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*xPsO1A4zVt1kwykbAhwt6A.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">具有两个分类的数据</figcaption></figure><blockquote class="if ig ih"><p id="7039" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在继续之前，分析该表并尝试找出聚类是基于哪个(些)特征发生的。</p></blockquote><p id="1b2b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">如果你想通了，太好了！，让我们继续绘制集群</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="4668" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Plotting the graph</strong><br/>plt.xlabel('Year')<br/>plt.ylabel('Cluster')<br/>plt.scatter(clustered_data['Year'],clustered_data['Cluster'],c=clustered_data['Cluster'])</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es na"><img src="../Images/1d42f49c24ce74b6d2cb02d22caeeb56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*a6K8lmJ33BZo2CN7-Qlf4g.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">年份与聚类图</figcaption></figure><p id="f7f9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们看到聚类是基于年份的。聚类0包含2012年之前发行的电影，聚类1包含2012年之后发行的电影。</p><blockquote class="if ig ih"><p id="b006" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">但为什么它是基于年份，而不是其他特征演员，导演和流派。我们忘了什么吗？我想是的，我们忘了缩放数据。</p></blockquote><p id="7302" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">请记住，所有的数据都是数值型的，并且年份中的数据在数量级上非常大。它在2000s的范围内，而其他特征中的数据是0或1，因为它们是虚拟的。</p><p id="403e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">这可能是聚类基于年份的原因，因为年份中的值要大得多，从而使其值最大化。</p><p id="1a38" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">让我们缩放数据，然后应用KMeans。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="e91d" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Importing the library</strong><br/>from sklearn import preprocessing</span><span id="7feb" class="lp jz hi me b fi mm mj l mk ml"><strong class="me hj">#Passing the values of the dataset to Min-Max-Scaler</strong><br/>movies_values = movie_dummy_set.values<br/>min_max_scaler = preprocessing.MinMaxScaler()<br/>x_scaled = min_max_scaler.fit_transform(movies_values)<br/>movies_scaled = pd.DataFrame(x_scaled,<br/>columns=movie_dummy_set.columns)</span></pre><p id="80d6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们对数据进行了缩放，并存储在“movies_scaled”变量中。让我们应用k = 2的KMeans，看看我们得到的结果是不同的还是相同的。</p><pre class="ji jj jk jl fd md me mf mg aw mh bi"><span id="6aa2" class="lp jz hi me b fi mi mj l mk ml"><strong class="me hj">#Modeling</strong><br/>kmeans = KMeans(2)<br/>kfit = kmeans.fit(movies_scaled)<br/>identified_clusters_scaled = kfit.predict(movies_scaled)</span><span id="f80e" class="lp jz hi me b fi mm mj l mk ml"><strong class="me hj">#Appending the identified clusters to the dataframe</strong><br/>clustered_data_scaled = movies.copy()<br/>clustered_data_scaled['Cluster'] = identified_clusters_scaled<br/>display(clustered_data_scaled.sort_values(by='Cluster'))</span></pre><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es nb"><img src="../Images/2e75f7c531ed7f1e296707cb81a07cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*Qiaiyp30ijBBHcMIOG1w4A.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">缩放后具有两个聚类的数据</figcaption></figure><p id="95ac" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">结果令人惊讶不是吗！现在，聚类是基于演员的，聚类0包含克里斯蒂安·贝尔主演的电影，而聚类1包含所有其他电影。</p><p id="9973" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated"><strong class="il hj">让我们看看当聚类数为3时会发生什么，即k =3。</strong></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es nc"><img src="../Images/d32882e67ab94b37a1a5d130d7a65581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*9hJyVqHj13qSJnw_paKTuA.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">具有三个聚类的数据</figcaption></figure><p id="3898" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">同样，聚类是基于演员的，聚类0包含汤姆克鲁斯主演的电影，聚类1包含克里斯蒂安·贝尔主演的电影，聚类2包含其他电影。</p><p id="82bb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated"><strong class="il hj">让我们看看当聚类数为4时会发生什么，即k =4。</strong></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mz"><img src="../Images/37fad6cb4314437a2cf828ffe56c8ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*U0Dlhsy-56gGbLi_coQX7A.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">具有四个簇的数据</figcaption></figure><p id="86e0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">这些分类现在基于两个特征，演员和导演。<br/>群集0包含汤姆·克鲁斯主演的电影。集群1包含由大卫·罗素执导的克里斯蒂安·贝尔主演的电影。聚类3包含乔阿金·菲尼克斯和休·杰克曼主演的电影，聚类4还包含克里斯蒂安·贝尔主演的但由克里斯托弗·诺兰导演的电影。</p><h2 id="f0d0" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">第六步:结论</h2><p id="ee3a" class="pw-post-body-paragraph ii ij hi il b im ky io ip iq kz is it la mv iw ix lc mw ja jb le mx je jf jg hb bi translated">我们看到了扩展如何影响集群。在缩放之前，两个分类是基于年份的，但是在缩放之后，分类是基于行动者的。<br/>我们还看到了改变聚类数如何改变数据分组，这完全取决于数据科学家决定聚类数。</p><blockquote class="if ig ih"><p id="1d74" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">Y <!-- -->你可能有几个问题，比如什么是正确的集群数量，或者如何决定“k”值。确定“k”值的方法之一是<strong class="il hj">弯头法</strong>。</p><p id="bb18" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">你可能会有另一个问题，为什么大多数时候聚类是基于演员特征，而不是类型。数据集中有3种类型，所以当k为3时，基于类型而不是演员进行聚类更有意义。答案是，这也取决于数据。</p></blockquote><blockquote class="nd"><p id="7bc4" class="ne nf hi bd ng nh ni nj nk nl nm jg dx translated">让我们看一个例子，看看聚类是如何依赖于数据的。</p></blockquote><p id="58a7" class="pw-post-body-paragraph ii ij hi il b im nn io ip iq no is it la np iw ix lc nq ja jb le nr je jf jg hb bi translated"><strong class="il hj">我只在数据集中做了一个改动，我把《蝙蝠侠诞生》的年份从2005年改成了2014年(是的，这是错的，但结果令人惊讶！)</strong></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ns"><img src="../Images/0f66b288044712a1cd92a41fe8edb194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*XoqBnEa0rY88mFfNTN3X1g.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">2014年《蝙蝠侠诞生》上映时</figcaption></figure><p id="d667" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">我们看到现在聚类是基于流派的！，仅仅更改数据集中的单个值就会导致分类发生重大变化。</p><p id="7370" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">想象一个现实生活中的数据集，它有大量的行和列以及大量缺失值。缺失值可以用各种技术来填充。<br/>不同的技术会导致不同的集群！</p><p id="db6c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it la iv iw ix lc iz ja jb le jd je jf jg hb bi translated">尝试不同数量的集群和不同的算法，看看它如何改变集群的形成方式。</p><blockquote class="if ig ih"><p id="531a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">资源库链接</strong>:<a class="ae jx" href="https://github.com/njain9104/Movies-Clustering" rel="noopener ugc nofollow" target="_blank">https://github.com/njain9104/Movies-Clustering</a></p></blockquote><h2 id="efb7" class="lp jz hi bd ka lq lr ls ke lt lu lv ki la lw lx km lc ly lz kq le ma mb ku mc bi translated">最后一步:结束</h2></div></div>    
</body>
</html>