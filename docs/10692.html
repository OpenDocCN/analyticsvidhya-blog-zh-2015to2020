<html>
<head>
<title>Let’s Talk about SQL — Part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈SQL —第6部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/lets-talk-about-sql-part-6-12228b1d2ca0?source=collection_archive---------9-----------------------#2020-10-30">https://medium.com/analytics-vidhya/lets-talk-about-sql-part-6-12228b1d2ca0?source=collection_archive---------9-----------------------#2020-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="708f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">窗口功能好玩！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6b8b5c604470e1f68c5c70bc9b7829f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMhTI9vl43WQJWuNOlhPug.png"/></div></div></figure><p id="4ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是SQL系列文章的第六篇。</p><p id="7169" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我关于SQL的第五篇文章更多的是关于连接和查询结构。你可以在这里阅读<a class="ae jp" rel="noopener" href="/analytics-vidhya/lets-talk-about-sql-part-5-afd04a49adbf"/>。</p><p id="bc25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">概括地说，在上一篇文章中，我们讨论了内连接和左连接以及如何构建查询。我们还使用连接代替子查询重写了第4部分中的查询。</p><p id="845c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用SQL编写:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8d3b" class="jv jw hi jr b fi jx jy l jz ka">SELECT c.state, c.county, c.cases, c.deaths, <br/>       c.cases/c.deaths as ‘case/death ratio’, m.ALWAYS<br/>FROM counties as c<br/>JOIN mask_use as m on c.fips = m.countyfp<br/>JOIN election as e on c.fips = e.fips<br/>ORDER BY e.clf_unemploy_pct DESC<br/>LIMIT 25</span></pre><p id="054e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将讨论窗口函数，并使用它们来计算跨行而不是列的值。听起来很有趣，对吧？</p><p id="7b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用来自纽约时报和麻省理工学院的相同数据，我们已经在整个系列中使用。</p><p id="ccdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，到底什么是窗口函数呢？基本上，窗口函数允许您跨行而不是列执行计算。</p><p id="9f73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">窗口函数—</strong><strong class="ih hj"/>函数，对一组行进行操作，返回该行的单个值。<em class="kb">窗口</em>指的是函数将要操作的一组行。</p><p id="2938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，给定我们的counties表，我们希望看到每个县每天的新病例数。让我们快速看一下我们的表，看看我们有什么。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="c7e8" class="jv jw hi jr b fi jx jy l jz ka">SELECT *<br/>FROM counties<br/>WHERE date = ‘2020–09–07’</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kc"><img src="../Images/15cb38cdd929e637e8c3c94404920f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*J7Roh3rKH_EeYXrHiwG_Mw.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">我们的县表示例</figcaption></figure><p id="3ce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，似乎我们已经在表中有了这些信息，但是当我们查阅数据字典时，我们发现每天报告的病例和死亡是累积的。为了找到每日新增病例和死亡人数，我们需要做一些数学计算。为了便于说明，我们只看一个县——伊利诺伊州库克县。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kc"><img src="../Images/4acd957d57e796b16934ec0790bfd646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*JPQ6X8rfp68aMClAM9FNgw.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">伊利诺伊州库克县的部分县表数据</figcaption></figure><p id="e791" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了得到9月10日的新病例数，我们需要从9月10日的总数(132，966)中减去9月9日的总数(132，401)。9月10日，伊利诺伊州库克县新增病例565例。因此，我们的窗口函数需要告诉SQL创建一个新列(我们称之为“new_cases”)，从当天的总数中减去前一天的总数。换句话说，从当前行中减去上一行。我们该怎么写？</p><p id="b886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用滞后！</p><p id="a418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> LAG — </strong> LAG是一个窗口函数，它提供与当前行有指定偏移量的行。</p><p id="8718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这听起来比实际情况复杂得多，所以让我们把它写出来。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="199c" class="jv jw hi jr b fi jx jy l jz ka">SELECT date, state, county, cases,<br/>       cases - LAG (cases,1) OVER (ORDER BY date) as ‘new_cases'<br/>FROM counties<br/>WHERE state = ‘Illinois’ <br/>      AND county = ‘Cook’ <br/>      AND date &gt;= ‘2020-09-01’<br/>ORDER BY date</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/9ca78d1d2447fed854165383e473d150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*PL46HQObVxqyx7osUk5e4A.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">使用LAG创建的新列“new_cases”</figcaption></figure><p id="107a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用上面突出显示的单元格来分解我的窗口函数。<br/>案例-滞后(案例，1)超过(按日期排序)</p><p id="1d59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的第一件事是告诉SQL从哪个字段开始。在本例中，SQL将使用当前行的“cases”列(在我们突出显示的示例中，这是9/10)。</p><p id="01d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一部分设置窗口— <strong class="ih hj"> LAG (cases，1) </strong>，告诉SQL我想使用上一行中的cases列(偏移量为1)并将其从当前行中减去。</p><p id="79cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们告诉SQL在进行计算时我们希望行如何排序。在本例中，我们按照日期从<strong class="ih hj">到(ORDER BY date ASC) </strong>的升序排序。我们希望将计算结果放在一个新列中，我们称之为“new_cases”。</p><p id="159d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我想知道过去7天的新病例总数，该怎么办？我们会改变偏移量！让我们试一试。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="7c2a" class="jv jw hi jr b fi jx jy l jz ka">SELECT date, state, county, cases,<br/>       cases - LAG (cases,1) OVER (ORDER BY date) as ‘new_cases’,<br/>       cases - LAG(cases,7) OVER (ORDER BY date) <br/>               as ‘7-day_new_cases’<br/>FROM counties<br/>WHERE state = ‘Illinois’ <br/>      AND county = ‘Cook’ <br/>      AND date &gt;= ‘2020-09-01’<br/>ORDER BY date</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/56bc2853d940ae17470bf0f335399ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*QTxVauHbCAwlD9P3LIId9Q.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">我们更改了偏移量来计算7天的新病例总数</figcaption></figure><p id="794a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一个LEAD函数，它的工作方式类似于LAG，但它是当前行之后的行，而不是当前行之后的行。您可以像编写LAG函数一样编写它，使用当前行的字段、LEAD关键字、列和偏移量，后跟您想要的行顺序。让我们试一试。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="c42a" class="jv jw hi jr b fi jx jy l jz ka">SELECT date, state, county, cases,<br/>       cases - LEAD (cases,1) OVER (ORDER BY date DESC) <br/>               as ‘new_cases’,<br/>       cases - LEAD (cases,7) OVER (ORDER BY date DESC) <br/>               as ‘7-day_new_cases’<br/>FROM counties<br/>WHERE state = ‘Illinois’ <br/>      AND county = ‘Cook’ <br/>      AND date &gt;= ‘2020-09-01’<br/>ORDER BY date</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/01aeed8cf63d78f52b60b51d1d384362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FOWtmXRVCW2ZEZ3U-i6Jw.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">我们用超前代替滞后，通过将日期改为DESC顺序，我们得到相同的结果</figcaption></figure><p id="1517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是相同的，但是顺序不同，这是因为我指出我希望行按日期降序排列，这使得计算与LAG函数相同。整洁！</p><p id="8944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我想查看伊利诺伊州的所有县，但仍然希望每天都有新病例，该怎么办？我们可以将我们的县分组，然后应用窗口函数！为此，我们使用关键字PARTITION BY。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="e26a" class="jv jw hi jr b fi jx jy l jz ka">SELECT date, state, county, cases,<br/>       cases - LAG (cases,1) OVER (PARTITION BY county <br/>                                   ORDER BY date) as ‘new_cases’,<br/>       cases - LAG (cases,7) OVER (PARTITION BY county <br/>                                   ORDER BY date)  <br/>               as ‘7-day_new_cases’<br/>FROM counties<br/>WHERE state = ‘Illinois’ <br/>      AND date &gt;= ‘2020-10-15’<br/>ORDER BY date</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/c843726c22bec76844ecd1371e2df9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrS46ciubhjAaxU9u-T1MA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">PARTITION BY允许我们按县分组，然后计算案例</figcaption></figure><p id="07f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，伊利诺伊州每个县每天都有新病例。您还可以在PARTITION BY子句中使用多列，例如，PARTITION BY state，county将对州进行分组，然后对县进行分组，这样您就可以得到所有的州和县。</p><p id="c539" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我想查找连续7天的平均新病例，该怎么办呢？我们不能用使用窗口函数的窗口函数创建列。所以我们需要创建一个cte。什么是cte？很高兴你问了！</p><p id="2836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> CTE — </strong>常见的餐桌表情。cte是一个临时结果集，与临时表不同，它只在查询范围内可用，而临时表可以在SQL会话期间使用。使用WITH语句定义cte。</p><p id="3776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">酷，酷。那里有很多不是很有用的行话。让我们看看它的运行情况。我将查找7天滚动平均新案例。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8edf" class="jv jw hi jr b fi jx jy l jz ka">WITH cte as (SELECT date, state, county,<br/>                    cases - LAG (cases,1) OVER <br/>                    (PARTITION BY fips ORDER BY date) <br/>                    as  ‘new_cases’,<br/>                    cases as ‘cumulative_cases’<br/>             FROM counties)</span><span id="f2e1" class="jv jw hi jr b fi kj jy l jz ka">SELECT date, state, county, new_cases, cumulative)_cases,<br/>       AVG(new_cases) OVER (PARTITION BY state, <br/>                            county ORDER BY date ASC <br/>                            rows 6 PRECEDING) as ‘7_day_avg_new’<br/>FROM cte<br/>ORDER BY state, county, date</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/15580178df2c32d81ddfaab2409dfe2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j-X4B5R-KPALyVs4DugRg.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">通过查询cte，我们可以在新的窗口函数中使用计算出的值！</figcaption></figure><p id="f6e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们的cte只是创建一个非常临时的表的一种方法，我们可以在下一步中查询这个表。我们也可以使用临时表来实现这一点，但是因为我们只需要查询cte一次，所以这是一个更有效的选择。我们稍后将讨论临时表，但它们非常类似于cte，只适用于整个SQL会话。</p><p id="1e50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不错！但是，这是目前计算不到7天的新病例数据的平均值。如果我们看3–25，我们显示3个新案例，总共4个案例，它显示我们在7天的滚动窗口内平均有3个新案例。我们需要更新这一点，以便平均显示，直到我们有7天的数据。我们将在下一篇文章中讨论这个问题。</p></div></div>    
</body>
</html>