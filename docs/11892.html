<html>
<head>
<title>Tensorflow 2 for Deep Learning — Logistic Regression ( Softmax )</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于深度学习的 tensor flow 2—逻辑回归(Softmax)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tensorflow-2-for-deep-learning-logistic-regression-softmax-bebf4f7e997c?source=collection_archive---------23-----------------------#2020-12-22">https://medium.com/analytics-vidhya/tensorflow-2-for-deep-learning-logistic-regression-softmax-bebf4f7e997c?source=collection_archive---------23-----------------------#2020-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6bf95f3cdbe6479db85d8c63cbcb4bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejUYVeFdJ89X_wzcXG0wfw.jpeg"/></div></div></figure><p id="f168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注:tensorflow 2 的程序文件可以在-</em><a class="ae jp" href="https://github.com/ashwinhprasad/Tensorflow-2.0" rel="noopener ugc nofollow" target="_blank"><em class="jo">【https://github.com/ashwinhprasad/Tensorflow-2.0】</em></a>找到</p><p id="b360" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">逻辑回归用于分类任务，本博客将带您通过 Tensorflow 2 实现逻辑回归。这篇博文不会涉及逻辑回归的理论，理论是前提。</p><h1 id="ace9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">让我们跳到代码部分:</strong></h1><h2 id="91a3" class="ko jr hi bd js kp kq kr jw ks kt ku ka jb kv kw ke jf kx ky ki jj kz la km lb bi translated">1.导入数据集</h2><blockquote class="lc ld le"><p id="52d3" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">本例中使用的数据集是 sklearn 库中的 iris 数据集。<br/>我们正在导入数据集，并以熊猫数据帧的形式存储它</p></blockquote><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="8abb" class="ko jr hi ln b fi lr ls l lt lu">#importing the libraries<br/>import numpy as np<br/>import tensorflow as tf<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="127f" class="ko jr hi ln b fi lv ls l lt lu">#importing the dataset<br/>from sklearn.datasets import load_iris<br/>data = load_iris()<br/>x = data['data']<br/>y = data['target']</span><span id="6d63" class="ko jr hi ln b fi lv ls l lt lu">dataset = pd.DataFrame(data=np.concatenate((x,y.reshape(-1,1)),axis=1),columns=['sepal length','sepal width','petal length','petal width','target'])</span></pre><h2 id="df25" class="ko jr hi bd js kp kq kr jw ks kt ku ka jb kv kw ke jf kx ky ki jj kz la km lb bi translated">2.列车测试分离</h2><blockquote class="lc ld le"><p id="b538" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">将数据集拆分为训练集和测试集，用于模型的未来分析</p></blockquote><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="cea0" class="ko jr hi ln b fi lr ls l lt lu">#train, test split<br/>from sklearn.model_selection import train_test_split<br/>x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.1,shuffle=True)</span></pre><h2 id="96c3" class="ko jr hi bd js kp kq kr jw ks kt ku ka jb kv kw ke jf kx ky ki jj kz la km lb bi translated">3.使用 keras functional API 的模型架构和培训</h2><blockquote class="lc ld le"><p id="b617" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">Keras Functional API 是顺序 API 的更好替代方案。它可以用于创建具有多个输入和多个输入以及复杂操作的模型。<br/>对于逻辑回归，我们可以使用 softmax 或 sigmoid 激活函数作为最终层。我使用了 softmax，因为输出只能是 3 种植物中的任何一种。</p><p id="acbb" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">注意:这不是纯粹的逻辑回归，因为我们在最后一层使用 softmax 激活。最后一层用 sigmoid 代替 softmax 可以实现逻辑回归。结果不会有太大的不同</p></blockquote><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="d089" class="ko jr hi ln b fi lr ls l lt lu">#model (Keras - Fuctional API)<br/>i = tf.keras.layers.Input(shape=(4))<br/>X = tf.keras.layers.Dense(3,activation=tf.keras.activations.softmax)(i)<br/>model = tf.keras.models.Model(i,X)</span><span id="cf14" class="ko jr hi ln b fi lv ls l lt lu">#compile and fit the model<br/>model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=0.01),loss=tf.keras.losses.sparse_categorical_crossentropy,metrics=['accuracy'])<br/>train = model.fit(x_train,y_train.reshape(-1),validation_data=(x_test,y_test.reshape(-1)),epochs=200)</span></pre><h2 id="68e9" class="ko jr hi bd js kp kq kr jw ks kt ku ka jb kv kw ke jf kx ky ki jj kz la km lb bi translated">4.模型性能</h2><blockquote class="lc ld le"><p id="a113" class="iq ir jo is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">使用图来分析模型的性能。该模型的精确度非常高</p></blockquote><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="ec46" class="ko jr hi ln b fi lr ls l lt lu">#plotting loss over epochs<br/>plt.figure(figsize=(10,8))<br/>plt.plot(train.history['loss'],label='Training loss')<br/>plt.plot(train.history['val_loss'],label='Validation loss')<br/>plt.xlabel('epochs')<br/>plt.ylabel('loss')<br/>plt.legend()</span><span id="b0ea" class="ko jr hi ln b fi lv ls l lt lu">#plotting accuracy over epochs<br/>plt.figure(figsize=(10,8))<br/>plt.plot(train.history['accuracy'],label='Training accuracy')<br/>plt.plot(train.history['val_accuracy'],label='Validation accuracy')<br/>plt.xlabel('Accuracy')<br/>plt.ylabel('loss')<br/>plt.legend()</span></pre><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/691700de933c979089184ec2120b2fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*DaANhSCvr2bpiGl0AGB7Pw.png"/></div></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/f9dc610819a6be41e657230a091de593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*UPgKSjZD9cc84cNwqELrzA.png"/></div></figure><h1 id="ad16" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="9cfa" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">从上面的可视化来看。我们可以断定我们的模型是有效的。<br/>逻辑回归是我们可以用于分类的强大工具，这就是如何使用 tensorflow 2 实施逻辑回归。</p></div></div>    
</body>
</html>