<html>
<head>
<title>Real-Time Head Pose Estimation With OpenCV and Dlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OpenCV和Dlib的实时头部姿态估计</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/real-time-head-pose-estimation-with-opencv-and-dlib-e8dc10d62078?source=collection_archive---------0-----------------------#2020-06-20">https://medium.com/analytics-vidhya/real-time-head-pose-estimation-with-opencv-and-dlib-e8dc10d62078?source=collection_archive---------0-----------------------#2020-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="91bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">头部姿态估计广泛用于各种计算机视觉应用中，如VR应用、免提手势控制应用、驾驶员注意力检测、凝视估计等等。在这篇文章中，我们将学习如何用OpenCV和Dlib来估计头部姿态。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/505d87832bd5a76ca556054e5f5d36f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojI1nkOcbu5xaZYOHVduTw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片提供:来自F.R.I.E.N.D.S .的乔伊·崔比亚尼—(我甚至不感到抱歉)</figcaption></figure><h1 id="fcdb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">计算机视觉中的姿态估计</h1><p id="7943" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在计算机视觉中，姿态估计特指物体相对于摄像机的相对方位。这里的参照系是摄像机的视场。在计算机视觉中，姿态估计通常被称为n点透视问题或PnP问题。问题的定义很简单，给定一组世界参考中的3D点和相机拍摄的相应2D图像，我将尝试用要点来简化这个问题</p><ul class=""><li id="5de0" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">重建参考的6自由度姿态-欧拉角(滚动、俯仰和偏航)以及相机从一个3D点到另一个3D点的移动。在纯文本中，我们必须找到<strong class="ih hj">平移</strong>和<strong class="ih hj">旋转</strong>。</li><li id="6bec" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">基于2D参考的三维重建</li></ul><p id="c7a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把这个问题定义为一个等式—</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/e806dfa00a6ec487704d11dbdb9e1d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*frbF-nNCA4TnigoabNJZmQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae ll" href="https://en.wikipedia.org/wiki/Perspective-n-Point" rel="noopener ugc nofollow" target="_blank"> PNP问题陈述</a></figcaption></figure><p id="0635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式<code class="du lm ln lo lp b">s[u v t]ᵗ</code>的左侧表示由相机拍摄的2D图像。等式的右侧，看起来像上三角矩阵的第一部分是我们的相机矩阵，其中<code class="du lm ln lo lp b">f(x, y)</code>是焦距，γ是偏斜参数，我们将在代码中将其保留为1。<code class="du lm ln lo lp b">(u₀, v₀)</code>是我们形象的中心。中间部分，<code class="du lm ln lo lp b">r</code>和<code class="du lm ln lo lp b">t</code>代表旋转和平移，最后一部分表示我们稍后将看到的人脸的3D模型。现在，我们将让他们来研究我们的理论和数学。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="4296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">获取代码</strong></p><div class="lx ly ez fb lz ma"><a href="https://github.com/by-sabbir/HeadPoseEstimation" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">by-sabbir/head pose估计</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">在计算机视觉中，姿态估计特指物体相对于目标的相对方位。</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">github.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo jn ma"/></div></div></a></div><p id="5923" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">理解“为什么和如何！?"</strong></p><p id="1998" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很明显，我们的应用程序需要检测人脸和预测形状来解决PnP并最终估计姿态。为了检测人脸和预测形状，我们将使用<a class="ae ll" href="http://dlib.net/" rel="noopener ugc nofollow" target="_blank"> <em class="mp"> dlib </em> </a> <em class="mp">。</em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="b988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在开始解决PnP。但在此之前，我们需要最后一次从上面的等式</p><ul class=""><li id="dfe4" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">三维人脸模型</li><li id="07dc" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">参考2D矩阵</li><li id="a8e1" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">相机矩阵</li></ul><p id="275a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">求解PnP并获得图像的旋转和平移(在我们的例子中是人脸)。让我们编码先决条件—</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="14fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lm ln lo lp b">ref3Dmodel()</code>和<code class="du lm ln lo lp b">ref2DImagePoints()</code>六坐标点是指鼻尖、下巴、左眼左角、右眼右角、嘴角。你可以可视化所有的点，并通过操作<code class="du lm ln lo lp b"><a class="ae ll" href="https://github.com/by-sabbir/HeadPoseEstimation/blob/master/Visualize3DModel.py" rel="noopener ugc nofollow" target="_blank">Visualize3DModel</a>.py</code>随意添加。</p><p id="5a1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV提供了两个简单的API来解决PnP</p><ul class=""><li id="d852" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><code class="du lm ln lo lp b">solvePnP</code></li><li id="5036" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><code class="du lm ln lo lp b">solvePnPRansac</code></li></ul><p id="7127" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们将使用<code class="du lm ln lo lp b">solvePnP</code>。按照惯例，这个API需要<a class="ae ll" href="https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool%20solvePnP(InputArray%20objectPoints,%20InputArray%20imagePoints,%20InputArray%20cameraMatrix,%20InputArray%20distCoeffs,%20OutputArray%20rvec,%20OutputArray%20tvec,%20bool%20useExtrinsicGuess,%20int%20flags)" rel="noopener ugc nofollow" target="_blank"> 4个输入参数</a></p><ul class=""><li id="437a" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">目标点→ <code class="du lm ln lo lp b">ref3Dmodel()</code></li><li id="964d" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">图像点→ <code class="du lm ln lo lp b">ref2DImagePoints()</code></li><li id="f859" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">cameraMatrix → <code class="du lm ln lo lp b">cameraMatrix()</code></li><li id="c6ea" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">distCoefs → <code class="du lm ln lo lp b">np.zeros(4, 1)</code></li></ul><p id="3dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过解析PnP，API返回<code class="du lm ln lo lp b">success message</code>、<code class="du lm ln lo lp b">rotation vector</code>和<code class="du lm ln lo lp b">translation vector</code>矩阵。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="038c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">摄像机的焦距必须经过<a class="ae ll" href="https://github.com/by-sabbir/HeadPoseEstimation/blob/master/cam_calibration.py" rel="noopener ugc nofollow" target="_blank">校准</a>，因为它是摄像机硬件的固有属性。</p><p id="4055" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">得到欧拉角</strong></p><p id="d931" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以很容易地提取滚动，俯仰和偏航。也就是说，我们要通过OpenCV的<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html?highlight=euler#rqdecomp3x3" rel="noopener ugc nofollow" target="_blank">RQDecomp3x3</a></code> API来提取欧拉角。但是它需要一个旋转矩阵而不是一个旋转向量。幸运的是，我们已经使用<code class="du lm ln lo lp b">solvePnP</code>计算了旋转向量。OpenCV的另一个API叫做<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html?highlight=euler#rodrigues" rel="noopener ugc nofollow" target="_blank">Rodrigues</a></code>，它将旋转矩阵转换成旋转向量，反之亦然。这就是我们如何实现它—</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="541f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的输出应该是这样的—</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ms mr l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">样本头部姿态估计</figcaption></figure><p id="f24a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">样本头部姿态估计</p><p id="f768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结总结</strong></p><p id="0874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始检测和预测人脸的形状。然后我们用<code class="du lm ln lo lp b">solvePnP</code>计算旋转和平移向量。最后用<code class="du lm ln lo lp b">RQDecomp3x3</code>得到旋转角度。又一个简单的3步过程。计算机视觉很有趣。</p></div></div>    
</body>
</html>