<html>
<head>
<title>Add power to your model with AdaBoost Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AdaBoost算法为您的模型增加动力</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/add-power-to-your-model-with-adaboost-algorithm-ff3951c8de0?source=collection_archive---------1-----------------------#2019-11-17">https://medium.com/analytics-vidhya/add-power-to-your-model-with-adaboost-algorithm-ff3951c8de0?source=collection_archive---------1-----------------------#2019-11-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5838a50833214bbf3d1829726f6451cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i-klCWvaxoTcKm5b"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae iu" href="https://unsplash.com/@bulkan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bulkan Evcimen </a>拍摄的照片</figcaption></figure><p id="32e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自适应增强算法通常被称为<strong class="ix hj"> <em class="jt"> AdaBoost </em> </strong>算法是一种基于决策树的<strong class="ix hj">集成增强学习技术</strong>，或者我们可以说是借助决策树。</p><p id="413d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为决策树也用于构建随机森林模型，所以我们需要知道adaboost和随机森林模型之间的区别:→</p><ol class=""><li id="9c8c" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated">在随机森林中，我们通过将数据集划分为n个相等的部分，从数据集的每个子部分生成不同的决策树，其中一些树可能比其他的更大，但是决策树的大小没有预先确定的长度。<em class="jt">相比之下，用AdaBoost生成的树的森林，每棵树包含一个父节点和两个叶节点，这种类型的树称为树桩。</em></li><li id="4898" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">对于随机森林的最终分类，每棵树都有同等的投票权。<em class="jt">然而，在由adaboost生成的树桩森林中，一些树桩在最终分类中比其他树桩获得更多发言权或更多投票。</em></li><li id="0982" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">在随机森林中，每棵树都是独立生成的，不会影响其他树。<em class="jt">相反，以adaBoost顺序生成的树桩森林很重要，因为第一棵树生成的错误会影响第二棵树，而第二棵树生成的错误会影响第三棵树，等等。，等等</em>。</li></ol><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/6635d20a8fb11eb69cbea433adf1bd2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQBDGwcdrPtxGEcGeD6Dgg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">残肢的图示</figcaption></figure><h2 id="a714" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">AdaBoost算法在哪里使用？→</h2><p id="8ffe" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">AdaBoost算法用于数据集的各种特征(自变量)与其目标变量(因变量)之间存在复杂关系的地方。</p><h2 id="6327" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">AdaBoost算法是如何工作的？→</h2><p id="456c" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">为了理解这一点，我们将使用该数据集对来自特定地区、具有特定收入并参考其性别的人是否患有心脏病进行分类。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/c4807c9e46767fc2bf191d9f872e2f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*PH0DhRa_iaqJXzvgTkUOYQ.png"/></div></figure><p id="f50e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们要做的第一件事是添加一个与表中每个数据点相对应的“权重”列，该列将指示相应数据点被正确分类与否的重要性。因为我们的数据集中有8行，所以我们将在“权重”列中为每个数据点分配1/8的权重。因此，每次开始时，我们将为数据集中的每个点分配一个权重<strong class="ix hj"> 1/(数据集中的样本总数)</strong>，这表明所有数据点在开始时同等重要。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/6a2e359b4e38f674db860ee9bade3d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3I25AaW6Nnw5coFvNTsgfQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">向我们的数据集添加等量的样品重量</figcaption></figure><p id="c36b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们需要在基尼系数的帮助下构建一个树桩森林，通过构建一串树桩来表示每个独立列的正确和错误分类数据点的数量</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/229b1f51936c2355d855514269a37d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6VcQpmUDHNvWf3tPUzuAw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">城市圆柱桩</figcaption></figure><p id="fa5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">达拉斯市的基尼系数= 1 -(2/(2+2)) -(2/(2+2)) = 0.5</p><p id="ec5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">纽约市的基尼系数= 1 -(1/(1+3)) -(3/(1+3)) = 0.375</p><p id="a966" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">城市列基尼系数</strong>= 0.5 *(2+2)/(2+2+1+3))+0.375 *(1+3)/(2+2+1+3))=<strong class="ix hj">0.437</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/52532efd13212cc5dcfd48ab98491b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xknohLrpgtL1-Wsq96R4mA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">性别栏树桩</figcaption></figure><p id="00f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，根据城市栏显示，性别栏的基尼指数= 0.48 *(2+3)/(2+3+1+2))+0.375 *(1+2)/(2+3+1+2))=<strong class="ix hj">0.44</strong></p><p id="4260" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于只有数值的柱，有不同的方法来构造树桩。首先，我们将并排保存独立列和从属列，然后我们将对独立数字列进行排序。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/2024a8955e8e6b77149c364d2937eee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNxXIcpmS4Q0qVrLaMYE9Q.png"/></div></div></figure><p id="a578" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，对于该列中每两行独立值，我们必须计算其平均值。得到这些值后，我们必须搜索返回最低基尼指数的值，该值将代表整个列的stump。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/8b33749671bd582c47489e16995ea9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*Aw2pne1dqVRCa5W9OO3beQ.png"/></div></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/b5a6b08ffcabdc3b4f3d65d9a0e1295f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZiQIJ_RbG7GPDNF2B0ceuw.png"/></div></div></figure><p id="a48a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼指数</strong>为<strong class="ix hj"> 40945.5 </strong>值= 0.48 *(4+3)/(0+1+4+3)=<strong class="ix hj">0.42</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/9f4ed73dab45e0f7b3de6046c9444b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF3fFTQ8Yft8RGZXrzhGcQ.png"/></div></div></figure><p id="7bae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼指数</strong>为<strong class="ix hj"> 43948.5 </strong>值= 0.5 *(1+1)/(1+1+2+4))+0.44 *(2+4)/(1+1+2+4))=<strong class="ix hj">0.455</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/5d10a185a0dc1da6c358ec4d97f0d419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vef5bBMhOpi28E0xys7ckg.png"/></div></div></figure><p id="5c02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼指数</strong>为<strong class="ix hj"> 51509 </strong>值= 0.11 *(2+1)/(2+1+1+4))+0.24125 *(1+4)/(2+1+1+4))=<strong class="ix hj">0.19</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/1b0502c3a03ae673d2cab583ded170de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFQ5owW_v64tZbX9Y-wV-A.png"/></div></div></figure><p id="287d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼指数</strong>为<strong class="ix hj"> 77370.5 </strong>值= 0.5 *(2+2)/(2+2+1+3))+0.375 *(1+3)/(2+2+1+3))=<strong class="ix hj">0.4375</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/47d6d36c9a375ee41732e31b0572e423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61UokiqPxdxD56E-7iC6Bw.png"/></div></div></figure><p id="297e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼指数</strong>为<strong class="ix hj"> 99379 </strong>值= 0.48 *(2+3)/(2+3+1+2))+0.44 *(1+2)/(2+3+1+2))=<strong class="ix hj">0.465</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/fa17964d4649a3d3e8cff7f9b8e345c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzcZP2Umpwv3RbxECud59Q.png"/></div></div></figure><p id="9339" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼指数</strong>为<strong class="ix hj"> 101375.5 </strong>值= 0.44 *(2+4)/(2+4+1+1))+0.5 *(1+1)/(2+4+1+1))=<strong class="ix hj">0.455</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/ee8d30496879091ca7a14c85295bb27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3565dif7lWRPAhF1hiF9w.png"/></div></div></figure><p id="01ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基尼系数</strong>为<strong class="ix hj"> 109676 </strong>值= 0.408 *(2+5)/(2+5+1+0)=<strong class="ix hj">0.357</strong></p><p id="9e6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们计算了每一栏的基尼指数后发现，<strong class="ix hj"> 51509 </strong>的<strong class="ix hj">基尼指数</strong>值为<strong class="ix hj"> 0.19，</strong>相对于其他值为<strong class="ix hj">最低的</strong>，使得<strong class="ix hj"> 51509成为收入栏</strong>的划分参数。在那之后，我们将再次计算<strong class="ix hj">的数量，比如说</strong>每个树桩都通过了不正确或错误分类的类别的数量。<strong class="ix hj"> <em class="jt">计算每个树桩的say量的公式为</em> </strong> : →</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/7bb68dc1c536b093921577d13e66aef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*z2hWdJBTtBxAQ74aDCPH6A.png"/></div></figure><p id="ce66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中，总误差等于<strong class="ix hj">独立列</strong>做出的错误预测数的权重之和，例如城市列的总误差=城市列的错误预测数= 5 =每次错误预测的权重之和= 1/8 + 1/8 + 1/8 + 1/8 + 1/8 = 5/8</p><p id="660e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">表示城市列的金额为</em></strong>:(1/2)* log((1-(5/8))/(5/8))=-0.11</p><p id="47c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">表示性别栏的金额为</em></strong>:(1/2)* log((1-(5/8))/(5/8))=-0.11</p><p id="e483" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">表示收入栏的金额为</em></strong>:(1/2)* log((1-(2/8))/(2/8))= 0.23</p><p id="a0db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，我们就知道了错误分类的数据点的样本权重是如何被用来确定每个树桩得到的样本量的。现在，我们将开始修改每个样本的权重。因此，<strong class="ix hj">我们将首先修改(即，我们将增加)被具有最低基尼指数的列树桩错误分类为<em class="jt"/>的数据点的权重，然后减少该列中被正确分类为<em class="jt"/></strong>的数据点的权重。我们将使用公式修改权重:→</p><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/795c025ae0f554b9689472fb704828f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*1V6F2kEaebC1OtVJVCLI5Q.png"/></div></figure><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/b3f9baf16fbccad0449e54c666437c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*8PlzX0j-lg2hELFtHd6qXQ.jpeg"/></div></figure><p id="05ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<strong class="ix hj"> <em class="jt">我们将为数据集“新权重”分配一个新列，它将作为修改后的权重来替换数据集中的“权重”列。</em> </strong>然后，我们将开始为表格中的每个数据点分配新的权重。被错误分类的数据点将在修改的权重列中增加，而被正确分类的数据点将在修改的权重列中减少。现在，<strong class="ix hj">我们将通过用整个“新权重”列</strong>的<em class="jt">和</em>除每个数据点来归一化新的样本权重，并将归一化的样本权重转移到“新权重”列，因为它们将对下一个残端有贡献。</p><p id="a1fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在我们的数据集<strong class="ix hj">中，在所有其他特征中具有最低基尼指数0.19的<strong class="ix hj"> 51509 </strong>值的收入</strong>将用于对患者是否患有心脏病的数据进行分类。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/5d10a185a0dc1da6c358ec4d97f0d419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vef5bBMhOpi28E0xys7ckg.png"/></div></div></figure><p id="e986" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为有2 ( 1 +1)个不正确的预测，所以那些列的权重将增加到(1/2)*e^(0.23) = 0.629，对于6 ( 2 + 4)个正确的预测，新的权重将减少到(1/2) * e^ -(0.397)，因此新的数据集将是:-</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/3ae5f9c66b21f8666cdc33e03f2ab069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qEP0r8ZRssqxfHJHv2vxg.png"/></div></div></figure><p id="e853" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们需要通过将每个新的权重除以整个列的总和来对新的权重进行归一化，这等于(0.629+0.397+0.397+0.397+0.397+0.397+0.397+0.397+0.629)= 3.64。因此，0.629/3.64 = 0.17，0.397/3.64 = 0.10，数据集如下所示:→</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/c770b61adff3f3e3d6fb9d5c06da57e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0jJbFCBaFxR7EwexhKXxw.png"/></div></div></figure><p id="ae54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，是我们开始构建第二个树桩(分类器)的时候了。但是，在<strong class="ix hj"> <em class="jt">之前，我们将创建一个新的空数据集，其大小与具有相同列名</em> </strong>的原始数据集相同。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/01b30927e1e90e6c29945d9cc18cea44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgDGGJVNzLDbJ-hFwLEIjg.png"/></div></div></figure><p id="24bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们必须开始将行数据分配给空白数据集，顺序是我们必须取0到1之间的8个随机数。根据我们选择的每个随机数，如果它在0到<strong class="ix hj"> 0.17(第一行的新权重)</strong>之间，那么第一行将首先被添加到空白数据集中，或者， 如果随机数在0.17到<strong class="ix hj"> 0.27 </strong> ( 0.17 + <strong class="ix hj"> 0.1(第二行的新权重)</strong>)之间，则将第二行添加到空白数据集中，同样，如果随机数在0.27到<strong class="ix hj"> 0.37 </strong> (0.27 + <strong class="ix hj"> 0.1(第三行的新权重)</strong>之间，则将第三行添加到空白数据集中，并分别用于其他新权重的新行</p><p id="6c47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们必须注意到，与正确分类的行相比，错误分类的行的范围<strong class="ix hj">更大，即</strong> 0.17(例如<strong class="ix hj"> 0到0.17 </strong>和<strong class="ix hj"> 0.77到0.94 </strong>，而正确分类的行的范围<strong class="ix hj">更小，即</strong> 0.1(例如<strong class="ix hj"> 0.17到0.27 </strong>和<strong class="ix hj"> 0.37到0.47【1】因此，在新的空白数据集</strong>中，<strong class="ix hj">错误分类的行将比正确分类的行出现更多次，并且具有最低基尼指数的<strong class="ix hj"> 51509 </strong>值的<strong class="ix hj">收入树桩</strong>将被视为该数据集</strong>的<strong class="ix hj">第一弱学习者。</strong></p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/5d10a185a0dc1da6c358ec4d97f0d419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vef5bBMhOpi28E0xys7ckg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">AdaBoost算法的第一个弱学习器</figcaption></figure><p id="dba5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，让我们假设，如果我们有新的更新数据集是这样的:→</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/29790666be78f71f2f82c8bd7a7a34c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvrEs4xPZHktroQ66xn_sw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">新更新的数据集包含更多错误分类的行</figcaption></figure><p id="7bb7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，根据这个新的数据集，我们将不得不再次构建下一个弱分类器，并继续这个过程，直到所有的行都以它们更新的权重被正确分类。</p><p id="9074" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当新的测试数据集通过这些弱决策树树桩时，新的测试数据集将被赋予一个值，该值从弱分类器获得关于其测试特征的人是否具有心脏数据集的最多投票，因为我们在这里组合这些弱学习器并使其成为强学习器。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/feeaef4a567612f40285f988777befd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfXJSSwZZzULN_gNmARD1A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">AdaBoost算法中的弱分类器集</figcaption></figure><p id="73b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是AdaBoost算法的工作原理。我希望你喜欢阅读这篇博客。如果您有任何意见、疑问或问题，请在评论区告诉我。在那之前享受学习。</p></div></div>    
</body>
</html>