<html>
<head>
<title>Auto annotate images for TensorFlow object detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于张量流对象检测自动注释图像</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/auto-annotate-images-for-tensorflow-object-detection-19b59f31c4d9?source=collection_archive---------2-----------------------#2019-12-24">https://medium.com/analytics-vidhya/auto-annotate-images-for-tensorflow-object-detection-19b59f31c4d9?source=collection_archive---------2-----------------------#2019-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f1919a400fbd252955aadf27d448c117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hRN_XYo4rK-rMEY1jhjiA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://hackernoon.com/hn-images/1*_ptBWjaV6FgVPgOYd5UZVg.png" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/HN-images/1 * _ ptbwjav 6 fgvpgoyd 5 uzvg . png</a></figcaption></figure><blockquote class="iv iw ix"><p id="6348" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这篇文章和库版本都过时了，请参考我的新文章查看新库版本:【https://medium.com/p/acf410a600b8<a class="ae iu" rel="noopener" href="/p/acf410a600b8"/></p></blockquote><p id="bb91" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">每个处理过对象检测问题的人都知道注释图像的过程是多么的无聊和耗时。</p><p id="bc8b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">注释它本身非常简单，如下面的GIF所示，我们只需要标记对象的位置并告诉它的类。对于一些图像来说这样做没有问题，但是当我们的数据集中有数百甚至数千个数据时，这在深度学习中是很正常的，这就变成了我们工作的瓶颈。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/41d397adcef1cd93538399a2b4ed45b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*RFy_qSddLuNt0uWiLq0zeA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个无聊又费时的注释图像的过程。</figcaption></figure><p id="25ca" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在我最后的作品之一中，我需要创建我自己的咖啡叶数据集，并标记它们的疾病。起初，我在<a class="ae iu" href="https://github.com/tzutalin/labelImg" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hj"> LabelImage </strong> </a>软件中手工注释图像，并训练模型，但我对这种方法真的不满意，因为我把所有时间都花在创建和注释数据集上，这使得扩大项目规模变得困难。</p><p id="1e07" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">所以我想到了一个简单的方法来改变这个过程，把它变成一个更加自动化的过程。</p><p id="97a7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">使用这种新方法，我创建了一个名为<strong class="jb hj"> generate XML </strong>的Python类，它负责为我做艰苦的工作，通过预训练模型的推理来注释图像，以获得边界框的位置，并创建一个在训练中使用的XML。</p><h1 id="9da0" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">自动化流程</h1><p id="ccee" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">要在您的机器上运行这个项目，您需要在<a class="ae iu" href="https://github.com/tensorflow/models" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上克隆TensorFlow存储库，并安装所有的依赖项。由于第一次可能会有点困难，<a class="ae iu" href="https://neptune.ai/blog/how-to-train-your-own-object-detector-using-tensorflow-object-detection-api" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到一个完整的教程，解释这个过程的步骤。</p><p id="1c33" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><a class="ae iu" href="https://github.com/AlvaroCavalcante/auto_annotate" rel="noopener ugc nofollow" target="_blank"> auto_annotate </a>项目是在TensorFlow 1.14中完成的，但它也与TF 2.x兼容。</p><p id="f315" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在文件夹<strong class="jb hj">research/object _ detection</strong>里面几乎是我们需要的一切，你可以查看名为<strong class="jb hj">object _ detection _ tutorial</strong>的笔记本，在那里他们详细解释了加载模型和创建新推论的过程。</p><p id="b5c6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在我的例子中，我在NodeJS API中使用了auto annotate，但是我们将创建一个目录方案来显示行为，然后您可以修改它以在任何您想要的地方使用。</p><p id="0a66" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">该方案有一个名为<strong class="jb hj"> auto_annotate </strong>的文件夹，在这个文件夹中，我有以下文件夹:<strong class="jb hj">图像、脚本、结果、图表和xml </strong>。</p><ul class=""><li id="3351" class="li lj hi jb b jc jd jg jh jx lk jy ll jz lm jw ln lo lp lq bi translated"><strong class="jb hj">图片</strong>包含所有你想推断和创建一个XML的照片</li><li id="93c7" class="li lj hi jb b jc lr jg ls jx lt jy lu jz lv jw ln lo lp lq bi translated"><strong class="jb hj">结果</strong>是推理的结果</li><li id="1584" class="li lj hi jb b jc lr jg ls jx lt jy lu jz lv jw ln lo lp lq bi translated"><strong class="jb hj">脚本</strong>包含了我们将使用的所有python算法。</li><li id="c774" class="li lj hi jb b jc lr jg ls jx lt jy lu jz lv jw ln lo lp lq bi translated"><strong class="jb hj">图</strong>是冻结的推理图和标签图。</li><li id="9201" class="li lj hi jb b jc lr jg ls jx lt jy lu jz lv jw ln lo lp lq bi translated"><strong class="jb hj"> xml </strong>是包含生成的xml文件的文件夹。</li></ul><p id="6bd3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">你可以找到我在GitHub上使用的代码:<a class="ae iu" href="https://github.com/AlvaroCavalcante/auto_annotate" rel="noopener ugc nofollow" target="_blank">https://github.com/AlvaroCavalcante/auto_annotate</a></p><p id="1aac" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">主文件是<strong class="jb hj"> detection_images.py </strong>，负责加载冻结的模型并为文件夹中的图像创建新的推断。如果有必要，您需要更改第一行来添加您自己的路径。我还添加了一些行来改变图像的尺寸并保存结果，其他的都和你在TensorFlow目录中找到的原始文件相似。</p><p id="07c1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jb hj"> generate_xml.py </strong>文件接收推断类的名称、图像尺寸、文件名和带有边界框坐标的字典数组。</p><p id="d7a1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">所有这些信息都通过文件<strong class="jb hj"> visualization_utils.py传递，</strong>也可以在TensorFlow目录中找到，我们只需要做如下一些修改。</p><pre class="kb kc kd ke fd lw lx ly lz aw ma bi"><span id="afd6" class="mb kg hi lx b fi mc md l me mf">array_position = []</span><span id="1c98" class="mb kg hi lx b fi mg md l me mf">im_height, im_width, shape = image.shape #get image dimensions</span><span id="def8" class="mb kg hi lx b fi mg md l me mf">for box, color in box_to_color_map.items(): #loop in predicted boxes</span><span id="2b2c" class="mb kg hi lx b fi mg md l me mf">ymin, xmin, ymax, xmax = box</span><span id="38c8" class="mb kg hi lx b fi mg md l me mf">dict_position = {'xmin': 0, 'xmax': 0, 'ymin': 0, 'ymax': 0}</span><span id="7e70" class="mb kg hi lx b fi mg md l me mf">dict_position['ymin'] = ymin * im_height #add the positions to the #dict, we multiply to get the real value in pixels</span><span id="8089" class="mb kg hi lx b fi mg md l me mf">dict_position['xmin'] = xmin * im_width</span><span id="945c" class="mb kg hi lx b fi mg md l me mf">dict_position['ymax'] = ymax * im_height</span><span id="f5d3" class="mb kg hi lx b fi mg md l me mf">dict_position['xmax'] = xmax * im_width</span><span id="7526" class="mb kg hi lx b fi mg md l me mf">array_position.append(dict_position)</span></pre><p id="4a48" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">有了这个设置，我们只需要实例化这个类并运行方法<strong class="jb hj">generate _ basic _ structure</strong>来生成XML。</p><pre class="kb kc kd ke fd lw lx ly lz aw ma bi"><span id="2861" class="mb kg hi lx b fi mc md l me mf">if new_xml != False: #this statement prevents to call the class with # we don't have predictions in the image.</span><span id="1e15" class="mb kg hi lx b fi mg md l me mf">xml = generate_xml.GenerateXml(array_position, im_width, im_height, class_name, file_name)</span><span id="f394" class="mb kg hi lx b fi mg md l me mf">xml.gerenate_basic_structure()</span></pre><p id="f138" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这个方法中，我们使用ElementTree(需要从pip安装)来创建一个基于LabelImage自动生成的XML结构，用for循环传递盒子位置并保存文件。请务必记住，XML的名称必须与推断出的图像文件的名称相同。</p><h1 id="d50e" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">运行脚本</h1><p id="41c8" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">在运行该算法之前，您需要将TensorFlow文件夹<strong class="jb hj">research/object _ detection/utils</strong>中的文件visualization_utils.py替换为我们修改过的文件(请记住，他们总是在TensorFlow存储库中添加新的更改，因此根据您完成本教程的时间，如果您将TF中的可视化文件替换为mine，这可能不起作用，复制并粘贴已更改的行更安全，但您可以先尝试替换)。</p><p id="47b8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">您还需要将文件<strong class="jb hj"> generate_xml.py </strong>复制并粘贴到utils文件夹，位置与<strong class="jb hj"> visualization_utils.py </strong>相同。</p><p id="1afc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">之后，你只需要进入你的文件夹(auto_annotate for me)并运行:</p><pre class="kb kc kd ke fd lw lx ly lz aw ma bi"><span id="df66" class="mb kg hi lx b fi mc md l me mf">python3 scripts/detection_images.py</span></pre><p id="7234" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果一切正常，您将在结果文件夹中看到推断的图像，如下所示:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/38ebb6fd97a9ca3c351bdb05081b3ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tMzi0xWv3nPxTfhLtzJSQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">模型推断出的我的咖啡叶！</figcaption></figure><p id="a167" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在XML文件夹中，您将找到包含注释的文件，让我们打开LabelImage中的图像和XML。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/607d4d5ae760163ac463e90ffb76254c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMYqv6_8fsaEIwFuux4yYg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们到了！！！自动创建的标签</figcaption></figure><p id="21b2" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">显然，它还不完善，您可能希望将盒子位置调整得更精确(取决于您的问题领域)，并且当您预先训练的模型不能正确推断时，肯定需要创建新的标签，但我们可以说，这比手动完成所有工作更快。</p><p id="e777" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">只要我们更多地训练我们的模型，推论就更准确，注释过程也变得更容易。</p><h1 id="de0a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="a97f" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">一种更自动化的方式来注释数据集对于每个使用对象检测的人来说都是非常重要的，这使得我们可以专注于真正重要的事情，而不是在这上面浪费时间。这只是第一步，我希望很快出现新的方法和算法来促进这一进程。</p><p id="5206" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">感谢你的阅读，我希望这篇教程能帮助你，如果你有困难或有疑问，请告诉我，我很乐意帮助你。:)</p></div></div>    
</body>
</html>