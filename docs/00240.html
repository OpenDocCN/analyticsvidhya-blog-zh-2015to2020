<html>
<head>
<title>A Hands-On Introduction to Time Series Classification (with Python Code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列分类实践介绍(带Python代码)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-hands-on-introduction-to-time-series-classification-with-python-code-48f8b442e7c1?source=collection_archive---------0-----------------------#2019-01-07">https://medium.com/analytics-vidhya/a-hands-on-introduction-to-time-series-classification-with-python-code-48f8b442e7c1?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="172b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对时间序列数据进行分类？这真的可能吗？这样做的潜在用途是什么？以上只是你在看这篇文章标题时一定会有的一些疑问。公平地说，当我第一次看到这个概念时，我也有同样的想法！</p><p id="b393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们大多数人接触到的时间序列数据主要用于生成预测。无论是预测产品的需求或销售、航空公司的乘客数量还是特定股票的收盘价，我们都习惯于利用久经考验的时间序列技术来预测需求。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/b4e83a1b3a57ebfda79b2ccc7dc8d380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*UpiPWiq2a1lO4Hx1.jpg"/></div></figure><p id="3db1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是随着生成的数据量呈指数级增长，尝试新想法和算法的机会也在增加。处理复杂的时间序列数据集仍然是一个利基领域，扩展您的知识库以包含新的想法总是有帮助的。</p><p id="b5b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我在这篇文章中要做的，向你介绍时间序列分类的新概念。我们将首先了解这个主题的含义及其在行业中的应用。但是我们不会停留在理论部分—我们将通过处理时间序列数据集和执行二元时间序列分类来动手。边做边学——这也将帮助你以实用的方式理解这个概念。</p><p id="c81b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你以前没有处理过时间序列问题，我强烈建议你先从一些基本的预测开始。首先，你可以阅读下面的文章:</p><p id="39a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jl" href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="noopener ugc nofollow" target="_blank">创建时间序列预测的综合初学者指南(用Python编写代码)</a></p><h1 id="6680" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">目录</h1><ol class=""><li id="bb98" class="kk kl hi ih b ii km im kn iq ko iu kp iy kq jc kr ks kt ku bi translated">时间序列分类介绍<br/> 1.1心电信号<br/> 1.2图像数据<br/> 1.3传感器</li><li id="276a" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">设置问题陈述</li><li id="5113" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">阅读和理解数据</li><li id="1578" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">预处理</li><li id="8fed" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">构建我们的时间序列分类模型</li></ol><h1 id="44af" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">时间序列分类介绍</h1><p id="0a67" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">时间序列分类实际上已经存在一段时间了。但到目前为止，它主要局限于研究实验室，而不是工业应用。但是有很多研究正在进行，新的数据集正在创建，许多新的算法正在提出。当我第一次遇到这个时间序列分类概念时，我最初的想法是——我们如何对时间序列进行分类，以及时间序列分类数据是什么样的？我相信你也在想同样的事情。</p><p id="693e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以想象，时间序列分类数据不同于常规分类问题，因为属性具有有序的序列。让我们看一些时间序列分类用例来理解这种差异。</p><h1 id="7330" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">1)对ECG/EEG信号进行分类</h1><p id="7636" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">ECG或心电图记录心脏的电活动，并广泛用于诊断各种心脏问题。这些ECG信号是使用外部电极采集的。</p><p id="9a87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，考虑以下代表一次心跳的电活动的信号样本。左边的图像代表正常的心跳，而旁边的图像代表心肌梗塞。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ld"><img src="../Images/f441beb70268000683cca609943591f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*SvHqY9gF08pLuvzl.png"/></div></figure><p id="72a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从电极捕获的数据将是时间序列形式，并且信号可以被分类为不同的类别。我们还可以对记录大脑电活动的EEG信号进行分类。</p><h1 id="243b" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">2)图像分类</h1><p id="5efa" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">图像也可以是顺序的时间相关格式。考虑以下场景:</p><p id="3065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作物种植在特定的田地里，这取决于天气条件、土壤肥力、水的可利用性和其他外部因素。连续5年每天拍摄这片土地的照片，并标上该土地上种植的作物名称。你明白我的意思了吗？数据集中的影像是在固定的时间间隔后拍摄的，并具有定义的序列，这是对影像进行分类的一个重要因素。</p><h1 id="8b5a" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">3)对运动传感器数据进行分类</h1><p id="6707" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">传感器产生高频数据，可以识别其范围内的物体运动。通过设置多个无线传感器，观察传感器中信号强度的变化，我们可以识别物体的运动方向。</p><p id="0a39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你能想到我们可以应用时间序列分类的其他应用吗？请在文章下方的评论区告诉我。</p><h1 id="b4df" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">设置问题陈述</h1><p id="2332" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们将致力于解决“<em class="le">室内用户运动预测</em>问题。在这项挑战中，多个运动传感器被放置在不同的房间中，目标是根据这些运动传感器捕获的频率数据来识别个人是否在房间中移动。</p><p id="358c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有四个运动传感器(A1、A2、A3、A4)横跨两个房间放置。请看下图，它展示了每个房间中传感器的位置。这两个房间的设置是在3对不同的房间中创建的(第1组、第2组和第3组)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/8532a257f13c0d8fc86c11ece122939c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BOwIRhOCa-W4ti8n.jpg"/></div></div></figure><p id="018c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个人可以沿着上图所示的六条预定义路径中的任何一条移动。如果一个人走在路径2、3、4或6上，他在房间内移动。另一方面，如果一个人沿着路径1或路径5走，我们可以说这个人在房间之间移动了。</p><p id="ff91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传感器读数可用于识别人在给定时间点的位置。当人在房间内或房间间移动时，传感器中的读数会发生变化。这种变化可以用来识别人的路径。</p><p id="ab0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在问题陈述清楚了，是时候开始编码了！在下一节中，我们将查看问题的数据集，这将有助于澄清您对该陈述可能存在的任何疑问。可以从这个链接下载数据集:<strong class="ih hj"> </strong> <a class="ae jl" href="https://archive.ics.uci.edu/ml/datasets/Indoor+User+Movement+Prediction+from+RSS+data" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">室内用户运动预测</strong> </a> <strong class="ih hj">。</strong></p><h1 id="49cf" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">阅读和理解数据</h1><p id="edcc" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们的数据集由316个文件组成:</p><ul class=""><li id="85a5" class="kk kl hi ih b ii ij im in iq lk iu ll iy lm jc ln ks kt ku bi translated">314 <strong class="ih hj"/></li><li id="5828" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc ln ks kt ku bi translated">一个<strong class="ih hj"> <em class="le">目标</em> </strong> csv文件，包含每个运动文件的目标变量</li><li id="ea08" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc ln ks kt ku bi translated">一个<strong class="ih hj"> <em class="le">组数据</em> </strong> csv文件，用于识别哪个运动文件属于哪个设置组</li><li id="6a2d" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc ln ks kt ku bi translated">包含对象路径的<strong class="ih hj"> <em class="le">路径</em> </strong> csv文件</li></ul><p id="4fc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看数据集。我们将从导入必要的库开始。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="24de" class="lt jn hi lp b fi lu lv l lw lx">import pandas as pd <br/>import numpy as np <br/>%matplotlib inline <br/>import matplotlib.pyplot as plt <br/>from os import listdir</span><span id="a7a2" class="lt jn hi lp b fi ly lv l lw lx">from keras.preprocessing import sequence <br/>import tensorflow as tf <br/>from keras.models import Sequential <br/>from keras.layers import Dense <br/>from keras.layers import LSTM <br/>from keras.optimizers import Adam <br/>from keras.models import load_model <br/>from keras.callbacks import ModelCheckpoint</span></pre><p id="afdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在加载所有文件之前，让我们先快速浏览一下我们将要处理的数据。从移动数据中读取前两个文件:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="5a2c" class="lt jn hi lp b fi lu lv l lw lx">df1 = pd.read_csv(‘/MovementAAL/dataset/MovementAAL_RSS_1.csv') df2 = pd.read_csv('/MovementAAL/dataset/MovementAAL_RSS_2.csv')</span><span id="a05d" class="lt jn hi lp b fi ly lv l lw lx">df1.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lz"><img src="../Images/719dcdab110e48669e735398e54ab4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/0*tWVIxwHqEil9MDxh.png"/></div></figure><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="fbaf" class="lt jn hi lp b fi lu lv l lw lx">df2.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/77c0108f4ae81785e6c44754336f9453.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*VsjajJvuT-Tkkq9n.png"/></div></figure><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="4e1b" class="lt jn hi lp b fi lu lv l lw lx">df1.shape, df2.shape</span><span id="96fd" class="lt jn hi lp b fi ly lv l lw lx">((27, 4), (26, 4))</span></pre><p id="95fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些文件包含来自四个传感器(A1、A2、A3和A4)的标准化数据。csv文件的长度(行数)各不相同，因为对应于每个csv的数据持续时间不同。为了简化，让我们假设每秒收集传感器数据。第一次读数持续时间为27秒(即27行)，而另一次读数持续时间为26秒(即26行)。</p><p id="292d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们建立模型之前，我们必须处理这个变化的长度。现在，我们将使用以下代码块读取传感器的值并将其存储在一个列表中:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="7ac1" class="lt jn hi lp b fi lu lv l lw lx">path = 'MovementAAL/dataset/MovementAAL_RSS_'<br/>sequences = list()<br/>for i in range(1,315):<br/>    file_path = path + str(i) + '.csv'<br/>    print(file_path)<br/>    df = pd.read_csv(file_path, header=0)<br/>    values = df.values<br/>    sequences.append(values)</span><span id="65fb" class="lt jn hi lp b fi ly lv l lw lx">targets = pd.read_csv('MovementAAL/dataset/MovementAAL_target.csv') <br/>targets = targets.values[:,1]</span></pre><p id="d8aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在有一个列表<em class="le">序列</em>，其中包含来自运动传感器的数据和保存csv文件标签的“目标”。当我们打印<em class="le">序列[0] </em>时，我们从第一个csv文件中获取传感器的值:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="0414" class="lt jn hi lp b fi lu lv l lw lx">sequences[0]</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mb"><img src="../Images/1f9beb6aeacbe288138cd048b30d87b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*Mx__R3G8XJArCRCR.png"/></div></div></figure><p id="5bbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，数据集是在三对不同的房间中收集的，因此分为三组。此信息可用于将数据集划分为训练集、测试集和验证集。我们现在将加载<strong class="ih hj"><em class="le">dataset group</em></strong>CSV文件:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="9823" class="lt jn hi lp b fi lu lv l lw lx">groups = pd.read_csv('MovementAAL/groups/MovementAAL_DatasetGroup.csv', header=0) <br/>groups = groups.values[:,1]</span></pre><p id="082b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将采用前两组数据进行训练，第三组数据进行测试。</p><h1 id="af87" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">预处理步骤</h1><p id="d5a5" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">由于时间序列数据的长度是可变的，我们不能直接在这个数据集上建立模型。那么如何才能决定一个系列的理想长度呢？我们可以用多种方式来处理它，这里有一些想法(我很乐意在评论区听到你的建议):</p><ul class=""><li id="c339" class="kk kl hi ih b ii ij im in iq lk iu ll iy lm jc ln ks kt ku bi translated">用零填充较短的序列，使所有序列的长度相等。在这种情况下，我们将向模型输入不正确的数据</li><li id="de57" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc ln ks kt ku bi translated">找出序列的最大长度，并用最后一行的数据填充序列</li><li id="c22c" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc ln ks kt ku bi translated">确定数据集中序列的最小长度，并将所有其他序列截断到该长度。但是，这将导致大量数据丢失</li><li id="2136" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc ln ks kt ku bi translated">取所有长度的平均值，截断较长的序列，填充比平均长度短的序列</li></ul><p id="4841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们找出最小、最大和平均长度:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="424e" class="lt jn hi lp b fi lu lv l lw lx">len_sequences = []<br/>for one_seq in sequences:<br/>    len_sequences.append(len(one_seq))<br/>pd.Series(len_sequences).describe()</span><span id="2c24" class="lt jn hi lp b fi ly lv l lw lx">count    314.000000<br/>mean      42.028662<br/>std       16.185303<br/>min       19.000000<br/>25%       26.000000<br/>50%       41.000000<br/>75%       56.000000<br/>max      129.000000<br/>dtype: float64</span></pre><p id="25e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数文件的长度在40到60之间。只有3个文件的长度超过了100。因此，取最小或最大长度没有多大意义。第90个四分位数是60，这是数据序列的长度。让我们把它编码出来:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="a5e6" class="lt jn hi lp b fi lu lv l lw lx">#Padding the sequence with the values in last row to max length<br/>to_pad = 129<br/>new_seq = []<br/>for one_seq in sequences:<br/>    len_one_seq = len(one_seq)<br/>    last_val = one_seq[-1]<br/>    n = to_pad - len_one_seq<br/>   <br/>    to_concat = np.repeat(one_seq[-1], n).reshape(4, n).transpose()<br/>    new_one_seq = np.concatenate([one_seq, to_concat])<br/>    new_seq.append(new_one_seq)<br/>final_seq = np.stack(new_seq)<br/><br/>#truncate the sequence to length 60<br/>from keras.preprocessing import sequence<br/>seq_len = 60<br/>final_seq=sequence.pad_sequences(final_seq, maxlen=seq_len, padding='post', dtype='float', truncating='post')</span></pre><p id="0022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然数据集已经准备好了，我们将根据组对其进行分离。准备训练、验证和测试集:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="132c" class="lt jn hi lp b fi lu lv l lw lx">train = [final_seq[i] for i in range(len(groups)) if (groups[i]==2)]<br/>validation = [final_seq[i] for i in range(len(groups)) if groups[i]==1]<br/>test = [final_seq[i] for i in range(len(groups)) if groups[i]==3]<br/><br/>train_target = [targets[i] for i in range(len(groups)) if (groups[i]==2)]<br/>validation_target = [targets[i] for i in range(len(groups)) if groups[i]==1]<br/>test_target = [targets[i] for i in range(len(groups)) if groups[i]==3]</span><span id="2aed" class="lt jn hi lp b fi ly lv l lw lx">train = np.array(train)<br/>validation = np.array(validation)<br/>test = np.array(test)<br/><br/>train_target = np.array(train_target)<br/>train_target = (train_target+1)/2<br/><br/>validation_target = np.array(validation_target)<br/>validation_target = (validation_target+1)/2<br/><br/>test_target = np.array(test_target)<br/>test_target = (test_target+1)/2</span></pre><h1 id="6d48" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">建立时间序列分类模型</h1><p id="cb2d" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们已经准备好了用于LSTM(长短期记忆)模型的数据。我们处理了可变长度序列，并创建了训练、验证和测试集。让我们建立一个单层LSTM网络。</p><p id="b052" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="le">注:可以在本期</em> <a class="ae jl" href="https://www.analyticsvidhya.com/blog/2017/12/fundamentals-of-deep-learning-introduction-to-lstm/" rel="noopener ugc nofollow" target="_blank"> <em class="le">精彩讲解教程</em> </a> <em class="le">中结识LSTMs。我建议你先浏览一遍，因为这会帮助你理解下面的代码是如何工作的。</em></p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="9ca8" class="lt jn hi lp b fi lu lv l lw lx">model = Sequential()<br/>model.add(LSTM(256, input_shape=(seq_len, 4)))<br/>model.add(Dense(1, activation='sigmoid'))</span><span id="74f0" class="lt jn hi lp b fi ly lv l lw lx">model.summary()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/91377523cfb53d162009379c40628ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*sisq0hQIolKtUia5.png"/></div></figure><p id="d6df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将训练模型并监控验证准确性:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="90cf" class="lt jn hi lp b fi lu lv l lw lx">adam = Adam(lr=0.001)<br/>chk = ModelCheckpoint('best_model.pkl', monitor='val_acc', save_best_only=True, mode='max', verbose=1)<br/>model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['accuracy'])<br/>model.fit(train, train_target, epochs=200, batch_size=128, callbacks=[chk], validation_data=(validation,validation_target))</span><span id="007a" class="lt jn hi lp b fi ly lv l lw lx">#loading the model and checking accuracy on the test data<br/>model = load_model('best_model.pkl')<br/><br/>from sklearn.metrics import accuracy_score<br/>test_preds = model.predict_classes(test)<br/>accuracy_score(test_target, test_preds)</span></pre><p id="1f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我得到了0.78846153846153844的准确率。这是一个非常有希望的开始，但我们肯定可以通过调整超参数、改变学习率和/或时期数来提高LSTM模型的性能。</p><h1 id="2518" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">结束注释</h1><p id="67a2" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">这就导致了本教程的结束。写这本书背后的想法是以一种实用的方式向你介绍一个全新的时间序列世界。</p><p id="34ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我发现预处理步骤是我们讨论的所有步骤中最复杂的部分。然而，这也是最重要的一点(否则整个时间序列数据将会失败！).在处理这类挑战时，为模型提供正确的数据同样重要。</p><p id="753e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个非常酷的时间序列分类资源，我参考了一下，发现它非常有用:</p><ul class=""><li id="f44b" class="kk kl hi ih b ii ij im in iq lk iu ll iy lm jc ln ks kt ku bi translated">关于“通过水库计算预测异质室内环境中的用户运动”的论文</li></ul><p id="1270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很乐意在下面的评论区听到你的想法和建议。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="7b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="le">原载于2019年1月7日</em><a class="ae jl" href="https://www.analyticsvidhya.com/blog/2019/01/introduction-time-series-classification/" rel="noopener ugc nofollow" target="_blank"><em class="le">www.analyticsvidhya.com</em></a><em class="le">。</em></p></div></div>    
</body>
</html>