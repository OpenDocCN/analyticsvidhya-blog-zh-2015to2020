<html>
<head>
<title>Emotion Analysis with building an Artificial Neural Network using ML.NET with Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于张量流 ML.NET 构建人工神经网络的情感分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/emotion-analysis-with-building-an-artificial-neural-network-using-ml-net-powered-by-tensorflow-dd08aeb9aad7?source=collection_archive---------4-----------------------#2020-12-11">https://medium.com/analytics-vidhya/emotion-analysis-with-building-an-artificial-neural-network-using-ml-net-powered-by-tensorflow-dd08aeb9aad7?source=collection_archive---------4-----------------------#2020-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b6fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习和人工智能是信息技术的新亮点。微软作为其最大的市场份额之一，终于在 2018 年 5 月宣布援助 ML.NET。Net 开发人员来实现他们的目标。但是与 Python、Java、LISP 等其他技术相比，它还是相当新的。就开源项目、库或第三方工具而言，还没有足够的资源。还有很长的路要走。Net 赶上其他大的技术公司来发展它的社区</p><p id="26bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，我们不必等到这种情况发生，感谢微软的工程师，他们使 ML.NET 获得了自适应的开发体验，并在与 NimbusML 一起使用时支持<a class="ae jd" href="https://en.wikipedia.org/wiki/Python_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Python </a>模型。<br/>我们都应该感谢微软的惊人工作！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9ca4f23c9296275e5e6e4332f1c8351d.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/1*FWFN3hFVYuuIB2CQSpdZBg.gif"/></div></div></figure><p id="da6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些人更喜欢看而不是读，也制作一个视频来演示这种东西在行动中往往是有意义的，正因为如此，下面的视频的存在。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="6d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的项目中，我们将使用现有的预训练 Tensorflow 模型，该模型由具有数千幅图像的神经网络构建，并驻留在谷歌的一个服务器中，并利用<strong class="ih hj"> </strong> <a class="ae jd" href="https://en.wikipedia.org/wiki/Deep_learning" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">深度学习</strong> </a>来构建我们自己的神经网络，以提高我们的准确性并加快训练过程。我将创建一个. Net 核心控制台应用程序来实现这一点，当文章结束时，我们将有一个跨平台的可执行应用程序。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es js"><img src="../Images/c2a254f10c6db95dc7aa58dcef6158cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZ_u3dMeTqh31q2pN9GNQQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">上图展示了 ML.NET 应用程序的拓扑结构</figcaption></figure><p id="213d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我说，这篇文章受到了微软官方文档的强烈启发。说得够多了，让我们开始行动吧。</p><p id="bd41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经更改了输入数据集并包含了帮助器方法，<br/>最后，为了准确起见，通过重新格式化和灰度化每个图像来标准化模型，下面是一些例子；</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jx"><img src="../Images/fc1448066b8d2c3be7b75aa114266152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9rHxs6184R3mRojdmBK_g.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jy"><img src="../Images/ad9557f304462f228c8a54bf1bd693b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSMBUAS86qRllwvaS0aaEA.png"/></div></div></figure><p id="49a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种编辑是如此简单，由于。Net 核心的图像处理库。绘图命名空间，我们所做的只是首先调整图像大小为 48x48，然后转换为灰度。下面这些代码优雅地满足了我们的需求；</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="d94d" class="ke kf hi ka b fi kg kh l ki kj">public static Bitmap TranformToGrayscale(Bitmap original)<br/>        {<br/>            //create a blank bitmap the same size as original<br/>            Bitmap newBitmap = new Bitmap(original.Width, original.Height);</span><span id="8e20" class="ke kf hi ka b fi kk kh l ki kj">//get a graphics object from the new image<br/>            using (Graphics g = Graphics.FromImage(newBitmap))<br/>            {<br/>                //create the grayscale ColorMatrix<br/>                System.Drawing.Imaging.ColorMatrix colorMatrix = new System.Drawing.Imaging.ColorMatrix(<br/>                   new float[][]<br/>                   {<br/>             new float[] {.3f, .3f, .3f, 0, 0},<br/>             new float[] {.59f, .59f, .59f, 0, 0},<br/>             new float[] {.11f, .11f, .11f, 0, 0},<br/>             new float[] {0, 0, 0, 1, 0},<br/>             new float[] {0, 0, 0, 0, 1}<br/>                   });</span><span id="232d" class="ke kf hi ka b fi kk kh l ki kj">//create some image attributes<br/>                using (ImageAttributes attributes = new ImageAttributes())<br/>                {<br/>                    //set the color matrix attribute<br/>                    attributes.SetColorMatrix(colorMatrix);</span><span id="7594" class="ke kf hi ka b fi kk kh l ki kj">//draw the original image on the new image<br/>                    //using the grayscale color matrix<br/>                    g.DrawImage(original, new System.Drawing.Rectangle(0, 0, original.Width, original.Height),<br/>                                0, 0, original.Width, original.Height, GraphicsUnit.Pixel, attributes);<br/>                }<br/>            }<br/>            return newBitmap;<br/>        }</span><span id="dcca" class="ke kf hi ka b fi kk kh l ki kj">public static Bitmap ResizeImage(System.Drawing.Image image, int width, int height)<br/>        {<br/>            var destRect = new System.Drawing.Rectangle(0, 0, width, height);<br/>            var destImage = new Bitmap(width, height);</span><span id="5381" class="ke kf hi ka b fi kk kh l ki kj">destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);</span><span id="3c95" class="ke kf hi ka b fi kk kh l ki kj">using (var graphics = Graphics.FromImage(destImage))<br/>            {<br/>                graphics.CompositingMode = CompositingMode.SourceCopy;<br/>                graphics.CompositingQuality = CompositingQuality.HighQuality;<br/>                graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;<br/>                graphics.SmoothingMode = SmoothingMode.HighQuality;<br/>                graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;</span><span id="e644" class="ke kf hi ka b fi kk kh l ki kj">using (var wrapMode = new ImageAttributes())<br/>                {<br/>                    wrapMode.SetWrapMode(WrapMode.TileFlipXY);<br/>                    graphics.DrawImage(image, destRect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, wrapMode);<br/>                }<br/>            }</span><span id="b1fc" class="ke kf hi ka b fi kk kh l ki kj">return destImage;<br/>        }To improve the accuracy of our model we standardize images as greyscaled and 48x48 length no matter the size of the original image</span></pre><p id="8d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以消除数据中的噪声，加快训练过程，并更快地执行预测。</p><p id="9b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将遵循以下步骤来实现它:</p><h1 id="a714" class="kl kf hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">1.建立模型</h1><p id="c806" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">构建模型包括以下步骤:</p><ul class=""><li id="38fa" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated">从初始数据视图的文件夹中加载图像路径和相关标签</li><li id="4792" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">根据使用的 TensorFlow 预训练模型(如 InceptionV3)的需要进行变换时，将图像加载到内存中。(根据所使用的深度神经网络的要求，调整像素值的大小并使其正常化)</li><li id="fb98" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">图像<em class="mb">使用深度神经网络模型的特征化</em></li><li id="9d19" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">基于 LbfgsMaximumEntropy 的图像分类</li></ul><p id="eee0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不是:你可以访问预先训练好的 Tensorflow 模型的数据库<a class="ae jd" href="https://www.tensorflow.org/resources/models-datasets" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="8b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在类类型中定义数据的模式，并在使用 TextLoader 加载数据时引用该类型。这里的类类型是 ImageNetData。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="153e" class="ke kf hi ka b fi kg kh l ki kj">public class ImageData<br/>    {<br/>        [LoadColumn(0)]<br/>        public string ImagePath;</span><span id="9b19" class="ke kf hi ka b fi kk kh l ki kj">        [LoadColumn(1)]<br/>        public string Label;<br/>    }</span></pre><p id="6191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过 LoadImagesFromDirectory()使用实用方法将所有训练和测试图像分别加载到数据视图中:</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="4660" class="ke kf hi ka b fi kg kh l ki kj">IEnumerable&lt;ImageData&gt; allImages = LoadImagesFromDirectory(folder: imagesDownloadFolderPath, useFolderNameasLabel: true);</span><span id="95a4" class="ke kf hi ka b fi kk kh l ki kj">IEnumerable&lt;ImageData&gt; testImages = LoadImagesFromDirectory(folder: testimagesDownloadFolderPath);</span></pre><p id="cc37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将数据集拆分为两个数据集(训练数据集和测试数据集)之前，对图像进行混洗，以便通过标注分类更好地平衡数据集。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="6cf3" class="ke kf hi ka b fi kg kh l ki kj">ConsoleHelper.ConsoleWriteHeader("Read model");<br/>Console.WriteLine($"Model location: {inputTensorFlowModelFilePath}");<br/>Console.WriteLine($"Training file: {dataLocation}");</span><span id="fcb3" class="ke kf hi ka b fi kk kh l ki kj">// 1. Load images information (filenames and labels) in IDataView</span><span id="0883" class="ke kf hi ka b fi kk kh l ki kj">//Load the initial single full Image-Set<br/>IDataView fullImagesDataset = mlContext.Data.LoadFromEnumerable(imageSet);<br/>IDataView trainDataView = mlContext.Data.ShuffleRows(fullImagesDataset);<br/>IDataView testDataView = mlContext.Data.LoadFromEnumerable(testSet);</span></pre><p id="f908" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下步骤定义了培训管道。通常，在处理深度神经网络时，您必须使图像适应网络预期的格式。这就是图像被调整大小然后变换的原因。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="3041" class="ke kf hi ka b fi kg kh l ki kj">// 2. Load images in-memory while applying image transformations <br/>// Input and output column names have to coincide with the input and output tensor names of the TensorFlow model<br/>// You can check out those tensor names by opening the Tensorflow .pb model with a visual tool like Netron: <a class="ae jd" href="https://github.com/lutzroeder/netron" rel="noopener ugc nofollow" target="_blank">https://github.com/lutzroeder/netron</a><br/>// TF .pb model --&gt; input node --&gt; INPUTS --&gt; input --&gt; id: "input" <br/>// TF .pb model --&gt; Softmax node --&gt; INPUTS --&gt; logits --&gt; id: "softmax2_pre_activation" (Inceptionv1) or "InceptionV3/Predictions/Reshape" (Inception v3)</span><span id="c185" class="ke kf hi ka b fi kk kh l ki kj">var dataProcessPipeline = mlContext.Transforms.Conversion.MapValueToKey(outputColumnName: LabelAsKey, inputColumnName: "Label")<br/>                .Append(mlContext.Transforms.LoadImages(outputColumnName: "image_object", imageFolder: imagesFolder, inputColumnName: nameof(DataModels.ImageData.ImagePath)))<br/>                .Append(mlContext.Transforms.ResizeImages(outputColumnName: "image_object_resized", <br/>                                                            imageWidth: ImageSettingsForTFModel.imageWidth, imageHeight: ImageSettingsForTFModel.imageHeight, <br/>                                                            inputColumnName: "image_object"))<br/>                .Append(mlContext.Transforms.ExtractPixels(outputColumnName:"input", inputColumnName:"image_object_resized", <br/>                                                            interleavePixelColors:ImageSettingsForTFModel.channelsLast, <br/>                                                            offsetImage:ImageSettingsForTFModel.mean, <br/>                                                            scaleImage:ImageSettingsForTFModel.scale))  //for Inception v3 needs scaleImage: set to 1/255f. Not needed for InceptionV1. <br/>                .Append(mlContext.Model.LoadTensorFlowModel(inputTensorFlowModelFilePath).<br/>                        ScoreTensorFlowModel(outputColumnNames: new[] { "InceptionV3/Predictions/Reshape" }, <br/>                                            inputColumnNames: new[] { "input" }, <br/>                                            addBatchDimensionInput: false));  // (For Inception v1 --&gt; addBatchDimensionInput: true)  (For Inception v3 --&gt; addBatchDimensionInput: false)</span></pre><p id="d17d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，添加 ML.NET 分级培训师(LbfgsMaximumEntropy)以最终确定培训渠道:</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="e3cb" class="ke kf hi ka b fi kg kh l ki kj">// Set the training algorithm and convert back the key to the categorical values (original labels)                            <br/>var trainer = mlContext.MulticlassClassification.Trainers.LbfgsMaximumEntropy(labelColumnName: LabelAsKey, featureColumnName: "InceptionV3/Predictions/Reshape");  //"softmax2_pre_activation" for Inception v1<br/>var trainingPipeline = dataProcessPipeline.Append(trainer)<br/>                                            .Append(mlContext.Transforms.Conversion.MapKeyToValue(PredictedLabelValue, "PredictedLabel"));</span></pre><h1 id="d1da" class="kl kf hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">2.火车模型</h1><p id="061a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">为了开始培训，在已建管道上执行<code class="du mc md me ka b">Fit</code>:</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="d6d0" class="ke kf hi ka b fi kg kh l ki kj">ITransformer model = trainingPipeline.Fit(trainingDataView);</span></pre><h1 id="b6f2" class="kl kf hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">3.评估模型</h1><p id="b43f" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">训练结束后，我们使用训练数据对模型进行评估。<code class="du mc md me ka b">Evaluate</code>函数需要一个<code class="du mc md me ka b">IDataView</code>作为参数，它包含使用测试数据集分割的所有预测，所以我们将<code class="du mc md me ka b">Transform</code>应用于模型，然后取<code class="du mc md me ka b">AsDynamic</code>值。</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="fd14" class="ke kf hi ka b fi kg kh l ki kj">// Make bulk predictions and calculate quality metrics<br/>ConsoleWriteHeader("Create Predictions and Evaluate the model quality");<br/>IDataView predictionsDataView = model.Transform(testDataView);<br/>           <br/>// Show the performance metrics for the multi-class classification            <br/>var classificationContext = mlContext.MulticlassClassification;<br/>var metrics = classificationContext.Evaluate(predictionsDataView, labelColumnName: LabelAsKey, predictedLabelColumnName: "PredictedLabel");<br/>ConsoleHelper.PrintMultiClassClassificationMetrics(trainer.ToString(), metrics);</span></pre><p id="355f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们保存模型:</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="8c67" class="ke kf hi ka b fi kg kh l ki kj">mlContext.Model.Save(model, predictionsDataView.Schema, outputMlNetModelFilePath);</span></pre><h2 id="d93a" class="ke kf hi bd km mf mg mh kq mi mj mk ku iq ml mm ky iu mn mo lc iy mp mq lg mr bi translated">运行应用程序来训练模型</h2><p id="1dc1" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">为了训练您的模型，您应该按照以下步骤进行:</p><ol class=""><li id="383a" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ms lt lu lv bi translated">在 Visual Studio 中将<code class="du mc md me ka b">ImageClassification.Train</code>设置为启动项目</li><li id="8470" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ms lt lu lv bi translated">在 Visual Studio 中按 F5。训练过程将开始，并会花费或多或少的时间，这取决于您训练的图像数量。</li><li id="5b7e" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ms lt lu lv bi translated">训练过程完成后，为了使用新的训练模型更新消费应用程序，您必须复制/粘贴生成的 ML.NET 模型文件(assets/inputs/image classifier . zip)并将其粘贴到消费应用程序项目(assets/inputs/MLNETModel)中，该项目模拟仅运行模型进行预测的最终用户应用程序。</li></ol><h1 id="5d2a" class="kl kf hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">4.模型消耗代码</h1><p id="382c" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">首先，您需要加载在模型训练期间创建的模型</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="5083" class="ke kf hi ka b fi kg kh l ki kj">ITransformer loadedModel = mlContext.Model.Load(modelLocation,out var modelInputSchema);</span></pre><p id="ab08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，创建一个预测器引擎，并进行示例预测:</p><pre class="jf jg jh ji fd jz ka kb kc aw kd bi"><span id="75a1" class="ke kf hi ka b fi kg kh l ki kj">var predictionEngine = mlContext.Model.CreatePredictionEngine&lt;ImageData, ImagePrediction&gt;(loadedModel);</span><span id="e4be" class="ke kf hi ka b fi kk kh l ki kj">IEnumerable&lt;ImageData&gt; imagesToPredict = LoadImagesFromDirectory(imagesFolder, true);</span><span id="1bae" class="ke kf hi ka b fi kk kh l ki kj">//Predict the first image in the folder<br/>//<br/>ImageData imageToPredict = new ImageData<br/>{<br/>    ImagePath = imagesToPredict.First().ImagePath<br/>};</span><span id="b6ba" class="ke kf hi ka b fi kk kh l ki kj">var prediction = predictionEngine.Predict(imageToPredict);</span><span id="9d4f" class="ke kf hi ka b fi kk kh l ki kj">Console.WriteLine("");<br/>Console.WriteLine($"ImageFile : [{Path.GetFileName(imageToPredict.ImagePath)}], " +<br/>                    $"Scores : [{string.Join(",", prediction.Score)}], " +<br/>                    $"Predicted Label : {prediction.PredictedLabelValue}");</span></pre><p id="e59e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测引擎接收类型为<code class="du mc md me ka b">ImageData</code>的对象作为参数(包含两个属性:<code class="du mc md me ka b">ImagePath</code>和<code class="du mc md me ka b">Label</code>)。然后返回一个类型为<code class="du mc md me ka b">ImagePrediction</code>的对象，它保存了<code class="du mc md me ka b">PredictedLabel</code>和<code class="du mc md me ka b">Score</code> ( <em class="mb">概率</em>值在 0 和 1 之间)属性。</p><p id="8992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们运行应用程序并检查我们的模型是如何工作的！顺便说一下，对于这次执行，我不会重新格式化测试图像，将它们按其原始形状推送到训练管道，之后我将重新开始执行。</p><p id="8347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两种结果都出现在下面的图片中；</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mt"><img src="../Images/478e659a8724bd8c14c522cfa6ad9879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2SfowViaHzDrWhFs-mIPA.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">结果:1 个正确，3 个错误</figcaption></figure><p id="04c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面看到的，这并不像预期的那样好，我和宝宝还好，但帕克先生在这里感觉不到平静(蜘蛛侠电影中的场景，当他的父亲发生车祸，死在他面前，是的，应该是悲伤的！🤬)</p><p id="be3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更糟糕的是，我们的网络认为拜登在这里感到悲伤…我认为这不应该是你赢得选举并成为美国总统时的感受。</p><blockquote class="mu mv mw"><p id="76b1" class="if ig mb ih b ii ij ik il im in io ip mx ir is it my iv iw ix mz iz ja jb jc hb bi translated">所以很明显我们的模型有问题，我在互联网上搜索人工神经网络的原理和建立训练模型的最佳实践，最终得出了标准化所有图像的想法。我已经在上面提到了它是如何做到的，在文章的最后还有一个链接可以下载完整的源代码</p></blockquote><p id="1bcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们重新启动应用程序，这一次图像将在预测之前经过调整大小和灰度的处理</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es na"><img src="../Images/569af45f3b60b2b700e6bb78f93f4b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a82CJ78OR2LrvwQlXeDJ6w.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">结果:3 个正确，1 个错误</figcaption></figure><p id="1c4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，<a class="ae jd" href="https://www.ijsr.net/archive/v6i3/25031706.pdf" rel="noopener ugc nofollow" target="_blank">图像降噪</a>如何提高准确性和预测以及性能(它的运行速度几乎快了 4 倍！)的重要性。</p><p id="e363" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不想再看到这篇文章了，我们正处在一个结束的好时机。<br/>您可以下载完整的<a class="ae jd" href="https://github.com/y3n3rrr/EmotionAnalysisWithMLNET" rel="noopener ugc nofollow" target="_blank">源代码</a>并尝试使用您自己的定制图像，它几乎可以发布用于生产环境，但如果您希望更准确地进行更好的预测，我强烈建议您使用训练有素的模型</p><p id="07dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我正在思考的问题，我想用我最近找到的训练集写一篇新文章。来自 Kaggle 的这个样本包含数以千计的图像，可以用来训练神经网络。这篇不错的<a class="ae jd" rel="noopener" href="/@jsflo.dev/training-a-tensorflow-model-to-recognize-emotions-a20c3bcd6468">文章</a>也涵盖了它。您可以跟进基于 python 的工作，或者等我来处理，在内部重新创建它。Net 核心的方法。网</p><p id="676a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，我对你的想法持开放态度，我很乐意知道你希望我为一篇新文章选择什么主题，只要它是一个游乐场。网络核心和反应⚛️.你可以在下面的版块发表评论，或者在<a class="ae jd" href="https://www.linkedin.com/in/mehmet-yener-yilmaz-833a07101/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae jd" href="https://twitter.com/myeneryilmaz" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上发送消息</p><p id="7115" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未完待续…</p><p id="59d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回见，<br/>穆罕默德·耶纳尔·耶尔马兹</p></div></div>    
</body>
</html>