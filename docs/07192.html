<html>
<head>
<title>Coding Interview Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/coding-interview-question-c8f2520faf72?source=collection_archive---------22-----------------------#2020-06-16">https://medium.com/analytics-vidhya/coding-interview-question-c8f2520faf72?source=collection_archive---------22-----------------------#2020-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="828f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">常数时间O(1)中的堆栈操作</h1><p id="c82a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">去厨房吧。</p><p id="ce70" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你看到了什么？</p><p id="df84" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">盘子、碗、容器和小吃以及更多美味佳肴。</p><p id="19b5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">仔细看。</p><p id="2734" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你也可能会看到这样的东西。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/ad6cd2866c5287c2771ea19958e07095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/0*K_npF4IltBqkhY_a"/></div></figure><p id="b5f9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">认出那些叠在一起的盘子了吗？</p><p id="01fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这正是堆栈概念的来源。</p><p id="3592" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">想想你能用这么一堆盘子做些什么。</p><p id="0d1a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可以在上面放一个新的盘子，也可以取下上面的盘子。</p><p id="1329" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你想把盘子放在底部，你必须先把上面的盘子都拿走。</p><p id="62c5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种安排被称为“后进先出”——放在最后的物品是第一个出去的。</p><h1 id="6a72" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">堆栈编程术语</strong></h1><p id="599f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">用计算机的语言来说，把一个项目放在栈顶叫做“push”，把一个项目移走叫做“pop”。</p><p id="5d13" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">堆栈是一个对象，或者更具体地说是一个抽象数据结构(ADT ),它允许下列操作:</p><ol class=""><li id="800c" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka kt ku kv kw bi translated">推送:将一个元素添加到堆栈的顶部</li></ol><p id="1365" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.Pop:从堆栈顶部删除一个元素</p><p id="b1e1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3.IsEmpty:检查堆栈是否为空</p><p id="491b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">4.IsFull:检查堆栈是否已满</p><p id="9a37" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">5.Peek:获取顶部元素的值，而不删除它。</p><p id="950e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">不用说，最顶层的元素叫做top()</p><p id="765a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以通过使用称为数组和/或链表的具体数据类型来实现堆栈。它们是线性数据结构。它们之间的区别与内存分配有关。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kx"><img src="../Images/6f1cec1091eb63cf667f1f115166af31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*05NVWYvbRLhys935"/></div></figure><p id="b71a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，这里的挑战是在O(1)时间内执行以下操作:</p><ul class=""><li id="0f49" class="ko kp hi jf b jg kb jk kc jo kq js kr jw ks ka ky ku kv kw bi translated">推(x)</li><li id="7ca1" class="ko kp hi jf b jg kz jk la jo lb js lc jw ld ka ky ku kv kw bi translated">流行()</li><li id="2200" class="ko kp hi jf b jg kz jk la jo lb js lc jw ld ka ky ku kv kw bi translated">顶部()</li><li id="b49c" class="ko kp hi jf b jg kz jk la jo lb js lc jw ld ka ky ku kv kw bi translated">getMin()</li></ul><p id="7800" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里我们的主要竞争者将是getMin()操作。</p><p id="fb6b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，存储整体最小值听起来是个好主意。但是一旦我们弹出一个元素，我们如何在O(1)时间内再次找到最小值？</p><p id="dd26" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们看看这个例子</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/1620facb539597ca663e5b2facb2adea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/0*cv1HcI6wbgMzkHul"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">堆栈A</figcaption></figure><p id="f417" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第三点</p><p id="77fc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们这里的最小值是3。</p><p id="b435" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是，如果我们弹出3，我们的最小值转移到5。</p><p id="d228" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果我们弹出5，我们的最小值应该是8。</p><p id="84d1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们如何实时地进行这项工作呢？</p><p id="677d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们能做的是:</p><p id="675d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以复制这个堆栈，得到另一个堆栈B，除了。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/1a5fa22055a5da7ba208a6419fbdc552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/0*vfawh2YRvfzNVbsx"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">堆栈B</figcaption></figure><p id="a339" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">每当你在新的栈中插入一个元素时，你就插入了前一个栈中的最小值。</p><p id="139c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，最初您将插入19，因为它是唯一的元素，然后比较8和19，</p><p id="4e86" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">8是最小值，因此堆栈B的第二个元素应该是8。</p><p id="56e7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在第三个元素是23，比较这三个元素，8是最小值，因此8再次被插入堆栈B。</p><p id="9a89" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">同样，插入5和3。</p><p id="bc62" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以，现在你可以看到第二个堆栈在O(1)时间内告诉我们堆栈A中的当前最小数。</p><p id="2dbf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">栈顶B指向栈a中当前最小的元素。</p><p id="03d5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，通过使用空间和时间的权衡，我们实际上使用了更多的空间，但我们能够在O(1)时间内解决整个问题。</p><p id="be3b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面给出了使用C++的代码实现:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ln"><img src="../Images/8bb95dca841d6827811ff81ae2a7dc31.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/0*Cr3826SbdAdcBV-y"/></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lo"><img src="../Images/be173b32206c92297e176c6a8f61fad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/0*5pJ30R8z6gxG9snx"/></div></figure><p id="6526" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以在此处获得代码:</p><div class="lp lq ez fb lr ls"><a href="https://github.com/Shreya869/get_min-Stack-in-O-1-/tree/master" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">shreya 869/get _ min-Stack-in-O-1-</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">恒定时间复杂度下的栈操作。为shreya 869/get _ min-Stack-in-O-1-开发做出贡献，创建一个…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">github.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg km ls"/></div></div></a></div><p id="d166" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">参考书目:</p><p id="4ce4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">更多参考，你可以看下面的视频，它帮助我把我的基本概念讲清楚。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>