<html>
<head>
<title>Building a face detector with OpenCV in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++中的OpenCV构建人脸检测器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-face-detector-with-opencv-in-c-8814cd374ea1?source=collection_archive---------8-----------------------#2020-08-08">https://medium.com/analytics-vidhya/building-a-face-detector-with-opencv-in-c-8814cd374ea1?source=collection_archive---------8-----------------------#2020-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c74877fab2baf31175de3586e48baba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e82tkWya3Glo0mZ6"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">奥米德·阿明在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f3cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博文中，我将解释如何用<a class="ae iu" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>中的机器学习组件构建人脸检测算法。我们将使用OpenCV从相机中读取图像并检测其中的人脸。结果会是这样的。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/50d637b2df3b0855170e08da3dd256b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*TmCkXXK1zADjM_2J.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">贝多芬脸色阴沉</figcaption></figure><p id="62be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在我的github 上找到这篇博文<a class="ae iu" href="https://github.com/bewagner/visuals/tree/blog-post-1" rel="noopener ugc nofollow" target="_blank">的所有代码。</a></p><h1 id="9ef7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">安装OpenCV</h1><p id="85c9" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们将使用OpenCV及其OpenCV_contrib模块的一些相当新的部分。确保您可以访问这些模块的最方便的方法是从源代码构建OpenCV。我在Ubuntu 16.04上用的是OpenCV 4 . 2 . 0版。为了方便起见，我包含了一个bash脚本，它负责安装正确的OpenCV版本。它还将安装所有必要的依赖项。脚本存在于GitHub repo 附带的<a class="ae iu" href="https://github.com/bewagner/visuals/tree/blog-post-1" rel="noopener ugc nofollow" target="_blank">中。</a></p><p id="ec50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用的<code class="du lb lc ld le b">cv::dnn::Net</code>类是在3.4.10版本中添加到OpenCV中的，所以早期版本可能也适用。但是，我没有测试这个。</p><h1 id="f74a" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">CMake设置</h1><p id="06af" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们将使用CMake构建我们的代码。为此，我们创建了一个带有单个可执行文件的CMake项目，并将C++标准设置为14。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="3501" class="lj jz hi le b fi lk ll l lm ln">cmake_minimum_required(VERSION 3.0) <br/>project(OpenCVFaceDetector LANGUAGES CXX)  </span><span id="b80b" class="lj jz hi le b fi lo ll l lm ln">add_executable(${PROJECT_NAME} main.cpp) target_compile_features(${PROJECT_NAME} PUBLIC cxx_std_14) target_include_directories(${PROJECT_NAME} PRIVATE include)</span></pre><p id="e282" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们处理OpenCV依赖性。我们找到<code class="du lb lc ld le b">OpenCV</code>包，并根据它链接我们的可执行文件。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="c3fc" class="lj jz hi le b fi lk ll l lm ln"># OpenCV setup <br/>find_package(OpenCV REQUIRED) <br/>target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS})</span></pre><p id="d98b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个<code class="du lb lc ld le b">CMakeLists.txt</code>文件应该是这样的。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="7292" class="lj jz hi le b fi lk ll l lm ln">cmake_minimum_required(VERSION 3.0) <br/>project(OpenCVFaceDetector LANGUAGES CXX)  <br/>add_executable(${PROJECT_NAME} main.cpp) target_compile_features(${PROJECT_NAME} PUBLIC cxx_std_14) target_include_directories(${PROJECT_NAME} PRIVATE include)  </span><span id="de67" class="lj jz hi le b fi lo ll l lm ln"># OpenCV setup find_package(OpenCV REQUIRED) target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS})</span></pre><h1 id="fe03" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从相机中获取图像</h1><p id="1d58" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们要做的第一件事是获取一个相机图像。幸运的是，<code class="du lb lc ld le b">cv::videocapture</code>类使这变得容易。</p><p id="25da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们包含了OpenCV头来访问OpenCV的功能。接下来，我们创建一个<code class="du lb lc ld le b">cv::videocapture</code>对象，并尝试打开我们能找到的第一个相机。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="b050" class="lj jz hi le b fi lk ll l lm ln">#include &lt;opencv4/opencv2/opencv.hpp&gt;  <br/>int main(int argc, char **argv) {<br/>      cv::VideoCapture video_capture;<br/>     if (!video_capture.open(0)) {<br/>         return 0;<br/>     }</span></pre><p id="6011" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，我们创建一个<code class="du lb lc ld le b">cv::Mat</code>来保存该帧，并在一个无限循环中显示它。如果用户按下“Esc ”,我们中断循环，破坏显示窗口并释放视频捕获。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="1943" class="lj jz hi le b fi lk ll l lm ln">cv::Mat frame;<br/>    while (true) {<br/>        video_capture &gt;&gt; frame;<br/><br/>        imshow("Image", frame);<br/>        const int esc_key = 27;<br/>        if (cv::waitKey(10) == esc_key) { <br/>            break;<br/>        }<br/>    }<br/><br/>    cv::destroyAllWindows();<br/>    video_capture.release();<br/><br/>    return 0;<br/>}</span></pre><p id="b66d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止,<code class="du lb lc ld le b">main.cpp</code>文件将如下所示。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="b269" class="lj jz hi le b fi lk ll l lm ln">#include &lt;opencv4/opencv2/opencv.hpp&gt;  <br/>int main(int argc, char **argv) {<br/>      cv::VideoCapture video_capture;<br/>     if (!video_capture.open(0)) {<br/>         return 0;<br/>     }</span><span id="ba6e" class="lj jz hi le b fi lo ll l lm ln">     cv::Mat frame;<br/>     while (true) {<br/>         video_capture &gt;&gt; frame;<br/>         imshow("Image", frame);<br/>         const int esc_key = 27;<br/>         if (cv::waitKey(10) == esc_key) {<br/>              break;<br/>         }<br/>     }<br/>     cv::destroyAllWindows();<br/>     video_capture.release();<br/>     return 0;<br/> }</span></pre><p id="39eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以显示从摄像机捕捉到的图像。😀</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/c5589e5eca8523bc286a32e0c86179b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*CaPznQYmWPVbHFl-.gif"/></div></figure><h1 id="4ca2" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用<code class="du lb lc ld le b">cv:dnn::Net</code>类加载预训练的SSD人脸检测网络</h1><p id="cd12" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">现在我们将开始建立一个面部检测器。我们使用<code class="du lb lc ld le b">cv::dnn::Net</code>类并从预训练的caffe模型中加载权重。</p><p id="efc6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为将所有功能放在一个地方很好，所以我们为模型创建了一个类<code class="du lb lc ld le b">FaceDetector</code>。所以首先，我们创建两个新文件<code class="du lb lc ld le b">src/FaceDetector.cpp</code>和<code class="du lb lc ld le b">include/FaceDetector.h</code>。为了确保我们的代码仍然可以构建，我们将实现文件添加到CMake目标中。也就是说，转到您的<code class="du lb lc ld le b">CMakeLists.txt</code>，将包含<code class="du lb lc ld le b">add_executable(...)</code>的行更改为如下所示</p><p id="4092" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lb lc ld le b">add_executable(${PROJECT_NAME} src/main.cpp src/FaceDetector.cpp)</code></p><p id="40f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du lb lc ld le b">include/FaceDetector.h</code>中，我们定义了这个类。该模型有一个构造函数，我们将在其中加载模型权重。此外，它还有一个方法</p><p id="5cab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lb lc ld le b">std::vector&lt;cv::Rect&gt; detect_face_rectangles(const cv::Mat &amp;frame)</code></p><p id="fd1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它接收一个输入图像，给我们一个检测到的人脸向量。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="72de" class="lj jz hi le b fi lk ll l lm ln">#ifndef VISUALS_FACEDETECTOR_H <br/>#define VISUALS_FACEDETECTOR_H <br/>#include &lt;opencv4/opencv2/dnn.hpp&gt;  <br/>class FaceDetector { <br/>public:     <br/>explicit FaceDetector();<br/>/// Detect faces in an image frame <br/>/// \param frame Image to detect faces in <br/>/// \return Vector of detected faces     <br/>std::vector&lt;cv::Rect&gt; detect_face_rectangles(const cv::Mat &amp;frame);</span></pre><p id="a652" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将实际的网络保存在私有成员变量中。除了模型，我们还将保存</p><ul class=""><li id="62eb" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><code class="du lb lc ld le b">input_image_width/height_</code>输入图像的尺寸</li><li id="b337" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><code class="du lb lc ld le b">scale_factor_</code>将图像转换为数据块时的缩放因子</li><li id="3cf3" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><code class="du lb lc ld le b">mean_values_</code>训练网络的每个通道的平均值。将图像转换为数据blob时，将从图像中减去这些值。</li><li id="be21" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><code class="du lb lc ld le b">confidence_threshold_</code>检测人脸时使用的置信度阈值。该模型将为每个检测到的面部提供置信度值。置信度值为&gt; = <code class="du lb lc ld le b">confidence_threshold_</code>的人脸将被保留。所有其他面都将被丢弃。</li></ul><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="cf6e" class="lj jz hi le b fi lk ll l lm ln">private:     <br/>/// Face detection network     <br/>cv::dnn::Net network_;     <br/>/// Input image width     <br/>const int input_image_width_;     <br/>/// Input image height     <br/>const int input_image_height_;     <br/>/// Scale factor when creating image blob     <br/>const double scale_factor_;     <br/>/// Mean normalization values network was trained with     <br/>const cv::Scalar mean_values_;     <br/>/// Face detection confidence threshold     <br/>const float confidence_threshold_;  <br/>};  <br/> <br/>#endif //VISUALS_FACEDETECTOR_H</span></pre><p id="a46d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的头文件在这里是<a class="ae iu" href="https://github.com/bewagner/visuals/blob/blog-post-1/include/FaceDetector.h" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b627" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们开始实现上面定义的函数。我们从构造函数开始。对于大多数成员变量，我们输入正确的值。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="1098" class="lj jz hi le b fi lk ll l lm ln">#include &lt;sstream&gt; <br/>#include &lt;vector&gt; <br/>#include &lt;string&gt; <br/>#include &lt;FaceDetector.h&gt; <br/>#include &lt;opencv4/opencv2/opencv.hpp&gt;  </span><span id="4d36" class="lj jz hi le b fi lo ll l lm ln">FaceDetector::FaceDetector() :<br/>     confidence_threshold_(0.5),<br/>     input_image_height_(300),<br/>     input_image_width_(300),<br/>     scale_factor_(1.0), <br/>     mean_values_({104., 177.0, 123.0}) {</span></pre><p id="1b1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构造函数内部，我们将使用<code class="du lb lc ld le b">cv::dnn::readNetFromCaffe</code>将模型加载到我们的<code class="du lb lc ld le b">network_</code>变量中。<code class="du lb lc ld le b">cv::dnn::readNetFromCaffe</code>需要两个文件来构建模型:第一个<a class="ae iu" href="https://github.com/bewagner/visuals/blob/blog-post-1/assets/deploy.prototxt" rel="noopener ugc nofollow" target="_blank"> (deploy.prototxt) </a>是描述模型架构的模型配置。第二个<a class="ae iu" href="https://github.com/bewagner/visuals/blob/blog-post-1/assets/res10_300x300_ssd_iter_140000_fp16.caffemodel" rel="noopener ugc nofollow" target="_blank">(res10 _ 300 x300 _ SSD _ ITER _ 140000 _ fp16 . caffemodel)</a>是模型权重的二进制数据。</p><p id="0f49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在构建后将这些文件移动到包含我们的二进制文件的目录中。但是这个解决方案是相当脆弱的，因为当二进制移动的时候它就崩溃了。因此，我们通过CMake传入文件位置。</p><h1 id="13d3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">快速跳回我们的CMake配置</h1><p id="2dec" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">在这篇StackOverflow文章中，我发现了一个传递文件路径给C++的好方法。他们建议将路径作为<code class="du lb lc ld le b">compile_definition</code>传递给目标。这样，CMake可以计算出文件的正确路径，并将其传递给一个变量。这个变量在C++中是可用的。</p><p id="5e83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也就是说，我们将下面几行添加到CMakeLists.txt中。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="b502" class="lj jz hi le b fi lk ll l lm ln"># Introduce preprocessor variables to keep paths of asset files set(FACE_DETECTION_CONFIGURATION<br/> "${PROJECT_SOURCE_DIR}/assets/deploy.prototxt")</span><span id="a1ce" class="lj jz hi le b fi lo ll l lm ln">set(FACE_DETECTION_WEIGHTS<br/> "${PROJECT_SOURCE_DIR}/assets/res10_300x300_ssd_iter_140000_fp16.caffemodel")  </span><span id="0f82" class="lj jz hi le b fi lo ll l lm ln">target_compile_definitions(${PROJECT_NAME} PRIVATE  FACE_DETECTION_CONFIGURATION="${FACE_DETECTION_CONFIGURATION}")  </span><span id="edef" class="lj jz hi le b fi lo ll l lm ln">target_compile_definitions(${PROJECT_NAME} PRIVATE  FACE_DETECTION_WEIGHTS="${FACE_DETECTION_WEIGHTS}")</span></pre><h1 id="fdb7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">整理<code class="du lb lc ld le b">FaceDetector.cpp</code>中的方法</h1><p id="b808" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">既然我们找到了访问必要文件的方法，我们就可以构建模型了。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="873f" class="lj jz hi le b fi lk ll l lm ln">FaceDetector::FaceDetector() :<br/>     confidence_threshold_(0.5),<br/>      input_image_height_(300),<br/>      input_image_width_(300),<br/>     scale_factor_(1.0),<br/>     mean_values_({104., 177.0, 123.0}) {<br/>         // Note: The variables MODEL_CONFIGURATION_FILE<br/>         // and MODEL_WEIGHTS_FILE are passed in via cmake<br/>         network_ = cv::dnn::readNetFromCaffe(FACE_DETECTION_CONFIGURATION,<br/>                 FACE_DETECTION_WEIGHTS);<br/>      if (network_.empty()) {<br/>         std::ostringstream ss;<br/>         ss &lt;&lt; "Failed to load network with the following settings:\n"<br/>            &lt;&lt; "Configuration: " + std::string(FACE_DETECTION_CONFIGURATION) + "\n"            <br/>            &lt;&lt; "Binary: " + std::string(FACE_DETECTION_WEIGHTS) + "\n";<br/>         throw std::invalid_argument(ss.str());<br/>     }</span></pre><p id="8862" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来就是实施<code class="du lb lc ld le b">detect_face_rectangles</code>。我们首先将输入图像转换成数据块。函数<code class="du lb lc ld le b"><a class="ae iu" href="https://www.pyimagesearch.com/2017/11/06/deep-learning-opencvs-blobfromimage-works/" rel="noopener ugc nofollow" target="_blank">cv::dnn::blobFromImage</a></code>负责将图像重新缩放到网络的正确输入尺寸。它还会减去每个颜色通道中的平均值。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="5c36" class="lj jz hi le b fi lk ll l lm ln">std::vector&lt;cv::Rect&gt; FaceDetector::detect_face_rectangles(const cv::Mat &amp;frame) {<br/>     cv::Mat input_blob = cv::dnn::blobFromImage(frame,<br/>             scale_factor_,<br/>             cv::Size(input_image_width_, input_image_height_),<br/>             mean_values_,<br/>             false,<br/>             false);</span></pre><p id="fbc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们可以通过网络转发我们的数据。我们将结果保存在变量<code class="du lb lc ld le b">detection_matrix</code>中。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="e2b3" class="lj jz hi le b fi lk ll l lm ln">     network_.setInput(input_blob, "data");<br/>     cv::Mat detection = network_.forward("detection_out");<br/>     cv::Mat detection_matrix(detection.size[2],<br/>             detection.size[3],<br/>             CV_32F,<br/>             detection.ptr&lt;float&gt;());</span></pre><p id="1614" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们遍历矩阵的行。每行包含一个检测。当迭代时，我们检查置信度值是否超过我们的阈值。如果是这样，我们构造一个<code class="du lb lc ld le b">cv::Rect</code>并保存在结果向量<code class="du lb lc ld le b">faces</code>中。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="57eb" class="lj jz hi le b fi lk ll l lm ln">std::vector&lt;cv::Rect&gt; faces;<br/><br/>    for (int i = 0; i &lt; detection_matrix.rows; i++) {<br/>        float confidence = detection_matrix.at&lt;float&gt;(i, 2);<br/><br/>        if (confidence &lt; confidence_threshold_) {<br/>            continue;<br/>        }<br/>        int x_left_bottom = static_cast&lt;int&gt;(<br/>                detection_matrix.at&lt;float&gt;(i, 3) * frame.cols);<br/><br/>        int y_left_bottom = static_cast&lt;int&gt;(<br/>                detection_matrix.at&lt;float&gt;(i, 4) * frame.rows);<br/><br/>        int x_right_top = static_cast&lt;int&gt;(<br/>                detection_matrix.at&lt;float&gt;(i, 5) * frame.cols);<br/><br/>        int y_right_top = static_cast&lt;int&gt;(<br/>                detection_matrix.at&lt;float&gt;(i, 6) * frame.rows);<br/><br/>        faces.emplace_back(x_left_bottom,<br/>                y_left_bottom,<br/>                (x_right_top - x_left_bottom),<br/>                (y_right_top - y_left_bottom));<br/>    }<br/><br/>    return faces;<br/>}</span></pre><p id="ef9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就结束了我们对<code class="du lb lc ld le b">FaceDetector</code>的实现。点击<a class="ae iu" href="https://github.com/bewagner/visuals/blob/blog-post-1/src/FaceDetector.cpp" rel="noopener ugc nofollow" target="_blank">此</a>链接查看全文。cpp文件。</p><h1 id="d688" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">可视化检测到的人脸</h1><p id="f87f" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">因为我们将人脸检测器实现为一个类，所以可视化矩形很容易。首先，包含<code class="du lb lc ld le b">FaceDetector.h</code>头文件。然后，我们创建一个<code class="du lb lc ld le b">FaceDetector</code>对象并调用<code class="du lb lc ld le b">detect_face_rectangles</code>方法。接下来，我们使用OpenCV的<code class="du lb lc ld le b">rectangle</code>方法在检测到的人脸上绘制一个矩形。</p><pre class="ju jv jw jx fd lf le lg lh aw li bi"><span id="2c25" class="lj jz hi le b fi lk ll l lm ln">#include &lt;opencv4/opencv2/opencv.hpp&gt; <br/>#include "FaceDetector.h"<br/>int main(int argc, char **argv) {<br/>      cv::VideoCapture video_capture;<br/>     if (!video_capture.open(0)) {<br/>         return 0;<br/>     }</span><span id="c0c4" class="lj jz hi le b fi lo ll l lm ln">      FaceDetector face_detector;</span><span id="9e1b" class="lj jz hi le b fi lo ll l lm ln">      cv::Mat frame;<br/>     while (true) {<br/>         video_capture &gt;&gt; frame;</span><span id="d086" class="lj jz hi le b fi lo ll l lm ln">         auto rectangles = face_detector.detect_face_rectangles(frame);<br/>         cv::Scalar color(0, 105, 205);<br/>         int frame_thickness = 4;<br/>         for(const auto &amp; r : rectangles){<br/>             cv::rectangle(frame, r, color, frame_thickness);<br/>         }<br/>         imshow("Image", frame);<br/>         const int esc_key = 27;<br/>         if (cv::waitKey(10) == esc_key) {<br/>             break;<br/>         }<br/>     }<br/>     cv::destroyAllWindows();<br/>     video_capture.release();</span><span id="5283" class="lj jz hi le b fi lo ll l lm ln">     return 0;<br/> }</span></pre><p id="0f86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们运行这个，我们会看到贝多芬的脸周围有一个矩形！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/6c51fcc3a9b22f7d3ca8a2a101e86274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*uLhL5bWFvCW7EpfS.gif"/></div></figure><h1 id="6e49" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">总结</h1><p id="ad8a" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们关于OpenCV中人脸检测的帖子到此结束。我们看到了如何在OpenCV中使用预训练的SSD网络来抓取相机图像并在其中找到人脸。</p><p id="3c33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢我的写作，考虑支持我，这样我可以继续为你创造内容！</p><div class="ju jv jw jx fd ab cb"><figure class="md ij me mf mg mh mi paragraph-image"><a href="https://ko-fi.com/bewagner"><img src="../Images/442e2379dd4c422211e3762adb3e50e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*upxn1lEIsQB36yY-a-RHVw.png"/></a></figure><figure class="md ij mj mf mg mh mi paragraph-image"><a href="https://www.patreon.com/bewagner?fan_landing=true"><img src="../Images/8f52df8c73b6eb1b2ef850f39042e120.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*rDcCY5d9_DyCDt9s_1RlQg.png"/></a></figure></div><p id="5730" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在Twitter上关注我</strong><a class="ae iu" href="https://twitter.com/bewagner_" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">@ be Wagner _</strong></a><strong class="ix hj">了解更多关于编程、机器学习和C++！</strong></p><p id="1fd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mk">最初发布于</em><a class="ae iu" href="https://bewagner.github.io/programming/2020/04/12/building-a-face-detector-with-opencv-in-cpp/" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://be Wagner . github . io</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>