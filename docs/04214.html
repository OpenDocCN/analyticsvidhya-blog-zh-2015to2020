<html>
<head>
<title>Is __init__() the constructor in python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">__init__()是python中的构造函数吗？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/is-init-the-constructor-in-python-43bb744e73b?source=collection_archive---------2-----------------------#2020-03-10">https://medium.com/analytics-vidhya/is-init-the-constructor-in-python-43bb744e73b?source=collection_archive---------2-----------------------#2020-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TLDR；__init()不是构造函数，__new__()是。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/59542e22a571bd6a2dd439474be90c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EVkafz1w0ro3o1dn"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jt" href="https://unsplash.com/@officestock?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·赫尔曼</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3a93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一般来说，</strong>刚接触python的开发者被告知__init__()方法被称为构造函数。</p><p id="7f1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入潜水之前，让我们先了解一下<strong class="ih hj">自我</strong>。</p><p id="7f07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经看到self被用作该方法的第一个参数。我们举个例子来理解这一点。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="169e" class="jz ka hi jv b fi kb kc l kd ke">class Power:<br/>     def __init__(self,n):<br/>         self.n=n<br/> <br/>     def cal(self):<br/>         return self.n**self.n</span></pre><p id="66f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，Power是一个有两种方法的类。cal用于计算数的幂。实例化后，我们得到以下输出</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="6c94" class="jz ka hi jv b fi kb kc l kd ke">p=Power(5)<br/>p.cal()<br/>3125</span></pre><p id="0ff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，添加另一个方法show()并且不要传递self。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="6b8f" class="jz ka hi jv b fi kb kc l kd ke">def show():<br/>    print('method without self')</span></pre><p id="5e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用we后出现以下错误</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="fb9e" class="jz ka hi jv b fi kb kc l kd ke">--------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-84-02f33f5f7a8f&gt; in &lt;module&gt;<br/>----&gt; 1 p.show()<br/><br/>TypeError: show() takes 0 positional arguments but 1 was given</span></pre><p id="1e7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述问题可以通过添加self作为参数或使其成为静态方法来解决。</p><p id="b390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">到目前为止的结论:</strong></p><ul class=""><li id="ae54" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated">__init__()定义了两个参数</li><li id="8c74" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">我们只传递了一个，它仍然没有给出错误。</li><li id="5b9b" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">为什么把<strong class="ih hj">自我</strong>作为第一个论证，而不是别的什么。</li></ul></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="d01b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们回到Power类，检查一下内部发生了什么。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="c280" class="jz ka hi jv b fi kb kc l kd ke">type(p.cal)<br/>&lt;class 'method'&gt;<br/>type(Power.cal)<br/>&lt;class 'funcion'&gt;</span></pre><p id="f61a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迷茫<strong class="ih hj">！！</strong></p><p id="dcad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python方法中，对象本身作为第一个参数传递给相应的函数。简言之，方法调用<code class="du la lb lc jv b">p.cal()</code>等于<code class="du la lb lc jv b">Power.cal(p)</code>。</p><p id="fbaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，当我们用一些参数调用一个方法时，相应的类函数是通过将方法的对象放在第一个参数之前来调用的。所以，像<code class="du la lb lc jv b"><strong class="ih hj">obj.method(args)</strong></code>这样的东西就变成了<code class="du la lb lc jv b"><strong class="ih hj">Class.method(obj)</strong></code>。</p><p id="41b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是类中函数的第一个参数必须是对象本身的原因。写这个参数本身仅仅是一个惯例。它不是一个关键字，在Python中没有特殊含义。我们可以使用其他名字(比如<code class="du la lb lc jv b">this</code>)。</p><p id="0a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">构造函数是创建对象的方法。</strong></p><p id="6209" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">至此结论:</strong></p><ul class=""><li id="d188" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated"><code class="du la lb lc jv b">__init__()</code>难道<strong class="ih hj">不是建造师</strong>。我们将自我视为第一个参数，它只不过是对象本身，即对象已经存在。</li><li id="48fc" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><code class="du la lb lc jv b">__init__()</code>在对象创建后立即被<strong class="ih hj">调用，用于初始化对象。</strong></li></ul></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="2d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果不是__init__()那么？</strong></p><p id="29f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是<code class="du la lb lc jv b"> <strong class="ih hj">__new__()</strong></code></p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="ad6e" class="jz ka hi jv b fi kb kc l kd ke">__new__(cls, *args, **kwargs) # signature</span></pre><p id="9d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">__new__()以cls作为第一个参数，表示需要实例化的类，编译器在实例化时自动提供这个参数。args和**kwargs是要传递的参数。</p><p id="965d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">__new__()总是在__init__()之前调用</p><p id="587e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="1d6e" class="jz ka hi jv b fi kb kc l kd ke">class Power:<br/>    <br/>    def __new__(cls,*args):<br/>        print("new method")<br/>        print(cls)<br/>        print(args)</span><span id="ac7c" class="jz ka hi jv b fi ld kc l kd ke"># create our object and return it<br/>        obj = super().__new__(cls)<br/>        return obj<br/>    <br/>    def __init__(self,n):<br/>        print("init method")<br/>        self.n=n<br/>    <br/>    def cal(self):<br/>        return self.n**self.n</span><span id="cb4a" class="jz ka hi jv b fi ld kc l kd ke">p=Power(5)<br/>p.cal()</span></pre><p id="cb63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="308e" class="jz ka hi jv b fi kb kc l kd ke">new method<br/>&lt;class '__main__.Power'&gt;<br/>(5,)<br/>init method<br/>3125</span></pre></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="402f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这对你有用。如果你在理解这个问题上有任何困难，或者你需要任何帮助，请联系我。</p><p id="5a21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="le">电子邮件:sambhavchoradia@gmail.com</em></p><p id="5e44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="le">社交媒体:</em> <a class="ae jt" href="https://www.linkedin.com/in/sambhav-choradia/" rel="noopener ugc nofollow" target="_blank"> <em class="le"> LinkedIn </em> </a></p><p id="b034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码。</p></div></div>    
</body>
</html>