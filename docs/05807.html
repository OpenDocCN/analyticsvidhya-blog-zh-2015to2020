<html>
<head>
<title>Big O Notation — Time Complexity in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号Javascript的时间复杂性</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/big-o-notation-time-complexity-in-javascript-f97f356de2c4?source=collection_archive---------0-----------------------#2020-05-03">https://medium.com/analytics-vidhya/big-o-notation-time-complexity-in-javascript-f97f356de2c4?source=collection_archive---------0-----------------------#2020-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/28b972815d7607c8a96ec69d3d2f48c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_xLLo8uvktxGNdAiyHSPw.png"/></div></div></figure><p id="fa2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用一个简写的数学符号来描述一个算法的效率是大O符号，用字母O是因为一个函数的增长率也叫它的阶。</p><p id="7b53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它允许as谈论算法的运行时间如何随着输入的增长而增长。</p><p id="a24e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设函数A的运行时间是f(n)，函数B的运行时间是g(n)，其中n是输入的大小。我们只关心函数如何增长，意思是，当n →∞时，函数发生了什么。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/b49aad1410f7d5a112bc77d5d512bcef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qmCsl6jK2jJahQTrFIQiQ.png"/></div></div></figure><p id="c11f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的示例函数中，接受输入数组并返回数组中数字的和。输入数组可以是任意长度，可以是一百个元素长，甚至十万个元素长。</p><p id="8757" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在的问题是，运行这个函数需要多少时间？这取决于各种因素，例如你的电脑有多快。你可以问下面的问题，而不是问这个问题。</p><p id="688f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着输入大小的增加，函数的运行时间如何增长？根据数组元素的长度，运行该函数需要不同的时间。要回答第二个问题，我们需要大O符号。</p><p id="1f6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大O符号一般可以归类为:</p><p id="785f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O(1): </strong>运行时间与问题的输入大小无关。</p><p id="2823" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O(n): </strong>问题对输入中的每个元素都需要少量的处理时间。<strong class="is hj">直线</strong>。</p><p id="1892" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O(n ): </strong>问题处理元素的所有对。<strong class="is hj">二次。</strong></p><p id="d7e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O(log n): </strong>当一个大问题通过某个常数分数将其转化为更小的规模来解决时。<strong class="is hj">对数。</strong></p><p id="0fa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O(n log n): </strong>当一个问题被分解成更小的子问题，独立求解，将解组合起来。<strong class="is hj">线型。</strong></p><p id="02a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> O(2^n) </strong> : <strong class="is hj">指数</strong>运行时间。要避免。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="84bb" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">常数时间算法</h1><p id="6a48" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">据说一个算法以恒定的时间运行。这意味着当你增加函数的输入量时。执行时间保持不变。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/4e9f9032bf5926d693b0ed3e033516a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8vsqXBe6uarwYCI95xH7g.png"/></div></div></figure><p id="33bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数相对于其输入以O(1)时间(常数时间)运行。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/31d097962d2c389a9d0dfeca93b36365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JX76woxCPUv29SIBus5EeQ.png"/></div></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="9978" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">线性时间算法</h1><p id="5762" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">函数的执行时间与输入大小成正比。函数的运行时间随着输入的增长而增长，我们将其标记为O(n)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/c933703b89e05d054b386fd119032cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpPIuaRawxLw3cI6rzSEzw.png"/></div></div></figure><p id="7d01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(n)表示增长率是线性的，即随着n的增加，处理时间以相同的速度增加。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/a1c947810e12601d862f820877622774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQLebuZoA56zCahYM5dNUw.png"/></div></div></figure><p id="8c61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑等式y= nx + z。如果y是对n个问题执行函数的成本，那么</p><ul class=""><li id="61c4" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">z决定了n = 0时的值，即执行的固定成本；</li><li id="5d9c" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">x决定了随着问题规模的增加，成本增长的速度。x是线性成本计划的比例常数。</li></ul><p id="d99d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有线性成本程序都有相同的执行时间是不正确的:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/cb5b770ebd6a078530426ed3516d4884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJ5k3iS86wlFt8LAsxE6sQ.png"/></div></div></figure><p id="1ccc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2倍成本增长更慢，但我们曾经考虑的所有问题可能都小于50，所以5倍计划可能更好。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="47e7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">对数算法</h1><p id="1d37" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">如果一个算法的时间执行与输入大小的对数成正比，则称该算法在对数时间内运行，我们将其标记为O(log n)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/f9a9da5b97f30d22515e45eec7d5053b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPxJFvu-7VsxQkQUwKrU6Q.png"/></div></div></figure><p id="ba7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(log n)算法从不查看输入中的所有元素。对数时间复杂性通常适用于在每个步骤中消除大量输入元素的算法。</p><p id="6d02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(log n)算法的一个例子是二分搜索法算法。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/03c12a4cb9cd59da7de1fc37a3720c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuIDO9YWFXovr1k_adOUZQ.png"/></div></div></figure><p id="efd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦列表被排序，就可以使用分治策略对其进行搜索。二进制搜索算法找到给定元素的中间，并将其与所需对象进行比较，如果找到匹配，则搜索成功并终止。</p><p id="f761" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不匹配，它确定中间元素大于或小于所需对象。这将消除一半的列表。它一次又一次地重复同样的过程，直到找到想要的对象。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="4587" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">二次算法</h1><p id="28f3" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">二次算法几乎是对数算法的逆算法。二次算法所需的步骤数是输入大小的平方根。如果输入大小是2，那么所需的步骤是4。如果输入大小为8，则需要64，以此类推。我们将其标记为O(n)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/7fa7d24a6c892c4c0c9c2b47d897ddae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezvdv6GMbMTL4dYayUFDZg.png"/></div></div></figure><p id="b5b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(n)算法的一个例子是冒泡排序算法。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/36bbb8a956aad691596e4021adfb11ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xos6vEF17SaeqLBijFkNKQ.png"/></div></div></figure><p id="dfd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">冒泡排序比较相邻的元素，它从前两个元素开始，如果第一个元素大于第二个元素，就交换它们。它重复相同的步骤，直到到达数组的末尾。同样的步骤将从i+1元素开始重复。</p><h2 id="30bf" class="lx kb hi bd kc ly lz ma kg mb mc md kk jb me mf ko jf mg mh ks jj mi mj kw mk bi translated">多项式算法</h2><p id="26bd" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">一个多项式算法由O(n^c表示)，如果一个算法的运行时间是由该算法的输入大小的多项式表达式的上界，则称该算法是<strong class="is hj">多项式时间的</strong>，对于c &gt; 1。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="23db" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">线性算法</h1><p id="b631" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">线性算法或对数线性算法比线性算法稍慢。我们把它标记为O(n log n)。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/3f5b67729629d644ff84af5b21888e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTHdNjcHqXp_L2kadsPL7g.png"/></div></div></figure><p id="591e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(n log n)算法的一个例子是合并排序算法。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/861804ba4d4e8c9ceb281fc42d661784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUUL-pWEUZTijcJLJhngFg.png"/></div></div></figure><p id="9a75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">合并排序使用分治策略对给定的数组进行排序，递归地分割数组，直到元素个数等于或少于两个。并且它递归地对划分后的数组进行排序。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/3e1d167524aeb36127c35df1201822c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3WbYC8eiV05fhoffu_eRg.png"/></div></div></figure><p id="c1ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是合并，它从每个数组中一个接一个地进行合并，使它们按升序排列。</p><p id="f691" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线性算法堆排序和快速排序的其他例子。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="85db" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">指数算法</h1><p id="de6d" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">指数算法是指算法执行的计算是相对于输入大小执行的操作数量的两倍。我们把它标为O(2^n).</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/39209fe44f0571276ed94b1b05bbb2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewEgK29aRGVYyO45tRmAvg.png"/></div></div></figure><p id="20c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(2^n函数的一个例子是斐波那契数的递归计算。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/348250b601daac438df48c92c9a6d0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWOMJ1NN3fRycLYVB9jyUw.png"/></div></div></figure><p id="1247" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(2^n)表示一种算法，其增长随着输入大小的每次增加而加倍。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="adfd" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">基本规则</h1><ul class=""><li id="1149" class="lg lh hi is b it ky ix kz jb mo jf mp jj mq jn ll lm ln lo bi translated">放下不断增加的东西。n+ 5是O(n)</li><li id="8435" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">去掉常数倍数。0.5n + 2n + 7是O(n)。</li><li id="8838" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">做2n次常数运算就是O(n)。</li><li id="7b99" class="lg lh hi is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">做O(n)运算n/2次就是O(n)。</li></ul><p id="720a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是所有复杂性的图表。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/6f62a4f6b657d789130001a279a9f98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFgoa0WJYvcaEaZ8M32xyg.png"/></div></div><figcaption class="ms mt et er es mu mv bd b be z dx translated">资料来源:bigocheatsheet</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="b3c3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="3027" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">Big-O符号为函数增长的上限提供了一个有用的抽象，2n + 3n + 2是O(n)，O(2^n)和O(n)。</p><p id="7405" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大ω:下界。2n + 3n + 2是ω(n)和ω(log(n))和ω(n)。</p><p id="8d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大θ:上下有界。2n + 3n + 2为θ(n ^ 2)。</p><h1 id="d98c" class="ka kb hi bd kc kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx bi translated">#爱它，犯错误，学习，继续磨</h1></div></div>    
</body>
</html>