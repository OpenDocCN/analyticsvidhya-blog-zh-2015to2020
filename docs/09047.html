<html>
<head>
<title>C++ : The fight between converting constructor and conversion operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++:转换构造函数和转换运算符之争</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/c-the-fight-between-converting-constructor-and-conversion-operator-abef3bf4baeb?source=collection_archive---------21-----------------------#2020-08-23">https://medium.com/analytics-vidhya/c-the-fight-between-converting-constructor-and-conversion-operator-abef3bf4baeb?source=collection_archive---------21-----------------------#2020-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/ab1744d571377f2e5a01dbc4738990bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*H80hO4T580Ijy14C.jpg"/></div></figure><div class=""/><p id="5d1b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们考虑下面的场景，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4256" class="jt ju hp jp b fi jv jw l jx jy">Bar obj;<br/>Foo x = obj;</span></pre><p id="79b2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你认为x的初始化会如何工作？</p><p id="df49" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可能想到的一件事是，如果Foo有一个接受Bar对象的构造函数，那么我们就可以开始了。的确是这样，但是如果Bar也有一个转换操作符(也称为转换函数)，允许自己转换成Foo对象，如下所示:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="09ea" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 1</span><span id="a440" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(const Bar&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="1e16" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo()<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="4532" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  // Using a temporary Bar object to create a foo object<br/>  Foo x = Bar();              // Copy Initialization<br/>  Foo y {Bar()};              // Direct Initialization<br/>}</span></pre><p id="337f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谁会接到电话？是否有预定义的优先顺序？我将复制和直接初始化分开的事实可能会给你一个提示，事情没有这么简单，在C++中没有什么是简单的。</p><p id="7409" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是打印出来的内容:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d519" class="jt ju hp jp b fi jv jw l jx jy">Bar Conversion operator.<br/>Foo Converting Constructor.</span></pre><p id="4e2a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们试着从Foo类中移除转换构造函数，看看会发生什么。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="288b" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 2</span><span id="1f1a" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  //Foo(const Bar&amp; x)<br/>  //{ <br/>  //  std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  //}<br/>};</span><span id="3fab" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo()<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="15e8" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  // Using a temporary Bar object to create a foo object<br/>  Foo x = Bar();              // Copy Initialization<br/>  Foo y {Bar()};              // Direct Initialization<br/>}</span></pre><p id="2218" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e3b4" class="jt ju hp jp b fi jv jw l jx jy">Bar Conversion operator.<br/>Bar Conversion operator.</span></pre><p id="3c76" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果没有有效的转换构造函数，似乎直接初始化将依赖于转换操作符。</p><p id="b73c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">无论Foo对象是由右值还是左值构造的，上面两个结果都是一样的。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="cc97" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们停止猜测输出，理解真正发生了什么。</p><p id="ed85" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">直接初始化的行为类似于调用一组重载的函数。这种情况下的函数是一个类的构造函数。它将执行任何隐式转换，并尝试调用构造函数，即使转换运算符提供了更好的匹配。只有当没有办法调用任何构造函数时，直接初始化才会尝试调用转换运算符。</p><p id="2929" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以在代码片段1中，在直接初始化期间，一个临时Bar对象被传递给构造函数。由于临时可以绑定到常量引用，因此调用转换构造函数。在代码片段2中，转换构造函数不存在，因此转换操作符被执行。</p><p id="1362" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不用说，如果转换构造函数接受非常数引用，也会调用转换运算符，因为右值不会绑定到非常数引用:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e8e5" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 3</span><span id="98f8" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(Bar&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="7d82" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo()<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="c8e8" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  // Using a temporary Bar object to create a foo object<br/>  Foo x = Bar();              // Copy Initialization<br/>  Foo y {Bar()};              // Direct Initialization<br/>}</span></pre><p id="a3d5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b534" class="jt ju hp jp b fi jv jw l jx jy">Bar Conversion operator.<br/>Bar Conversion operator.</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="0da7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于拷贝初始化，情况就不同了。这里发生正常的过载解决。但是怎么做呢？</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="c8a4" class="jt ju hp jp b fi jv jw l jx jy">// When we say<br/>Foo x = Bar();</span><span id="b870" class="jt ju hp jp b fi jz jw l jx jy">// The candidate functions are<br/>Foo::Foo(T)       // Where T is parameter signature of <br/>                  // converting constructor</span><span id="2804" class="jt ju hp jp b fi jz jw l jx jy">Bar::operator Foo()</span></pre><p id="849c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于过载解决方案，这被转换为:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4dde" class="jt ju hp jp b fi jv jw l jx jy">Foo::Foo(T)       // As before</span><span id="9219" class="jt ju hp jp b fi jz jw l jx jy">// Implicit parameter is added to the conversion operator<br/>Foo(U)        // Where U is either Bar&amp; or Bar&amp;&amp;<br/>              // Depending on whether the object being converted<br/>              // is a lvalue or rvalue</span><span id="2a93" class="jt ju hp jp b fi jz jw l jx jy">...</span><span id="9eee" class="jt ju hp jp b fi jz jw l jx jy">Foo x = Bar();      // Rvalue. Hence U is Bar&amp;&amp;</span><span id="22f8" class="jt ju hp jp b fi jz jw l jx jy">Bar z;<br/>Foo x = z;          // Lvalue. Hence U is Bar&amp;</span></pre><p id="2eba" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，根据正常的重载决策规则，将调用最佳匹配。</p><p id="88f9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">记住这一点，让我们分析上面3个关于复制初始化的片段。</p><p id="49f7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在代码片段1中，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a273" class="jt ju hp jp b fi jv jw l jx jy">Foo x = Bar();</span><span id="723f" class="jt ju hp jp b fi jz jw l jx jy">// Candidate functions</span><span id="0b86" class="jt ju hp jp b fi jz jw l jx jy">Foo(const Bar&amp; x);<br/>operator Foo(Bar&amp;&amp; x);           // Better match for an rvalue</span></pre><p id="fd8c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在代码片段3中，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="7089" class="jt ju hp jp b fi jv jw l jx jy">Foo x = Bar();</span><span id="ddc5" class="jt ju hp jp b fi jz jw l jx jy">// Candidate functions</span><span id="568f" class="jt ju hp jp b fi jz jw l jx jy">Foo(Bar&amp; x);                     // Temporary does not bind to     <br/>                                 // lvalue reference<br/>operator Foo(Bar&amp;&amp; x);           // Only match for an rvalue</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="02f1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设我们现在已经有了坚实的理解，让我们进一步扭曲例子。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="10a9" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 4</span><span id="5dc5" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(Bar&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="5f45" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo()<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="aafe" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  Bar z;<br/>  Foo x = z;              // Copy Initialization<br/>  Foo y {z};              // Direct Initialization<br/>}</span></pre><p id="89d3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你说现在会发生什么？</p><p id="487b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们先看看直接初始化。它将首先尝试调用<code class="du kh ki kj jp b">Foo(Bar&amp; x)</code>,这将成功，因为它需要一个左值引用，我们传递给它一个左值。</p><p id="0b15" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在对于拷贝初始化，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d2d3" class="jt ju hp jp b fi jv jw l jx jy">Foo x = z;</span><span id="d219" class="jt ju hp jp b fi jz jw l jx jy">// Candidate functions</span><span id="5e2f" class="jt ju hp jp b fi jz jw l jx jy">Foo(Bar&amp; x);                     <br/>operator Foo(Bar&amp; x);           </span></pre><p id="7ebc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很明显，两个候选函数具有完全相同的签名，因此调用是不明确的。对于拷贝初始化，下面展示了相同类型的不明确行为。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="bfaf" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 5</span><span id="89f2" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(Bar&amp;&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="e437" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo()<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="dc63" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  Foo x = Bar();              // Copy Initialization<br/>  Foo y {Bar()};              // Direct Initialization<br/>}</span></pre><p id="ab9f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果被转换的对象是const怎么办？</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b4aa" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 6</span><span id="890f" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(const Bar&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="b11b" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo()<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="1fa6" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  const Bar z;<br/>  Foo x = z;              // Copy Initialization<br/>  Foo y {z};              // Direct Initialization<br/>}</span></pre><p id="43ff" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">const对象只能调用const成员函数，所以<code class="du kh ki kj jp b">operator Foo()</code>没有资格被调用，在这两种情况下，转换构造函数都将被调用。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="ca6f" class="kk ju hp bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">如果转换运算符被标记为const会怎样？</h1><p id="b074" class="pw-post-body-paragraph im in hp io b ip lh ir is it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj hb bi translated">这就是你遇到具体实现行为的地方(你没想到一篇C++文章会以这样的东西结束？).前面我说过隐式参数不是const限定的。不是巴&amp;就是巴&amp;&amp;。也就是说，转换运算符不是const。</p><p id="f3b2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当转换操作符被标记为const时，它将反映在隐式参数中，该参数现在要么是const Bar&amp;要么是const Bar&amp;&amp;。<br/>这个规则被发现适用于<strong class="io hq">铿锵</strong>。</p><p id="1805" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将转换操作符标记为const似乎会使MSVC出错，因为在我尝试的例子中，它会转储大约4000行汇编代码，但不会打印任何内容。对于所有不明确的调用，GCC似乎更喜欢转换构造函数而不是转换操作符。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="bdd4" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 7</span><span id="404d" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(Bar&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="20ee" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo() const<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="2877" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  const Bar z;<br/>  Foo x = z;              // Copy Initialization<br/>  Foo y {z};              // Direct Initialization<br/>}</span></pre><p id="07ff" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="1321" class="jt ju hp jp b fi jv jw l jx jy">Bar Conversion operator.<br/>Bar Conversion operator.</span></pre><p id="e9f0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于复制初始化，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d39e" class="jt ju hp jp b fi jv jw l jx jy">const Bar z;<br/>Foo x = z;</span><span id="0315" class="jt ju hp jp b fi jz jw l jx jy">// Candidate functions</span><span id="3d4c" class="jt ju hp jp b fi jz jw l jx jy">Foo(Bar&amp; x);                  // Not a match since it takes a <br/>                              // non-const ref<br/>operator Foo(const Bar&amp; x);   // Match</span></pre><p id="cff0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们让Foo的转换构造函数接受一个常量引用，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="7b5a" class="jt ju hp jp b fi jv jw l jx jy">const Bar z;<br/>Foo x = z;</span><span id="e731" class="jt ju hp jp b fi jz jw l jx jy">// Candidate functions</span><span id="fd24" class="jt ju hp jp b fi jz jw l jx jy">Foo(const Bar&amp; x);                  <br/>operator Foo(const Bar&amp; x);</span><span id="9f26" class="jt ju hp jp b fi jz jw l jx jy">// Ambiguous</span></pre><p id="6b51" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们尝试扭曲代码片段7来处理右值。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d617" class="jt ju hp jp b fi jv jw l jx jy">// Snippet 8</span><span id="5451" class="jt ju hp jp b fi jz jw l jx jy">struct Foo<br/>{<br/>  Foo() {}<br/>  Foo(Bar&amp;&amp; x)<br/>  { <br/>    std::cout &lt;&lt; "Foo Converting Constructor.\n"; <br/>  }<br/>};</span><span id="5795" class="jt ju hp jp b fi jz jw l jx jy">struct Bar<br/>{<br/>  operator Foo() const<br/>  { <br/>    std::cout &lt;&lt; "Bar conversion operator.\n";<br/>    return Foo();<br/>  }<br/>};</span><span id="015b" class="jt ju hp jp b fi jz jw l jx jy">int main()<br/>{<br/>  Foo x = Bar();              // Copy Initialization<br/>  Foo y {Bar()};              // Direct Initialization<br/>}</span></pre><p id="c955" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5170" class="jt ju hp jp b fi jv jw l jx jy">Foo Converting Constructor.<br/>Foo Converting Constructor.</span></pre><p id="10ea" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于复制初始化，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b920" class="jt ju hp jp b fi jv jw l jx jy">Foo x = Bar();     // Do note that this is a non-const rvalue. </span><span id="7080" class="jt ju hp jp b fi jz jw l jx jy">// Candidate functions</span><span id="3ff0" class="jt ju hp jp b fi jz jw l jx jy">Foo(Bar&amp;&amp; x);                  <br/>operator Foo(const Bar&amp;&amp; x);    // const rvalue references although<br/>                                // syntactically valid, <br/>                                // don't make much sense.</span></pre><p id="66b4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">重载决策总是倾向于较小的常量版本，因此Foo的转换构造函数被调用。</p><p id="5ff3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不用说，如果我们将Foo的转换构造函数改为<code class="du kh ki kj jp b">Foo(const Bar&amp;&amp; x);</code>，调用将变得不明确。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="b3fe" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我似乎已经涵盖了关于这场战斗的所有可能的场景，我希望你能从这篇文章中学到一些东西。请随时分享你对这个话题的了解，我可能会编辑这篇文章，并在其中加入你的想法。最后，如果你走到这一步，谢谢你。</p></div></div>    
</body>
</html>