<html>
<head>
<title>JS, meet Python — I am JSON.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS，认识一下Python——我是JSON。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/js-meet-python-i-am-json-f0300db8d68f?source=collection_archive---------26-----------------------#2019-11-11">https://medium.com/analytics-vidhya/js-meet-python-i-am-json-f0300db8d68f?source=collection_archive---------26-----------------------#2019-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c3f8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过JSON对象在JavaScript和(Python) Flask应用程序之间建立本地对话。然后，在谷歌应用引擎上运行它。</h2></div><blockquote class="ix iy iz"><p id="ef4c" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">注意:出于某种原因，使用Jupyter中的<strong class="jd hj">请求</strong>包从谷歌应用引擎(GAE)加载请求需要<em class="hi">很长时间..</em>。为什么？你告诉我！我很想知道。</p></blockquote><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/65a66f443cfc921dbb220eda949a4791.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*l0my4AQ-jOky7yC3.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">左边的东西是莱夫·埃里克森用过的烧瓶</figcaption></figure><h1 id="9be3" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">构建您的应用</h1><p id="21ac" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">你要做的第一件事是构建一个你计划放到GAE上的应用程序，并将其保存到某个目录文件夹中。我假设你知道如何在<a class="ae ln" href="https://www.fullstackpython.com/flask.html" rel="noopener ugc nofollow" target="_blank"> Flask </a>上设置一个简单的应用，但是如果你不知道，他们在主页上有一个很棒的<code class="du lo lp lq lr b">hello world</code>例子。</p><p id="0ac1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">对于我们对Flask的实际使用，我们想要的不仅仅是一个接受<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" rel="noopener ugc nofollow" target="_blank"> GET </a>请求并展示有趣内容的应用程序。我们想要构建一个<a class="ae ln" href="https://www.freecodecamp.org/news/what-is-an-api-in-english-please-b880a3214a82/" rel="noopener ugc nofollow" target="_blank"> API </a>“服务器”,它接受<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" rel="noopener ugc nofollow" target="_blank"> POST </a>请求，这些请求包含一些数据的有效载荷，并且根据这些有效载荷，用另一组数据作为响应，供客户端使用。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ls"><img src="../Images/b672b97e09cbb78cade6502863cae7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtnU9KpoqfSI9a5-XI_JBw.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">(非常)粗略的帖子请求草图</figcaption></figure><p id="3180" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">你可能已经注意到了，我决定给你链接一些我认为比我更能解释概念的文章。在继续编写代码之前，我强烈建议看一看这些文章。</p><h2 id="cbec" class="lt ko hi bd kp lu lv lw kt lx ly lz kx lh ma mb kz lj mc md lb ll me mf ld mg bi translated">一些代码</h2><p id="a54c" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">不要太深入，让我们先把所有的代码写下来，然后浏览一下:</p><p id="d5d9" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">首先，导入您需要的库，并加载数据</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="fb6f" class="lt ko hi lr b fi ml mm l mn mo">from flask import Flask, request<br/>from flask_cors import cross_origin<br/>import json<br/>import pandas as pd</span><span id="1885" class="lt ko hi lr b fi mp mm l mn mo">app = Flask(__name__)</span><span id="3ece" class="lt ko hi lr b fi mp mm l mn mo">cross_origins = ['http://localhost:1313', 'http://localhost:8888']<br/>df = pd.read_csv("./datafile.csv")  # df should be loaded upon init</span></pre><p id="3dd4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">然后，编写一个函数来接收来自使用<a class="ae ln" href="https://realpython.com/python-requests/" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hj">请求</strong> </a>(或者一个替代方案)的Python请求或者来自JavaScript <code class="du lo lp lq lr b">XMLHttpRequest</code>的数据。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="1ff1" class="lt ko hi lr b fi ml mm l mn mo">def get_data():<br/>    <em class="jc">'''<br/>    a standard reception of data from POST/GET request.<br/><br/>    '''<br/>    </em># Python call<br/>    try:<br/>        request_data = json.loads(request.data)<br/>        data = json.loads(request_data['json_payload'])<br/>        calltype = 'python'<br/><br/>    # JavaScript call<br/>    except:<br/>        request_data = request.json<br/>        data = request_data['json_payload']<br/>        calltype = 'javascript'<br/><br/>    print(calltype)<br/>    print(request_data)<br/>    print(data)<br/><br/>    return data</span></pre><p id="2eb4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">然后，添加初始化应用程序的路由，以及一个post请求的路由。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="f4f2" class="lt ko hi lr b fi ml mm l mn mo">@app.route('/')<br/>@cross_origin(origins=cross_origins)<br/>def index():<br/>    return 'Yay initialization!\n'</span><span id="0746" class="lt ko hi lr b fi mp mm l mn mo">@app.route('/retrieve_data', methods=['GET', 'POST', 'OPTIONS'])<br/>@cross_origin(origins=cross_origins, allow_headers=['Content-Type'])<br/>def retrieve_data():<br/>    data = get_data()</span><span id="728e" class="lt ko hi lr b fi mp mm l mn mo">    # ... do stuff using `data` and `df`, save result as `df_report`</span><span id="296f" class="lt ko hi lr b fi mp mm l mn mo">    response = {"data": df_report.to_json(orient='records')}<br/><br/>    return response</span></pre><p id="2a78" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">最后，将应用程序设置为在<code class="du lo lp lq lr b">__main__</code>实例上运行。<em class="jc">(注:评论中的措辞直接来自</em> <a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/building-app/writing-web-service" rel="noopener ugc nofollow" target="_blank"> <em class="jc"> GAE app.yaml讨论</em> </a> <em class="jc">)。)</em></p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="0b09" class="lt ko hi lr b fi ml mm l mn mo">if __name__ == '__main__':<br/>    # This is used when running locally only. When deploying to GAE<br/>    # a webserver process such as Gunicorn will serve the app. This<br/>    # can be configured by adding an `entrypoint` to app.yaml.<br/>    app.run(host='127.0.0.1', port=8080, debug=True)</span></pre><h2 id="dea1" class="lt ko hi bd kp lu lv lw kt lx ly lz kx lh ma mb kz lj mc md lb ll me mf ld mg bi translated">解释1: CORS</h2><p id="3e4b" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">我们在这里做的第一件奇怪的事情是导入一个叫做<code class="du lo lp lq lr b">flask_cors</code>的东西，并定义一些<code class="du lo lp lq lr b">cross_origins</code>。基本上，有一个叫做<a class="ae ln" href="https://cloud.google.com/storage/docs/cross-origin" rel="noopener ugc nofollow" target="_blank">跨源资源共享(CORS) </a>的东西，它是最近开发的，用来提供额外的安全级别。嗯，这导致了许多谷歌(或其他)应用程序的问题，因为大多数(如果不是全部)数据共享发生在多个来源之间。例如，考虑如果<em class="jc">女士服务器</em>位于IP地址123.456.7.89，而<em class="jc">先生Blah </em>位于IP地址987.654.3.21。然后，对话发生在两个不同的起源之间。更实际的是，如果你有一个来自GAE的对Google存储容器的请求，那么你也有同样的问题。</p><p id="f39a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">CORS是解决错误产生的问题的方法<code class="du lo lp lq lr b">No ‘Access-Control-Allow-Origin’ header is present on the requested resource</code>。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="9dc7" class="lt ko hi lr b fi ml mm l mn mo">...<br/>from flask_cors import cross_origin<br/>...</span><span id="f141" class="lt ko hi lr b fi mp mm l mn mo">...</span><span id="c743" class="lt ko hi lr b fi mp mm l mn mo">cross_origins = ['http://localhost:1313', 'http://localhost:8888']<br/>...</span></pre><p id="5849" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated"><a class="ae ln" href="https://flask-cors.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"><strong class="jd hj">flask _ CORS</strong></a><strong class="jd hj"/>是一个帮助我们解决问题的库，而<code class="du lo lp lq lr b">cross_origins</code>是API应该期望POST请求并应该满足它们的位置。</p><blockquote class="ix iy iz"><p id="a171" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">注意:Google确实有一个“内置”解决方案，它包括更新你的app.yaml文件以支持特定的http头。<strong class="jd hj">然而</strong>，我花了一整天的时间为我的用例尝试这个解决方案的每一个变体，但是我不能让它工作。因此，我使用<strong class="jd hj"> flask_cors </strong>。在这一点上，有时应用程序会在一开始加载有点慢。Google针对这个问题提供了一个<a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/configuring-warmup-requests" rel="noopener ugc nofollow" target="_blank">预热请求解决方案</a>，但是我也发现对我也不起作用！真扫兴。</p></blockquote><h2 id="d13d" class="lt ko hi bd kp lu lv lw kt lx ly lz kx lh ma mb kz lj mc md lb ll me mf ld mg bi translated">解释2: get_data</h2><p id="b162" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">接下来，您会注意到这个<code class="du lo lp lq lr b">get_data</code>函数，它对传入的请求做了很多事情。让我一行一行地看完<code class="du lo lp lq lr b"># Python call</code>和<code class="du lo lp lq lr b"># JavaScript call</code>部分。<em class="jc">注意:稍后，我们将介绍如何在Python和JavaScript调用中格式化数据以实现这一点。</em></p><ol class=""><li id="994f" class="mq mr hi jd b je jf jh ji lh ms lj mt ll mu jw mv mw mx my bi translated"><strong class="jd hj">请求数据。</strong>您想要的数据将保存在变量<code class="du lo lp lq lr b">request_data</code>中。在Python中，要得到它，使用<code class="du lo lp lq lr b">json.loads(request.data)</code>。在JavaScript中，使用<code class="du lo lp lq lr b">request.json</code>。</li><li id="63dc" class="mq mr hi jd b je mz jh na lh nb lj nc ll nd jw mv mw mx my bi translated"><strong class="jd hj">提取数据。</strong>稍后，我们将看到数据被格式化，我们想要使用的实际数据存储在<code class="du lo lp lq lr b">'json_payload'</code>内发送给应用程序的有效载荷中。因此，为了做到这一点，我们使用Python <code class="du lo lp lq lr b">json.loads(request_data[‘json_payload’])</code>中的load JSON，或者只使用键从JavaScript <code class="du lo lp lq lr b">request_data[‘json_payload’]</code>中访问数据。</li></ol><h2 id="7dc1" class="lt ko hi bd kp lu lv lw kt lx ly lz kx lh ma mb kz lj mc md lb ll me mf ld mg bi translated">解释post请求</h2><p id="532d" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">代码的最后一部分是指向POST请求的数据收集部分的应用程序路由。让我们来解决这个问题:</p><p id="f85f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated"><code class="du lo lp lq lr b">@app.route(‘/retrieve_data’, methods=[‘GET’, ‘POST’, ‘OPTIONS’])</code></p><p id="7b79" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">对于这个路由，我们需要接受GET、POST和OPTIONS请求。目前，POST请求是唯一对应用程序有意义的请求，但我保留了GET和OPTIONS，以防我决定改变数据处理方式。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="08c7" class="lt ko hi lr b fi ml mm l mn mo">@cross_origin(origins=cross_origins, allow_headers=['Content-Type'])</span></pre><p id="3051" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">这个装饰器指的是<strong class="jd hj"> flask_cors </strong>包。我们已经在<code class="du lo lp lq lr b">cross_origins</code>中定义了可以跨越数据的原点，所以应该没问题。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="888c" class="lt ko hi lr b fi ml mm l mn mo">data = get_data()</span></pre><p id="fda1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">从<code class="du lo lp lq lr b">get_data()</code>出来的数据是POST请求中发送的客户端数据的提取内容，您不需要传入任何参数就可以让它工作。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="75ef" class="lt ko hi lr b fi ml mm l mn mo">response = {"data": df_report.to_json(orient='records')}</span></pre><p id="1472" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">最后，这是我们将如何打包数据。这个应用程序的目的是为D3可视化提供数据，当数据是以<code class="du lo lp lq lr b">[{'key': 'value', ...}, ...]</code>的形式时，D3(和JavaScript)工作得最好，其中我们的数据被表示为一个对象列表，每个对象独立地规定每个属性的值。因此，出现了<code class="du lo lp lq lr b">orient="records"</code>位。</p><h1 id="7864" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">建立GAE</h1><p id="5ea9" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">好的，这里重要的事情是非常小心地遵循谷歌给出的<a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/building-app/" rel="noopener ugc nofollow" target="_blank">指令</a>，但是也要小心地遵循我的指令(我只做几个警告，我不确定谷歌是否已经更新了……我确定他们正在更新。)</p><p id="6ee0" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">我们不会使用大量数据(出于我们的目的，我们<em class="jc">可以</em>在谷歌存储上托管我们的数据，但为了简单起见，我们不需要这么做)。而且，我们不太担心用户的认证。因此，我们将只需要使用步骤<a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/building-app/creating-gcp-project" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/building-app/writing-web-service" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/building-app/deploying-web-service" rel="noopener ugc nofollow" target="_blank"> 3 </a>和<a class="ae ln" href="https://cloud.google.com/appengine/docs/standard/python3/building-app/deploying-web-service" rel="noopener ugc nofollow" target="_blank"> 4 </a>。记住，当你<code class="du lo lp lq lr b">gcloud app deploy</code>时，你保留代码的最后一部分<code class="du lo lp lq lr b">if __name__ == "__main__"</code>。我会在执行中忽略它所需要的。</p><h1 id="0d64" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">从Python请求数据</h1><p id="7627" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">在Python中，假设您使用上述方法在应用程序中发布数据，您可以使用请求来运行</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="56d2" class="lt ko hi lr b fi ml mm l mn mo">import requests<br/>import json<br/>import pandas as pd</span></pre><p id="7d22" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">要导入库</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="b3df" class="lt ko hi lr b fi ml mm l mn mo">request = requests.get('<a class="ae ln" href="https://blog1-256621.appspot.com/'" rel="noopener ugc nofollow" target="_blank">https://blah-1.appspot.com/'</a>)<br/># request = requests.get('<a class="ae ln" href="https://blog1-256621.appspot.com/'" rel="noopener ugc nofollow" target="_blank">https://localhost:1313/'</a>) # Flask run<br/>print(request.content.decode())</span></pre><p id="f061" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">测试你的应用(无论是在GAE，还是由Flask本地驱动)</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="f3d7" class="lt ko hi lr b fi ml mm l mn mo">data = {'var_1': ['data_stuff1', 'data_stuff2', ...],<br/>        'var_2': ['data_stuff1', 'data_stuff2', ...]}</span><span id="7a2f" class="lt ko hi lr b fi mp mm l mn mo">request = requests.post('<a class="ae ln" href="https://blog1-256621.appspot.com/select_income'" rel="noopener ugc nofollow" target="_blank">https://blah-1.appspot.com/</a>retrieve_data',<br/>                         headers={"Content-Type":       <br/>                                  "application/json;charset=UTF-8"},<br/>                         json={'json_payload': json.dumps(data)})</span></pre><p id="2838" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">来发送数据。注意，这最后一部分基本上是通过POST请求发送有效负载的标准操作方式。</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="5e93" class="lt ko hi lr b fi ml mm l mn mo">pd.read_json(request.json()['data'])</span></pre><p id="21c4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">最后，您可以使用pandas以表格形式显示数据。</p><h1 id="5269" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">从JavaScript请求数据</h1><p id="5e59" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">好吧，这个是个大麻烦。上述Python脚本的目的是测试我们的API。出于某种原因，这需要一段时间，但主要是为了调试和测试。JavaScript部分是D3.js的工作所在，所以我们需要聪明地处理我们的请求。</p><h2 id="fb3d" class="lt ko hi bd kp lu lv lw kt lx ly lz kx lh ma mb kz lj mc md lb ll me mf ld mg bi translated">承诺</h2><p id="c0fa" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">在深入研究我们的应用程序的JavaScript请求之前，首先要理解JavaScript承诺。老实说，真正掌握这里发生的事情的最好方法是研究Mozilla MDN Web文档中的<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">理解承诺</a>，然后<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">构造它们</a>。你可以整天(像我一样)研究不同的媒体文章和博客文章，试图找到一个简洁的解释，但在一天结束时，最有价值的信息将来自MDN web文档。尽可能点击所有链接，以确保你理解了你正在阅读的内容，并接受在你理解承诺之前，你可能还需要理解JavaScript中的其他基本概念。把它想象成维基百科的一篇文章— <strong class="jd hj">不要害怕点击一堆链接</strong>！一旦你经历了这个过程，你仍然会有点失落(就像我一样)，记住这个帮助我的想法:</p><blockquote class="ne"><p id="dd12" class="nf ng hi bd nh ni nj nk nl nm nn jw dx translated">JS承诺*不是数据*，但它是一个* <strong class="ak">途径，通过它你将获得数据(无论它是否是你想要的)。</strong></p><p id="a0a8" class="nf ng hi bd nh ni nj nk nl nm nn jw dx translated">是* <strong class="ak">而不是</strong> <strong class="ak">冰淇淋甜筒* </strong>，是你最好的朋友答应给你冰淇淋甜筒。</p></blockquote><p id="85eb" class="pw-post-body-paragraph ja jb hi jd b je no ij jg jh np im jj lh nq jm jn lj nr jq jr ll ns ju jv jw hb bi translated">所以，当你写类似于<code class="du lo lp lq lr b">var promise2 = promise1().then(...)</code>的东西时，只要记住<code class="du lo lp lq lr b">promise2</code>真的是一个承诺，而不是数据。</p><h2 id="11fa" class="lt ko hi bd kp lu lv lw kt lx ly lz kx lh ma mb kz lj mc md lb ll me mf ld mg bi translated">代码</h2><p id="b1e3" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">同样，我将在这里张贴一大堆数据，我们将浏览这些数据:</p><pre class="jy jz ka kb fd mh lr mi mj aw mk bi"><span id="57d4" class="lt ko hi lr b fi ml mm l mn mo">function postRequest(url, data) {<br/>  /*<br/>  url - API route<br/>  data - the 'data' (e.g., dictionary) that the API will extract.</span><span id="4273" class="lt ko hi lr b fi mp mm l mn mo">  Get data back from this request using this syntax:</span><span id="8e06" class="lt ko hi lr b fi mp mm l mn mo">  var request = postRequest(api_route, data);</span><span id="0c56" class="lt ko hi lr b fi mp mm l mn mo">  request.then(function(result) {<br/>    json_data = JSON.parse(JSON.parse(result)['data']);<br/>    // do something with `json_data` ...<br/>  }).catch(function(error) {<br/>    console.log(error);<br/>  });<br/>  */</span><span id="ac00" class="lt ko hi lr b fi mp mm l mn mo">  var xhttp = new XMLHttpRequest();<br/>  <br/>  // Return the promise of an xhttp request<br/>  // that has successfully posted `data` to the `url`</span><span id="6641" class="lt ko hi lr b fi mp mm l mn mo">  return new Promise(function(resolve, reject) {<br/>    xhttp.onreadystatechange = function() {<br/>      // Set handler to watch for the Ready State to change to DONE<br/>      if (xhttp.readyState == 4) {<br/>        if (xhttp.status &gt;= 300) {<br/>          // Reject promise with error if the post is a failure<br/>          reject("Error, status code = " + xhttp.status);<br/>        } else {<br/>          // (Lazily) Resolve the promise if success<br/>          resolve(xhttp.responseText);<br/>        }<br/>      }<br/>    }<br/>  // Open post request to the Flask App<br/>  xhttp.open('POST', url, true);</span><span id="5112" class="lt ko hi lr b fi mp mm l mn mo">  // Send the proper header information along with the request<br/>  xhttp.setRequestHeader("Content-Type",<br/>                         "application/json;charset=UTF-8");</span><span id="5ea1" class="lt ko hi lr b fi mp mm l mn mo">  // My standard for json_payload back and forth<br/>  var payload = {"json_payload": data};</span><span id="8f48" class="lt ko hi lr b fi mp mm l mn mo">  xhttp.send(JSON.stringify(payload));<br/>  });<br/>}</span></pre><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es nt"><img src="../Images/ef9f38faa08f05c05515b4cd23d38c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*KmZh8wAO4uwWk9pC.jpg"/></div><figcaption class="kj kk et er es kl km bd b be z dx translated">这大概就是你rn的感受吧。</figcaption></figure><ol class=""><li id="900a" class="mq mr hi jd b je jf jh ji lh ms lj mt ll mu jw mv mw mx my bi translated"><strong class="jd hj">说明如何调用函数。这段代码的第一步是提供一种关于如何使用该函数的文档(在<code class="du lo lp lq lr b">/* */</code>中)。<code class="du lo lp lq lr b">postRequest</code>的输出是一个承诺，所以一旦<em class="jc">解决了</em>，你需要告诉JavaScript做什么。我们通过使用<code class="du lo lp lq lr b">.then</code>和<code class="du lo lp lq lr b">.catch</code>来做到这一点。如果问题解决了，我们就可以使用<code class="du lo lp lq lr b">JSON.parse(JSON.parse(result)['data'])</code>语法提取数据后再进行<code class="du lo lp lq lr b">// do our stuff</code>，因为这就是我们发送数据的方式(如上所述)。但是如果它被拒绝，我们只想在控制台中记录错误。</strong></li><li id="0ba4" class="mq mr hi jd b je mz jh na lh nb lj nc ll nd jw mv mw mx my bi translated"><strong class="jd hj">功能定义。</strong> <em class="jc">注意:使用jQuery、Node.js和其他成熟的web开发工具有很多方法可以做到这一点，但我不是一个成熟的web开发人员——我只是一个数据科学家。</em>在这个函数中，我们创建一个<code class="du lo lp lq lr b">XMLHttpRequest</code>对象，然后使用函数定义的其余部分来定义它的属性:(1)做什么<code class="du lo lp lq lr b">.onreadystatechange</code>，(2)如何<code class="du lo lp lq lr b">.open</code>请求，(3)将什么<code class="du lo lp lq lr b">.setRequestHeader</code>发送给<code class="du lo lp lq lr b">.send</code>，以及如何发送(即使用<code class="du lo lp lq lr b">JSON.stringify</code>并将数据放入<code class="du lo lp lq lr b">{"json_payload": data}</code>)。使用<code class="du lo lp lq lr b">onreadystatechange</code>，函数将返回<em class="jc">一个<code class="du lo lp lq lr b">.responseText</code>的承诺</em>如果承诺是<code class="du lo lp lq lr b">resolve</code> d，或者一个<code class="du lo lp lq lr b">.status</code>的日志如果承诺是<code class="du lo lp lq lr b">reject</code> ed。</li></ol><h1 id="4079" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">一个例子</h1><p id="bbd8" class="pw-post-body-paragraph ja jb hi jd b je lf ij jg jh lg im jj lh li jm jn lj lk jq jr ll lm ju jv jw hb bi translated">差不多就是这样！如果你想看看这个框架的一个工作示例，请查看Python Flask App <a class="ae ln" href="https://github.com/ltjds/gcp_apps/tree/master/worldbank" rel="noopener ugc nofollow" target="_blank">代码</a>中托管在GAE的<a class="ae ln" href="https://ltjds.github.io/post/d3pds_2/" rel="noopener ugc nofollow" target="_blank"> D3可视化</a>，以及可视化本身的<a class="ae ln" href="https://github.com/ltjds/blog/blob/master/static/js/d3pds/d3pds_4.js" rel="noopener ugc nofollow" target="_blank"> JavaScript代码</a>。</p><blockquote class="ix iy iz"><p id="40b4" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">就像我之前说的，这个应用程序需要一点时间来加载和运行，但是一旦它启动并运行，一切都很好。</p></blockquote><p id="2bb7" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj lh jl jm jn lj jp jq jr ll jt ju jv jw hb bi translated">感谢阅读，希望有所帮助！如果你看到我可以改进的地方，请告诉我！</p></div></div>    
</body>
</html>