<html>
<head>
<title>The Python logging cheatsheet. Easy and fast ways to get logging done in Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python日志记录清单。用Python实现日志记录的简单快捷的方法。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-python-logging-cheatsheet-easy-and-fast-way-to-get-logging-done-in-python-aa3cb99ecfe8?source=collection_archive---------5-----------------------#2020-07-20">https://medium.com/analytics-vidhya/the-python-logging-cheatsheet-easy-and-fast-way-to-get-logging-done-in-python-aa3cb99ecfe8?source=collection_archive---------5-----------------------#2020-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有良好的日志对于监控应用程序、了解生产行为和捕获错误至关重要。python中的日志制作得很好，也有很好的文档记录。然而，有时你只是需要快速完成工作，而你只是没有时间去阅读<a class="ae jd" href="https://docs.python.org/3/howto/logging.html" rel="noopener ugc nofollow" target="_blank">优秀但相当长的官方文档</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a5153bb899b16438fc8c4464b4b3037a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K7gZxIrtQKo-N6Eu"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">日志记录对于您了解应用程序的行为非常重要，并且有助于IT运营拥有一个专用的控制面板来快速监控和分析应用程序问题。</figcaption></figure><p id="e486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将尝试找出快速的方法来提高日志记录的效率。在我们开始之前，有一些关于python日志的基本术语:</p><ul class=""><li id="b7ac" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><strong class="ih hj"> Loggers </strong>:提供几种方法允许应用程序运行时记录日志的主要参与者。</li><li id="2a36" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><strong class="ih hj">处理器</strong>:它们接收你的日志信息，并将它们发送到特定的位置，比如文件或控制台。</li><li id="883f" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">格式化程序:它们让你的日志以你想要的方式出现，以你可以定义的特定格式出现</li></ul><p id="4353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事不宜迟，让我们直接进入主题，获取一些快速方法，让您的python应用程序立即登录。</p><h1 id="8694" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">场景1:我有一个简单的应用程序，我需要设置一些基本的日志文件</h1><p id="3740" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">为简单的应用程序完成日志记录的最快方法是使用<a class="ae jd" href="https://docs.python.org/3/library/logging.html#logging.basicConfig" rel="noopener ugc nofollow" target="_blank"> logging.basicConfig </a>，它将创建一个StreamHandler(和一个FileHandler，如果我们指定了文件名)并将其添加到根日志记录器。<br/>配置如下:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="d123" class="lq kj hi lm b fi lr ls l lt lu"><em class="lv">import </em>logging<br/>logging.basicConfig(filename='my_log_file.log',level=logging.INFO)</span></pre><p id="0540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后按如下方式使用它:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="7005" class="lq kj hi lm b fi lr ls l lt lu"><em class="lv">import </em>logging<br/><em class="lv">from </em>time <em class="lv">import </em>sleep<br/><br/><br/><em class="lv">def </em>setup_logger():<br/>    logging.basicConfig(filename='my_log_file.log', level=logging.INFO)<br/><br/><br/><em class="lv">def </em>my_app_logic():<br/>    logging.info("Just entered the function")<br/>    sleep(0.1)<br/>    logging.info("Just after the sleep")<br/>    <em class="lv">try</em>:<br/>        res = 1 / 0<br/>    <em class="lv">except ZeroDivisionError</em>:<br/>        logging.exception("Attempted division by zero")<br/><br/><br/><em class="lv">if </em>__name__ == '__main__':<br/>    setup_logger()<br/>    my_app_logic()</span></pre><p id="991d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在我们的<em class="lv"> my_log_file.log </em>文件中产生以下输出:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="edd0" class="lq kj hi lm b fi lr ls l lt lu">INFO:root:Just entered the function<br/>INFO:root:Just after the sleep<br/>ERROR:root:Attempted division by zero<br/>Traceback (most recent call last):<br/>  File "/xxxx/simple_application.py", line 14, in my_app_logic<br/>    res = 1 / 0<br/>ZeroDivisionError: division by zero</span></pre><p id="7995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您还想显示时间，只需添加如下格式:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="e8b3" class="lq kj hi lm b fi lr ls l lt lu">logging.basicConfig(filename='my_log_file.log', format='%(asctime)s - %(message)s', level=logging.INFO)</span></pre><p id="80ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会将日志文件中的输出消息更改为:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="b99c" class="lq kj hi lm b fi lr ls l lt lu">2020-07-20 17:05:29,686 - Just entered the function<br/>2020-07-20 17:05:29,790 - Just after the sleep<br/>2020-07-20 17:05:29,790 - Attempted division by zero<br/>...</span></pre><p id="c7aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时使用</strong>:简单的应用程序，你只需要在没有太多模糊的情况下完成一些日志记录。最少使用外部库，并且不需要对如何执行日志记录进行太多控制。</p><p id="6b3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时不使用</strong>:当您需要对如何执行日志记录或任何多进程应用程序进行细粒度控制时。</p><h1 id="a198" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">场景2:我有一个单线程/多线程应用程序，它正在使用几个库，我想完成一些日志记录</h1><p id="364e" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">如果您的应用程序开始变得稍微复杂一些，并且您需要对日志进行更多的控制，我们应该避免使用根日志记录器，相反，让我们创建自己的日志记录器，如下所示:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="2068" class="lq kj hi lm b fi lr ls l lt lu">logger = logging.getLogger('non_simple_example')</span></pre><p id="7c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们添加处理程序来将日志发送到控制台和/或文件，格式化程序来指定我们喜欢的日志记录格式:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="59b9" class="lq kj hi lm b fi lr ls l lt lu"><em class="lv"># create console handler and set level to info<br/></em>stream_handler = logging.StreamHandler()<br/>stream_handler.setLevel(logging.INFO)<br/><br/><em class="lv"># create file handler and set level to info<br/></em>file_handler = logging.FileHandler(filename='my_log_name.log')<br/>file_handler.setLevel(logging.DEBUG)<br/><br/><em class="lv"># create formatter<br/></em>formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<br/><br/><em class="lv"># add formatters to our handlers<br/></em>stream_handler.setFormatter(formatter)<br/>file_handler.setFormatter(formatter)<br/><br/><em class="lv"># add Handlers to our logger<br/></em>logger.addHandler(stream_handler)<br/>logger.addHandler(file_handler)</span></pre><p id="79f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在整个应用程序中使用logger，例如:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="6754" class="lq kj hi lm b fi lr ls l lt lu">logger.info("Info message")<br/>logger.debug("Debug message")</span></pre><p id="cb6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将根据日志级别和处理程序配置将事情记录到控制台/文件中。在前面的例子中，文件处理程序有一个调试级别，而控制台处理程序有一个信息级别。这意味着具有调试级别的每个日志不会显示在控制台中，但会显示在日志文件中。</p><p id="16de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是控制台输出:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="2a86" class="lq kj hi lm b fi lr ls l lt lu">2020–07–20 17:13:34,439 — non_simple_example — INFO — Info message</span></pre><p id="60ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及日志文件中的以下输出:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="c63d" class="lq kj hi lm b fi lr ls l lt lu">2020-07-20 17:13:34,439 - non_simple_example - INFO - Info message<br/>2020-07-20 17:13:34,439 - non_simple_example - DEBUG - Debug message</span></pre><p id="e99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此找到完整代码<a class="ae jd" href="https://gist.github.com/arocketman/5f9e2043425c57d17676af1407bfe1e1" rel="noopener ugc nofollow" target="_blank">。<br/>这种方法在多线程应用中也能很好地工作，事实上日志模块是<strong class="ih hj">线程安全的</strong>。然而，对于需要更多努力的多进程日志来说，这是行不通的。</a></p><p id="67a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时使用</strong>:当您需要对日志进行更多控制，并且希望避免使用/污染root logger时。</p><p id="5952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时不用</strong>:如果你有多个进程。</p><h1 id="e62c" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">场景3:我的日志越来越大，怎么办？</h1><p id="9827" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">非常简单，从简单的文件处理器切换到更复杂的<a class="ae jd" href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.RotatingFileHandler" rel="noopener ugc nofollow" target="_blank">旋转文件处理器</a>，当日志文件达到特定大小时，它将切换日志文件:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="3484" class="lq kj hi lm b fi lr ls l lt lu">handler = RotatingFileHandler('my_log.log', maxBytes=1000, backupCount=10)</span></pre><p id="e786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在每天/每周/每月结束时切换日志，您可以使用<a class="ae jd" href="https://docs.python.org/3/library/logging.handlers.html#logging.handlers.TimedRotatingFileHandler" rel="noopener ugc nofollow" target="_blank">TimedRotatingFileHandler</a>:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="bee1" class="lq kj hi lm b fi lr ls l lt lu">handler = TimedRotatingFileHandler(filename="my_log.log", when="midnight")</span></pre><h1 id="c8c4" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">场景4:我有一个多进程应用程序，我需要记录日志。</h1><p id="0da4" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">从不同的进程中记录日志并不简单，这需要一些额外的工作。我建议不要采用快速而肮脏的解决方案，而应该通读官方文档<a class="ae jd" href="https://docs.python.org/3/howto/logging-cookbook.html#logging-to-a-single-file-from-multiple-processes" rel="noopener ugc nofollow" target="_blank">中的内容，该文档详细解释了正在发生的事情以及应对挑战的策略。</a></p><p id="5cc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这个问题的一个有趣的方法是使用一个<a class="ae jd" href="https://docs.python.org/3/library/logging.handlers.html#watchedfilehandler" rel="noopener ugc nofollow" target="_blank"> WatchedFileHandler </a>并使用一个外部实用程序如<a class="ae jd" href="https://linux.die.net/man/8/logrotate" rel="noopener ugc nofollow" target="_blank"> logrotate </a>来根据配置实际旋转日志。</p><h1 id="658a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="a440" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">这绝不是一个详尽的日志指南，而是一个快速而简单的完成日志记录的方法。<br/>要了解更多信息和详细指南，请参考<a class="ae jd" href="https://docs.python.org/3/howto/logging-cookbook.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，其中也提供了几个例子来让您体验一下。</p></div></div>    
</body>
</html>