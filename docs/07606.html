<html>
<head>
<title>Asynchronous Web Server in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步Web服务器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/asynchronous-web-server-in-python-eac521fba518?source=collection_archive---------6-----------------------#2020-07-01">https://medium.com/analytics-vidhya/asynchronous-web-server-in-python-eac521fba518?source=collection_archive---------6-----------------------#2020-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8639" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何使用aiohttp和aiopg用Python创建一个只有1个脚本文件的简单异步web服务器</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e76556f6860649ef6d932f29eada6294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EwkUF_XSgN9c3lZ1"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">克里斯托弗·高尔在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9c4f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在过去的一年里，我一直在从事一个项目，该项目需要异步web服务器来同时处理数千个用户连接，并向用户实时广播数据。面对学习异步编程和弄清楚如何创建异步web服务器的困难时期，我决定分享如何创建它。</p><p id="8c3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文主要关注使用<code class="du kk kl km kn b">aiohttp</code>和<code class="du kk kl km kn b">aiopg</code>的代码结构。我的目的是揭示异步web服务器的结构是什么样子的。如果您想深入了解Python中的异步，可以点击<em class="ko">同步与异步</em>部分的链接。</p><h1 id="b1fc" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">同步与异步</h1><p id="775d" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">同步程序是一个逐个执行每个任务的程序。它只在另一个任务完成后才执行另一个任务。如果有一个步骤需要等待来自其他进程的返回值(例如，数据库查询、对其他API的请求)，它会阻塞程序，直到返回值可用，然后继续执行任务。之后，它执行另一个任务。</p><p id="cd70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，异步程序是并发执行任务<strong class="jq hj">的程序。</strong>表示当有一个步骤需要等待其他流程的返回值时，它会处理其他任务，并在返回值可用之前返回到该任务。这在我们有一个带有<strong class="jq hj"> I/O绑定</strong>的项目时很有用(一个有很多I/O进程的项目，比如处理很多请求并与数据库或其他服务交互的web服务器)。因此，web服务器可以有效地处理许多请求，最大化I/O进程的等待时间。</p><p id="b462" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Python中，我们可以使用<code class="du kk kl km kn b">asyncio</code>库创建异步应用程序。它使用<code class="du kk kl km kn b">async</code>将一个函数转换成一个协程(一个可以在进程中暂停的特殊函数)。每当遇到<code class="du kk kl km kn b">await</code>关键字时，协程将暂停进程，计算机将处理其他协程，然后当等待进程的返回值可用时，返回暂停的协程。你可以在这里阅读更多关于<code class="du kk kl km kn b">asyncio</code> <a class="ae jn" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">的细节</a></p><h1 id="2e92" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">初始化web服务器</h1><p id="35d9" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">我们将用<code class="du kk kl km kn b">aiohttp</code> &amp; <code class="du kk kl km kn b">aiopg</code>创建一个web服务器，这是一个异步库，用于创建web服务器并使用<code class="du kk kl km kn b">asyncio</code>与数据库交互。这个web服务器有2个REST APIs，用于用户登录和用户注销，还有1个PostgreSQL数据库引擎。首先，我们需要使用aiohttp初始化web服务器应用程序，并使用aiopg创建一个数据库引擎。</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="818b" class="lq kq hi kn b fi lr ls l lt lu"><em class="ko"># Built-in library<br/>import </em>json<br/>from uuid import uuid4</span><span id="3182" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko"># Third-party library<br/>from </em>aiohttp <em class="ko">import </em>web<br/><em class="ko">from </em>aiopg.sa <em class="ko">import </em>create_engine</span><span id="0922" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">class </em>WebServer:<br/>    <em class="ko">def </em>__init__(<em class="ko">self</em>, **kwargs: dict):<br/>        <em class="ko">self</em>.app = web.Application()<br/>        <em class="ko">self</em>.host = kwargs['webserver']['host']<br/>        <em class="ko">self</em>.port = kwargs['webserver']['port']<br/>        <em class="ko">self</em>.dbConf = kwargs['db']<br/>        <em class="ko">self</em>.dbEngine = None<br/>        <em class="ko">self</em>.sessionToUser = {}<br/>        self.userToSession = {}</span></pre><p id="c82a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用面向对象编程(OOP)范例，因为我们需要将web服务器应用程序、数据库引擎和用户会话封装在一个地方。它需要一个配置字典，可以是作为字典加载的JSON文件，也可以是硬编码的字典。接下来，我们创建用于创建数据库引擎的<code class="du kk kl km kn b">initializer</code>方法，设置API路由，并返回web应用程序。</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="77e3" class="lq kq hi kn b fi lr ls l lt lu"><em class="ko">async def </em>initializer(<em class="ko">self</em>) -&gt; web.Application:<br/>    <em class="ko"># Create a database engine<br/>    self</em>.dbEngine = <em class="ko">await </em>create_engine(<br/>        user=<em class="ko">self</em>.dbConf['user'],<br/>        password=<em class="ko">self</em>.dbConf['password'],<br/>        host=<em class="ko">self</em>.dbConf['host'],<br/>        database=<em class="ko">self</em>.dbConf['database']<br/>    )</span><span id="ab74" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko"># Setup routes and handlers</em><br/>    <em class="ko">self</em>.app.router.add_post('/user', <em class="ko">self</em>.loginHandler)<em class="ko"><br/>    self</em>.app.router.add_delete('/user', <em class="ko">self</em>.logoutHandler)<br/>    <br/>    return self.app</span></pre><p id="dea4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们通过使用需要用户、密码、主机和数据库参数的<code class="du kk kl km kn b">create_engine</code>协程来创建数据库引擎。该引擎将用于获取到数据库的连接并执行查询。我们还为具有用于处理登录请求的<code class="du kk kl km kn b">self.loginHandler</code>回调的<code class="du kk kl km kn b">POST</code>方法和具有用于处理注销请求的<code class="du kk kl km kn b">self.logoutHandler</code>回调的<code class="du kk kl km kn b">DELETE</code>方法设置了路由<code class="du kk kl km kn b">/user</code>。</p><h1 id="0fc2" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">创建请求处理程序</h1><p id="0085" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">接下来，我们需要在<code class="du kk kl km kn b">WebServer</code>类中创建<code class="du kk kl km kn b">loginHandler</code>方法和<code class="du kk kl km kn b">logoutHandler</code>方法。</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="8b7f" class="lq kq hi kn b fi lr ls l lt lu"><em class="ko">async def </em>loginHandler(<em class="ko">self</em>, request: web.Request) -&gt; web.Response:<br/>    <em class="ko">try</em>:<br/>        # loads dictionary from JSON-formatted request body<br/>        data = <em class="ko">await </em>request.json()<br/>    <em class="ko">except </em>ValueError:<br/>        <em class="ko">return </em>web.HTTPBadRequest()</span><span id="dfd8" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">    if </em>'username' <em class="ko">not in </em>data <em class="ko">or </em>'password' <em class="ko">not in </em>data:<br/>        <em class="ko">return </em>web.HTTPUnprocessableEntity()</span><span id="68b4" class="lq kq hi kn b fi lv ls l lt lu">    username = data['username']<br/>    password = data['password']<br/>    rawSql = 'SELECT password = %s verified FROM users where username = %s;'<br/>    params = (password, username)</span><span id="4d2d" class="lq kq hi kn b fi lv ls l lt lu">    query = <em class="ko">None<br/>    async with self</em>.dbEngine.acquire() <em class="ko">as </em>dbConn:<br/>        <em class="ko">async for </em>row <em class="ko">in </em>dbConn.execute(rawSql, params):<br/>            query = dict(row)</span><span id="0736" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">    if </em>query <em class="ko">is None</em>:<br/>        <em class="ko">return </em>web.HTTPUnauthorized()</span><span id="2c84" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">    if not </em>query['verified']:<br/>        <em class="ko">return </em>web.HTTPUnauthorized()</span><span id="14af" class="lq kq hi kn b fi lv ls l lt lu">    sessionId = str(uuid4())<br/>    <em class="ko">self</em>.userToSession[username] = sessionId<br/>    <em class="ko">self</em>.sessionToUser[sessionId] = username<br/>    response = {'session_id': sessionId}</span><span id="984a" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">return </em>web.json_response(response)</span></pre><p id="b875" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">loginHandler</code>方法接受JSON格式的请求体。在处理它之前，我们需要检查请求体。然后，我们使用<code class="du kk kl km kn b">async with</code>和<code class="du kk kl km kn b">async for</code>语句向数据库验证用户名-密码组合。<code class="du kk kl km kn b">async with</code>语句是一个上下文管理器。在这种情况下，当查询过程完成时，它会自动断开数据库连接。<code class="du kk kl km kn b">async for</code>语句用于异步迭代可迭代对象。在这种情况下，它用来异步地逐行查询数据库中的数据。因此，web服务器可以在查询过程中处理其他请求。然后，如果验证过程成功，我们通过使用<code class="du kk kl km kn b">uuid</code>库创建一个惟一的会话ID，在<code class="du kk kl km kn b">sessionToUser</code>和<code class="du kk kl km kn b">userToSession</code>属性中将它与用户进行映射，并以JSON格式将其附加到响应对象。</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="72a5" class="lq kq hi kn b fi lr ls l lt lu"><em class="ko">async def </em>logoutHandler(<em class="ko">self</em>, request: web.Request) -&gt; web.Response:<br/>    sessionId = dict(request.headers).get('Authorization')</span><span id="1fd2" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">    if </em>sessionId <em class="ko">not in self</em>.sessionToUser:<br/>        <em class="ko">return </em>web.HTTPUnauthorized()</span><span id="1366" class="lq kq hi kn b fi lv ls l lt lu">    username = <em class="ko">self</em>.sessionToUser[sessionId]</span><span id="6283" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">    self</em>.sessionToUser.pop(sessionId)<br/>    <em class="ko">self</em>.userToSession.pop(username)</span><span id="67bc" class="lq kq hi kn b fi lv ls l lt lu"><em class="ko">    return </em>web.HTTPOk()</span></pre><p id="1cd4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">logoutHandler</code>方法接受授权头中的会话ID。如果会话ID被web服务器识别，则web服务器将从内存中删除该会话ID。</p><h1 id="0787" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">运行web服务器</h1><p id="e07c" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">最后，我们需要创建运行web服务器的<code class="du kk kl km kn b">run</code>方法，并在主函数中实现<code class="du kk kl km kn b">WebServer</code>类。</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="7ea8" class="lq kq hi kn b fi lr ls l lt lu"><em class="ko">def </em>run(<em class="ko">self</em>):<br/>    web.run_app(<em class="ko">self</em>.initializer(), host=<em class="ko">self</em>.host, port=<em class="ko">self</em>.port)</span></pre><p id="3de6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在main函数中，我们只需要加载JSON配置文件，用它来构造<code class="du kk kl km kn b">WebServer</code>对象。然后使用<code class="du kk kl km kn b">run</code>方法运行<code class="du kk kl km kn b">WebServer</code>。</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="5609" class="lq kq hi kn b fi lr ls l lt lu"><em class="ko">if </em>__name__ == '__main__':<br/>    <em class="ko">with </em>open('config.json') <em class="ko">as </em>fp:<br/>        cfg = json.load(fp)</span><span id="32b2" class="lq kq hi kn b fi lv ls l lt lu">    webserver = WebServer(**cfg)<br/>    webserver.run()</span></pre><p id="06c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您想使用JSON文件进行配置，这里是JSON配置的样子:</p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="1889" class="lq kq hi kn b fi lr ls l lt lu">{<br/>  "webserver": {<br/>    "host": "localhost",<br/>    "port": 8000<br/>  },</span><span id="9204" class="lq kq hi kn b fi lv ls l lt lu">"db": {<br/>    "user": "&lt;user&gt;",<br/>    "password": "&lt;password&gt;",<br/>    "host": "&lt;host&gt;",<br/>    "database": "&lt;database&gt;"<br/>  }<br/>}</span></pre><h1 id="8bcc" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">最后的话</h1><p id="ab9f" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">就是这样！只有一个脚本文件，我们可以使用Python中的<code class="du kk kl km kn b">aiohttp</code>和<code class="du kk kl km kn b">aiopg</code>创建一个异步web服务器。本文中的代码可以作为项目的样板。希望这篇文章能帮助你入门异步编程。</p><p id="851e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">谢谢你，</p><p id="f02e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">伊克万·里兹基·努尔扎曼</p></div></div>    
</body>
</html>