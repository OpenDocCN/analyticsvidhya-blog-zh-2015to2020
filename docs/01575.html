<html>
<head>
<title>Hey Pandas, why you no fast loop?!?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘿熊猫，你为什么不快速循环？！？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hey-pandas-why-you-no-fast-loop-e7226ed97322?source=collection_archive---------1-----------------------#2019-11-01">https://medium.com/analytics-vidhya/hey-pandas-why-you-no-fast-loop-e7226ed97322?source=collection_archive---------1-----------------------#2019-11-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将你的循环速度提高X倍。</p><p id="e58d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速循环DataFrame对象的初学者指南。</p><p id="081b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一名日常数据科学家以一杯咖啡和两种强制性代码开始他的一天:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="15e0" class="jm jn hi ji b fi jo jp l jq jr">import pandas as pd<br/>import numpy as np</span></pre><p id="3bab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我们可能太熟悉<strong class="ih hj">熊猫</strong>的数据帧结构，但我们有时会忽略它提供的许多关键功能，以及引人注目但功能强大的<strong class="ih hj">熊猫。</strong>这篇文章是一个小小的尝试，帮助你熟悉熊猫和numpy的一些能力(<em class="js">显然仅限于循环</em>)</p><p id="8855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从一个简单的基于列值的分组例子开始。</p><p id="9435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该死。没有数据。让我们继续为这种情况创建一些虚拟数据和虚拟条件，生成整数作为一个人的年龄，我们将在一个新列中存储，比如“age_bucket”</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">10万会员的虚拟数据，完成！</figcaption></figure><p id="dde0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好一点了。现在，让我们假设在我们的数据集中有一些跨越人们年龄的支配规则如下:</p><blockquote class="ka"><p id="d5f7" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">“年龄范围”-&gt;“桶标签”</p><p id="a647" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">0–5--&gt;“婴儿”</p><p id="0964" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">6–20-&gt;“青少年”</p><p id="3de6" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">21–40--&gt;“成年早期”</p><p id="1376" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">41–80-&gt;“成年中期”</p><p id="12b6" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">≥81--&gt;“成年后期”</p></blockquote><p id="b16d" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">好了，现在我们有我们的条件，让我们循环它！</p><h1 id="8771" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">朴素循环</strong></h1><p id="bec0" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">如果我们使用一种非常简单的循环方式，</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">数据帧上的简单循环</figcaption></figure><p id="9b60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并计算到bucket的总计算时间(<a class="ae lr" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank"> %%timeit </a>)，我们得到如下结果:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es ls"><img src="../Images/42e46e21206e279de89081164243800d.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*Xdy0IDbiuy7T6TB2mnZrdw.png"/></div></figure><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/10c54a4aab3047cf832a90866c11b3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKXqvLHNiD3ZaZYGAZT-dg.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">朴素循环的计算时间</figcaption></figure><p id="90bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">(如果你的机器很小，请确保不要运行这段代码，因为计算运行时间需要5个小时。如果您想测试计算时间，我建议您将初始数据帧中的全部记录更改为1000或更小)</em></p><p id="a752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于仅仅10万年龄组来说不是很好，<strong class="ih hj">因为10万实际上是为良好的机器学习模型构建考虑的最小数据</strong>(大多数情况下为<em class="js"/>)。Pandas中的简单循环没有利用任何内置的优化(我们将在下面看到)，这使得它非常慢。让我们继续，看看熊猫的一个内置功能。</p><h1 id="a2b2" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">利用pd.df.iterrows() </strong></h1><p id="23f8" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated"><code class="du ma mb mc ji b"><a class="ae lr" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">pd.df.itterows()</strong></a></code>作为一对索引和与该索引相关联的对象的值，在DataFrame对象上迭代。例如，如果我们使用<code class="du ma mb mc ji b">itterows()</code>来检查一个对象，我们会得到以下输出:</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">使用itterows()检查对象</figcaption></figure><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="aadc" class="jm jn hi ji b fi jo jp l jq jr">person_age    40<br/>buckets         <br/>Name: 0, dtype: object</span></pre><p id="3499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du ma mb mc ji b">itterows()</code>循环遍历我们的数据帧来标记桶，</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">使用itterows()在DataFrame上循环</figcaption></figure><p id="34c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并计时，我们得到以下结果:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es md"><img src="../Images/03ff770b6ce354573dafbe2fa7165d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0psX7OJ3PhydhngGuIW6Ig.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">使用iterows在DataFrame上循环时的结果</figcaption></figure><p id="2629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与普通循环相比，我们刚刚增加了我们的循环<strong class="ih hj"> ~149倍</strong>。让我们看看是否可以进一步减少计算时间！</p><h1 id="bc60" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用<strong class="ak"> apply() </strong>进行循环</h1><p id="973b" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated"><code class="du ma mb mc ji b"><a class="ae lr" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">apply()</a></code>函数在特定轴的数据帧上循环，也就是说，它既可以在列(轴=1)上循环，也可以在行(轴=0)上循环。<code class="du ma mb mc ji b">apply()</code>比<code class="du ma mb mc ji b">iterrows()</code>好，因为它在Cython中使用了Python的C扩展。</p><p id="dd1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用apply和<code class="du ma mb mc ji b"><a class="ae lr" href="https://www.geeksforgeeks.org/python-lambda-anonymous-functions-filter-map-reduce/" rel="noopener ugc nofollow" target="_blank">lambda</a></code>函数以及<code class="du ma mb mc ji b">axis</code>参数，</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">apply()的自定义存储桶函数</figcaption></figure><p id="11bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后如下应用它，给我们以下结果:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es me"><img src="../Images/ae5156c8cdc533525ca032859b8d8d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKj8v1nBACFlTh77eV-8jA.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">带有lambda函数的df.apply()的结果</figcaption></figure><p id="1782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在以微秒为单位，在时间上使循环快了<strong class="ih hj"> ~1900倍</strong>。到目前为止，我们已经使用pandas <strong class="ih hj">矢量化在改进代码的计算时间方面取得了很大的进步。</strong></p><h1 id="e34d" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">熊猫矢量化</h1><p id="3048" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">事实上这很简单。矢量化会立即对整个数据帧进行操作，而不是对单个行进行操作。本质上，矢量化是对整个阵列执行操作的过程。在pandas的例子中，矢量化应用于完整的列，作为一个序列传递给函数。以下是我们在熊猫案例中的矢量化部分:</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">熊猫矢量化，其中输入是来自数据帧的一系列数据</figcaption></figure><p id="d2a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在函数<code class="du ma mb mc ji b">pd_vector</code>中，年龄是数据帧(<em class="js"> df </em>)中的一个序列。在传递一个序列作为输入时，pandas使用了许多可用于矢量化函数的内置优化，同时对整个序列执行操作<strong class="ih hj"/>。</p><p id="ba00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算该版本的矢量化形式的计算时间，我们得到以下结果:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/13b4572ab48d467aaae93c227e69e290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okRQVV1eslV4nYKOBsDQqg.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">熊猫矢量化的结果</figcaption></figure><p id="7ddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，使用熊猫的矢量化，我们从我们的<code class="du ma mb mc ji b">apply()</code>方法中获得了大约<strong class="ih hj">到39倍</strong>的循环速度，并且比我们的标准循环快了<strong class="ih hj">到82608倍</strong></p><p id="a66a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看我们是否能把它系得更紧！</p><h1 id="ea03" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">Numpy矢量化</h1><p id="b743" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">虽然pandas使用series对象进行矢量化，但我们可以简单地将series对象从series调整到array，这样速度会更快。通过去除所有额外的开销，如索引、数据类型、数据格式等，它变得更快。但是，应该小心使用numpy矢量化，也就是说，如果系列索引不是最重要的，那么我们肯定可以继续使用numpy矢量化来进一步减少计算时间！</p><p id="98a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您喜欢将序列对象转换为数组，那么将序列对象转换为数组是非常简单的，如果完成了，我们将看到以下结果:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mf"><img src="../Images/c57f9b69ad99fdd1125a6ce8d325141c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlYfLIc-2KB1t1rqf9lFMQ.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">Numpy矢量化循环</figcaption></figure><p id="6ff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，现在从我们最初对数据帧的简单循环开始，仅仅10万次条件循环总共花费了<strong class="ih hj"> ~38分钟</strong>，我们现在处于<strong class="ih hj"> 14.7毫秒</strong>，速度提高了大约<strong class="ih hj"> ~155102倍</strong>。</p><h2 id="a6b5" class="jm jn hi bd kq mg mh mi ku mj mk ml ky iq mm mn lc iu mo mp lg iy mq mr lk ms bi translated">我们当然可以到此为止，但是如果速度是你真正想要的，那么我们仍然可以使用"<strong class="ak"> numpy" </strong>更进一步</h2><h1 id="5e92" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">削减中间人</h1><p id="67c0" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">到目前为止，我们所有的循环都是通过将我们的pandas行或系列转换成某种形式来构建和实现的，然后使用内置的优化。现在，我们准备砍掉我们的中间人(熊猫，而不是人🙊).这就是我们完全依赖从一开始就导入的一个模块的地方。</p><p id="2fe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是要在循环中使用<code class="du ma mb mc ji b">numpy</code>,你必须弄脏你的手(同样，只是弄脏代码😅).下面是我曾经读过的一段话，我希望这段话也能激励你去写这样的代码:</p><blockquote class="ka"><p id="200e" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">不要害怕写复杂的代码，因为有时候写得最好的代码也没有优化得太好！</p></blockquote><p id="129f" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">也就是说，我们的<code class="du ma mb mc ji b">numpy</code>代码看起来会很可怕，但是相信我，失去所有的美感是值得的。</p><h2 id="3361" class="jm jn hi bd kq mg mh mi ku mj mk ml ky iq mm mn lc iu mo mp lg iy mq mr lk ms bi translated">使用np.where()进行循环</h2><p id="bc73" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated"><code class="du ma mb mc ji b">np.where()</code>有时是大小写特定的，但是如果你有一个if-else循环，它几乎总是可以作为更快代码的最佳选择。下面是np.where() <a class="ae lr" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="noopener ugc nofollow" target="_blank">文档</a>的一个片段，解释了它是如何工作的:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mt"><img src="../Images/ba12fa9d599e06963326baf4f32b564b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7AadSA9sk2Lxp8xQGevyA.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">np.where doc</figcaption></figure><p id="0696" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以基本上，它只是根据我们提供的条件从“x”或“y”返回元素。让我们继续，看看我们的代码将如何使用仅仅<code class="du ma mb mc ji b">np.where()</code>函数，作为一个循环使用:</p><figure class="jd je jf jg fd jt"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">使用np.where的Numpy循环</figcaption></figure><p id="0769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试这个np.where循环的计算时间，我们得到以下结果:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mu"><img src="../Images/b378f3f6b717d415dddb0f1b311f3d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCOHQ4eSCW6xVQ9tjWNe3Q.png"/></div></div></figure><p id="8865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我们现在在<strong class="ih hj"> 11.6 ms </strong>，从<strong class="ih hj"> 38分钟开始，</strong>通过<strong class="ih hj"> ~196551 </strong>提高代码速度。</p><p id="31ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即便如此，这还不是结束。你仍然可以使用<a class="ae lr" href="https://cython.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Cython </strong> </a>自定义函数、<a class="ae lr" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.digitize.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">NP . digitize()</strong></a><strong class="ih hj">、</strong>等多种优化来获得微秒级的运行时！</p><p id="410b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，总的来说，循环遍历数据帧的一般首选顺序(至少我是这样认为的)如下:</p><ol class=""><li id="b88b" class="mv mw hi ih b ii ij im in iq mx iu my iy mz jc na nb nc nd bi translated"><strong class="ih hj">矢量化</strong> {numpy}</li><li id="9933" class="mv mw hi ih b ii ne im nf iq ng iu nh iy ni jc na nb nc nd bi translated"><strong class="ih hj">矢量化</strong>{熊猫}</li><li id="5560" class="mv mw hi ih b ii ne im nf iq ng iu nh iy ni jc na nb nc nd bi translated"><strong class="ih hj">PD . df . apply()</strong>{使用lambda函数}</li><li id="a4b3" class="mv mw hi ih b ii ne im nf iq ng iu nh iy ni jc na nb nc nd bi translated"><strong class="ih hj"> pd.df.iterrows() </strong></li><li id="c047" class="mv mw hi ih b ii ne im nf iq ng iu nh iy ni jc na nb nc nd bi translated"><strong class="ih hj">基本循环</strong>{基本从不}</li></ol><p id="98de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在某一天可能遇到的测试用例中使用上述循环方法，我会非常高兴！😸</p><h1 id="40a9" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">来源:</h1><p id="dfbc" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated"><a class="ae lr" href="https://docs.scipy.org/doc/numpy/reference/" rel="noopener ugc nofollow" target="_blank">https://docs.scipy.org/doc/numpy/reference/</a></p><p id="472d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lr" href="https://pandas.pydata.org/pandas-docs/stable/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/stable/</a></p><p id="b5f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lr" href="https://stackoverflow.com/questions/1422149/what-is-vectorization" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1422149/什么是矢量化</a></p><p id="f2dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lr" href="https://en.wikipedia.org/wiki/Array_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Array_programming</a></p><p id="46ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果你觉得帖子中有任何错误，我将非常乐意纠正它们。否则，如果你喜欢这篇文章，并从这篇文章中学到了一些好的优化方法，那么我在这里的工作就完成了！</p></div></div>    
</body>
</html>