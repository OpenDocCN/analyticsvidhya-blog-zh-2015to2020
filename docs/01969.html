<html>
<head>
<title>Multiple Imputation: a Better Way to Fill NAs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多重插补:填补NAs的更好方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multiple-imputation-a-better-way-to-fill-nas-a8b9ec811e1f?source=collection_archive---------12-----------------------#2019-11-24">https://medium.com/analytics-vidhya/multiple-imputation-a-better-way-to-fill-nas-a8b9ec811e1f?source=collection_archive---------12-----------------------#2019-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d63555cdfea7429f14223cfcffa22142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxG36_b6DZedxpgEylEKng.png"/></div></div></figure><p id="00d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缺失值是数据科学生活中的一个事实，处理它们总是需要判断。是时候放弃功能了。删除行是有时间的。粗分类是有时间的。是否真的有时间用平均值/中值/众数填写多个NAs？我从未被说服:它扭曲了变量的分布——拜托，我们是数据科学家！一定有更好的方法。</p><p id="f7b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，这是一个反问句——这不是一个新问题，还有其他方法。今天，我将讨论一种这样的方法，即多重插补，由格雷厄姆和斯查费在<a class="ae jo" href="https://www.amazon.com/gp/product/0761908862/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;psc=1" rel="noopener ugc nofollow" target="_blank">小样本研究的统计策略</a>中提出(这是有意义的，当你有100个数据点要处理时，NAs可能是一个生死攸关的问题)。</p><p id="221c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前提是使用您必须使用的变量来对NAs的功能进行建模，但是，正如作者所指出的，在此止步会有两个问题:</p><ol class=""><li id="c2ed" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">你的估算模型可能完全不可信。</li><li id="0615" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">其输出将是完全同质的/缺乏实际数据的自然变化。</li></ol><p id="2a2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于问题一，有两件事需要考虑:偏差和方差。如果模型有偏差，除了尝试不同的估计量之外，你没有什么可以做的，但方差是另一回事-我们知道该怎么做:装袋(即，取用替换绘制的数据集子集的几个模型的输出的平均值)。</p><p id="ab88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">装袋中使用的模型数量是数据集缺失百分比的函数，也是真实分布和估算分布之间的相似性百分比的函数，您可以使用以下公式找到它:</p><blockquote class="kd ke kf"><p id="85f1" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated"><strong class="is hj">百分比_缺失/((1/Var _偏差_公差)-1) </strong></p></blockquote><p id="292e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有必要在容忍水平上走极端，边际效应递减肯定是有效的——我倾向于0.97。</p><p id="b5a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于同质性问题，解决方法很简单:添加噪声。具体来说，根据插补模型为该要素的非缺失值生成的残差，向插补模型的输出添加随机残差。如果你觉得残差的分布看起来有道理，那就计算一下，然后随机给每个输出加一。否则，如果看起来有一些奇怪的事情正在发生，并且分布看起来可疑(例如，它意外地是双峰的，可能因为缺失不是随机的)，则根据它们的均值和方差从高斯分布中提取它们。</p><p id="ac80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，还有两件小事需要考虑:</p><ol class=""><li id="714b" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">只取整数值的舍入变量。</li><li id="c20c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">裁剪具有最小值和/或最大值的变量范围。</li></ol><p id="68a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">瞧啊。理论上听起来很合理吧？让我们通过在经典的Iris数据集上测试这个方法来看看它在实践中是如何做的。</p><p id="22f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们比较一下在不同NAs级别上通过填充平均值和插补来处理萼片长度列中缺失值的情况:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/f0dd47997fb85f9eb6ebb281f54e3fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d31M_SsmWc7tmUfEllNOFA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">缺少15%的值</figcaption></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/bab1877456ba8202aeed8db15739a947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8vea5l0Z-f-erqj_ShWNQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">25%的值缺失</figcaption></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/cbcffc743bcf7dbbe34d1734089fb4d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCQIqzMyDM4tyOnmUWTC8A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">33%的缺失值</figcaption></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/aaa02c8cf7d29af7e3025ac728c4ef34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnXrTwZf_4x1p-qlVn-MLQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">50%缺失值</figcaption></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/5c7d9019bbd9b4e3a36e408f82601ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgyt7i98W_Zq0pmQ6xLHdg.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">75%的缺失值</figcaption></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/eacc841cd91c9a14566ff2ed74ac6563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SymEMTGCNZ0LWn6zleyPyQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">90%的缺失值</figcaption></figure><p id="b4ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">眼球测试说明了一切。简单地填充平均值会扭曲分布，使其在15%缺失值的相对适中的水平上看起来像人工高斯分布，并且事情会从那里变得更糟，而估算的分布在每个水平上都保持原始分布的总体特征。</p><p id="68de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">统计数据证实了这一点:我们可以使用Kullback-Leibler散度来确定两个分布之间的相似性(越高越不相似)，在每种情况下，原始分布和均值填充分布之间的KL散度都是其估算对应物的倍数(准确地说，是2.6到6.6倍)。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/62f91539ddcec613efaa002a30b35480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QYn6eDdAZtnRypoFxaw9w.png"/></div></div></figure><p id="bcf7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，有趣的是，这两列的值都很低——这是否意味着这两种方法的性能在实践中不会有实质性的差异？让我们以鸢尾属物种为目标，通过在五重交叉值的简单逻辑回归中使用它来找出答案。</p><p id="6650" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(作为参考，在一个简单的回归中，没有NAs的原始“萼片长度”列给出的准确度为0.6867。)</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/2a5e319c4cfe283c98a9535d74e92b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClKLg_VsRbYNQ7n4X4Dp4w.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">虹膜类型分类准确度</figcaption></figure><p id="c768" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多重插补得到证实。对于每一级NAs，估算列的准确性更高，并且随着缺失百分比上升，它更多地停留在原始的水平，而平均填充下降到比机会好不了多少。</p><p id="1ee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">游戏，设置和匹配…有点。完全公开:当我们将数据集中其他可用的特性用于多重逻辑时，会发生一些奇怪的事情。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/b2ecb366e379d0dc0ab52a52b90ebb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fH-gaiVoo03NJYaR91GKww.png"/></div></div></figure><p id="78e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两者之间没有明显的区别。这是怎么回事？为了找到答案，我对原始(即无NA)数据进行了回归，得到了0.9600的准确度分数。把“萼片长度”一栏完全去掉，你仍然得到0.9533。</p><p id="20d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这是有意义的(并且，我希望，在看起来像一个灌篮结果之后包括这一部分的事实也是有意义的——我正在说明一个观点)。我们已经接近了这些数据所能告诉我们的上限，多重插补并不是对缺失值的神奇修复:你不是在丰富你的数据集——只是在填充它。因此，当你有其他好的预测时，可能是时候放弃列了。然而，如果你确实需要依赖NA列，我认为选择是明确的:每次都进行多重插补。</p><p id="f579" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">干杯！如果我已经向你推销了这种方法，这里有到我的python实现的链接。它已经完全加载，能够处理数值和分类特性，只是要确保在数据帧中保持分类列为字符串。</p></div></div>    
</body>
</html>