<html>
<head>
<title>Historical load into Ingestion Time partitioned BigQuery table using Dataflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用数据流将历史加载到摄取时间分区的BigQuery表中</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/historical-load-into-ingestion-time-partitioned-bigquery-table-using-dataflow-3242b3f2739?source=collection_archive---------3-----------------------#2019-12-07">https://medium.com/analytics-vidhya/historical-load-into-ingestion-time-partitioned-bigquery-table-using-dataflow-3242b3f2739?source=collection_archive---------3-----------------------#2019-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="38a6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.介绍</h1><p id="12b6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我目前的组织中，我们严重依赖Google Cloud的服务来运行我们的大规模数据管道。我们使用PubSub每秒接收近12万个事件，并将它们存储到BigQuery中，以满足分析和报告需求。我们从我们的移动应用和网站获取点击流数据，并通过BigQuery以尽可能低的延迟查询这些数据。点击流数据是用户行为的最佳指标，对几个下游流程至关重要。</p><p id="6199" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们从mobile和web SDK接收JSON事件，过去我们将复杂的数据类型(数组和嵌套对象)作为字符串存储在BigQuery列中。因此，所有下游流程都必须在BigQuery或应用程序中解析这些列值，以获取它们感兴趣的值。这导致了依赖这些数据的不同团队之间的代码和工作的大量重复。将这些复杂的字段存储为字符串也意味着没有对其中的值进行验证，这也是一个数据质量问题。</p><p id="2435" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最近，我们决定利用BigQuery的记录和重复类型来存储这些值，以保持数据的正确形状。我们调整了数据流管道，开始解析复杂类型，并将其推送给BigQuery。由于新模式与旧表不兼容，我们必须用新模式创建新的下游表。</p><p id="1895" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">实现这一更改后，面临的挑战是将历史数据批量加载到这些新表中。BigQuery中的所有表都是摄取时间分区的，将历史数据批量加载到较新的表中意味着我们要么丢失分区信息，要么使用<a class="ae kg" href="https://cloud.google.com/bigquery/table-decorators" rel="noopener ugc nofollow" target="_blank">表装饰器</a>逐个分区地加载数据。我们不能浪费分区时间，因为我们的许多下游进程对特定分区中的数据很敏感，因此我们决定走另一条路。</p><p id="818a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当我实现这个一次性批处理管道时，我在Beam中遇到了一个漂亮的小API，叫做<a class="ae kg" href="https://beam.apache.org/releases/javadoc/2.5.0/org/apache/beam/sdk/transforms/SerializableFunction.html" rel="noopener ugc nofollow" target="_blank"><em class="kh">serializable function</em></a>，它让我们基于当前窗口中的记录返回一个定制的表名。使用这个特性意味着我可以一次加载全部历史数据，而不用遍历分区。</p><p id="a714" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这篇文章中，我将分享如何使用<a class="ae kg" href="https://beam.apache.org/releases/javadoc/2.0.0/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIO.Write.html#to-org.apache.beam.sdk.transforms.SerializableFunction-" rel="noopener ugc nofollow" target="_blank"> SerializableFunction </a>将数据加载到BigQuery表的正确分区中。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/ec52eba9a44f1d99ce82d3444113d111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3DaBd600GTJSvJzjbvXvw.png"/></div></div></figure><h1 id="f3d2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.设置</h1><p id="4847" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">出于本文的目的，我将设置两个表(1个历史表和1个新表)。历史表将JSON数据存储为字符串，而新表将记录和重复类型列。这两个表都将按摄取时间进行分区。</p><h2 id="1df1" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">历史表</h2><p id="a391" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将使用BigQuery控制台来创建表。您也可以使用<code class="du li lj lk ll b">bq</code>命令行工具或API来创建表格。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es lm"><img src="../Images/2ecaec6e8b19998039e510342e46339a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4oEiktK0OfImU_rlInt-A.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">历史表创建</figcaption></figure><p id="5c3e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们的历史表包含以下各列:</p><p id="07c5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> id: </strong>用于识别客户的唯一id</p><p id="abed" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">属性:</strong>客户的属性，如姓名、年龄等。</p><p id="3d4d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">客户端时间戳:</strong>事件在设备上发生时的时间戳。</p><blockquote class="lr ls lt"><p id="4618" class="jd je kh jf b jg kb ji jj jk kc jm jn lu kd jq jr lv ke ju jv lw kf jy jz ka hb bi translated">我们将使用client_timestamp来标识新表中的正确分区。</p></blockquote><p id="c217" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接下来，我们将在这个表中插入一些历史数据。目前在UI中不支持使用表装饰器插入数据，因此我们将编写一个小的python脚本来将数据插入到我们的历史表中。</p><p id="9840" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用pip安装<a class="ae kg" href="https://pypi.org/project/google-cloud-bigquery/" rel="noopener ugc nofollow" target="_blank"> BigQuery客户端库</a>。</p><pre class="kj kk kl km fd lx ll ly lz aw ma bi"><span id="30b8" class="ku ig hi ll b fi mb mc l md me">pip install google-cloud-bigquery</span></pre><p id="f140" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然后执行以下python脚本，将2条记录加载到两个不同的分区中。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="067a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">运行脚本，您应该在输出中看到<code class="du li lj lk ll b">New Rows have been added.</code>。</p><p id="dbb2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">插入后，通过从控制台执行SQL，仔细检查数据是否已插入正确的分区。</p><pre class="kj kk kl km fd lx ll ly lz aw ma bi"><span id="67f4" class="ku ig hi ll b fi mb mc l md me">SELECT *  FROM `just-landing-231706.test_dataset.historical_table` where DATE(_PARTITIONTIME) = '2019-11-30'</span><span id="0f9b" class="ku ig hi ll b fi mh mc l md me">SELECT *  FROM `just-landing-231706.test_dataset.historical_table` where DATE(_PARTITIONTIME) = '2019-12-01'</span></pre><p id="c38e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您应该在每个查询中看到1行。这确认了我们的数据已经被插入到正确的分区中。</p><blockquote class="lr ls lt"><p id="569a" class="jd je kh jf b jg kb ji jj jk kc jm jn lu kd jq jr lv ke ju jv lw kf jy jz ka hb bi translated">您的行可能需要一些时间才能显示在正确的分区中。流式插入首先放入缓冲区，然后放入正确的分区。</p></blockquote><h2 id="5d6e" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">新表格</h2><p id="9c3c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们现在创建我们的新表。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mi"><img src="../Images/ff686725913d10604560116a547f062a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GZq4jciocUwv5BR74CdIA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">带有记录类型列的新表</figcaption></figure><p id="18fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">新表的记录类型为<code class="du li lj lk ll b">attribute</code>列，字段为<code class="du li lj lk ll b">name</code>和<code class="du li lj lk ll b">age</code>。</p><h1 id="4553" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.数据流作业</h1><p id="5bc4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">表设置完成后，让我们编写数据流作业，将数据从<code class="du li lj lk ll b">historical_table</code>加载到<code class="du li lj lk ll b">new_table</code>。</p><p id="1dc1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你想为数据流开发和工作提交设置你的系统，请参考我之前的博客文章。</p><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/@Sushil_Kumar/hello-world-in-dataflow-the-bohemian-approach-e6ce8b2092e"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">数据流中的Hello World波西米亚风格</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">这个周末，我参加了谷歌在Coursera上的无服务器课程，他们介绍了数据流，一个完全管理的…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="381f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以从我的repo中克隆数据流作业。我将一段一段地向你介绍代码。请记住将项目和数据集变量更改为您的值。</p><div class="mj mk ez fb ml mm"><a href="https://github.com/kaysush/dataflow-bigquery-historical" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">kaysush/数据流-大查询-历史</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">github.com</p></div></div><div class="mv l"><div class="nb l mx my mz mv na ks mm"/></div></div></a></div><p id="f3f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你需要注意的主要部分是<code class="du li lj lk ll b">BigQueryIO.write.to()</code>函数调用中<code class="du li lj lk ll b">SerializableFunction</code>类的匿名初始化。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="72c4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们需要覆盖<code class="du li lj lk ll b">SerializableFunction</code>类的<code class="du li lj lk ll b">apply()</code>函数并返回一个<code class="du li lj lk ll b">TableDestination</code>对象。我们在这个函数中所做的是从<code class="du li lj lk ll b">TableRow</code>对象中获取<code class="du li lj lk ll b">client_timestamp</code>并用表装饰器<code class="du li lj lk ll b">$</code>创建<code class="du li lj lk ll b">tableName</code>并修正分区值。因此tableName的一个样本值将是<code class="du li lj lk ll b">projectID:dataset.table_name$partition_date</code>。使用表名，我们返回一个<code class="du li lj lk ll b">TableDestination</code>的实例。</p><p id="b638" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另一段重要的代码是对<code class="du li lj lk ll b">withFormatFunction</code>的调用。该函数也接受输入a <code class="du li lj lk ll b">SerializableFunction</code>，但它返回的不是<code class="du li lj lk ll b">TableDestination</code>，而是<code class="du li lj lk ll b">TableRow</code>。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="dab4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这里，我们获取<code class="du li lj lk ll b">historical_table</code>的所有字段，解析<code class="du li lj lk ll b">attributes</code>字段中的JSON，并创建一个输出表行，将<code class="du li lj lk ll b">age</code>和<code class="du li lj lk ll b">name</code>作为单独的记录字段。</p><p id="bf0f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过传入以下程序参数来运行该程序。</p><pre class="kj kk kl km fd lx ll ly lz aw ma bi"><span id="5d4f" class="ku ig hi ll b fi mb mc l md me">--tempLocation=gs://&lt;YOUR-BUCKET&gt;/temp/ --project=&lt;YOUR-PROJECT-ID&gt;</span></pre><p id="c9f9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">程序应该会成功执行。</p><p id="e825" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">尝试用特定的<code class="du li lj lk ll b">_PARTITIONTIME</code>查询<code class="du li lj lk ll b">new_table</code>。您应该在正确的分区中看到这两行。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nc"><img src="../Images/48f35c286ea04164b5f48985847f70c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0H5dg1yfFvXKfNOU-fEuA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">分区1中的记录</figcaption></figure><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nd"><img src="../Images/e7b1d9a0e89dbe8561abd1dc9f53e37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7Sjd8aCwq4HGGhHsOuw2Q.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">分区2中的记录</figcaption></figure><p id="4aef" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在你知道了。我们成功地将历史数据上传到正确的分区中，即使我们的表是按摄取时间分区的。</p><h1 id="3616" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">4.结论</h1><p id="0ffd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du li lj lk ll b">SerializableFunction</code>是BigQueryIO中一个强大的构造，当您希望将行路由到不同的BigQuery表时，它非常有用。然而，需要注意的一点是，所有这些表都需要有相同的模式。如果您希望将行写入具有不同模式的不同表中，有一个名为<code class="du li lj lk ll b">DynamicDestinations</code>的不同构造。使用<code class="du li lj lk ll b">DynamicDestination</code>,您不仅返回名称，还返回表的模式。你可以在这里<a class="ae kg" href="https://beam.apache.org/releases/javadoc/2.0.0/org/apache/beam/sdk/io/gcp/bigquery/DynamicDestinations.html" rel="noopener ugc nofollow" target="_blank">阅读更多关于它们的内容</a>，我将在我即将发布的帖子中尝试介绍它们，因为我们在数据管道中大量使用它们。</p><p id="0f96" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您发现我的代码中有任何错误，或者有任何问题或建议，请随时在下面发表评论。</p><p id="5068" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">到那时，快乐的编码！:)</p></div></div>    
</body>
</html>