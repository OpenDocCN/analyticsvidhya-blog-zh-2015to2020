<html>
<head>
<title>Understanding Embedding Layer in Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Keras 中的嵌入层</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-embedding-layer-in-keras-bbe3ff1327ce?source=collection_archive---------0-----------------------#2020-10-03">https://medium.com/analytics-vidhya/understanding-embedding-layer-in-keras-bbe3ff1327ce?source=collection_archive---------0-----------------------#2020-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深度学习中，嵌入层听起来像一个谜，直到你抓住它。由于嵌入层是神经网络的重要组成部分，所以理解它的工作原理是很重要的。在这篇文章中，我将尝试解释什么是嵌入层，它的需求是什么，它是如何工作的，以及一些编码示例。所以让我们开始吧。</p><h2 id="2a06" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">什么是嵌入层</strong></h2><p id="cff2" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">嵌入层是 Keras 中可用的层之一。这主要用于自然语言处理相关的应用，如语言建模，但它也可以用于涉及神经网络的其他任务。在处理 NLP 问题时，我们可以使用预先训练的单词嵌入，如 GloVe。或者，我们也可以使用 Keras 嵌入层来训练我们自己的嵌入。</p><h2 id="35be" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">需要嵌入</strong></h2><blockquote class="kd"><p id="7c6b" class="ke kf hi bd kg kh ki kj kk kl km jc dx translated">词嵌入可以被认为是一种与降维一起的一键编码的替代方案。</p></blockquote><p id="2101" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">正如我们所知，在处理文本数据时，我们需要在输入任何机器学习模型(包括神经网络)之前将其转换为数字。为简单起见，单词可以比作范畴变量。我们使用一次性编码将分类特征转换成数字。为此，我们为每个类别创建虚拟特征，并用 0 和 1 填充它们。</p><p id="77d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，如果我们对文本数据中的单词使用一次性编码，我们将为每个单词创建一个虚拟特征，这意味着 10，000 个单词的词汇表有 10，000 个特征。这不是一种可行的嵌入方法，因为它需要用于单词向量的大存储空间，并且降低了模型效率。</p><p id="a664" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嵌入层使我们能够将每个单词转换成定义大小的固定长度向量。结果向量是一个密集的向量，具有真实的值，而不仅仅是 0 和 1。固定长度的单词向量有助于我们以更好的方式表示单词，同时降低维数。</p><p id="002f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种嵌入层的工作方式就像一个查找表。单词是这个表中的键，而密集的单词向量是值。为了更好地理解它，我们来看看 Keras 嵌入层的实现。</p><h2 id="25c2" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">在 Keras 实施</strong></h2><p id="b1c1" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">让我们从导入所需的库开始。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="76b6" class="jd je hi kx b fi lb lc l ld le">from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Embedding<br/>import numpy as np</span></pre><p id="b306" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过添加一个嵌入层来创建一个简单的 Keras 模型。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="15e9" class="jd je hi kx b fi lb lc l ld le">model = Sequential()<br/>embedding_layer = Embedding(input_dim=10,output_dim=4,input_length=2)<br/>model.add(embedding_layer)<br/>model.compile('adam','mse')</span></pre><p id="833b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嵌入层有三个参数</p><ul class=""><li id="c835" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><strong class="ih hj"> input_dim </strong>:词汇的大小</li><li id="2c7e" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><strong class="ih hj"> output_dim </strong>:每个单词的向量长度</li><li id="b7e8" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><strong class="ih hj">输入长度</strong>:序列的最大长度</li></ul><p id="1fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们将 10 设置为词汇大小，因为我们将对数字 0 到 9 进行编码。我们希望字向量的长度为 4，因此 output_dim 被设置为 4。嵌入层的输入序列的长度将是 2。</p><p id="35a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们将一个样本输入传递给我们的模型，看看结果。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="853c" class="jd je hi kx b fi lb lc l ld le">input_data = np.array([[1,2]])<br/>pred = model.predict(input_data)<br/>print(input_data.shape)<br/>print(pred)</span></pre><p id="71c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述代码的输出如下。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cee3" class="jd je hi kx b fi lb lc l ld le">(1, 2)<br/>[[[ 0.04502351  0.00151128  0.01764284 -0.0089057 ]<br/>  [-0.04007018  0.02874336  0.02772436  0.00842067]]]</span></pre><p id="91da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，每个单词(1 和 2)都由一个长度为 4 的向量表示。如果我们打印嵌入层的权重，我们得到下面的结果。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7100" class="jd je hi kx b fi lb lc l ld le">[array([[-0.04333381, -0.02326865, -0.00812379,  0.02167496],<br/>        [ 0.04502351,  0.00151128,  0.01764284, -0.0089057 ],<br/>        [-0.04007018,  0.02874336,  0.02772436,  0.00842067],<br/>        [ 0.00512743,  0.03695237, -0.02774147, -0.03748262],<br/>        [ 0.02066498, -0.01512628, -0.03989452,  0.00809463],<br/>        [-0.02207369,  0.02889762, -0.01229819, -0.03157005],<br/>        [ 0.02565557,  0.02931032, -0.01611946, -0.00105535],<br/>        [ 0.03920721,  0.04009463, -0.04943105,  0.04145898],<br/>        [ 0.04208959, -0.00412361, -0.04585704,  0.03489918],<br/>        [-0.04016889,  0.03448426,  0.00623332,  0.02844917]],<br/>       dtype=float32)]</span></pre><p id="6ca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些权重基本上是词汇中单词的向量表示。正如我们之前讨论的，这是一个大小为 10 x 4 的查找表，用于单词 0 到 9。第一个单词(0)由该表中的第一行表示，即</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d197" class="jd je hi kx b fi lb lc l ld le">[-0.04333381, -0.02326865, -0.00812379,  0.02167496]</span></pre><p id="a96d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>在这个例子中，我们没有训练嵌入层。分配给单词向量的权重被随机初始化。</p><p id="3dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个很好的例子。但是在处理实际的文本数据时，我们需要训练嵌入层来获得正确的单词嵌入。让我们看看如何使用餐馆评论数据来做到这一点。</p><h2 id="8116" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">餐厅点评分类</strong></h2><p id="c77b" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在解决这个问题时，我们将执行以下步骤。</p><ol class=""><li id="ed15" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lt ll lm ln bi translated">把句子标记成单词。</li><li id="7827" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lt ll lm ln bi translated">为每个单词创建一个独热编码向量。</li><li id="26f7" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lt ll lm ln bi translated">使用填充以确保所有序列长度相同。</li><li id="6508" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lt ll lm ln bi translated">将填充的序列作为输入传递给嵌入层。</li><li id="ae16" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lt ll lm ln bi translated">展平并应用密集层来预测标签。</li></ol><p id="d6f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从导入所需的库开始</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8d8c" class="jd je hi kx b fi lb lc l ld le">from numpy import array<br/>from tensorflow.keras.preprocessing.text import one_hot<br/>from tensorflow.keras.preprocessing.sequence import pad_sequences<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Flatten,Embedding,Dense</span></pre><p id="b4fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，我们将使用总共 10 个评论。其中一半是正的，用 0 表示，另一半是负的，用 1 表示。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="bba1" class="jd je hi kx b fi lb lc l ld le"># Define 10 restaurant reviews<br/>reviews =[<br/>          'Never coming back!',<br/>          'horrible service',<br/>          'rude waitress',<br/>          'cold food',<br/>          'horrible food!',<br/>          'awesome',<br/>          'awesome services!',<br/>          'rocks',<br/>          'poor work',<br/>          'couldn\'t have done better'<br/>]</span><span id="6b3e" class="jd je hi kx b fi lu lc l ld le">#Define labels<br/>labels = array([1,1,1,1,1,0,0,0,0,0])</span></pre><p id="dec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把词汇量定为 50，并使用 Keras 的 one_hot 函数对单词进行 one-hot 编码。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fad5" class="jd je hi kx b fi lb lc l ld le">Vocab_size = 50<br/>encoded_reviews = [one_hot(d,Vocab_size) for d in reviews]<br/>print(f'encoded reviews: {encoded_reviews}')</span></pre><p id="3505" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将得到如下编码审查的结果。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5eea" class="jd je hi kx b fi lb lc l ld le">encoded reviews: [[18, 39, 17], [27, 27], [5, 19], [41, 29], [27, 29], [2], [2, 1], [49], [26, 9], [6, 9, 11, 21]]</span></pre><p id="00fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里你可以看到每个编码评论的长度等于评论中的字数。Keras one_hot 基本上是将每个单词转换成它的 one-hot 编码索引。现在，我们需要应用填充，以便所有编码的评论长度相同。让我们将 4 定义为最大长度，并在编码向量的最后填充 0。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e5d2" class="jd je hi kx b fi lb lc l ld le">max_length = 4<br/>padded_reviews = pad_sequences(encoded_reviews,maxlen=max_length,padding='post')<br/>print(padded_reviews)</span></pre><p id="e0e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">填充和编码的评论将是这样的。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e73b" class="jd je hi kx b fi lb lc l ld le">[[18 39 17  0]<br/> [27 27  0  0]<br/> [ 5 19  0  0]<br/> [41 29  0  0]<br/> [27 29  0  0]<br/> [ 2  0  0  0]<br/> [ 2  1  0  0]<br/> [49  0  0  0]<br/> [26  9  0  0]<br/> [ 6  9 11 21]]</span></pre><p id="2cfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在创建了评论的填充的一键表示之后，我们准备将它作为输入传递给嵌入层。在下面的代码片段中，我们创建了一个简单的 Keras 模型。我们将每个单词的嵌入向量的长度固定为 8，输入长度将是我们已经定义为 4 的最大长度。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="df9e" class="jd je hi kx b fi lb lc l ld le">model = Sequential()<br/>embedding_layer = Embedding(input_dim=Vocab_size,output_dim=8,input_length=max_length)<br/>model.add(embedding_layer)<br/>model.add(Flatten())<br/>model.add(Dense(1,activation='sigmoid'))<br/>model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['acc'])</span><span id="d648" class="jd je hi kx b fi lu lc l ld le">print(model.summary())</span></pre><p id="577d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型摘要将是。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5c0d" class="jd je hi kx b fi lb lc l ld le">Model: "sequential_1"<br/>_________________________________________________________________<br/>Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>embedding_1 (Embedding)      (None, 4, 8)              400       <br/>_________________________________________________________________<br/>flatten (Flatten)            (None, 32)                0         <br/>_________________________________________________________________<br/>dense (Dense)                (None, 1)                 33        <br/>=================================================================<br/>Total params: 433<br/>Trainable params: 433<br/>Non-trainable params: 0<br/>_________________________________________________________________<br/>None</span></pre><p id="070d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将对模型进行 100 个纪元的训练。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5fb0" class="jd je hi kx b fi lb lc l ld le">model.fit(padded_reviews,labels,epochs=100,verbose=0)</span></pre><p id="9d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦训练完成，嵌入层已经学习了权值，它只不过是每个单词的矢量表示。让我们检查权重矩阵的形状。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6fab" class="jd je hi kx b fi lb lc l ld le">print(embedding_layer.get_weights()[0].shape)</span></pre><p id="16fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个嵌入矩阵本质上是一个 50 行 8 列的查找表，从输出可以明显看出。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="71f3" class="jd je hi kx b fi lb lc l ld le">(50, 8)</span></pre><p id="0a27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们检查第一个单词的嵌入，我们得到下面的向量。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e1a4" class="jd je hi kx b fi lb lc l ld le">[ 0.056933    0.0951985   0.07193055  0.13863552 -0.13165753  0.07380469    0.10305451 -0.10652688]</span></pre><p id="c23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们如何在我们的文本语料库上训练嵌入层，并获得每个单词的嵌入向量。这些向量然后被用来表示句子中的单词。</p><h2 id="fe66" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">结论</strong></h2><p id="b14b" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">嵌入是处理 NLP 问题的好方法，原因有二。首先，由于我们可以控制特征的数量，它有助于减少一键编码的维数。第二，它能够理解单词的上下文，使得相似的单词具有相似的嵌入。这篇文章详细解释了单词嵌入的工作原理。</p><p id="46e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得这篇文章有用，请在评论中告诉我。我是一名数据科学爱好者和博客作者。你可以通过我的 LinkedIn <a class="ae lv" href="https://www.linkedin.com/in/sawan-saxena-640a4475/" rel="noopener ugc nofollow" target="_blank">个人资料</a>联系我。</p><p id="deab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。</p><p id="564b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><ul class=""><li id="5e7c" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">杰夫·希顿的 Keras (11.3)中的嵌入层是什么:<a class="ae lv" href="https://www.youtube.com/watch?v=OuNH5kT-aD0" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=OuNH5kT-aD0</a>。</li></ul></div></div>    
</body>
</html>