<html>
<head>
<title>Insert into a Binary Search Tree — Day 12(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">插入二叉查找树—第12天(蟒蛇皮)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/insert-into-a-binary-search-tree-day-12-python-69a44d7c6063?source=collection_archive---------12-----------------------#2020-10-07">https://medium.com/analytics-vidhya/insert-into-a-binary-search-tree-day-12-python-69a44d7c6063?source=collection_archive---------12-----------------------#2020-10-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d3f47a7f53004b59ed43b1d355d31e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uo77S1UKk8rr1UAY"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">格雷格·罗森克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0333" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我们将讨论leetcode十月份每日编码挑战问题中的一个。</p><p id="436d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我进入这个问题之前，我们需要了解二叉查找树的一些特点。</p><p id="4407" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二叉查找树是一种树状数据结构，具有如下新增功能。</p><ol class=""><li id="2eb8" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">根节点左侧的子树将总是小于根节点。</li><li id="23a0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">根节点右侧的子树将总是大于根节点。</li><li id="fc39" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">根节点的左右子树必须是二叉查找树。</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="59a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> 701 </strong> </a> <strong class="ix hj">。插入二叉查找树</strong></p><p id="3207" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给你一个二叉查找树(BST)的<code class="du ko kp kq kr b">root</code>节点和一个要插入到树中的<code class="du ko kp kq kr b">value</code>。在插入之后返回<em class="ks">BST的根节点。<strong class="ix hj">保证</strong>新值不存在于原始BST中。</em></p><p id="f5a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>可能存在多种有效的插入方式，只要树在插入后仍然是BST。你可以退回<strong class="ix hj">其中任何一个</strong>。</p><p id="cc60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例1: </strong></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/38861c95d42ebb83e976b16eebc5d183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VHCt219iLqXpMYRl.jpg"/></div></div></figure><pre class="ku kv kw kx fd ky kr kz la aw lb bi"><span id="529d" class="lc ld hi kr b fi le lf l lg lh"><strong class="kr hj">Input:</strong> root = [4,2,7,1,3], val = 5<br/><strong class="kr hj">Output:</strong> [4,2,7,1,3,5]<br/><strong class="kr hj">Explanation:</strong> Another accepted tree is:</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es li"><img src="../Images/0e4987b8935587afa2a9dd710f5c6446.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/0*TD_AigVjNb6q_A3t.jpg"/></div></figure><p id="62d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例二:</strong></p><pre class="ku kv kw kx fd ky kr kz la aw lb bi"><span id="7e01" class="lc ld hi kr b fi le lf l lg lh"><strong class="kr hj">Input:</strong> root = [40,20,60,10,30,50,70], val = 25<br/><strong class="kr hj">Output:</strong> [40,20,60,10,30,50,70,null,null,25]</span></pre><p id="638f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例3: </strong></p><pre class="ku kv kw kx fd ky kr kz la aw lb bi"><span id="b4c3" class="lc ld hi kr b fi le lf l lg lh"><strong class="kr hj">Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5<br/><strong class="kr hj">Output:</strong> [4,2,7,1,3,5]</span></pre><p id="5a7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">约束:</strong></p><ul class=""><li id="8365" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js lj jz ka kb bi translated">树中节点的数量将在<code class="du ko kp kq kr b">[0, 104]</code>范围内。</li><li id="3d25" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lj jz ka kb bi translated"><code class="du ko kp kq kr b">-108 &lt;= Node.val &lt;= 108.</code></li><li id="1b46" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lj jz ka kb bi translated">所有的值<code class="du ko kp kq kr b">Node.val</code>都是<strong class="ix hj">唯一的</strong>。</li><li id="0726" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lj jz ka kb bi translated"><code class="du ko kp kq kr b">-108 &lt;= val &lt;= 108.</code></li><li id="a431" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js lj jz ka kb bi translated"><strong class="ix hj">保证</strong>原来的BST里没有<code class="du ko kp kq kr b">val</code>。</li></ul><p id="81df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们记得BST的特性，想出一个解决方案会更简单。我们需要将给定的数字与根节点的值进行比较。如果根节点的值高于给定的数字，我们移动到根的左侧。否则，我们移动到根节点的右侧。我们将递归执行上述步骤，直到基本条件。</p><p id="5c6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们深入算法。</p><ol class=""><li id="51eb" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">我们使用递归算法，所以我们需要确定基本条件。当根节点为none时，我们满足基本条件。</li><li id="3152" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">将给定的数字与根节点进行比较，如果根节点的值大于给定的数字，则移动到根节点的左侧。</li><li id="8e7f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果根节点的值低于给定的数字，则移动到根节点的右侧。</li></ol><pre class="ku kv kw kx fd ky kr kz la aw lb bi"><span id="a600" class="lc ld hi kr b fi le lf l lg lh">class BSTInserter:<br/>    def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode:<br/>        if root == None:<br/>            root = TreeNode(val)<br/>            return root<br/>        if val &lt; root.val:<br/>            root.left = self.insertIntoBST(root.left, val)<br/>        else:<br/>            root.right = self.insertIntoBST(root.right, val)<br/>        <br/>        return root</span></pre><p id="375d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析。</p><p id="47a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="07d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一般情况下，如果给定的BST是一棵平衡树，那么我们将访问树的一边，因此时间复杂度是O(logN)。在最坏的情况下，如果树是倾斜的BST，时间复杂度将是O(N)，其中N表示节点的数量。</p><p id="c030" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="1966" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一般情况下，如果给定的BST是一棵平衡树，那么我们将递归地访问树的一边，因此空间复杂度是O(logN)。在最坏的情况下，如果树是倾斜的BST，空间复杂度将是O(N)，其中N表示节点的数量。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="9814" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果对这篇文章有任何反馈或建议，请务必告诉我。</p></div></div>    
</body>
</html>