<html>
<head>
<title>Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/big-o-notation-58614f2b6318?source=collection_archive---------22-----------------------#2020-04-22">https://medium.com/analytics-vidhya/big-o-notation-58614f2b6318?source=collection_archive---------22-----------------------#2020-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jd" rel="noopener" href="/@manikanthgoud123/introduction-to-algorithm-analysis-4c1228744d12">博客</a>中，我们已经看到了为什么我们不能用“跑步时间”作为一个客观的衡量标准。因为那将取决于计算机本身的<strong class="ih hj">速度和硬件能力</strong>。所以我们将需要有更有效的方法来分析任何算法，这是<strong class="ih hj">大O！</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/b15cea716b9ac707be873bab52b2da59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*tgQt6HbTLqJsPUdpxubaMQ.png"/></div></figure><p id="d48f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Big-O符号描述了当输入变得任意大时，算法根据给定的输入获得期望的输出需要多长时间。</p><p id="145f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更仔细地研究其中一些要点:</p><ul class=""><li id="b67b" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">请记住，我们要比较运行时间增长的速度，而不是比较确切的运行时间，因为这些会因硬件而异。</li><li id="eef8" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">因为我们想要比较各种输入大小，所以我们只关心相对于输入的运行时增长。这就是为什么我们用<strong class="ih hj"> n </strong>表示符号。</li><li id="2ca8" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">当n变得任意大时，我们只担心当n变大时增长最快的项，在这一点上，Big-O分析也被称为<strong class="ih hj">渐近分析</strong></li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es ka"><img src="../Images/ede5192be2febba54b2ed8d5f0a4a600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hwy28NI0GvntURZu.png"/></div></div></figure><p id="b6ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于语法fun1()可以说是<strong class="ih hj"> O(n) </strong>因为它的运行时间随着输入大小线性增长。类似地，对于不同类型的算法，我们有不同类型的大O符号，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kf"><img src="../Images/b000666d9c1cb72a5a76a805d78d7236.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*FT2-Vvu1HNDZ3WYBB6ZznQ.png"/></div></figure><p id="fc61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们绘制输入值对执行特定类型算法所需时间的图表，我们将得到如下图表</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es kg"><img src="../Images/e5ef7f032843d6de1fd0c0b47b34a9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aw6NjkmZsBAXj6AmK7NjKw.png"/></div></div></figure><p id="feaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图可以看出，对于从1到2的较小值范围，运行时间没有任何区别，因为我们获得的值越大，运行时间可能会发生变化，如上图所示。在下一篇博客中，我们将讨论如何找到不同函数的运行时，以及如何关联它的大O符号。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="04d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何反馈或批评，请随时与我分享。如果本演练对您有所帮助，请喜欢👏文章。干杯！🍻</p></div></div>    
</body>
</html>