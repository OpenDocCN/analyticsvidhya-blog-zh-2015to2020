<html>
<head>
<title>Managing a Python development environment in Emacs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Emacs中管理Python开发环境</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/managing-a-python-development-environment-in-emacs-43897fd48c6a?source=collection_archive---------7-----------------------#2019-11-18">https://medium.com/analytics-vidhya/managing-a-python-development-environment-in-emacs-43897fd48c6a?source=collection_archive---------7-----------------------#2019-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3ecb2ca687c2536743f94244ff8b7e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97U-1v8IBVqbGUjLlRtfhg.png"/></div></div></figure><p id="b800" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于我的Python开发的两篇文章的第二部分。<a class="ae jo" rel="noopener" href="/@aiguofer/my-python-development-and-daily-usage-setup-af8633ddef78">点击此处查看第一部分。</a></p><p id="9ff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我需要/想要从我的IDE中得到的主要东西是:</p><ul class=""><li id="c690" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">代码完成</li><li id="0182" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">证明文件</li><li id="9387" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">跳到定义</li><li id="08b5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">将区域/缓冲区发送到REPL(口译语言)</li><li id="5310" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">代码问题的识别</li><li id="64dd" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">自动格式化/组织/清理代码</li><li id="dd70" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">基本重构(重命名变量)(很好)</li></ul><p id="458e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我尝试过使用各种编辑器和ide，但是我总是会发现一些我不喜欢的东西，然后回到Emacs。我的主要问题倾向于使用不同的环境(一个用于Java的IDE，一个用于Python，一个用于Web开发，一个用于编辑配置文件/脚本等),并真正学习每个工具来充分利用它。我可以在Emacs中“上下文切换”,而不必切换工具。我可以获得我需要的大部分功能；尽管可能不像某些替代方案那样“完美”,但可扩展性使得在相同的舒适环境中使用几乎任何类型的文件/编程语言都很容易。在这里，我将具体谈谈我的Python设置，以及我是如何完成上述大部分内容的。</p><h1 id="ac22" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">埃尔比</h1><p id="e5b3" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">我在Emacs中用于Python开发的主要工具是<a class="ae jo" href="https://github.com/jorgenschaefer/elpy" rel="noopener ugc nofollow" target="_blank"> Elpy </a>。这个伟大的工具照顾了我的大部分需求:代码完成(通过jedi)，文档(显示函数定义)，跳转到def，发送到REPL，以及基本的重构。Elpy通过flymake提供错误检查，但是我禁用了它，并使用flycheck来代替。这是我的Elpy配置:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c0e5" class="lp ke hi ll b fi lq lr l ls lt">(use-package elpy<br/>    :straight t<br/>    :bind<br/>    (:map elpy-mode-map<br/>          ("C-M-n" . elpy-nav-forward-block)<br/>          ("C-M-p" . elpy-nav-backward-block))<br/>    :hook ((elpy-mode . flycheck-mode)<br/>           (elpy-mode . (lambda ()<br/>                          (set (make-local-variable 'company-backends)<br/>                               '((elpy-company-backend :with company-yasnippet))))))<br/>    :init<br/>    (elpy-enable)<br/>    :config<br/>    (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))<br/>    ; fix for MacOS, see <a class="ae jo" href="https://github.com/jorgenschaefer/elpy/issues/1550" rel="noopener ugc nofollow" target="_blank">https://github.com/jorgenschaefer/elpy/issues/1550</a><br/>    (setq elpy-shell-echo-output nil)<br/>    (setq elpy-rpc-python-command "python3")<br/>    (setq elpy-rpc-timeout 2)))</span></pre><p id="adf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最常用的快捷键是:</p><p id="ea00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">elpy-shell-send-region-or-buffer</code> <code class="du lu lv lw ll b">C-c C-c</code>让我将代码发送到REPL。如果一个区域被选中，它将发送该区域，否则它将发送整个缓冲区。</p><p id="e172" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">elpy-doc</code> <code class="du lu lv lw ll b">C-c C-d</code>在新窗口中显示光标下的函数/类的文档。</p><p id="7d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">elpy-goto-definition</code> <code class="du lu lv lw ll b">M-.</code>转到光标下的函数/类的定义。这有助于我了解它是如何实现的，即使它是在第三方包中。</p><p id="bcd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">elpy-nav-indent-shift-(left/right)</code> <code class="du lu lv lw ll b">M-(left/right)</code>将所选块向右或向左移动1级。这对于将代码块移入/移出if语句或循环非常有用。</p><p id="f063" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">elpy-nav-(forward/backward)-block</code> <code class="du lu lv lw ll b">C-M-(n/p)</code>在代码块之间导航。这有助于在块/函数/类之间移动。</p><p id="71c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">elpy-nav-move-line-or-region-(up/down)</code> <code class="du lu lv lw ll b">M-(up/down)</code>上下移动整个代码块。这有助于移动代码。</p><h1 id="5454" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">公司</h1><p id="89a5" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">Elpy使用公司模式完成代码。我对我的公司模式配置做了一些调整，所以我在这里分享一下:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bafc" class="lp ke hi ll b fi lq lr l ls lt">(use-package company<br/>  :straight t<br/>  :diminish company-mode<br/>  :init<br/>  (global-company-mode)<br/>  :config<br/>  ;; set default `company-backends'<br/>  (setq company-backends<br/>        '((company-files          ; files &amp; directory<br/>           company-keywords       ; keywords<br/>           company-capf)  ; completion-at-point-functions<br/>          (company-abbrev company-dabbrev)<br/>          ))</span><span id="bd2e" class="lp ke hi ll b fi lx lr l ls lt">(use-package company-statistics<br/>    :straight t<br/>    :init<br/>    (company-statistics-mode))</span><span id="5982" class="lp ke hi ll b fi lx lr l ls lt">(use-package company-web<br/>    :straight t)</span><span id="13b9" class="lp ke hi ll b fi lx lr l ls lt">(use-package company-try-hard<br/>    :straight t<br/>    :bind<br/>    (("C-&lt;tab&gt;" . company-try-hard)<br/>     :map company-active-map<br/>     ("C-&lt;tab&gt;" . company-try-hard)))</span><span id="65f3" class="lp ke hi ll b fi lx lr l ls lt">(use-package company-quickhelp<br/>    :straight t<br/>    :config<br/>    (company-quickhelp-mode))<br/>)</span></pre><p id="1bef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了设置默认的company-backends(注意，当Elpy被启用时，缺省情况下这个完成列表是不活动的)之外，我没有做太多不同寻常的事情。然而，我也使用其他一些软件包来添加一些不错的功能。<code class="du lu lv lw ll b">company-statistics</code>帮助记录我最常用的补全，并使用这些信息来改进排序。<code class="du lu lv lw ll b">company-web</code>为web模式生成一些完成。<code class="du lu lv lw ll b">company-try-hard</code>让我使用<code class="du lu lv lw ll b">C-&lt;tab&gt;</code>在不同的公司后台列表中循环。当建议完成时,<code class="du lu lv lw ll b">company-quickhelp</code>在弹出窗口中给我文档。</p><h1 id="af98" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">保存时格式化/修复</h1><p id="33c3" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">有一些工具对自动格式化代码、文档和导入非常有帮助。我使用了其中的一些，并且让一些在保存时自动运行。这是我的配置:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1941" class="lp ke hi ll b fi lq lr l ls lt">(use-package buftra<br/>    :straight (:host github :repo "humitos/buftra.el"))</span><span id="0ec7" class="lp ke hi ll b fi lx lr l ls lt">(use-package py-pyment<br/>    :straight (:host github :repo "humitos/py-cmd-buffer.el")<br/>    :config<br/>    (setq py-pyment-options '("--output=numpydoc")))</span><span id="34e9" class="lp ke hi ll b fi lx lr l ls lt">(use-package py-isort<br/>    :straight (:host github :repo "humitos/py-cmd-buffer.el")<br/>    :hook (python-mode . py-isort-enable-on-save)<br/>    :config<br/>    (setq py-isort-options '("--lines=88" "-m=3" "-tc" "-fgw=0" "-ca")))</span><span id="dc2b" class="lp ke hi ll b fi lx lr l ls lt">(use-package py-autoflake<br/>    :straight (:host github :repo "humitos/py-cmd-buffer.el")<br/>    :hook (python-mode . py-autoflake-enable-on-save)<br/>    :config<br/>    (setq py-autoflake-options '("--expand-star-imports")))</span><span id="018c" class="lp ke hi ll b fi lx lr l ls lt">(use-package py-docformatter<br/>    :straight (:host github :repo "humitos/py-cmd-buffer.el")<br/>    :hook (python-mode . py-docformatter-enable-on-save)<br/>    :config<br/>    (setq py-docformatter-options '("--wrap-summaries=88" "--pre-summary-newline")))</span><span id="52be" class="lp ke hi ll b fi lx lr l ls lt">(use-package blacken<br/>    :straight t<br/>    :hook (python-mode . blacken-mode)<br/>    :config<br/>    (setq blacken-line-length '88))</span><span id="2ef0" class="lp ke hi ll b fi lx lr l ls lt">(use-package python-docstring<br/>    :straight t<br/>    :hook (python-mode . python-docstring-mode))</span></pre><p id="4be8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">pyment</code>帮助我轻松创建文档字符串。我可以突出显示我的函数定义，<code class="du lu lv lw ll b">M-x py-pyment-region</code>，瞧，从我的函数定义创建了一个准系统docstring。</p><p id="e1a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">isort</code>帮助组织我的导入，并在保存时自动完成。我在这里使用了一些选项来很好地处理<code class="du lu lv lw ll b">black</code>。我也用<code class="du lu lv lw ll b">autoflake</code>，主要是扩展* imports，去掉不用的imports。</p><p id="f3b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">docformatter</code>帮助我格式化文档字符串，使它们在88列的限制内，并帮助保持整洁、有序和标准。这将在保存时自动运行。</p><p id="8a3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">black</code>帮助我格式化代码，并在保存时自动启用。</p><p id="9ccf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lu lv lw ll b">docstring</code>当文档字符串为reStructuredText或Epydoc格式时，有助于突出显示文档字符串。现在这已经没什么用了，因为我已经主要转换到Numpy风格了，但是当我在不能选择格式的代码上工作时，这样做还是不错的。</p><h1 id="1ebb" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Pyenv</h1><p id="885e" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在我之前的博客中，我解释了如何设置pyenv和pyenv-version-alias。为了在Emacs中使用它，我派生并扩展了一个包来满足我的需求。我安装了它，并设置为:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0ebd" class="lp ke hi ll b fi lq lr l ls lt">(use-package pyenv<br/>    :straight (:host github :repo "aiguofer/pyenv.el")<br/>    :config<br/>    (setq pyenv-use-alias 't)<br/>    (setq pyenv-modestring-prefix " ")<br/>    (setq pyenv-modestring-postfix nil)<br/>    (setq pyenv-set-path nil)</span><span id="497f" class="lp ke hi ll b fi lx lr l ls lt">(global-pyenv-mode)<br/>    (defun pyenv-update-on-buffer-switch (prev curr)<br/>      (if (string-equal "Python" (format-mode-line mode-name nil nil curr))<br/>          (pyenv-use-corresponding)))<br/>    (add-hook 'switch-buffer-functions 'pyenv-update-on-buffer-switch))</span></pre><p id="7dcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在模式行中给了我一个很好的显示，显示了当前活动的pyenv版本(使用别名，如果提供的话)。它还确保当我在缓冲区之间切换时，总是设置正确的pyenv。不幸的是，这个挂钩并不总是有效，所以我有时不得不手动运行<code class="du lu lv lw ll b">pyenv-use-corresponding</code>(注意，这需要安装<code class="du lu lv lw ll b">switch-buffer-functions</code>)。</p><h1 id="2a9c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">混杂的</h1><p id="e659" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">我还对我的Python设置做了一些其他的调整。我在另一篇文章中描述了如何为每个pyenv版本生成一个Jupyter内核。当我处理一些Python代码时，我使用一些定制代码来确保使用正确的内核。如果我在做Django项目，它也会使用<code class="du lu lv lw ll b">django-admin</code>。我还修复了comint密码条目，以便在Python shell中调用<code class="du lu lv lw ll b">getpass</code>时，密码被“标上星号”。这是我的所有配置:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="be10" class="lp ke hi ll b fi lq lr l ls lt">(use-package python<br/>  :hook (inferior-python-mode . fix-python-password-entry)<br/>  :config<br/>  (setq python-shell-interpreter "jupyter-console"<br/>        python-shell-interpreter-args "--simple-prompt"<br/>        python-shell-prompt-detect-failure-warning nil)<br/>  (add-to-list 'python-shell-completion-native-disabled-interpreters<br/>               "jupyter-console")<br/>  (add-to-list 'python-shell-completion-native-disabled-interpreters<br/>               "jupyter")</span><span id="e680" class="lp ke hi ll b fi lx lr l ls lt">(defun fix-python-password-entry ()<br/>    (push<br/>     'comint-watch-for-password-prompt comint-output-filter-functions))</span><span id="2f9e" class="lp ke hi ll b fi lx lr l ls lt">(defun my-setup-python (orig-fun &amp;rest args)<br/>    "Use corresponding kernel"<br/>    (let* ((curr-python (car (split-string (pyenv/version-name) ":")))<br/>           (python-shell-buffer-name (concat "Python-" curr-python))<br/>           (python-shell-interpreter-args (if (bound-and-true-p djangonaut-mode)<br/>                                              "shell_plus -- --simple-prompt"<br/>                                            (concat "--simple-prompt --kernel=" curr-python)))<br/>           (python-shell-interpreter (if (bound-and-true-p djangonaut-mode)<br/>                                         "django-admin"<br/>                                       python-shell-interpreter)))<br/>      (apply orig-fun args)))</span><span id="36a1" class="lp ke hi ll b fi lx lr l ls lt">(advice-add 'python-shell-get-process-name :around #'my-setup-python)<br/>  (advice-add 'python-shell-calculate-command :around #'my-setup-python)<br/>)</span></pre><h1 id="1b19" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="b7a2" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个设置满足了我的大部分需求。我遇到的最大问题是pyenv版本在开放缓冲区之间切换时并不总是正确设置(因为没有“真正的”钩子用于缓冲区之间的切换)。我也有很多其他的emacs配置选项，所以请随意查看我的配置文件中的<a class="ae jo" href="https://github.com/aiguofer/dotfiles/blob/master/user/.emacs.d/init.el" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>