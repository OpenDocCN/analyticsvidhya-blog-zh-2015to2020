<html>
<head>
<title>Variable Clustering from scratch using SAS and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SAS 和 Python 从头开始进行变量聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/variable-clustering-from-scratch-using-sas-and-python-4e21c7505cab?source=collection_archive---------3-----------------------#2020-10-01">https://medium.com/analytics-vidhya/variable-clustering-from-scratch-using-sas-and-python-4e21c7505cab?source=collection_archive---------3-----------------------#2020-10-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好，</p><p id="aa72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我试图展示我对变量聚类算法(最流行的降维技术)的理解。</p><p id="855d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">免责声明</strong>:本文旨在分享我的变量聚类知识。这不包括任何与项目相关的数据、代码等。本文中使用的 SAS/Python 代码完全基于公开可用的数据集，与任何公司项目无关。本文的读者必须具备统计学、SAS 和 Python 方面的背景知识</p><p id="16bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集的复杂性随着维度的增加而迅速增加。它增加了计算时间，影响了探索模型关系、模型评分的能力，增加了数据集中的冗余，等等。</p><p id="67b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">补救措施之一可以是可变聚类。它找出一组变量，这些变量在一个聚类中相互之间尽可能相关，而与其他聚类中的变量尽可能不相关。</p><p id="d36d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的。现在，让我们了解它是如何完成的。</p><p id="059a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PCA——主成分分析是算法的核心。让我们了解一下它是如何工作的。</p><p id="b9cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有 10 个变量，它们之间的相关性如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5de7dc1677f122646e460f68a379ca54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTEsQUphiAJWeo9q9Md6BQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 1</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/bcc1017f94458f66ad0ec3d62546e357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Z_0-0_4VuInvNMeQ4HvIA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 2</figcaption></figure><p id="12df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将为第一个主成分或因子创建一个系数。主成分是预测变量的加权线性组合。其计算如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/8c413ddc64d468599005294c10d9763a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efhRqzC8SwkhVJSXUmMVwQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 3</figcaption></figure><p id="84dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我扩展一下公式。它接受列总计和行总计，然后第一个 PC = column_total / sqrt(row_total)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/ddebcf203b6c934ee1376fb99c993c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mm3mhF4XFW0EKAEK71HWQg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 4</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jw"><img src="../Images/7a73938e75e53b41c82c0410236e612e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OMi6C_eWHI3tyWuNIvHWw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 5</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jx"><img src="../Images/92a1707a9f0ec3b11bd31f9f14b3135a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*523m83zRUQcORD2_VfZdNw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 6</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jy"><img src="../Images/22fb1ad97238601bf6aad369c18cccf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ile5XxIw-znW7LwXNErllg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 7</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/03e0419040d3631962f0530d159182e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDTdr_7zllR_-42GwCaVhw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 8</figcaption></figure><p id="2387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，由表 7 的值到表 2 的(R)值获得残差系数矩阵(R1)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/07c53fbf71e705bb6017b91332419097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qhl-mnBrv4c3O5eLHsGrLQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 9</figcaption></figure><p id="acc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在这个剩余矩阵上，我们将执行相同的计算来得到第二个 PC2。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/dd51522bceb819f9a9799021e8a450f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJxanCEvGSiS5CAneF5S0Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 10</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/859d263fa302aa5bdeaaa25e71a51ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQ5AHxUnljQsPAfyfh8uxg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 11</figcaption></figure><p id="68c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于所有的因子/PCs，将遵循相同的过程。因为我们有 10 个变量，所以将会计算 10 个。到目前为止，我们得到的 PCs 系数如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/f8cb79d34d623dbf9383dded4ed7e60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCNxMYBnIQm3dmZh79AkLg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 12(成分矩阵)</figcaption></figure><p id="1230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">表 12 表示<strong class="ih hj"> <em class="ke">因素负荷</em> </strong>，这是每个 PCs 和变量之间的相关性。如果我们简单地平方这些值，我们将得到 R2 如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kf"><img src="../Images/2e16ae79c95337b7c0c4ff6a0edf1cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_aCrBsjng_ZdsN7F6XjJw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 13 (R2)</figcaption></figure><p id="5824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用表 13 计算不同的度量。</p><p id="4b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">特征值:</strong>各 PC 对所有变量解释的方差(各 PC 的列合计)。</p><p id="8bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">公度:</strong>由单个变量的所有 PC 解释的方差(行总计)。对于单个变量，所有 PCs 解释的 100%方差的总和始终为 1。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kg"><img src="../Images/e9ce4f5ce28b356dcc3602e5192a2fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEFrbbAB9V-ZQUB640aKQQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表 14(公度和特征值)</figcaption></figure><p id="efda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，将保留前几个 PC(例如本例中的前两个 PC ),因为它们解释了数据中的大多数变化。这个缩减的 PC 集将用于创建分数，该分数将用于代替最初的 10 个变量。</p><p id="305b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的。现在，我们清楚了 PC，特征值，公度等等。变量聚类使用相同的算法，但不是使用 PC 分数，我们将从每个聚类中选取一个变量。所有的变量都集中在一个簇中。对聚类中的变量进行主成分分析。如果 PC 的<strong class="ih hj"> <em class="ke">第二特征值大于指定阈值，则该簇被分裂。</em>T3】</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/6b961ad887ed6f1a0d273b70704a08bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*63oJ6QZ4-EWf0DQcdUl0Ow.png"/></div></figure><p id="8963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是从每个聚类中挑选哪个变量？人们应该选择与自己的类相关度最高而与其他类相关度最低的变量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ki"><img src="../Images/74b9ee593be2c47d5849f4d12af3489a.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*vDR6MbSLHIFpk1l05_zaJw.png"/></div></figure><p id="b673" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，具有最低 1-R2 比率的变量可以很好地代表聚类，该变量将被使用，而来自该聚类的其他变量将被丢弃。这就是我们如何实现降维。</p><p id="5dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用 SAS 和 Python 来实现。SAS 和 Python 之间的集群总数不匹配。在 SAS 中，总共有 35 个集群，而在 Python 中有 40 个。然而，在大多数集群中的可变分配和它们的 1-R2 比率是匹配的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kj"><img src="../Images/66373f3eee8109505db8607723b61b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P307NYqT3AIwR5045mfs8w.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/53a7fc544ddf3b1ae338661e46d45cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-TduMx0vUgn2irFEHvXkg.png"/></div></div></figure><p id="bbc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入数据集包含 63 个变量，包括哑变量、缺失指标变量等。在最后的输出中，它给出了包含不同变量的聚类，我们将基于 1-R2 比率选择一个变量。</p><p id="a580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为有 40 个集群，所以将有 40 个变量而不是 63 个变量。</p><p id="84d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用的是 maxeigval = 0.7。这意味着如果第二特征值大于 0.7，簇将分裂。该参数值越大，给出的聚类越少，所解释的变化也越少。较小的值给出更多的聚类和更多的变化解释。通常选择 1，因为它代表特征值的平均大小。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kl"><img src="../Images/c25211e60d14cc955fad2e0693009b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hbgsGYWIIwd3FEHGmNWIA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">SAS 代码</figcaption></figure><p id="80c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前 10 个集群的 SAS 输出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es km"><img src="../Images/78bd5d7a81280020e6522d6006b5046b.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*qdVli_YRO9YUHsLn6RymLg.png"/></div></figure><p id="9f40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢，</p><p id="7576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乌尔维什·沙阿</p></div></div>    
</body>
</html>