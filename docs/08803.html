<html>
<head>
<title>Python OOP — Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python OOP —继承</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-oop-inheritance-20f973fe9096?source=collection_archive---------4-----------------------#2020-08-14">https://medium.com/analytics-vidhya/python-oop-inheritance-20f973fe9096?source=collection_archive---------4-----------------------#2020-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/011a622da56bd45f37d3ef3534ece911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*Vl5KyxsfL3GwXS5Qm-STuA.png"/></div></figure><p id="6b84" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">继承是面向对象编程中的一个关键概念。它使我们能够从现有的类创建一个新的类。新类是现有类的专用版本，它继承了现有类的所有非私有变量和方法。</p><p id="030d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">什么时候应该使用继承？答案是，每当我们碰到一个<strong class="io hj"> <em class="jk">就是一个</em> </strong> <em class="jk"> </em>的关系对象。</p><ul class=""><li id="f123" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">Python <strong class="io hj"> <em class="jk">是一种</em> </strong>编程语言</li><li id="70cc" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">特斯拉<strong class="io hj"> <em class="jk">是一辆</em> </strong>汽车</li><li id="d48e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">谷歌<strong class="io hj"> <em class="jk">是一家</em> </strong>公司</li></ul><p id="85a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从上面的例子中，我们可以通过扩展现有的类(编程语言、汽车、公司)来构建新的类</p><h1 id="bb8d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">语法和术语</h1><p id="d00c" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">当我们基于现有类创建新类时，我们使用以下术语:</p><ul class=""><li id="7ed1" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">父类(超级类)</li><li id="ebea" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">子类(子类):这个类继承了超类</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ed3f" class="ll ka hi lh b fi lm ln l lo lp">Class ParentClass:</span><span id="9455" class="ll ka hi lh b fi lq ln l lo lp">Class ChildClass (ParentClass):</span></pre><p id="1ef3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">示例</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="84a2" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    def __init__(self, make, color, model):<br/>        self.make = make<br/>        self.color = color<br/>        self.model = model<br/>    def printDetails(self):<br/>        print ("Manufacturer: ", self.make)<br/>        print ("Color: ", self.color)<br/>        print ("Model: ", self.model)</span><span id="2540" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    def __init__(self, make, color, model, doors):<br/>        Vehicle.__init__(self, make, color, model)<br/>        self.doors = doors<br/>    def printCarDetails(self):<br/>        self.printDetails()<br/>        print ("Doors: ", self.doors)</span></pre><p id="9fe0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个例子中，Vehicle 是一个父类，我们实现了一个从这个 Vehicle 类扩展而来的 Car 类。</p><h1 id="a68f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Super()函数</h1><p id="22ba" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">当我们实现继承时，它用在子类中，并且它引用父类而不显式命名它。</p><p id="3d9c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它主要用于三种情况</p><h2 id="8714" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated"><strong class="ak"> 1。访问父类属性</strong></h2><p id="5f65" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">如果我们在车辆类中定义了一个名为 fuelCap 的字段来跟踪车辆的燃料容量。如果我们实现了一个从 Vehicle 类扩展而来的 Car 类，并且我们在 Car 类中声明了一个具有相同名称 fuelCap 但不同值的类属性，我们可以在子类中引用父类的 fuelCap，然后我们将使用 super()函数。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="901b" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    fuelCap = 100</span><span id="b514" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    fuelCap = 50<br/>    <br/>    def display(self):<br/>        print ("Fuel Cap from Vehicle: ", super().fuelCap)</span><span id="b8ab" class="ll ka hi lh b fi lq ln l lo lp">        print ("Fuel Cap from Car: ", self.fuelCap)</span></pre><h2 id="abf5" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated">2.<strong class="ak">调用父类方法</strong></h2><p id="0746" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">super()也可以与方法一起使用。当父类和直接子类有同名的方法时，我们使用 super()来访问子类中父类的方法。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0d8b" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    def display(self):<br/>        print ("This is from Vehicle.")</span><span id="236f" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    def display(self):<br/>        super().display()<br/>        print ("This is from Car.")</span></pre><h2 id="3257" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated"><strong class="ak"> 3。与初始值一起使用</strong></h2><p id="8843" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">super()的另一个重要用途是从子类的初始化器内部调用父类的初始化器。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8e3c" class="ll ka hi lh b fi lm ln l lo lp"># Parent class<br/>class ParentClass():<br/>    def __init__(self, a, b):<br/>        self.a = a<br/>        self.b = b</span><span id="146c" class="ll ka hi lh b fi lq ln l lo lp"># Child class<br/>class ChildClass(ParentClass):<br/>    def __init__(self, a, b, c):<br/>        super().__init__(a,b)<br/>        self.c = c</span></pre><p id="c343" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们用 super()来改变我们前面的例子</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="72e5" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    def __init__(self, make, color, model):<br/>        self.make = make<br/>        self.color = color<br/>        self.model = model<br/>    def printDetails(self):<br/>        print ("Manufacturer: ", self.make)<br/>        print ("Color: ", self.color)<br/>        print ("Model: ", self.model)</span><span id="8230" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    def __init__(self, make, color, model, doors):<br/>        #Vehicle.__init__(self, make, color, model)<br/>        super().__init__(make, color, model)  <br/>        self.doors = doors<br/>    def printCarDetails(self):<br/>        self.printDetails()<br/>        print ("Doors: ", self.doors)</span></pre><h1 id="2aaf" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">继承的类型</h1><p id="e6b7" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">有五种类型的继承:</p><ol class=""><li id="5337" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj me jr js jt bi translated">单一的</li><li id="a896" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj me jr js jt bi translated">多层次</li><li id="c0e0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj me jr js jt bi translated">等级体系的</li><li id="18ea" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj me jr js jt bi translated">多重</li><li id="6f82" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj me jr js jt bi translated">混合物</li></ol><h2 id="0b3f" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated">单一遗传</h2><p id="84b7" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">在这种情况下，只有一个类是从另一个类扩展而来的。</p><p id="7614" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">汽车— — — →车辆</p><p id="8605" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">(孩子)— — →(父母)</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9c64" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    def __init__(self, make, color, model):<br/>        self.make = make<br/>        self.color = color<br/>        self.model = model<br/>    def printDetails(self):<br/>        print ("Manufacturer: ", self.make)<br/>        print ("Color: ", self.color)<br/>        print ("Model: ", self.model)</span><span id="b8ef" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    def printCarDetails(self):<br/>        print ("This is a car.")</span></pre><h2 id="e635" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated">多层次继承</h2><p id="f333" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">当一个类是从一个类派生出来的，而这个类本身又是从另一个类派生出来的，这就叫做多级继承。</p><p id="b06b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">SUV— →轿车—→汽车</p><ul class=""><li id="6284" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">SUV <strong class="io hj">是一辆</strong>汽车</li><li id="3174" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">汽车<strong class="io hj">是</strong>车辆</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="18c2" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    def setSpeed(self, speed):<br/>        self.speed = speed<br/>        print ("Current speed is set to: ", self.topSpeed)</span><span id="2ba7" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    def openDoor(self):<br/>        print ("Door is now open.")</span><span id="2a1f" class="ll ka hi lh b fi lq ln l lo lp">class SUV(Car):<br/>    def openTruck(self):<br/>        print (Trunk of SUV is now open.")</span></pre><h2 id="633d" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated">分层继承</h2><p id="925b" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">当一个以上的类从同一个类继承时，它被称为层次继承。</p><ul class=""><li id="6e6d" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">一个<code class="du mf mg mh lh b">Car</code> <strong class="io hj">是一个</strong> <code class="du mf mg mh lh b">Vehicle</code></li><li id="ffa8" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个<code class="du mf mg mh lh b">Truck</code>是一个<strong class="io hj">是一个<code class="du mf mg mh lh b">Vehicle</code></strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="88f5" class="ll ka hi lh b fi lm ln l lo lp">class Vehicle:<br/>    def setSpeed(self, speed):<br/>        self.speed = speed<br/>        print ("Current speed is set to: ", self.topSpeed)</span><span id="bc9f" class="ll ka hi lh b fi lq ln l lo lp">class Car(Vehicle):<br/>    pass</span><span id="cd01" class="ll ka hi lh b fi lq ln l lo lp">class Truck(Vehicle):<br/>    pass</span></pre><h2 id="32f8" class="ll ka hi bd kb lr ls lt kf lu lv lw kj ix lx ly kn jb lz ma kr jf mb mc kv md bi translated">多重遗传</h2><p id="0795" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">当一个类是从一个以上的基类派生出来的时候，就叫做多重继承。</p><ul class=""><li id="1d6a" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><code class="du mf mg mh lh b">HybridEngine</code> <strong class="io hj">是一个</strong> <code class="du mf mg mh lh b">ElectricEngine</code>。</li><li id="c22e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><code class="du mf mg mh lh b">HybridEngine</code> <strong class="io hj">是一个</strong> <code class="du mf mg mh lh b">CombustionEngine</code>也是。</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ede0" class="ll ka hi lh b fi lm ln l lo lp">class CombustionEngine():<br/>    def setTankCapacity(self, tankCapacity):<br/>        self.tankCapacity = tankCapacity</span><span id="2419" class="ll ka hi lh b fi lq ln l lo lp">class ElectricEngine():<br/>    def setChargeCapacity(self, chargeCapacity):<br/>        self.chargeCapacity = chargeCapacity</span><span id="dfad" class="ll ka hi lh b fi lq ln l lo lp">class HybridEngine(CombustionEngine, EletricEngine):<br/>    def printDetails(self):<br/>        print ("Tank capacity: ", self.tankCapacity)<br/>        print ("Charge capacity: ", self.chargeCapacity)</span></pre><p id="bf52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">混合遗传</p><p id="88e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它是多重和多层次传承的结合。</p><ul class=""><li id="419f" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><code class="du mf mg mh lh b">CombustionEngine</code>T23 是一个 T9。</li><li id="9611" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><code class="du mf mg mh lh b">ElectricEngine</code>T25 是一个 T11。</li><li id="9db0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><code class="du mf mg mh lh b">HybridEngine</code>T27 是一个 T13 和一个<code class="du mf mg mh lh b">CombustionEngine</code>。</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="592f" class="ll ka hi lh b fi lm ln l lo lp"># Parent class<br/>class Engine:<br/>    def setPower(self, power):<br/>        self.power = power</span><span id="79fa" class="ll ka hi lh b fi lq ln l lo lp"># Child class inherited from Engine<br/>class CombustionEngine(Engine):<br/>    def setTankCapacity(self, tankCapacity):<br/>        self.tankCapacity = tankCapacity</span><span id="be2e" class="ll ka hi lh b fi lq ln l lo lp">class ElectricEngine(Engine):<br/>    def setChargeCapacity(self, chargeCapacity):<br/>        self.chargeCapacity = chargeCapacity</span><span id="f402" class="ll ka hi lh b fi lq ln l lo lp"># Child class inherited from CombustionEngine and EletricEngine<br/>class HybridEngine(CombustionEngine, EletricEngine):<br/>    def printDetails(self):<br/>        print ("Tank capacity: ", self.tankCapacity)<br/>        print ("Charge capacity: ", self.chargeCapacity)<br/>        print ("Power: ", self.power)</span></pre></div></div>    
</body>
</html>