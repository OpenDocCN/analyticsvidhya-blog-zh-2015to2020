<html>
<head>
<title>Bubble Sort: Implementation and Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冒泡排序:实现和分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bubble-sort-implementation-and-analysis-557998f63096?source=collection_archive---------13-----------------------#2020-04-21">https://medium.com/analytics-vidhya/bubble-sort-implementation-and-analysis-557998f63096?source=collection_archive---------13-----------------------#2020-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">排序是编码的生命线。我们几乎总是希望事情按照自然的顺序进行。项目列表的字母顺序更容易理解。按照日期顺序查看你的银行交易历史，会更好分析。</p><p id="5a90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我们有高级的、易于读写的编程语言，它们通常有内置的排序功能。例如，在C#中，你只需要调用数组。Sort()方法，C#会为您完成剩下的工作。</p><p id="d267" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是理解幕后发生的事情会让你成为一个更好的程序员。您可以分析数据排序的快慢，以及该算法对应用程序的影响。</p><p id="c92f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将研究最基本的排序算法——冒泡排序。它有一个有趣的名字，很容易理解。我们将首先学习什么是冒泡排序，并分析算法的复杂性。然后我们用C#写一些代码。我们还将尝试在布尔变量的帮助下提高代码的性能。</p><p id="3b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">冒泡排序—定义</strong></p><p id="b212" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从冒泡排序到排序算法就像学习A-B-C-D来理解英语一样！让我们跳到例子中，一步一步地学习算法。考虑以下数字数组:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/47168a6dec235c30d918b931ae9c8919.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/0*BlaLLWMdKnWiJjEv"/></div></figure><p id="b96b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从数组中的前两个元素开始，比较它们。如果第一个元素大于第二个元素，则交换元素。</p><p id="cb5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">对比:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jm"><img src="../Images/d3b211ed8d1afd9c74402131a9fc9887.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*t6zEhuhm1rGhyNvT"/></div></figure><p id="4e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">互换:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jn"><img src="../Images/d3502f7db8f47cca5f9c4b1ccf6a955c.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*xHZ4RsdC4NJLBSzk"/></div></figure><p id="4d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续下面的两个元素。像我们在上一步中所做的那样再次比较和交换:</p><p id="854e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">比较:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jo"><img src="../Images/eff8608265945d668f01dfcd7bea4a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/0*3ZhymoFPGuw715ji"/></div></figure><p id="1eb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这两个元素已经排序，所以我们不交换并继续下两个元素</p><p id="a881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">比较:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/c0e3989d9822910b254cb7205b8e4077.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/0*a_qyU0UXPFbz-9Fs"/></div></figure><p id="fb9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">互换:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/4487f20b7f73a7b615a47a79291480be.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*E9uWGQq4A2x69I1q"/></div></figure><p id="fdda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，比较并交换最后两个元素:</p><p id="b08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">比较:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/b0dfb7ebeb21e22c763ba567b65f4da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*tpdg79Pe8a-PWRLN"/></div></figure><p id="03ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">互换:</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es js"><img src="../Images/59e152e86ff156b369c0304b2bfcd4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*HhklnqcQ7oVna6dC"/></div></figure><p id="0ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们一直工作到最后一个索引。现在我们的阵列看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/3ba96a61cce857f0fe8521f51a214c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/0*NKhCB1mJaZNUJZVT"/></div></figure><p id="15e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在这里暂停一下，指出<strong class="ih hj">这只是数组的一次传递。</strong>我们从索引0到索引4，一路上进行比较和交换，这一遍的结果是数组(6)中最高的元素在最后一个位置。换句话说，<strong class="ih hj">我们将<em class="jl">最高的元素</em>冒泡到最后一个位置</strong>——因此得名，冒泡排序。</p><p id="d58f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您可能已经猜到的那样，算法不会就此停止，因为在第一遍之后，我们刚刚将一个元素放到了正确的位置，而我们仍然将前四个元素放在了错误的位置。</p><p id="9c9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们又做了一遍，但是这次我们从索引0到索引3(因为我们的最后一个元素已经被排序了)。让我们把最后一个元素灰掉，让事情更清楚。现在我们已经掌握了比较和交换是如何工作的，让我们快速浏览第二遍:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ju"><img src="../Images/ec3966adff4dcc9bd0c8fe2e9077f9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*61rIpMBAGWBrSPjT"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jz"><img src="../Images/962e16850fcea20be4bdc67dd41c6f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHtsEGaYV476X7_m"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ka"><img src="../Images/70494214e198ff239fcf6f48d18fa107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nq3XmaTeTXIzEOPl"/></div></div></figure><p id="d50a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过这一步后，我们现在已经将数组中第二高的元素放到了正确的位置:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kb"><img src="../Images/6f07c9fd4ce7807d5b4f639b6608f269.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/0*avpoLIzT_AkHHD4s"/></div></div></figure><p id="9988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经减少了2遍，但是我们的数组仍然没有排序。让我们再做一遍，但这次只到索引2，因为最后两个元素已经排序:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ju"><img src="../Images/a58f15081c7f98b8a673683fffd07f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ke8O85POw1M9cUkN"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ju"><img src="../Images/b0389f3b09b099107c191cb32452460c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DHR2Z3bXw4O6Oq5E"/></div></div></figure><p id="4d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三遍过后，我们的第三高元素就位了:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kc"><img src="../Images/d5f8091ef7f29670142fd49181da9111.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*w0eGpcCRJBjA-uV7"/></div></div></figure><p id="149f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还有一关要走，因为前两个元素还没有排序。第四遍将只有一次比较和交换操作:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kd"><img src="../Images/cc891c43080e442e75752682939d478d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Taj48fHC5QKNseR5"/></div></div></figure><p id="9e14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步之后，我们有了排序后的数组:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/f6f5292e398eeba75c9b7b72292887e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*B2AvOARoHq2q2gBm"/></div></figure><p id="8610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分析和复杂性</strong></p><p id="3cb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在这里停下来，记下一路上发生的一些事情:</p><ol class=""><li id="ddd6" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated">我们的数组中有5个元素，我们能够通过4次对数组进行排序。这意味着对于N个元素，冒泡排序将遍历数组N-1次。</li><li id="b437" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">每经过一次，我们能够排序1个元素。从这个角度来看，我们可以再次得出结论，对于N个元素的数组，我们需要N-1次数组遍历。</li><li id="81f3" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">在第一步中，我们做了4次比较。在第二步中，我们进行了3次比较。在第三步中，我们做了两次比较。在第4阶段，我们做了1次比较。因此，对于N个元素的数组，冒泡排序将进行(N-1) + (N-2) + (N-3) +……+ 1次比较。在我们5个元素的例子中，我们做了4+3+2+1 = 10次比较。</li><li id="848c" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">在传递1中，我们进行了3次交换，在传递2中，我们进行了2次交换，在传递3中，我们进行了1次交换，在传递4中，我们再次进行了1次交换。这相当于3+2+1+1 = 7次交换。</li><li id="d17f" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">总之，为了对我们的5个元素的数组进行排序，我们进行了4次传递+ 10次比较+ 7次交换=或者总共21个步骤或操作。我们也可以说总步数接近于(5) ( <em class="jl"> 5的平方)</em>。</li><li id="6a5e" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">最坏的情况是我们将数组按逆序排序(降序)。在这种情况下，我们将对每个比较进行交换。在上面的例子中，如果所有的元素都是降序排列的，那么为了对数组进行排序，我们将进行4次遍历+ 10次比较+ 10次交换，总共24次操作。(再次几乎等于5)</li></ol><p id="a214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你遵循并理解了我们刚才做的所有6个步骤，那么你就解决了冒泡排序的复杂性！对于具有N个元素的数组，冒泡排序将需要接近N个步骤来对数组进行完全排序。换句话说，冒泡排序的复杂度是O(N)或N的平方阶。这意味着如果我们有一个6个元素的数组，冒泡排序将需要接近36步，10个元素100步，20个元素400步。您可能已经猜到，当我们有大量数据时，冒泡排序并不是一个很好的选择。但是通过学习冒泡排序，通过理解为什么它会随着数据的增加而变得低效，我们可以开发出更好更快的算法！</p><p id="12d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">实现</strong></p><p id="55a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是C#中冒泡排序的实现:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kt"><img src="../Images/2703e5a9069a983006069d5c60dc6431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rc0dqqhtD1EvUxqY"/></div></div></figure><ul class=""><li id="7b12" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc ku kl km kn bi translated"><em class="jl"> sortedIndex </em>被初始化为指向数组的最后一个元素。每经过一次，我们将把sortedIndex减1</li><li id="2d0d" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc ku kl km kn bi translated"><em class="jl"> Pass </em>变量将跟踪数组的传递次数，以便对数组进行完全排序</li><li id="7997" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc ku kl km kn bi translated"><em class="jl"> ComparisonSteps </em>变量将跟踪我们进行比较的次数</li><li id="6eed" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc ku kl km kn bi translated"><em class="jl">互换步骤</em>变量将跟踪我们进行的互换数量</li><li id="33f1" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc ku kl km kn bi translated">而(sortedIndex &gt; 0)表示数组的每次传递。</li><li id="ec92" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc ku kl km kn bi translated">for循环在一次传递中涵盖了所有的比较和交换</li></ul><p id="b084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们在代码中初始化了一个由10个元素组成的数组，该数组是降序排列的。这种情况代表了最坏的情况。运行上面的代码，我们得到以下结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kv"><img src="../Images/49f6cd9fcc8cc019972366978cbb8596.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/0*e7Iqk-JzEjuJBIqU"/></div></div></figure><p id="717d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法经过9次通过、45个比较步骤和45个交换步骤，总共得到99个步骤，接近10。因此给出了算法复杂性的一个很好的例子。</p><p id="2731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">稍微好一点的实现</strong></p><p id="724d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们之前所做的实现将进行N-1遍，并且沿途比较每两个元素。现在考虑一种情况，数组的一些元素已经排序。例如:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e15d8ebcfa738383dc1a3cdbca5ef042.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/0*fTLY25XT6c_tbXS_"/></div></figure><p id="0090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，最后三个元素已经排序，但是根据算法，我们仍然需要比较所有的元素。</p><p id="fe69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以稍微改进我们算法的实现，首先检查我们是否已经有了一个排序的数组。我们将声明一个布尔变量“sorted ”,它将被设置为false。在1次传递中，如果我们进行交换，我们将变量设置为true。现在，如果我们完成了传递，但是我们没有进行任何交换(因为所有的元素都已经排序了)，布尔变量“sorted”仍然会被设置为false。这将表明数组已经排序，我们可以安全地结束算法。</p><p id="797f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们修改后的代码如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kw"><img src="../Images/89def7ee6ed16caadc11485d03abcfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RlttDLqR7loLO6lM"/></div></div></figure><p id="9b90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数组[1，0，2，5，6]上运行上述代码时，我们得到以下输出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/9c0c639a03cc4bbff4003418cb2503ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/0*1CozIkzpgsXuH5bg"/></div></figure><p id="c9c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们只进行了1次传递和1次交换步骤！！这都是因为我们沿途检查了数组的其余部分是否已排序，并在不再需要遍历每个元素时退出了while循环。</p><p id="dbcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="2abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们深入了解了冒泡排序算法。这是一个简单的排序算法，它比较数组中的每个元素，每次都将较大的元素向右移动。</p><p id="7bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">冒泡排序的复杂度是O(N)，我们做了深入的分析并实现了代码来理解这一点。冒泡排序可能不是对大量数据进行排序的好算法。</p><p id="8c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">特征图像:</em><a class="ae ky" href="https://www.pexels.com/@padrinan" rel="noopener ugc nofollow" target="_blank"><em class="jl">https://www.pexels.com/@padrinan</em></a></p></div></div>    
</body>
</html>