<html>
<head>
<title>Sorting Algorithms in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的排序算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sorting-algorithms-in-javascript-a20a7f33337c?source=collection_archive---------23-----------------------#2020-08-30">https://medium.com/analytics-vidhya/sorting-algorithms-in-javascript-a20a7f33337c?source=collection_archive---------23-----------------------#2020-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="70e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从我第一次听说排序算法，它们就一直是有趣的同义词！</p><p id="90c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从列表中组织元素是我们日常生活中经常需要的东西，通常顺序非常简单，就像数字或尊重一些优先级标志。然而，现在的开发人员对他们的实现非常抽象。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c46afd963c8582bcf38869b94ecdb66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VA1CXCTd_0zdo-VauSk2cQ.jpeg"/></div></div></figure><p id="f59e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然问题很简单，但解决方案并不是很直接，就我自己而言，我经常看到自己重温最常见的算法。几个月前，我决定用 JS 实现 4 个最常用的排序算法:</p><ul class=""><li id="baba" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">插入排序；</li><li id="3f9e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">冒泡排序；</li><li id="7be9" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">合并排序；</li><li id="1a1b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">快速排序。</li></ul><p id="bf3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇文章能帮助你理清它们的概念，并为你提供一个简单的实现。</p><h1 id="a278" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">插入排序</strong></h1><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="3bd9" class="lg ke hi lc b fi lh li l lj lk">function insertionSort(arrayToSort) { <br/>  for (let i = 1; i &lt; arrayToSort.length; i++) {  <br/>    let j = i;  <br/>    while (j &gt; 0 &amp;&amp; arrayToSort[j-1] &gt; arrayToSort[j]) {   <br/>      swap(arrayToSort, j-1, j);<br/>      j--;   <br/>    } <br/>  } <br/>  return arrayToSort;<br/>}</span></pre><p id="e00b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入排序的工作方式是从列表中逐个取出元素，然后将这些值与当前列表中已经访问过的值进行比较。在<em class="ll"> n </em>次迭代结束时，我们保证了<em class="ll"> n </em>个元素被排序。</p><p id="b73c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*最坏情况 O(n^{2})比较<br/> *最好情况 O(n)比较</p><h1 id="9f48" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">冒泡排序</h1><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="c4ff" class="lg ke hi lc b fi lh li l lj lk">function bubbleSort(arrayToSort) {<br/>  for (let i = 0; i &lt; arrayToSort.length; i++) {<br/>    for (let j = 0; j &lt; (arrayToSort.length - i - 1); j++) {<br/>      if (arrayToSort[j] &gt; arrayToSort[j+1]) {<br/>        swap(arrayToSort, j, j+1);<br/>      }<br/>    }   <br/>  }<br/>  return arrayToSort;<br/>}</span></pre><p id="7b3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">冒泡排序既简单又低效。效率将取决于作为输入给出的列表，但是大多数时候只有在使用几乎排序/排序列表时才是有效的。</p><p id="da06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*最坏情况下的 O(n^{2})比较<br/> *最好情况下的 O(n^{2})比较—如果添加额外的检查来验证数组是否已经排序，则可能为 O(n)</p><h1 id="230e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">合并排序</h1><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="6103" class="lg ke hi lc b fi lh li l lj lk">function mergeSort(arrayToSort) {<br/>  if (arrayToSort.length === 1) {<br/>    return arrayToSort;<br/>  }<br/>  const middle = Math.floor(arrayToSort.length / 2);<br/>  const left = arrayToSort.slice(0, middle); <br/>  const right = arrayToSort.slice(middle);</span><span id="874c" class="lg ke hi lc b fi lm li l lj lk">  return merge(mergeSort(left), mergeSort(right));<br/>}</span><span id="27d9" class="lg ke hi lc b fi lm li l lj lk">function merge(left, right) {<br/>  let result = [];<br/>  while (left.length &amp;&amp; right.length) {<br/>    if (left[0] &gt; right[0]) {<br/>      result.push(right.shift());<br/>    } else {<br/>      result.push(left.shift());<br/>    }<br/>  }<br/>  while (left.length) {<br/>    result.push(left.shift());<br/>  }<br/>  while (right.length){<br/>    result.push(right.shift());<br/>  }<br/>  return result;<br/>}</span></pre><p id="70ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并排序有利于合并已经排序的列表。实现从将输入列表分解成两个独立的列表开始，递归地分解成更小的部分，重点是保持独立列表有组织，并保持左侧比右侧“小”。</p><p id="43ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*最坏情况 O(n log n)比较<br/> *最好情况 O(n log n)比较</p><h1 id="235d" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">快速排序</h1><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="d70c" class="lg ke hi lc b fi lh li l lj lk">function quickSort(arrayToSort) {<br/>  if (arrayToSort.length &lt;= 1) {<br/>    return arrayToSort;<br/>  }<br/>  let left = [];<br/>  let right = [];<br/>  let result = [];<br/>  let pivot = arrayToSort.shift();<br/>  <br/>  for (let i=0; i &lt; arrayToSort.length; i++) {<br/>    if (arrayToSort[i] &gt; pivot) {<br/>      right.push(arrayToSort[i]);<br/>    } else {<br/>      left.push(arrayToSort[i]);<br/>    }<br/>  }<br/>  return result.concat(quickSort(left), pivot, quickSort(right));<br/>}</span></pre><p id="5f8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速排序对大列表很有用。使用分而治之的方法。算法选择一个中枢，并从该中枢将列表分成更小的列表块。请记住，选择一个好的枢轴(枢轴应该尽可能接近中间值，在当前的实现中，我选择第一个元素)可以极大地提高效率。使用多线程方法可以很容易地分配该算法的执行。</p><p id="2e97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*最坏情况 O(n log n)比较<br/> *最好情况 O(n log n)比较</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="d125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在一些算法中使用了交换函数。这个函数应该是这样的:</p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="33e4" class="lg ke hi lc b fi lh li l lj lk">function swap(arrayToSwap, firstIndex, secondIndex) {<br/>  const temp = arrayToSwap[firstIndex];<br/>  arrayToSwap[firstIndex] = arrayToSwap[secondIndex];<br/>  arrayToSwap[secondIndex] = temp;<br/>}</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="f03a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有很多关于排序算法的信息，请随意探索。我还创建了一个公共的 GitHub repo，代码如下:<br/><a class="ae lu" href="https://github.com/JMGomes/SortingAlgorithms/" rel="noopener ugc nofollow" target="_blank">https://github.com/JMGomes/SortingAlgorithms/</a></p><p id="24df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在那个回购上，你会发现<strong class="ih hj">我用一个名为<em class="ll"> customCompare() </em> </strong> <em class="ll">的抽象函数替换了普通的比较语句(value1 &gt; value2)。</em>这允许用户使用更复杂的比较语句，例如读取对象属性。</p><p id="6284" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个 repo，<strong class="ih hj">您还可以传递您的自定义输入数组，并通过每个算法的执行时间进行比较。</strong>在我看来，这是最好玩的部分。</p><p id="45f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢</p></div></div>    
</body>
</html>