<html>
<head>
<title>Probabilistic Neural Network and Competitive Probabilistic Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">概率神经网络和竞争概率神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/probabilistic-neural-network-and-competitive-probabilistic-neural-network-4581be53b290?source=collection_archive---------11-----------------------#2019-09-28">https://medium.com/analytics-vidhya/probabilistic-neural-network-and-competitive-probabilistic-neural-network-4581be53b290?source=collection_archive---------11-----------------------#2019-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c0af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">大家早上好。今天，我想就概率神经网络(PNN)和竞争概率神经网络(CPNN)做一个简短的介绍。本帖参考Zeinali和故事文章:</p><p id="f520" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Zeinali，Yasha &amp; Story，Brett。(2017).竞争概率神经网络。综合计算机辅助工程。24.1–14.10.3233/ICA-170540。</p><p id="65a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在那里，PNN作为一种先行算法被研究。这里我将使用R作为编程工具。其实已经有一个名为“pnn”的R库了。该库执行PNN功能，使用简单。然而，我认为我必须编写自己的R脚本来执行CPNN过程，作为PNN的扩展。这是因为我仍然找不到R的仓库下的CPNN库。在下面的脚本中，我也将提供我自己的PNN函数。先说距离平方函数的定义。顺便说一下，请注意，我使用的变量名与论文中指定的相似。我也用“dplyr”和“ggplot2”库，先加载吧。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="08a4" class="jt ju hi jp b fi jv jw l jx jy">suppressMessages(suppressWarnings(<strong class="jp hj">library</strong>(dplyr)))<br/>suppressMessages(suppressWarnings(<strong class="jp hj">library</strong>(ggplot2)))<br/><br/>squared.distance &lt;- <strong class="jp hj">function</strong>(input1, input2) input1 %&gt;% rbind(input2) %&gt;% dist %&gt;% '^'(2)</span></pre><p id="701e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我定义了omega.ij函数。请阅读这篇论文，以便你至少有一个初步的理解。比如这个omega.ij描述了什么。不过，如果你对后面发生的事情不感兴趣，也没关系。只需复制脚本的每一部分，并将函数应用于数据集(我将在本文末尾向您展示如何操作)。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4818" class="jt ju hi jp b fi jv jw l jx jy">omega.ij &lt;- <strong class="jp hj">function</strong>(x.new, x.c.ij, sigma.input) {<br/>  argument &lt;- -squared.distance(x.new, x.c.ij) %&gt;% '/'(2 * (sigma.input^2)) %&gt;% exp<br/>  <strong class="jp hj">return</strong>(argument / (<br/>      ((2 * pi)^(length(x.new) / 2)) * (sigma.input^length(x.new))<br/>    )<br/>  )<br/>}</span></pre><p id="e1a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我定义p.x.new.ci函数如下。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4414" class="jt ju hi jp b fi jv jw l jx jy">p.x.new.ci &lt;- <strong class="jp hj">function</strong>(x.new, data.input, sigma.input, gamma.input = NULL) {<br/>  <strong class="jp hj">if</strong>(!is.null(gamma.input) &amp; is.numeric(gamma.input)) {<br/>    omega.sum &lt;- data.input %&gt;% nrow %&gt;% '*'(gamma.input) %&gt;% round<br/>    omega &lt;- apply(data.input, 1, <strong class="jp hj">function</strong>(input1) <br/>      omega.ij(x.new, input1, sigma.input)) %&gt;% sort %&gt;% rev<br/>    <strong class="jp hj">return</strong>(omega[1:omega.sum] %&gt;% mean(na.rm = TRUE))<br/>  } <strong class="jp hj">else</strong> {<br/>    apply(data.input, 1, <strong class="jp hj">function</strong>(input1) <br/>      omega.ij(x.new, input1, sigma.input)) %&gt;% mean(na.rm = TRUE) <br/>  }<br/>}</span></pre><p id="8ff6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是PNN的定义和CPNN的主要功能。两种算法共享相同的功能。为了区分它是PNN还是CPNN，对于PNN,“γ输入”的自变量必须填充为空，对于CPNN必须填充范围从0到1的实数。我将默认值NULL赋予了“gamma.input”参数，因此这意味着对函数的默认调用执行PNN算法。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a1b8" class="jt ju hi jp b fi jv jw l jx jy">c.pnn &lt;- <strong class="jp hj">function</strong>(x.new, data.input, class.input, sigma.input, gamma.input = NULL) {<br/>  class.index &lt;- tapply(1:length(class.input), class.input, <strong class="jp hj">function</strong>(input1) <strong class="jp hj">return</strong>(input1))<br/>  p.x.new.result &lt;- sapply(<br/>    class.index, <strong class="jp hj">function</strong>(input1) {<br/>      p.x.new.ci(x.new, data.input[input1, ], sigma.input, gamma.input)<br/>    }<br/>  )<br/>  p.x.new.result &lt;- (p.x.new.result / sum(p.x.new.result)) %&gt;% round(3)<br/>  output &lt;- data.frame(<br/>    class.output = (class.input %&gt;% as.factor %&gt;% levels)[p.x.new.result %&gt;% which.max],<br/>    probability = p.x.new.result[p.x.new.result %&gt;% which.max]<br/>  )<br/>  rownames(output) &lt;- NULL<br/>  <strong class="jp hj">return</strong>(output)<br/>}</span></pre><p id="7eb3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们来试试算法。作者举例说明了一个非线性分离的数据(在他们的论文中显示为图表)。观测值的类别属性为矩形和圆形。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="8b6b" class="jt ju hi jp b fi jv jw l jx jy">data.input &lt;- expand.grid(x1 = seq(0.5, 1.5, length.out = 3), x2 = seq(-0.5, 0.5, length.out = 5))<br/>angle.1 &lt;- seq(0, 2*pi, length.out = 24) + runif(24, 0, .2)<br/>angle.2 &lt;- seq(0, 2*pi, length.out = 12) + runif(12, 0, .2)<br/>data.input &lt;- rbind(<br/>  data.input, cbind(<br/>    x1 = c(cos(angle.1) + 3.5, (cos(angle.2) * 0.8) + 3.5),<br/>    x2 = c(sin(angle.1), sin(angle.2) * 0.8)<br/>  )<br/>)<br/>data.input &lt;- rbind(<br/>  data.input, cbind(x1 = c(3, 3.5, 3.5, 4), x2 = c(0, -0.5, 0.5, 0))<br/>)<br/>data.input$Class &lt;- c(<br/>  rep('rect', 15), rep('circ', 36), rep('rect', 4)<br/>)</span></pre><p id="c97c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来看看数据</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="38be" class="jt ju hi jp b fi jv jw l jx jy">print(data.input)</span><span id="4dc1" class="jt ju hi jp b fi jz jw l jx jy">##          x1           x2 Class<br/>## 1  0.500000 -0.500000000  rect<br/>## 2  1.000000 -0.500000000  rect<br/>## 3  1.500000 -0.500000000  rect<br/>## 4  0.500000 -0.250000000  rect<br/>## 5  1.000000 -0.250000000  rect<br/>## 6  1.500000 -0.250000000  rect</span><span id="b400" class="jt ju hi jp b fi jz jw l jx jy">## 50 4.180493 -0.420629481  circ<br/>## 51 4.292294  0.110774459  circ<br/>## 52 3.000000  0.000000000  rect<br/>## 53 3.500000 -0.500000000  rect<br/>## 54 3.500000  0.500000000  rect<br/>## 55 4.000000  0.000000000  rect</span></pre><p id="0e5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有身材。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="1769" class="jt ju hi jp b fi jv jw l jx jy">ggplot(data.input, aes(x1, x2)) +<br/>  geom_point(<br/>    aes(color = Class), size = 3, shape = ifelse(data.input$Class == 'rect', 15, 16)<br/>  ) + scale_x_continuous(limits = c(0, 6)) + scale_y_continuous(limits = c(-1.5, 1.5)) +<br/>  theme_minimal()</span></pre><figure class="jk jl jm jn fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es ka"><img src="../Images/db86cb46f7e19dec0342d1dff07313ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViAPJa_C5eLw6wStloVd5A.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">训练数据集。</figcaption></figure><p id="1ccd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，现在让我们创建测试数据。这里的场景是，我想决定数据维空间的任何地方是矩形还是圆形。第一步是在空间内创造一个扩展的价值观。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="411f" class="jt ju hi jp b fi jv jw l jx jy">data.test &lt;- expand.grid(x1 = seq(0, 6, length.out = 50), x2 = seq(-1.5, 1.5, length.out = 50))</span></pre><p id="cdc3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一些顶级的data.test看起来像这样:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6b76" class="jt ju hi jp b fi jv jw l jx jy">head(data.test)</span><span id="57d3" class="jt ju hi jp b fi jz jw l jx jy">##          x1   x2<br/>## 1 0.0000000 -1.5<br/>## 2 0.1224490 -1.5<br/>## 3 0.2448980 -1.5<br/>## 4 0.3673469 -1.5<br/>## 5 0.4897959 -1.5<br/>## 6 0.6122449 -1.5</span></pre><p id="a981" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看看它们在数据空间中的位置。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="c4f8" class="jt ju hi jp b fi jv jw l jx jy">ggplot(data.input, aes(x1, x2)) +<br/>  geom_point(mapping = aes(x1, x2), data = data.test, color = gray(0, 0.2)) +<br/>  geom_point(<br/>    aes(color = Class), size = 3, shape = ifelse(data.input$Class == 'rect', 15, 16)<br/>  ) +<br/>  theme_minimal()</span></pre><figure class="jk jl jm jn fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es ka"><img src="../Images/2bfd074341a9ed1b6223f24f0ad2f2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktwDbnlCDNMW4Rzcttedug.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">数据维度空间中的测试数据。</figcaption></figure><p id="a78e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">需要记住的一点是，我们必须调整data.input和data.test的值。这个过程不会改变位置。只有值相对于参考数据成比例地改变。在这里，data.input是我们的引用数据集。因此它被缩放到自身，而data.test被缩放到data.input值。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="50cb" class="jt ju hi jp b fi jv jw l jx jy">data.input.scaled &lt;- scale(data.input[,1:2])<br/>data.test.scaled &lt;- scale(data.test, <br/>                          center = attr(data.input.scaled, 'scaled:center'), <br/>                          scale = attr(data.input.scaled, 'scaled:scale'))</span></pre><p id="aeaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一下，数据仍然相对于彼此位于相同的地层，但是相对于维度空间位于不同的位置。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="23e8" class="jt ju hi jp b fi jv jw l jx jy">ggplot(data.input.scaled %&gt;% as.data.frame, aes(x1, x2)) +<br/>  geom_point(mapping = aes(x1, x2), data = data.test.scaled %&gt;% as.data.frame, color = gray(0, 0.2)) +<br/>  geom_point(<br/>    aes(color = data.input$Class), size = 3, shape = ifelse(data.input$Class == 'rect', 15, 16)<br/>  ) + <br/>  labs(color = 'Class') +<br/>  theme_minimal()</span></pre><figure class="jk jl jm jn fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es ka"><img src="../Images/9bd2c41c4e41b44a8a4f12a35c316b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rb8RziVWuFEIsIprKL9iUA.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">训练和测试数据的缩放版本。</figcaption></figure><p id="c718" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们准备好识别数据的类别。使用PNN和/或CPNN进行测试。这需要一些时间，因为我们的测试数据集有2500个观察值。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="7ec9" class="jt ju hi jp b fi jv jw l jx jy">data.test.result &lt;- apply(data.test.scaled, 1, <strong class="jp hj">function</strong>(input) {<br/>  c.pnn(x.new = input, data.input = data.input.scaled, class.input = data.input$Class, sigma.input = 0.1,<br/>        gamma.input = 0.5)<br/>})</span></pre><p id="f83e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看最上面的输出。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="496b" class="jt ju hi jp b fi jv jw l jx jy">head(data.test.result)</span><span id="c6df" class="jt ju hi jp b fi jz jw l jx jy">## [[1]]<br/>##   class.output probability<br/>## 1         rect           1<br/>## <br/>## [[2]]<br/>##   class.output probability<br/>## 1         rect           1<br/>## <br/>## [[3]]<br/>##   class.output probability<br/>## 1         rect           1<br/>## <br/>## [[4]]<br/>##   class.output probability<br/>## 1         rect           1<br/>## <br/>## [[5]]<br/>##   class.output probability<br/>## 1         rect           1<br/>## <br/>## [[6]]<br/>##   class.output probability<br/>## 1         rect           1</span></pre><p id="c79e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">c.pnn函数提供了具有两个元素的向量，即类输出和概率。第一个元素是算法决定的类。第二个元素是数据集中可用类中所选类的概率值。因此，变量data.test.result是一个有2500个元素的列表，每个元素由一个有两个元素的向量组成。</p><p id="268f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们根据模型已经分类的类，通过对测试数据集着色来绘制我们的结果。为此，首先我们必须提取每个列表元素中的class.output元素。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f58f" class="jt ju hi jp b fi jv jw l jx jy">test.class &lt;- sapply(data.test.result, <strong class="jp hj">function</strong>(input) input$class.output)</span><span id="a5f4" class="jt ju hi jp b fi jz jw l jx jy">combined.data &lt;- data.frame(<br/>  rbind(data.input, cbind(data.test, Class = test.class)),<br/>  origin = c(rep('train', nrow(data.input)), rep('test', nrow(data.test)))<br/>) <br/><br/>ggplot(combined.data %&gt;% filter(origin == 'test'), aes(x1, x2)) +<br/>  geom_point(aes(color = Class)) +<br/>  geom_point(aes(x1, x2, fill = Class, shape = Class), data.input, inherit.aes = FALSE, size = 3) +<br/>  scale_shape_manual(values = c(21, 22)) + <br/>  theme_minimal()</span></pre><figure class="jk jl jm jn fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es ka"><img src="../Images/60b02ec7473af1208b22e36c75190b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nW5hqjb8lm8HgVmlkFVedQ.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">CPNN输出。</figcaption></figure><p id="c1c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从上图中，我们可以得出结论，我们的CPNN脚本一直在工作。它能够区分圆形和矩形的非线性可分区域。我认为是时候让读者去尝试另一种算法了:PNN。只需将参数“gamma.input”设置为空即可。从这个PNN/CPNN脚本中，我们仍然可以调整很多东西，例如，执行时间的改进。另一个是改变sigma和/或gamma输入的灵敏度响应。此外，混合分类和数字特征。我还想附上一份免责声明，我不承担任何关于上述脚本的使用责任。这是我的个人作品，没有任何保证。</p></div></div>    
</body>
</html>