<html>
<head>
<title>How Javascript is single threaded? In-Depth explaination of Event Loop and call stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript是如何单线程的？深入解释事件循环和调用堆栈</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-javascript-is-single-threaded-in-depth-explaination-of-event-loop-and-call-stacks-dbc7e4f6ca56?source=collection_archive---------14-----------------------#2020-04-17">https://medium.com/analytics-vidhya/how-javascript-is-single-threaded-in-depth-explaination-of-event-loop-and-call-stacks-dbc7e4f6ca56?source=collection_archive---------14-----------------------#2020-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="23af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约两年前，我开始学习Javascript，想找一些零碎的东西来探索它的内部工作原理。我听说过在浏览器上运行的v8运行时引擎，但对此一无所知，并开始在浏览器上做自己的研究和实验。大多数JS开发人员可能听说过术语V8，chrome的运行时，但有些人甚至不知道这是什么意思，是做什么的。</p><p id="f2a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，引擎盖下的Javascript是什么NodeJS的核心组件。JS是单线程、单一并发语言，它有一个调用栈、一个事件循环、一个回调队列和一些其他API。如果我们在浏览器中谈论v8运行时，下面的一个是它真正是什么的简化视图…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/4a05267831d96b40914cd7503ffc70d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*er3XdTeHaMN16w5C"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/11c37018b598ccf4894539af8eda7e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zfgCgIsWNVp8naAM.png"/></div></div></figure><p id="9d57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是调用栈？</strong></p><p id="5c1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您的Javascript代码逐行运行时，您可以将调用堆栈视为功能堆栈或执行堆栈。除非将代码部分交给回调队列，否则它会填充运行时引擎的调用堆栈。</p><p id="fc48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于理解，请考虑下面的图像。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/1ccb5bfe38667c961166fd513b1318c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*bT0ru6n97Ru3creC.gif"/></div></figure><p id="4b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，首先JS被设计为在main()线程上运行，所以当我们一起执行上面的代码时，main()函数将首先被调用。入口执行点是console.log()语句，执行将被停止，直到其中提供的参数没有完成其执行，即bar(6)。现在，bar(6)将被推送到堆栈上，然后它调用函数foo(3*6 ),因此位于顶部。现在，当foo()的执行完成时，它将通过从stack弹出条目返回结果，并到达bar(6)，bar(6)又将条目返回到控制台，并打印结果。</p><p id="dc6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你们一定都在我们的浏览器控制台中看到过长长的红色错误堆栈跟踪，它基本上指示了调用堆栈的当前状态，以及在函数中从上到下失败的地方，就像堆栈一样。请看下图，这是写在图片旁边的代码的结果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/0f534f08921720b0d99f2b155a58a201.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*0HE3OiQdtClYgcA7"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/5223a174fb9427e469d81f0a9e35f8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*TTYAtlnen8l_5S4t.png"/></div></figure><pre class="je jf jg jh fd js jt ju jv aw jw bi"><span id="a78d" class="jx jy hi jt b fi jz ka l kb kc">function add(a, b) {<br/>  throw Error("something went wrong");<br/>}function bar(a,b) {<br/>  add(3,4)<br/>  return a-b<br/>}bar(3,4)</span></pre><p id="4c69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，我们会陷入无限循环，因为Chrome浏览器的堆栈大小限制为16，000帧，这可能是由于重复的函数调用而发生的，浏览器试图为您取消并抛出“范围错误:超出最大堆栈大小”</p><p id="1c8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">web API</strong></p><p id="98f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Web API中有一些JS模块，如XMLHttpRequest、Timeout和DOM事件。Web API开始执行，当执行完成时，它将函数调用放在任务队列中，我们将在下一节讨论。WebAPIs本身不能将执行代码放到堆栈上，这就是任务队列的作用。</p><p id="8664" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当下面的代码执行时，它会立即被移交给webAPI并完成工作。</p><pre class="je jf jg jh fd js jt ju jv aw jw bi"><span id="9484" class="jx jy hi jt b fi jz ka l kb kc">//timeout or execution after some delay<br/>setTimeout(function() {<br/>   console.log('after delay')<br/>}, 5000);//XMLHttpRequest call<br/>fetch('https://example.api.com').then(function(result) {<br/>    console.log(result);<br/>});//DOM event<br/>document.getElementById('btn-submit').onclick = function(event) {<br/>    clicked++;<br/>    console.log(event.target.value);<br/>}</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e41a0efca675df337f3c462b37cfee09.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*wNExklv1oZRAS4yw"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es kd"><img src="../Images/9f3b4016f82572eb79db129c6e87ee82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YAhfKd_sui8USbcr.png"/></div></div></figure><p id="a282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请看上面的插图。当它将setTimeout推送到堆栈上时，它被发送到webapis运行模块并在后台执行，直到它完成执行。</p><p id="376e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">事件循环</strong></p><p id="6bf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事件循环的主要职责是监控任务队列和堆栈状态。如果要执行webapis任务队列中的一些函数回调，则事件循环会拾取这些回调，如果堆栈为空，则会将其放入堆栈中。如果堆栈处于执行状态，或者简单地说，如果它不为空，那么任务队列中的回调需要等待，直到调用堆栈变空。因此，setTimeout()函数不能保证以指定的延迟执行，如果调用堆栈函数花费更多的时间来执行，它可能必须在任务队列中等待。</p><p id="403a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，下面代码的执行不是异步的，而是以同步的方式执行。</p><pre class="je jf jg jh fd js jt ju jv aw jw bi"><span id="2fb1" class="jx jy hi jt b fi jz ka l kb kc">let arr = [2,3,7,8,9,11,3,4]arr.filter(i =&gt; i%2 == 0)<br/> .forEach(function(i) {<br/> console.log(i);<br/>})</span></pre><p id="8871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，根据上面的解释，很明显，使用0 ms延迟定义的setTimeout()函数不能保证立即执行，因为它首先被放入堆栈，然后由webapi运行计时器，并在任务队列中等待，然后由事件循环选择再次推送到调用堆栈。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/9fde9283faebb72886ed7a5acad51f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*adgcMzI1_XHcvpXZ"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ke"><img src="../Images/6fac4669780144bcad64dbdca4be05d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_3RQvjNpZYsvyx2J.png"/></div></div></figure><p id="fa5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于上面的代码，输出显示如下，在setTimeout()中编写的语句在最后执行并打印消息。</p><p id="5be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，上面解释的所有组件一起工作来保持JS代码的单线程执行。</p><p id="4a44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>