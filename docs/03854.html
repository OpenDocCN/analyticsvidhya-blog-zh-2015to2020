<html>
<head>
<title>OpenCV Decorator for easy Image and Video Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV装饰器用于简单的图像和视频测试</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/opencv-decorator-for-easy-image-and-video-testing-d1677c3dbc3?source=collection_archive---------16-----------------------#2020-02-22">https://medium.com/analytics-vidhya/opencv-decorator-for-easy-image-and-video-testing-d1677c3dbc3?source=collection_archive---------16-----------------------#2020-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4a527e6039a6a39fdefb360b549aa871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*1ouzU2R3x2iVWcrjbBdoiw.jpeg"/></div></figure><p id="1029" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在计算机视觉中，当我们测试我们的图像处理模型，如VGG-16、Yolo、Res-Net101或定制模型时，我们面临着使用cv2.imshow()函数查看图像的重复任务。让我详细说明一下，在计算机视觉中，为了做概念验证，我们首先合成我们的模型。然后对于测试部分，我们将我们的模型放在一个函数中，该函数将一个<strong class="io hj">单个图像</strong>作为参数，并返回绘制在图像本身上的边界框或某种标识符，以便进行调试。最后，我们可以看到使用cv2.imshow()函数调试后的图像。</p><blockquote class="jk jl jm"><p id="0090" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">如果你是OpenCV的新手，可以通过这个链接:<a class="ae jr" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" rel="noopener ugc nofollow" target="_blank">https://OpenCV-python-tutro als . readthedocs . io/en/latest/py _ tutorials/py _ GUI/py _ image _ display/py _ image _ display . html</a></p></blockquote><p id="aafa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果模型(函数)在单个图像上完成的处理工作正常，那么我们前进到在视频流上测试它。这就是装饰者发挥作用的地方。我们可以使用我制作的decorator函数，它将向我们的模型函数添加功能，以视频流作为输入，并通过在我们的模型函数上方添加decorator("@decorator ")行来显示调试后的输出！！</p><p id="a097" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了更清楚地解释它，我展示了一个简单的函数示例，它在传递彩色图像时返回灰度图像。现在我们想修改我们的函数，这样它将输入一个彩色视频并返回一个黑白视频，同时使用cv2.imshow()显示结果……我的装饰器马上就会为您完成！！</p><h2 id="c45f" class="js jt hi bd ju jv jw jx jy jz ka kb kc ix kd ke kf jb kg kh ki jf kj kk kl km bi translated">定义基本图像处理功能</h2><p id="7f63" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated">图像处理函数<strong class="io hj"> processFrame </strong>的例子，它将返回处理后的帧(这里做BGR到灰度转换，但我们通常做类似于<em class="jn">在“Res-Net-101”</em>中传递帧的操作):-</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ab5e" class="js jt hi kx b fi lb lc l ld le">def <strong class="kx hj"><em class="jn">processFrame(frame)</em></strong>:<br/>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    return [frame,gray]</span></pre><h2 id="5c33" class="js jt hi bd ju jv jw jx jy jz ka kb kc ix kd ke kf jb kg kh ki jf kj kk kl km bi translated">单幅图像上的测试函数</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="09b0" class="js jt hi kx b fi lb lc l ld le">#reading image from disk<br/>inputFrame= cv2.imread('testColorImage.jpg')</span><span id="d65b" class="js jt hi kx b fi lf lc l ld le">#processing the input image<br/>img= processFrame(inputFrame)</span><span id="09ef" class="js jt hi kx b fi lf lc l ld le">#showing image that we got after processing<br/>cv2.imshow('inputImage',inputFrame)<br/>cv2.imshow('processedImage',img)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><h2 id="5a94" class="js jt hi bd ju jv jw jx jy jz ka kb kc ix kd ke kf jb kg kh ki jf kj kk kl km bi translated">视频馈送的测试功能</h2><p id="47f6" class="pw-post-body-paragraph im in hi io b ip kn ir is it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj hb bi translated"><strong class="io hj"> *传统方法</strong>是将我们的函数放在下面的代码中，并在每次测试新函数时复制粘贴其余的代码</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="31d9" class="js jt hi kx b fi lb lc l ld le">import numpy as np<br/>import cv2</span><span id="71cd" class="js jt hi kx b fi lf lc l ld le">#<strong class="kx hj"><em class="jn">videoPath is 0</em></strong><br/>cap = cv2.VideoCapture(0)</span><span id="23de" class="js jt hi kx b fi lf lc l ld le">while(True):<br/>    # Capture frame-by-frame<br/>    ret, frame = cap.read()</span><span id="c71d" class="js jt hi kx b fi lf lc l ld le">    # Our operations on the frame come here<br/>    inputFrame,outputFrame= <strong class="kx hj"><em class="jn">processFrame(frame)</em></strong></span><span id="7820" class="js jt hi kx b fi lf lc l ld le">    # Display the resulting frame<br/>    cv2.imshow('inframe',inputFrame)<br/>    cv2.imshow('outframe',outputFrame)<br/>    if cv2.waitKey(1) &amp; 0xFF == ord('q'):<br/>        break</span><span id="6b2b" class="js jt hi kx b fi lf lc l ld le"># When everything done, release the capture<br/>cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="0d0d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> *装饰者的方法— </strong>如果我们使用装饰者，这就是我们能做的</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6f31" class="js jt hi kx b fi lb lc l ld le">import numpy as np<br/>import cv2</span><span id="dc39" class="js jt hi kx b fi lf lc l ld le">@testFuncOnVideo <br/><strong class="kx hj"><em class="jn">processFrame(frame)</em></strong>:<br/>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    return [frame,gray]</span><span id="66ab" class="js jt hi kx b fi lf lc l ld le"><strong class="kx hj"><em class="jn">processFrame(videoPath=0)</em></strong></span></pre><p id="bb5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面带有装饰器的代码将转换这个只占用一帧的函数，现在将处理来自<strong class="io hj"> videoPath </strong>源的视频馈送，并显示处理后视频的输出。</p><p id="1f1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们只需要导入<strong class="io hj"> testFuncOnVideo </strong>函数<strong class="io hj"> </strong>就可以在需要的时候用它作为装饰器。这个函数的代码如下，我刚刚修改了传统的方法，并试图返回一个包装器，它将把函数从处理图像突变为处理视频。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e0fe" class="js jt hi kx b fi lb lc l ld le">def testFuncOnVideo(function):<br/>    <em class="jn">#defining a wrapper function</em><br/>    def coverFunction(*args,**kwargs):<br/>        try:<br/>            cap = cv2.VideoCapture(kwargs['videoPath'])<br/>            while(True):<br/>                <em class="jn"># Capture frame-by-frame</em><br/>                ret, frame = cap.read()<br/>                if frame is not None:<br/>                    <em class="jn"># Our operations on the frame comes here</em><br/>                    output= function(frame)<br/>                    <em class="jn">#output should be a list</em><br/>                    if type(output)==type(list()):<br/>                        for i,image in enumerate(output):<br/>                            if image is not None:<br/>                                cv2.imshow('frame'+str(i),image)<br/>                    if cv2.waitKey(1) &amp; 0xFF == ord('q'):<br/>                        break<br/>            <em class="jn"># When everything done, release the capture</em><br/>            cap.release()<br/>            cv2.destroyAllWindows()<br/>        except KeyboardInterrupt:<br/>            pass<br/>    return coverFunction</span></pre><p id="6c56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，就像这个例子一样，我们可以在代码部分找到其他合适的地方，在那里我们可以看到重复并实现一个装饰器。但是应该清楚它实际上做什么。在上面我们使用@ operator的代码中，该代码相当于:-</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fe74" class="js jt hi kx b fi lb lc l ld le">@testFuncOnVideo <br/><strong class="kx hj"><em class="jn">processFrame(frame)</em></strong>:<br/>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    return [frame,gray]</span><span id="4a1c" class="js jt hi kx b fi lf lc l ld le">||           ||</span><span id="0119" class="js jt hi kx b fi lf lc l ld le"><strong class="kx hj"><em class="jn">processFrame(frame)</em></strong>:<br/>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br/>    return [frame,gray]</span><span id="cf87" class="js jt hi kx b fi lf lc l ld le"><strong class="kx hj"><em class="jn">processFrame = </em></strong>testFuncOnVideo(<strong class="kx hj"><em class="jn">processFrame</em></strong>)</span></pre><blockquote class="jk jl jm"><p id="e19c" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">阅读更多关于装修工的信息:-<a class="ae jr" href="https://www.geeksforgeeks.org/decorators-in-python/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/decorators-in-python</a></p></blockquote><h1 id="3673" class="lg jt hi bd ju lh li lj jy lk ll lm kc ln lo lp kf lq lr ls ki lt lu lv kl lw bi translated">摘要</h1><ul class=""><li id="32f6" class="lx ly hi io b ip kn it ko ix lz jb ma jf mb jj mc md me mf bi translated">在编码时，我们会遇到这样一种情况，我们需要添加一些对函数来说并不重要的特性，在这种情况下，装饰者可以完美地工作，而不会影响函数的原始结构</li><li id="fb5c" class="lx ly hi io b ip mg it mh ix mi jb mj jf mk jj mc md me mf bi translated">我在OpenCV中找到了一个甜蜜点，在这里我们可以通过使用@ <strong class="io hj"> testFuncOnVideo，在装饰者的帮助下使我们的调试和测试生活变得更容易。</strong>需要记住的一点是，主机函数应该返回图像列表。</li></ul></div></div>    
</body>
</html>