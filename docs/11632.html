<html>
<head>
<title>How to build your first Desktop Application in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python构建您的第一个桌面应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-your-first-desktop-application-in-python-7568c7d74311?source=collection_archive---------0-----------------------#2020-12-12">https://medium.com/analytics-vidhya/how-to-build-your-first-desktop-application-in-python-7568c7d74311?source=collection_archive---------0-----------------------#2020-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2fdc396dac3bfb7fec62dca192ea5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZDAL3RJZSKSz8qb8sLBIw.jpeg"/></div></div></figure><p id="4210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在整个互联网上搜索python编程语言的用法，他们会列出那些被标记为不太适合Python的桌面应用程序。但是几年前的2016年，当我希望从web开发转向软件开发时，Google.com告诉我应该选择python，因为它用于构建一些现代和先进的科学应用程序，然后他们提到了blender3d。我知道blender3d，它是一个很棒的3d创作软件。爱</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/efebe47fbb2ed811c3a72b0f2f8b3057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VxpBvjS42Oejx5aFigUNA.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">blender3d截图(图片来源:blender.org)</figcaption></figure><p id="c770" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这不是他们的错，人们用来展示python图形用户界面的丑陋的东西是可憎的，太老了，看起来太过时了，没有年轻人会喜欢这样。我希望通过这个简单的桌面应用教程来改变这种观念。我们走吧。</p><p id="8d1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用PyQt(很快会有更多的介绍)来代替Tkinter，Tkinter因为过时而几乎从python标准库列表中删除。</p><p id="965e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PyQt是什么(发音:pie-cute)。它是一个框架的两个端口之一，来自C++，Qt(发音:cute)。该框架被认为是C++开发人员的必备框架。它是blender3d、Tableau、Telegram、Anaconda Navigator、IPython、Jupyter Notebook、VirtualBox、VLC等软件背后的框架。我们会用它来代替尴尬的Tkinter。</p><p id="f54c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Qt的两个端口是PySide和PyQt。他们99%都一样。PyQt是两者中最容易安装的。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="add2" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">先决条件</h1><ol class=""><li id="e5a6" class="lc ld hi is b it le ix lf jb lg jf lh jj li jn lj lk ll lm bi translated">您应该已经了解了一些python基础知识</li><li id="1e23" class="lc ld hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">您应该知道如何用pip安装软件包或库</li><li id="952e" class="lc ld hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">当然，您应该已经安装了python。</li></ol></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="1789" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">装置</h1><p id="63a3" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">我们唯一需要安装的是PyQt。因此，打开您的终端，在windows上将是命令提示符或Powershell。</p><p id="8445" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在您的终端中键入以下命令</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="86c0" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; pip install PyQt6</span></pre><p id="ccb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们正在下载PyQt的第6版。等待安装完成，这将只需要一两分钟。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="8eca" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">项目文件和文件夹</h1><p id="8fec" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">现在我们已经完成了安装。我们应该从我们的项目开始。为这个应用程序创建一个项目文件夹，我们称之为:helloApp。你可以在电脑上的任何地方创建它，但最好是有条理的。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h2 id="2968" class="ma kf hi bd kg mg mh mi kk mj mk ml ko jb mm mn ks jf mo mp kw jj mq mr la ms bi translated">让我们做一个“你好，世界”</h2><p id="fe7f" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">打开main.py，最好是在vscode中，并输入以下代码</p><blockquote class="mt mu mv"><p id="a4af" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="fb30" class="ma kf hi lw b fi mb mc l md me">import sys<br/>import os</span><span id="91a5" class="ma kf hi lw b fi mz mc l md me">from PyQt6.QtGui import QGuiApplication<br/>from PyQt6.QtQml import QQmlApplicationEngine<br/>from PyQt6.QtQuick import QQuickWindow</span><span id="2524" class="ma kf hi lw b fi mz mc l md me"><br/>QQuickWindow.setSceneGraphBackend('software')</span><span id="ede0" class="ma kf hi lw b fi mz mc l md me">app = QGuiApplication(sys.argv)</span><span id="ad7c" class="ma kf hi lw b fi mz mc l md me">engine = QQmlApplicationEngine()<br/>engine.quit.connect(app.quit)<br/>engine.load('./UI/main.qml')</span><span id="33f5" class="ma kf hi lw b fi mz mc l md me">sys.exit(app.exec())</span></pre><p id="3a32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">在代码上面；我们导入sys、os、QGuiApplication和QQmlApplication模块。</em></p><p id="19e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf"/><strong class="is hj"><em class="mf">qquickwindow . setscenegraphback end(' software ')</em></strong><em class="mf">应该包含在您的代码中，作为使用旧硬件规格的后备选项，除此之外，它们会看到如下所示的错误信息:</em></p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="f1bc" class="ma kf hi lw b fi mb mc l md me"><em class="mf">&gt;&gt;&gt; Failed to create vertex shader: Error 0x80070057: The parameter is incorrect.<br/>&gt;&gt;&gt; Failed to build graphics pipeline state</em></span></pre><p id="1ba0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">代码还调用了</em><strong class="is hj"><em class="mf">qgui Application</em></strong><em class="mf">和</em><strong class="is hj"><em class="mf">QQmlApplicationEngine</em></strong><em class="mf">，它们将使用Qml而不是QtWidgets作为Qt应用程序的UI层。然后，它将UI层退出功能与应用程序的主退出功能连接起来。因此当用户关闭UI时，两者都可以关闭。接下来，它加载qml文件作为qml UI的Qml代码。</em><strong class="is hj"><em class="mf">app . exec()</em></strong><em class="mf">运行应用程序，它位于</em><strong class="is hj"><em class="mf">sys . exit</em></strong><em class="mf">内，因为它返回应用程序的退出代码，该代码被传递到退出python系统的</em><strong class="is hj"><em class="mf">sys . exit</em></strong><em class="mf">中。</em></p><p id="9f49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将此代码添加到<strong class="is hj"> main.qml </strong></p><blockquote class="mt mu mv"><p id="1384" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="2c40" class="ma kf hi lw b fi mb mc l md me">import QtQuick<br/>import QtQuick.Controls.Basic</span><span id="6261" class="ma kf hi lw b fi mz mc l md me">ApplicationWindow {<br/>    visible: true<br/>    width: 600<br/>    height: 500<br/>    title: "HelloApp"</span><span id="c4e0" class="ma kf hi lw b fi mz mc l md me">    Text {<br/>        anchors.centerIn: parent<br/>        text: "Hello World"<br/>        font.pixelSize: 24<br/>    }</span><span id="b352" class="ma kf hi lw b fi mz mc l md me">}</span></pre><p id="d856" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面的代码创建了一个窗口，其中</em> <strong class="is hj"> <em class="mf">可见</em> </strong> <em class="mf">代码非常重要，如果没有这些，UI将会运行但会不可见，用</em> <strong class="is hj"> <em class="mf">宽度</em> </strong> <em class="mf">和</em> <strong class="is hj"> <em class="mf">高度</em> </strong> <em class="mf">作为指定，用</em> <strong class="is hj"> <em class="mf">标题</em> </strong> <em class="mf">作为" HelloApp "。而在</em> <strong class="is hj"> <em class="mf">父</em> </strong> <em class="mf">居中的一段文字(恰好是窗口)，则</em> <strong class="is hj"> <em class="mf">文字</em> </strong> <em class="mf">显示的是“Hello World”，像素大小为24px。</em></p><p id="fdcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">在之前的Qt5中，上述导入代码将包含版本号</em></p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="00fd" class="ma kf hi lw b fi mb mc l md me">import QtQuick 2.15<br/>import QtQuick.Controls 2.15</span></pre><p id="105c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">此外，在Qt6中，我们明确地将控件的样式声明为</em></p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="8ceb" class="ma kf hi lw b fi mb mc l md me">import QtQuick.Controls.Basic</span></pre><p id="4f29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">稍后更多关于控件样式的信息</em></p><p id="8b4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有以上，你可以运行它，看看你的结果。</p><p id="09e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导航到您的helloApp文件夹</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="7897" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; cd helloApp</span></pre><p id="6be1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在通过执行以下操作来运行它:</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="ab9d" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; python main.py</span></pre><p id="24e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您的代码运行，您应该看到:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es na"><img src="../Images/96a73578c52e42257e9e948d2de70c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*MItXIJYQ8yHq3JtNTroXfA.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">显示文本“Hello World”的应用程序窗口</figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="1501" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">更新用户界面</h1><p id="b13d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">现在让我们稍微更新一下用户界面，让我们添加一个图像作为背景和一个有时间的文本</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="79ff" class="ma kf hi lw b fi mb mc l md me">import QtQuick<br/>import QtQuick.Controls.Basic</span><span id="e2dc" class="ma kf hi lw b fi mz mc l md me">ApplicationWindow {<br/>    visible: true<br/>    width: 400<br/>    height: 600<br/>    title: "HelloApp"</span><span id="c297" class="ma kf hi lw b fi mz mc l md me">    Rectangle {<br/>        anchors.fill: <em class="mf">parent</em></span><span id="9e12" class="ma kf hi lw b fi mz mc l md me">        Image {<br/>            sourceSize.width: <em class="mf">parent</em>.width<br/>            sourceSize.height: <em class="mf">parent</em>.height<br/>            source: "./images/playas.jpg"<br/>            fillMode: Image.PreserveAspectCrop</span><span id="a8b9" class="ma kf hi lw b fi mz mc l md me">        }</span><span id="c214" class="ma kf hi lw b fi mz mc l md me">        Rectangle {<br/>            anchors.fill: <em class="mf">parent<br/>            </em>color: "transparent"</span><span id="5e5e" class="ma kf hi lw b fi mz mc l md me">            Text {<br/>                text: "16:38:33"<br/>                font.pixelSize: 24<br/>                color: "white"<br/>            }</span><span id="45db" class="ma kf hi lw b fi mz mc l md me">        }</span><span id="2f26" class="ma kf hi lw b fi mz mc l md me">    }<br/>}</span></pre><p id="9aa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面有一个</em><strong class="is hj"><em class="mf">application window</em></strong><em class="mf">类型，里面有一个</em> <strong class="is hj"> <em class="mf">矩形</em> </strong> <em class="mf">类型，那实际上是填满了窗口的所有空间。有一个</em> <strong class="is hj"> <em class="mf">图像</em> </strong> <em class="mf">在它的里面，还有一个另外的</em> <strong class="is hj"> <em class="mf">矩形</em> </strong> <em class="mf">看起来像是它的旁边，但是因为不存在一个布局类型，它实际上在</em> <strong class="is hj"> <em class="mf">图像</em> </strong> <em class="mf">类型的上面。</em> <strong class="is hj"> <em class="mf">矩形</em> </strong> <em class="mf">有一个</em><strong class="is hj"><em class="mf"/></strong><em class="mf">的透明矩形因为默认情况下是白色的，所以有一个</em> <strong class="is hj"> <em class="mf">文本</em> </strong> <em class="mf">在里面，上面写着16:38:33，用来模拟时间。</em></p><p id="d0ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您运行该应用程序，文本将出现在窗口的左上角。我们不喜欢这样，所以我们要让它出现在左下角，并留一些空白。</p><p id="dea4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在您的qml代码中，更新<strong class="is hj">文本</strong>类型以包含<strong class="is hj">锚</strong>，如下所示:</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="dc93" class="ma kf hi lw b fi mb mc l md me">            ...</span><span id="0272" class="ma kf hi lw b fi mz mc l md me">            Text {<br/>                anchors {<br/>                    bottom: parent.bottom<br/>                    bottomMargin: 12<br/>                    left: parent.left<br/>                    leftMargin: 12</span><span id="bd50" class="ma kf hi lw b fi mz mc l md me">                }<br/>                text: "16:38:33"<br/>                font.pixelSize: 24<br/>                ...<br/>            }</span><span id="fdfc" class="ma kf hi lw b fi mz mc l md me">            ...</span></pre><p id="ae9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在通过做来运行它</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="6480" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; python main.py</span></pre><p id="d7cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您应该会看到类似这样的内容。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/0c16a25a0ef8e81fe8e822e9d4adfaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*F59PHhThOIYJvcXJDjhXjQ.jpeg"/></div></figure><p id="c94c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我想要更新的时间</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h2 id="34c5" class="ma kf hi bd kg mg mh mi kk mj mk ml ko jb mm mn ks jf mo mp kw jj mq mr la ms bi translated">使用实时</h2><p id="c3d3" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">让我们用一个真实的时间。Python为我们提供了原生函数，这些函数为我们提供了各种与时间和日期相关的函数。我们需要一个带有当前时间的字符串。<strong class="is hj"> gmtime </strong>为您提供了包含各种信息的全局时间结构，而<strong class="is hj"> strftime </strong>使用<strong class="is hj"> gmtime </strong>函数将时间的某些部分构造为字符串</p><p id="f272" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导入<strong class="is hj"> strftime </strong>和<strong class="is hj"> gmtime </strong>函数</p><blockquote class="mt mu mv"><p id="a488" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="7830" class="ma kf hi lw b fi mb mc l md me">import sys<br/>import os<br/>from time import strftime, gmtime</span><span id="f18d" class="ma kf hi lw b fi mz mc l md me">from PyQt6.QtGui import QGuiApplication<br/>...</span></pre><p id="1e5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在文件中的任何地方，在导入下面构造您的时间字符串</p><blockquote class="mt mu mv"><p id="aa51" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="e17a" class="ma kf hi lw b fi mb mc l md me">curr_time = strftime("%H:%M:%S", gmtime())</span></pre><p id="51d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">% H、%M、%S告诉</em><strong class="is hj"><em class="mf">strftime</em></strong><em class="mf">，我们要查看小时(24小时制)、分钟和秒。(点击</em><em class="mf"><em class="mf">strftime</em><em class="mf"/><a class="ae nc" href="https://docs.python.org/3/library/datetime.html?highlight=strftime#strftime-and-strptime-format-codes" rel="noopener ugc nofollow" target="_blank"><em class="mf">了解更多格式代码)。</em>该变量将被传递到qml层。</a></em></p><p id="d5a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在qml中创建一个属性，我们可以用它来接收时间字符串。这个变量使得改变时间变得更容易。让我们把这个属性叫做<strong class="is hj"> <em class="mf">当前时间</em> </strong></p><blockquote class="mt mu mv"><p id="b736" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="9059" class="ma kf hi lw b fi mb mc l md me">...</span><span id="e840" class="ma kf hi lw b fi mz mc l md me">ApplicationWindow {<br/>    ...<br/>    title: "HelloApp"</span><span id="e5f8" class="ma kf hi lw b fi mz mc l md me">    property string currTime: "00:00:00"<br/>    ...</span></pre><p id="da37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在qml中使用这个属性，所以当这个值改变时，所有其他使用它的地方也会改变。</p><blockquote class="mt mu mv"><p id="f4c5" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="0b8f" class="ma kf hi lw b fi mb mc l md me">...</span><span id="a468" class="ma kf hi lw b fi mz mc l md me">Text {<br/>    ...<br/>    text: <em class="mf">currTime  // used to be; text: "</em>16:38:33<em class="mf">"<br/>    </em>font.pixelSize: 48<br/>    color: "white"<br/>}</span><span id="dbca" class="ma kf hi lw b fi mz mc l md me">...</span></pre><p id="0081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，通过将我们在python中创建的<strong class="is hj"> curr_time </strong>变量设置为<strong class="is hj"> currTime </strong> qml属性，将其发送到qml。</p><blockquote class="mt mu mv"><p id="3c73" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="086d" class="ma kf hi lw b fi mb mc l md me">...</span><span id="0690" class="ma kf hi lw b fi mz mc l md me">engine.load('./UI/main.qml')<br/>engine.rootObjects()[0].setProperty('currTime', curr_time)</span><span id="36fe" class="ma kf hi lw b fi mz mc l md me">...</span></pre><p id="5a54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面的代码将qml属性</em><strong class="is hj"><em class="mf"/></strong><em class="mf">设置为</em><strong class="is hj"><em class="mf">curr _ time</em></strong><em class="mf">python属性的值。这是我们将信息从python传递到UI层的一种方式。</em></p><p id="24e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行应用程序，你应该不会看到任何错误，还会有当前时间。万岁！！！前进！！！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="f968" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">更新时间</h1><p id="f4ae" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">来更新我们的时间。我们将需要使用线程。python中的线程简单明了，我们将使用它来代替Qt的线程。线程使用函数或线程调用函数。我更喜欢我们在Qt中使用一种叫做signals的技术，这是一种专业的方法，学习它会让你喜欢得更好更容易。让我们将当前时间代码放入一个函数中，使用下划线(_)作为文件名。稍后我会解释原因。这不是一个要求或任何东西，它只是一个好的做法</p><p id="0c33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用信号，我们必须简单明了地子类化<strong class="is hj"> QObject </strong>。</p><p id="74b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个<strong class="is hj"> QObject的子类，</strong>随便你怎么称呼它。我将称之为后端。</p><blockquote class="mt mu mv"><p id="5e8e" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="05c4" class="ma kf hi lw b fi mb mc l md me">...<br/>from PyQt6.QtQuick import QQuickWindow<br/>from PyQt6.QtCore import QObject, pyqtSignal</span><span id="18d7" class="ma kf hi lw b fi mz mc l md me"><br/>class Backend(QObject):</span><span id="e922" class="ma kf hi lw b fi mz mc l md me">    def __init__(self):<br/>        QObject.__init__(self)</span><span id="efb5" class="ma kf hi lw b fi mz mc l md me">QQuickWindow.setSceneGraphBackend('software')</span><span id="42c4" class="ma kf hi lw b fi mz mc l md me">...</span></pre><p id="0522" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面的代码导入了</em><strong class="is hj"><em class="mf">q object</em></strong><em class="mf">和</em><strong class="is hj"><em class="mf">pyqtSignal</em></strong><em class="mf">，在pyside这叫做</em><strong class="is hj"><em class="mf">Signal</em></strong><em class="mf">。这是pyqt和pyside为数不多的区别之一。</em></p><p id="7a88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">形式上，我们有一个从python接收我们的<strong class="is hj"> curr_time </strong>字符串的属性字符串，现在我们创建一个属性<strong class="is hj"> QtObject </strong>来从python接收<strong class="is hj">后端</strong>对象。没有那么多类型。Qml将python基础类型转换成<strong class="is hj"> bool </strong>、<strong class="is hj"> int </strong>、<strong class="is hj"> double </strong>、<strong class="is hj"> string </strong>、<strong class="is hj"> list </strong>、<strong class="is hj"> QtObject </strong>和<strong class="is hj"> var </strong>。var 可以处理所有的python类型，但是它是最不受欢迎的。</p><blockquote class="mt mu mv"><p id="17b9" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="bc74" class="ma kf hi lw b fi mb mc l md me">...<br/>property string currTime: "00:00:00"<br/>property QtObject backend<br/>...</span></pre><p id="9310" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面的代码创建了一个</em><strong class="is hj"><em class="mf">Qt object</em></strong><em class="mf"/><strong class="is hj"><em class="mf">back end</em></strong><em class="mf">来存放我们的python对象</em> <strong class="is hj"> <em class="mf"> back_end。</em> </strong> <em class="mf">使用的名字都是我的，随便你怎么改</em></p><p id="e270" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在python中传递它</p><blockquote class="mt mu mv"><p id="2870" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="f775" class="ma kf hi lw b fi mb mc l md me">...<br/>engine.load('./UI/main.qml')<br/>back_end = Backend()<br/>engine.rootObjects()[0].setProperty('backend', back_end)<br/>...</span></pre><p id="a209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">在上面的代码中一个对象</em> <strong class="is hj"> <em class="mf"> back_end </em> </strong> <em class="mf">是从类</em><strong class="is hj"><em class="mf">back end</em></strong><em class="mf">中创建的。然后我们将其设置为名为</em> <strong class="is hj"> <em class="mf">后端</em> </strong>的qml属性</p><p id="fd67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Qml中，一个<strong class="is hj"> QtObject </strong>可以从做许多事情的python接收许多函数(称为信号),但是它们必须被组织在那个<strong class="is hj"> QtObject </strong>下。</p><p id="bdef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建<strong class="is hj">连接</strong>类型并将其定位到<strong class="is hj">后端</strong>。现在，在<strong class="is hj">连接</strong>类型中可以有我们想要为<strong class="is hj">后端</strong>接收的众多函数。</p><blockquote class="mt mu mv"><p id="b760" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="3b9d" class="ma kf hi lw b fi mb mc l md me">...<br/>Rectangle {<br/>    anchors.fill: <em class="mf">parent</em></span><span id="1ee4" class="ma kf hi lw b fi mz mc l md me">    Image {<br/>    ...<br/>    }<br/>    ...</span><span id="1605" class="ma kf hi lw b fi mz mc l md me">}</span><span id="2128" class="ma kf hi lw b fi mz mc l md me">Connections {<br/>    target: <em class="mf">backend<br/></em>}<br/>...</span></pre><p id="bf2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们与python信号联系的方式。</p><p id="f081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们不使用线程，我们的用户界面将冻结。很明显，我们这里需要的是线程而不是多重处理。</p><p id="6fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建两个函数，一个用于线程，一个用于实际函数。这就是下划线派上用场的地方。</p><blockquote class="mt mu mv"><p id="c266" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="c877" class="ma kf hi lw b fi mb mc l md me">...<br/>import threading<br/>from time import sleep<br/>...<br/></span><span id="82f3" class="ma kf hi lw b fi mz mc l md me">class Backend(QObject):</span><span id="2526" class="ma kf hi lw b fi mz mc l md me"><br/>    def __init__(self):<br/>        QObject.__init__(self)</span><span id="387d" class="ma kf hi lw b fi mz mc l md me">    def bootUp(self):<br/>        t_thread = threading.Thread(target=self._bootUp)<br/>        t_thread.daemon = True<br/>        t_thread.start()</span><span id="45b0" class="ma kf hi lw b fi mz mc l md me">    def _bootUp(self):<br/>        while True:<br/>            curr_time = strftime("%H:%M:%S", gmtime())<br/>            print(curr_time)<br/>            sleep(1)</span><span id="32cd" class="ma kf hi lw b fi mz mc l md me">...</span></pre><p id="fe6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面的代码有一个下划线函数，它创建一个更新的时间。</em></p><p id="b5a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个名为<strong class="is hj"> updated </strong>的pyqtsignal，并从名为<strong class="is hj"> updater </strong>的函数中调用它</p><blockquote class="mt mu mv"><p id="3e44" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="b2a6" class="ma kf hi lw b fi mb mc l md me">...<br/>from PyQt6.QtCore import QObject, pyqtSignal</span><span id="272a" class="ma kf hi lw b fi mz mc l md me">...</span><span id="cee2" class="ma kf hi lw b fi mz mc l md me">    def __init__(self):<br/>        QObject.__init__(self)</span><span id="429a" class="ma kf hi lw b fi mz mc l md me">    updated = pyqtSignal(str, arguments=['updater'])</span><span id="06ca" class="ma kf hi lw b fi mz mc l md me">    def updater(self, curr_time):<br/>        self.updated.emit(curr_time)</span><span id="81c0" class="ma kf hi lw b fi mz mc l md me">    ...</span></pre><p id="39f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面代码中的<em class="mf">pyqtSignal、</em> <strong class="is hj"> <em class="mf"> updated、</em> </strong> <em class="mf">中，已经为它的</em><strong class="is hj"><em class="mf">arguments</em></strong><em class="mf">parameter列表中包含了函数名‘updater’。从这个</em> <strong class="is hj"> <em class="mf">更新器</em> </strong> <em class="mf">函数，qml将接收数据。在</em><strong class="is hj"><em class="mf">updater</em></strong><em class="mf">函数中我们调用(</em><strong class="is hj"><em class="mf">emit</em></strong><em class="mf">)signal</em><strong class="is hj"><em class="mf">updated</em></strong><em class="mf">并向它传递数据(</em><strong class="is hj"><em class="mf">curr _ time</em></strong><em class="mf">)</em></p><p id="80b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更新qml，通过创建信号处理程序接收信号，信号处理程序名称是信号名称的大写形式，前面加“on”。所以，‘我的信号’变成了‘on my signal’，‘我的信号’变成了‘on my signal’。</p><blockquote class="mt mu mv"><p id="269d" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="2b74" class="ma kf hi lw b fi mb mc l md me">...<br/>    target: <em class="mf">backend</em></span><span id="6d80" class="ma kf hi lw b fi mz mc l md me">    function onUpdated(msg) {<br/>        <em class="mf">currTime</em> = <em class="mf">msg</em>;<br/>    }<br/>...</span></pre><p id="ffc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">在上面的代码中你可以看到</em> <strong class="is hj"> <em class="mf">更新后的</em> </strong> <em class="mf">信号被称为</em> <strong class="is hj"> <em class="mf">更新后的</em> </strong> <em class="mf">。它还将</em><strong class="is hj"><em class="mf">curr _ time</em></strong><em class="mf">作为</em><strong class="is hj"><em class="mf">msg</em></strong><em class="mf">传递给它。</em></p><p id="95fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一切都很好，但是我们还没有调用<strong class="is hj"> updater </strong>函数。对于这样的小应用程序，没有必要使用单独的函数来调用信号。但是在一个大的应用程序中，这是推荐的方法。将延迟秒数更改为1/10秒。我发现这个数字最好更新时间。</p><blockquote class="mt mu mv"><p id="a1b7" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="7d75" class="ma kf hi lw b fi mb mc l md me">            ...<br/>            curr_time = strftime("%H:%M:%S", gmtime())<br/>            self.updater(curr_time)<br/>            sleep(0.1)<br/>...</span></pre><p id="c703" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在UI加载后，应该立即调用<strong class="is hj">启动</strong>函数。</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="59a1" class="ma kf hi lw b fi mb mc l md me">...<br/>engine.rootObjects()[0].setProperty('backend', back_end)</span><span id="56c2" class="ma kf hi lw b fi mz mc l md me">back_end.bootUp()</span><span id="e849" class="ma kf hi lw b fi mz mc l md me">sys.exit(app.exec())</span></pre><p id="64f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一切都结束了！！！</strong></p><p id="c1e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行代码:</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="b77e" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; python main.py</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/0c16a25a0ef8e81fe8e822e9d4adfaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*F59PHhThOIYJvcXJDjhXjQ.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">你的秒针现在应该正在更新</figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="225f" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">奖金:</h1><h1 id="32d8" class="ke kf hi bd kg kh nd kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx nh kz la lb bi translated">使窗口无框架</h1><p id="0f6e" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">你可以把窗口做成无框的，贴在屏幕右下方。</p><blockquote class="mt mu mv"><p id="398a" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="d4af" class="ma kf hi lw b fi mb mc l md me">...<br/>height: 600<br/>x: <em class="mf">screen</em>.desktopAvailableWidth - <em class="mf">width</em> - 12<br/>y: <em class="mf">screen</em>.desktopAvailableHeight - <em class="mf">height</em> - 48<br/>title: "HelloApp"</span><span id="89d9" class="ma kf hi lw b fi mz mc l md me">flags: <em class="mf">Qt</em>.FramelessWindowHint | <em class="mf">Qt</em>.Window</span><span id="1949" class="ma kf hi lw b fi mz mc l md me">...</span></pre><p id="5956" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">上面的代码为窗口设置</em><strong class="is hj"><em class="mf">【x】</em></strong><em class="mf"/><strong class="is hj"><em class="mf">【y】</em></strong><em class="mf">，并添加</em> <strong class="is hj"> <em class="mf">标志</em> </strong> <em class="mf">，使窗口无框架。</em> <strong class="is hj"> <em class="mf"> Qt。窗口</em> </strong> <em class="mf">标志确保即使窗口是无框架的，我们仍然得到一个任务按钮</em></p><p id="6b4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行它，你应该对你所看到的感到高兴。</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="3950" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; python main.py</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2fdc396dac3bfb7fec62dca192ea5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZDAL3RJZSKSz8qb8sLBIw.jpeg"/></div></div></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="cd15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">终于，编码结束了，这是最终的代码。</p><blockquote class="mt mu mv"><p id="3096" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.py</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="be3a" class="ma kf hi lw b fi mb mc l md me">import sys<br/>import os<br/>from time import strftime, gmtime<br/>import threading<br/>from time import sleep</span><span id="ac8e" class="ma kf hi lw b fi mz mc l md me">from PyQt6.QtGui import QGuiApplication<br/>from PyQt6.QtQml import QQmlApplicationEngine<br/>from PyQt6.QtQuick import QQuickWindow<br/>from PyQt6.QtCore import QObject, pyqtSignal</span><span id="c186" class="ma kf hi lw b fi mz mc l md me"><br/>class Backend(QObject):</span><span id="ab1b" class="ma kf hi lw b fi mz mc l md me"><br/>    def __init__(self):<br/>        QObject.__init__(self)</span><span id="b293" class="ma kf hi lw b fi mz mc l md me">    updated = pyqtSignal(str, arguments=['updater'])</span><span id="f171" class="ma kf hi lw b fi mz mc l md me">    def updater(self, curr_time):<br/>        self.updated.emit(curr_time)</span><span id="7817" class="ma kf hi lw b fi mz mc l md me">    def bootUp(self):<br/>        t_thread = threading.Thread(target=self._bootUp)<br/>        t_thread.daemon = True<br/>        t_thread.start()</span><span id="d623" class="ma kf hi lw b fi mz mc l md me">    def _bootUp(self):<br/>        while True:<br/>            curr_time = strftime("%H:%M:%S", gmtime())<br/>            self.updater(curr_time)<br/>            sleep(0.1)</span><span id="56ab" class="ma kf hi lw b fi mz mc l md me"><br/>QQuickWindow.setSceneGraphBackend('software')</span><span id="61d2" class="ma kf hi lw b fi mz mc l md me">app = QGuiApplication(sys.argv)<br/>engine = QQmlApplicationEngine()<br/>engine.quit.connect(app.quit)<br/>engine.load('./UI/main.qml')</span><span id="e9b0" class="ma kf hi lw b fi mz mc l md me">back_end = Backend()</span><span id="3cdc" class="ma kf hi lw b fi mz mc l md me">engine.rootObjects()[0].setProperty('backend', back_end)</span><span id="b591" class="ma kf hi lw b fi mz mc l md me">back_end.bootUp()</span><span id="259e" class="ma kf hi lw b fi mz mc l md me">sys.exit(app.exec())<br/></span></pre><blockquote class="mt mu mv"><p id="bda7" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">main.qml</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="3530" class="ma kf hi lw b fi mb mc l md me">import QtQuick<br/>import QtQuick.Controls.Basic</span><span id="2be3" class="ma kf hi lw b fi mz mc l md me">ApplicationWindow {<br/>    visible: true<br/>    width: 360<br/>    height: 600<br/>    x: <em class="mf">screen</em>.desktopAvailableWidth - <em class="mf">width</em> - 12<br/>    y: <em class="mf">screen</em>.desktopAvailableHeight - <em class="mf">height</em> - 48<br/>    title: "HelloApp"</span><span id="ac70" class="ma kf hi lw b fi mz mc l md me">    flags: <em class="mf">Qt</em>.FramelessWindowHint | <em class="mf">Qt</em>.Window</span><span id="e8cf" class="ma kf hi lw b fi mz mc l md me">    property string currTime: "00:00:00"<br/>    property QtObject backend</span><span id="7c0e" class="ma kf hi lw b fi mz mc l md me">    Rectangle {<br/>        anchors.fill: <em class="mf">parent</em></span><span id="2c8a" class="ma kf hi lw b fi mz mc l md me">        Image {<br/>            sourceSize.width: <em class="mf">parent</em>.width<br/>            sourceSize.height: <em class="mf">parent</em>.height<br/>            source: "./images/playas.jpg"<br/>            fillMode: Image.PreserveAspectFit<br/>        }</span><span id="b94d" class="ma kf hi lw b fi mz mc l md me">        Text {<br/>            anchors {<br/>                bottom: parent.bottom<br/>                bottomMargin: 12<br/>                left: parent.left<br/>                leftMargin: 12<br/>            }<br/>            text: <em class="mf">currTime<br/>            </em>font.pixelSize: 48<br/>            color: "white"<br/>        }</span><span id="deb9" class="ma kf hi lw b fi mz mc l md me">    }</span><span id="2d1b" class="ma kf hi lw b fi mz mc l md me"><br/>    Connections {<br/>        target: <em class="mf">backend</em></span><span id="df5f" class="ma kf hi lw b fi mz mc l md me">        function onUpdated(msg) {<br/>            <em class="mf">currTime</em> = <em class="mf">msg</em>;<br/>        }<br/>    }</span><span id="c47e" class="ma kf hi lw b fi mz mc l md me">}<br/></span></pre><p id="acc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了您可能更改的名称之外，所有内容都应该是相似的。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="a184" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">构建和后续步骤</h1><p id="6dd4" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">构建pyqt应用程序可能是最简单的，因为它广为人知。</p><p id="a553" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要建造，安装<strong class="is hj"> pyinstaller </strong>，由于建造是加成部分的一部分，我们之前没有安装。</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="2500" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; pip install pyinstaller</span></pre><p id="f99c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以很容易地在applications文件夹(helloApp)中运行下面的代码，但是我们必须注意我们使用的资源。</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="cc41" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; pyinstaller main.py</span></pre><p id="1ac9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，首先要做:</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="a84e" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; pyi-makespec main.py</span></pre><p id="aa07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它首先为您生成一个spec文件进行更新，然后您可以再次运行pyinstaller</p><p id="5854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据</strong>参数可用于将数据文件包含在您的应用程序或应用程序文件夹中。它是一个元组列表，元组总是有两个项目，目标路径，我们将包括在内，以及目的地路径，它应该存储在应用程序的文件夹中。目标路径必须是相对路径。如果你想把它和应用程序的可执行文件放在一起，你可以把它设置成一个空字符串(')，如果你想把它放在应用程序文件夹的嵌套文件夹中，你可以指定嵌套文件夹(' nest/nested/really_nested ')</p><p id="9921" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更新<strong class="is hj">数据</strong>参数，如下图所示，以匹配您电脑上hello app UI文件夹的路径。</p><p id="bf05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将<strong class="is hj">控制台</strong>参数设置为<strong class="is hj">假</strong>，因为这是一个Gui，我们没有测试它。</p><blockquote class="mt mu mv"><p id="5d2d" class="iq ir mf is b it iu iv iw ix iy iz ja mw jc jd je mx jg jh ji my jk jl jm jn hb bi translated">主规格</p></blockquote><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="d5ab" class="ma kf hi lw b fi mb mc l md me">...<br/>a = Analysis(['main.py'],<br/>             ...<br/>             datas=[('I:/path/to/helloApp/UI', 'UI')],<br/>             hiddenimports=[],<br/>...<br/>exe = EXE(pyz,<br/>          a.scripts,<br/>          [],<br/>          ...<br/>          name='main',<br/>          debug=False,<br/>          ...<br/>          console=False )<br/>coll = COLLECT(exe,<br/>               ...<br/>               upx_exclude=[],<br/>               name='main')</span></pre><p id="237b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> EXE </strong>调用中的<strong class="is hj">名称</strong>参数是可执行文件本身的名称。例如，main.dmg或main.dmg，但<strong class="is hj"> COLLECT </strong>调用中的<strong class="is hj">名称</strong>参数是用于存储可执行文件及其所有附带文件的文件夹名称，两者都可以更改。但是名称是基于我们用来生成规范的文件，记住:<strong class="is hj">‘main . py’</strong></p><p id="e514" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，使用</p><pre class="jp jq jr js fd lv lw lx ly aw lz bi"><span id="aee0" class="ma kf hi lw b fi mb mc l md me">&gt;&gt;&gt; pyinstaller main.spec</span></pre><p id="dd2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您应该看到一个名为“dist”的文件夹，其中包含另一个名为“main”的文件夹，其中包含应用程序文件。搜索main.exe或主可执行文件并运行它。TADAAA！一切都很好。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/16b46e403470e91ad66640c480036a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*3TCec53425IT4gmvoUtZ5w.jpeg"/></div></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="f8fd" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">后续步骤</h1><p id="57ad" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">除了在应用程序中包含和使用UI文件夹的方式之外，我们讨论的所有东西都在生产中使用。资源在部署到生产中之前是捆绑在一起。</p><p id="2bce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是信号，背景图像是如何使用的，无框窗口都是在生产中使用的技术，可以说，在现实世界中。这只是有更多的东西。是的，无框窗口有更多的功能，如果你不打算把它作为闪屏使用，你必须处理标题栏、窗口的大小调整和拖动等，这并不复杂，但这超出了本教程的范围。</p><p id="d423" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Qml不仅仅是图片，矩形和文本，布局系统是四种类型。它们很容易学习，但是实用的方法是最好的，所以我不想解释它们。</p><p id="51ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继续学习PyQt和Qml，它将引领你进入软件开发、嵌入式系统和未来数据可视化的职业生涯。比起TKinter，我更喜欢它，它的受欢迎程度与日俱增。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="f038" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击<strong class="is hj"> <em class="mf">跟随</em> </strong>按钮了解更多。</p><p id="12e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阅读下一个教程:<a class="ae nc" href="https://amohgyebiampofo.medium.com/create-a-file-converter-in-python-6fefeb747434" rel="noopener">如何用Python创建文件转换器</a></p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="af9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多资源可在以下网址找到:</p><ul class=""><li id="2379" class="lc ld hi is b it iu ix iy jb nj jf nk jj nl jn nm lk ll lm bi translated">PyQt/PySide—<a class="ae nc" href="https://martinfitz.dev/b/nv2Zt/af63c96d69567cf" rel="noopener ugc nofollow" target="_blank">Python GUIs</a>，<a class="ae nc" href="http://thepythoncode.com" rel="noopener ugc nofollow" target="_blank">Python代码</a>，<a class="ae nc" href="https://wiki.qt.io/Qt_for_Python" rel="noopener ugc nofollow" target="_blank"> Qt官方文档</a>，<a class="ae nc" href="https://www.riverbankcomputing.com/static/Docs/PyQt6/" rel="noopener ugc nofollow" target="_blank">河堤计算</a></li><li id="a396" class="lc ld hi is b it ln ix lo jb lp jf lq jj lr jn nm lk ll lm bi translated">evileg.com，<a class="ae nc" href="https://doc.qt.io/qt-6/qtqml-index.html" rel="noopener ugc nofollow" target="_blank"> Qt官方文件</a></li></ul><p id="dada" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下次见。</p></div></div>    
</body>
</html>