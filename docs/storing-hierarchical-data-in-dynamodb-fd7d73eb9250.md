# 在 DynamoDB 中存储分层数据

> 原文：<https://medium.com/analytics-vidhya/storing-hierarchical-data-in-dynamodb-fd7d73eb9250?source=collection_archive---------1----------------------->

最近，我创建了一个需要在 DynamoDB 中存储树结构的应用程序。虽然我能够找到一些关于如何做到这一点的文章，但我找不到任何关于很好地解决了我的用例的解决方案的文档。这篇文章试图成为解决类似问题的未来灵魂的文档。本文还假设您具备 DynamoDB 的工作知识。

在设计任何 DynamoDB 表时，考虑您的查询模式是很重要的。在我的例子中，我需要高效的查询来获取给定节点的所有祖先及其所有后代。即给定下面的绿色节点“G ”,能够有效地返回所有用红色圈出的节点(祖先)和所有用蓝色圈出的节点(后代)。在这种情况下，高效意味着“请求数量不会随着树中节点数量的增加而增加。”此外，祖先和后代应该以一种可以重建树结构的方式返回。

![](img/0eeebc2c461240985772124905f9de2d.png)

此时，如果您正在阅读本文，并且认为您的访问模式需求是不同的，那么以不同的方式构建您的表可能会更好。存储每个节点的父节点、存储邻接表或存储嵌套集合都是存储这种数据的有据可查的方式，它们将容易地支持访问模式，例如检索给定节点的直接父节点和子节点。

我还应该提到将要存储的树结构的一些附加要求。

1.  数据库中可以有任意数量的不相交的树。
2.  每棵树可以有任意的深度。
3.  每个节点可以有任意数量的子节点。
4.  当移动一个节点时，它的所有后代都应该随之移动。
5.  当删除一个节点时，该节点的所有子节点应该替换它，成为被删除节点的父节点的子节点。
6.  当根节点仍有子节点时，不能删除它们。
7.  虽然所有这些修改都必须是可能的，但是为了使祖先和后代查询高效，它们可能是昂贵的。

# 第一种方法

因为数据库中可能有多个不相交的树，所以每个节点必须有一个 treeId 来标识它属于哪个树(还有其他方法，但是它们需要从树根开始的树遍历，这不满足有效读取的约束)。此外，treeId 应该是全局二级索引(GSI)的分区键，以便可以在查询中用作键。这就需要 GSI 排序键来找出如何将查询从整棵树缩小到祖先和后代。

我遇到的第一个有希望的方法是为每个节点存储左索引和右索引，其中左索引根据在树的 DFS 搜索中节点被触摸的第*个*时间增加，而右索引根据它被触摸的最后*个*时间增加。在上面的树中，这些索引如下所示:

![](img/4bb238a48658255c58bb80a8559cf3ff.png)

从此处，可以通过以下方式查询节点的所有祖先:

```
ancestors = SELECT *
    WHERE treeId == this.treeId
    AND leftIndex < this.leftIndex
    AND rightIndex > this.rightIndexdescendants = SELECT *
    WHERE treeId == this.treeId
    AND leftIndex > this.leftIndex
    AND rightIndex < this.rightIndex
```

如果使用关系数据库，这是可以的，但是像这样的查询在 DynamoDB 中是不可能的。使左索引和右索引成为复合 GSI 将不起作用，因为分区键已经被 treeId 占用。据我所知，没有什么聪明的方法既能在排序键中存储左索引和右索引，又能保留在单个索引上搜索大于/小于的能力。

这种方法对于修改树结构还有其他缺点。如果您希望将所有索引保持为整数，那么对树的一些修改将需要对大的子树进行昂贵的重新索引操作。如果你同意使用浮动作为指数，那么你可以减少一些成本，但代价是使用浮动和随之而来的所有问题。

# 更好的解决方案

我最终采用的方法涉及一个单独的 GSI，分区键 treeId 和排序键是从根到节点的路径的连接。使用这种方法，上述树在表中可以表示为:

有了这个结构，给定一个节点，我们可以使用下面的(伪代码)高效地查询祖先和后代

```
ancestors = BatchGetItem(nodeIds = this.path.split(#))descendants = Query
    .withKeyCondition(treeId == this.treeId)
    .withConditionExpression(path starts_with this.path)
```

这满足了我们两个的约束！我们可以有效地查询祖先和后代。并且可以通过查看每个返回节点的路径来重构树结构。

更新仍然非常昂贵，因为它要求我们潜在地重写大量的路径字段，但是我们不必重写不在被修改的节点下的节点的路径。此外，我们不必处理浮动:)