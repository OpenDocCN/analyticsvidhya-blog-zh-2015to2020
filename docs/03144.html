<html>
<head>
<title>Spark Parquet File</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">火花拼花锉</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spark-parquet-file-cac4af92981d?source=collection_archive---------2-----------------------#2020-01-18">https://medium.com/analytics-vidhya/spark-parquet-file-cac4af92981d?source=collection_archive---------2-----------------------#2020-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ac50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将讨论Spark中最广泛使用的文件格式。</p><p id="47f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们了解Spark中可用的数据存储模型以及Parquet在其中的地位。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/25e759eba14d1547aa2961a0c507a7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-TbLepwC6dnGu_NORBWAQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">数据源和格式</figcaption></figure><p id="556f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有3种可以在Spark中处理的数据格式。</p><ul class=""><li id="f567" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><em class="kc">非结构化</em>格式给了你很大的灵活性，但是它有很高的解析开销。</li><li id="8989" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated"><em class="kc">半结构化</em>格式不需要有定义明确的模式，但需要有记录的清晰概念。</li><li id="5b94" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">结构化格式的解析开销最小，存储效率最高。我们有行和列的概念以及定义良好的模式。</li></ul><h1 id="ce55" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">物理存储布局模型</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/f6841503527da4b7e1d59b4b8bc0f4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCauxW3XT69yh2z0BhmRyg.png"/></div></div></figure><p id="016b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">按行存储(水平分区)</strong></p><p id="714c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按行存储类似于数据的逻辑表示，速度快，适合所有OLTP事务。当您需要插入整个记录或根据键更新记录时，这种存储模型更好。在这两种情况下，您都需要将记录的所有细节紧密耦合在一起，而行存储模型可以做到这一点。<br/>该模型基于整行工作。因此，如果您只想从整个数据集中读取有限的列，这个结构会执行大量的I/O操作，遍历您不需要的列值。</p><p id="6866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">列级存储(垂直分区)</strong></p><p id="2dea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列级存储是背靠背存储单个列的所有值的地方，最适合OLAP应用程序。在OLAP应用程序中，我们只对列的子集感兴趣，比如说，如果您只对列A感兴趣，那么您可以用较少的I/O操作来读取它，因为您将该列中的所有值耦合在一起。当我们执行更新/插入操作时，这个模型会使我们失败，因为它想要识别每条记录在列存储中的位置，为此，它必须遍历每列中的所有值。</p><p id="c0c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">混合动力车型</strong></p><p id="6a1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">混合模型同时应用行级和列级存储。在这种情况下，每3行应用一次水平分区，在这3行中，它进行垂直分区。<br/>这种模型适合快速读取数据，而且如果您想进行更新或插入，它可以很容易地识别记录的位置。</p><blockquote class="lh li lj"><p id="6663" class="if ig kc ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">混合模式由<em class="hi">拼花</em>和<em class="hi"> ORC使用。</em></p></blockquote><h1 id="43e9" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">镶木地板</h1><p id="2868" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">Parquet遵循混合模型，是Spark/Hadoop生态系统中使用最多的格式之一。它是由Twitter和Cloudera联合开发的。</p><p id="4d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">拼花:数据组织</strong></p><ul class=""><li id="791c" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">它通常不是单个文件。</li><li id="4d14" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">水平分区(行组)的大小为<strong class="ih hj"> 128 MB </strong>(默认)。比方说，如果您有一个1GB大小的文件，它将被分成10个分区。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/7ee79da6f0a54d669b23736c9669d64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHfPr6PtE6KT08vJFFIlIA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">行组</figcaption></figure><ul class=""><li id="cd45" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">在行组中，我们有垂直分区(列块)</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/a12da840408209e7bca8756dd3e1308c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkDM8vbg2tv5r1qb0tyYQA.png"/></div></div></figure><ul class=""><li id="7023" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">在列块中，我们将实际数据存储在我们称之为数据页的地方。</li><li id="95d5" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">每个数据页都包含元数据详细信息，如最小值、最大值、该页中的值数和编码值。</li><li id="0f7e" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">在行组级别也有元数据，它们与行组一起存储在页脚中。</li></ul><p id="d797" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">拼花地板:编码方案</strong></p><ul class=""><li id="c4ae" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">普通<br/>这是最简单的编码。值是背靠背编码的。每当不能使用更有效的编码时，就使用普通编码。</li><li id="b4f6" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">RLE _字典(游程长度编码)<br/>这种编码方案主要使用字典压缩来存储数据，当我们有重复或重复的值时，它会节省大量内存。字典编码构建在给定列中遇到的值的字典。如果字典变得太大，无论是大小还是不同值的数量，编码都将退回到普通编码。首先写入字典页，然后写入列块的数据页。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/973d14fa08f3a685044e1b45ee002b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcqLXYUMybED7IdE-BsmUg.png"/></div></div></figure><p id="3353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们有8个不同国家名称的记录。RLE _字典方案将每个国家的名称映射到字典中的一个键(字典压缩)。游程编码识别出密钥3连续重复三次。因此，它被组合在一起，我们有3，3(即，密钥)和重复的次数。RLE不是显式存储重复值，而是存储重复值及其重复次数。</p><blockquote class="lh li lj"><p id="7179" class="if ig kc ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">每个列块一个字典，并且有大小限制。</p></blockquote><p id="6a61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看Parquet提供了哪些优化。</p><p id="2719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化:字典编码</strong></p><ul class=""><li id="4f1f" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">由于编码，我们有更小的文件，这有助于I/O操作。Parquet还为您提供了增加字典大小的灵活性。</li><li id="4e37" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">另一种选择是减小行组的大小，这样它将有更少的记录，这间接导致每个列组中唯一值的数量减少。</li></ul><p id="d23c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化:页面压缩</strong></p><ul class=""><li id="f12a" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">Parquet还允许您压缩数据页面。(爽快，gzip，lzo)</li><li id="6638" class="jt ju hi ih b ii kd im ke iq kf iu kg iy kh jc jy jz ka kb bi translated">可以使用spark命令设置压缩编解码器。</li></ul><blockquote class="lh li lj"><p id="aaa2" class="if ig kc ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">spark . SQL . parquet . compression . codec</p></blockquote><ul class=""><li id="d6cb" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">要记住的一个关键点是，当您压缩数据时，在您的过程中读取数据时，它必须是未压缩的。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/878ca7d00fd62982758e9f9e5303377c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1Ojfb2WsTl-__uMjVMbXA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">解压缩速度与I/O节省的权衡</figcaption></figure><p id="5b8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化:谓词下推</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/8982c8fe4d572edbc0087b6e62986d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHIl6klNvNBqJ-BKNsO_xQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">谓词下推—第一种情况</figcaption></figure><p id="4880" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当Spark运行这个查询时，它首先读取存储元数据的拼花地板的页脚。Spark利用这些元数据来实现行组跳过。在本例中，我们有3个行组，从元数据来看，Spark知道它不必将行组2放入内存。<br/>利用行组中最小/最大统计数据的Spark配置—<em class="kc">Spark . SQL . parquet . filter pushdown .</em>这是默认启用的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/5676c679d675c8de334341819e8f4c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrMbQXRkHb14DYzGhAkXHQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">谓词下推—第二种情况</figcaption></figure><p id="1737" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们寻找等于5的值。Spark基于元数据跳过row-group2。但是它还有2个行组要遍历。Spark现在查看列块的字典。让我们考虑一下行组0，它有全0和一个9。这个栏目块的字典里不会有5。因此，Spark将跳过这个行组。<br/>启用字典过滤的parquet配置—<em class="kc">parquet . filter . dictionary . enabled</em></p><p id="b16d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优化:分区</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/50dae8422c70d53f38e70fcc06ccc726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PR-DvJ8fhbgoj--1LLEx0Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">分割</figcaption></figure><p id="b5af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分区是Spark提供的一个特性。如果我们知道过滤器经常出现的领域，这是非常有用的。在上面的例子中，数据按日期字段进行分区，parquet为日期字段中的每个惟一值创建子目录。</p><p id="b10c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提示</strong></p><p id="9ac6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">避免将数据分成太多的小文件或大块存储。试着在你的文件大小之间找到一个平衡点。</p><p id="63dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">附:这是一份来自Databricks的Spark峰会视频的抄本。</p><p id="6ea5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，请点击👏所以其他人会在媒体上看到它。</p></div></div>    
</body>
</html>