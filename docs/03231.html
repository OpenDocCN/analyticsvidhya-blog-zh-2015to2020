<html>
<head>
<title>Datasets and Dataloaders in PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch中的数据集和数据加载器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/datasets-and-dataloaders-in-pytorch-b1066892b759?source=collection_archive---------13-----------------------#2020-01-21">https://medium.com/analytics-vidhya/datasets-and-dataloaders-in-pytorch-b1066892b759?source=collection_archive---------13-----------------------#2020-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8571" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><em class="ix">一个介绍</em></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/725a0aba254638413b32fa086fe0e334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPd1rUWAIL0uP05fa8TrpQ.png"/></div></div></figure><p id="0910" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi kg translated"><span class="l kh ki kj bm kk kl km kn ko di"> T </span>在实际训练一个模型之前，我们要做的第一件事就是获取数据，清理并准备好这些数据，使它们能够通过我们的模型。我们在这个阶段花费了大部分时间，不仅因为它要求更多，而且我们的模型需要在分配给它的任何任务中实现良好的性能。</p><p id="db4e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">为了让这项艰巨的任务变得简单一点，PyTorch提供了一些工具，包括<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>和<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>。本文的重点是清楚地理解这些工具，以便我们能够有效地使用它们。</p><p id="46e3" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">为了处理数据，PyTorch提供了一个抽象类形式的数据集类。等等，什么是抽象类？让我们快速浏览一遍。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kq"><img src="../Images/8c9d3c3dd4521f012bccbef1a3276d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*OFTVWrdmKl2o6g-QlpYjPQ.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><strong class="bd kv">父类&amp;子类——直觉</strong></figcaption></figure><p id="c94e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">父类可以被视为其子类的蓝图。子类继承父类的属性。类似地，抽象类是其他类的蓝图，但是这个类包括一组称为抽象方法的方法，这些方法必须在任何子类中创建。关于这些抽象方法要记住的另一件事是，它们在抽象类中声明，但没有任何实现。它们是通过子类实现的。</p><blockquote class="kw"><p id="8006" class="kx ky hi bd kz la lb lc ld le lf kf dx translated">你知道吗？</p><p id="9fba" class="kx ky hi bd kz la lb lc ld le lf kf dx translated">Python有一个名为“<a class="ae kp" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank"> abc </a>的模块，为定义抽象基类(ABCs)提供了基础设施。</p></blockquote><p id="1fb6" class="pw-post-body-paragraph jk jl hi jm b jn lg ij jp jq lh im js jt li jv jw jx lj jz ka kb lk kd ke kf hb bi translated">回到我们的抽象数据集类，__len__()和__getitem__()是我们的抽象方法。这意味着无论我们编写什么样的自定义数据集，它都应该覆盖这些抽象方法。我们将很快看到更多关于自定义数据集的内容。</p><p id="db00" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">__len__方法返回传递的数据集的大小。</p><p id="a666" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">__getitem__方法将索引“I”作为输入，并返回数据集中的第“I”个样本，如果指定，则对其应用必要的转换。转换作为可选参数传递给我们的数据集类。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ll"><img src="../Images/cbde4a4305f5a7787ec4676921a6731b.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*6T5IhjDQflNLgkHNrvjPsw.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><strong class="bd kv">数据集类</strong></figcaption></figure><p id="e8c6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">上面显示的<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" rel="noopener ugc nofollow" target="_blank">torch . utils . data . dataset</a>类是从Python的抽象基类(abc)构建的。让我们看看如何创建一个<a class="ae kp" href="https://pytorch.org/tutorials/beginner/data_loading_tutorial.html" rel="noopener ugc nofollow" target="_blank">定制数据集类</a>。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es lm"><img src="../Images/4dca7264945792cb684cf88aef624411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*W-aLIIzwDQIa6PcVCaDM3w.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><strong class="bd kv">从数据集类创建的自定义数据集</strong></figcaption></figure><p id="b727" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在上面的代码块中，My_Dataset是子类，<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" rel="noopener ugc nofollow" target="_blank"> torch.utils.data.Dataset </a>是父抽象类。我们通过传递路径和转换来实例化My_Dataset。</p><blockquote class="ln lo lp"><p id="a21f" class="jk jl lq jm b jn jo ij jp jq jr im js lr ju jv jw ls jy jz ka lt kc kd ke kf hb bi translated">new _ datset = My _ Dataset(path = ' path _ to _ Dataset '，transform = None)</p></blockquote><blockquote class="kw"><p id="2966" class="kx ky hi bd kz la lu lv lw lx ly kf dx translated">你知道吗？</p><p id="1742" class="kx ky hi bd kz la lb lc ld le lf kf dx translated">从抽象类派生的类不能被实例化，除非它的所有抽象方法都被重写。这意味着我们必须在子类中使用抽象方法。</p></blockquote><p id="ea57" class="pw-post-body-paragraph jk jl hi jm b jn lg ij jp jq lh im js jt li jv jw jx lj jz ka kb lk kd ke kf hb bi translated">如果我们不在子类中使用抽象方法，我们会得到一个“<a class="ae kp" href="https://pytorch.org/docs/stable/_modules/torch/utils/data/dataset.html#Dataset" rel="noopener ugc nofollow" target="_blank">notimplementererror</a>”，正如我们在上面的Dataset类中看到的。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="658e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们看到了如何实现Dataset类来创建自定义数据集。我们必须在数据集上迭代，同时将它们传递给我们的模型。<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank">torch . utils . data . data loader</a>是实现这一目标的有效工具，具有以下几个优点。<br/> 1。我们可以创建成批的数据，并将整批数据传递给模型。<br/> 2。我们可以打乱数据。<br/> 3。我们可以使用多重处理并行加载数据。</p><pre class="iz ja jb jc fd mg mh mi mj aw mk bi"><span id="f756" class="ml mm hi mh b fi mn mo l mp mq">dataloader = torch.utils.data.DataLoader(new_dataset, batch_size = 4, shuffle = True, num_workers = 4)</span><span id="3def" class="ml mm hi mh b fi mr mo l mp mq">for i, data in enumerate(dataloader):<br/>_____________<br/>_____________</span></pre><p id="eb06" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">传递给DataLoader的new_dataset是创建的自定义数据集。batch_size指定一次要加载的数据(比如图像)的批次。shuffle = True，启用数据混排。num_workers表示用于并行生成批处理的进程数。</p><p id="d091" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Dataloader只是从数据集中调用__getitem__()方法，并在训练和推理期间对整个批处理进行包装。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ms"><img src="../Images/6f23c9c4fd415e33852c5ff196deb7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*GMn9BMQv2qmqTzs7sTsddQ.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><strong class="bd kv">火炬视觉包让某些任务变得更简单</strong></figcaption></figure><p id="bec7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">PyTorch 的<a class="ae kp" href="https://pytorch.org/docs/stable/torchvision/index.html" rel="noopener ugc nofollow" target="_blank"> Torchvision包有一些常用的数据集，包括MNIST、CIFAR等。使用这个包可以创建自定义数据集，这使得这个过程更加简单。我们不必编写自定义数据集类，除非我们充分利用它的特性。</a></p><p id="4191" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae kp" href="https://pytorch.org/docs/stable/torchvision/datasets.html" rel="noopener ugc nofollow" target="_blank"> torchvision.datasets </a>下的所有数据集都是父抽象类<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" rel="noopener ugc nofollow" target="_blank"> torch.utils.data.Dataset </a>的子类，这意味着它们都实现了__len__()和__getitem__()方法。同样，这些数据集可以类似地传递给一个<a class="ae kp" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>，就像我们之前看到的那样。torchvision.datasets下的一个通用数据集类是<a class="ae kp" href="https://pytorch.org/docs/stable/torchvision/datasets.html#imagefolder" rel="noopener ugc nofollow" target="_blank"> ImageFolder类。</a></p><p id="f611" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们看到了PyTorch的数据集和数据加载器是如何工作的，以及我们如何利用这些神奇的工具来构建我们的自定义数据集。准备数据是最重要的，因为模型从我们提供的数据中学习。</p><p id="b121" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">最后，查看关于数据集和数据加载器的PyTorch文档，了解更多信息和示例。如果这篇文章有帮助，请告诉我。</p></div></div>    
</body>
</html>