<html>
<head>
<title>Namespace, Scope , LEGB rule and global and non-local variable in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中的命名空间、范围、LEGB规则以及全局和非局部变量</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/namespace-scope-legb-rule-and-global-and-non-local-variable-in-python-d84c3e05e1c8?source=collection_archive---------12-----------------------#2020-05-12">https://medium.com/analytics-vidhya/namespace-scope-legb-rule-and-global-and-non-local-variable-in-python-d84c3e05e1c8?source=collection_archive---------12-----------------------#2020-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="203c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">命名空间:</h2></div><p id="b7e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Python中，一切都是一个对象，我们给这个对象一个名字，这样我们以后就可以访问它。</p><p id="2e17" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以将名称空间看作是一个键-值对的字典，其中键是变量名，值是与之关联的对象。</p><h2 id="aae5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">范围</h2><p id="9e11" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">变量范围定义了我们搜索变量的层次结构。</p><p id="7e9b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">python中变量的作用域是代码中可访问或可见的位置或部分。</p><h2 id="c471" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">LEGB:</h2><p id="2b7f" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">LEGB规则用于决定在范围解析中搜索名称空间的顺序。</p><p id="837f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">变量的作用域可以是局部的(L)，封闭的(E)，全局的(G)，内置的(B)。</p><p id="d571" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们借助例子来理解整个概念:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/a52cb0ba662d7d9116eb1280dc6c154c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSo2DwCeK-c9YqkvNTScZQ.jpeg"/></div></div></figure><p id="8fc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，变量a，b没有在任何函数中定义，因此它们是全局变量。它们可以在程序的任何地方被访问。</p><p id="7e31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在看看local_function()，这里我们又有了变量a，但它只能在函数内部访问，因此它被称为局部变量。</p><p id="ac7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们调用local_function()时，输出将是，</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lf"><img src="../Images/a0a02b881f11fa40b240db972da663bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnW54227PPhuDpvxrzvwOA.jpeg"/></div></div></figure><p id="c70a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要打印a和b的值，解释器将检查变量是否定义在局部范围内。这里定义了变量a，但没有定义b，现在解释器在全局范围内检查变量b。在输出中，我们得到a=20和b=20，因为解释器在局部范围内得到a的值，在全局范围内得到b的值。</p><blockquote class="lg lh li"><p id="283d" class="ix iy lj iz b ja jb ij jc jd je im jf lk jh ji jj ll jl jm jn lm jp jq jr js hb bi translated">记住，解释器总是首先在局部范围内搜索变量值。</p></blockquote><p id="d9d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，上去看看enclosing_function。在enclosing_function中，我们有变量c和inner_function()，变量c可以在enclosing_function和inner_function中访问，因此c有封闭的作用域。</p><p id="6921" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们调用enclosing_function()时，它将返回inner_function()，当我们调用inner_function时，输出将是，</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ln"><img src="../Images/310bc2bc9789d03afe3de1419d5a2505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5yJhjGvw2qDhC-cfjhgjw.jpeg"/></div></div></figure><p id="e041" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解释器将在局部范围内检查变量d的值，即在inner_function内部，得到d的值。由于c没有在inner_function中定义，它将在封闭范围内检查，即在enclosing_function内部，得到c的值。变量b没有在inner_function和enclosing_function中定义，解释器将检查全局范围内的b。</p><blockquote class="lg lh li"><p id="1e98" class="ix iy lj iz b ja jb ij jc jd je im jf lk jh ji jj ll jl jm jn lm jp jq jr js hb bi translated">别忘了，</p><p id="987c" class="ix iy lj iz b ja jb ij jc jd je im jf lk jh ji jj ll jl jm jn lm jp jq jr js hb bi translated">局部→封闭→全局</p></blockquote><p id="f34d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们已经完成了LEGB规则的一部分，现在让我们来理解内置(B)。</p><p id="2b8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">内置的是一个特殊的Python作用域，每当运行脚本时都会创建或加载它。这个范围包含诸如关键字、函数、异常和Python中内置的其他属性的名称。这个Python范围内的名称也可以在代码中的任何地方找到。当你运行一个程序或脚本时，Python会自动加载它。</p><p id="2022" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们借助下面的例子来理解它:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lo"><img src="../Images/0ebd32e6646f0336dee37b130aff8d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iN2I-oQzyIshdcaj6hb4A.jpeg"/></div></div></figure><p id="d976" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">len()是python中的内置函数。len()计算长度。当我们运行以上代码时，输出将是:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lp"><img src="../Images/94d4f0239683e87edb9c4460a89fcc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dC5HOOxpUXj7TtH41QaRLw.jpeg"/></div></div></figure><p id="3973" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在看看下面代码，</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lq"><img src="../Images/150d74d7e0544e10e52cf028ab822110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQb4XUzTpLId-BkmkiR6pw.jpeg"/></div></div></figure><p id="cfd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们运行上面的代码输出时，我们得到的是，</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lr"><img src="../Images/304baad00286d0f46fc82472883b4922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8r6CRKLkxx3In2bQeNp9g.jpeg"/></div></div></figure><p id="78a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们调用了同一个函数len，但是在第一个输出中我们得到了列表的长度，在第二个输出中我们得到了列表本身。这是因为，我们已经定义了同名的函数，而那个函数只是返回了列表。</p><p id="17c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一种情况下，解释器在我们的脚本中没有len函数，因此它调用内置函数。</p><p id="1a92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第二种情况下，解释器在我们的脚本中获得了len函数，因此它没有调用内置函数。</p><blockquote class="lg lh li"><p id="a179" class="ix iy lj iz b ja jb ij jc jd je im jf lk jh ji jj ll jl jm jn lm jp jq jr js hb bi translated">记住这条规则，</p><p id="29eb" class="ix iy lj iz b ja jb ij jc jd je im jf lk jh ji jj ll jl jm jn lm jp jq jr js hb bi translated">局部→封闭→全局→内置</p></blockquote><h2 id="c3d3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">全局和非局部变量:</h2><p id="d3d2" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">如果我们在函数内部用关键字global定义了变量，那么我们就可以访问和修改全局变量。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ls"><img src="../Images/51668835433e53463c6d9cbceb90aac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHlJQT_L__Os2oGy-04YNA.jpeg"/></div></div></figure><p id="18e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lt"><img src="../Images/95ab9c582e8295f79af50112fa68f77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lu0OmT0FgKS7URTlP6SLOQ.jpeg"/></div></div></figure><p id="4d2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们已经访问了全局变量a并修改了内部函数。</p><h2 id="3f25" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">非局部变量:</h2><p id="863d" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">非局部变量用于未定义局部范围嵌套函数中。这意味着变量既不能在局部范围内，也不能在全局范围内。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lu"><img src="../Images/ff4361dba505a8434c385485040d4e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKEjs8rhKGsRGY_E-42BbQ.jpeg"/></div></div></figure><p id="8ed0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lv"><img src="../Images/0a3285d984cb44ccbbfb4f7de95c9637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZKVfr6pL_lRfVLdgSv7AQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>