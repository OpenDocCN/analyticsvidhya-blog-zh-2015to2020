<html>
<head>
<title>Cachediff: A tool to perform localized cache analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cachediff:执行本地化缓存分析的工具</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cachediff-a-tool-to-perform-localized-cache-analysis-bfd7ea0406a0?source=collection_archive---------14-----------------------#2020-09-13">https://medium.com/analytics-vidhya/cachediff-a-tool-to-perform-localized-cache-analysis-bfd7ea0406a0?source=collection_archive---------14-----------------------#2020-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db609f0bc8deed767fedb8425f6b3211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*65H3NnI2BfPGEvCW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">泰勒·达维在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0dc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cachediff 是一个用来执行本地化缓存分析的工具。本地化高速缓存分析处理回答关于本地代码如何在同一 C/C++程序的两个或多个版本之间变化影响高速缓存性能的问题。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="9e45" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为什么我们需要 Cachediff？</h1><p id="2501" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">计算机组织和体系结构是任何计算机科学课程的核心课程。教授这门课程的一般方法是使用幻灯片和图表等被动工具。为了让学生感兴趣，教师必须拿出像动画和模拟这样的主动学习工具。这确实需要讲师花费大量的时间和精力。可以理解的是，这种情况并不总是发生，经常会导致学生失去兴趣。</p><p id="463b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">内存管理是计算机组织和体系结构的一个重要方面。像本课程中的大多数其他主题一样，用常规的方法学习是很困难的。研究人员已经提出了缓存模拟器。缓存模拟器是真实世界的模型。虽然复杂，但它们是理解和验证的极好工具。然而，这些缓存模拟器只能帮助分析整个程序。它们不提供本地化分析。</p><p id="32c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cachediff 是一个免费的开源工具，我们开发该工具是为了让学生、教师和专业人士能够执行本地化的缓存分析。这里的本地化缓存分析是指改变一个较大程序的一小部分如何影响较大程序的缓存性能。</p><p id="dc12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">学生可以使用它来更好地理解他们在整个计算机科学课程中学到的概念。他们可能用它来验证一些问题的答案，比如为什么按行遍历比按列遍历快。他们可以使用它来验证他们的编译器确实执行了优化以提高缓存性能。</p><p id="8fab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">教师可以用它作为教学辅助。他们可以演示编写非缓存友好代码的效果。教师也可能会布置作业，并根据哪个学生编写的代码最适合缓存来给作业打分。</p><h1 id="0a0e" class="ka kb hi bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">高速缓存性能和程序执行</h1><p id="175f" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">让我们举一个在 C/C++代码中迭代二维数组的简单例子。遍历整个数组有两种方法，要么是行主遍历，要么是列主遍历，也就是说，选择一行，遍历该行中的所有元素，然后转到下一行，或者选择一列，遍历该列中的所有元素，然后继续下一列。相同的图示可以在下面看到</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/3331a1ca0a45b6b337e6197f64c4f91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GKbVOU6rn_-NLkQn.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片取自<a class="ae iu" href="https://craftofcoding.files.wordpress.com/2017/02/rowcolumnarrays.jpg" rel="noopener ugc nofollow" target="_blank">卡夫丁峡谷</a></figcaption></figure><p id="ad02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是两个遍历的代码片段。</p><p id="1deb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">行主遍历</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8d26" class="ls kb hi lo b fi lt lu l lv lw">#include &lt;stdio.h&gt;<br/>#define SIZE 10000</span><span id="3c9f" class="ls kb hi lo b fi lx lu l lv lw">int main() {<br/>    int x[SIZE][SIZE];<br/>    int i, j;<br/>    for(i=0; i&lt;SIZE; ++i) {<br/>        for(j=0; j&lt;SIZE; ++j) {<br/>            x[i][j];<br/>        }<br/>    }<br/>}</span></pre><p id="76a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">列主遍历</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="be35" class="ls kb hi lo b fi lt lu l lv lw">#include &lt;stdio.h&gt;<br/>#define SIZE 10000</span><span id="a847" class="ls kb hi lo b fi lx lu l lv lw">int main() {<br/>    int x[SIZE][SIZE];<br/>    int i, j;<br/>    for(i=0; i&lt;SIZE; ++i) {<br/>        for(j=0; j&lt;SIZE; ++j) {<br/>            x[j][i]; // See it is x[j][i], not x[i][j]<br/>        }<br/>    }<br/>}</span></pre><p id="b32c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">以上代码片段会有相似/可比的性能吗？当</strong> <code class="du ly lz ma lo b"><strong class="ix hj">SIZE</strong></code> <strong class="ix hj">趋向于</strong> <code class="du ly lz ma lo b"><strong class="ix hj">INFINITY</strong></code> <strong class="ix hj">时会发生什么？</strong></p><p id="aacc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要理解在<code class="du ly lz ma lo b">C/C++</code>语言中内存分配是如何发生的。在许多高级语言中，内存分配是以行为主的，这意味着以行为主的方式比以列为主的方式更容易读写。为了简单地找出性能差异，我们可以使用下面的代码(摘自<a class="ae iu" href="https://www.geeksforgeeks.org/performance-analysis-of-row-major-and-column-major-order-of-storing-arrays-in-c/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a>)来检查遍历 row-major 和 column-major 所需的时间。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="81d5" class="ls kb hi lo b fi lt lu l lv lw">#include &lt;stdio.h&gt; <br/>#include &lt;time.h&gt; <br/>int m[9999][999];</span><span id="fd55" class="ls kb hi lo b fi lx lu l lv lw">void main() {<br/>    int i, j; <br/>    clock_t start, stop; <br/>    double d = 0.0;</span><span id="3b80" class="ls kb hi lo b fi lx lu l lv lw">start = clock(); <br/>    for (i = 0; i &lt; 9999; i++) <br/>        for (j = 0; j &lt; 999; j++) <br/>            m[i][j] = m[i][j] + (m[i][j] * m[i][j]);</span><span id="c2b4" class="ls kb hi lo b fi lx lu l lv lw">stop = clock(); <br/>    d = (double)(stop - start) / CLOCKS_PER_SEC; <br/>    printf("The run-time of row major order is %lf\n", d);</span><span id="c5dd" class="ls kb hi lo b fi lx lu l lv lw">start = clock(); <br/>    for (j = 0; j &lt; 999; j++) <br/>        for (i = 0; i &lt; 9999; i++) <br/>            m[i][j] = m[i][j] + (m[i][j] * m[i][j]);</span><span id="f40d" class="ls kb hi lo b fi lx lu l lv lw">stop = clock(); <br/>    d = (double)(stop - start) / CLOCKS_PER_SEC; <br/>    printf("The run-time of column major order is %lf", d); <br/>}</span></pre><p id="37f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出是</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="fc3b" class="ls kb hi lo b fi lt lu l lv lw">The run-time of row major order is 0.067300<br/>The run-time of column major order is 0.136622</span></pre><p id="691d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以清楚地看到，列主遍历所花费的时间是行主遍历的 2 倍。罪魁祸首是，每当您试图获取 2D 数组中的下一个元素时，都会出现缓存未命中。下图解释了缓存命中/未命中流。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/d56c351b9239b862cc2de53397cc7c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*Lgu4PeKOlBsk2KSY.jpg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片取自<a class="ae iu" href="https://www.geeksforgeeks.org/locality-of-reference-and-cache-operation-in-cache-memory/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a></figcaption></figure><p id="dfc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以下一个明显的问题是，为什么我们在列主遍历中比在行主遍历中看到更多的未命中？这是因为高速缓存试图根据“引用局部性”原则获取下一条指令和数据。每当处理第 I 个位置的数据时，高速缓存会尝试预取第 i+1 个位置的数据，以期待下一个处理该数据。在行主遍历的情况下，处理的是 i+1 位置，而在列主遍历的情况下，是 i+ROW_SIZE 位置，如果 ROW_SIZE 足够大的话，很可能不会在缓存中。</p><p id="dd97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用 Cachediff 工具来理解程序 wrt 缓存(尤其是 L1 缓存)的行为。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="4f97" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Cachediff</h1><p id="f0a7" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Cachediff:是一个用来执行本地化缓存分析的工具。本地化高速缓存分析处理回答关于本地代码如何在同一 C/C++程序的两个或多个版本之间变化影响高速缓存性能的问题。以前关于这个主题的工作仅仅涵盖了对一个程序的整体分析。我们以他们的工作为基础，同时利用某些操作系统和编译器特性来隔离本地代码更改，并跟踪它们对整个缓存系统的影响。Cachediff 对于教师、学生和专业人员分析程序的缓存性能非常有用。</p><p id="d3b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cachediff 内部是如何工作的？</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/689e48821241cbc83158e9a123dec60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*twml3TT280oRLR7Hi0TlIQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Cachediff 的高层设计</figcaption></figure><p id="03e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里是同样的一步一步的指令/算法。</p><ol class=""><li id="e9f8" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">为 C/C++程序编译并生成一个可执行的二进制文件。</li><li id="bc44" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">然后用流水线指令转储可执行文件，得到抽象文件表示。</li><li id="aa2e" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">从上一步构建的抽象表示中找出差异/增量。</li><li id="53fa" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">可执行文件以及相应的输入文件在英特尔 pin 下运行，以获得 Pin 跟踪。</li><li id="36fe" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">确保我们得到“全局跟踪”——整个程序的跟踪，“非局部跟踪”——全局跟踪减去局部跟踪，“局部跟踪”——我们感兴趣的程序的跟踪。</li><li id="dde7" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">“全局跟踪”和“局部跟踪”文件被提供给像 DineroIV 这样的跟踪驱动的缓存模拟器。</li><li id="3d04" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">禁用地址空间布局随机化(ASLR) —这可能是必需的，以便我们从两个程序的比较中获得的可执行文件来自相似的地址空间布局。</li></ol><h2 id="2488" class="ls kb hi bd kc mr ms mt kg mu mv mw kk jg mx my ko jk mz na ks jo nb nc kw nd bi translated">试用 Cachediff</h2><p id="b857" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">要快速开始，您可以运行下面的命令</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="5a0c" class="ls kb hi lo b fi lt lu l lv lw"># Clone this Repo<br/>git clone <a class="ae iu" href="https://github.com/ksameersrk/cachediff" rel="noopener ugc nofollow" target="_blank">https://github.com/ksameersrk/cachediff</a> /tmp/cachediff</span><span id="d8d5" class="ls kb hi lo b fi lx lu l lv lw"># Run the Simulation using the image: ksameersrk/cachediff<br/>docker run -v /tmp/cachediff/examples:/app/examples ksameersrk/cachediff examples/matrix/row_wise_traversal.c examples/matrix/column_wise_traversal.c examples/matrix/input100.txt examples/matrix/input100.txt</span></pre><p id="1260" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该会看到这样的输出</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/e093a506e3fdc34495f216160bfa0327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*13J153pMSSKnYZmwsqlwnA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Cachediff 的输出</figcaption></figure><p id="78e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据输出，本地文件 1 是行优先遍历，本地文件 2 是列优先遍历。我们清楚地看到，与列主遍历[红点]相比，行主遍历[绿点]中的未命中更少。下图显示了列主的 L1 缓存未命中是如何随着数组大小的增加而呈指数增长的。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/4fe68ab527130e4bf38ec286fd526342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*yQ4ZmdlwsMss5s6Cgswrmg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">缓存未命中随着输入大小的增加而增加</figcaption></figure><p id="88a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以尝试更多有趣的例子，比如冒泡排序和快速排序，以及来自<a class="ae iu" href="https://github.com/ksameersrk/cachediff" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>的不同散列算法。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="9832" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这项工作是由<a class="ae iu" href="http://saimadhav.com/" rel="noopener ugc nofollow" target="_blank">赛马达夫</a>和<a class="ae iu" href="https://sameer.page" rel="noopener ugc nofollow" target="_blank">梅</a>在本科期间完成的。你可以在 GitHub 资源库—【https://github.com/ksameersrk/cachediff】T4 中找到项目论文和代码。这篇文章最初发表在我的博客上——这篇文章摘自<a class="ae iu" href="https://sameer.page/Cachediff-localized-cache-analysis" rel="noopener ugc nofollow" target="_blank">我的页面</a>。</p></div></div>    
</body>
</html>