<html>
<head>
<title>CNN Transfer Learning with VGG16 using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras的VGG16的CNN迁移学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cnn-transfer-learning-with-vgg16-using-keras-b0226c0805bd?source=collection_archive---------9-----------------------#2020-08-23">https://medium.com/analytics-vidhya/cnn-transfer-learning-with-vgg16-using-keras-b0226c0805bd?source=collection_archive---------9-----------------------#2020-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如何使用VGG-16预训练Imagenet权重识别物体</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/21749f04906fb43e5bdb90c6ebff0569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niqzkr1IOzfegXdB5FV1BQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">来源(<a class="ae ju" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="1ba7" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak">什么是迁移学习</strong></h2><blockquote class="kq kr ks"><p id="7872" class="if ig jd ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">将从一项任务中学到的知识转移到另一项相关任务的认知行为。每当我们试图学习新技能时，我们人类天生就使用这一点。一些例子是</p></blockquote><ul class=""><li id="2320" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">知道如何骑cycle⮫学习如何骑摩托车。</li><li id="ee40" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">知道如何骑摩托车⮫学习如何骑汽车。</li></ul><p id="15f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的类比，它也适用于深度学习CNN，其中我们可以使用来自预训练网络的学习/权重来预测或分类另一个数据集上的标签。</p><h2 id="e44e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak">为什么要为CNN转学</strong></h2><ul class=""><li id="b5bf" class="kw kx hi ih b ii lk im ll iq lm iu ln iy lo jc lb lc ld le bi translated">通常很少有人从零开始(随机初始化)训练卷积网络，因为很少能得到足够的数据集。因此，我们通常使用预先训练好的网络权重作为解决大部分问题的初始值。</li><li id="0342" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">训练非常深的网络是昂贵的。最复杂的模型需要数周时间，使用数百台配备昂贵GPU的机器进行训练。</li></ul><p id="d1e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，我们有预先训练的模型，这些模型通常以数百万个参数/权重的形式共享，这些参数/权重是模型在被训练到稳定状态时获得的。</p><ul class=""><li id="543a" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><a class="ae ju" href="https://www.kaggle.com/keras/vgg16/home" rel="noopener ugc nofollow" target="_blank"> VGG-16 </a></li><li id="8cee" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><a class="ae ju" href="https://www.kaggle.com/keras/vgg19/home" rel="noopener ugc nofollow" target="_blank"> VGG-19 </a></li><li id="9abf" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><a class="ae ju" href="https://arxiv.org/abs/1512.00567" rel="noopener ugc nofollow" target="_blank">盗梦空间V3 </a></li><li id="d4f1" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><a class="ae ju" href="https://arxiv.org/abs/1610.02357" rel="noopener ugc nofollow" target="_blank">异常</a></li><li id="9428" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><a class="ae ju" href="https://www.kaggle.com/keras/resnet50/home" rel="noopener ugc nofollow" target="_blank"> ResNet-50 </a></li></ul><h2 id="b1dc" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak">迁移学习是如何工作的？</strong></h2><p id="7baf" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">让我们看看神经网络结构如何寻找任何模型</p><ul class=""><li id="f5f7" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">我们有第一个部分是特征转换器。</li><li id="a307" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">最后一部分是线性模型。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ls"><img src="../Images/b0a214badf058a597c2174b281b01e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvqgIO8kcIfwsRMQsSA30g.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">神经网络视角</figcaption></figure><p id="f1ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将了解如何使用VGG-16作为预训练模型来实现迁移学习并预测水果数据集的标签。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/dfc4b2c51700e14f04e27a4a7f2afb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7U6OUq79AZSixZYrME0Dcw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">VGG迁移学习</figcaption></figure><p id="101d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是实施迁移学习的步骤</p><ul class=""><li id="551c" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">加载在大数据集上训练的预训练VGG-16 CNN模型。</li><li id="b43e" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">断开头部(冻结模型较低卷积层中的参数(权重))。</li><li id="a6d1" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">直到倒数第二层的所有东西都是最先进的特性转换器，可以直接使用。</li><li id="a3e9" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">在最先进的特征转换器上添加我们自己的自定义分类器，并对其进行训练。</li></ul><h2 id="7cc9" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak"> Keras实施</strong></h2><p id="c06a" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">我们将使用kaggle的fruits-360数据集来应用迁移学习和预测水果标签。(<a class="ae ju" href="https://www.kaggle.com/moltean/fruits" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a>)。</p><p id="6c92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它被称为fruit-360，因为它可以从各个视角拍摄水果图像。</p><p id="aaee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。装载VGG-16预训练模型</strong></p><p id="8d09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在VGG-16上装载预先训练好的图像净重。</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="2e3a" class="jv jw hi lv b fi lz ma l mb mc">vgg<strong class="lv hj">=</strong>VGG16(include_top<strong class="lv hj">=False</strong>,weights<strong class="lv hj">=</strong>'imagenet',input_shape<strong class="lv hj">=</strong>(100,100,3))</span></pre><p id="bf26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。冻结所有VGG-16层，只训练分类器</strong></p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="1716" class="jv jw hi lv b fi lz ma l mb mc">for layer in vgg.layers:<br/>   layer.trainable = False<br/>#Now we will be training only the classifiers (FC layers)</span></pre><p id="412d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。添加Softmax分类器</strong></p><p id="93f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">展平vgg下层输出，用activation softmax创建致密层。</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="17fb" class="jv jw hi lv b fi lz ma l mb mc">x=Flatten()(vgg.output)<br/>prediction=Dense(len(folders),activation='softmax')(x)<br/>model=Model(inputs=vgg.input,outputs=prediction)</span></pre><p id="1a8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。编译模型</strong></p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="950d" class="jv jw hi lv b fi lz ma l mb mc">model.compile(optimizer=’rmsprop’,loss=’categorical_crossentropy’,metrics=[‘accuracy’])</span></pre><p id="81c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。图像增强和预处理</strong></p><p id="e19d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像增强是通过对图像应用随机变换来人为增加我们的模型看到的训练图像的数量。例如，我们可以随机旋转或裁剪图像，或者水平翻转它们。</p><p id="4437" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有最后一个参数<code class="du md me mf lv b">preprocess_input</code>，它的意思是使你的图像符合模型要求的格式。它将按照VGG-16对图像进行预处理。</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="4d43" class="jv jw hi lv b fi lz ma l mb mc">gen=ImageDataGenerator(rotation_range=20,width_shift_range=0.1,height_shift_range=0.1,shear_range=0.1,zoom_range=0.2,horizontal_flip=True,vertical_flip=True,preprocessing_function=preprocess_input)</span></pre><p id="7c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 6。拟合模型</strong></p><p id="4d09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用Keras<em class="jd">flow _ from _ directory</em>方法创建训练和测试数据生成器，并将训练和验证目录作为输入。</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="f613" class="jv jw hi lv b fi lz ma l mb mc">batch_size = 32<br/>train_generator = gen.flow_from_directory(<br/>  train_path,<br/>  target_size=IMAGE_SIZE,<br/>  shuffle=True,<br/>  batch_size=batch_size,<br/>)<br/>valid_generator = gen.flow_from_directory(<br/>  valid_path,<br/>  target_size=IMAGE_SIZE,<br/>  shuffle=True,<br/>  batch_size=batch_size,<br/>)</span></pre><p id="475d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后用fit_generator方法拟合模型。</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="f2d5" class="jv jw hi lv b fi lz ma l mb mc">epochs=2</span><span id="55a4" class="jv jw hi lv b fi mg ma l mb mc"># fit the model<br/>r = model.fit_generator(<br/> train_generator,<br/> validation_data=valid_generator,<br/> epochs=epochs,<br/> steps_per_epoch=len(image_files) // batch_size,<br/> validation_steps=len(valid_image_files) // batch_size,<br/>)</span></pre><p id="53b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 7。预测模型</strong></p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="3860" class="jv jw hi lv b fi lz ma l mb mc">STEP_SIZE_TEST=valid_generator.n//valid_generator.batch_size<br/>valid_generator.reset()<br/>pred=model.predict_generator(valid_generator,<br/>steps=STEP_SIZE_TEST,<br/>verbose=1)</span><span id="2f2b" class="jv jw hi lv b fi mg ma l mb mc">predicted_class_indices=np.argmax(pred,axis=1)</span></pre><p id="8aa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8。获取混淆矩阵</p><p id="cb8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了生成混淆矩阵，我们需要相同顺序的预测和实际标签。但是这里由于使用了flow_from_directory，所以我们不确定它们的顺序。所以我们将创建自己的函数来获得混淆矩阵</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="5a98" class="jv jw hi lv b fi lz ma l mb mc">image_files = glob(train_path + '/*/*.jp*g')<br/>valid_image_files = glob(valid_path + '/*/*.jp*g')</span><span id="5f7b" class="jv jw hi lv b fi mg ma l mb mc">def get_confusion_matrix(data_path, N):<br/>  # we need to see the data in the same order<br/>  # for both predictions and targets<br/>  print("Generating confusion matrix", N)<br/>  predictions = []<br/>  targets = []<br/>  i = 0<br/>  for x, y in gen.flow_from_directory(data_path, target_size=IMAGE_SIZE, shuffle=False, batch_size=batch_size * 2):<br/>    i += 1<br/>    if i % 50 == 0:<br/>      print(i)<br/>    p = model.predict(x)<br/>    p = np.argmax(p, axis=1)<br/>    y = np.argmax(y, axis=1)<br/>    predictions = np.concatenate((predictions, p))<br/>    targets = np.concatenate((targets, y))<br/>    if len(targets) &gt;= N:<br/>      break</span><span id="4a6f" class="jv jw hi lv b fi mg ma l mb mc">cm = confusion_matrix(targets, predictions)<br/>return cm</span><span id="2690" class="jv jw hi lv b fi mg ma l mb mc">cm = get_confusion_matrix(train_path, len(image_files))<br/>print(cm)<br/>valid_cm = get_confusion_matrix(valid_path, len(valid_image_files))<br/>print(valid_cm)</span></pre><p id="31fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">生成混淆矩阵</em> <strong class="ih hj"> <em class="jd">需要一些时间，所以要有耐心</em> </strong> <em class="jd">！</em></p><p id="d5a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 9。绘图损失和精确度</strong></p><p id="8d96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将绘制验证和训练集的损失和准确性。</p><pre class="jf jg jh ji fd lu lv lw lx aw ly bi"><span id="7851" class="jv jw hi lv b fi lz ma l mb mc">#loss<br/>plt.plot(r.history['loss'], label='train loss')<br/>plt.plot(r.history['val_loss'], label='val loss')<br/>plt.legend()<br/>plt.show()</span><span id="b8a5" class="jv jw hi lv b fi mg ma l mb mc"># accuracies<br/>plt.plot(r.history['acc'], label='train acc')<br/>plt.plot(r.history['val_acc'], label='val acc')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mh"><img src="../Images/82e3ee7ae413372f665d735bba6fb4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*k4QaONPNe8KA0i3viYKwEA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">损耗和精度图</figcaption></figure><p id="076c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经训练了epochs=2的模型，我们可以尝试用更多的数字来查看更多的变化和洞察力。</p><p id="79d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们能够使用VGG-16预训练权重从fruits-360数据集预测水果，准确率超过85%。它可以通过更多次数的训练来进一步提高。</p><h2 id="cfea" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak">代码</strong></h2><p id="c1bf" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">(<a class="ae ju" href="https://github.com/jhanwarakhil/vgg16_transfer_learning" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">https://github.com/jhanwarakhil/vgg16_transfer_learning</strong></a><strong class="ih hj">)</strong></p><h2 id="6e05" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">参考</h2><ol class=""><li id="77a4" class="kw kx hi ih b ii lk im ll iq lm iu ln iy lo jc mi lc ld le bi translated"><a class="ae ju" href="https://www.kaggle.com/moltean/fruits" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/moltean/fruits</a></li><li id="e050" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mi lc ld le bi translated"><a class="ae ju" href="http://keras.io/" rel="noopener ugc nofollow" target="_blank"> keras.io </a></li></ol></div></div>    
</body>
</html>