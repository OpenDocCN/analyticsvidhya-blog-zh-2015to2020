# 什么是贪婪算法？

> 原文：<https://medium.com/analytics-vidhya/what-is-the-greedy-algorithm-5ed71f9a7b3a?source=collection_archive---------12----------------------->

![](img/413a228e2757d0d35b6138e727330b10.png)

贪婪算法通过在特定时刻做出看起来最合适的选择来解决问题。这种算法的使用经常出现在许多优化问题中。贪婪算法提供了在两个属性下接近最优的有效解决方案:其中之一是“贪婪选择属性”,其基于其当前情况做出局部最优决策，第二个是“最优结构”,其包含最优解决方案的子问题的解决方案。然而，贪婪算法有时无法获得全局最优解，因为它们不会一次性穷尽所有数据。这是一个问题，因为在算法的早期做出某些决定可能会阻止它在以后找到最佳的整体解决方案。也就是说，如果贪婪算法被证明能够产生给定问题的全局最优解，那么它就成为首选方法，因为它比任何其他优化方法(如动态规划等)都要快。

在一个优化问题中，例如在找零时确定要给的硬币的最小数量，一个人基本上会模仿一个贪婪的算法，例如用值为{1，5，10，25}的硬币来表示 35 美分。从剩余的零钱中减去最高值的硬币，在这种情况下是“25”，这是局部最优值。这个示例问题被称为“做出改变”问题。使用贪婪算法的另一个例子是在二叉树中寻找最大和的路径。它通过在寻找局部最优解的每个步骤中选择最大的数，然后继续直到到达最后一个节点。然而，因为这种算法根据它在给定步骤上的信息做出局部最优解，而不考虑整体问题，所以这种算法在这样的优化问题中并不总是被证明是可靠的。

另一个贪婪算法的例子可以在霍夫曼算法中找到。Huffman 算法导出一个表格，记录输入中每个符号/字符的出现频率。这是用于压缩的——从传真机，压缩文件 mp4 等等。霍夫曼编码的工作原理是操纵一些事情比其他事情发生得更频繁的想法。使用这种编码，一个字符出现得越多，它使用的位就越少——可以通过一个树来表示，其中每个节点用一个字节符号和该字节在数据中的出现频率来表示。这在数据传输和文件压缩中尤其重要，因为快速高效数据传输的目标是在最常发生的事情上花费更少的精力。关于贪婪算法，Huffman 的算法结合了两个最小的节点(唯一的输入/字符),并使这些编码长一位——因为给它们分配更长的位模式比更频繁的输入/字符更优化，从而最小化给定文件的大小。

霍夫曼编码的使用可以追溯到在任何数据传输过程中减少数据大小最终减少内存消耗的时代。这一点很重要，因为十多年前，计算机的硬盘容量不超过 10 兆字节，而现在，微小的芯片拥有数十亿字节的内存。随着技术越来越先进，数据所需的内存和数据传输之间的关系成线性增长。随着更先进的技术的出现，出现了更好地利用内存的新方法——一种新方法是压缩文件的概念。如前所述，压缩文件是一个通过处理某些事情比其他事情发生得更频繁的想法的过程。这种“压缩”的想法在通过普通网络传输文件或者甚至只是在磁盘上分配更多空间时变得非常方便。

空间和内存是计算机操作的重要组成部分，尤其是在主要的计算机应用程序中。这就是为什么数据结构和算法对于有效地存储和搜索大量数据如此重要。根据问题/应用的性质，实现适当的数据结构，在该数据结构中，以最佳的时间复杂度来操纵数据。大多数结构基于关键字值执行搜索，而数据结构“Trie”基于保存关键字的单个字符或数字执行存储和搜索。当有单独的字符操作来确定结构本身中的某些位置时，通常需要 Trie 结构。这种结构也被称为“m 元树”,因为它根据单个字符创建分支的数量。trie 结构的分支通常取决于特定的字符位置。此外，trie 的整体结构依赖于一组连接回空根节点的链接节点。Tries 提供了一些很大的好处，因为大多数 trie 的实现都发生在构造函数中。构造函数是添加节点和为每个数组分配大量内存的地方。然而，随着 trie 大小的增长，这变得更加简单和有效。trie 的时间复杂度取决于该结构包含多少关键字/单词以及它们的长度。

总之，贪婪算法通常很容易提出和实现。然而，这种算法因为狡猾而臭名昭著。哪怕是最小的细节都可能导致错误，从而破坏算法的核心原则。其他优化方法，如回溯或动态编程，为错误提供了一个相对安全的基础——但是，如果证明可以生成给定问题的全局最优解，贪婪算法的执行速度比任何其他方法都快。最终，没有任何关于如何应用贪婪方法的通用模板，但是根据问题的具体情况，可以得出是否使用该算法的结论。此外，有些情况下，程序员面临许多贪婪的假设，但只有少数是正确的。这就是挑战机会出现的地方，由程序员决定如何处理这样的优化问题。