<html>
<head>
<title>How to make a movie recommender: making a REST API using FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作电影推荐器:使用FastAPI制作REST API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-make-a-movie-recommender-making-a-rest-api-using-fastapi-196cc0299a13?source=collection_archive---------6-----------------------#2020-12-12">https://medium.com/analytics-vidhya/how-to-make-a-movie-recommender-making-a-rest-api-using-fastapi-196cc0299a13?source=collection_archive---------6-----------------------#2020-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="395e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>是Python的后端框架，就像Flask或者Django一样(比Django更Flask)。这个框架使得创建和测试端点变得非常容易，因为它抽象了REST API的许多复杂部分。这有其利弊，主要是易用性与可配置性的交换。后端的所有代码都可以在<a class="ae jd" href="https://github.com/jdortuzar5/movie-recommender/tree/master/backend" rel="noopener ugc nofollow" target="_blank">这里</a>找到。该项目的所有代码可以在<a class="ae jd" href="https://github.com/jdortuzar5/movie-recommender" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="65b3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是REST API？</h1><p id="9e7a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">API(应用程序编程接口)是一个接口，它根据规则和定义定义了一个程序可以与另一个程序交互的数量(<a class="ae jd" href="https://en.wikipedia.org/wiki/API" rel="noopener ugc nofollow" target="_blank">源</a>)。REST(表示状态转移)API是编写web服务的“风格”或“指南”。换句话说，Rest API是一个专门设计用于在网络中交流和交互的软件。</p><p id="4f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个项目中，我们将我们的应用程序分为两个后端和前端。前端是用户如何与我们的应用程序、按钮、用户看到的文本等进行交互。这将是我们使用苗条。后端的工作是处理用户和前端之间的交互，它处理数据，在我们的例子中，它是与我们的推荐模型交互的人。举个例子，我们可以使用自动售货机，前端是你选择产品的按钮，投币口，以及告诉你已经加了多少钱的屏幕。后端是数钱的系统，是给你产品的马达，是计算你的零钱的系统。</p><h1 id="d562" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们还需要一个数据库</h1><p id="cc09" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">因此，为了保存我们的数据和其他东西，我们将使用MongoDB，因为我想使用基于文档的数据库引擎。要安装数据库，您可以使用下面的<a class="ae jd" href="https://docs.mongodb.com/manual/installation/#mongodb-community-edition-installation-tutorials" rel="noopener ugc nofollow" target="_blank">教程</a>，但这不是必需的，因为我们将使用Docker镜像来简化事情。如果你要在没有Docker的情况下测试系统，你只需要安装MongoDB。您可以随意修改本教程的代码，以使用您喜欢的任何数据库引擎。</p><h1 id="5200" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">让我们创建一个REST API</h1><p id="e700" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们开始为我们的后端创建一个虚拟环境。为此，我们将使用virtualenv(查看这个<a class="ae jd" href="https://help.dreamhost.com/hc/en-us/articles/115000695551-Installing-and-using-virtualenv-with-Python-3" rel="noopener ugc nofollow" target="_blank">教程</a>关于什么是以及如何使用python中的虚拟环境)。以下是该脚本的依赖项:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="cc67" class="kq jf hi km b fi kr ks l kt ku">fastapi[all]<br/>pymongo<br/>pandas<br/>requests<br/>uvicorn</span></pre><p id="9bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以将它们保存在一个名为<code class="du kv kw kx km b">requirements.txt</code>的文件中，并使用命令<code class="du kv kw kx km b">pip install -r requirements.txt</code>，或者您可以单独安装每个依赖项。</p><p id="dff7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从将应用程序连接到MongoDB数据库开始。既然我们要用Docker把我们不同的系统合并在一起，那么当你运行脚本的时候，会有一些东西不能工作，这是可以的。为了测试，有注释的参数，您可以取消注释并注释同名的参数。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7fc9" class="kq jf hi km b fi kr ks l kt ku">from fastapi import FastAPI, BackgroundTasks, File, UploadFile<br/>from fastapi.middleware.cors import CORSMiddleware<br/>from pymongo import MongoClient<br/>import pandas as pd<br/>import json<br/>import uvicorn<br/>import uuid<br/>from bson import json_util<br/>from typing import List<br/>import requests<br/>import numpy as np<br/>import os<br/>import time<br/># MONGO_HOST = "localhost"<br/>MONGO_HOST = os.getenv("MONGOHOST")<br/># TF_SERVING = "localhost"<br/>TF_SERVING = os.getenv("TF_SERVING_HOST")</span><span id="c934" class="kq jf hi km b fi ky ks l kt ku">mongo_client = MongoClient(MONGO_HOST, 27017)<br/>db = mongo_client["MovieRecommenderDB"]<br/>movie_col = db["movies"]<br/>user_col = db["user"]<br/>status_col = db["status"]<br/>ratings_col = db["ratings"]<br/>movie_encoded_col = db["movieEncoding"]</span></pre><p id="4a59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">忽略导入，我们只是连接到我们的MongoDB实例，选择名为<code class="du kv kw kx km b">MovieRecommenderDB</code>的数据库和我们的集合。如果您以前没有实例化过您的数据库或集合，不要担心MongoDB会处理好的。</p><p id="aeaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们开始创建FastAPI应用程序。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6562" class="kq jf hi km b fi kr ks l kt ku">app = FastAPI()</span><span id="9f37" class="kq jf hi km b fi ky ks l kt ku">origins = [<br/>    "*"<br/>]</span><span id="8ab2" class="kq jf hi km b fi ky ks l kt ku">app.add_middleware(<br/>    CORSMiddleware,<br/>    allow_origins=origins,<br/>    allow_credentials=True,<br/>    allow_methods=["*"],<br/>    allow_headers=["*"],<br/>)</span></pre><p id="59fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这几行中，我们有很多东西要解开。首先，<code class="du kv kw kx km b">app</code>是FastAPI实例，这是创建我们的API所需的最少实例。下面几行是为了让我们的前端与后端进行通信，要了解更多关于CORS的信息，你可以阅读<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">这里</a>和/或<a class="ae jd" href="https://fastapi.tiangolo.com/tutorial/cors/?h=+cors" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="3785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设数据库将使用我们的API进行更新，因此让我们创建逻辑来实现这一点。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3ad9" class="kq jf hi km b fi kr ks l kt ku">def get_number_of(collection):<br/>    num_of_movies = collection.find({}).count()<br/>    return num_of_movies</span><span id="b019" class="kq jf hi km b fi ky ks l kt ku">def save_to_db(csv_file, file_size, jobId, collection):<br/>    _index = get_number_of(collection)<br/>    csv_file.file.seek(0)<br/>    for i, l in enumerate(csv_file.file):<br/>        pass<br/>    csv_file.file.seek(0)<br/>    headers = csv_file.file.readline().decode().replace(";\\n", "").split(";")<br/>    for j, l in enumerate(csv_file.file):<br/>        line = l.decode()<br/>        line = line.replace(";\\n", "")<br/>        row_elem = line.split(";")<br/>        if len(row_elem) &gt; len(headers):<br/>            job_doc = {"jobId": jobId,<br/>                "status": "Error",<br/>                "percentage": int((j/i)*100),<br/>                "reason": f"Ilegal Character in line {j}"}<br/>            status_col.update_one({"jobId": jobId}, {"$set": job_doc})<br/>        else:<br/>            doc = {}<br/>            for e in range(len(row_elem)):<br/>                doc[headers[e]] = row_elem[e]<br/>            doc["index"] = _index + j<br/>            if collection.find_one(doc) is None: <br/>                collection.insert_one(doc)<br/>            else:<br/>                pass<br/>            status_col.update_one({"jobId": jobId}, {"$set": {"percentage": int((j/i)*100)}})<br/>    status_col.update_one({"jobId": jobId}, {"$set": {"percentage": 100, "status": "complete", "fileName": csv_file.filename, "fileSize": file_size, "numOfRows": i}})<br/>            <br/>def make_movie_encoding():<br/>    unique_movies = ratings_col.distinct("movieId")<br/>    movie_encoder = {x: i for i, x in enumerate(unique_movies)}<br/>    for key, item in movie_encoder.items():<br/>        doc = {"movieId": key, "index": item}<br/>        movie_encoded_col.insert_one(doc)</span><span id="0917" class="kq jf hi km b fi ky ks l kt ku">def save_ratings_to_db(csv_file, file_size, jobId):<br/>    save_to_db(csv_file, file_size, jobId, ratings_col)<br/>    make_movie_encoding()</span><span id="da42" class="kq jf hi km b fi ky ks l kt ku">@app.get("/status/{jobId}")<br/>def get_status_bulk_update(jobId: str):<br/>    job_doc = status_col.find_one({"jobId": jobId}, {'_id': False})<br/>    job_doc = json.loads(json_util.dumps(job_doc))<br/>    return job_doc</span><span id="2af4" class="kq jf hi km b fi ky ks l kt ku">def insert_status(doc):<br/>    status_col.insert_one(json.loads(json.dumps(doc)))</span><span id="a751" class="kq jf hi km b fi ky ks l kt ku">@app.post("/movies/bulk_update")<br/>def bulk_update_movie_database(background_task: BackgroundTasks, csv_file: UploadFile = File(...)):<br/>    jobId = str(uuid.uuid4())<br/>    csv_file.file.seek(0, 2)<br/>    file_size = csv_file.file.tell()/1000<br/>    job_doc = {"jobId": jobId,<br/>                "status": "inProgress",<br/>                "percentage": 0}<br/>    insert_status(job_doc)<br/>    background_task.add_task(save_to_db, csv_file, file_size, jobId, movie_col)</span><span id="edb3" class="kq jf hi km b fi ky ks l kt ku">    return {"filename": csv_file.filename,<br/>            "file_size": file_size,<br/>            "job": job_doc}</span><span id="19e2" class="kq jf hi km b fi ky ks l kt ku">@app.post("/ratings/bulk_update")<br/>def bulk_update_rating_database(background_task: BackgroundTasks, csv_file: UploadFile = File(...)):<br/>    jobId = str(uuid.uuid4())<br/>    csv_file.file.seek(0, 2)<br/>    file_size = csv_file.file.tell()/1000<br/>    job_doc = {"jobId": jobId,<br/>                "status": "inProgress",<br/>                "percentage": 0}<br/>    insert_status(job_doc)<br/>    background_task.add_task(save_ratings_to_db, csv_file, file_size, jobId)</span><span id="983d" class="kq jf hi km b fi ky ks l kt ku">    return {"filename": csv_file.filename,<br/>            "file_size": file_size,<br/>            "job": job_doc}</span></pre><p id="6de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这段代码中，我们将从函数<code class="du kv kw kx km b">bulk_update_rating_database</code>、<code class="du kv kw kx km b">bulk_update_movie_database</code>和<code class="du kv kw kx km b">get_status_bulk_update</code>开始。如您所见，在所有这些函数之上，您可以找到一个python装饰器<code class="du kv kw kx km b">@app.get</code>或<code class="du kv kw kx km b">@app.post</code>。这些装饰器允许我们创建URL路径或端点。端点不能是许多端点中的一个，但是大多数时候你使用四个:获取、发布、更新和删除。对于数据管道，我们使用POST用新的收视率或新的电影更新我们的数据库。我们使用GET方法来检查任务的状态</p><p id="33c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">FastAPI的一个很棒的特性就是所谓的BackgroundTasks。您可以告诉FastAPI发送一些工作，比如本例中的数据预处理，在后台运行，并为您的用户提供一种检查任务状态的方法。</p><p id="0ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们开始调用我们的模型来提出建议。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8a06" class="kq jf hi km b fi kr ks l kt ku">def find_movies_by_ids(id_list):<br/>    title_list = []<br/>    for id in id_list:<br/>        movie_title = movie_col.find_one({"movieId": str(id)})<br/>        if movie_title is not None:<br/>            title_list.append(movie_title["title"])<br/>        else:<br/>            pass<br/>    return title_list</span><span id="44d8" class="kq jf hi km b fi ky ks l kt ku">def get_recomendation(movie_ids):<br/>    movie_array = np.hstack(([[0]]*len(movie_ids), movie_ids))<br/>    body = {"instances": movie_array.tolist()}<br/>    url = f"http://{TF_SERVING}:8501/v1/models/movie_model:predict"<br/>    response = requests.request("POST", url, data=json.dumps(body))<br/>    aux = response.json()<br/>    return aux</span><span id="02f5" class="kq jf hi km b fi ky ks l kt ku">def get_movie_index(movieIds):<br/>    movie_indexs = []<br/>    for movie in movieIds:<br/>        movie_doc = movie_col.find_one({"movieId": str(movie)})<br/>        if movie_doc is not None:<br/>            movie_indexs.append([movie_doc["index"]])<br/>        else:<br/>            pass</span><span id="a73e" class="kq jf hi km b fi ky ks l kt ku">    return movie_indexs</span><span id="95cd" class="kq jf hi km b fi ky ks l kt ku">def encode_movieIds(movieIds):<br/>    encoded_movies = []</span><span id="731d" class="kq jf hi km b fi ky ks l kt ku">    for movie in movieIds:<br/>        doc = movie_encoded_col.find_one({"movieId": str(movie)})<br/>        if doc is not None:<br/>            encoded_movies.append([doc["index"]])<br/>        else:<br/>            pass<br/>        <br/>    return encoded_movies</span><span id="07b4" class="kq jf hi km b fi ky ks l kt ku">def find_movies_not_watched(movieIndexs):<br/>    indexs_to_watch = []<br/>    movies_to_watch = movie_col.find({"$nor": [{"movieId": {"$in": movieIndexs}}]})<br/>    indexs_to_watch = [int(x["movieId"]) for x in movies_to_watch]<br/>    return indexs_to_watch</span><span id="b76b" class="kq jf hi km b fi ky ks l kt ku">def clean_up_recommendations(recommendation_scores, top_indexes):<br/>    recommendation_body = []<br/>    for index in top_indexes:<br/>        movieId = movie_encoded_col.find_one({"index": int(index)}, {'_id': False})["movieId"]<br/>        movieDoc = movie_col.find_one({"movieId": movieId}, {'_id': False})<br/>        movieScore = recommendation_scores[index]<br/>        body = {<br/>            "title": movieDoc["title"],<br/>            "genre": movieDoc["genres"],<br/>            "movieScore": movieScore[0]<br/>        }<br/>        recommendation_body.append(body)<br/>    return recommendation_body</span><span id="e688" class="kq jf hi km b fi ky ks l kt ku">def generate_recommendations(movieIds, jobId):<br/>    start = time.time()<br/>    movieIds = [str(x) for x in movieIds]<br/>    still_to_watch_indxs = find_movies_not_watched(movieIds)<br/>    encoded_movies = encode_movieIds(still_to_watch_indxs)<br/>    recommendation = get_recomendation(encoded_movies)<br/>    recomender_scores = np.array(recommendation["predictions"]).flatten()<br/>    top_recommendations_indx  = np.array(recomender_scores).argsort()[-10:][::-1]<br/>    recommendations = clean_up_recommendations(recommendation["predictions"], top_recommendations_indx)<br/>    inputMovieTitles = find_movies_by_ids(movieIds)<br/>    end = time.time()<br/>    timeTaken = end-start<br/>    status_col.update_one({"jobId": jobId}, {"$set": {"status": "complete", "input": inputMovieTitles, "recommendation": recommendations, "timeTaken": timeTaken}})</span><span id="0054" class="kq jf hi km b fi ky ks l kt ku">@app.post("/movie/make_recom")<br/>def make_recomendation(movies: List, background_task: BackgroundTasks):<br/>    jobId = str(uuid.uuid4())<br/>    job_doc = {"jobId": jobId,<br/>                "status": "inProgress"<br/>                }<br/>    insert_status(job_doc)<br/>    background_task.add_task(generate_recommendations, movies, jobId)<br/>    <br/>    return job_doc</span><span id="2026" class="kq jf hi km b fi ky ks l kt ku">@app.get("/autocomplete")<br/>def get_autocomplete_movies():<br/>    movie_all = movie_col.find()<br/>    data = {}<br/>    for doc in movie_all:<br/>        data[doc["title"]] = doc["movieId"]<br/>    return data</span><span id="8c34" class="kq jf hi km b fi ky ks l kt ku">if __name__ == "__main__":<br/>    uvicorn.run("main:app", host="127.0.0.1", port=8000, log_level="info")</span></pre><p id="068a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些功能的要点或多或少很简单。它首先接收一个电影id列表，然后我们过滤掉所有不在这个列表中的电影。然后，我们使用对Tensorflow服务服务器的HTTP请求来调用模型。我们得到一个概率列表，我们得到概率最高的10个指数。最后，我们将这些索引转换回电影，并使用我们的状态端点返回给用户。</p><h1 id="0698" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">这个怎么测试？</h1><p id="3e12" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">FastAPI最棒的一点是使用Swagger的自动文档。你可以在你的电脑上运行这个脚本，在网络浏览器中点击下面的地址:<code class="du kv kw kx km b"><a class="ae jd" href="http://localhost:8000/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/docs</a></code>，你应该会看到类似这样的内容:</p><figure class="kh ki kj kk fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kz"><img src="../Images/a4d7b659751f8ecbb1ba93bcc3290b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REMRldQDsUDqVo2G_FgDeA.png"/></div></div></figure><p id="bf9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以尝试您的端点，有些可能无法工作，因为外部依赖，如MongoDB或Tensorflow服务。不过不要担心，因为在本教程的Docker部分，我们将把所有的东西连接在一起。</p></div></div>    
</body>
</html>