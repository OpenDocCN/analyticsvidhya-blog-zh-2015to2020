<html>
<head>
<title>Graph Algorithms — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形算法—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/graph-algorithms-1-5d80d022019?source=collection_archive---------10-----------------------#2020-04-01">https://medium.com/analytics-vidhya/graph-algorithms-1-5d80d022019?source=collection_archive---------10-----------------------#2020-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7fe962cf4c86fac6046bb7f994dedd07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eAPEun-1y0s55soL.jpg"/></div></div></figure><p id="9fcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di"> F </span>首先，感谢Mosh令人难以置信的课程——<a class="ae jx" href="https://codewithmosh.com/courses" rel="noopener ugc nofollow" target="_blank">终极数据结构&amp;算法</a>。我从他的课程中学到了很多，这篇文章是我对他的课程的图算法部分的笔记。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="87f0" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">介绍</h1><p id="6c2e" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">图形可以表示连接的对象。在现实世界场景中，它可能是一个社交网络，代表人们的关系。当你想描述一堆物体之间的关系时，尽量用图！</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es li"><img src="../Images/b15ea1b8d6a4731d52c952877c3c7440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*a5qvLSwYhCzJNa5c.jpg"/></div></figure><h2 id="ed86" class="ln kg hi bd kh lo lp lq kl lr ls lt kp jb lu lv kt jf lw lx kx jj ly lz lb ma bi translated"><strong class="ak">组件，邻居</strong></h2><p id="9340" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">图由<strong class="is hj">节点/顶点</strong>和<strong class="is hj">边</strong>组成。如果两个节点直接相连，则它们是<strong class="is hj">邻居/相邻</strong>。在这个图中，节点代表不同的人，边显示人与人之间的关系。每对节点都是相邻的。我们把这种图叫做<strong class="is hj">团</strong>。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/aa92481c1b296458c82ec77fccb1ecb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SvhtSE3BCEA52jFPwa6bw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">团，间接图</figcaption></figure><p id="9708" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相比之下，在下图中，John与Sam没有直接联系。因此，约翰和萨姆不是邻居。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/d21c52f9b91e26088d38680ca2074b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9PK_OSRA8bo0R1ufvm1TA.png"/></div></div></figure><h2 id="18b8" class="ln kg hi bd kh lo lp lq kl lr ls lt kp jb lu lv kt jf lw lx kx jj ly lz lb ma bi translated">有向和无向图</h2><p id="0d38" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">上面我们关注的是无向图，这意味着边没有方向。什么是有向图？想想推特吧！我是斯蒂芬·库里的粉丝，我在推特上关注他，但他不关注我。因此，我和库里的关系需要一个方向。那就是<strong class="is hj">直接图</strong>。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/0f1411ff647e397e2565bcae737c2165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSZiWjmjpDE7JVa0G-j4uw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">直接图形</figcaption></figure><h2 id="398f" class="ln kg hi bd kh lo lp lq kl lr ls lt kp jb lu lv kt jf lw lx kx jj ly lz lb ma bi translated">加权和未加权图</h2><p id="68f7" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">边也可以具有表示关系有多强的权重。例如，在社交网络中，如果约翰和玛丽有许多交互，他们的关系将具有更高的权重。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/dcc294cea56e4c1ceca1ed85d513df2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVt8OvoNVIYUGkDGB9x9UQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">加权图</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="e08b" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">表现</h1><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/565aa7c9264a11ca5ceccaa2fc0750f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2BQteD7C_Ty1T7Cz.png"/></div></div></figure><p id="c6a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有几种方法来表示一个图。这里我们要讲的是<strong class="is hj">邻接矩阵</strong>和<strong class="is hj">邻接表</strong>。</p><h2 id="2182" class="ln kg hi bd kh lo lp lq kl lr ls lt kp jb lu lv kt jf lw lx kx jj ly lz lb ma bi translated">邻接矩阵</h2><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/fadf5166e89db05d344c932b918f69a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G3heKltsTZhyatLx.png"/></div></div></figure><p id="ab52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果两个节点相连，我们将交集标记为1或true否则，我们将其标记为0或false。我们可以使用二维数组轻松实现这种方法。缺点是我们需要为这个矩阵分配额外的空间。如果我们有n个节点，空间复杂度是O(V)。(我们在处理图的时候用V代替n。v是指节点的数量)</p><p id="8e6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加一个新节点是O(V ),因为我们需要创建一个多一行多一列的新数组，并将所有现有的项复制到新数组中。</p><p id="fa1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，删除一个节点是O(V ),因为我们需要分配一个新的更小的矩阵，并复制周围的项目。</p><p id="bce8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">加个边怎么样？例如，我们想在约翰和玛丽之间添加一个关系，第一步是找到(约翰，玛丽)的索引。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/fa05b7704d33f37d4b0a6a59e75985f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usKzqtcIfF2pA9dW54AdDQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">哈希表</figcaption></figure><p id="71fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用一个<strong class="is hj">散列表</strong>来存储索引。因此，添加新的边只需要O(1)运算。要删除一个边，通过相同的过程，它也是O(1)。</p><p id="1c96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询边意味着我们要检查两个节点是否连接。我们要做的是找到指数，寻找值。这是一个O(1)运算。</p><p id="6bbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">寻找给定节点的所有邻接是一个O(V)运算。例如，我们想找到鲍勃的邻居。首先求Bob的索引，那就是O(1)。然后我们需要查看该行/列中的每一项。一行/一列中有多少项？五.项目。</p><h2 id="50e9" class="ln kg hi bd kh lo lp lq kl lr ls lt kp jb lu lv kt jf lw lx kx jj ly lz lb ma bi translated"><strong class="ak">邻接表</strong></h2><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/09ffa8d3913dae0dec8feacde58c83af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yT5AJj9m4Xs2tZ8P"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">邻接表</figcaption></figure><p id="acac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">邻接表是链接列表的一个<strong class="is hj">数组</strong>。这个数组中的每一项都是一个<strong class="is hj">链表</strong>。并且每个列表包含特定节点的邻居。</p><p id="5d94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法更加节省空间，因为我们只存储存在的边。空间复杂度为O(V + E)。e指总边数。在最坏的情况下，每个节点都与其他节点相连。我们称这种图为稠密图。总边数为E = V * (V-1)，空间复杂度为O(V -1+V ) = O(V)。(我们只关心比其他部分增长更快的V部分)</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/a2bda28745024d42018bd2383fa9d6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgco24giT1rMOYyl3yfXxQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">稠密图</figcaption></figure><p id="1db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加一个节点需要O(1)运算，因为我们只需要在邻接表中添加一个新项。(这里，我们可以使用一个能够自动增加长度的数组列表)</p><p id="9bd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要删除一个节点，首先我们需要从邻接表中删除该元素，并确保没有其他节点链接到该节点，这意味着我们需要遍历列表，并从每个LinkedList中删除目标节点。</p><p id="af0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，根据下图，我们有一个邻接表，我们想删除节点4。首先，我们需要遍历数组并删除节点4。那是一个O(V)。在每次迭代中，我们需要从每个LinkedList中删除目标节点。移除LinkedList中的项目需要O(n)次运算，但是n的确切值因每个LinkedList而异。我们图中的每条边对应于LinkedList中的一个元素。总的来说，我们有E条边，所以在我们的五个链表中有E个元素。所以时间复杂度是O(V + E)。在最坏的情况下，E = V*(V-1)，时间复杂度为O(V)。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/232a2d10900ac441bf27a2c1b8fc47bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLJvT5w8fLuc9fQ8Zgqn5Q.jpeg"/></div></div></figure><p id="c7f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:关键是，图中的边数(E)= linked list中的项目总数。</strong></p><p id="a063" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加一条边的运行时间为O(K)。例如，我们想添加一个从B到a的关系，首先，我们需要找到B的索引，然后我们需要迭代LinkedList以确保这个关系当前不存在。最后，我们可以添加一个新的关系。作为HashMap的结果，第一步只需要O(1)。在LinkedList的末尾添加一个新项目需要O(1)。第二步采用O(K)迭代LinkedList。(K指给定节点的边数)。所以加一条边是O(K)。最坏的情况下，又是一个稠密图，K = V-1，时间复杂度为O(V)。</p><p id="52ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">温馨提示:如果你处理的是</strong> <a class="ae jx" href="https://en.wikipedia.org/wiki/Multigraph" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">多图</strong> </a> <strong class="is hj">，这意味着两个节点可以通过不同的边连接。那我们就不需要第二步了。因此，在多重图中添加一条边的时间复杂度为O(1)。</strong></p><p id="15fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">移除边与添加边非常相似。找到索引O(1) -&gt;迭代LinkedList找到目标边O(K) -&gt;移除它O(1)。还是那句话，最坏的情况下是O(V)。</p><p id="302b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询边和在邻接表中寻找邻居都是O(K)运算。我们需要遍历链表来查看目标边是否存在(或者找到所有的邻居)，这在最坏的情况下需要O(K)和O(V)。</p><h2 id="cec2" class="ln kg hi bd kh lo lp lq kl lr ls lt kp jb lu lv kt jf lw lx kx jj ly lz lb ma bi translated">比较</h2><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/e40f0f55f3b37a249be1d1e253b34200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDFBCIvMUBsz243VimOeRQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">平均情景</figcaption></figure><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/3c243c7a719313c8d8f6c09b3402e751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyMCTrYbPX61Vq37SvvGDQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">最坏情况(密集图)</figcaption></figure><p id="4946" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总的来说，如果你处理的是密集图，使用矩阵更好；否则，使用列表会更有效。</p><h1 id="fab8" class="kf kg hi bd kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky ms la lb lc bi translated">使用Java创建图表</h1><p id="7d3a" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">让我们用Java创建一个graph类。Mosh使用两个HashMaps来创建图表，因为它更面向对象。我还尝试使用Array、LinkedList和HashMap来创建图表。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="71f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我想解释一下这两个散列表是如何工作的。第一个HashMap节点帮助我们封装节点对象。用户只需要传递一个字符串作为参数。第二个散列表是我们的邻接表。这里我们使用HashMap代替array进行快速查找。</p><p id="80d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们测试我们的程序！</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/0dd7a4713b229ed9a790bd69ef449d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*1UFNt_qnFK6qkEBb.png"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">直接图形示例</figcaption></figure><p id="dfd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据示例图，我们将添加节点和边。</p><pre class="lj lk ll lm fd mw mx my mz aw na bi"><span id="21b2" class="ln kg hi mx b fi nb nc l nd ne">public class Main {<br/><br/>    public static void main(String[] args) {<br/>        Graph g = new Graph();<br/>        g.addNode("A");<br/>        g.addNode("B");<br/>        g.addNode("C");<br/>        g.addNode("D");<br/>        g.addNode("E");<br/>        g.addNode("F");<br/>        g.addEdge("A","B");<br/>        g.addEdge("D","B");<br/>        g.addEdge("B","C");<br/>        g.addEdge("C","E");<br/>        g.addEdge("E","D");<br/>        g.addEdge("E","F");<br/>        g.print();<br/>    }<br/>}</span></pre><p id="aef6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">程序输出:</p><p id="27de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a连接到[B] <br/> E连接到[D，F] <br/> B连接到[C] <br/> C连接到[E] <br/> D连接到[B]</p><pre class="lj lk ll lm fd mw mx my mz aw na bi"><span id="0b34" class="ln kg hi mx b fi nb nc l nd ne">g.removeNode("F");<br/>g.removeEdge("A","B");<br/>g.print();</span></pre><p id="4b4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">程序输出:</p><p id="ee6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">E连接到[D] <br/> B连接到[C] <br/> C连接到[E] <br/> D连接到[B]</p><p id="6a09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我还使用HashMap、LinkedList和array实现了graph类的相同功能。这两种方法的时间复杂度完全相同。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mt mu l"/></div></figure><pre class="lj lk ll lm fd mw mx my mz aw na bi"><span id="5ce1" class="ln kg hi mx b fi nb nc l nd ne">public class Main {<br/><br/>    public static void main(String[] args) {<br/>        Graph2 g = new Graph2();<br/>        g.addNode("A");<br/>        g.addNode("B");<br/>        g.addNode("C");<br/>        g.addNode("D");<br/>        g.addNode("E");<br/>        g.addNode("F");<br/>        g.addEdge("A","B");<br/>        g.addEdge("D","B");<br/>        g.addEdge("B","C");<br/>        g.addEdge("C","E");<br/>        g.addEdge("E","D");<br/>        g.addEdge("E","F");<br/>        g.removeEdge("A","B");<br/>        g.removeNode("F");<br/>        g.print();<br/>    }<br/>}</span></pre><p id="4fbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">程序输出:</p><p id="d3bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a连接到[] <br/> B连接到[C] <br/> C连接到[E] <br/> D连接到[B] <br/> E连接到[D]</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><blockquote class="nf"><p id="6901" class="ng nh hi bd ni nj nk nl nm nn no jn dx translated">感谢您的阅读！学习永无止境。</p></blockquote><p id="ea46" class="pw-post-body-paragraph iq ir hi is b it np iv iw ix nq iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated"><strong class="is hj"> <em class="nu">接下来:</em> </strong> <a class="ae jx" rel="noopener" href="/@allenhuang1996/graph-algorithms-part-2-3a42512f1745"> <strong class="is hj"> <em class="nu">图形算法(二)</em> </strong> </a></p></div></div>    
</body>
</html>