<html>
<head>
<title>Black–Litterman Model for Asset Allocation for Top 20 Indian Companies by Market Capitalization and Backtesting — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">black–little man按市值和回溯测试对前20名印度公司进行资产配置的模型—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/black-litterman-model-for-asset-allocation-for-top-20-indian-companies-by-market-capitalization-e22e1450dc39?source=collection_archive---------14-----------------------#2020-06-26">https://medium.com/analytics-vidhya/black-litterman-model-for-asset-allocation-for-top-20-indian-companies-by-market-capitalization-e22e1450dc39?source=collection_archive---------14-----------------------#2020-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者:萨比尔·贾纳</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="2b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将通过一步一步的过程来回溯测试从<a class="ae jk" rel="noopener" href="/@sabirh.jana/black-litterman-model-for-asset-allocation-for-top-20-indian-companies-by-market-capitalization-c9fcbd362d72">Black-litter man资产配置模型中创建的投资组合，通过市值和回溯测试对前20名印度公司进行资产配置——第1部分</a>。在我们进入下一步之前，让我们快速回顾一下到目前为止的总结。作为第一步，我们收集了20家印度公司的市值和每日定价数据。接下来，在<code class="du jl jm jn jo b"><a class="ae jk" href="https://pyportfolioopt.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">PyPortfolioOpt</a> </code> (python开源库)的帮助下，我们计算了市场隐含回报率。然后，我们计算了回报的后验估计和协方差矩阵，还考虑了分析师的观点和对这些观点的信心。使用收益的后验估计和协方差矩阵作为输入，我们运行了有效的前沿优化器，以获得最小波动性的最优权重和任何单只股票不超过10%的权重约束。</p><p id="b64d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了回溯测试这个投资组合，我想到了使用两个强大的python库，<code class="du jl jm jn jo b"><a class="ae jk" href="https://www.zipline.io/" rel="noopener ugc nofollow" target="_blank">zipline</a></code>和<code class="du jl jm jn jo b"><a class="ae jk" href="https://www.backtrader.com/" rel="noopener ugc nofollow" target="_blank">Backtrader</a></code>。在我看来，两者各有利弊，但我决定支持反向交易。有了Backtrader，您将更容易理解本文并在您的机器上运行代码，而不会沉迷于zipline的定制捆绑包复杂性。然而，如果你想使用zipline，你可以参考我的文章<a class="ae jk" rel="noopener" href="/@sabirh.jana/how-to-import-indian-equities-data-to-zipline-on-your-local-machine-3b8587aaf112">如何将印度股票数据导入你本地机器上的zipline？因为zipline将要求您创建一个自定义包来对其进行回溯测试。您可以在我的</a><a class="ae jk" href="https://github.com/sabirjana/blog/tree/master/Black%E2%80%93Litterman" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Github</strong></a><strong class="ih hj"/>资源库中找到本文的代码和数据。</p><p id="c820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的方法如下:</p><ol class=""><li id="4919" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">收集数据。</li><li id="4090" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在Backtrader中定义我们的回溯测试策略。</li><li id="5053" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">提取性能统计数据，与基准进行比较和对比。</li></ol></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="6abd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">收集数据</strong></p><p id="b223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要我们的投资组合权重。在本文的第一部分，我们将这些信息保存为csv文件，因此我们将从csv文件中读取这些信息。除此之外，我们还需要2010年1月1日至2020年5月29日这20家券商的OHLCV数据集。您可以从您选择的数据源获取该数据集，但是作为一个开端，我为该数据集提供了一个csv文件。</p><p id="bbda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们动手操作代码并执行以下任务:</p><ol class=""><li id="9dd5" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">从<code class="du jl jm jn jo b">wt_min_vola_wts.csv </code>中读取代码和相应的重量，并绘制出来以便快速验证。</li><li id="3fd9" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">将回溯测试日期定义为2010年1月1日至2020年5月29日。</li><li id="5ccc" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">读取<code class="du jl jm jn jo b">prices_all.csv</code>文件并创建一个带有OHLCV列的堆栈数据帧。</li><li id="e06b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">创建一个列表的股票和相应的权重元组，我们将需要在稍后阶段。</li></ol><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="b43b" class="kl km hi jo b fi kn ko l kp kq"># necessary imports<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import datetime<br/>import yfinance as yf<br/>import pandas_datareader.data as web<br/>import pyfolio as pf<br/>import backtrader as bt<br/>idx = pd.IndexSlice</span><span id="c513" class="kl km hi jo b fi kr ko l kp kq">%matplotlib inline<br/>%config InlineBackend.figure_format = ‘retina’</span><span id="2f1b" class="kl km hi jo b fi kr ko l kp kq"># Read our 20 tickers weights<br/>wt_min_vola = pd.read_csv('data/wt_min_vola_wts.csv',  index_col=[0])<br/>print(wt_min_vola)</span><span id="a0a6" class="kl km hi jo b fi kr ko l kp kq"># plot the weights<br/>wt_min_vola.plot.bar(figsize=(14,6), <br/>                    title = 'Asset Allocation Based on BL with Confidence Matrix', grid=True,legend=False);<br/>plt.ylabel('Percentage')<br/>plt.savefig('images/chart6', dpi=300)</span><span id="86a6" class="kl km hi jo b fi kr ko l kp kq"># date range for the backtesting<br/>fromdate=datetime.datetime(2010, 1, 1)<br/>todate=datetime.datetime(2020, 5, 29)</span><span id="576e" class="kl km hi jo b fi kr ko l kp kq"># Read daily prices from csv<br/>prices = pd.read_csv('data/prices_all.csv', index_col=['ticker','date'], parse_dates=True)<br/>prices.head(2)</span><span id="3fa6" class="kl km hi jo b fi kr ko l kp kq">prices.info()</span><span id="4f70" class="kl km hi jo b fi kr ko l kp kq"># create a tuple list of ticker and weight<br/>assets_param = [(ind, wt_min_vola.loc[ind][0]) for ind in wt_min_vola.index]<br/>print(assets_param)</span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ks"><img src="../Images/13d4083ea53af2bcedb1b352910aa422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdQDdf99WdjSGwVvNM5tlw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">基于置信矩阵的商业智能资产配置</figcaption></figure><p id="29e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个多元化的投资组合，包括市值排名前20位的印度公司。如果你检查第一部分的有效边界的输出，预期年回报率是8%左右，年波动率是9.8%，夏普比率是0.61。但是，我们需要理解，这种性能预期是在“买入并持有”的情况下，并不考虑回溯测试期间的任何再平衡。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="ab32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在Backtrader中定义我们的回溯测试策略</strong></p><p id="5458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的回溯测试策略如下:</p><ol class=""><li id="5e8d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">我们将从我们的20只股票和相应权重的500，000货币现金和股票宇宙开始。</li><li id="fa42" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">每个季度，我们都会重新平衡权重，并将其重置为初始值。</li><li id="6118" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">因为我们每个季度都在重新平衡，所以我计算了0.4%的交易费用</li></ol><p id="80d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们跳到代码:</p><ol class=""><li id="8052" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">在<code class="du jl jm jn jo b">Backtrader</code>中，我们的策略类需要继承<code class="du jl jm jn jo b">bt.Strategy</code>。它有输入参数<code class="du jl jm jn jo b">assets </code>和<code class="du jl jm jn jo b">rebalance_months</code> <em class="le">。</em>参数<code class="du jl jm jn jo b">assets</code>用于提供tickers和相应权重的元组列表。第二个参数<code class="du jl jm jn jo b">rebalance_month </code>用于提供重新平衡月份的列表。例如，一月在列表中用数字1表示。</li><li id="1348" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在<code class="du jl jm jn jo b">__init__</code>函数中，我们创建了一个股票和相应权重的字典，并附加了一个“rebalanced”标志。</li><li id="a411" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在<code class="du jl jm jn jo b">next </code>函数中，我们枚举所有20只股票，并检查当前月份是否在<code class="du jl jm jn jo b">rebalance_months</code>列表中，以及<code class="du jl jm jn jo b">‘rebalanced’</code>标志是否为‘False’。在这种情况下，我们将目标百分比排序，并将标志设置为“True”。</li><li id="8483" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果当前月份不在列表中，我们将<code class="du jl jm jn jo b">‘rebalanced’</code>标记保持为“假”。</li><li id="8855" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在<code class="du jl jm jn jo b">notify_order</code>函数中，我们检查订单是否完成。</li><li id="185b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果订单完成，我们用完成策略类的<code class="du jl jm jn jo b">notify_trade</code>函数通知交易。</li><li id="23ef" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">接下来，我们创建Backtrader背后的主要引擎<code class="du jl jm jn jo b">bt.Cerebro</code>的实例，并将起始现金设置为500，000，交易佣金设置为0.004 (0.4%)。</li><li id="0262" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">参数<code class="du jl jm jn jo b">set_checksubmit</code>被设置为“假”。这将确保订单不会被检查，看看我们是否能负担得起，然后再提交。</li><li id="5f51" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">下一步，我们编写一个循环，将这20只股票的回溯测试数据加载到内存中。</li><li id="8f1c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">现在，我们需要将策略添加到<code class="du jl jm jn jo b">cerebro </code>中，输入是我们在上一节中创建的股票和权重的元组列表。</li><li id="ea02" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们添加了回报和投资组合分析器，我们将使用它们来提取我们的策略的性能。</li><li id="94bf" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">最后，我们运行策略并在<code class="du jl jm jn jo b">results</code>变量中捕获输出。</li></ol><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="71f3" class="kl km hi jo b fi kn ko l kp kq"># define the strategy<br/>class Strategy(bt.Strategy):<br/># parameters for inputs    <br/>    params = dict(<br/>        assets = [],<br/>        rebalance_months = [1,3,6,9]<br/>    )<br/> <br/>    # initialize<br/>    def __init__(self):<br/>        # create a dictionary of ticker:{'rebalanced': False, 'target_percent': target%}<br/>        self.rebalance_dict = dict()<br/>        for i, d in enumerate(self.datas):<br/>            self.rebalance_dict[d] = dict()<br/>            self.rebalance_dict[d]['rebalanced'] = False<br/>            for asset in self.p.assets:<br/>                if asset[0] == d._name:<br/>                    self.rebalance_dict[d]['target_percent'] = asset[1]<br/> <br/>    def next(self):<br/>        # rebalance for the month in the list<br/>        for i, d in enumerate(self.datas):<br/>            dt = d.datetime.datetime()<br/>            dname = d._name<br/>            pos = self.getposition(d).size<br/> <br/>            if dt.month in self.p.rebalance_months and self.rebalance_dict[d]['rebalanced'] == False:<br/>                print('{} Sending Order: {} | Month {} | Rebalanced: {} | Pos: {}'.<br/>                      format(dt, dname, dt.month,<br/>                             self.rebalance_dict[d]['rebalanced'], pos ))<br/>            <br/>                self.order_target_percent(d, target=self.rebalance_dict[d]['target_percent']/100)<br/>                self.rebalance_dict[d]['rebalanced'] = True<br/> <br/>            # Reset the flage<br/>            if dt.month not in self.p.rebalance_months:<br/>                self.rebalance_dict[d]['rebalanced'] = False<br/>                <br/>    # notify the order if completed<br/>    def notify_order(self, order):<br/>        date = self.data.datetime.datetime().date()<br/> <br/>        if order.status == order.Completed:<br/>            print('{} &gt;&gt; Order Completed &gt;&gt; Stock: {},  Ref: {}, Size: {}, Price: {}'.<br/>                  format(date, order.data._name, order.ref, order.size,<br/>                         'NA' if not order.price else round(order.price,5)<br/>                        ))</span><span id="6f42" class="kl km hi jo b fi kr ko l kp kq"># notify the trade if completed        <br/>    def notify_trade(self, trade):<br/>        date = self.data.datetime.datetime().date()<br/>        if trade.isclosed:<br/>            print('{} &gt;&gt; Notify Trade &gt;&gt; Stock: {}, Close Price: {}, Profit, Gross {}, Net {}'.<br/>                  format(date, trade.data._name, trade.price, round(trade.pnl,2),round(trade.pnlcomm,2))<br/>                 )</span><span id="b55a" class="kl km hi jo b fi kr ko l kp kq"># starting cash<br/>startcash = 500000</span><span id="88a9" class="kl km hi jo b fi kr ko l kp kq"># 0.4% commission<br/>commission = 0.004</span><span id="6013" class="kl km hi jo b fi kr ko l kp kq">#Create an instance of cerebro<br/>cerebro = bt.Cerebro()</span><span id="a09f" class="kl km hi jo b fi kr ko l kp kq">cerebro.broker.setcash(startcash)</span><span id="6893" class="kl km hi jo b fi kr ko l kp kq"># orders will not be checked to see if you can afford it before submitting them<br/>cerebro.broker.set_checksubmit(False)</span><span id="e5e2" class="kl km hi jo b fi kr ko l kp kq">cerebro.broker.setcommission(commission=commission)</span><span id="1f2f" class="kl km hi jo b fi kr ko l kp kq">TICKERS = list(prices.index.get_level_values('ticker').unique())<br/>print(TICKERS)</span><span id="411b" class="kl km hi jo b fi kr ko l kp kq"># load the data<br/>for ticker, data in prices.groupby(level=0):<br/>    if ticker in TICKERS:<br/>        print(f"Adding ticker: {ticker}")<br/>        data = bt.feeds.PandasData(dataname=data.droplevel(level=0),<br/>                                   name=str(ticker),<br/>                                   fromdate=fromdate,<br/>                                   todate=todate,<br/>                                   plot=False)<br/>        cerebro.adddata(data)</span><span id="0b29" class="kl km hi jo b fi kr ko l kp kq">#Add our strategy<br/>cerebro.addstrategy(Strategy, assets=assets_param)</span><span id="a6e5" class="kl km hi jo b fi kr ko l kp kq"># add analyzers<br/>cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')<br/>cerebro.addanalyzer(bt.analyzers.TimeReturn, _name='time_return')<br/>cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')</span><span id="db42" class="kl km hi jo b fi kr ko l kp kq">print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())</span><span id="c26c" class="kl km hi jo b fi kr ko l kp kq"># Run the strategy. <br/>results = cerebro.run(stdstats=True, tradehistory=False)</span><span id="b332" class="kl km hi jo b fi kr ko l kp kq"># Print out the final result<br/>print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="1de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提取性能统计数据，与基准测试进行比较和对比</strong></p><p id="af42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，是时候看看在漫长的投资组合识别和后续回溯测试过程之后，我们做得有多好了。在本节中，我们将获得回溯测试结果，并将其与基准性能进行比较。我们将使用S&amp;P BSE-Sensex作为我们的基准。这是考虑到我们的20只股票都是大盘股。我们使用<code class="du jl jm jn jo b"><a class="ae jk" href="https://quantopian.github.io/pyfolio/" rel="noopener ugc nofollow" target="_blank">pyfolio</a></code> <a class="ae jk" href="https://quantopian.github.io/pyfolio/" rel="noopener ugc nofollow" target="_blank"> </a> Python库进行性能分析。</p><p id="2403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们对它进行如下编码:</p><ol class=""><li id="d924" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">从回溯测试<code class="du jl jm jn jo b">results </code>变量中提取投资组合所需的输入，包括回报、头寸和交易。</li><li id="c3a6" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">借助python库<code class="du jl jm jn jo b"><a class="ae jk" href="https://github.com/ranaroussi/yfinance" rel="noopener ugc nofollow" target="_blank">yfinance</a></code>下载基准S&amp;P BSE-Sensex每日定价数据，并将其转换为每日回报。我们需要确保使用正确的时区，否则<code class="du jl jm jn jo b">pyfolio </code>会抛出错误。避免任何前瞻偏差也很重要。我更喜欢将所有数据转换为UTC时区。</li><li id="7bb4" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">绘制策略和基准的性能图，以比较和对比结果。我更喜欢根据需要绘制单个参数，而不是使用<code class="du jl jm jn jo b">pyfolio.</code>中的cheatsheet选项。如果你是python新手，那么请使用代码进行绘制，不要投入太多时间和精力，因为随着时间的推移和经验的积累，你会慢慢明白这一点。</li></ol><p id="90f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来编码一下:</p><pre class="kd ke kf kg fd kh jo ki kj aw kk bi"><span id="bc41" class="kl km hi jo b fi kn ko l kp kq"># Extract inputs for pyfolio<br/>strat = results[0]<br/>pyfoliozer = strat.analyzers.getbyname(‘pyfolio’)</span><span id="4316" class="kl km hi jo b fi kr ko l kp kq"># Extract inputs for pyfolio<br/>returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items()<br/>returns.name = 'Strategy'<br/>returns.head(2)</span><span id="2e66" class="kl km hi jo b fi kr ko l kp kq"># Get the benchmark returns for comparison<br/>benchmark = '^BSESN' # S&amp;P BSE Sensex<br/>benchmark_rets= web.DataReader(benchmark, 'yahoo', start='2010-01-01',)['Adj Close'].pct_change().dropna()<br/>benchmark_rets.index = benchmark_rets.index.tz_localize('UTC') <br/>benchmark_rets = benchmark_rets.filter(returns.index)<br/>benchmark_rets.name = 'S&amp;P BSE-SENSEX'<br/>benchmark_rets.head(2)</span><span id="e2ba" class="kl km hi jo b fi kr ko l kp kq"># Get the benchmark prices for comparison<br/>benchmark = '^BSESN' # S&amp;P BSE Sensex<br/>benchmark_prices = web.DataReader(benchmark, 'yahoo', start='2010-01-01',)['Adj Close']<br/>benchmark_prices = benchmark_prices.asfreq('D', method='ffill')<br/>benchmark_prices.index = benchmark_prices.index.tz_localize('UTC')<br/>benchmark_prices = benchmark_prices.filter(returns.index)<br/>benchmark_prices.head(5)</span><span id="b346" class="kl km hi jo b fi kr ko l kp kq"># Rebase the benchmark prices for comparison<br/>benchmark_prices = (benchmark_prices/benchmark_prices.iloc[0]) * startcash<br/>benchmark_prices.head()</span><span id="7845" class="kl km hi jo b fi kr ko l kp kq">portfolio_value = returns.cumsum().apply(np.exp) * startcash</span><span id="8993" class="kl km hi jo b fi kr ko l kp kq"># Visulize the output<br/>fig, ax = plt.subplots(2, 1, sharex=True, figsize=[14, 8])</span><span id="0bdf" class="kl km hi jo b fi kr ko l kp kq"># portfolio value<br/>portfolio_value.plot(ax=ax[0], label='Strategy')<br/>benchmark_prices.plot(ax=ax[0], label='Benchmark - S&amp;P BSE-Sensex')<br/>ax[0].set_ylabel('Portfolio Value')<br/>ax[0].grid(True)<br/>ax[0].legend()</span><span id="94d7" class="kl km hi jo b fi kr ko l kp kq"># daily returns<br/>returns.plot(ax=ax[1], label='Strategy', alpha=0.5)<br/>benchmark_rets.plot(ax=ax[1], label='Benchmark - S&amp;P BSE-Sensex', alpha=0.5)<br/>ax[1].set_ylabel('Daily Returns')</span><span id="c93a" class="kl km hi jo b fi kr ko l kp kq">fig.suptitle('Black–Litterman Portfolio Allocation vs S&amp;P BSE-Sensex', fontsize=16)<br/>plt.grid(True)<br/>plt.legend()<br/>plt.show()<br/>fig.savefig('images/chart9', dpi=300)</span><span id="49ba" class="kl km hi jo b fi kr ko l kp kq">import seaborn as sns<br/>import warnings<br/>%matplotlib inline<br/>%config InlineBackend.figure_format = 'retina'<br/>warnings.filterwarnings('ignore')</span><span id="32ec" class="kl km hi jo b fi kr ko l kp kq"># get performance statistics for strategy<br/>pf.show_perf_stats(returns,)</span><span id="5b00" class="kl km hi jo b fi kr ko l kp kq"># get performance statistics for benchmark<br/>pf.show_perf_stats(benchmark_rets)</span><span id="e61c" class="kl km hi jo b fi kr ko l kp kq"># plot performance for strategy<br/>fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(14, 8),constrained_layout=True)<br/>axes = ax.flatten()</span><span id="da16" class="kl km hi jo b fi kr ko l kp kq">pf.plot_drawdown_periods(returns=returns, ax=axes[0])<br/>axes[0].grid(True)<br/>pf.plot_rolling_returns(returns=returns,<br/>                        factor_returns=benchmark_rets,<br/>                        ax=axes[1], title='Strategy vs BSE-SENSEX')<br/>axes[1].grid(True)<br/>pf.plot_drawdown_underwater(returns=returns, ax=axes[2])<br/>axes[2].grid(True)<br/>pf.plot_rolling_sharpe(returns=returns, ax=axes[3])<br/>axes[3].grid(True)<br/>fig.suptitle('BL Portfolio vs BSE-SENSEX - 1', fontsize=16, y=0.990)</span><span id="3459" class="kl km hi jo b fi kr ko l kp kq">plt.grid(True)<br/>plt.legend()<br/>plt.tight_layout()<br/>plt.savefig('images/chart7', dpi=300)</span><span id="c98f" class="kl km hi jo b fi kr ko l kp kq"># plot performance<br/>fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(16, 9),constrained_layout=True)<br/>axes = ax.flatten()</span><span id="2cd5" class="kl km hi jo b fi kr ko l kp kq">pf.plot_rolling_beta(returns=returns, factor_returns=benchmark_rets, ax=axes[0])<br/>axes[0].grid(True)</span><span id="526b" class="kl km hi jo b fi kr ko l kp kq">pf.plot_rolling_volatility(returns=returns, factor_returns=benchmark_rets,ax=axes[1])<br/>axes[1].grid(True)</span><span id="ee6f" class="kl km hi jo b fi kr ko l kp kq">pf.plot_annual_returns(returns=returns, ax=axes[2])<br/>axes[2].grid(True)</span><span id="b3b3" class="kl km hi jo b fi kr ko l kp kq">pf.plot_monthly_returns_heatmap(returns=returns, ax=axes[3],)<br/>fig.suptitle('BL Portfolio vs BSE-SENSEX - 2', fontsize=16, y=0.950)</span><span id="a0e7" class="kl km hi jo b fi kr ko l kp kq">plt.tight_layout()<br/>plt.savefig('images/chart8', dpi=300)</span></pre><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lf"><img src="../Images/9553a1db4f278f4a0eeaf49b6effec6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dc-Vgudkg9zu0FfLBiIAw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">布莱克-立特曼组合vs S&amp;P BSE-Sexsex</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div class="er es lg"><img src="../Images/a7fb46213db33514654bb07df11e33ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*E7wBCHXY1rfQYS4RubrmQA.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">战略vs S&amp;P BSE-Sensex性能</figcaption></figure><p id="a46e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图可以看出，我们做得很好，在一些关键参数上击败了基准，如年回报率、夏普比率、索提诺比率、稳定性、最大下降等。年波动率和日风险值略高于基准。我们在其他几个参数上表现不佳，比如非常高的峰度和负的回报率偏差。让我们看看这些参数和其他几个参数的性能图形表示。</p><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lf"><img src="../Images/336df8b494b968de385af5d0ec2e291f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03vyG9TOmoSAcriVR6v2GQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">商业智能组合与基准— 1</figcaption></figure><figure class="kd ke kf kg fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lh"><img src="../Images/8250e8f5670e6a24de401198ea51f5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogvRK91VutTyzoqF_t4XMw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">商业智能组合与基准— 2</figcaption></figure><p id="fd71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，该策略的累积回报远远超过基准。6个月滚动波动率符合基准，6个月和12个月滚动beta均小于1。然而，在6个月滚动夏普比率的高波动是令人担忧的。</p><p id="1212" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与S&amp;P BSE-Sensex相比，我们的总体战略表现非常好，这可能是一个巧合，因为我没有用科学的方法来定义我的观点和信心。它们是基于我的直觉。另外，请注意，我使用了免费的定价数据，可能会有数据质量问题。目标是与您一起经历整个过程，并强调这种模式提供的灵活性和选项。在我看来，我们需要这一点来确保我们和我们的客户对我们的资产配置决策有足够的信心。</p><p id="930a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝投资愉快，请在文章中留下您的反馈:)</p><p id="3ed7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢</p><p id="d18c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意:此分析仅用于教育目的，作者不对您的任何投资决策负责。</p></div></div>    
</body>
</html>