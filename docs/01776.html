<html>
<head>
<title>How to deploy a large scale Python application with Docker Swarm?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Docker Swarm部署大规模Python应用？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-deploy-a-python-application-with-docker-swarm-1c9038130b4b?source=collection_archive---------3-----------------------#2019-11-13">https://medium.com/analytics-vidhya/how-to-deploy-a-python-application-with-docker-swarm-1c9038130b4b?source=collection_archive---------3-----------------------#2019-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/e59b8abf2ae20019c7bbc83ed20781da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yi9fH_hVkBHnlkA4UM5xLw.png"/></div></div></figure><p id="8b8d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Docker容器技术于2013年作为开源Docker引擎推出。它利用了围绕容器的现有计算概念，特别是在Linux世界中，称为cgroups和namespaces的原语。Docker的技术是独一无二的，因为它专注于开发人员和系统运营商的要求，将应用程序依赖关系与基础设施分离开来。</p><p id="fb74" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Docker swarm是Docker的一个很好的补充。它旨在轻松管理多个主机上的容器调度。</p><ul class=""><li id="0ca9" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">要点:<strong class="ja hj">允许用Docker将多台主机连接在一起</strong>。</li><li id="888e" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">相对<strong class="ja hj">简单</strong>。与其他解决方案相比，从Docker Swarm开始真的很容易。</li><li id="247e" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated"><strong class="ja hj">高可用性</strong> —集群中有两种节点类型:<em class="kk">主节点</em>和<em class="kk">工作节点</em>。一个大师是领袖。如果当前领导者失败，另一个主人将成为领导者。如果工作主机出现故障，所有容器将被重新调度到其他节点。</li><li id="3194" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated"><strong class="ja hj">声明式配置</strong>。您告诉我们您想要什么，需要多少个副本，它们将根据给定的限制自动进行调度。</li><li id="3ddb" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated"><strong class="ja hj">滚动更新</strong> — Swarm存储容器的配置。如果您更新配置，容器将成批更新，因此默认情况下服务将始终可用。</li><li id="1caa" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated"><strong class="ja hj">内置服务发现和负载均衡</strong> —类似于Docker-Compose完成的负载均衡。您可以使用名称引用其他服务，容器存储在哪里并不重要，它们将以循环方式接收请求。</li><li id="4559" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated"><strong class="ja hj">覆盖网络</strong> —如果您从服务中公开一个端口，它将在集群中的任何节点上可用。它确实有助于外部负载平衡。</li></ul><h1 id="3c6c" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">在这篇文章中我们会看到什么？</h1><ul class=""><li id="7591" class="jw jx hi ja b jb lj jf lk jj ll jn lm jr ln jv kb kc kd ke bi translated">我们将使用Docker Swarm形成一个由三台机器组成的集群</li><li id="e54e" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">我们将展示如何启动docker注册表</li><li id="8d09" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">我们将标记并构建一个Python应用程序映像，然后将它放入我们的注册表中</li><li id="9f60" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">我们将部署一个堆栈并展示一些有用的群命令</li></ul><h1 id="7afd" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">先决条件:</strong></h1><p id="5a87" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">—安装了linus debian发行版的机器<br/> —每台机器上都安装了Docker<br/>——机器之间相互监视，可以发送和接收数据包</p><h1 id="895e" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">在开始组建蜂群之前，你应该知道些什么？</h1><p id="0c42" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">—在您的群集中，您可以有一台、两台、三台或多台服务器。<br/> —每台机器被称为集群中的一个节点。<br/> —为了利用swarm模式的容错特性，Docker建议您根据您组织的高可用性要求实现奇数个节点<br/> —要建立swarm，您需要有经理节点/机器和工人节点/机器。</p><p id="e226" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">管理器节点处理集群管理任务:</p><ul class=""><li id="cf65" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">维护集群状态</li><li id="42db" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">调度服务</li><li id="7113" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">服务群组模式HTTP API端点</li></ul><p id="9fad" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">工作者节点不参与Raft分布式状态，不做出调度决策，也不服务于群体模式HTTP API。</p><p id="e4a6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—一个N管理器群集最多允许损失(N-1)/2个管理器。例:一个有三个经理的群体最多能容忍失去一个经理。<br/> —您可以创建一个由一个管理器节点组成的群组，但是您不能拥有一个没有至少一个管理器节点的工作器节点。默认情况下，所有经理也是工人。在单个管理器节点集群中，可以运行docker service create这样的命令，调度器将所有任务放在本地引擎上。</p><h1 id="4604" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak"> 1-组建机器集群。</strong></h1><p id="ccbf" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">对于这个例子，我使用3台机器。<br/> <br/>参见下面我的机器角色和IP(所有三台机器都将成为管理器):<br/> <strong class="ja hj">我的管理器一具有IP 10.10.25.165和主机名serveur17 <br/>我的管理器二具有IP 10.10.25.166和主机名serveur18 <br/>我的管理器三具有IP 10.10.25.167和主机名serveur19 </strong></p><p id="56be" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> <em class="kk"> a-在三台服务器上打开三个终端会话和ssh。</em> </strong></p><p id="d6c3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="kk"> ssh root@machine_IP </em>并输入密码。</p><p id="fd4d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在1号航站楼</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="9509" class="lw km hi ls b fi lx ly l lz ma"><em class="kk">$ ssh root@10.10.25.165</em></span></pre><p id="33d9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在2号航站楼</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="0399" class="lw km hi ls b fi lx ly l lz ma"><em class="kk">$ ssh root@10.10.25.166</em></span></pre><p id="2756" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在3号航站楼</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="3393" class="lw km hi ls b fi lx ly l lz ma"><em class="kk">$ ssh root@10.10.25.167</em></span></pre><p id="1b6a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> <em class="kk"> b-设置您的机器主机</em> </strong> <br/>在3台机器上重复此操作:<br/> —在每台服务器上编辑主机文件</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="9a4b" class="lw km hi ls b fi lx ly l lz ma"><em class="kk">$ vim /etc/hosts</em></span></pre><p id="0e58" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—在每台机器的主机文件中添加这3行并保存</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="f94e" class="lw km hi ls b fi lx ly l lz ma">10.10.25.165 dockernode1 <br/>10.10.25.166 dockernode2 <br/>10.10.25.167 dockernode3</span></pre><p id="b6c3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> <em class="kk"> c- Ping它们之间的机器以查看发送的数据包和收到的数据包</em> </strong> <br/>来自dockernode1机器(10.10.25.165)，Ping他人管理器dockernode2和dockernode3</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="2716" class="lw km hi ls b fi lx ly l lz ma">$ ping dockernode2 <br/>$ ping dockernode3</span></pre><p id="7bd2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">从dockernode2机器(10 . 10 . 25 . 166)ping其他管理器dockernode1和dockernode3</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="e809" class="lw km hi ls b fi lx ly l lz ma">$ ping dockernode1 <br/>$ ping dockernode3</span></pre><p id="e2df" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">从dockernode3机器(10 . 10 . 25 . 167)ping其他管理器dockernode1和dockernode2</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="30ce" class="lw km hi ls b fi lx ly l lz ma">$ ping dockernode1 <br/>$ ping dockernode3</span></pre><p id="0443" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">可能的问题</strong>:如果没有收到数据包，请检查您的防火墙设置。</p><p id="e140" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> d-初始化docker swarm，让我们组成集群</strong></p><ul class=""><li id="6844" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated"><strong class="ja hj"> <em class="kk">继续在docker node 1</em></strong><em class="kk"/><strong class="ja hj"><em class="kk">机器上初始化我们的蜂群</em> </strong></li></ul><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="356c" class="lw km hi ls b fi lx ly l lz ma">$ docker swarm init --advertise-addr 10.10.25.165</span></pre><blockquote class="mb mc md"><p id="111b" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">你会看到以下输出:<br/> <strong class="ja hj"> <em class="hi"> Swarm初始化:当前节点(0knoujuvtkoq1pg3mhjhxsbhn)现在是一个管理器。</em>T46】</strong></p><p id="9142" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"> <em class="hi">要将一个工人添加到这个群，运行下面的命令:</em> </strong></p><p id="ca20" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"><em class="hi">docker swarm join—token swm tkn-1–3g 85y 47 bq 6 w7 frwqq 7 GNP xqg 85 klk 02 escd 5n 5 I 180 EO 6 yiwb 1-e 46 NZD j2o H4 YC 62 p 66 rogd j 7h 10 . 10 . 25 . 165:2377</em></strong></p><p id="d803" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"> <em class="hi">要向该群组添加管理器，运行“docker swarm join-token manager ”,并按照说明进行操作。</em> </strong></p></blockquote><p id="5120" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在初始化我们的swarm之后，总是在<strong class="ja hj"> dockernode1 </strong>机器上，运行这个命令:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="49df" class="lw km hi ls b fi lx ly l lz ma">$ docker swarm join-token manager</span></pre><blockquote class="mb mc md"><p id="14be" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><em class="hi">您将会看到以下输出:</em></p><p id="9ab3" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"> <em class="hi">要向这个群添加一个管理器，运行下面的命令:</em> </strong></p><p id="e7a7" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"><em class="hi">docker swarm join—token swm tkn-1–3g 85y 47 bq 6 w7 frwqq 7 GNP xqg 85 klk 02 escd 5n 5 I 180 EO 6 yiwb 1–4 wes 668 cwnowczst 9v 32736g 6 10 . 10 . 25 . 165:2377</em></strong></p></blockquote><p id="3649" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">请从该确认文本中复制输出命令。这个命令将用于将我们的其他服务器添加到集群中</p><ul class=""><li id="0535" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated"><strong class="ja hj"> <em class="kk">上dockernode2机器(</em> 10.10.25.166 <em class="kk">)添加到我们的群</em> </strong></li></ul><p id="dcd7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要将<strong class="ja hj"><em class="kk">docker node 2</em></strong><em class="kk">机器作为</em>管理器添加到集群，请在运行以下命令后按照说明操作:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="a199" class="lw km hi ls b fi lx ly l lz ma">$ docker swarm join --token SWMTKN-1-3g85y47bq6w7frwqq7gnpxqg85klk02escd5n5i180eo6yiwb1-4wes668cwnawczst9v32736g6 10.10.25.165:2377</span></pre><blockquote class="mb mc md"><p id="f26a" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><em class="hi">你会看到下面的输出:</em></p><p id="eb66" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"> <em class="hi">这个节点作为管理者加入了一个虫群。</em>T29】</strong></p></blockquote><blockquote class="mh"><p id="2a7d" class="mi mj hi bd mk ml mm mn mo mp mq jv dx translated"><em class="mr">输出告诉您dockernode2现在是一个经理。</em></p></blockquote><ul class=""><li id="2172" class="jw jx hi ja b jb ms jf mt jj mu jn mv jr mw jv kb kc kd ke bi translated"><strong class="ja hj"> <em class="kk">上dockernode3机器(</em> 10.10.25.167 <em class="kk">)添加到我们的群</em> </strong></li></ul><p id="9456" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要将<strong class="ja hj"><em class="kk">docker node 3</em></strong><em class="kk">机器作为</em>管理器添加到群中，请在运行该命令后按照说明操作:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="51a5" class="lw km hi ls b fi lx ly l lz ma">$ docker swarm join --token SWMTKN-1-3g85y47bq6w7frwqq7gnpxqg85klk02escd5n5i180eo6yiwb1-4wes668cwnawczst9v32736g6 10.10.25.165:2377</span></pre><p id="9bfe" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">输出告诉您该节点现在是一个管理器。</p><blockquote class="mb mc md"><p id="c716" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><em class="hi">你会看到下面的输出:</em></p><p id="b966" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><strong class="ja hj"> <em class="hi">这个节点以管理者的身份加入了虫群。</em>T49】</strong></p></blockquote><blockquote class="mh"><p id="d039" class="mi mj hi bd mk ml mm mn mo mp mq jv dx translated">输出告诉你dockernode3现在是一个经理。</p></blockquote><p id="f71d" class="pw-post-body-paragraph iy iz hi ja b jb ms jd je jf mt jh ji jj mx jl jm jn my jp jq jr mz jt ju jv hb bi translated"><strong class="ja hj"> <em class="kk"> f-检查节点状态</em> </strong> <br/> $ docker节点ls</p><blockquote class="mb mc md"><p id="1ae7" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">您将看到以下某种输出:</p></blockquote><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es na"><img src="../Images/4452c25231f481488cc73764f3f96f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJ_hV9pkC3d8JhtXGD_dpw.png"/></div></div></figure><blockquote class="mh"><p id="3485" class="mi mj hi bd mk ml mm mn mo mp mq jv dx translated">我们的集群已经准备好了…</p></blockquote><h1 id="10ee" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw nb ky kz la nc lc ld le nd lg lh li bi translated"><strong class="ak"> 2-建立注册表</strong></h1><p id="25c5" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">在集群中部署应用程序之前，我们需要将应用程序docker映像放在注册表中。</p><p id="cbc7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">注册表是存储和标记图像以备后用的地方。</p><p id="8a3f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">基于Docker的工作流的主要组件是图像，它包含运行应用程序所需的一切。作为持续集成的一部分，映像通常是自动创建的，因此每当代码发生变化时，它们都会更新。当图像被构建为在开发人员和机器之间共享时，它们需要被存储在某个地方，这就是容器注册表的用武之地。</p><p id="d02b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">开发人员可能希望维护他们自己的注册表，用于私有的、公司的图像，或者只用于测试的一次性图像。</p><p id="c3b5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你可以使用哪个docker注册表？ </p><blockquote class="mb mc md"><p id="c079" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><em class="hi">第一种可能</em> <br/>你可以在你的服务器上建立自己的私有注册表。</p></blockquote><p id="e3c0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">通过这种选择，您应该维护用于构建注册表的服务器，并确保服务不会关闭。</p><blockquote class="mb mc md"><p id="76a2" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated"><em class="hi">第二种可能性</em> <br/>你可以使用在线服务作为<a class="ae ne" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub Registry </a>或<a class="ae ne" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab Container Registry </a>来存储你的Docker图片。</p></blockquote><p id="41fc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">通过选择这些在线注册服务，您无需维护服务器。这些在线服务也让你有可能建立一个私人或公共注册。</p><p id="a2b7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> <em class="kk"> b-如何在自己的服务器上创建私有注册表？</em> </strong></p><p id="3de8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在我的例子中，我在一台机器(10.10.25.165)上设置了注册表。</p><p id="494c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—将注册表作为服务启动:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="87c1" class="lw km hi ls b fi lx ly l lz ma">$ docker service create — name agile-registry — publish published=5000,target=5000 registry:2</span></pre><ul class=""><li id="7c56" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">检查注册表状态</li></ul><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="2b87" class="lw km hi ls b fi lx ly l lz ma">$ docker service ls</span></pre><blockquote class="mb mc md"><p id="9740" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">您将看到以下某种输出:</p></blockquote><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nf"><img src="../Images/3f88d1c1508d5b4e04f60a623b6e8e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3C0IOAA4_nDKF1kurE9CA.png"/></div></div></figure><p id="c091" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> <em class="kk"> c-如何在docker Hub和Gitlab上创建注册表？</em> </strong> <br/>在这个例子中，我说的不是在Hub或Docker Gitlab上创建注册表，而是你有很多处理这个主题的在线教程。</p><h1 id="12b2" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3-让我们构建一个python示例应用程序映像</h1><p id="6651" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">我们将在dockernode1机器上创建和构建应用程序，并标记注册表</p><p id="efa1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—为项目创建一个目录:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="dddf" class="lw km hi ls b fi lx ly l lz ma">$ mkdir stackdemo<br/>$ cd stackdemo</span></pre><p id="e6fd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—在项目目录中创建名为app.py的文件，并将其粘贴到:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="788a" class="lw km hi ls b fi lx ly l lz ma">from flask import Flask<br/>   from redis import Redis</span><span id="a5a0" class="lw km hi ls b fi ng ly l lz ma">app = Flask(__name__)<br/>   redis = Redis(host='redis', port=6379)</span><span id="21e4" class="lw km hi ls b fi ng ly l lz ma"><a class="ae ne" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>   def hello():<br/>       count = redis.incr('hits')<br/>       return 'Hello World! I have been seen {} times.\n'.format(count)</span><span id="892e" class="lw km hi ls b fi ng ly l lz ma">if __name__ == "__main__":<br/>       app.run(host="0.0.0.0", port=8000, debug=True)</span></pre><p id="1979" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—创建一个名为requirements.txt的文件，并将这两行粘贴到:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="9312" class="lw km hi ls b fi lx ly l lz ma"><em class="kk">flask<br/>redis</em></span></pre><p id="4201" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—创建一个名为Dockerfile的文件，并将其粘贴到:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="a08c" class="lw km hi ls b fi lx ly l lz ma">FROM python:3.4-alpine<br/>ADD . /code<br/>WORKDIR /code<br/>RUN pip install -r requirements.txt<br/>CMD ["python", "app.py"]</span></pre><p id="9855" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—创建一个名为docker-compose-dist-app-registry-build . yml的文件，并将其粘贴到:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="dd36" class="lw km hi ls b fi lx ly l lz ma">version: '3'<br/><br/>services:<br/>  web:<br/>    image: 127.0.0.1:5000/stackdemo<br/>    build: .<br/>    ports:<br/>      - "8000:8000"</span></pre><p id="c02f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="kk">web应用程序的图像是使用上面定义的Dockerfile构建的。它还被标记为127.0.0.1:5000，这是之前创建的注册表的地址。这在将应用程序分发给群体时非常重要。</em></p><p id="951b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—构建应用程序映像</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="f499" class="lw km hi ls b fi lx ly l lz ma">$ docker-compose -f docker-compose-dist-app-registry-build.yml build</span></pre><h1 id="b99d" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4-在上一步中，我们的应用程序映像已经建立，现在让我们把它放在注册表中。</h1><p id="7081" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">总是在我们的应用程序文件夹中，让我们执行以下命令:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="0983" class="lw km hi ls b fi lx ly l lz ma">$ docker-compose -f docker-compose-dist-app-registry-build.yml push</span></pre><blockquote class="mb mc md"><p id="181d" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">您将会看到以下输出:<br/>Pushing web(127 . 0 . 0 . 1:5000/stack demo:latest)…<br/>push引用一个存储库[127 . 0 . 0 . 1:5000/stack demo]<br/>5b 5a 49501 a 76:Pushed<br/>be 44185 ce 609:Pushed<br/>BD 7330 a 79 BCF:Pushed<br/>c9fc 143 a 00</p></blockquote><h1 id="227c" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak"> <em class="mr"> 5-让我们在集群上部署堆栈</em> </strong></h1><p id="d989" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">总是在我们的应用程序文件夹中，<br/> <br/> —创建一个名为docker-compose-dist-deploy.yml的文件，并将其粘贴到:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="83a9" class="lw km hi ls b fi lx ly l lz ma">version: '3'<br/><br/>services:<br/>  web:<br/>    image: 127.0.0.1:5000/stackdemo<br/>    hostname: '{{.Node.Hostname}}'<br/>    ports:<br/>      - "8000:8000"<br/>    deploy:<br/>      mode: replicated<br/>      replicas: 6<br/>      restart_policy:<br/>        condition: on-failure<br/>  redis:<br/>    image: redis:alpine<br/>    ports:<br/>      - "6379:6379"<br/><br/>  visualizer:<br/>    image: dockersamples/visualizer<br/>    ports:<br/>      - "8080:8080"<br/>    stop_grace_period: 1m30s<br/>    volumes:<br/>      - "/var/run/docker.sock:/var/run/docker.sock"<br/>    deploy:<br/>      placement:<br/>        constraints: [node.role == manager]</span></pre><p id="6505" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—使用docker stack deploy创建堆栈:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="4455" class="lw km hi ls b fi lx ly l lz ma">$ docker stack deploy — compose-file docker-compose-dist-deploy.yml stackdemo</span></pre><blockquote class="mb mc md"><p id="c483" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">您将看到以下某种输出:</p><p id="7cab" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">忽略不支持的选项:构建</p><p id="7f8d" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">创建网络堆栈demo_default <br/>创建服务堆栈demo_web <br/>创建服务堆栈demo_redis</p></blockquote><p id="f7ca" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—检查它是否在以下条件下运行:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="a17f" class="lw km hi ls b fi lx ly l lz ma">$ docker stack services stackdemo</span></pre><blockquote class="mb mc md"><p id="60bc" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">您将看到以下某种输出:</p></blockquote><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nh"><img src="../Images/a2785b8e19f62eb7a61b187ff2f6354c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZwx_pKp03qm1WhTWOUoMQ.png"/></div></div></figure><p id="b6e2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—检查我们的应用是否在我们的节点上运行:<br/>由于Docker内置的路由网格，您可以在端口8000上访问swarm中的任何节点，并路由到应用:</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="f746" class="lw km hi ls b fi lx ly l lz ma">$ curl <a class="ae ne" href="http://10.10.14.165:8000" rel="noopener ugc nofollow" target="_blank">http://10.10.14.165:8000</a></span></pre><blockquote class="mb mc md"><p id="d7bf" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">输出:</p><p id="8222" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">你好世界！我已经被看过1次了。</p></blockquote><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="6ac1" class="lw km hi ls b fi lx ly l lz ma">$ curl <a class="ae ne" href="http://10.10.14.165:8000" rel="noopener ugc nofollow" target="_blank">http://10.10.14.166:8000</a></span></pre><blockquote class="mb mc md"><p id="a6f1" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">输出:</p><p id="efaf" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">你好世界！我被看过两次。</p></blockquote><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="2f38" class="lw km hi ls b fi lx ly l lz ma">$ curl <a class="ae ne" href="http://10.10.14.165:8000" rel="noopener ugc nofollow" target="_blank">http://10.10.14.167:8000</a></span></pre><blockquote class="mb mc md"><p id="3c29" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">输出:</p><p id="086b" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">你好世界！我已经被看过3次了。</p></blockquote><p id="ca75" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">—使用创建的visualizer服务来检查节点，并查看您的应用程序副本如何在三台服务器之间共享。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ni"><img src="../Images/5d09f18aa1a430c7b1ccafc60645e73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*v-dmu8OZ68rZXsi7I-b1YQ.png"/></div></figure><p id="7c8f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">您可以关闭任何机器来检查您的应用程序在其他可用的机器上是否仍然可用。</p><p id="f707" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我关闭了第一个<strong class="ja hj"> 10.10.25.165 </strong>服务器，我的应用程序在其他节点上仍然可用，并且继续计数。</p><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="0c3b" class="lw km hi ls b fi lx ly l lz ma">$ curl <a class="ae ne" href="http://10.10.14.167:8000" rel="noopener ugc nofollow" target="_blank">http://10.10.14.167:8000</a></span></pre><blockquote class="mb mc md"><p id="8e2f" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">输出:</p><p id="e627" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">你好世界！我已经被看过4次了。</p></blockquote><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="0dab" class="lw km hi ls b fi lx ly l lz ma">$ curl <a class="ae ne" href="http://10.10.14.168:8000" rel="noopener ugc nofollow" target="_blank">http://10.10.14.168:8000</a></span></pre><blockquote class="mb mc md"><p id="fb62" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">输出:</p><p id="1598" class="iy iz kk ja b jb jc jd je jf jg jh ji me jk jl jm mf jo jp jq mg js jt ju jv hb bi translated">你好世界！我已经被看过5次了。</p></blockquote><h1 id="52c1" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">6-要关闭堆栈，请使用:</h1><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="1dbb" class="lw km hi ls b fi lx ly l lz ma">$ docker stack rm stackdemo</span></pre><h1 id="c4e3" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">7-要删除注册表:</h1><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="3c6a" class="lw km hi ls b fi lx ly l lz ma">$ docker service rm registry</span></pre><h1 id="7f5a" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">8-从群中删除节点</h1><pre class="in io ip iq fd lr ls lt lu aw lv bi"><span id="b582" class="lw km hi ls b fi lx ly l lz ma">$ docker swarm leave — force</span></pre><p id="e06a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">节点离开了虫群。</p><h1 id="927a" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">如果你想在配置上更进一步</h1><p id="6f29" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">下面是我总结用户查询路径的顶层架构:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es nj"><img src="../Images/1cabde935524d750922c969bd1eb8ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rH_JBrbwPjpngzgSpUwjfw.png"/></div></div></figure><p id="88ac" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我使用以下元素:</p><p id="376b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">-一个域名<br/> -至少两个公共IP<br/>-一个负载平衡器</p><p id="d48e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 1-我创建了多个A类DNS记录:</strong></p><p id="b67f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae ne" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a>= =&gt;公共IP 1</p><p id="5814" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae ne" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a>= =&gt;公共IP 2</p><p id="ad7d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae ne" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a>= =&gt;公共IP n</p><p id="a81f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 2-我配置一个负载均衡器:</strong></p><p id="e629" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我将我的n个公共IP地址添加到我的负载平衡器中。此配置取决于您在前面使用的负载平衡器和您的虚拟主机。</p><p id="0843" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">总结一下，下面的旅程由一个用户提出请求</strong></p><ul class=""><li id="c3c3" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">用户向域www.example.com发送请求</li><li id="81cb" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">由于我们已经为具有多个IP地址的同一个域注册了多个DNS记录，DNS将根据循环算法选择一个可用的IP地址来将请求路由到负载平衡器。由于多个IP地址支持域请求，这使得该解决方案在DNS级别更加可用。</li><li id="2cbf" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">负载均衡器监听并将来自这些公共IP地址的请求重定向到Docker swarm。</li><li id="a285" class="jw jx hi ja b jb kf jf kg jj kh jn ki jr kj jv kb kc kd ke bi translated">Docker swarm从Docker节点中选择将做出响应的可用节点。即使其中一个节点(例如10.10.25.165)不可用，由于有另外两个Docker节点，应用程序也能继续正常运行，不会出现问题。</li></ul><p id="0069" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在网络浏览器中，用户只知道域名。因此，即使一些Docker节点丢失，应用程序也将继续正常运行。</p><p id="2760" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">感谢阅读。如有必要，您可以添加评论，留下您的赞赏。我会考虑你的意见来改进这篇文章。</p><h1 id="1c3c" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">下一步是什么？</h1><p id="580f" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv hb bi translated">我将在另一篇文章中展示如何扩展Redis，以及如何监控我们的堆栈，并在其中一个节点出现故障时自动触发警报(邮件、短信)。</p></div></div>    
</body>
</html>