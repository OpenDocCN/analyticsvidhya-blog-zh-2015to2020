<html>
<head>
<title>Racing Bar Chart in D3js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">D3js 中的赛车条形图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-racing-bar-chart-in-d3js-d89b71cd3439?source=collection_archive---------1-----------------------#2020-09-12">https://medium.com/analytics-vidhya/building-racing-bar-chart-in-d3js-d89b71cd3439?source=collection_archive---------1-----------------------#2020-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/647fd06e3d950440007c27801b6e8a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*HI4UoJh_3hvVw5uBJCg1QA.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">CLL SOAI 新冠肺炎赛车条形图</figcaption></figure><p id="48da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们海德拉巴 AI 学校与 CLL 合作学习中心(Co-learning Lounge)合作制作了赛车条形图，这是一个发展最快的技术社区，旨在开源教育，从而使其变得负担得起。所有的社区成员将通过友好的链接免费获得这篇文章。在下面的视频中查看我们的工作。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="a890" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">让我们开始构建赛车条形图</strong></p><p id="3c3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，如果你不知道 D3js 的基础知识，我强烈推荐你阅读我的<a class="ae ju" rel="noopener" href="/analytics-vidhya/d3js-basic-to-mastery-bf5459836970"> D3js 文章</a>，否则会非常困难，因为我不会在这里解释任何技术内容。</p><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/d3js-basic-to-mastery-bf5459836970"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">D3.js 基础到精通第 1 部分基础</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">如果你点击了这篇文章，我想你已经知道 d3js 是什么了，你可以在…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km ik jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/d3js-basic-to-mastery-part-2-mastery-680db40f2ec5"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">D3js 基础到精通第 2 部分精通</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">在上一篇文章中，我们学习了 D3js 的基础知识，比如选择、DOM 操作、SVG、缩放和数据…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="kn l kj kk kl kh km ik jy"/></div></div></a></div><h1 id="570d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">数据源</h1><p id="8eda" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">我将使用的数据源来自<a class="ae ju" href="https://api.covid19india.org/states_daily.json" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://api.covid19india.org</em></a>，这是一个由志愿者驱动的众包数据库，用于新冠肺炎统计&amp;印度患者追踪。”。我从<br/><a class="ae ju" href="https://api.covid19india.org/states_daily.json" rel="noopener ugc nofollow" target="_blank">https://api.covid19india.org/states_daily.json</a>那里拿到了《美国日报》的 json 数据。</p><p id="cfdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们检查一下数据格式。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="d465" class="lx kp hi lt b fi ly lz l ma mb"><strong class="lt hj">{</strong>"states_daily": <strong class="lt hj">[<br/>{</strong>"an": "0"<br/>"ap": "1",<br/>"ar": "0",<br/>"as": "0",<br/>"date": "14-Mar-20",<br/>"dd": "0",<br/>"dl": "7",<br/>...<br/>"status": "Confirmed",<br/>"tg": "1",<br/>"tn": "1",<br/>...<strong class="lt hj">}]}</strong></span></pre><p id="b08d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到在<code class="du mc md me lt b">states_daily</code>对象下，有一个数组对象，其中包含所有状态代码以及日期和状态。我们可以用数据和状态对项目进行分组，然后用它来构建图表。</p><p id="df26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置你的项目，添加 D3js，然后回来。</p><h1 id="15d3" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">处理数据</h1><p id="000a" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">使用<code class="du mc md me lt b">fetch</code>从 API 获取数据。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="7657" class="lx kp hi lt b fi ly lz l ma mb">fetch('https://api.covid19india.org/states_daily.json')<br/>     .then(res =&gt; res.json())<br/>     .then((data: any) =&gt; {<br/>       const processedData = processData(data);<br/>       plotChart(processedData)<br/>})</span></pre><p id="030d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在<code class="du mc md me lt b">processData</code>函数中将数据处理成所需的格式，并将其传递给<code class="du mc md me lt b">plotChart</code>函数来绘制图表。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="98a0" class="lx kp hi lt b fi ly lz l ma mb">function processData(data) { <br/>   return d3.group(data.states_daily, d =&gt; d.date, e =&gt; e.status);<br/>}</span></pre><p id="1ed0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是数据嵌套的两个阶段。我们将<code class="du mc md me lt b">date</code>作为第一阶段的嵌套，因为我们需要迭代日期。如你所知，我们需要通过动画显示每个日期，使它看起来像一个赛车图表。第二阶段嵌套我们采用<code class="du mc md me lt b">status</code>，因为我们只需要在任何给定日期比较一种状态。</p><p id="fa96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出是以<code class="du mc md me lt b">date</code>为关键字的映射关键字对值和以<code class="du mc md me lt b">status</code>为关键字的另一个映射。如果你不知道 Javascript 中的<a class="ae ju" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">地图，点击这里</a>了解一下。对于大型数据集，它还提高了对象的性能。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/ead894e8b95b1ffff7d82cf583f4ef9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*a1TLVZn_zNDv-03TXeEmdg.png"/></div></figure><p id="e166" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们已经处理了数据，为了绘制图表，首先我们需要制作比例尺。为了进行缩放，我们需要 SVG 的大小，以及现存的<em class="lr"> (min，max) </em>数据。不制作动画时，我们一次只绘制一个日期的图表。因此，让我们为一个单一的日期。</p><h1 id="316a" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">构建图表</h1><h2 id="79a1" class="lx kp hi bd kq mg mh mi ku mj mk ml ky jb mm mn lc jf mo mp lg jj mq mr lk ms bi translated"><strong class="ak"> HTML </strong></h2><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="dbe4" class="lx kp hi lt b fi ly lz l ma mb">&lt;svg id="chart" style="width: 80vw;height: 80vh;"&gt;&lt;/svg&gt;</span></pre><p id="cfd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将 SVG 高度设为视图高度(vh)的 80%,宽度设为视图宽度(vw)的 80%。如果我们想让图表反应灵敏，它就派上用场了。</p><h2 id="9d0f" class="lx kp hi bd kq mg mh mi ku mj mk ml ky jb mm mn lc jf mo mp lg jj mq mr lk ms bi translated"><strong class="ak"> JS </strong></h2><p id="7d95" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">在<code class="du mc md me lt b">fetch</code>中，我们将<code class="du mc md me lt b">processedData</code>传递给<code class="du mc md me lt b">plotChart</code>函数，让我们开始在其中构建图表。在<code class="du mc md me lt b">plotChart</code>功能中</p><ol class=""><li id="277b" class="mt mu hi is b it iu ix iy jb mv jf mw jj mx jn my mz na nb bi translated"><strong class="is hj">设置 SVG 的高度和宽度。</strong></li></ol><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="1381" class="lx kp hi lt b fi ly lz l ma mb">    const svg = d3.select("#chart");<br/>    const width = svg.node().clientWidth;<br/>    const height = svg.node().clientHeight;</span></pre><p id="5495" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。获取日期和第一次约会的列表。</strong> <code class="du mc md me lt b"><strong class="is hj">data</strong></code> <strong class="is hj">中的所有键都是日期。</strong></p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="6c1a" class="lx kp hi lt b fi ly lz l ma mb">    const dateList = Array.from(data.keys());<br/>    const present-day = dateList[0];</span></pre><p id="af15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。获取特定日期的数据，并根据我们的要求进行更改。</strong></p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="334f" class="lx kp hi lt b fi ly lz l ma mb">const presentData = processEachDateData(<br/>                               data.get(presentDate)<br/>                                   .get("confirmed")[0])</span></pre><p id="1505" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mc md me lt b">processEachDateData</code>功能。我们需要从数据中删除<code class="du mc md me lt b">data</code>和状态，因为我们只需要它们来识别数据而不是绘制。然后将所有数据转换成<code class="du mc md me lt b">{key, value}</code>对象。然后对它们进行分类。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="e1a0" class="lx kp hi lt b fi ly lz l ma mb">function processEachDateData(data) {</span><span id="227d" class="lx kp hi lt b fi nc lz l ma mb">    //remove status and date<br/>    delete data.date<br/>    delete data.status</span><span id="e434" class="lx kp hi lt b fi nc lz l ma mb">    return Object.keys(data)<br/>                 .map(key =&gt; ({key, value: data[key]}))<br/>                 .sort((a,b) =&gt; b.value-a.value)</span><span id="3cc4" class="lx kp hi lt b fi nc lz l ma mb">}</span></pre><p id="1f48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。准备</strong> <code class="du mc md me lt b"><strong class="is hj">Scale</strong></code> <strong class="is hj">。域的范围应该从 0 到最高的</strong> <code class="du mc md me lt b"><strong class="is hj">value</strong></code> <strong class="is hj">。</strong></p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="3223" class="lx kp hi lt b fi ly lz l ma mb">const xScale = d3.scaleLinear()<br/>        .domain([0, d3.max(Object.values(presentData), d =&gt; parseInt(d.value))]<br/>        ).range([0, width])</span></pre><p id="59a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。添加</strong> <code class="du mc md me lt b"><strong class="is hj">rect</strong></code> <strong class="is hj">并将数据和</strong> <code class="du mc md me lt b"><strong class="is hj">enter</strong></code> <strong class="is hj">循环绑定到其中。</strong> <code class="du mc md me lt b">x</code>是固定的，所以给了一些<code class="du mc md me lt b">10px</code>、<code class="du mc md me lt b">y</code>的填充，每个<code class="du mc md me lt b">rect</code>的位置应该在排名的基础上增加，所以<code class="du mc md me lt b">height * index</code>和<code class="du mc md me lt b">rect</code>之间要加一些空隙，我加了填充。<code class="du mc md me lt b">width</code>应该基于<code class="du mc md me lt b">value</code>动态。所以传递标尺的值。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="39b9" class="lx kp hi lt b fi ly lz l ma mb">const container = svg.append("g")<br/>                          .classed("container", true)<br/>const rectProperties = {height: 20, padding: 10}<br/>    <br/>container.selectAll("rect")<br/>         .data(presentData)<br/>         .enter()<br/>         .append("rect")<br/>         .attr("x", 10)<br/>         .attr("y", (d,i) =&gt; {<br/>           return i * (rectProperties.height + rectProperties.padding)<br/>         })<br/>         .attr("width", d =&gt; xScale(parseInt(d.value)))<br/>         .attr("height", rectProperties.height)</span></pre><p id="c6ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整体代码将如下所示</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="nd jt l"/></div></figure><p id="cecb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/051e24c118916c610b4dd15b893891b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*5b33nYC-jQd393PVXLkSAg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">赛车条形图 d3js 教程</figcaption></figure><p id="9cf7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">耶，我们得到了基本的图表，现在我们需要将图表的位置和宽度设置为下一个值。每当我们更新到新值时，我们也需要更新我们的标度。所以我们只需将所有需要更新的内容转移到一个函数中，并将<code class="du mc md me lt b">date</code>作为参数传递。对于动画，在将要更新的属性上添加带有<code class="du mc md me lt b">delay</code>的<code class="du mc md me lt b">transition</code>。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="d02d" class="lx kp hi lt b fi ly lz l ma mb">const update = (date) =&gt; { <br/>   // get the data  <br/>   const presentData = processEachDateData(data.get(date).get("Confirmed")[0])</span><span id="cf70" class="lx kp hi lt b fi nc lz l ma mb">   // make the scale <br/>   const widthScale = d3.scaleLinear()<br/>                       .domain([0,d3.max(Object.values(presentData), d =&gt; parseInt(d.value))])<br/>                       .range([0, width - fontSize - 50])</span><span id="7b16" class="lx kp hi lt b fi nc lz l ma mb">    container<br/>           .selectAll("rect")<br/>           .data(presentData)<br/>           .enter()<br/>           .append("rect")<br/> <br/>    container<br/>          .selectAll("rect")<br/>          .attr("x", 10)<br/>          .transition()<br/>          .delay(500)<br/>          .attr("y", (d,i) =&gt; i * 30 )<br/>          .attr("width", d =&gt; d.value &lt;= 0? 0 : widthScale(d.value))<br/>          .attr("height", 20)</span><span id="b72e" class="lx kp hi lt b fi nc lz l ma mb">}</span></pre><p id="382d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加循环以每隔几毫秒更新一次。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="30e5" class="lx kp hi lt b fi ly lz l ma mb">for (const date of dateList) {<br/>     update(date)<br/>     await new Promise(done =&gt; setTimeout(() =&gt; done(), 500));<br/>}</span></pre><p id="6769" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常<code class="du mc md me lt b">setTimeout</code>是一个<em class="lr">异步</em>方法，但是我们通过添加<code class="du mc md me lt b">await new Promise</code>使其成为<em class="lr">同步</em>。</p><h1 id="fd7d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">问题修正</strong></h1><p id="c23f" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">这段代码有问题。我们正在对数据进行排序，然后将其绑定到<code class="du mc md me lt b">rect</code>。当我们将新数据绑定到<code class="du mc md me lt b">rect</code>时，新数据与先前数据的顺序不同，即<code class="du mc md me lt b">[mh: 3, tt: 2, kr: 1]</code>绑定到第一个<code class="du mc md me lt b">rect</code>的数据，但新数据是<code class="du mc md me lt b">[kr: 5, mh: 3, tt: 2]</code>，如果我们绑定该数据，<code class="du mc md me lt b">mh</code> <code class="du mc md me lt b">rect</code>被替换为<code class="du mc md me lt b">kr</code> <code class="du mc md me lt b">rect</code>。这不是我们想要的，我们需要更新相同的各自<code class="du mc md me lt b">rect</code>的值。要做到这一点，我们不应该在追加<code class="du mc md me lt b">rect</code>并激活它们的<code class="du mc md me lt b">y</code>位置之前对数据进行排序。</p><p id="5c18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">移除<code class="du mc md me lt b"> processEachDateData</code>功能中的分类。顺便说一下，也让<code class="du mc md me lt b">parseInt</code>这个函数本身的值，这样我们就不需要在每次使用它的时候解析它。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="0403" class="lx kp hi lt b fi ly lz l ma mb">function processEachDateData(data) {<br/>    //remove status, date and tt(total)<br/>    delete data.date<br/>    delete data.status<br/>    delete data.tt</span><span id="2dc1" class="lx kp hi lt b fi nc lz l ma mb">    return Object.keys(data)<br/>              .map(key =&gt; ({key, value: parseInt(data[key])})) <br/>}</span></pre><p id="1730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在追加<code class="du mc md me lt b">rect</code>之前，在<code class="du mc md me lt b">update</code>函数中对数据进行排序</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="4a3a" class="lx kp hi lt b fi ly lz l ma mb">const sortedRange = [...presentData].sort((a,b) =&gt; b.value-a.value)</span></pre><p id="2cae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mc md me lt b"><em class="lr">[…presentData].sort</em></code> <em class="lr">此招是为了不影响原阵。</em></p><p id="4d5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在对于<code class="du mc md me lt b">rect</code>的<code class="du mc md me lt b">y</code>位置，找到<code class="du mc md me lt b">sortedRange</code>上的索引并相乘。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="a3b3" class="lx kp hi lt b fi ly lz l ma mb">.attr(“y”, (d,i) =&gt; sortedRange.findIndex(e =&gt; e.key === d.key) *<!-- -->(rectProperties.height + rectProperties.padding))</span></pre><p id="9e8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在输出应该是这样的</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/8e315ae785b2e8ff44aeb00c6e16bfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/1*Iex4EKQPJ9pGDMu-BRNkhA.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">赛车条形图 d3js 教程</figcaption></figure><p id="56c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在工作正常。让我们添加一些文本。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="08b8" class="lx kp hi lt b fi ly lz l ma mb">container<br/>    .selectAll("text")<br/>    .data(presentData)<br/>    .enter()<br/>    .append("text")</span><span id="88cc" class="lx kp hi lt b fi nc lz l ma mb">container<br/>    .selectAll("text")<br/>    .text(d =&gt; d.key + " "+ d.value)<br/>    .transition()<br/>    .delay(500)<br/>    .attr("x", d =&gt; widthScale(d.value) + fontSize)<br/>    .attr("y", (d,i) =&gt; {<br/>      return sortedRange.findIndex(e =&gt; e.key === d.key) * (rectProperties.height + rectProperties.padding) + fontSize <br/>    })</span></pre><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/91b3586398ff8fd035aa770d3e327054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/1*KOLWyN3sPG6JMyJCb73TKw.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">赛车条形图 d3js 教程</figcaption></figure><p id="ee81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到现在为止的代码</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="nd jt l"/></div></figure><p id="44c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以将轴添加到顶部。为了制作轴的动画，我们需要更新轴，但是现在我们每次更新都要创建新的比例，轴生成器依赖于这个比例。</p><p id="6350" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在需要将标尺移动到父函数中，并在更新函数中更新它们。让我们创建一个具有空域和范围的标度，然后在更新函数上方生成虚拟轴。</p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="2031" class="lx kp hi lt b fi ly lz l ma mb">const widthScale = d3.scaleLinear()<br/>const ticker = 500;<br/>const axisTop = svg<br/>                .append('g')<br/>                .classed('axis', true)<br/>                .style("transform", "translate(10px, 20px)")<br/>                .call(d3.axisTop(widthScale))</span></pre><p id="80cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在更新功能中，过渡到新的<code class="du mc md me lt b">axisTop</code></p><pre class="jo jp jq jr fd ls lt lu lv aw lw bi"><span id="b2ea" class="lx kp hi lt b fi ly lz l ma mb">const update = (date) =&gt;  { <br/>   ....<br/>   ....</span><span id="5378" class="lx kp hi lt b fi nc lz l ma mb">    widthScale<br/>     .domain([0, d3.max(Object.values(presentData), d =&gt; d.value)])<br/>     .range([0, width - fontSize - 50])</span><span id="c268" class="lx kp hi lt b fi nc lz l ma mb">    axisTop                <br/>        .transition()<br/>        .duration(ticker / 1.2)<br/>        .ease(d3.easeLinear)<br/>        .call(d3.axisTop(widthScale))</span><span id="7aa9" class="lx kp hi lt b fi nc lz l ma mb">    ....<br/>    ....<br/>}</span></pre><p id="7618" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出将会是</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/a058942d17b8e58b32e53a657460f3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/1*U8khvkWEEichuIAZIwYaNg.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">赛车条形图 d3js 教程</figcaption></figure><p id="6e00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以去调整位置，动画速度和改变动画功能。添加更多细节，如标题和日期显示等。</p><h2 id="2767" class="lx kp hi bd kq mg mh mi ku mj mk ml ky jb mm mn lc jf mo mp lg jj mq mr lk ms bi translated">最终代码</h2><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="nd jt l"/></div></figure><h1 id="6b51" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">最后</h1><p id="8240" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">当您拥有的数据在所有日期都一致时，这一切都很酷。不会一直这样的。对于我们在 CLL 的项目，在世界数据中，第一个月的数据只包括中国，以后的数据包括更多的国家。对于这类数据，我们要么填写该日期的所有国家。这意味着，你必须正确地映射所有的国家及其名称。另一种方法是按国家而不是日期对所有数据进行分组，并将所有日期数据绑定到各自的元素，但这将把大量数据绑定到每个元素。然后根据日期制作动画。如果你也想看这篇文章，请在回复中告诉我，我会写一篇新文章或者更新同一篇文章。</p><h1 id="8430" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">谢谢你</h1><p id="4589" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">感谢所有阅读我的文章的人，也感谢<a class="nh ni ge" href="https://medium.com/u/1556949f4866?source=post_page-----d89b71cd3439--------------------------------" rel="noopener" target="_blank">共同学习休息室</a>和<a class="nh ni ge" href="https://medium.com/u/d310856a9437?source=post_page-----d89b71cd3439--------------------------------" rel="noopener" target="_blank"> Yogesh Kothiya </a>、<a class="nh ni ge" href="https://medium.com/u/613cc67b32af?source=post_page-----d89b71cd3439--------------------------------" rel="noopener" target="_blank"> Dhruv Kumar Patwari </a>协调并帮助建立这个项目。</p></div></div>    
</body>
</html>