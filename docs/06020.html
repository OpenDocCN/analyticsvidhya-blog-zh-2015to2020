<html>
<head>
<title>Python Decorators- A Weapon To Be Mastered</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python装饰者——需要掌握的武器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-decorators-a-weapon-to-be-mastered-be310b519ac5?source=collection_archive---------0-----------------------#2020-05-09">https://medium.com/analytics-vidhya/python-decorators-a-weapon-to-be-mastered-be310b519ac5?source=collection_archive---------0-----------------------#2020-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d905fb4a63946a0ffcdd1b9b966a6cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLccyedpH0sd2h2Wnx6kEg.jpeg"/></div></div></figure><p id="981e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好Pythonist！。在这篇文章中，我们将学习Python Decorators。我想让你知道并感受一下简单python函数的威力，以及它们是如何让Decorator成为Python如此美丽的特性的，而不是直接跳到它的工作上。</p><p id="47aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python函数拥有三种能力，这就是为什么它们被称为<strong class="is hj"> <em class="jo">【第一类对象】</em> </strong>。</p><p id="0407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那些能力是什么？他们能做什么？让我看看-</p><ol class=""><li id="9acf" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">你可以把它们分配给变量- </strong></li></ol><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="aef2" class="kh ki hi kd b fi kj kk l kl km">def parent():<br/>    print("Inside parent function")</span><span id="23e0" class="kh ki hi kd b fi kn kk l kl km">fun=parent</span><span id="dd0f" class="kh ki hi kd b fi kn kk l kl km">fun()</span><span id="d188" class="kh ki hi kd b fi kn kk l kl km">&gt;&gt; <br/>Inside parent function</span></pre><p id="3537" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">这里“fun”变量保存了父函数的引用，而赋值父函数没有被调用。现在可以调用“fun”变量作为执行父函数</em>的函数</p><p id="8529" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。它们可以作为值传递给其他函数</strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="b8be" class="kh ki hi kd b fi kj kk l kl km">def neighbor():<br/>   print("Hey, I am neighbor")</span><span id="d8d2" class="kh ki hi kd b fi kn kk l kl km">def parent(func):<br/>   print("hi there!")<br/>   func()</span><span id="8607" class="kh ki hi kd b fi kn kk l kl km">fun=parent<br/>fun(neighbor)</span><span id="c193" class="kh ki hi kd b fi kn kk l kl km">&gt;&gt;<br/>hi there!<br/>Hey, I am neighbor</span></pre><p id="cbe8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">这里“neighbor”作为值传递给“parent”函数，然后在其中调用。</em></p><p id="2b75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。它们可以作为其他函数的值返回</strong></p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="e9b8" class="kh ki hi kd b fi kj kk l kl km">def neighbor():<br/>   print("Hey, I am neighbor, where is your son?")<br/>   return 1</span><span id="a621" class="kh ki hi kd b fi kn kk l kl km">def parent(func):<br/>   print("hi there!")<br/>   call = func()</span><span id="07ee" class="kh ki hi kd b fi kn kk l kl km">   # nested function<br/>   def son():<br/>      print("Hi neighbor, I am his son")</span><span id="e813" class="kh ki hi kd b fi kn kk l kl km">   # nested function<br/>   def daughter():<br/>      print("Hi neighbor, I am his daughter")<br/>   <br/>   if call == 1:<br/>      return son<br/>   else:<br/>      return daughter</span><span id="3ffd" class="kh ki hi kd b fi kn kk l kl km">fun=parent</span><span id="d8b4" class="kh ki hi kd b fi kn kk l kl km">child = fun(neighbor) # returns reference of nested function</span><span id="f6ae" class="kh ki hi kd b fi kn kk l kl km">&gt;&gt;<br/>hi there!<br/>Hey, I am neighbor, where is your son?</span><span id="6631" class="kh ki hi kd b fi kn kk l kl km"><br/>child() # nested function "son" gets called<br/>&gt;&gt;<br/>Hi neighbor, I am his son</span></pre><p id="7378" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">这里我们在父函数中定义了两个嵌套函数，即“儿子”和“女儿”。这种嵌套函数既不能从外部直接调用，也不能在外部函数被调用时自动执行。但是我们可以在外部函数之外返回它们的引用，这样它们就可以从外部被调用。</em></p><blockquote class="ko"><p id="162c" class="kp kq hi bd kr ks kt ku kv kw kx jn dx translated">python函数的这三种能力是最有用和最强大的武器(即装饰者)的成分。</p></blockquote><blockquote class="ky kz la"><p id="3d45" class="iq ir jo is b it lb iv iw ix lc iz ja ld le jd je lf lg jh ji lh li jl jm jn hb bi translated">没错，是Python Devs击落很多问题的利器！！！</p></blockquote><p id="930e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住这三个要素，它会帮助你在我们前进的时候理解装饰者。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="5cdc" class="lq ki hi bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><span class="l mn mo mp bm mq mr ms mt mu di"> W </span>什么是装饰工？</h1><blockquote class="ko"><p id="03cb" class="kp kq hi bd kr ks kt ku kv kw kx jn dx translated">教科书定义-装饰器是接受另一个可调用函数(函数、方法和类)并扩展其行为而不显式修改它的函数。</p><p id="7061" class="kp kq hi bd kr ks kt ku kv kw kx jn dx translated">通俗地说——装饰者包装一个可调用对象，修改它的行为。</p></blockquote><p id="1105" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb le jd je jf lg jh ji jj li jl jm jn hb bi translated">听起来有趣吗？</p><p id="55a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个简单的装饰者的例子</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="3419" class="kh ki hi kd b fi kj kk l kl km">def decorator(func):<br/>    def wrapper():<br/>      print("Before the function gets called.")<br/>      func()<br/>      print("After the function is executed.")<br/>    return wrapper</span><span id="7fa3" class="kh ki hi kd b fi kn kk l kl km">def wrap_me():<br/>    print("Hello Decorators!")</span><span id="fa4a" class="kh ki hi kd b fi kn kk l kl km">wrap_me = decorator(wrap_me)<br/>wrap_me()</span><span id="7c42" class="kh ki hi kd b fi kn kk l kl km">&gt;&gt;<br/>Before the function gets called<br/>Hello Decorators!<br/>After the function is executed</span></pre><h1 id="e02b" class="lq ki hi bd lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi mz mk ml mm bi translated">它是如何工作的？</h1><p id="574d" class="pw-post-body-paragraph iq ir hi is b it na iv iw ix nb iz ja jb nc jd je jf nd jh ji jj ne jl jm jn hb bi translated">在上面的例子中，我们看到了python函数的所有三种功能。</p><p id="4127" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过传递函数<em class="jo"> wrap_me </em>来调用<em class="jo">装饰器</em>。当<em class="jo">装饰器</em>被调用时；<em class="jo">包装器</em>函数被定义为保存<em class="jo"> wrap_me </em>(一个闭包)的引用，并使用它来包装输入函数(即<em class="jo"> wrap_me </em>)，以便在调用时修改其行为。</p><blockquote class="ky kz la"><p id="5a19" class="iq ir jo is b it iu iv iw ix iy iz ja ld jc jd je lf jg jh ji lh jk jl jm jn hb bi translated">什么是终结？-</p><p id="97c4" class="iq ir jo is b it iu iv iw ix iy iz ja ld jc jd je lf jg jh ji lh jk jl jm jn hb bi translated">将一些数据(在我们的例子中是“wrap_me”函数引用)附加到代码上的技术在Python  中被称为<a class="ae nf" rel="noopener" href="/@amitrandive442/python-closures-b71e8847286f"> <strong class="is hj">闭包。</strong></a></p><p id="88a3" class="iq ir jo is b it iu iv iw ix iy iz ja ld jc jd je lf jg jh ji lh jk jl jm jn hb bi translated">即使变量超出范围，封闭范围内的值也会被记住。</p></blockquote><p id="8fdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包装闭包可以访问未修饰的输入函数，并且可以在调用输入函数之前和之后自由地执行额外的代码。</p><p id="0009" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">装饰器</em>返回由<em class="jo"> wrap_me </em>变量捕获的<em class="jo">包装器</em>函数的引用，当我们调用它时，我们将实际调用<em class="jo">包装器</em>函数。</p><p id="56d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，嵌套函数被执行，并在原始<em class="jo"> wrap_me </em>函数调用前后执行指令。</p><blockquote class="ky kz la"><p id="d8c9" class="iq ir jo is b it iu iv iw ix iy iz ja ld jc jd je lf jg jh ji lh jk jl jm jn hb bi translated">这可能感觉有点沉重，但一旦你完全理解这是如何工作的，你一定会爱上it❤</p></blockquote></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="e1b3" class="lq ki hi bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">@ (Pi)语法</h1><p id="589e" class="pw-post-body-paragraph iq ir hi is b it na iv iw ix nb iz ja jb nc jd je jf nd jh ji jj ne jl jm jn hb bi translated">您可以使用Python的@ (pi)语法，而不是在wrap_me上调用decorator并重新分配<em class="jo"> wrap_me </em>变量。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="b402" class="kh ki hi kd b fi kj kk l kl km">def decorator(func):<br/>    def wrapper():<br/>      print("Before the function gets called.")<br/>      func()<br/>      print("After the function is executed.")<br/>    return wrapper</span><span id="1fa8" class="kh ki hi kd b fi kn kk l kl km">@decorator<br/>def wrap_me():<br/>    print("Hello Decorators!")</span><span id="e4cc" class="kh ki hi kd b fi kn kk l kl km">wrap_me()</span><span id="fc1c" class="kh ki hi kd b fi kn kk l kl km">&gt;&gt;<br/>Before the function gets called<br/>Hello Decorators!<br/>After the function is executed</span></pre><p id="9e72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用@ syntax只是添加了语法糖来实现这种常用的模式或简写来调用输入函数上的装饰器。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="99e8" class="lq ki hi bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">接受论点的装饰者-</h1><p id="f586" class="pw-post-body-paragraph iq ir hi is b it na iv iw ix nb iz ja jb nc jd je jf nd jh ji jj ne jl jm jn hb bi translated">现在，任何人都可能会问的一个明显的问题是——“我如何将装饰器应用于接受参数的函数？”</p><p id="a9f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python允许这样做，而且非常简单。你还记得我们有类似于<em class="jo"> *args </em>和<em class="jo"> **kwargs </em>的东西来处理可变数量的参数吗？</p><p id="7812" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！这两个人随时准备帮忙。</p><p id="a469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们写一个装饰器来记录函数参数信息-</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="1d2b" class="kh ki hi kd b fi kj kk l kl km">def dump_args(func):<br/>  def wrapper(*args,**kwargs):<br/>      print(f'{args}, {kwargs}')<br/>      func(*args, **kwargs)<br/>  return wrapper</span><span id="9315" class="kh ki hi kd b fi kn kk l kl km">@dump_args<br/>def wrap_me(arg1,arg2):<br/>    print(f"Arguments dumped")</span><span id="5aa5" class="kh ki hi kd b fi kn kk l kl km">wrap_me("arg_dump1","arg_dump2")</span><span id="bdbe" class="kh ki hi kd b fi kn kk l kl km">&gt;&gt;<br/>('arg_dump1', 'arg_dump2'), {}<br/>Arguments dumped</span></pre><p id="0554" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它使用<em class="jo">包装器</em>定义中的*和**操作符来收集所有位置和关键字参数，并将它们分别存储在变量args和kwargs中，然后转发给输入函数(即wrap_me)。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="81e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">装饰者是可重用的。这意味着你可以对多个函数使用同一个装饰器。你也可以从其他模块导入它。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="49f8" class="lq ki hi bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">堆叠装饰者</h1><p id="f7ba" class="pw-post-body-paragraph iq ir hi is b it na iv iw ix nb iz ja jb nc jd je jf nd jh ji jj ne jl jm jn hb bi translated">多个装饰器可以用于一个功能。</p><p id="747b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，假设我们需要记录函数的执行时间和参数-</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="9c13" class="kh ki hi kd b fi kj kk l kl km">import datetime</span><span id="0f67" class="kh ki hi kd b fi kn kk l kl km">def dump_args(func):<br/>   def wrapper(*args,**kwargs):<br/>       print(f'{func.__name__} has arguments - {args}, {kwargs}')<br/>       func(*args, **kwargs)<br/>   return wrapper</span><span id="8ede" class="kh ki hi kd b fi kn kk l kl km">def cal_time(func):<br/>   def wrapper(*args,**kwargs):<br/>       now = datetime.datetime.now()<br/>       print("start of execution : ",  now.strftime("%d/%m/%Y %H:%M:%S"))<br/>       func(*args,**kwargs)<br/>       now = datetime.datetime.now()<br/>       print("end of execution : ",  now.strftime("%d/%m/%Y %H:%M:%S"))<br/>  return wrapper</span><span id="7cff" class="kh ki hi kd b fi kn kk l kl km">@cal_time<br/>@dump_args<br/>def wrap_me(arg1,arg2):<br/>   print("Arguments dumped")</span><span id="1477" class="kh ki hi kd b fi kn kk l kl km">wrap_me("arg_dump1","arg_dump2")</span></pre><p id="41f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们在<em class="jo"> wrap_me </em>函数上堆叠了两个装饰器。想想现在会是什么行为？</p><p id="64c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事情是这样的-</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="9545" class="kh ki hi kd b fi kj kk l kl km">&gt;&gt;start of execution : 08/05/2020 21:13:11<br/>wrap_me has arguments - ('arg_dump1', 'arg_dump2'), {}<br/>Arguments dumped<br/>end of execution : 08/05/2020 21:13:11</span></pre><p id="a628" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">装饰者是自下而上的。首先，输入函数被<em class="jo"> @dump_args </em>装饰器包装，然后产生的(装饰的)函数被<em class="jo"> @cal_time </em>装饰器再次包装。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="26b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在实际的可调用执行之前，你需要执行的任何通用功能，只要简单地把它写成decorator，并把它放在特定的可调用上。</p><p id="a1ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如</p><p id="eb5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">测井</em></p><p id="bbd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">强制认证</em></p><p id="89c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">计算功能性能</em></p><ul class=""><li id="25c3" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ng jv jw jx bi translated"><em class="jo">缓存等。</em></li></ul><p id="6b3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我前面说过的，decorators是可重用的构建模块，使这个特性更加强大，它经常被用于标准库和第三方库中。</p><p id="1df1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在编写面向对象的Python代码时，你经常会遇到<em class="jo"> @staticmethod、@abstractmethod、@classmethod </em>对吗？现在你知道它们的真正含义了。当我们将它应用于任何函数时，试着探究一下这个装饰器到底做了什么。</p><p id="cc9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，装饰不应该被过度使用，因为它不能解决所有问题，但如果你知道何时何地使用它，它们是非常有用的。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="f7f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果你到达这里并且理解了这篇文章中的一切，那么<em class="jo">祝贺你！！</em>你刚刚学到了Python中最难的一个概念。</strong></p><p id="72eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">干杯！！</strong></p></div></div>    
</body>
</html>