<html>
<head>
<title>Learn Numpy by Playing — Concepts, Indexing, Vectorization and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过游戏学习数字——概念、索引、矢量化等等</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/learn-numpy-by-playing-concepts-indexing-vectorization-and-more-efea45485f19?source=collection_archive---------8-----------------------#2019-11-08">https://medium.com/analytics-vidhya/learn-numpy-by-playing-concepts-indexing-vectorization-and-more-efea45485f19?source=collection_archive---------8-----------------------#2019-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bffb5743db810acbdd5c33aebe66ca50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kXmvy4nOsNxfDHa0bwTAg.jpeg"/></div></div></figure><h1 id="16c8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="584a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个博客旨在成为初学者通过尝试真实代码来学习numpy的游乐场。我尽可能少地使用文本内容，尽可能多地使用代码示例。</p><p id="fb21" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这也是你已经了解的numpy特性的<strong class="jq hj">快速未来参考指南</strong>。每个单元的输出都有描述结果的细节。</p><h2 id="8893" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">先决条件</h2><ul class=""><li id="c3e0" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">基本编程知识</li><li id="9779" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">熟悉python(循环、数组等)。)</li></ul><h2 id="e6de" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">我们将涵盖哪些内容</h2><p id="2f9b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">基础</p><ul class=""><li id="4969" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated">创建数组</li><li id="bbab" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">了解Numpy数组的结构(维度、形状和步距)</li><li id="7393" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">数据类型和转换</li><li id="b405" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">索引方法</li><li id="7189" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">数组运算</li></ul><p id="0c49" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">预先的</p><ul class=""><li id="1a25" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated">广播</li><li id="37b7" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">…向量化…</li><li id="f6b5" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">Ufunc和Numba</li></ul><h2 id="3716" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">什么是Numpy？</h2><p id="1bc8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Numpy是python的基础计算库。它支持N维数组，并提供简单高效的数组操作。</p><p id="2ca5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">NumPy是用C语言编写的算法库，它将数据存储在连续的内存块中，独立于其他内置的python对象，并且可以在没有任何类型检查或其他Python开销的情况下对该内存进行操作。NumPy数组使用的内存也比内置Python序列少得多。</p><h2 id="9293" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">为什么要用Numpy？</h2><p id="d325" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Python最初不是为数值计算而设计的。由于python是解释型语言，它天生就比c等编译型语言慢。因此numpy填补了这一空白，以下是使用numpy的一些优势</p><ul class=""><li id="4866" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated">它在内存和计算方面提供了高效的多维数组操作</li><li id="4b71" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">它提供了对整个数组的快速数学运算，而不需要使用循环</li><li id="3b32" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">它还提供与线性代数、统计学、傅立叶变换等相关的科学运算</li><li id="6816" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">它为c和c++的互操作性提供了工具</li></ul><h2 id="b1ae" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">Numpy怎么玩？</h2><p id="44f9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我将推荐两种使用Numpy的方法</p><ul class=""><li id="aa3a" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated"><a class="ae lw" href="https://www.kaggle.com/notebooks" rel="noopener ugc nofollow" target="_blank"> kaggle </a>或<a class="ae lw" href="https://colab.research.google.com/notebooks/intro.ipynb#" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>:你可以直接进入编码，不需要任何设置</li><li id="6974" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><a class="ae lw" href="https://jupyter.org/install" rel="noopener ugc nofollow" target="_blank"> Jupyter Notebook </a>:您需要安装Jupyter Notebook，然后<a class="ae lw" href="https://pypi.org/project/numpy/" rel="noopener ugc nofollow" target="_blank">使用pip安装numpy </a>库(如果您有anaconda或miniconda，numpy可能已经安装)</li></ul><h2 id="259e" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">遵循本教程</h2><p id="c3ff" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">你可以在kaggle或google colab上分别通过分叉或复制以下笔记本来尝试这个教程</p><blockquote class="lx ly lz"><p id="bd77" class="jo jp ma jq b jr km jt ju jv kn jx jy mb ko kb kc mc kp kf kg md kq kj kk kl hb bi translated"><strong class="jq hj">叉本</strong> <a class="ae lw" href="https://www.kaggle.com/devkhadka/numpy-guide-book-for-beginners" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi"> kaggle笔记本</em> </strong> </a></p><p id="0c2d" class="jo jp ma jq b jr km jt ju jv kn jx jy mb ko kb kc mc kp kf kg md kq kj kk kl hb bi translated">或者</p><p id="e11c" class="jo jp ma jq b jr km jt ju jv kn jx jy mb ko kb kc mc kp kf kg md kq kj kk kl hb bi translated"><strong class="jq hj">复制本</strong> <a class="ae lw" href="https://colab.research.google.com/drive/1RFpHPJ5ZzK2VHjgJP-o6WSOtM_SXnjbq" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi"> colab笔记本</em> </strong> </a></p></blockquote><h2 id="1db1" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">关于Jupyter笔记本的一些提示</h2><ul class=""><li id="20da" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">要查看自动完成建议<strong class="jq hj">,请按</strong> <code class="du me mf mg mh b"><strong class="jq hj">tab</strong></code></li><li id="650f" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">要查看功能<strong class="jq hj">的参数，在输入功能名称和'('后按</strong> <code class="du me mf mg mh b"><strong class="jq hj">shift + tab</strong></code>。键入<code class="du me mf mg mh b">np.asarray(</code>，然后按下<code class="du me mf mg mh b">shift + tab</code></li><li id="1b65" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">要查看文档字符串，请使用“？”喜欢<code class="du me mf mg mh b"><strong class="jq hj">np.asarray?</strong></code>然后按<code class="du me mf mg mh b"><strong class="jq hj">shift + enter</strong></code></li></ul><p id="e544" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">看够了！！</strong> <strong class="jq hj"> <em class="ma">让我们把手弄脏</em> </strong></p><h1 id="e49e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建数组</h1><h2 id="eecc" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">来自python列表</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="2dfa" class="kr ir hi mh b fi mq mr l ms mt"><strong class="mh hj">import</strong> <strong class="mh hj">numpy</strong> <strong class="mh hj">as</strong> <strong class="mh hj">np</strong><br/>print(np.array([1,2,3,4]))</span><span id="7147" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'array of 16 bit integers')<br/>print(np.array([1,2,3,4], dtype=np.int16))</span><span id="a89e" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', '2 dimensional array')<br/>print(np.array([[1,2,3], [4,5,6]]))</span></pre><p id="6332" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="3d8c" class="kr ir hi mh b fi mq mr l ms mt">[1 2 3 4]</span><span id="c977" class="kr ir hi mh b fi mu mr l ms mt">array of 16 bit integers<br/>[1 2 3 4]</span><span id="2c31" class="kr ir hi mh b fi mu mr l ms mt">2 dimensional array<br/>[[1 2 3]<br/> [4 5 6]]</span></pre><h2 id="ccbd" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">努皮方法</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="3913" class="kr ir hi mh b fi mq mr l ms mt">print('Numpy array from range')<br/>print(np.arange(3,8))</span><span id="ac46" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', '2D 3X3 array of zeros')<br/>print(np.zeros((3,3)))</span><span id="368d" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', '2D 2X3 array of ones')<br/>print(np.ones((2,3)))</span><span id="f780" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'Triangular array with ones at and below diagonal')<br/>print(np.tri(3, 4))</span><span id="541f" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'Index matrix with ones at diagonal')<br/>print(np.eye(3))</span><span id="7c30" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', '20 equally spaced values between 1 and 5')<br/>print(np.linspace(1, 5, 20))</span></pre><p id="a554" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="b822" class="kr ir hi mh b fi mq mr l ms mt">Numpy array from range<br/>[3 4 5 6 7]</span><span id="8fb8" class="kr ir hi mh b fi mu mr l ms mt">2D 3X3 array of zeros<br/>[[0. 0. 0.]<br/> [0. 0. 0.]<br/> [0. 0. 0.]]</span><span id="450f" class="kr ir hi mh b fi mu mr l ms mt">2D 2X3 array of ones<br/>[[1. 1. 1.]<br/> [1. 1. 1.]]</span><span id="0f5a" class="kr ir hi mh b fi mu mr l ms mt">Triangular array with ones at and below diagonal<br/>[[1. 0. 0. 0.]<br/> [1. 1. 0. 0.]<br/> [1. 1. 1. 0.]]</span><span id="4872" class="kr ir hi mh b fi mu mr l ms mt">Index matrix with ones at diagonal<br/>[[1. 0. 0.]<br/> [0. 1. 0.]<br/> [0. 0. 1.]]</span><span id="302f" class="kr ir hi mh b fi mu mr l ms mt">20 equally spaced values between 1 and 5<br/>[1.         1.21052632 1.42105263 1.63157895 1.84210526 2.05263158<br/> 2.26315789 2.47368421 2.68421053 2.89473684 3.10526316 3.31578947<br/> 3.52631579 3.73684211 3.94736842 4.15789474 4.36842105 4.57894737<br/> 4.78947368 5.        ]</span></pre><h2 id="1ac4" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">使用<code class="du me mf mg mh b">np.random</code></h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="0be1" class="kr ir hi mh b fi mq mr l ms mt">print('3X2 array of uniformly distributed number between 0 and 1')<br/>print(np.random.rand(3,2))</span><span id="5b60" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'Normally distributed random numbers with mean=0 and std=1')<br/>print(np.random.randn(3,3))</span><span id="44bf" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'Randomly choose integers from a range (&gt;=5, &lt;11)')<br/>print(np.random.randint(5, 11, size=(2,2)))</span><span id="fc5d" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', "Randomly selects a permutation from array")<br/>print(np.random.permutation([2,3,4,5,6]))</span><span id="731c" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', "This is equivalent to rolling dice 10 times and counting <strong class="mh hj">\</strong><br/>occurance of getting each side")<br/>print(np.random.multinomial(10, [1/6]*6))</span></pre><p id="6604" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="6a01" class="kr ir hi mh b fi mq mr l ms mt">3X2 array of uniformly distributed number between 0 and 1<br/>[[0.99718301 0.46455866]<br/> [0.12057951 0.95932211]<br/> [0.22538176 0.99273413]]</span><span id="3433" class="kr ir hi mh b fi mu mr l ms mt">Normally distributed random numbers with mean=0 and std=1<br/>[[-0.53815353  1.58638922  0.81410291]<br/> [ 0.01157038 -0.03269712 -1.16455499]<br/> [-0.3351507  -0.05698716  0.10403848]]</span><span id="5170" class="kr ir hi mh b fi mu mr l ms mt">Randomly choose integers from a range (&gt;=5, &lt;11)<br/>[[ 7  9]<br/> [ 6 10]]</span><span id="7b73" class="kr ir hi mh b fi mu mr l ms mt">Randomly selects a permutation from array<br/>[3 4 2 5 6]</span><span id="afb1" class="kr ir hi mh b fi mu mr l ms mt">This is equivalent to rolling dice 10 times and counting occurance of getting each side<br/>[3 4 1 2 0 0]</span></pre><h2 id="397d" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">了解Numpy数组的结构(维度、形状和步距)</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="0341" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np<br/>arr = np.array([[1,2,3], [2,3,1], [3,3,3]])</span><span id="4bd3" class="kr ir hi mh b fi mu mr l ms mt">print('Number of array dimensions')<br/>print(arr.ndim)</span><span id="cbdf" class="kr ir hi mh b fi mu mr l ms mt">print('\nShape of array is tuple giving size of each dimension')<br/>print(arr.shape)</span><span id="7b4d" class="kr ir hi mh b fi mu mr l ms mt">print('\nstrides gives byte steps to be moved in memory to get to next \<br/>index in each dimension')<br/>print(arr.strides)</span><span id="765d" class="kr ir hi mh b fi mu mr l ms mt">print('\nByte size of each item')<br/>print(arr.itemsize)</span></pre><p id="8222" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="d33d" class="kr ir hi mh b fi mq mr l ms mt">Number of array dimensions<br/>2</span><span id="8c10" class="kr ir hi mh b fi mu mr l ms mt">Shape of array is tuple giving size of each dimension<br/>(3, 3)</span><span id="c737" class="kr ir hi mh b fi mu mr l ms mt">strides gives byte steps to be moved in memory to get to next index in each dimension<br/>(24, 8)</span><span id="2e17" class="kr ir hi mh b fi mu mr l ms mt">Byte size of each item<br/>8</span></pre><h2 id="a761" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">更多关于跨步</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c4a2" class="kr ir hi mh b fi mq mr l ms mt">print('Slice indexing is done by changing strides, as in examples below')</span><span id="7898" class="kr ir hi mh b fi mu mr l ms mt">print('Strides of original array')<br/>print(arr.strides)</span><span id="8f0f" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Slice with step of 2 is done by multiplying stride(byte step size) by 2 in that dimension')<br/>print(arr[::2].strides)</span><span id="4435" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Reverse index will negate the stride')<br/>print(arr[::-1].strides)</span><span id="7d7f" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Transpose will swap the stride of the dimensions')<br/>print(arr.T.strides)</span></pre><p id="2622" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="9449" class="kr ir hi mh b fi mq mr l ms mt">Slice indexing is done by changing strides, as in examples below<br/>Strides of original array<br/>(24, 8)</span><span id="d1e8" class="kr ir hi mh b fi mu mr l ms mt">Slice with step of 2 is done by multiplying stride(byte step size) by 2 in that dimension<br/>(48, 8)</span><span id="7967" class="kr ir hi mh b fi mu mr l ms mt">Reverse index will negate the stride<br/>(-24, 8)</span><span id="6e0f" class="kr ir hi mh b fi mu mr l ms mt">Transpose will swap the stride of the dimensions<br/>(8, 24)</span></pre><h2 id="ae6a" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">一些步幅技巧:改变步幅的内积</h2><p id="07aa" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您可能很少想要使用这些技巧，但是它有助于我们理解numpy中的索引是如何工作的</p><p id="8418" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du me mf mg mh b">as_strided</code>函数返回一个具有不同步幅和形状的数组视图</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="a846" class="kr ir hi mh b fi mq mr l ms mt">from numpy.lib.stride_tricks import as_strided</span><span id="f2e5" class="kr ir hi mh b fi mu mr l ms mt">arr1 = np.arange(5)<br/>print('arr1: ', arr1)</span><span id="ec0c" class="kr ir hi mh b fi mu mr l ms mt">arr2 = np.arange(3)<br/>print('arr2: ', arr2)</span><span id="5242" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Adding a dimension with stride 0 allows us to repeat array in that dimension without making copy')</span><span id="93ba" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Making stride 0 for rows repeats rows.')<br/>print('As step size is zero to move to next row it will give same row repeatedly')<br/>r_arr1 = as_strided(arr1, strides=(0,arr1.itemsize), shape=(len(arr2),len(arr1)))<br/>print(r_arr1)</span><span id="8586" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Making stride 0 for columns repeats columns.')<br/>r_arr2 = as_strided(arr1, strides=(arr2.itemsize, 0), shape=(len(arr2),len(arr1)))<br/>print(r_arr2, '\n')</span><span id="4f3a" class="kr ir hi mh b fi mu mr l ms mt">print('Inner product: product of every value of arr1 to every value of arr2')<br/>print(r_arr1 * r_arr2)</span></pre><p id="5c36" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="ff64" class="kr ir hi mh b fi mq mr l ms mt">arr1:  [0 1 2 3 4]<br/>arr2:  [0 1 2]</span><span id="72ab" class="kr ir hi mh b fi mu mr l ms mt">Adding a dimension with stride 0 allows us to repeat array in that dimension without making copy</span><span id="417c" class="kr ir hi mh b fi mu mr l ms mt">Making stride 0 for rows repeats rows.<br/>As step size is zero to move to next row it will give same row repeatedly<br/>[[0 1 2 3 4]<br/> [0 1 2 3 4]<br/> [0 1 2 3 4]]</span><span id="aad5" class="kr ir hi mh b fi mu mr l ms mt">Making stride 0 for columns repeats columns.<br/>[[0 0 0 0 0]<br/> [1 1 1 1 1]<br/> [2 2 2 2 2]]</span><span id="90ad" class="kr ir hi mh b fi mu mr l ms mt">Inner product: product of every value of arr1 to every value of arr2<br/>[[0 0 0 0 0]<br/> [0 1 2 3 4]<br/> [0 2 4 6 8]]</span></pre><p id="a64a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">利用广播</strong></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="d61a" class="kr ir hi mh b fi mq mr l ms mt">print('Above example is equivalent to using broadcast to do inner product')<br/>print(arr1[np.newaxis, :] * arr2[:, np.newaxis])</span><span id="658b" class="kr ir hi mh b fi mu mr l ms mt">print('arr1[np.newaxis, :].strides =&gt; ', arr1[np.newaxis, :].strides)<br/>print('arr2[:, np.newaxis].strides =&gt; ', arr2[:, np.newaxis].strides)</span></pre><p id="5025" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="f85e" class="kr ir hi mh b fi mq mr l ms mt">Above example is equivalent to using broadcast to do inner product<br/>[[0 0 0 0 0]<br/> [0 1 2 3 4]<br/> [0 2 4 6 8]]<br/>arr1[np.newaxis, :].strides =&gt;  (0, 8)<br/>arr2[:, np.newaxis].strides =&gt;  (8, 0)</span></pre><h1 id="4296" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数据类型和转换</h1><p id="3677" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">注释</strong></p><ul class=""><li id="ffb5" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated">Numpy数组只能存储一种数据类型的项</li><li id="e893" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b">np_array.dtype</code>属性将给出数组的dtype</li><li id="0818" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">下表显示了一些常见的数据类型及其字符串名称</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c424" class="kr ir hi mh b fi mq mr l ms mt">Numpy Attribute                                 | String Name                | Description<br/>------------------------------------------------------------------------------------------------------<br/>np.int8, np.int16, np.int32, np.int64           | '&lt;i1', '&lt;i2', '&lt;i4', '&lt;i8' | signed int<br/>np.uint8, np.uint16, np.uint32, np.uint64       | '&lt;u1', '&lt;u2', '&lt;u4', '&lt;u8' | unsigned int<br/>np.float16, np.float32, np.float64, np.float128 | '&lt;f2', '&lt;f4', '&lt;f8', '&lt;f16'| floats<br/>np.string_                                      |'S1', 'S10', 'S255'         | string of bytes (ascii)<br/>np.str                                          |'U1', 'U255'                | string of unicode characters<br/>np.datetime64                                   |'M8'                        | date time<br/>np.Object                                       |'O'                         | python object<br/>np.bool                                         |'?'                         | boolean</span></pre><ul class=""><li id="a225" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated"><strong class="jq hj">分解字符串名'&lt; u8': </strong>这里'&lt;'表示小端字节顺序，' u '表示无符号整数，' 8 '表示8个字节。字节顺序的其他选项有'&gt;'大端'和' = '系统默认值</li><li id="2ea5" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">上面讨论的所有数组初始化函数都采用“dtype”参数来设置数组的数据类型，例如:<code class="du me mf mg mh b">np.random.randint(5, 11, size=(2,2), dtype=np.int8)</code></li></ul><h2 id="80fd" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">铸造</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="1860" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np<br/>arr = np.arange(5, dtype='&lt;f4')<br/>print('arr: ', arr)</span><span id="93c8" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Cast to integer using astype function which will make copy of the array')<br/>display(arr.astype(np.int8))</span><span id="b6ae" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'By default casting is unsafe which will ignore the overflow. e.g. `2e10` is converted to 0')<br/>arr[3] = 2e10<br/>print(arr.astype('&lt;i1'))</span><span id="c59b" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Casting from string to float')<br/>sarr = np.array("1 2 3 4 5.0".split())<br/>print(sarr)<br/>print(sarr.astype('&lt;f4'))</span><span id="b7ca" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Use casting="safe" for doing safe casting, which will raise error if overflow')<br/><em class="ma"># print(arr.astype('&lt;i1', casting='safe'))</em></span></pre><p id="76e7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="49c1" class="kr ir hi mh b fi mq mr l ms mt">arr:  [0. 1. 2. 3. 4.]</span><span id="759a" class="kr ir hi mh b fi mu mr l ms mt">Cast to integer using astype function which will make copy of the array</span><span id="2b08" class="kr ir hi mh b fi mu mr l ms mt">array([0, 1, 2, 3, 4], dtype=int8)</span><span id="90cf" class="kr ir hi mh b fi mu mr l ms mt">By default casting is unsafe which will ignore the overflow. e.g. `2e10` is converted to 0<br/>[0 1 2 0 4]</span><span id="8883" class="kr ir hi mh b fi mu mr l ms mt">Casting from string to float<br/>['1' '2' '3' '4' '5.0']<br/>[1. 2. 3. 4. 5.]</span><span id="72b8" class="kr ir hi mh b fi mu mr l ms mt">Use casting="safe" for doing safe casting, which will raise error if overflow</span><span id="dea7" class="kr ir hi mh b fi mu mr l ms mt">---------------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>&lt;ipython-input-8-3f587ee2f6f0&gt; in &lt;module&gt;()<br/>     16 <br/>     17 print('\n', 'Use casting="safe" for doing safe casting, which will raise error if overflow')<br/>---&gt; 18 print(arr.astype('&lt;i1', casting='safe'))</span><span id="597b" class="kr ir hi mh b fi mu mr l ms mt">TypeError: Cannot cast array from dtype('float32') to dtype('int8') according to the rule 'safe'</span></pre><h2 id="6a44" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">重塑</h2><ul class=""><li id="5047" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">只要元素总数不变，数组就可以改变成任何形状</li></ul><p id="8c38" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在[9]中:</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="464f" class="kr ir hi mh b fi mq mr l ms mt">arr = np.arange(20)<br/>print('arr: ', arr)</span><span id="8ca4" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'reshape 1D arr of length 20 to shape (4,5)')<br/>print(arr.reshape(4,5))</span><span id="ea67" class="kr ir hi mh b fi mu mr l ms mt">print('<strong class="mh hj">\n</strong>', 'One item of shape tuple can be -1 in which case the item will be calculated by numpy')<br/>print('For total size to be 20 missing value must be 5')<br/>print(arr.reshape(2,2,-1))</span><span id="0688" class="kr ir hi mh b fi mu mr l ms mt">arr:  [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span><span id="2b60" class="kr ir hi mh b fi mu mr l ms mt"> reshape 1D arr of length 20 to shape (4,5)<br/>[[ 0  1  2  3  4]<br/> [ 5  6  7  8  9]<br/> [10 11 12 13 14]<br/> [15 16 17 18 19]]</span><span id="4ef0" class="kr ir hi mh b fi mu mr l ms mt"> One item of shape tuple can be -1 in which case the item will be calculated by numpy<br/>For total size to be 20 missing value must be 5<br/>[[[ 0  1  2  3  4]<br/>  [ 5  6  7  8  9]]</span><span id="7d82" class="kr ir hi mh b fi mu mr l ms mt"> [[10 11 12 13 14]<br/>  [15 16 17 18 19]]]</span></pre><h2 id="ccf5" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">具有不同数据类型的数组视图</h2><ul class=""><li id="e8cc" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated"><code class="du me mf mg mh b">arr.view()</code>方法用新的数据类型给出相同数据的新视图。用不同的数据类型创建视图与强制转换不同。例如，如果我们有NP . float 32(&lt;F4’)的ndarray，用dtype byte(&lt;i8’)创建视图将读取4字节浮点数据作为单个字节</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="0ed0" class="kr ir hi mh b fi mq mr l ms mt">arr = np.arange(5, dtype='&lt;i2')<br/>print('arr: ', arr)</span><span id="81f0" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'View with dtype "&lt;i1" for array of dtype "&lt;i2" will breakdown items to bytes')<br/>print(arr.view('&lt;i1'))</span><span id="84cb" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Changing little-endian to big-endian will change value as they use different byte order')<br/>print(arr.view('&gt;i2'))</span><span id="f2e6" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Following will give individual bytes in memory of each items')<br/>arr = np.arange(5, dtype='&lt;f2')<br/>print(arr)<br/>print(arr.view('&lt;i1'))</span></pre><p id="5a22" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c6d4" class="kr ir hi mh b fi mq mr l ms mt">arr:  [0 1 2 3 4]</span><span id="ec30" class="kr ir hi mh b fi mu mr l ms mt">View with dtype "&lt;i1" for array of dtype "&lt;i2" will breakdown items to bytes<br/>[0 0 1 0 2 0 3 0 4 0]</span><span id="779e" class="kr ir hi mh b fi mu mr l ms mt">Changing little-endian to big-endian will change value as they use different byte order<br/>[   0  256  512  768 1024]</span><span id="929d" class="kr ir hi mh b fi mu mr l ms mt">Following will give individual bytes in memory of each items<br/>[0. 1. 2. 3. 4.]<br/>[ 0  0  0 60  0 64  0 66  0 68]</span></pre><h1 id="3a0f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">索引方法</h1><h2 id="5390" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">整数和切片索引</h2><ul class=""><li id="3c42" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">这种索引方法类似于python list中使用的索引</li><li id="3aee" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">切片总是为数组ie创建视图。不复制数组</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="8953" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np<br/>arr = np.arange(20)<br/>print("arr: ", arr)</span><span id="ca7f" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Get item at index 4(5th item) of the array')<br/>print(arr[4])</span><span id="c7d2" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Assign 0 to index 4 of array')<br/>arr[4] = 0<br/>print(arr)</span><span id="0557" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Get items in the index range 4 to 10 not including 10')<br/>print(arr[4:10])</span><span id="4c43" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Set 1 to alternate items starting at index 4 to 10 ')<br/>arr[4:10:2] = 1<br/>print(arr)</span></pre><p id="0038" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="2dc1" class="kr ir hi mh b fi mq mr l ms mt">arr:  [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span><span id="9e63" class="kr ir hi mh b fi mu mr l ms mt">Get item at index 4(5th item) of the array<br/>4</span><span id="dfbd" class="kr ir hi mh b fi mu mr l ms mt">Assign 0 to index 4 of array<br/>[ 0  1  2  3  0  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span><span id="4321" class="kr ir hi mh b fi mu mr l ms mt">Get items in the index range 4 to 10 not including 10<br/>[0 5 6 7 8 9]</span><span id="30c1" class="kr ir hi mh b fi mu mr l ms mt">Set 1 to alternate items starting at index 4 to 10 <br/>[ 0  1  2  3  1  5  1  7  1  9 10 11 12 13 14 15 16 17 18 19]</span></pre><h2 id="43b8" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">2D数组中的切片索引</h2><ul class=""><li id="6a92" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">对于多维数组，切片索引可以用逗号分隔</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="e1c0" class="kr ir hi mh b fi mq mr l ms mt">arr = np.arange(20).reshape(4,5)</span><span id="991f" class="kr ir hi mh b fi mu mr l ms mt">print('arr:\n', arr)</span><span id="237e" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Set 0 to first 3 rows and and last 2 columns')<br/>arr[:3, -2:] = 1<br/>print(arr)</span></pre><p id="142a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c994" class="kr ir hi mh b fi mq mr l ms mt">arr:<br/> [[ 0  1  2  3  4]<br/> [ 5  6  7  8  9]<br/> [10 11 12 13 14]<br/> [15 16 17 18 19]]</span><span id="1749" class="kr ir hi mh b fi mu mr l ms mt">Set 0 to first 3 rows and and last 2 columns<br/>[[ 0  1  2  1  1]<br/> [ 5  6  7  1  1]<br/> [10 11 12  1  1]<br/> [15 16 17 18 19]]</span></pre><h2 id="1d43" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">布尔索引</h2><ul class=""><li id="ede6" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">与原始数组形状相同(或可扩展为该形状)的布尔数组可用作索引。这将选择索引值为真的项目</li><li id="7b53" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">布尔数组也可以用来过滤具有特定条件的数组</li><li id="f20c" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">布尔索引<strong class="jq hj">将向数组返回副本</strong>而不是视图</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="cfe0" class="kr ir hi mh b fi mq mr l ms mt">arr = np.arange(6).reshape(2,3)<br/>print('arr:\n', arr)</span><span id="3832" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Following index will gives last two items of 1st row and 1st element of 2nd row')<br/>indx = np.array([[False, True, True], [True, False,False]])<br/>arr[indx]</span><span id="fa98" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Boolean index to filter values greater than 3 from arr')<br/>filter_indx = arr&gt;3<br/>print('Filter Index:\n', filter_indx)</span><span id="6e1d" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Set 3 to values greater than 3 in arr')<br/>arr[filter_indx] = 3<br/>print(arr)</span></pre><p id="19da" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="a56e" class="kr ir hi mh b fi mq mr l ms mt">arr:<br/> [[0 1 2]<br/> [3 4 5]]</span><span id="8440" class="kr ir hi mh b fi mu mr l ms mt">Following index will gives last two items of 1st row and 1st element of 2nd row</span><span id="a3d3" class="kr ir hi mh b fi mu mr l ms mt">Boolean index to filter values greater than 3 from arr<br/>Filter Index:<br/> [[False False False]<br/> [False  True  True]]</span><span id="c675" class="kr ir hi mh b fi mu mr l ms mt">Set 3 to values greater than 3 in arr<br/>[[0 1 2]<br/> [3 3 3]]</span></pre><h2 id="dd05" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">花式索引</h2><ul class=""><li id="c69c" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">花式索引是指使用索引数组(整数)作为索引，以获得所有项目一次</li><li id="2bf1" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">花式索引<strong class="jq hj">也将返回副本</strong>而不是视图到数组</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="bc42" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np</span><span id="1a4e" class="kr ir hi mh b fi mu mr l ms mt">arr = np.arange(10)<br/>print('arr:\n', arr)</span><span id="a4af" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Get items at indexes 3,5 and 7 at once')<br/>print(arr[[3,5,7]])</span><span id="226a" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Sorting arr based on another array "values"')<br/>np.random.seed(5)<br/>values = np.random.rand(10)<br/>print('values:\n', values)<br/>print('\n', 'np.argsort instead of returning sorted values will return array of indexes which will sort the array')<br/>indexes = np.argsort(values) <br/>print('indexes:\n', indexes)<br/>print('Sorted array:\n', arr[indexes])</span><span id="80f8" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'You can also use fancy indexing to get same item multiple times')<br/>print(arr[[0,1,1,2,2,2,3,3,3,3]])</span></pre><p id="8ca8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="dcff" class="kr ir hi mh b fi mq mr l ms mt">arr:<br/> [0 1 2 3 4 5 6 7 8 9]</span><span id="d25f" class="kr ir hi mh b fi mu mr l ms mt">Get items at indexes 3,5 and 7 at once<br/>[3 5 7]</span><span id="55c3" class="kr ir hi mh b fi mu mr l ms mt">Sorting arr based on another array "values"<br/>values:<br/> [0.22199317 0.87073231 0.20671916 0.91861091 0.48841119 0.61174386<br/> 0.76590786 0.51841799 0.2968005  0.18772123]</span><span id="5234" class="kr ir hi mh b fi mu mr l ms mt">np.argsort instead of returning sorted values will return array of indexes which will sort the array<br/>indexes:<br/> [9 2 0 8 4 7 5 6 1 3]<br/>Sorted array:<br/> [9 2 0 8 4 7 5 6 1 3]</span><span id="78b0" class="kr ir hi mh b fi mu mr l ms mt">You can also use fancy indexing to get same item multiple times<br/>[0 1 1 2 2 2 3 3 3 3]</span></pre><h2 id="baf2" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">元组索引</h2><ul class=""><li id="1f5f" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">可以使用等长的整数数组元组来索引多维数组，其中元组中的每个数组将索引相应的维</li><li id="c12e" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">如果元组中索引数组的数量小于被索引数组的维度，则它们将被用于索引更低的维度(即从0到元组长度的维度)</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="8159" class="kr ir hi mh b fi mq mr l ms mt">arr2 = np.arange(15).reshape(5,3)<br/>print('arr2:\n', arr2)</span><span id="efef" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Will give items at index (4,0) and (1,2)')<br/>indx = ([4,1],[0,2])<br/>print(arr2[indx])</span><span id="ebb5" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Tuple of length one will return rows')<br/>indx = ([4,1],)<br/>print(arr2[indx])</span></pre><p id="f818" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="dc48" class="kr ir hi mh b fi mq mr l ms mt">arr2:<br/> [[ 0  1  2]<br/> [ 3  4  5]<br/> [ 6  7  8]<br/> [ 9 10 11]<br/> [12 13 14]]</span><span id="185f" class="kr ir hi mh b fi mu mr l ms mt">Will give items at index (4,0) and (1,2)<br/>[12  5]</span><span id="d985" class="kr ir hi mh b fi mu mr l ms mt">Tuple of length one will return rows<br/>[[12 13 14]<br/> [ 3  4  5]]</span></pre><h2 id="b411" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">带有高级索引的赋值</h2><ul class=""><li id="ecd2" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">高级索引(即布尔、花式和元组)将副本而不是视图返回到索引数组。但是使用那些索引直接赋值会改变原来的数组，这个特性是为了方便。但是，如果我们链接索引，它可能会以一种似乎有些出乎意料的方式运行</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="7516" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np</span><span id="a456" class="kr ir hi mh b fi mu mr l ms mt">arr = np.arange(10)<br/>print('arr: ', arr)</span><span id="5490" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Direct assignment will change the original array')<br/>arr[[3,5,7]] = -1<br/>print(arr)</span><span id="6cdc" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'When we chain the indexing it will not work')<br/>arr[[3,5,7]][0] = -2<br/>print(arr)</span><span id="2d3d" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'But chaining index will work with slicing indexing')<br/>arr[3:8:2][0] = -2<br/>print(arr)</span></pre><p id="3414" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="95cd" class="kr ir hi mh b fi mq mr l ms mt">arr:  [0 1 2 3 4 5 6 7 8 9]</span><span id="36fc" class="kr ir hi mh b fi mu mr l ms mt">Direct assignment will change the original array<br/>[ 0  1  2 -1  4 -1  6 -1  8  9]</span><span id="ffb0" class="kr ir hi mh b fi mu mr l ms mt">When we chain the indexing it will not work<br/>[ 0  1  2 -1  4 -1  6 -1  8  9]</span><span id="ae08" class="kr ir hi mh b fi mu mr l ms mt">But chaining index will work with slicing indexing<br/>[ 0  1  2 -2  4 -1  6 -1  8  9]</span></pre><h2 id="6f69" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">混合索引</h2><ul class=""><li id="b002" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">在多维数组中，我们可以同时对每个维度使用不同的索引方法(切片、布尔和花式)</li><li id="3e70" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">为了混合使用布尔和花式索引，布尔索引中True的数量必须等于花式索引的长度</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="e37c" class="kr ir hi mh b fi mq mr l ms mt">arr = np.arange(64).reshape(4,4,4)<br/>print('arr: ', arr)<br/>print('\n', 'Following mixed indexing will select 1st and 3rd item in 0th dimension')<br/>print('and item at index 0 and 2 at 1st dimension and item at index &gt;=2')<br/>print(arr[[True, False, True, False], [0,2], 2:])</span></pre><p id="d998" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">输出</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="d321" class="kr ir hi mh b fi mq mr l ms mt">arr:  [[[ 0  1  2  3]<br/>  [ 4  5  6  7]<br/>  [ 8  9 10 11]<br/>  [12 13 14 15]]</span><span id="f833" class="kr ir hi mh b fi mu mr l ms mt">[[16 17 18 19]<br/>  [20 21 22 23]<br/>  [24 25 26 27]<br/>  [28 29 30 31]]</span><span id="4fe0" class="kr ir hi mh b fi mu mr l ms mt">[[32 33 34 35]<br/>  [36 37 38 39]<br/>  [40 41 42 43]<br/>  [44 45 46 47]]</span><span id="f61f" class="kr ir hi mh b fi mu mr l ms mt">[[48 49 50 51]<br/>  [52 53 54 55]<br/>  [56 57 58 59]<br/>  [60 61 62 63]]]</span><span id="e678" class="kr ir hi mh b fi mu mr l ms mt">Following mixed indexing will select 1st and 3rd item in 0th dimension<br/>and item at index 0 and 2 at 1st dimension and item at index &gt;=2<br/>[[ 2  3]<br/> [42 43]]</span></pre><h1 id="f394" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数组运算</h1><h2 id="49f9" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">简单的数组运算</h2><ul class=""><li id="279c" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">Numpy提供了简单的语法来在兼容形状的数组之间执行数学和逻辑运算。这里兼容的形状意味着，一个数组的形状可以使用广播规则扩展以匹配另一个数组的形状，我们将在下面讨论</li><li id="9963" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">在本节中，我们将只看到两种情况</li><li id="918b" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">数组具有相同的形状，在这种情况下，操作将是元素方式的</li><li id="c83f" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">其中一个操作数是标量，在这种情况下，操作将在标量和数组的每个元素之间进行</li><li id="bc20" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">数组之间的这些操作称为向量化，比使用循环的相同操作要快得多。</li><li id="91a5" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">矢量化速度更快，因为它是用C实现的，没有类型检查等开销。</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="be82" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np</span><span id="02c2" class="kr ir hi mh b fi mu mr l ms mt">print('Evaluate expression (x1*x2 - 3*x1 + 30) for x1 and x2 in range 0 to 10')<br/>x1 = np.linspace(0,10,20)<br/>x2 = np.linspace(0, 10, 20)<br/>z = x1*x2 - 3*x1 + 30<br/>print(z)</span><span id="af8e" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Spatial distance between corresponding points in two array')<br/>p1 = np.random.rand(20,2)<br/>p2 = np.random.rand(20,2)</span><span id="1b0f" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma">'''np.sum will add values along given axis (dimension). If shape of array is (3,4,5)')</em><br/><em class="ma">then axis 0,1 and 2 corresponds to dimension with length 3, 4 and 5 respectively'''</em><br/>d = np.sum((p1-p2)**2, axis=1)<br/>print(d)</span><span id="7802" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Element wise comparison, "&gt;=" will give boolean array with True where element')<br/>print('of p2 is greater than or equal to p1')<br/>r = p2&gt;=p1<br/>print(r)</span><span id="41ec" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Element wise logical operation, "&amp;" will give True where point of p2 is ahead')<br/>print('in both x and y direction from corresponding point in p1')<br/>print(r[:,0] &amp; r[:,1])</span></pre><p id="91e6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="8dda" class="kr ir hi mh b fi mq mr l ms mt">Evaluate expression (x1*x2 - 3*x1 + 30) for x1 and x2 in range 0 to 10<br/>[ 30.          28.69806094  27.9501385   27.75623269  28.11634349<br/>  29.03047091  30.49861496  32.52077562  35.09695291  38.22714681<br/>  41.91135734  46.14958449  50.94182825  56.28808864  62.18836565<br/>  68.64265928  75.65096953  83.2132964   91.32963989 100.        ]</span><span id="3e8d" class="kr ir hi mh b fi mu mr l ms mt">Spatial distance between corresponding points in two array<br/>[0.54052263 0.17505988 0.59108818 0.41593393 0.03548522 0.29946201<br/> 0.84649163 0.24975051 0.90016153 0.54062043 0.00097261 0.39826495<br/> 0.64710327 0.40655563 0.00531519 0.94567232 0.33333277 0.01713418<br/> 0.53797027 0.48080742]</span><span id="714f" class="kr ir hi mh b fi mu mr l ms mt">Element wise comparison, "&gt;=" will give boolean array with True where element<br/>of p2 is greater than or equal to p1<br/>[[ True False]<br/> [False False]<br/> [False False]<br/> [ True  True]<br/> [ True False]<br/> [ True  True]<br/> [ True  True]<br/> [ True False]<br/> [ True False]<br/> [False  True]<br/> [ True False]<br/> [False False]<br/> [ True False]<br/> [ True False]<br/> [False False]<br/> [ True False]<br/> [False False]<br/> [ True False]<br/> [False  True]<br/> [False False]]</span><span id="7c75" class="kr ir hi mh b fi mu mr l ms mt">Element wise logical operation, "&amp;" will give True where point of p2 is ahead<br/>in both x and y direction from corresponding point in p1<br/>[False False False  True False  True  True False False False False False<br/> False False False False False False False False]</span></pre><h2 id="801c" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">数组运算的函数</h2><ul class=""><li id="c999" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">Numpy也有上述操作的函数版本，如<code class="du me mf mg mh b">np.add, np.substract, np.divide, np.greater_equal, np.logical_and</code>等等</li><li id="0f87" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">我们在上一节看到的使用+、*等运算符的数组运算是函数运算的运算符重载版本</li><li id="668e" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">函数版本的操作会给我们额外的参数来定制，其中一个常用的参数是<code class="du me mf mg mh b">out</code>。默认情况下是<code class="du me mf mg mh b">None</code>，这将为结果创建一个新的数组。</li><li id="89cb" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">如果我们将一个形状和数据类型与预期结果匹配的数组传递给<code class="du me mf mg mh b">out</code>，参数结果将被填充到传递的数组中。如果我们做多个操作，这将是有效的内存方式</li></ul><p id="b56c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在[19]中:</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="1148" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np</span><span id="90c3" class="kr ir hi mh b fi mu mr l ms mt">print('Evaluate expression (x1*x2 - 3*x1 + 30) using functions')<br/>x1 = np.linspace(0,10,20)<br/>x2 = np.linspace(0, 10, 20)</span><span id="020a" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma">'''Create empty output array with expected shape'''</em><br/>z = np.empty_like(x1)</span><span id="e7a5" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma">'''Code is not very clean as using operator but it will perform very well memory wise'''</em><br/>np.multiply(x1, x2, out=z)<br/>np.subtract(z, 3*x1, out=z)<br/>np.add(z, 30, out=z)<br/>print(z)</span></pre><p id="8dec" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="ab45" class="kr ir hi mh b fi mq mr l ms mt">Evaluate expression (x1*x2 - 3*x1 + 30) using functions<br/>[ 30.          28.69806094  27.9501385   27.75623269  28.11634349<br/>  29.03047091  30.49861496  32.52077562  35.09695291  38.22714681<br/>  41.91135734  46.14958449  50.94182825  56.28808864  62.18836565<br/>  68.64265928  75.65096953  83.2132964   91.32963989 100.        ]</span></pre><h1 id="9a47" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">广播</h1><h2 id="2033" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">广播规则</h2><p id="dea9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当在形状不完全匹配的两个数组之间进行数组操作时，只需几个简单的步骤，就可以改变形状，使它们相互匹配，如果它们是兼容的话。</p><ol class=""><li id="b339" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl mv ll lm ln bi translated"><strong class="jq hj">检查数组尺寸</strong>:如果尺寸不匹配，添加到较小尺寸数组的左边</li><li id="3c06" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl mv ll lm ln bi translated"><strong class="jq hj">匹配每个维度上的形状</strong>:如果任何维度上的形状不匹配，并且其中一个数组的形状为1，则重复该操作以匹配该维度上其他数组的形状</li><li id="8fe9" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl mv ll lm ln bi translated"><strong class="jq hj">如果尺寸和形状不匹配，则引发错误</strong>:如果尺寸和形状在此步骤之前不匹配，则引发错误</li></ol><h2 id="7ec0" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">让我们用自定义实现来可视化广播规则</h2><p id="16b2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们进行自定义实现，用代码来直观显示广播规则是如何工作的</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="03a9" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np</span><span id="d9f7" class="kr ir hi mh b fi mu mr l ms mt">arr1 = np.arange(20).reshape(10,2)<br/>arr2 = np.random.rand(2)<br/>arr3 = arr2.copy()</span><span id="799c" class="kr ir hi mh b fi mu mr l ms mt">print('arr1.shape: ', arr1.shape)<br/>print('arr2.shape: ', arr2.shape)</span><span id="5089" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma"># Step 1: Check Array Dimensions</em><br/>print('\n', 'arr1 has dimension 2 and arr2 has dimension 1, so add 1 dimension to\<br/>left side of arr2')<br/><em class="ma"># np.newaxis is convenient way of adding new dimension</em><br/>arr2 = arr2[np.newaxis, :]<br/>print('arr1.shape: ', arr1.shape)<br/>print('arr2.shape: ', arr2.shape)</span><span id="7078" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma"># Step 2: Match Shape On Each Dimension</em><br/>print('\n', 'Now in axis=0 arr1 has 10 items and arr2 has one item, so repeat it 10\<br/>times to match arr2')<br/>arr2 = np.repeat(arr2, 10, axis=0)<br/>print('arr1.shape: ', arr1.shape)<br/>print('arr2.shape: ', arr2.shape)</span><span id="0f75" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Now both array has same dimension and shape, we can multiply them')<br/>print('arr1*arr2:\n', arr1*arr2)</span><span id="57d7" class="kr ir hi mh b fi mu mr l ms mt">print('\n', 'Lets see if broadcasting also produce same result')<br/>print('arr1*arr3:\n', arr1*arr3)</span></pre><p id="f96b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="937b" class="kr ir hi mh b fi mq mr l ms mt">arr1.shape:  (10, 2)<br/>arr2.shape:  (2,)</span><span id="c6f4" class="kr ir hi mh b fi mu mr l ms mt">arr1 has dimension 2 and arr2 has dimension 1, so add 1 dimension toleft side of arr2<br/>arr1.shape:  (10, 2)<br/>arr2.shape:  (1, 2)</span><span id="97bc" class="kr ir hi mh b fi mu mr l ms mt">Now in axis=0 arr1 has 10 items and arr2 has one item, so repeat it 10times to match arr2<br/>arr1.shape:  (10, 2)<br/>arr2.shape:  (10, 2)</span><span id="0f19" class="kr ir hi mh b fi mu mr l ms mt">Now both array has same dimension and shape, we can multiply them<br/>arr1*arr2:<br/> [[ 0.          0.11111075]<br/> [ 1.71941377  0.33333225]<br/> [ 3.43882755  0.55555375]<br/> [ 5.15824132  0.77777525]<br/> [ 6.8776551   0.99999675]<br/> [ 8.59706887  1.22221824]<br/> [10.31648264  1.44443974]<br/> [12.03589642  1.66666124]<br/> [13.75531019  1.88888274]<br/> [15.47472397  2.11110424]]</span><span id="eda2" class="kr ir hi mh b fi mu mr l ms mt">Lets see if broadcasting also produce same result<br/>arr1*arr3:<br/> [[ 0.          0.11111075]<br/> [ 1.71941377  0.33333225]<br/> [ 3.43882755  0.55555375]<br/> [ 5.15824132  0.77777525]<br/> [ 6.8776551   0.99999675]<br/> [ 8.59706887  1.22221824]<br/> [10.31648264  1.44443974]<br/> [12.03589642  1.66666124]<br/> [13.75531019  1.88888274]<br/> [15.47472397  2.11110424]]</span></pre><h2 id="e2da" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">让我们试几个形状的例子</h2><p id="1f73" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您可以通过创建给定形状的数组并在它们之间进行一些操作来尝试</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="ee6f" class="kr ir hi mh b fi mq mr l ms mt">Before Broadcast        |Step 1                      | Step 2 and 3  <br/>Shapes of arr1 and arr2 |                            | Shapes of result <br/>-------------------------------------------------------------------------<br/>(3, 1, 5); (4, 1)       | (3, 1, 5); (1, 4, 1)       | (3, 4, 5)        <br/>(10,); (1, 10)          | (10, 1); (1, 10)           | (10, 10)         <br/>(2, 2, 2); (2, 3)       | (2, 2, 2); (1, 2, 3)       | Not Broadcastable<br/>(2, 2, 2, 1); (2, 3)    | (2, 2, 2, 1); (1, 1, 2, 3) | (2, 2, 2, 2, 3)</span></pre><h1 id="5ccd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">广播的一些用法</h1><h2 id="9900" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">使用广播评估线性方程</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="8ae1" class="kr ir hi mh b fi mq mr l ms mt">print("Let's evaluate equation c1*x1 + c2*x2 + c3*x3 for 100 points at once")<br/>points = np.random.rand(100,3)<br/>coefficients = np.array([5, -2, 11])<br/>results = np.sum(points*coefficients, axis=1)<br/>print('results first 10:<strong class="mh hj">\n</strong>', results[:10])<br/>print('results.shape: ', results.shape)</span></pre><p id="5895" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="5a19" class="kr ir hi mh b fi mq mr l ms mt">Let's evaluate equation c1*x1 + c2*x2 + c3*x3 for 100 points at once<br/>results first 10:<br/> [ 6.35385279  0.85639146 12.87683079  5.99433896  4.50873972 10.44691041<br/>  3.87407211  6.62954602 11.00386582 10.09247866]<br/>results.shape:  (100,)</span></pre><h2 id="71db" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">寻找数组之间的公共元素</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="31b0" class="kr ir hi mh b fi mq mr l ms mt">np.random.seed(5)<br/><em class="ma">## Get 20 random value from 0 to 99</em><br/>arr1 = np.random.choice(50, 20, replace=False)<br/>arr2 = np.random.choice(50, 15, replace=False)<br/>print("arr1: ", arr1)<br/>print("arr2: ", arr2)<br/>print('\n', 'arr1 and arr2 are 1D arrays of length 20, 15 respectively.')<br/>print('To make them broadcastable Change shape of arr2 to (15, 1)')<br/>arr2 = arr2.reshape(15, 1)<br/>print('\n', 'Then both arrays will be broadcasted to (15, 20) matrix with all possible pairs')<br/>comparison = (arr1 == arr2)<br/>print('\n', 'comparison.shape: ', comparison.shape)<br/>print('\n', 'Elements of arr1 also in arr2: ', arr1[comparison.any(axis=0)])</span></pre><p id="2916" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">输出</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="80dd" class="kr ir hi mh b fi mq mr l ms mt">arr1:  [42 29  6 19 28 17  2 43  3 21 31  4 32  0 23  5 48 34 37 26]<br/>arr2:  [40 37 41 48  4 20 10 18 34 28 19 32 17 22 23]</span><span id="3ed2" class="kr ir hi mh b fi mu mr l ms mt">arr1 and arr2 are 1D arrays of length 20, 15 respectively.<br/>To make them broadcastable Change shape of arr2 to (15, 1)</span><span id="336d" class="kr ir hi mh b fi mu mr l ms mt">Then both arrays will be broadcasted to (15, 20) matrix with all possible pairs</span><span id="1400" class="kr ir hi mh b fi mu mr l ms mt">comparison.shape:  (15, 20)</span><span id="3d22" class="kr ir hi mh b fi mu mr l ms mt">Elements of arr1 also in arr2:  [19 28 17  4 32 23 48 34 37]</span></pre><h2 id="f729" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">查找k个最近邻</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c54d" class="kr ir hi mh b fi mq mr l ms mt">import numpy as np</span><span id="3582" class="kr ir hi mh b fi mu mr l ms mt">np.random.seed(5)</span><span id="f7d3" class="kr ir hi mh b fi mu mr l ms mt">points = np.random.rand(20, 2)<br/>print('To calculate distance between every pair of points make copy of points ')<br/>print('with shape (20, 1, 2) which will broadcast both array to shape (20, 20, 2)', '\n')<br/>cp_points = points.reshape(20, 1, 2)</span><span id="0787" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma">## calculate x2-x1, y2-y1</em><br/>diff = (cp_points - points)<br/>print('diff.shape: ', diff.shape)</span><span id="6221" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma">## calculate (x2-x1)**2 + (y2-y1)**</em><br/>distance_matrix = np.sum(diff**2, axis=2)<br/>print('distance_matrix.shape: ', distance_matrix.shape, '\n')</span><span id="4fbd" class="kr ir hi mh b fi mu mr l ms mt"><em class="ma">## sort by distance along axis 1 and take top 4, one of which is the point itself</em><br/>top_3 = np.argsort(distance_matrix, axis=1)[:,:4]<br/>print("Get the points with it's 3 nearest neighbors")<br/>points[top_3]</span></pre><p id="a97c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="3e43" class="kr ir hi mh b fi mq mr l ms mt">To calculate distance between every pair of points make copy of points <br/>with shape (20, 1, 2) which will broadcast both array to shape (20, 20, 2)</span><span id="2e72" class="kr ir hi mh b fi mu mr l ms mt">diff.shape:  (20, 20, 2)<br/>distance_matrix.shape:  (20, 20)</span><span id="03de" class="kr ir hi mh b fi mu mr l ms mt">Get the points with it's 3 nearest neighbors</span><span id="788c" class="kr ir hi mh b fi mu mr l ms mt">array([[[0.22199317, 0.87073231],<br/>        [0.20671916, 0.91861091],<br/>        [0.16561286, 0.96393053],<br/>        [0.08074127, 0.7384403 ]],</span><span id="2f0d" class="kr ir hi mh b fi mu mr l ms mt">       [[0.20671916, 0.91861091],<br/>        [0.22199317, 0.87073231],<br/>        [0.16561286, 0.96393053],<br/>        [0.08074127, 0.7384403 ]],</span><span id="cf92" class="kr ir hi mh b fi mu mr l ms mt">       [[0.48841119, 0.61174386],<br/>        [0.62878791, 0.57983781],<br/>        [0.69984361, 0.77951459],<br/>        [0.76590786, 0.51841799]],</span><span id="b80e" class="kr ir hi mh b fi mu mr l ms mt">       [[0.76590786, 0.51841799],<br/>        [0.62878791, 0.57983781],<br/>        [0.69984361, 0.77951459],<br/>        [0.87993703, 0.27408646]],</span><span id="d465" class="kr ir hi mh b fi mu mr l ms mt">       [[0.2968005 , 0.18772123],<br/>        [0.32756395, 0.1441643 ],<br/>        [0.28468588, 0.25358821],<br/>        [0.44130922, 0.15830987]],</span><span id="d638" class="kr ir hi mh b fi mu mr l ms mt">       [[0.08074127, 0.7384403 ],<br/>        [0.02293309, 0.57766286],<br/>        [0.22199317, 0.87073231],<br/>        [0.20671916, 0.91861091]],</span><span id="f89d" class="kr ir hi mh b fi mu mr l ms mt">       [[0.44130922, 0.15830987],<br/>        [0.32756395, 0.1441643 ],<br/>        [0.41423502, 0.29607993],<br/>        [0.2968005 , 0.18772123]],</span><span id="ac69" class="kr ir hi mh b fi mu mr l ms mt">       [[0.87993703, 0.27408646],<br/>        [0.96022672, 0.18841466],<br/>        [0.76590786, 0.51841799],<br/>        [0.5999292 , 0.26581912]],</span><span id="53b4" class="kr ir hi mh b fi mu mr l ms mt">       [[0.41423502, 0.29607993],<br/>        [0.28468588, 0.25358821],<br/>        [0.44130922, 0.15830987],<br/>        [0.2968005 , 0.18772123]],</span><span id="5295" class="kr ir hi mh b fi mu mr l ms mt">       [[0.62878791, 0.57983781],<br/>        [0.48841119, 0.61174386],<br/>        [0.76590786, 0.51841799],<br/>        [0.69984361, 0.77951459]],</span><span id="4187" class="kr ir hi mh b fi mu mr l ms mt">       [[0.5999292 , 0.26581912],<br/>        [0.41423502, 0.29607993],<br/>        [0.44130922, 0.15830987],<br/>        [0.87993703, 0.27408646]],</span><span id="5d5d" class="kr ir hi mh b fi mu mr l ms mt">       [[0.28468588, 0.25358821],<br/>        [0.2968005 , 0.18772123],<br/>        [0.32756395, 0.1441643 ],<br/>        [0.41423502, 0.29607993]],</span><span id="b133" class="kr ir hi mh b fi mu mr l ms mt">       [[0.32756395, 0.1441643 ],<br/>        [0.2968005 , 0.18772123],<br/>        [0.44130922, 0.15830987],<br/>        [0.28468588, 0.25358821]],</span><span id="4da4" class="kr ir hi mh b fi mu mr l ms mt">       [[0.16561286, 0.96393053],<br/>        [0.20671916, 0.91861091],<br/>        [0.22199317, 0.87073231],<br/>        [0.08074127, 0.7384403 ]],</span><span id="1836" class="kr ir hi mh b fi mu mr l ms mt">       [[0.96022672, 0.18841466],<br/>        [0.87993703, 0.27408646],<br/>        [0.5999292 , 0.26581912],<br/>        [0.76590786, 0.51841799]],</span><span id="62e4" class="kr ir hi mh b fi mu mr l ms mt">       [[0.02430656, 0.20455555],<br/>        [0.28468588, 0.25358821],<br/>        [0.2968005 , 0.18772123],<br/>        [0.32756395, 0.1441643 ]],</span><span id="7ae1" class="kr ir hi mh b fi mu mr l ms mt">       [[0.69984361, 0.77951459],<br/>        [0.62878791, 0.57983781],<br/>        [0.63979518, 0.9856244 ],<br/>        [0.76590786, 0.51841799]],</span><span id="dba4" class="kr ir hi mh b fi mu mr l ms mt">       [[0.02293309, 0.57766286],<br/>        [0.00164217, 0.51547261],<br/>        [0.08074127, 0.7384403 ],<br/>        [0.22199317, 0.87073231]],</span><span id="c894" class="kr ir hi mh b fi mu mr l ms mt">       [[0.00164217, 0.51547261],<br/>        [0.02293309, 0.57766286],<br/>        [0.08074127, 0.7384403 ],<br/>        [0.02430656, 0.20455555]],</span><span id="0f55" class="kr ir hi mh b fi mu mr l ms mt">       [[0.63979518, 0.9856244 ],<br/>        [0.69984361, 0.77951459],<br/>        [0.48841119, 0.61174386],<br/>        [0.62878791, 0.57983781]]])</span></pre><h1 id="4464" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">…向量化…</h1><ul class=""><li id="8b00" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">在numpy中，向量化意味着对相同类型的数据序列执行优化操作。</li><li id="e38f" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">除了具有清晰的代码结构，矢量化操作也非常高效，因为代码是编译的，避免了python的开销，如类型检查、内存管理等。</li><li id="b9a9" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">我们在上面的<strong class="jq hj">广播部分看到的例子也是矢量化的好例子</strong></li></ul><h2 id="0e03" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">矢量化与循环</h2><p id="9b82" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设我们有一个像<code class="du me mf mg mh b">a1*x + a2*x^2 + a3*x^3 ... + a10*x^10</code>这样的单变量10次多项式方程。让我们尝试仅使用python和numpy矢量化来评估大量x的方程，看看它们是如何比较的</p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="2c17" class="kr ir hi mh b fi mq mr l ms mt">def evaluate_polynomial_loop():<br/>  result_loop = np.empty_like(X)<br/>  for i in range(X.shape[0]):<br/>    exp_part = 1<br/>    total = 0<br/>    for j in range(coefficients.shape[0]):<br/>      exp_part *= X[i]<br/>      total+=coefficients[j]*exp_part<br/>    result_loop[i] = total<br/>  return result_loop</span><span id="4b6c" class="kr ir hi mh b fi mu mr l ms mt">def evaluate_polynomial_vect():<br/>  ## repeates x's in 10 columns<br/>  exponents = X[:, np.newaxis] + np.zeros((1, coefficients.shape[0]))<br/>  exponents.cumprod(axis=1, out=exponents)<br/>  result_vect = np.sum(exponents * coefficients, axis=1)<br/>  return result_vect<br/>  <br/>print('Verify that both gives same result')<br/>print('Loop:\n', evaluate_polynomial_loop()[:10])<br/>print('Vectorization:\n', evaluate_polynomial_vect()[:10])</span></pre><p id="539a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="e49d" class="kr ir hi mh b fi mq mr l ms mt">Verify that both gives same result<br/>Loop:<br/> [222.57782534  30.62439847  59.69953776 373.52687079 123.89007218<br/> 179.70369976   6.49315699 321.685257    73.14575517  69.71437596]<br/>Vectorization:<br/> [222.57782534  30.62439847  59.69953776 373.52687079 123.89007218<br/> 179.70369976   6.49315699 321.685257    73.14575517  69.71437596]</span></pre><h2 id="fc48" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">比较</h2><p id="3504" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了公平比较，我在两者中都使用了numpy数组，它的索引比python list快得多。通过比较，我们看到矢量化比<strong class="jq hj">快了大约80倍</strong></p><p id="f7a5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">循环</strong></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="7c39" class="kr ir hi mh b fi mq mr l ms mt">%timeit evaluate_polynomial_loop()</span></pre><p id="7057" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c1b0" class="kr ir hi mh b fi mq mr l ms mt">113 ms ± 3.82 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="57be" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">矢量化</strong></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="55f6" class="kr ir hi mh b fi mq mr l ms mt">%<strong class="mh hj">timeit</strong> evaluate_polynomial_vect()</span></pre><p id="783c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="899e" class="kr ir hi mh b fi mq mr l ms mt">1.22 ms ± 75 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><h1 id="5ada" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Ufunc和Numba</h1><p id="c0a0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> Ufunc: </strong>也称为通用函数，是函数的矢量化包装。Ufunc可以在ndarray上运行，并支持广播和类型转换。etc是用c实现的Ufunc的例子。我们可以使用<code class="du me mf mg mh b">np.frompyfunc</code>或numba创建自定义的Ufunc。</p><p id="dc9f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Numba是一个即时编译器，它从纯python数组和数字函数中生成优化的机器代码。你可以在一个函数上使用<code class="du me mf mg mh b">numba.jit</code>装饰，使得这个函数在第一次运行时就被编译。可以使用<code class="du me mf mg mh b">numba.vectorize</code> decorator将python函数转换为Ufunc。</p><p id="7faa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们比较添加两个大数组的不同实现，如下所示</p><h2 id="44f6" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">创建大数组</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="60e6" class="kr ir hi mh b fi mq mr l ms mt">arr1 = np.arange(1000000, dtype='int64')<br/>arr2 = np.arange(1000000, dtype='int64')</span></pre><h2 id="2032" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">使用Python循环实现</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="cbdc" class="kr ir hi mh b fi mq mr l ms mt">def add_arr(arr1, arr2):<br/>  assert len(arr1)==len(arr2), "array must have same length"<br/>  result = np.empty_like(arr1)<br/>  for i in range(len(arr1)):<br/>    result[i] = arr1[i] + arr2[i]<br/>  return result</span><span id="2411" class="kr ir hi mh b fi mu mr l ms mt">%timeit _ = add_arr(arr1, arr2)</span></pre><p id="5461" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="5e59" class="kr ir hi mh b fi mq mr l ms mt">563 ms ± 9.34 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><h2 id="ae4c" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">使用<code class="du me mf mg mh b">np.frompyfunc</code>创建Ufunc</h2><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="e6a8" class="kr ir hi mh b fi mq mr l ms mt">def add(a, b):<br/>  return a+b</span><span id="0611" class="kr ir hi mh b fi mu mr l ms mt">vect_add =  np.frompyfunc(add,2,1)</span><span id="388d" class="kr ir hi mh b fi mu mr l ms mt">%timeit _ = vect_add(arr1, arr2)</span></pre><p id="fbee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="5341" class="kr ir hi mh b fi mq mr l ms mt">197 ms ± 9.16 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><h2 id="08e1" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">使用Numba JIT</h2><ul class=""><li id="f4ff" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">“nopython=True”表示如果无法转换，将所有代码转换为机器代码，并引发错误</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="c39d" class="kr ir hi mh b fi mq mr l ms mt">import numba<br/>@numba.jit(nopython=True)<br/>def add_arr_jit(arr1, arr2):<br/>  assert len(arr1)==len(arr2), "array must have same length"<br/>  result = np.empty_like(arr1)<br/>  for i in range(len(arr1)):<br/>    result[i] = arr1[i] + arr2[i]<br/>  return result</span><span id="8f41" class="kr ir hi mh b fi mu mr l ms mt">_ = add_arr_jit(arr1, arr2)<br/>%timeit _ = add_arr_jit(arr1, arr2)</span></pre><p id="466e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="d5b9" class="kr ir hi mh b fi mq mr l ms mt">3.8 ms ± 455 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><h2 id="d1f6" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">使用<code class="du me mf mg mh b">numba.vectorize</code>创建Ufunc</h2><ul class=""><li id="53c4" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated">“numba.vectorize”将被转换的函数的签名作为参数。int64(int64，int64)'表示接受2个' int64 '参数并返回' int64 '</li></ul><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="ee1f" class="kr ir hi mh b fi mq mr l ms mt">import numba</span><span id="1cbb" class="kr ir hi mh b fi mu mr l ms mt">@numba.vectorize(['int64(int64,int64)'], nopython=True)<br/>def vect_add(a, b):<br/>  return a+b</span><span id="03d3" class="kr ir hi mh b fi mu mr l ms mt">%timeit _ = vect_add(arr1, arr2)</span></pre><p id="90aa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="ma">输出</em></p><pre class="mi mj mk ml fd mm mh mn mo aw mp bi"><span id="b827" class="kr ir hi mh b fi mq mr l ms mt">2.58 ms ± 309 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="d52f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">结论</strong>方案使用<code class="du me mf mg mh b">numba.jit and numba.vectorize</code>效果更好。您还可以检查numpy矢量化与这些相比如何</p><h1 id="442b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">更多探索</h1><h2 id="afb3" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">一些有用的功能</h2><ul class=""><li id="f0da" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.where</strong></code> <strong class="jq hj"> : </strong>元素方面<code class="du me mf mg mh b">if .. then .. Else</code></li><li id="8b0f" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.select</strong></code> <strong class="jq hj"> : </strong>根据多个条件从多个数组中选择值</li><li id="e175" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.concatenate, np.vstack, np.r_, np.hstack, np.c_</strong></code> <strong class="jq hj"> : </strong>按行、按列或给定轴连接多个数组</li><li id="28f6" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.ravel, np.flatten</strong></code> <strong class="jq hj"> : </strong>将多维数组转换为1D数组</li><li id="64d4" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.roll</strong></code> <strong class="jq hj"> : </strong>将数组沿给定轴做圆周移动</li></ul><h2 id="955b" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">集合操作</h2><ul class=""><li id="1fe3" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.unique(x)</strong></code> <strong class="jq hj"> : </strong>给出数组中唯一元素的数组</li><li id="bfe9" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">Intersect1d(x, y)</strong></code> <strong class="jq hj"> : </strong>给出两个数组共有元素的1D数组</li><li id="fc2f" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">Union1d(x, y)</strong></code> <strong class="jq hj"> : </strong>给出两个数组中唯一元素的1D数组</li><li id="be0a" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">In1d(x, y)</strong></code> <strong class="jq hj"> : </strong>检查x的每个元素是否也出现在y上，并返回长度等于x的布尔值数组</li><li id="276b" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">Setdiff1d(x, y)</strong></code> <strong class="jq hj"> : </strong>给出不在y中的x元素</li><li id="14b4" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">Setxor1d(x, y)</strong></code> <strong class="jq hj"> : </strong>给出在x或y中的元素，但不同时在两者中</li></ul><h2 id="11d7" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">从/向磁盘保存和加载数组</h2><ul class=""><li id="3da9" class="lf lg hi jq b jr js jv jw jz lh kd li kh lj kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.save("filename.npy", x)</strong></code> <strong class="jq hj"> : </strong>保存单个数数组到磁盘</li><li id="1b5c" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.load("filename.npy")</strong></code> <strong class="jq hj"> : </strong>从磁盘加载单个数数组</li><li id="a712" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.savez("filename.npz", key1=arr1, key2=arr2)</strong></code> <strong class="jq hj"> : </strong>用给定的键保存多个数组</li><li id="8668" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.savetxt("filename.npy", x)</strong></code> <strong class="jq hj"> : </strong>将单个numpy数组作为分隔文本文件保存到磁盘</li><li id="f469" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.loadtxt("filename.npy")</strong></code> <strong class="jq hj"> : </strong>从文本文件加载单个numpy数组</li></ul><h1 id="8ac5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">存储器交换</h1><p id="2a05" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要使用不适合RAM的大型numpy数组，可以使用numpy.memmap函数将数组映射到磁盘中的文件。它将只透明地加载当前操作所需的阵列段。</p><ul class=""><li id="90a5" class="lf lg hi jq b jr km jv kn jz lt kd lu kh lv kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">np.memmap(filename, dtype, mode, shape)</strong></code> <strong class="jq hj"> : </strong>创建给定文件的内存映射数组</li><li id="2e41" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><code class="du me mf mg mh b"><strong class="jq hj">mmap.flush()</strong></code> <strong class="jq hj"> : </strong>将内存中的所有更改刷新到磁盘</li></ul><p id="7651" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">谢谢</strong></p><p id="eaa0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">衷心感谢您阅读博客。希望它对您在numpy中的启动和运行有所帮助。欢迎任何意见、建议和建设性的批评。如果你喜欢这些内容，请不要忘记鼓掌<a class="ae lw" href="https://emojipedia.org/clapping-hands-sign/" rel="noopener ugc nofollow" target="_blank">👏👏👏</a></p></div></div>    
</body>
</html>