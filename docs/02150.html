<html>
<head>
<title>Extract Excel data in parallel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并行提取Excel数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/extract-excel-data-in-parallel-181838c4ed37?source=collection_archive---------7-----------------------#2019-12-03">https://medium.com/analytics-vidhya/extract-excel-data-in-parallel-181838c4ed37?source=collection_archive---------7-----------------------#2019-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/64a82b0931c07e6a02ac1d3a0edc9ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gP5xMMo-EbzufXyWylrLZw.jpeg"/></div></div></figure><p id="b587" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管有些人因为Excel的<a class="ae jo" href="https://support.office.com/en-us/article/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3" rel="noopener ugc nofollow" target="_blank">限制</a>以及<a class="ae jo" href="https://stackoverflow.com/a/3681908/1860314" rel="noopener ugc nofollow" target="_blank">未记录的限制</a>而不喜欢Excel，但是这个程序却<a class="ae jo" rel="noopener" href="/@hypergiant/why-are-you-still-using-excel-fef6c3821a7b">无处可去</a>。在大数据和AI越来越普遍的情况下，这有些违背直觉。</p><p id="4326" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在我的工作中，有时我必须处理复杂的Excel文件，例如&gt; 7000行、&gt; 100列和&gt; 30张表格。有一种需求，给定一个Excel文件一年，你有另一个另一年；并且必须比较这两个文件以查明差异(如果有的话)。毫无疑问，手动做这个是<em class="jp">劳动密集、枯燥且容易出错的</em>。我自然会想到通过编程来实现这些任务的自动化。</p><p id="bd34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Python world(我最喜欢的编程语言和生态系统)里，我找到了几个库:<code class="du jq jr js jt b">xlwings</code>、<code class="du jq jr js jt b">openpyxl</code>；这里优雅地描述了他们的不同之处<a class="ae jo" href="https://stackoverflow.com/questions/58328776/differences-between-xlwings-vs-openpyxl-reading-excel-workbooks" rel="noopener ugc nofollow" target="_blank">。需要注意的一点是，微软Office格式，尤其是Excel，是</a><a class="ae jo" href="https://en.wikipedia.org/wiki/Office_Open_XML" rel="noopener ugc nofollow" target="_blank">标准化的</a>。该文件实际上是一个压缩文件夹，里面包含许多XML文件，如果您确切地知道如何在底层利用该格式，就可以超级高效地提取Excel属性。在我的例子中，<code class="du jq jr js jt b">xlwings</code>被选中是因为它包含了微软的库；从而使其功能全面(像VBA一样强大)。然而，因为它是羽翼丰满，预计开销和缓慢。</p><h1 id="63af" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">我们开始吧</h1><p id="8e52" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在Excel文件中提取数据的示例源代码在我的<a class="ae jo" href="https://github.com/ThachNgocTran/ExtractExcelDataInParallel" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。希望它能帮助人们快速解决Excel数据- <em class="jp">提取的问题。</em></p><p id="215c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在微软的函数库上运行需要预先在机器上安装Office应用程序。根据<em class="jp">特定用例</em>，提取单元格值、单元格公式、单元格背景颜色，甚至单元格缩进级别。在不知道调用哪个(Python的<code class="du jq jr js jt b">xlwings</code>)范围属性的情况下，<code class="du jq jr js jt b">dir(rang)</code>喜欢下面的快速技巧，然后参考官方文档[2]。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/b0b13fe0fc634e5b388b087c2d3432fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*tL0QAgtGdZq0-2q2fP2zdg.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">探索产品系列的功能</figcaption></figure><p id="b176" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">常用属性，如值、公式，可以快速获取，即使<code class="du jq jr js jt b">Range</code>覆盖了许多单元格。返回的结果格式合理。也就是说，如果调用<code class="du jq jr js jt b">Range("A1").value</code>，则返回浮点型、字符串型或日期时间型的<em class="jp">单值</em>；如果<code class="du jq jr js jt b">Range("A1:A2")</code>，返回一个2元列表；如果<code class="du jq jr js jt b">Range("A1:B2")</code>，返回一个列表列表，代表行和列。</p><p id="1d8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使<code class="du jq jr js jt b">Range</code>跨越&gt; 1000个单元，其<em class="jp">值</em>也能闪电般暴露。问题是当涉及到非内置属性时，比如条件格式中的<code class="du jq jr js jt b">IndentLevel</code>或<code class="du jq jr js jt b">Color</code>，其中<em class="jp">低级</em>单元格必须通过<code class="du jq jr js jt b">xlwings</code> ) <code class="du jq jr js jt b">rang.api</code>，具体是<code class="du jq jr js jt b">rang.api.Cells(1, 1).DisplayFormat.Interior.Color</code>来访问。这种低水平使得计算成本很高:一个细胞需要几毫秒。对于一个小区来说不算多，但是成千上万个小区将导致实质性的延迟。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/2f0a6fb5d746eb54c60c29422b49665b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUe1WzUGqusOgWvjsHyo_g.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">调用低级功能</figcaption></figure><p id="8adf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们尝试用两种方法提取1000个细胞:直接通过<code class="du jq jr js jt b">rang.value</code>和通过<code class="du jq jr js jt b">rang.api.Cells(row_idx, col_idx).value</code>:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/1744af747e4fa198ebee131cd4495865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIFGlWMsvJuwoqrrBxi9GQ.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">直接获取单元格数值数组<strong class="bd jw"/></figcaption></figure><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/81a94794103db4763d612da3622fb144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfaU9jAnzUW2z0GMhJog8A.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">逐个获取单元格值的数组<strong class="bd jw"><em class="lj"/></strong></figcaption></figure><p id="f884" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">外卖</em> : 1150倍<em class="jp">慢</em>。</p><p id="c2d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">时间不是唯一要浪费的东西。CPU也是。在逐个获取单元值的过程中，许多CPU内核会持续使用。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/1658280a535f827bc106e0a16adb527b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6bKrgudrrwBNbrmplxvFg.png"/></div></div></figure><p id="3009" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是如果考虑到<code class="du jq jr js jt b"><a class="ae jo" href="https://docs.python.org/3.8/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>的话，我希望进一步提速的原因。相关技术有<a class="ae jo" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">并发</a>和<a class="ae jo" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">多线程</a>。然而，它们更适合于受<em class="jp"> I/O限制的</em>任务，例如访问网络或硬盘。像我们正在做的提取细胞很可能会受到CPU的限制。正因如此，Python的<code class="du jq jr js jt b">multiprocessing</code>更合适。</p><p id="7923" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设必须挖掘单元的<code class="du jq jr js jt b">Locked</code>状态，l <em class="jp">低级</em>访问<code class="du jq jr js jt b">Cell</code>是必须的。如图所示，预计需要更多的时间和CPU但是，我们还是尽力了:</p><pre class="ky kz la lb fd ll jt lm ln aw lo bi"><span id="bff4" class="lp jv hi jt b fi lq lr l ls lt">pool = <strong class="jt hj">Pool</strong>(specified_cpu_count, initialize, ())  <br/>cell_values = list(map(lambda request: (request, extract_func), requests))<br/>results = pool.<strong class="jt hj">starmap</strong>(extracting_data, cell_values)</span></pre><p id="6068" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在处理数千个复杂的Excel文件的情况下，执行速度会变得难以忍受<strong class="is hj"><em class="jp"/></strong>对单元格的低级访问是必须的(这一点怎么强调都不为过！).幸运的是，<em class="jp">直接</em>挖掘深埋在上述<em class="jp"> raw </em> zipped-xml-folder格式中的那些信息可能是一个有前途的替代选择。我认为最完美的解决方案是最能满足我们特定需求的方案——这是我从《企业世界》中学到的一课。</p><h1 id="4173" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">实验</h1><p id="962b" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在<a class="ae jo" href="https://github.com/ThachNgocTran/ExtractExcelDataInParallel" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上，给定<code class="du jq jr js jt b">requests.txt</code>，指定一个<em class="jp">感兴趣区域</em>的列表。它的结构不言自明。我在两种模式下运行脚本。</p><p id="51c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个用于一次性提取单元格值:</p><pre class="ky kz la lb fd ll jt lm ln aw lo bi"><span id="10b2" class="lp jv hi jt b fi lq lr l ls lt">python main_program -num_core 4 -cell_mode value_fast<br/>-----------------------------------------<br/><strong class="jt hj">2019-12-03 20:27:23 INFO     Start processing Excel files.<br/>2019-12-03 20:27:26 INFO     Finish processing Excel files.</strong><br/>2019-12-03 20:27:26 INFO     Collected Dataframe: (5001, 2).<br/><strong class="jt hj">2019-12-03 20:27:26 INFO     First row: [Central America and the Caribbean Antigua and Barbuda |]</strong><br/>2019-12-03 20:27:26 INFO     Collected Dataframe: (5001, 2).<br/>2019-12-03 20:27:26 INFO     First row: [Baby Food|Online]<br/>2019-12-03 20:27:26 INFO     Collected Dataframe: (5001, 2).<br/>2019-12-03 20:27:26 INFO     First row: [M|12/20/2013]<br/>2019-12-03 20:27:26 INFO     Collected Dataframe: (5001, 2).<br/>2019-12-03 20:27:26 INFO     First row: [957081544|01/11/2014]<br/>2019-12-03 20:27:26 INFO     Done</span></pre><p id="eead" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个是一个接一个地做:</p><pre class="ky kz la lb fd ll jt lm ln aw lo bi"><span id="ce3d" class="lp jv hi jt b fi lq lr l ls lt">python main_program -num_core 4 -cell_mode value_aggressive<br/>-----------------------------------------<br/><strong class="jt hj">2019-12-03 20:17:35 INFO     Start processing Excel files.<br/>2019-12-03 20:21:50 INFO     Finish processing Excel files.</strong><br/>2019-12-03 20:21:50 INFO     Collected Dataframe: (5001, 2).<br/><strong class="jt hj">2019-12-03 20:21:50 INFO     First row: [Central America and the Caribbean Antigua and Barbuda |Central America and the Caribbean Antigua and Barbuda ]</strong><br/>2019-12-03 20:21:50 INFO     Collected Dataframe: (5001, 2).<br/>2019-12-03 20:21:50 INFO     First row: [Baby Food|Online]<br/>2019-12-03 20:21:50 INFO     Collected Dataframe: (5001, 2).<br/>2019-12-03 20:21:50 INFO     First row: [M|12/20/2013]<br/>2019-12-03 20:21:50 INFO     Collected Dataframe: (5001, 2).<br/>2019-12-03 20:21:50 INFO     First row: [957081544|01/11/2014]<br/>2019-12-03 20:21:50 INFO     Done</span></pre><p id="ba94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了在执行时间方面的巨大差异(3英寸对4英寸15英寸)，一个微妙的差异是主动模式可以提取单元格<code class="du jq jr js jt b">B1</code>，它是由<em class="jp">合并</em>和<code class="du jq jr js jt b">A1</code>。这只能通过<em class="jp">低级</em>访问来实现。</p><p id="b4f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jq jr js jt b">multiprocessing</code>的代价是需要更多内存。在代码中，每个进程都有其<em class="jp">自己的</em>Excel实例，为<em class="jp">提供一个给定的文件路径</em>！为了进一步提高效率，人们可以重写代码，以利用每个进程的单个Excel实例<em class="jp">来打开许多Excel文件；或者使用某种缓存机制在一段时间后关闭未使用的工作簿。</em></p><h1 id="2a3b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="c27c" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">其中，<code class="du jq jr js jt b">xlwings</code>允许我们<em class="jp">提取Excel文件中的</em>数据。它的优点(全功能/类似VBA，开发时间快)和缺点(在某些任务上很慢，依赖于微软)也被讨论。但是我们通过利用Python的<code class="du jq jr js jt b">multiprocessing.Pool</code>缓解了速度慢的问题。与主要由<em class="jp">构建</em> Excel文件的开发人员相比，主要由<em class="jp">提取</em> Excel数据的开发人员可能有不同的偏好。</p><p id="eb9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果<code class="du jq jr js jt b">multiprocessing</code>仍然不够，分布式计算是下一个考虑。参见[3]。</p><p id="3d6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我花在学习<code class="du jq jr js jt b">xlwings</code>上的时间并不显著；结果，我可能漏掉了一些要点。欢迎你的建议。祝编码愉快！</p><h1 id="0887" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参考</h1><p id="1fbb" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">[1]<a class="ae jo" href="https://docs.xlwings.org/en/stable/threading_and_multiprocessing.html" rel="noopener ugc nofollow" target="_blank">https://docs . XL wings . org/en/stable/threading _ and _ multi processing . html</a></p><p id="9ef8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2]<a class="ae jo" href="https://docs.xlwings.org/en/stable/api.html" rel="noopener ugc nofollow" target="_blank">https://docs.xlwings.org/en/stable/api.html</a></p><p id="4ad4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[3]<a class="ae jo" href="https://rise.cs.berkeley.edu/blog/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray/" rel="noopener ugc nofollow" target="_blank">https://rise . cs . Berkeley . edu/blog/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray/</a></p></div></div>    
</body>
</html>