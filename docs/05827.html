<html>
<head>
<title>Tracking COVID-19 spread in India — Time-Series data modeling and clustering in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">追踪新冠肺炎在印度的传播Python中的时序数据建模和聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tracking-covid-19-spread-in-india-time-series-data-modeling-and-clustering-in-python-f3ca70eb4f2?source=collection_archive---------20-----------------------#2020-05-03">https://medium.com/analytics-vidhya/tracking-covid-19-spread-in-india-time-series-data-modeling-and-clustering-in-python-f3ca70eb4f2?source=collection_archive---------20-----------------------#2020-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ae12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">探索和构建时序数据模型的实践演练</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="7f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本帖中，我们试图解决追踪全印度上升的新冠肺炎病例的问题。</p><p id="da5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，这个问题似乎可以通过按顺序组织的一系列数据点(案例数)来最好地表示(也称为时间序列数据)。但仔细观察，人们可能会发现有如此多的不同因素导致了印度病例数量的上升。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/a5ab91f6ee6924521045775aeed774de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*obEpzh0Rx2SfDkUcrgBPrw.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">各州案件总数(<a class="ae jw" href="https://www.covid19india.org/" rel="noopener ugc nofollow" target="_blank">https://www.covid19india.org/</a></figcaption></figure><p id="ec74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jx">在本帖中，我们将着眼于可以提取的不同特征(可用的和衍生的),并使用XGBoost构建/验证集成模型，以预测任何给定州每日报告的病例数。</em> </strong></p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="5e67" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">数据来源</strong></h1><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kw"><img src="../Images/7b9cadac4ca64d1e49b5e5866d92be02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOnqCoCPCgoA1eimzdL0aw.jpeg"/></div></div></figure><p id="766c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Covid19India.Org是一个开源项目，它整理和维护谷歌表单上与新冠肺炎相关的数据。他们有以CSV/JSON格式提供数据的HTTP-API。本分析中使用的数据简述如下:</p><ol class=""><li id="b48a" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">原始数据—这是实时数据，每隔几分钟就会更新一次，其中包含检测呈阳性的患者的信息</li><li id="505b" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">全国总检测数据——该数据来自ICMR网站，该网站每天更新每天进行的检测数量</li><li id="ce76" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">州级测试数据—这些数据来自不同的州政府和第三方资源。包含该州正在进行的测试总数</li></ol><p id="f1b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然，这些数据也有缺失值(我们将在后面的文章中处理)，但我确信整理和维护这些数据需要付出巨大的努力。感谢Covid19India.Org团队。请通过<a class="ae jw" href="https://t.me/covid19indiaops" rel="noopener ugc nofollow" target="_blank">电报</a>了解更多信息。</p><h1 id="6b70" class="jy jz hi bd ka kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv bi translated">数据准备</h1><p id="6fe2" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">让我们加载所需的库和包:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="82e1" class="mb jz hi bd ka mc md me ke mf mg mh ki iq mi mj km iu mk ml kq iy mm mn ku mo bi translated">1.国家一级的数据</h2><p id="f71a" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">该数据集包含以下重要信息:</p><ol class=""><li id="79f1" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated"><strong class="ih hj">日期</strong> —报告数字的日期</li><li id="8c2b" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">检出阳性病例总数(累计)</strong></li><li id="65d1" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">每日检测出的阳性病例数</strong></li><li id="fc3e" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">进行的COVID检测试验总数(累计)</strong></li><li id="8830" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">每天进行的COVID检测测试次数</strong></li></ol><p id="e0f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用Pandas读取文件，并将日期列解析为日期格式(这在接下来的部分中很重要)</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mp"><img src="../Images/ea5e8b5b93cb13f21763802d6343e835.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*X3-2RBfsAvclxHTXFDCKqw.png"/></div></figure><p id="7427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将通过执行滞后1差分，然后使用“回填”插值填充第一个值，将累积计数转换为每日计数。此外，为了获取最近的数据，我们将定义一个较低的截止日期，该日期将指定需要考虑数据的日期。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mq"><img src="../Images/081ca9f3ae2895c465fc04d8826bd926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*P9XqdT1CEwEACV0pprUj4g.png"/></div></figure><p id="e9a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。状态级别数据</strong></p><p id="e32f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用这个<a class="ae jw" href="https://api.covid19india.org/csv/latest/raw_data3.csv" rel="noopener ugc nofollow" target="_blank"> csv </a>获取<strong class="ih hj">各州病例数</strong>的数据源。这是一个病人级别的数据集，我们将把它带到州日期级别。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mr"><img src="../Images/04882aaab9ea7f6d1a9e244a38acc14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*5YdX36OuPRN5Jbh6j9-9rw.png"/></div></figure><p id="f5ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们从单独的<a class="ae jw" href="https://api.covid19india.org/csv/latest/statewise_tested_numbers_data.csv" rel="noopener ugc nofollow" target="_blank"> csv </a>中加载<strong class="ih hj">状态级测试数据</strong>。然后，我们将它与州级案例数合并，以获得以下每日州级统计数据框架:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es ms"><img src="../Images/817f6cb8e0574f50038ba47ac05a6d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*YSZrIXog92erZskSpGyl8A.png"/></div></figure><p id="d701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，查看各州的测试数据，这些数据并不是非常完整和详尽的。例如，让我们看看德里的数据:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mt"><img src="../Images/890bd7de312b03e7bf3a595ec501cc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*dffCL1q-aFIZXek5s6dxtQ.png"/></div></figure><p id="07f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过简单地以线性方式内插这些值来填充<strong class="ih hj">累积投资状态总测试</strong>中的这些缺失值。然而，这可能不是最准确的方式来填补这一点。相反，我们将对<strong class="ih hj">累积国家测试</strong>进行加权，因为我们有每个日期的数据。下面的流程图说明了我们如何做到这一点:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mu"><img src="../Images/c8ff3832205f927ec499df6397583828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1H1oLGWVJJkbtPMXVQ7ew.png"/></div></div></figure><ol class=""><li id="cc84" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">获取上面数据框架中每个日期的国家总测试数</li><li id="a6e1" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">计算各州考试人数对全国考试人数的贡献</li><li id="d828" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">使用线性插值法填充StateTestingContribution值</li><li id="412e" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">现在，通过将状态的估计贡献(通过在步骤3中插值获得)乘以当天进行的总绝对测试，来填充每日测试数中的缺失值</li><li id="18c2" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">通过累计值的差值计算在一个州进行的日常测试</li></ol><p id="9c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种方式，我们得到了该州一天内进行的测试数量的近似估计值。</p><p id="253d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们在Python中的做法:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="c30d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有完整的数据集如下:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mv"><img src="../Images/6c9f735352a242c207f150d760691fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*ibctd1ZmkUT2UeMNz7JqPA.png"/></div></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="99c2" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">探索性数据分析</strong></h1><p id="87db" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">让我们来看看我们在上一节中清理的一些变量:</p><ol class=""><li id="ce70" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">看起来是一个持续上升的趋势，围绕着它有波动。</li></ol><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mw"><img src="../Images/b98a70002d4adb303e4a4ca17d1ba6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niKTx6uiH-tLf_DQQD2Arg.png"/></div></div></figure><p id="93eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。全国范围内进行的考试数量也在增加，尽管速度不同</strong></p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mx"><img src="../Images/926ce37ec7f13098d2bb3017f3858c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jeW8iHIze0dIdIha.png"/></div></div></figure><p id="d790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">各州的趋势也是相似的，尽管我们想了解各州之间感染传播的差异。</p><p id="0b3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为探索性练习，我们来看两个指标，它们有助于我们了解一个州内的感染传播情况:</p><ol class=""><li id="651d" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">州内本地传播的百分比——我们对少数患者进行了分类(可作为样本)</li><li id="1f12" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">检测阳性率— </strong>检测呈阳性的样本百分比</li></ol><p id="49c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将提取本地传输速率和TPR，然后查看状态的分布，以区分高风险v/s低风险状态。</p><p id="2bc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先提取本地传输速率:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es my"><img src="../Images/2264bb836f2208be795bd7f2836c2fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*QndjCy3JPMxc6MRXIZngtQ.png"/></div></figure><p id="dff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将把阳性病例总数加上在该州进行的检测总数的百分比，以表示检测阳性率</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mz"><img src="../Images/3f84098b29a258e3377f6cc8a6ab43e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*H6Keu7dQgbIe043KAZ1ewA.png"/></div></figure><p id="1c97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看一个散点图，以了解这两个参数的状态分布:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es na"><img src="../Images/00c2f4cf23c12d42b4923df60cb14512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HS8OjK-lfQIX71rr5OJTuQ.png"/></div></div></figure><p id="8feb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，这些状态分散在各处，似乎成簇分布。因此，自然地，我们应用K-Means聚类算法来识别具有高本地传输和TPR(spread)的状态。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="3d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以看看下面矩阵中的4个集群，以了解高影响和低影响状态:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es nb"><img src="../Images/6a9cb361efd9cb5d794c1b60e3d7829d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*x1qx7icSVDn_DTEcEAuDrA.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">聚类结果以存储状态</figcaption></figure><p id="c0bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有助于我们了解全国的情况，不仅可以看到感染人数，还可以看到传播方式和检测阳性率(TPR)。</p><h1 id="ac31" class="jy jz hi bd ka kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv bi translated"><strong class="ak">特色工程</strong></h1><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es nc"><img src="../Images/c34d14da288f2a3954b0f0e3923340e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*I1q4DL0V5Go5MjtH.jpg"/></div></figure><p id="575d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们希望在州级别构建模型，因此让我们看看目前为止每个州的功能:</p><ol class=""><li id="9669" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated"><strong class="ih hj">CumulativeStatewiseTotalTests—</strong>这给出了在该状态下进行的测试的累计次数，直到数据帧中的相应日期</li><li id="314e" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj"> TestPositivityRate — </strong>检测出阳性病例的检测比例</li><li id="80eb" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">每日阳性数— </strong>数据框中相应日期确认的新阳性病例数</li></ol><p id="1ef9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们知道进行测试的次数是一个非常重要的指标，它影响着一天内确定的阳性病例总数</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es nd"><img src="../Images/adc9717e52d02813ef8809ed3ac3ce9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*a1B3XmGRRghm5QCxZTtU8g.png"/></div></figure><p id="b58e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于戈德史密斯可能已经泄露了消息，每日的正面消息也将取决于前几天的情况。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es ne"><img src="../Images/0d7d4d18a401f49ed7684c4377a5daa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*cPBRSK3gmTc9slLxHayLfg.png"/></div></figure><p id="5260" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们为这些变量取多个滞后值，然后我们可以在稍后列出有用的值:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es nf"><img src="../Images/44e9bf424beb841a0c4a782ad9b1ffba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7mvnZHVdnmPBfm-hg6Zvw.png"/></div></div></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="2519" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">模型构建</strong></h1><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es ng"><img src="../Images/5c836358bf3c4a04378e74ddd03900b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*sIvfpXZANH9RIPUTBETURg.png"/></div></figure><p id="cf62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将在集合模型中使用<a class="ae jw" href="https://towardsdatascience.com/tree-based-methods-regression-trees-4ee5d8db9fe9" rel="noopener" target="_blank">回归树</a>查看建模时间序列数据。</p><p id="2806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回归树类似于决策树，是最容易解释的模型之一，但是这是以准确性为代价的。这是通过使用<a class="ae jw" href="https://towardsdatascience.com/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205" rel="noopener" target="_blank">技术</a>如bagging或boosting组合不同的回归树(弱学习者)来解决的。两种组装技术的简介:</p><ol class=""><li id="b28f" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated"><strong class="ih hj">Bagging</strong>——我们采用多个弱学习者，并行地独立训练他们，然后按照某种确定性平均过程将他们组合起来</li><li id="58e4" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">促进— </strong>这是一个连续的过程，其中一个弱学习者依赖于前一个弱学习者。在每一步中，新的学习者将给予先前被错误分类的数据点更多的权重，并且将尝试正确地分类这些数据点。升压可以以多种方式实现，例如自适应升压(AdaBoost)、梯度升压(GBM)等。</li></ol><p id="2ed5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个问题，我们将使用一个GBM的变体，在Python中称为<strong class="ih hj"> XGBRegressor </strong>。这将有助于我们将boosting方法应用于连续变量。</p><p id="ac9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在我们将数据集分为训练数据集和测试数据集之前，让我们删除重复值并用0填充空值(如果有的话)。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="2744" class="mb jz hi bd ka mc md me ke mf mg mh ki iq mi mj km iu mk ml kq iy mm mn ku mo bi translated"><strong class="ak">基线精度</strong></h2><p id="7dce" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">让我们尝试创建一个基线精度，以了解要达到的最低基准，这是由一个相当简单的近似值确定的。如果这是一个二进制分类的问题，我们可以很容易地假设基线准确率为50%(抛硬币)。在这种情况下，我们可以将前一天的值近似为找到的阳性病例数的第二天的值。让我们看看采用这种策略的准确性如何:</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0ee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们一个基线精度，为38.82%，这是使用该模型所无法超越的</p><h2 id="e5f4" class="mb jz hi bd ka mc md me ke mf mg mh ki iq mi mj km iu mk ml kq iy mm mn ku mo bi translated"><strong class="ak">训练模型</strong></h2><p id="375f" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">让我们从创建一个将ADS(分析数据集)分成训练和测试的函数开始。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="e1db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将创建一种方法来为每个州的XGBRegressor模型定型。为此，让我们创建一个名为XGBOptimizer的类，在其中我们将实现构建一个状态的模型所需的所有方法。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="b561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了训练XGBRegressor模型，我们将使用<a class="ae jw" href="http://hyperopt.github.io/hyperopt/" rel="noopener ugc nofollow" target="_blank"> HyperOpt </a>进行超参数调整。这个软件包帮助我们以最小化损失函数的方式设置超参数(在我们的例子中是RMSE)。</p><p id="83e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们简要回顾一下本课程中的不同功能:</p><ol class=""><li id="46e1" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">optimize_hp:这是进行优化的主要函数。它从HyerOpt库中调用fmin函数，这将进行贝叶斯优化。它接受以下参数:</li></ol><ul class=""><li id="68e1" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc nh lh li lj bi translated">fn —损失函数，采用当前参数集并返回需要最小化的损失值。例如，训练模型并返回RMSE值的函数</li><li id="45c4" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nh lh li lj bi translated">空间-定义不同参数值的空间。我们可以定义这个空间，以确保它被约束在模型的预期参数值内。例如，我们返回所有参数的字典以及它们可以取的值的范围</li><li id="faeb" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nh lh li lj bi translated">algo —这由HyperOpt负责。这实际上指定了在选择下一组参数值时要使用的贝叶斯算法，HyperOpt使用<a class="ae jw" href="https://github.com/hyperopt/hyperopt/blob/master/hyperopt/tpe.py" rel="noopener ugc nofollow" target="_blank">树结构Parzen估计器模型</a>，我们可以调用tpe.suggest为我们自动配置算法</li><li id="62ad" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nh lh li lj bi translated">试验——这是一个记录不同评估值的试验对象(来自HyperOpt)。在优化之后，这个对象可以用来查看尝试的不同值</li><li id="65c5" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nh lh li lj bi translated">return _ arg min-False值将返回使损失函数最小化的实际最优值，而True值将使函数返回最优值的索引</li></ul><p id="7e49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.train _ reg:loss函数，用给定的参数训练模型并返回损失</p><p id="0899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.train_best_model:用优化后的最终参数训练模型</p><p id="a038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.get_xgb_possible_params:返回所有可能的参数值的值空间</p><p id="a690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.get_xgb_preds:打印最佳模型的测试和训练精度(MAPE)</p><p id="b780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唷！！现在，我们已经创建了这个框架，我们可以调用这些函数，并为各个状态训练模型。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ni"><img src="../Images/ab94d571e4d99a3d1e53f5cfeae7a249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDxAzb755PNERFko1WYQEw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">一种状态的控制台输出示例</figcaption></figure><p id="93f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看所有这些模型的训练和测试准确度:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es nj"><img src="../Images/1a0c6c649c398efc0e535f66b305ba10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5rnccJh0-HETr6wioFdCA.png"/></div></div></figure><p id="558f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然训练精度比基线模型好，但是测试精度在<strong class="ih hj"> 93.83% </strong>看起来相当不错。尽管如此，我们只创建了每个状态1个数据点的测试集。</p><p id="216e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这些模型中的每一个都有它们自己的重要特征，并且这些特征对于每一个模型都是不同的。例如，对于马哈拉施特拉邦，让我们看看XGBoost生成的要素重要性值</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es nk"><img src="../Images/473507565d1284d9849f8406c17f6469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOxAzZ5FFKswvkvw1ECFsA.png"/></div></div></figure></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="3a80" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">结论</strong></h1><p id="4686" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">我们能够以很高的准确度对新冠肺炎的真实世界时间序列数据进行建模，以预测第二天的积极结果。这最终可以帮助我们理解我们在考虑跨州感染控制方面的发展方向。</p><ol class=""><li id="88f4" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">我们使用了来自Covid19India.Org的数据，这些数据是由州和国家提供的。利用国家级数据来完善州级数据</li><li id="ec2b" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">州级统计数据帮助我们根据分布情况将各州分为4个不同的部分</li><li id="3656" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">我们使用XGBoost来预测每个州每天即将出现的病例数</li><li id="801e" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">我们使用贝叶斯优化来调整XGBoost模型，以获得最佳结果</li><li id="5277" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">国家级模型给出的综合验证准确度为<strong class="ih hj"> 93.8% </strong></li></ol><p id="9b63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jx">本文概述了使用XGBoost使用真实世界数据对时间序列数据建模的过程。</em></p><p id="baee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jx">感谢你阅读这篇文章！如果你有任何问题，请在下面留言。</em></p></div></div>    
</body>
</html>