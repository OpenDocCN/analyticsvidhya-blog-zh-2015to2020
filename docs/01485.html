<html>
<head>
<title>Credit Card Fraud Detection in Python using Scikit Learn.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Scikit Learn在Python中进行信用卡欺诈检测。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/credit-card-fraud-detection-in-python-using-scikit-learn-f9046a030f50?source=collection_archive---------0-----------------------#2019-10-26">https://medium.com/analytics-vidhya/credit-card-fraud-detection-in-python-using-scikit-learn-f9046a030f50?source=collection_archive---------0-----------------------#2019-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9d9c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="6ecf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">【注:“编码者”，来看机器学习算法的可以直接跳转代码】</p><p id="0d5a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我已经厌倦了所有我收到的关于我的信用卡被使用的确认信息，如果不是我，我会要求回复。不仅仅是信用卡，任何在线支付媒介，他们总是用他们疯狂的确认信息来烦你。我有时会想，为什么他们不能被说服，在确实有可疑的事情发生的时候给我发信息。我打赌你也是。但信用卡欺诈是政府面临的最大问题之一，涉及的金额通常非常巨大。所以我们来看看这类服务商面临的挑战是什么。我们采取了什么策略来解决这个巨大的问题，为什么你会如此频繁地被这些信息骚扰？</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/70c903f90153569a1b9aa6d8758d0259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3f4KQvOVZQRCsFLxvHD4rA.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">特征图像</figcaption></figure><h2 id="15b9" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">信用卡诈骗是如何发生的？</h2><p id="bcb3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一些最常见的可能发生方式是:</p><ul class=""><li id="18e8" class="lk ll hi jf b jg kb jk kc jo lm js ln jw lo ka lp lq lr ls bi translated">首先，也是最明显的，当你的<strong class="jf hj">卡的细节</strong>被其他人<strong class="jf hj">监督</strong>时。</li><li id="fb64" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">当你的<strong class="jf hj">卡丢失或被盗</strong>时，拥有它的人知道如何处理事情。</li><li id="9ee8" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated"><strong class="jf hj">假电话</strong>电话说服你分享细节。</li><li id="e25a" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">最后，也是最不可能的一点是，对银行账户细节的高级黑客攻击。</li></ul><h2 id="cf78" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">信用卡欺诈检测面临的主要挑战是:</h2><ul class=""><li id="93d7" class="lk ll hi jf b jg jh jk jl jo ly js lz jw ma ka lp lq lr ls bi translated"><strong class="jf hj">每天都要处理大量数据</strong>，模型构建必须足够快，以便及时应对骗局。</li><li id="2571" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated"><strong class="jf hj">不平衡的数据</strong>即大多数交易(99.8%)不是欺诈性的，这使得检测欺诈性交易变得非常困难</li><li id="50f5" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated"><strong class="jf hj">数据可用性</strong>因为数据大多是私有的。</li><li id="eeac" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated"><strong class="jf hj">分类错误的数据</strong>可能是另一个主要问题，因为并非所有欺诈交易都会被发现和报告。</li><li id="9c3b" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">最后但并非最不重要的一点是，<strong class="jf hj">骗子针对模型使用的适应性技术</strong>。</li></ul><h2 id="0c07" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">如何应对这些挑战？</h2><ul class=""><li id="d698" class="lk ll hi jf b jg jh jk jl jo ly js lz jw ma ka lp lq lr ls bi translated">使用的<strong class="jf hj">模型</strong>必须<strong class="jf hj">足够简单快速</strong>以检测异常情况并尽快将其归类为欺诈交易。</li><li id="cf7e" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">可以通过适当地使用一些方法来处理不平衡，我们将在下一段中讨论这些方法</li><li id="e16b" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">为了保护用户的隐私，可以减少数据的维度<strong class="jf hj"/>。</li><li id="b369" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">至少为了训练模型，必须采用一个更可信的来源来双重检查数据。</li><li id="eb83" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">我们可以使模型<strong class="jf hj">简单易懂</strong>，这样当骗子只需稍加调整就能适应它时，我们就可以部署一个新的模型。</li></ul><h2 id="867e" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">处理不平衡</h2><p id="99ea" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将在本文的后面部分看到，我们收到的数据是高度不平衡的，即只有0.17%的信用卡交易是欺诈性的。嗯，类不平衡是现实生活中非常常见的问题，在应用任何算法之前都需要处理。</p><p id="bfd5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有三种常见的方法来处理数据的不平衡</p><ul class=""><li id="faeb" class="lk ll hi jf b jg kb jk kc jo lm js ln jw lo ka lp lq lr ls bi translated"><strong class="jf hj">欠采样</strong>-Kubat和Matwin的单边采样(ICML 1997)</li><li id="1c11" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated"><strong class="jf hj">过采样</strong> - <strong class="jf hj"> SMOTE </strong>(合成少数过采样技术)</li><li id="0f2f" class="lk ll hi jf b jg lt jk lu jo lv js lw jw lx ka lp lq lr ls bi translated">综合以上两者。</li></ul><p id="a88d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种不平衡不在本文的讨论范围之内。<a class="ae mb" href="https://www.analyticsvidhya.com/blog/2016/03/practical-guide-deal-imbalanced-classification-problems/" rel="noopener ugc nofollow" target="_blank">这里</a>是另一篇指导你具体处理这个问题的文章。</p><p id="46a4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于那些想知道欺诈性交易是否如此罕见的人来说，这是另一个事实。欺诈交易涉及的金额高达数十亿美元，通过将特异性提高到0.1%，我们可以节省数百万美元。而更高的敏感度意味着被骚扰的人更少。</p><h1 id="28e7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码</h1><p id="b27a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你好编码员，如果你直接跳到这一部分，这里是你需要知道的。信用卡欺诈是不好的，我们必须找到一种方法来识别欺诈，使用数据中提供给我们的一些特征，目前您可以完全依赖这些特征。所以不多说了，让我们开始吧。</p><p id="e0db" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先选择了一个平台，我更喜欢Google Colab，但Kaggle也很棒。你可以从GPU配置的角度来比较<a class="ae mb" href="https://towardsdatascience.com/kaggle-vs-colab-faceoff-which-free-gpu-provider-is-tops-d4f0cd625029" rel="noopener" target="_blank">这篇</a>文章中的这两个，因为价格不是一个因素(它们都是免费使用的)。</p><p id="11bb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你想让我写一篇关于如何使用Google Colab或Kaggle平台或你的本地机器来构建你的分类器的文章，请在下面的评论中告诉我😉。</p><p id="3b29" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里是到笔记本资源库的<a class="ae mb" href="https://github.com/amancodeblast/Credit-Card-Fraud-Detection" rel="noopener ugc nofollow" target="_blank"> GitHub </a>链接。您可以派生它，甚至推送来建议存储库中的一些更改。请随意尝试。</p><p id="c200" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">导入依赖关系</strong></p><p id="a4f2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是导入所有需要的依赖项的代码</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="f625" class="kw ig hi md b fi mh mi l mj mk"># import the necessary packages<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from matplotlib import gridspec</span></pre><p id="e803" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您还没有安装所有这些依赖项，我推荐您安装Anaconda发行版,它包含了您将会遇到的大多数包。你也可以观看这个视频来指导windows安装Anaconda，或者阅读<a class="ae mb" href="https://www.analyticsvidhya.com/blog/2019/08/everything-know-about-setting-up-python-windows-linux-and-mac/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章，作者是Analytical Vidya for Mac或Linux。</p><p id="8f5c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">加载数据</strong></p><p id="1951" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你得先从<a class="ae mb" href="https://www.kaggle.com/mlg-ulb/creditcardfraud/data#" rel="noopener ugc nofollow" target="_blank"> Kaggle网站</a>下载数据。单击屏幕中间新笔记本按钮旁边的下载按钮。</p><p id="7ced" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，您可以使用这段代码将数据集加载到您正在使用的ipython笔记本中。</p><p id="3300" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意:括号中的路径必须是您在计算机中存储数据集的路径。如果您使用的是Colab，那么您可以将您的驱动器安装到笔记本上，并将其提供给Google Drive的数据集目录路径。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="5540" class="kw ig hi md b fi mh mi l mj mk"># Load the dataset from the csv file using pandas<br/>data = pd.read_csv(‘/content/drive/My Drive/creditcard.csv’)</span></pre><h2 id="47a6" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">理解数据</h2><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="c686" class="kw ig hi md b fi mh mi l mj mk">Grab a peak at the data<br/>data.head()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ml"><img src="../Images/3f834bff9b8807fe33d02f9440077334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkVrs-z8dS39LIAxTvHyEw.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图1可从Kaggle获得的数据</figcaption></figure><p id="aee5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于一些保密问题，原来的功能被替换为V1，V2，… V28列，这是应用于原来的PCA转换的结果。唯一没有被PCA转换的特征是“时间”和“数量”。特征“类别”是响应变量，在欺诈的情况下取值1，否则取值0。</p><p id="111b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">时间</strong></p><p id="2f28" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">此事务与数据集中第一个事务之间经过的秒数。</p><p id="092b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">金额</strong></p><p id="9502" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">交易金额</p><p id="57dc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">类</strong></p><p id="9ac8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">1表示欺诈交易，否则为0</p><p id="3b06" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">知道数字</strong></p><p id="4700" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您想先处理一个较小的数据集，然后当一切正常时，可以选择取消对第二行的注释，再次注释它并运行所有单元格。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="47bf" class="kw ig hi md b fi mh mi l mj mk"># Print the shape of the data<br/># data = data.sample(frac=0.1, random_state = 48)<br/>print(data.shape)<br/>print(data.describe())</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mm"><img src="../Images/99ec7a32fc9ccbd185ca80099a3ab51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSG8Qof0HDAAeRh8L9BjBQ.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图2描述了数据</figcaption></figure><p id="a6b0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们将在图表上可视化数据集的所有要素。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="e555" class="kw ig hi md b fi mh mi l mj mk"># distribution of anomalous features<br/>features = data.iloc[:,0:28].columns</span><span id="2541" class="kw ig hi md b fi mn mi l mj mk">plt.figure(figsize=(12,28*4))<br/>gs = gridspec.GridSpec(28, 1)<br/>for i, c in enumerate(data[features]):<br/> ax = plt.subplot(gs[i])<br/> sns.distplot(data[c][data.Class == 1], bins=50)<br/> sns.distplot(data[c][data.Class == 0], bins=50)<br/> ax.set_xlabel(‘’)<br/> ax.set_title(‘histogram of feature: ‘ + str(c))<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mo"><img src="../Images/bde1d5e69fdb3e60169366f695d6d702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuCOg62UaBK4ri2chrtpvQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图3可视化数据</figcaption></figure><p id="8157" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们将欺诈案例与真实案例分开，并比较它们在数据集中的出现情况。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="5d28" class="kw ig hi md b fi mh mi l mj mk"># Determine number of fraud cases in dataset</span><span id="ff2a" class="kw ig hi md b fi mn mi l mj mk">Fraud = data[data[‘Class’] == 1]<br/>Valid = data[data[‘Class’] == 0]</span><span id="fc99" class="kw ig hi md b fi mn mi l mj mk">outlier_fraction = len(Fraud)/float(len(Valid))<br/>print(outlier_fraction)</span><span id="7004" class="kw ig hi md b fi mn mi l mj mk">print(‘Fraud Cases: {}’.format(len(data[data[‘Class’] == 1])))<br/>print(‘Valid Transactions: {}’.format(len(data[data[‘Class’] == 0])))</span></pre><p id="d459" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">欺诈在所有交易中，欺诈交易仅占0.17%。数据极不平衡。让我们首先应用我们的模型，但不要平衡它，如果我们没有获得很好的准确性，那么我们可以找到一种方法来平衡这个数据集。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mp"><img src="../Images/ebb92960eede1fd7c060d26486bb3273.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*gFym-RxoXhAj2iKDHJX0sA.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图5欺诈案件的百分比</figcaption></figure><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="3251" class="kw ig hi md b fi mh mi l mj mk">print(“Amount details of fraudulent transaction”)<br/>Fraud.Amount.describe()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mq"><img src="../Images/5efed1e4075fd9275e63f8d1d3cc9aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*aMmxShfkYizfKiZN5pvEFA.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图6欺诈交易的金额明细</figcaption></figure><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="a8ac" class="kw ig hi md b fi mh mi l mj mk">print(“details of valid transaction”)<br/>Valid.Amount.describe()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mr"><img src="../Images/11e1e5419f715081a6bc2006ec2239a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*YTmOH8nWsJSO2nAaLum-kQ.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图7有效交易的金额明细</figcaption></figure><p id="9421" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以清楚地注意到，欺诈者的平均金钱交易更多。这使得这个问题的处理至关重要。</p><p id="00c2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">相关矩阵以图形方式让我们了解特征之间的相互关系，并帮助我们预测与预测最相关的特征。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="508b" class="kw ig hi md b fi mh mi l mj mk"># Correlation matrix<br/>corrmat = data.corr()<br/>fig = plt.figure(figsize = (12, 9))</span><span id="2bf5" class="kw ig hi md b fi mn mi l mj mk">sns.heatmap(corrmat, vmax = .8, square = True)<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ms"><img src="../Images/357a4debee6ea4a8d55ec253eadea457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*teLLYuC56Pn0ZoI2o21ITw.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图8相关矩阵</figcaption></figure><p id="da1d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在热图中，我们可以清楚地看到大多数功能与其他功能不相关，但有一些功能彼此之间存在正相关或负相关。例如，“V2”和“V5”与称为“数量”的特征高度负相关。我们也看到与“V20”和“量”的一些关联。这让我们对现有数据有了更深入的了解。</p><p id="753b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，让我们继续将数据值划分为特性和目标。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="6b16" class="kw ig hi md b fi mh mi l mj mk">#dividing the X and the Y from the dataset<br/>X=data.drop([‘Class’], axis=1)<br/>Y=data[“Class”]<br/>print(X.shape)<br/>print(Y.shape)<br/>#getting just the values for the sake of processing (its a numpy array with no columns)<br/>X_data=X.values<br/>Y_data=Y.values</span></pre><p id="94c6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用Skicit learn将数据分为训练和测试。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="c50e" class="kw ig hi md b fi mh mi l mj mk"># Using Skicit-learn to split data into training and testing sets<br/>from sklearn.model_selection import train_test_split<br/># Split the data into training and testing sets<br/>X_train, X_test, Y_train, Y_test = train_test_split(X_data, Y_data, test_size = 0.2, random_state = 42)</span></pre><h2 id="68ce" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">构建隔离林模型</h2><p id="5f87" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">隔离林一般用于异常检测。如果你想了解这个算法的更多信息，请随意看看这个视频。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="df1d" class="kw ig hi md b fi mh mi l mj mk">#Building another model/classifier ISOLATION FOREST<br/>from sklearn.ensemble import IsolationForest<br/>ifc=IsolationForest(max_samples=len(X_train),<br/> contamination=outlier_fraction,random_state=1)<br/>ifc.fit(X_train)<br/>scores_pred = ifc.decision_function(X_train)<br/>y_pred = ifc.predict(X_test)</span></pre><h2 id="3b55" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">在测试集上构建评估矩阵</h2><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="ece7" class="kw ig hi md b fi mh mi l mj mk"># Reshape the prediction values to 0 for valid, 1 for fraud. <br/>y_pred[y_pred == 1] = 0<br/>y_pred[y_pred == -1] = 1</span><span id="d61c" class="kw ig hi md b fi mn mi l mj mk">n_errors = (y_pred != Y_test).sum()</span></pre><p id="8c30" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">可视化该模型的混淆矩阵。</strong></p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="66ed" class="kw ig hi md b fi mh mi l mj mk">#printing the confusion matrix<br/>LABELS = [‘Normal’, ‘Fraud’]<br/>conf_matrix = confusion_matrix(Y_test, y_pred)<br/>plt.figure(figsize=(12, 12))<br/>sns.heatmap(conf_matrix, xticklabels=LABELS,<br/> yticklabels=LABELS, annot=True, fmt=”d”);<br/>plt.title(“Confusion matrix”)<br/>plt.ylabel(‘True class’)<br/>plt.xlabel(‘Predicted class’)<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mt"><img src="../Images/afd6aeaeffbf183fe97c6ae24edf70df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*VbLLim6AfZeVKqx38dDl2g.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图9隔离林的混淆矩阵。</figcaption></figure><p id="3ca7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们看看如何评估模型并打印结果。我们将计算准确度、精确度、召回率、F1分数和马修斯相关系数，以便进行总体分析。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="a22a" class="kw ig hi md b fi mh mi l mj mk">#evaluation of the model<br/>#printing every score of the classifier<br/>#scoring in any thing<br/>from sklearn.metrics import confusion_matrix<br/>n_outliers = len(Fraud)<br/>print(“the Model used is {}”.format(“Isolation Forest”))<br/>acc= accuracy_score(Y_test,y_pred)<br/>print(“The accuracy is {}”.format(acc))<br/>prec= precision_score(Y_test,y_pred)<br/>print(“The precision is {}”.format(prec))<br/>rec= recall_score(Y_test,y_pred)<br/>print(“The recall is {}”.format(rec))<br/>f1= f1_score(Y_test,y_pred)<br/>print(“The F1-Score is {}”.format(f1))<br/>MCC=matthews_corrcoef(Y_test,y_pred)<br/>print(“The Matthews correlation coefficient is{}”.format(MCC))</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mu"><img src="../Images/c2c52686018914572ff8d01fd945500b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWtnmqLuU71l4sif-W25MA.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图10隔离林模型报告</figcaption></figure><p id="35ea" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如你可以清楚地看到，这个模型并不像预期的那样好，所以让我们建立一些其他的模型来获得更好的结果。</p><h2 id="48dd" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">构建随机森林模型</h2><p id="0de6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们构建一个随机森林来提高检测器的性能。我想到了使用决策树模型，但正如我们所知的<strong class="jf hj"> <em class="mv">随机森林</em> </strong>就像是<strong class="jf hj"> <em class="mv">决策树</em> </strong>的军队，那么为什么还要费心尝试和失败。你可以认为随机森林是应用于决策树的集合。<a class="ae mb" href="http://analyticsvidhya.com/blog/2014/06/introduction-random-forest-simplified/" rel="noopener ugc nofollow" target="_blank">这里的</a>是对随机森林的一个很好很简单的解释。</p><p id="a1fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你也可以参考这个视频</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="7644" class="kw ig hi md b fi mh mi l mj mk"># Building the Random Forest Classifier (RANDOM FOREST)<br/>from sklearn.ensemble import RandomForestClassifier<br/># random forest model creation<br/>rfc = RandomForestClassifier()<br/>rfc.fit(X_train,Y_train)<br/># predictions<br/>y_pred = rfc.predict(X_test)</span></pre><h2 id="a8fa" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">在测试集上构建评估矩阵</h2><p id="75b4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们看看如何评估模型并打印结果。我们将计算准确度、精确度、召回率、F1分数和马修斯相关系数。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="2cd8" class="kw ig hi md b fi mh mi l mj mk">#Evaluating the classifier<br/>#printing every score of the classifier<br/>#scoring in any thing<br/>from sklearn.metrics import classification_report, accuracy_score,precision_score,recall_score,f1_score,matthews_corrcoef<br/>from sklearn.metrics import confusion_matrix<br/>n_outliers = len(Fraud)<br/>n_errors = (y_pred != Y_test).sum()<br/>print(“The model used is Random Forest classifier”)<br/>acc= accuracy_score(Y_test,y_pred)<br/>print(“The accuracy is {}”.format(acc))<br/>prec= precision_score(Y_test,y_pred)<br/>print(“The precision is {}”.format(prec))<br/>rec= recall_score(Y_test,y_pred)<br/>print(“The recall is {}”.format(rec))<br/>f1= f1_score(Y_test,y_pred)<br/>print(“The F1-Score is {}”.format(f1))<br/>MCC=matthews_corrcoef(Y_test,y_pred)<br/>print(“The Matthews correlation coefficient is{}”.format(MCC))</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mw"><img src="../Images/f1eab5be3cf16b9f62a80b517ee610cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4KyTWhuMhsSj3Ea12rSvQ.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图11模型报告随机森林。</figcaption></figure><p id="a657" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">可视化混淆矩阵。</strong></p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="698a" class="kw ig hi md b fi mh mi l mj mk">#printing the confusion matrix<br/>LABELS = [‘Normal’, ‘Fraud’]<br/>conf_matrix = confusion_matrix(Y_test, y_pred)<br/>plt.figure(figsize=(12, 12))<br/>sns.heatmap(conf_matrix, xticklabels=LABELS, yticklabels=LABELS, annot=True, fmt=”d”);<br/>plt.title(“Confusion matrix”)<br/>plt.ylabel(‘True class’)<br/>plt.xlabel(‘Predicted class’)<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mt"><img src="../Images/67530b85826ef21ab12d1b4d2dcf3ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*WOk8rda6Ah-TkTmbB8i_mw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图12随机森林</figcaption></figure><h2 id="27dc" class="kw ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">想象森林</h2><p id="5c6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从森林中随机选取一棵树，然后可视化，以便了解算法如何做出决定，如果骗子采取对策，这将有助于轻松改变模型。为此，你必须从Sklearn库和IPython库中导入一些工具，以便在笔记本中显示。</p><pre class="kh ki kj kk fd mc md me mf aw mg bi"><span id="f35d" class="kw ig hi md b fi mh mi l mj mk">#visualizing the random tree <br/>feature_list = list(X.columns)<br/># Import tools needed for visualization<br/>from IPython.display import Image<br/>from sklearn.tree import export_graphviz<br/>import pydot</span><span id="d50e" class="kw ig hi md b fi mn mi l mj mk">#pulling out one tree from the forest<br/>tree = rfc.estimators_[5]<br/>export_graphviz(tree, out_file = ‘tree.dot’, feature_names = feature_list, rounded = True, precision = 1)<br/># Use dot file to create a graph<br/>(graph, ) = pydot.graph_from_dot_file(‘tree.dot’)<br/># Write graph to a png file<br/>display(Image(graph.create_png()))</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mx"><img src="../Images/f8644b44d1db1b9ff85682d78968f4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kw-f15fAjKXw1-XLn68D0w.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图13可视化决策树</figcaption></figure><h1 id="85cb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es my"><img src="../Images/6cd31c9765c43946f7ffafc1e44b06f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8-XY9di8R2Uclkhiv4fAw.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图14比较的其他模型</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mw"><img src="../Images/f1eab5be3cf16b9f62a80b517ee610cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4KyTWhuMhsSj3Ea12rSvQ.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图16随机森林报告</figcaption></figure><p id="6ceb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们的<strong class="jf hj">随机森林</strong>结果在大多数情况下超过了之前报道的结果，其<strong class="jf hj">马修斯相关系数</strong>为<strong class="jf hj"> 0.8629。</strong>其他性能特征也令人满意，因此现在我们不需要对此应用其他模型。</p><p id="c910" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如你可以清楚地看到，我们的模型或任何模型，一般来说，有一个低召回值，这正是你在交易后被<em class="mv">那么多确认信息</em>骚扰的原因。但随着机器学习模型越来越多的进步，我们正在缓慢但稳步地处理这个问题，而不会危及你的帐户的安全。</p><p id="c37e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们看看在这篇文章中我们实现了多少目标:</p><p id="56dc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">模型是<strong class="jf hj">快速</strong>，它绝对是<strong class="jf hj">简单</strong>，最重要的是<strong class="jf hj">易于解释</strong>，如决策树图所示。用户的隐私仍然完好无损，因为所使用的数据在开始时已经降低了维度。嗯，我们仍然没有设法处理数据的不平衡，但我认为我们没有它也做得很好。这实际上是我们所有人的一个重要里程碑。还有很长的路要走，但这对我来说是一个好的开始。希望你喜欢读这篇文章，就像我喜欢写它一样。老实说，一开始我对此有点怀疑，特别是当隔离森林没有产生好的结果时，但现在看到了随机森林的结果，在完成这种结果后，我感到非常满意。</p><p id="692b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该领域需要更多的研究，这是特异性增加0.1%将节省数百万美元(如果不是数十亿美元)的主题之一。</p><p id="0e76" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你对这个话题有任何困难或疑问，欢迎在下面评论。非常感谢你的支持，这将激励我为你写更多这样有用的文章。</p><p id="9b38" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下一篇文章再见。在那之前，继续编码👩‍💻！！</p></div></div>    
</body>
</html>