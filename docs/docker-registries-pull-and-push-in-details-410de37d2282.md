# Docker 注册表:详细的拉和推

> 原文：<https://medium.com/analytics-vidhya/docker-registries-pull-and-push-in-details-410de37d2282?source=collection_archive---------20----------------------->

Docker 图像是负责 Docker 容器创建的主要元素。基本上，它们是用于创建应用程序的只读模板，其中有代码和支持文件，用于设置运行应用程序的指令。

在内部，Docker 映像是一堆相互堆叠的代码层，在实例化时被视为一个单一的平面映像。

没有 Docker 图像，实际上什么也做不了。

在这里，我将尝试从 Docker Registry 的角度总结一些 Docker 映像的基本动作(命令)。这一课程的整体思想并不是相同的实践课程，而是理解当我们与 Docker 图像交互时，在引擎盖下发生了什么。

说了这么多，让我们转到 Docker registry 可以为您做的最基本的命令，即`pull`和`push`命令。

我们开始吧。

# Docker 图像到底住在哪里？

当我们`pull`一个图像时，我们从注册表(通常是 **Docker Hub** ，一个目录 **Docker 图像**的公共存储库)下载它，但是还有更多众所周知的替代方案，如 VMWare 的 VSphere 或 Google Cloud 的 Container-Registry。

Docker 还有 **DTR (Docker 可信注册中心)**，这个是企业版的私有服务。DTR 提供了与安全性和版本管理相关的多个附加功能。是正规 Docker 社区版的 pro 版(你免费安装的那个)。

在动手之前，应该说 docker 可以处理官方和非官方(第三方)图像。当 Docker 下载图像时，对于 Linux 操作系统，它被存储在`/var/lib/docker/<your-storage-driver>`目录中，对于基于 Windows 的操作系统，它被存储在`C:\ProgramData\docker\windowsfiler`目录中。

以下是一些复习技巧:

1.  用`docker image ls`我们可以看到我们下载的图像。
2.  Docker 图像是只读模板。在创建容器的时候，在只读图像之上创建了一个可写层，因此我们可以毫无问题地向它写入更新。
3.  每个容器(图像-容器)都有一个 1:M 关系

## 拉动图像

提取图像非常容易，提取是从 Docker 注册表下载图像的过程。这里有一个例子:`docker pull redis:latest`

在这个例子中，我们用`pull`命令设置我们想要的`redis`图像带有一个名为`latest`的特定标签。

在内部，每个安装步骤都是一个层，这会产生一个 BLOB 文件。在封面下，清单文件描述了图像，还包括层列表及其堆叠方式，这是因为层之间没有任何引用，但 united 创建了工作特征。

`pull`做了很多事情，首先，执行对 Docker Hub 的 API 请求，这返回包含关于支持的架构列表的所有信息的清单文件，评估您请求的机器架构规格，然后获取映像清单，然后，传递并下载一个层列表。

这可能会非常令人困惑，但实际上这对最终用户来说是非常清楚的，API 会使用名为“FAT manifest”的第一个清单文件，该文件通过列出和评估您的系统架构来执行选择，然后根据您的系统规格抓取包含工作层的清单文件。

这太棒了。

我们可以更深入，很容易。

每一层都有一堆代码文件和东西在里面，你可以通过比较哈希码来验证你下载的图片是否合法和有效。一个来自清单文件，另一个来自下载映像的哈希代码。

层组合从一个基础文件(操作系统文件和对象)开始，该映像将使用任何主机内核，然后，在许多自定义层(应用程序代码、更新等)之上，然后，在构建之后，“层”结构将“消失”，成为看起来像是单一统一的文件系统。

在幕后，有一个存储驱动程序将整个分层系统整合在一起(我在另一篇文章中谈到了这一点，请点击这里查看)。

您可以像这样检查文件系统上表示的每个层:`ls -l /var/lib/docker/aufs/diff`这显示了层的列表。在它们里面是将构成目录的一部分的文件。

在他们的官方文件中有更多的信息，非常有趣。

以下是一些用于检查和获取图像详细信息的有用命令

`docker history redis`这显示了构建`redis`映像的步骤，比如时间、映像 ID 和大小。

`docker inspect redis`这个显示了图像的完整配置设置。

太棒了，拉够了，让我们移到推的一边

## 推送图像

我们已经有了包含数据的独立层，如何将它存储到我们的注册表中？我们知道我们有 docker push 命令。但我的目标是谈论内部发生的事情。

那么，这是怎么做到的？

当我们推送时，会创建一个定义层信息的清单文件，清单和容器的层实际上是独立推送和压缩的。

这是这个过程中最重要的部分。当进行分发哈希的压缩过程时，图层哈希会发生变化，分发哈希基本上是映射压缩图层，而不是原始图层。

为区分工作容器的每个可用版本设置一个标签是一个很好的做法。

这个过程非常简单，因为码头工人登记处会处理之后的所有事情。

如果你花一分钟时间，你会发现在几秒钟内有很多事情发生。这一切都是由 Docker 自己处理的，但是如果你认为 Docker 像我一样是一个迷人的工具，那么，这可能是一个很好的阅读材料，可以了解事情是如何在内部运作的。

请随意分享，如果您发现问题，请纠正。这是根据我的经验写的。

快乐编码:)